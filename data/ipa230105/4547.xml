<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004548A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004548</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17362743</doc-number><date>20210629</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>23</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>25</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>242</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>2365</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>254</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>2448</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">REGISTERING ADDITIONAL TYPE SYSTEMS USING A HUB DATA MODEL FOR DATA PROCESSING</invention-title><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Amazon Technologies, Inc.</orgname><address><city>Seattle</city><state>WA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Papakonstantinou</last-name><first-name>Yannis</first-name><address><city>La Jolla</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Certain</last-name><first-name>Tate Andrew</first-name><address><city>Seattle</city><state>WA</state><country>US</country></address></addressbook></inventor></inventors></us-parties><assignees><assignee><addressbook><orgname>Amazon Technologies, Inc.</orgname><role>02</role><address><city>Seattle</city><state>WA</state><country>US</country></address></addressbook></assignee></assignees></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A new type system may be added to a type registry for a data processing service. A request to add the new type system may be received that describes the new type system for a data store. The new type system may be used to perform a data processing job that accesses the data store to obtain or store data as a source or target data store.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="108.37mm" wi="158.75mm" file="US20230004548A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="230.21mm" wi="161.21mm" orientation="landscape" file="US20230004548A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="226.23mm" wi="162.48mm" file="US20230004548A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="244.60mm" wi="150.28mm" file="US20230004548A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="202.61mm" wi="161.63mm" orientation="landscape" file="US20230004548A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="229.02mm" wi="98.13mm" file="US20230004548A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="215.56mm" wi="108.20mm" orientation="landscape" file="US20230004548A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="149.10mm" wi="159.51mm" file="US20230004548A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="176.95mm" wi="121.67mm" file="US20230004548A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="187.28mm" wi="161.80mm" file="US20230004548A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="187.62mm" wi="140.80mm" file="US20230004548A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="176.70mm" wi="159.51mm" file="US20230004548A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">BACKGROUND</heading><p id="p-0002" num="0001">As the technological capacity for organizations to create, track, and retain information continues to grow, a variety of different technologies for managing and storing the rising tide of information have been developed. Database systems, for example, provide clients with many different specialized or customized configurations of hardware and software to manage stored information. However, the increasing amounts of data that organizations must store and manage often correspondingly increases both the number, size and complexity of data storage and management technologies that are used to perform various operations and services, such as utilizing the features of database systems, object stores, and data streams, which in turn escalate the cost of maintaining the information. Moreover, as different data storage technologies offer different performance benefits and features, tailoring the location of data to a data storage technology that provides performance and analysis benefits for that data may result in different data sets being spread across many different locations and types of storage systems. While utilizing such a deployment strategy for individual data sets offers some benefit to the individual data sets, some systems or applications may need access to multiple different data sets in order to operate, which can be challenging given the various interfaces, languages, and other technological hurdles that occur when accessing multiple data storage systems. Thus, techniques that can obtain and co-locate data from disparate data storage systems for systems or applications that use data from the disparate storage systems, without removing the data from their optimized source storage locations, may be highly desirable.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0002" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0003" num="0002"><figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates a logical block diagram illustrating registering additional type systems using a hub data model for data processing, according to some embodiments.</p><p id="p-0004" num="0003"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a logical block diagram illustrating a provider network offering a materialized view management service other services, including various data storage and processing services, that generates views according to received view definitions using a hub data model with registered type systems, according to some embodiments.</p><p id="p-0005" num="0004"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a logical block diagram illustrating a materialized view management service that implements managed materialized views created from data sources using a type registry, according to some embodiments.</p><p id="p-0006" num="0005"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a sequence diagram illustrating interactions for creation and maintenance phases for a materialized view managed by a materialized view management service, according to some embodiments.</p><p id="p-0007" num="0006"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is logical block diagram illustrating interactions supported by an example interface for a materialized view management service, according to some embodiments.</p><p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a logical block diagram illustrating a materialized view incremental maintenance engine that implements a violation handler for managed materialized views, according to some embodiments.</p><p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is an example user interface for viewing data schemas with a type lens, according to some embodiments.</p><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a high-level flowchart illustrating various methods and techniques to implement registering additional type systems using a hub data model for data processing, according to some embodiments.</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a high-level flowchart illustrating various methods and techniques to inspect type of a data schema according to a specified type lens, according to some embodiments.</p><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a high-level flowchart illustrating various methods and techniques to implement a violation handler for a managed view, according to some embodiments</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. <b>11</b></figref> illustrates an example system configured to implement the various methods, techniques, and systems described herein, according to some embodiments.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><p id="p-0014" num="0013">While embodiments are described herein by way of example for several embodiments and illustrative drawings, those skilled in the art will recognize that embodiments are not limited to the embodiments or drawings described. It should be understood, that the drawings and detailed description thereto are not intended to limit embodiments to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope as defined by the appended claims. The headings used herein are for organizational purposes only and are not meant to be used to limit the scope of the description or the claims. As used throughout this application, the word &#x201c;may&#x201d; is used in a permissive sense (i.e., meaning having the potential to), rather than the mandatory sense (i.e., meaning must). Similarly, the words &#x201c;include,&#x201d; &#x201c;including,&#x201d; and &#x201c;includes&#x201d; mean including, but not limited to.</p><p id="p-0015" num="0014">It will also be understood that, although the terms first, second, etc. may be used herein to describe various elements, these elements should not be limited by these terms. These terms are only used to distinguish one element from another. For example, a first contact could be termed a second contact, and, similarly, a second contact could be termed a first contact, without departing from the scope of the present invention. The first contact and the second contact are both contacts, but they are not the same contact.</p><heading id="h-0003" level="1">DETAILED DESCRIPTION OF EMBODIMENTS</heading><p id="p-0016" num="0015">Various techniques of registering additional type systems using a hub data model for data processing are described herein. Different systems, applications, or services store data in multiple purpose-built databases or other data storage or processing technologies to ensure they use the right tool for the job at hand. However, there are many use cases that combine data from multiple such databases, data stores, or other types of data sources. For example, an application implementing an online multi-player game may need to track player profile data, player behavior, and offer in-game promotions. The application might keep player profile data in a low-latency non-relational (e.g., NoSQL) database, game events in an indexing service, player behavior analytics in a data warehouse service, and promotion catalog in a document database. To build a dashboard of top players and their game activities, an Extract Transform and Load (TEL) service could be used to set up pipelines that extract, transform, and combine data from these disparate systems into a single data store, such as a data caching service, in order to host the dashboard and do activities such as in-game promotion targeting. While such an approach may work for batch updates, keeping the dashboard updated in near real-time would have to rely upon writing significant custom code. The costs to create the custom code for complex integration and pre-computation workflows may increase as fast changing underlying data sources would cause further refinements or changes. Use cases and patterns like the example above exist in virtually every industry, decreasing system performance and increasing implementation costs.</p><p id="p-0017" num="0016">In various embodiments, a data processing system, such as a view management system, may simplify operational workloads by making it easy to move data and/or create views (e.g., materialized or federated query results) that integrate data from multiple sources, storing these views in a specified target database, and, in the scenario for materialized views, keeping the views up-to-date in near real-time as the underlying data changes (instead of, for instance, relying upon making batch-based sets of changes). As discussed in detail below with regard to <figref idref="DRAWINGS">FIGS. <b>2</b>-<b>7</b></figref>, a materialized view management service can offer a serverless experience for client applications while also offering for high performance. For example, in various embodiments, the materialized view management service can scale automatically to ingest large volumes of source data changes and to perform computations to construct the views. Because the materialized view management service may be serverless, in some embodiments, a client application (or developers for the client application) will not have to setup infrastructure, provision capacity or configure read and write limits. The materialized view management service may instead receive a materialized view definition that specifies data sources, the integration of data from the different data sources and a target (or multiple targets) to store the materialized views. Other view management systems may be implemented, in some embodiments, that support federated querying across multiple data stores to a target data store with maintaining the view in materialized fashion (e.g., continuing to update the view).</p><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates a logical block diagram illustrating registering additional type systems using a hub data model for data processing, according to some embodiments. Data processing system <b>110</b>, may be a view management system, such as materialized view manage service <b>210</b> as discussed below with regard to <figref idref="DRAWINGS">FIGS. <b>2</b>-<b>7</b></figref> implemented as part of a provider network or implemented as part of a private or on-premise network, or, in some embodiments, a view management system that can generate and store a federated a view in a specified location (e.g., for further analysis) without performing further updates, or other data processing system that moves data from source data stores to target data stores (e.g., Extract Transform Load (ETL) systems, data stream processing systems, etc.). Data processing system <b>110</b> may store data, such as data <b>136</b> (e.g., creating views, moving and transforming data, storing or reformatting data streams, and so on) from different numbers and types of source data sources <b>120</b> and store the resultant data <b>136</b> in one (or more) target data store(s) <b>130</b>.</p><p id="p-0019" num="0018">The data <b>136</b> can be accessed using the target data store, such as target data store <b>130</b> via access requests <b>170</b> (e.g., queries, data pull requests, downloads, etc.). In this way, a desired type or style of data store, for example, for integrating the stored data can be specified. The interface supported by target data store <b>130</b> may be used to access the stored data <b>136</b>, in various embodiments. For example, a SQL query may be made to access data stored as a view if target data store <b>130</b> is a relational database that supports SQL. If, however, target data store <b>132</b> were stored in a non-relational database, then a request according to the programming language or interface of the non-relational database may be used to access the stored data instead. In this way, data can be deployed to targets that support the desired features for analyzing and accessing the data, in some embodiments.</p><p id="p-0020" num="0019">Determining what data to move can be specified in various ways. A data processing job <b>102</b>, for instance, can specify the source data store, target data store, and various other data processing operations that may be performed. Consider an example where the data processing job <b>102</b> is to create a materialized view. The materialized view may be specified according to a view definition that may be provided to data processing system <b>110</b>, in various embodiments. For example, in some embodiments, a user interface or other type of interface (e.g. an Application Programming Interface (API)) can be used to specify the data processing job, including the desired results (e.g., scan, get, join, aggregate, etc.), sources (e.g., by selecting data sources <b>120</b> from a list of offered sources), and targets (e.g., by selecting target(s) <b>130</b> from a list of offered targets). In some embodiments, target data store <b>130</b> can be one of the data sources <b>120</b> (e.g., with the view stored in a different location, such as a different table in a same database).</p><p id="p-0021" num="0020">In at least some embodiments, data processing job <b>102</b> can be specified in a query language (e.g., PartiQL or other structured query language (SQL)-like language). In this way, the view definition <b>102</b> can take advantage of a hub data model <b>114</b> supported by view management system <b>110</b>. Hub data model <b>114</b> may be an extensible data model, in various embodiments (e.g., Ion Schema Language (ISL)) which may allow for the data models of source data store(s) <b>120</b> and target data store(s) <b>130</b> (e.g., data model <b>122</b> and data model <b>132</b> respectively) to be described (e.g., as type systems using a schema language). In this way, the respective types <b>124</b> and <b>134</b> natively supported in each target data store can be enforced via the respective descriptions of the different type systems <b>118</b> corresponding to different source data stores <b>120</b> and target data stores <b>130</b> using types of hub data model <b>114</b>. For example, data processing job <b>102</b> may describe stored data <b>136</b> by including one or more mapping functions to convert a type of data <b>126</b> (e.g., a string value) into a character data type <b>134</b> of data model <b>132</b>. Instead of imposing a translation burden on source data store(s) <b>120</b> or a user that submits data processing job <b>102</b> to translate from data model <b>122</b> to data model <b>132</b>, the data changes <b>150</b> may be provided in a format according to hub data model <b>114</b>, which in turn may allow data processing engine <b>112</b> to convert them according in a manner specified in data processing job <b>102</b> (e.g., allowing a user flexibility to identify how data <b>126</b> should be translated to data model <b>132</b> without having to specify how to translate from data model <b>122</b>).</p><p id="p-0022" num="0021">In various embodiments, data processing system <b>110</b> may implement type registry <b>116</b> to support different type systems based on hub data model <b>114</b>. For example, hub data model <b>114</b> may include various primitive types <b>115</b> (e.g., STRING, INTEGER, DECIMAL, etc.). Primitive types <b>115</b> may be broad and logically unconstrained (e.g. a STRING is a string of arbitrary length). Hub data model <b>114</b> may also support an extensible list of additional types (e.g., &#x201c;rdb_A_STRING&#x201d;, &#x201c;dw_B_INT,&#x201d; and so on), that have been registered in type registry <b>114</b> as part of a new type system <b>118</b>. For example, a request to add a new type system <b>180</b> may include a type system description (e.g., definition file), which may be written or specified in various schema or other language specifications. The request may cause a type system to be added to existing type systems, such as type systems <b>118</b><i>a</i>, <b>118</b><i>b</i>, <b>118</b><i>c </i>through <b>118</b><i>n </i>that are already present for various source data store(s) <b>120</b> and/or target data store(s) <b>130</b>.</p><p id="p-0023" num="0022">An example type system definition may be given below:</p><p id="p-0024" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="203pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>// Type System for the &#x201c;NoSQLdb&#x201d; service are prefixed with</entry></row><row><entry/><entry>&#x201c;nsdb_&#x201d;</entry></row><row><entry/><entry>// annotations are used for descriptive purposes, but are</entry></row><row><entry/><entry>not required</entry></row><row><entry/><entry>&#x2002;(define_typesystem service::&#x201c;nsdb&#x201d; prefix::&#x201c;nsdb&#x201d;</entry></row><row><entry/><entry>&#x2003;// The root is like the entry point for the type</entry></row><row><entry/><entry>definitions of the service</entry></row><row><entry/><entry>&#x2003;// It is not named explicitly, but you can think of it</entry></row><row><entry/><entry>like the notion of table.</entry></row><row><entry/><entry>&#x2003;//</entry></row><row><entry/><entry>&#x2003;// For most systems this is a bag (table) of struct</entry></row><row><entry/><entry>&#x2002;(tuples),</entry></row><row><entry/><entry>&#x2003;// but could be anything else...</entry></row><row><entry/><entry>&#x2003;(root</entry></row><row><entry/><entry>&#x2003;&#x2003;{</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;type: bag,</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;element: {</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;// Since the struct is not constrained with</entry></row><row><entry/><entry>content:closed,</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;// its content is open.</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;type: struct,</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;// Constraint on the serialized size of the</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;// struct.</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;// See notes below on soundness and tightness of</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;// the type system definitions.</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;encoded_byte_length: range::[1, 1MB],</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;// Constraint on the length of top level attribute</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;//names in NoSQLDB.</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;// Other systems may have regex constraints around</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;// what is allowed here.</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;// and constraint on name collisions,</entry></row><row><entry/><entry>attribute_name: {</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;utf8_byte_length: range::[1,65535]</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;}</entry></row><row><entry/><entry>&#x2003;&#x2003;}</entry></row><row><entry/><entry>&#x2003;)</entry></row><row><entry/><entry>&#x2003;// definitions of named types</entry></row><row><entry/><entry>&#x2003;(type s2048 ( ) {type: string, bytelength: range::[1,</entry></row><row><entry/><entry>2047]})</entry></row><row><entry/><entry>&#x2003;(type s ( ) {type: string, bytelength: range::[1, 65535]})</entry></row><row><entry/><entry>&#x2003;(type n ( ) // ...</entry></row><row><entry/><entry>&#x2003;(type</entry></row><row><entry/><entry>&#x2003;//...</entry></row><row><entry/><entry>)</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0025" num="0023">In various embodiments, the type system <b>118</b> may be for data stores that are suppliers (sources) and/or appliers (targets). In some embodiments, an applier type system may include extensions that describe the kind of views that are compatible with the target data store. Type system definitions for applier type systems may be more detailed, in some embodiments, because appliers are the most demanding on type system definitions. The supplier type systems may not need all of the features that are described for applier type systems (although such features could still be included).</p><p id="p-0026" num="0024">An applier type system description may, in some embodiments, capture the following aspects: Do the compatible views have an open schema or a closed schema? What are the types that may appear in the compatible view and what constraints must they satisfy? Does an applier type system definition capture precisely all limitations of the target? Would a compatibility check be sound and tight? &#x201c;Sound&#x201d; may occur if the compatibility check says that a view schema is compatible to the target, then this view schema is indeed compatible to the target, and where &#x201c;compatible to the target&#x201d; may be that all data that may be described by this schema will be accepted and losslessly represented at the target. Compatibility soundness may be indicated if a compatibility check produces no false positives. &#x201c;Tight&#x201d; may occur if there is no view schema that is actually compatible to the target but the compatibility check fails to recognize that it is indeed compatible and calls it non-compatible. Thus compatibility tightness may occur when the compatibility check produces no false negatives.</p><p id="p-0027" num="0025">The above notions of sound and tight useful in describing the applier type system definitions. A sound compatibility may require a sound applier type system definition. Users that specify applier type systems may strive to produce sound and tight applier type system definitions. The compatibility check may strive to infer compatibility correctly based on the applier type system definitions. In some scenarios, however, there may be constraints that will not be expressible in the applier type system definition. For example, consider the constraint &#x201c;the compressed size of the tuples of this schema is compatible with data warehouse's 1 MB record size limit&#x201d;.</p><p id="p-0028" num="0026">An example of an applier type system may be described as follows:</p><p id="p-0029" num="0000"><tables id="TABLE-US-00002" num="00002"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="203pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>// &#x201c;nosql_&#x201d; means that the types understood by the nosqldb</entry></row><row><entry/><entry>applier start with nosql<sub>&#x2014;</sub></entry></row><row><entry/><entry>&#x2002;(define_typesystem &#x201c;nosqldb&#x201d; &#x201c;nosql_&#x201d; applier</entry></row><row><entry/><entry>&#x2003;// the root defines the type of the view itself (is it</entry></row><row><entry/><entry>&#x2003;// open schema? closed schema?)</entry></row><row><entry/><entry>&#x2003;&#x2009;(root ( )</entry></row><row><entry/><entry>&#x2003;&#x2003;{type: bag,</entry></row><row><entry/><entry>&#x2003;&#x2003;element:</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;{// since the struct is not constrained with</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;// content:closed, its content is open</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;type: struct,</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;// constraint on the total size of the struct;</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;// see notes above on soundness and tightness of</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;// the type system definitions</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;bytelength: range::[1, 1MB],</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;// constraint on the length of top level attribute</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;// names in NoSQL DB</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;// regex constraints on attribute names</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;// and constraints on name collisions</entry></row><row><entry/><entry>attribute_name: {type: string, bytelength:</entry></row><row><entry/><entry>range::[1,65535]}</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;}</entry></row><row><entry/><entry>&#x2003;)</entry></row><row><entry/><entry>&#x2003;// definitions of types</entry></row><row><entry/><entry>&#x2003;&#x2002;(type nosql_s2048 ( ) {type: string, bytelength: range::[1,</entry></row><row><entry/><entry>2047]})</entry></row><row><entry/><entry>&#x2003;&#x2002;(type nosql_s ( ) {type: string, bytelength: range::[1,</entry></row><row><entry/><entry>65535]})</entry></row><row><entry/><entry>&#x2003;&#x2002;(type nosql_n ( ) // ...</entry></row><row><entry/><entry>&#x2003;&#x2002;(type nosql<sub>&#x2014;</sub></entry></row><row><entry/><entry>&#x2003;&#x2002;//...</entry></row><row><entry/><entry>)</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0030" num="0027">In some embodiments, the type system may be a supplier type system. A supplier type system may be expected to, at least, provide the definitions of the types understood by the supplier. For example, the NoSQL DB supplier type system will declare that all its types come with the prefix nosql_ and a type is the nosql_s, another type is the nosql_n, etc. The supplier will later use these types to declare the type of a NoSQL DB table and will also use them as dynamic type annotations when it sends data. An example may be described below:</p><p id="p-0031" num="0000"><tables id="TABLE-US-00003" num="00003"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="21pt" align="left"/><colspec colname="1" colwidth="196pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2002;(define_typesystem &#x201c;nosql&#x201d; &#x201c;nosql_&#x201d; supplier</entry></row><row><entry/><entry>&#x2003;(type nosql_s ( ) {type: string, bytelength: range::[1,</entry></row><row><entry/><entry>65535]})</entry></row><row><entry/><entry>&#x2003;(type nosql_n ( ) // ...</entry></row><row><entry/><entry>&#x2003;//...</entry></row><row><entry/><entry>)</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0032" num="0028">An additional consideration for supplier type systems may be to define if any of the following functionalities are provided by data processing system. These functionalities may include: being able to check the compatibility of attribute names that are unknown at compatibility check time against the limitations that an applier type system may have on attribute names; preparation for materialization of a table that has open schema (e.g., prepare a NoSQL DB table for materialization to Document DB); are the attribute names used at the top-level documents of NoSQL DB compatible with the attribute names used in the top-level of Document DB; are the attribute names used in the nested tuples (e.g., objects, documents, or structs) of NoSQL DB compatible with the attribute names used in the nested tuples of Document DB; and preparation for materialization of SELECT * or SELECT VALUE over a table that has open schema (e.g., materialize into an Elasticsearch store for the view). For example, this may be described as:</p><p id="p-0033" num="0000">SELECT * FROM my_nosql_table d WHERE d.foo=3<br/>or the view<br/>SELECT VALUE d FROM my_nosql_table d WHERE d.foo=3</p><p id="p-0034" num="0029">Again, in both of these cases, both the supplier type system and the applier type system may provide the constraints on attribute names because the compatibility check may determine whether the potential attribute names of my_nosql_table are compatible with the Elasticsearch store type system. If they are not compatible, a compatibility checker, as discussed below, may provide mappings to compatible names.</p><p id="p-0035" num="0030">In scenarios, such compatibility issues may be avoided at the top level but occur within nested tuples. For example, consider this view</p><p id="p-0036" num="0000">SELECT d.pk, d.this_may_be_nested_docs FROM my_nosql&#x2014;table d WHERE d.foo=3<br/>and assume it is materialized at Document DB or Elasticsearch store or data warehouse. Are the attribute names of the nested tuples that may appear in the attribute this_may_be-nested_docs compatible with the ones of Document DB_ANY or Elasticsearch store_ANY or data warehouse SUPER? The constraints on the attribute names of the NoSQL DB type system and of the Elasticsearch store/Document DB/data warehouse type system may, in such a scenario, be known in order resolve the compatibility issues.</p><p id="p-0037" num="0031">As noted earlier, applier type system definitions may be more complex because they may also need to declare what is the type of the table that can be materialized in them. In particular, is the acceptable table a bag of open tuples, or it is constrained to be a bag of closed tuples? This information may be used during a compatibility check.</p><p id="p-0038" num="0032">Consider the following. What are the constraints on attribute names used on top level tuples? For example, a data warehouse may not accept that a tuple has two attributes whose names become identical once all capitals are turned into smalls. In another example, another data store may not accept some characters in attribute names</p><p id="p-0039" num="0000"><tables id="TABLE-US-00004" num="00004"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="21pt" align="left"/><colspec colname="1" colwidth="196pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2002;(define_typesystem &#x201c;nosql&#x201d; &#x201c;nosql_&#x201d; supplier</entry></row><row><entry/><entry>&#x2003;// type alias -- no parameterization</entry></row><row><entry/><entry>&#x2003;(type uint2 ( ) {type: int, valid_values: range::[0,</entry></row><row><entry/><entry>65535]})</entry></row><row><entry/><entry>&#x2003;// type function</entry></row><row><entry/><entry>&#x2003;(type varchar ((N {type: int, valid_values: range::[0,</entry></row><row><entry/><entry>65535]}))</entry></row><row><entry/><entry>&#x2003;&#x2003;{type: int, utf8_byte_length: range::[0, (param N)]})</entry></row><row><entry/><entry>&#x2003;//...</entry></row><row><entry/><entry>)</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0040" num="0033">In both of these cases, both the supplier type system and the applier type system may the constraints on attribute names because the compatibility check may determine whether the potential attribute names of my_nosql_table are compatible with the Elasticsearch store type system. If they are not compatible, then the compatibility checker may provide mappings to compatible names.</p><p id="p-0041" num="0034">Nested tuples may also create scenarios for handling compatible name issues. For example, consider this view</p><p id="p-0042" num="0000">SELECT d.pk, d.this_may_be_nested_docs FROM my_nosql&#x2014;table d WHERE d.foo=3<br/>and assume it is materialized at Document DB or Elasticsearch store or data warehouse. Are the attribute names of the nested tuples that may appear in the attribute this_may_be-nested_docs compatible with the ones of Document DB_ANY or Elasticsearch store_ANY or data warehouse_SUPER? Constraints on the attribute names of the NoSQL DB type system and of the Elasticsearch store/Document DB/data warehouse type system may be need to be known in order to perform a compatibility check.</p><p id="p-0043" num="0035">Applier type system definitions may be more complex because they may also need to declare what is the type of the table that can be materialized in them. For instance, is the acceptable table a bag of open tuples or it is constrained to be a bag of closed tuples? This information may be used during compatibility check. What are the constraints on the attribute names used on top level tuples? For example, a data warehouse does not accept that a tuple has two attributes whose names become identical once you turn all capitals into smalls. managed query service does not seem to accept some characters in attribute names.</p><p id="p-0044" num="0000"><tables id="TABLE-US-00005" num="00005"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="21pt" align="left"/><colspec colname="1" colwidth="196pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2002;(define_typesystem &#x201c;nosql&#x201d; &#x201c;nosql_&#x201d; supplier</entry></row><row><entry/><entry>&#x2003;// type alias -- no parameterization</entry></row><row><entry/><entry>&#x2003;(type uint2</entry></row><row><entry/><entry>&#x2002;( ) {type: int, valid_values: range::[0, 65535]})</entry></row><row><entry/><entry>&#x2003;// type function</entry></row><row><entry/><entry>&#x2003;(type varchar ((N {type: int, valid_values: range::[0,</entry></row><row><entry/><entry>65535]}))</entry></row><row><entry/><entry>&#x2003;&#x2003;{type: int, utf8_byte_length: range::[0, (param N)]})</entry></row><row><entry/><entry>&#x2003;&#x2003;//...</entry></row><row><entry/><entry>)</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0045" num="0036">The type system registry may implement type definitions</p><p id="p-0046" num="0000">--type definition<br/>[&#x3c;type name/type function name&#x3e;, &#x3c;type definition&#x3e;]</p><p id="p-0047" num="0037">Furthermore, the type registry may have type list registrations of the form</p><p id="p-0048" num="0000">[&#x3c;service name&#x3e;, supplier|applier, [list of type names] ]</p><p id="p-0049" num="0038">In some embodiments, all the types of service xyz are named xyz_NativeType. The NativeType may be the name of a type at the source and/or target. For example, nosql_s may be the nosql string because s is what NoSQL DB natively uses for string. Sometimes, the type registry may have type names that do not correspond 1:1 to the native types of the service.</p><p id="p-0050" num="0039">In some embodiments, type registry <b>116</b> may implement an access control component so that a random user cannot delete or modify the types or type lists that the supplier/applier builders have built for their services.</p><p id="p-0051" num="0040">In various embodiments, hub data model <b>114</b> may include primitive types <b>115</b> (e.g., string, decimal, array, integer, float, date-time, etc.) which may be practically unconstrained. For example, the data sizes of such primitive types <b>115</b> may be constrained only by processing limitations posed by data processing system <b>110</b> which may be less than the limitations imposed by source data stores <b>120</b> and target data stores <b>130</b>. In some embodiments, added types <b>117</b> may be defined as structural types that are combinations of a primitive type (e.g., string, decimal) and constraints (e.g., (string) codepoint length, (string) byte length, scale, precision, value range, etc.). The schema language for hub data model <b>114</b> may be used to describe a structural type. A structural type may not have a name, some embodiments. For instance, the following may be a structural type for data warehouse's VARCHAR(10). Notice, the following description does not call out the name VARCHAR(10). Rather it defines what is known at data warehouse as VARCHAR(10).</p><p id="p-0052" num="0000"><tables id="TABLE-US-00006" num="00006"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="49pt" align="left"/><colspec colname="1" colwidth="168pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>type::{</entry></row><row><entry/><entry>&#x2003;type: string,</entry></row><row><entry/><entry>&#x2003;utf8_byte_length: range::[0, 10],</entry></row><row><entry/><entry>}</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0053" num="0041">Nominal types (also referred to as logical types) may be another type of hub data model <b>114</b> which may associate a name with a structural type. When adding a new type system 180, as applier and/or supplier, a list of nominal types for the new types system may be provided. The name may be unique within the type registry, in some embodiments. Assuming that new data store &#x201c;S&#x201d; has a type &#x201c;T&#x201d;, the name may be of the form S_T (e.g., datawarehouse_varchar( ). Nominal types may give the ability to different users to inspect table and view types using their preferred type nomenclature. See below the default use of this feature by the console.</p><p id="p-0054" num="0000">typeDefNominal(&#x3c;unique name&#x3e;, &#x3c;structural type<br/>in ISL&#x3e;, &#x3c;type list&#x3e;)<br/>-&#x3e;creates new type in registry</p><p id="p-0055" num="0042">The type system may be an optional tag. For example, a type system could be &#x201c;data warehouse&#x201d;, thus making it easy to later find all data warehouse types.</p><p id="p-0056" num="0043">Nominal parameterized type functions may be useful when specifying applier type systems in describing types like VARCHAR(.) and DECIMAL(.,.). For example, they are useful in declaring that data warehouse has a type datawarehouse_varchar(X), which has base type string and the parameter X is a byte length constraint with valid range 1 to 64K. They are also useful in describing types that are parameterized by other types, such as foo_list&#x3c;STRING&#x3e;. In some embodiments, supplier type systems may not emit nominal parameterized type functions, but instead use particular nominal parameterized types (such as mysql_varchar(20)).</p><p id="p-0057" num="0044">An opaque type of hub data model <b>114</b> may also be used, in some embodiments. An opaque type may be used by providing a name and an underlying structural type that has enough &#x201c;capacity&#x201d; to represent the source data. The name may be unique within the type registry and not conflict with a primitive type name. For example, the &#x201c;blob&#x201d; may be an underlying type but the supplier builder may make better choices for underlying type.</p><p id="p-0058" num="0000">typeDefOpaque(&#x3c;unique name&#x3e;, &#x3c;structural type in ISL&#x3e;)-&#x3e;registers new type</p><p id="p-0059" num="0045">Note that the definition of an opaque type, may appear to be similar to the definition of a nominal type: both use a name and a structural type. However, the opaque type differs from a nominal type in that query language functions and the compatibility function by default may override, and thus ignore, the structural part and treat the type as if it were a primitive.</p><p id="p-0060" num="0046">A user case for opaque types of hub data model <b>14</b> may be that many suppliers will introduce opaque types that the query language query processor may not be able to operate on, e.g., a PartiQL processor will not have functions applicable to them. For example, Postgres GEOMETRY may not be expected to be a type that data processing system PartiQL will support. Thus, Postgres GEOMETRY will be an opaque type. The PartiQL processor may still be able to pass through a GEOMETRY as-is and this ability will be enough if both source and target are if the target applier understands GEOMETRY.</p><p id="p-0061" num="0047">In various embodiments, the end user can inspect the type name of opaque types and cannot apply a query language function on them, other than IS and IS NULL. The end user may be unaware of the underlying type. For example, assume that the GEOMETRY has blob as an underlying type. Then consider an expression &#x201c;e&#x201d; of type GEOMETRY.</p><heading id="h-0004" level="2">e IS GEOMETRY-&#x3e;true</heading><heading id="h-0005" level="2">e IS BLOB-&#x3e;false</heading><p id="p-0062" num="0048">Similarly, data processing system <b>110</b> by default may not map a GEOMETRY into a BLOB just because the underlying type of GEOMETRY is a BLOB.</p><p id="p-0063" num="0049">Some users will want be able to work with an underlying type. A query language may feature the function UNWRAP(x). When x is a value with an opaque type the unwrap returns a value whose type is the underlying structural type. For example, assume that the opaque type POINT has underlying structural type STRUCT&#x3c;x: float, y:float&#x3e;. Then consider a value v with type POINT and x=5.</p><p id="p-0064" num="0000">v.x-&#x3e;MISSING, because the &#x201c;.x&#x201d; attempts to navigate into the opaque POINT<br/>UNWRAP(v).x-&#x3e;5, because the UNWRAP(v) is a struct with x and thus &#x201c;.x&#x201d; makes sense</p><p id="p-0065" num="0050">Some users may also synthesize new opaque values with WRAP(x AS&#x3c;opaque type&#x3e;). This is similar to CAST except that in the case of opaque types, the structure of x may have to match the underlying structural type of the opaque type. So for example CAST({x: 10, y: 20} AS POINT) would return an opaque POINT value. In some embodiments, functions may be implemented to transform one opaque type into another type (e.g., potentially also opaque) by operating directly on the representation of the underlying structural type. For another example, assume that the NoSQL DB set type is an opaque type with the underlying type being list. This allows the use of query language constructs, such as unnesting, that apply to list. At the same time, the data is still a set and will be mapped into a NoSQL DB set, assuming there is a NoSQL DB applier. Furthermore, if one attempts to materialize a list at NoSQL DB there will be no accident where they are mapped into a set just because the underlying type is list. Furthermore, because some query languages may be &#x201c;schema optional,&#x201d; the following distinctions can be made (1) Static Types&#x2014;types that are known at table or view definition time. These types may or may not be represented (reified) at run-time. SQL, for example, may only have static types. A database schema can be considered as a representation of static type instances. (2) Dynamic Types&#x2014;types that are known at run time, these types are late bound and associated with the instances of data themselves. Some query languages, like PartiQL, may be different from SQL in that they have both static and dynamic types. A dynamic type is data that has no schema, where the system has to evaluate when it operates on such data what that data represents when it gets it at runtime. Nominal and opaque dynamic types may be conveyed by Ion annotations, in some embodiments.</p><p id="p-0066" num="0051">Data sources <b>120</b> may be many different types of data storage, processing, and/or management technologies, in some embodiments. For example, data sources <b>120</b> may be various types of databases (including relational databases, non-relational databases, graph databases, document databases, time series databases, data warehouses, or various other types of databases). In another example, data sources <b>120</b> may include various data streaming services or services (e.g., data streams for data feeds, events, or other stream processing techniques). In some embodiments, data sources <b>120</b> may be messaging, notification, or other communication services or services. Various combinations of the different example data sources may be used or combined to create a materialized view (e.g., a materialized view that joins a database table with a data stream). Similarly target data store <b>130</b> can be various types of data storage, processing, and/or management technologies, such as the examples given above.</p><p id="p-0067" num="0052">Once data processing <b>110</b> stores data <b>136</b> in target data store <b>130</b>, data processing system <b>110</b> may also data <b>132</b> (e.g., as materialized view) to provide near real-time updates, in some embodiments. In this way, data <b>136</b> may provide up-to-date changes when queries or analyzed. For example, as different changes <b>140</b> are made to (or by) data sources <b>120</b>, these changes may be obtained <b>150</b> data processing system <b>110</b>. For example, as discussed below with regard to <figref idref="DRAWINGS">FIG. <b>3</b></figref>, techniques for submitting data changes <b>150</b> as delta records in format corresponding to hub data model <b>114</b> may be performed.</p><p id="p-0068" num="0053">Data processing system <b>110</b> may implement data processing engine <b>112</b>, in various embodiments. Data processing engine <b>112</b> may perform various operations to on the captured changes and then reformat, package, encapsulate, or otherwise translate the changes to the data <b>136</b>, and provide view updates <b>160</b> in a format according to hub data model <b>114</b> (e.g., via target connectors <b>360</b>) which may then be translated according to data model <b>132</b> to update data <b>136</b>.</p><p id="p-0069" num="0054">Please note that the previous description of a data processing system is a logical illustration and thus is not to be construed as limiting as to the implementation of data sources, targets, views, or various other features. Different combinations or implementations may be implemented in various embodiments.</p><p id="p-0070" num="0055">This specification begins with a general description of a provider network that implements a materialized view management service. Then various examples of a materialized view management service including different components/modules, or arrangements of components/module that may be employed as part of implementing the materialized view management service are discussed. A number of different methods and techniques to implement registering additional type systems using a hub data model for data processing are then discussed, some of which are illustrated in accompanying flowcharts. Finally, a description of an example computing system upon which the various components, modules, systems, devices, and/or nodes may be implemented is provided. Various examples are provided throughout the specification.</p><p id="p-0071" num="0056"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a logical block diagram illustrating a provider network offering a materialized view management service other services, including various data storage and processing services, that generates views according to received view definitions using a hub data model with registered type systems, according to some embodiments. Provider network <b>200</b> may be a private or closed system or may be set up by an entity such as a company or a public sector organization to provide one or more services (such as various types of cloud-based storage) accessible via the Internet and/or other networks to clients <b>270</b>, in some embodiments. Provider network <b>200</b> may be implemented in a single location or may include numerous data centers hosting various resource pools, such as collections of physical and/or virtualized computer servers, storage devices, networking equipment and the like (e.g., computing system <b>2000</b> described below with regard to <figref idref="DRAWINGS">FIG. <b>11</b></figref>), needed to implement and distribute the infrastructure and services offered by the provider network <b>200</b>. In some embodiments, provider network <b>200</b> may implement various computing systems, services, resources, or services, such as a materialized view management service <b>210</b>, compute services <b>220</b>, database service(s) <b>230</b>, (e.g., relational or non-relational (NoSQL) database query engines, map reduce processing, data flow processing, and/or other large scale data processing techniques), data storage service(s) <b>240</b>, (e.g., an object storage service, block-based storage service, or data storage service that may store different types of data for centralized access), data stream and/or event services <b>250</b>, and other services <b>260</b> (any other type of network based services (which may include various other types of storage, processing, analysis, communication, event handling, visualization, and security services not illustrated).</p><p id="p-0072" num="0057">In various embodiments, the components illustrated in <figref idref="DRAWINGS">FIG. <b>2</b></figref> may be implemented directly within computer hardware, as instructions directly or indirectly executable by computer hardware (e.g., a microprocessor or computer system), or using a combination of these techniques. For example, the components of <figref idref="DRAWINGS">FIG. <b>2</b></figref> may be implemented by a system that includes a number of computing nodes (or simply, nodes), each of which may be similar to the computer system embodiment illustrated in <figref idref="DRAWINGS">FIG. <b>11</b></figref> and described below. In various embodiments, the functionality of a given system or service component (e.g., a component of data storage service <b>230</b>) may be implemented by a particular node or may be distributed across several nodes. In some embodiments, a given node may implement the functionality of more than one service system component (e.g., more than one data store component).</p><p id="p-0073" num="0058">Compute services <b>210</b> may be implemented by provider network <b>200</b>, in some embodiments. Compute services <b>210</b> may offer instances, containers, and/or functions according to various configurations for client(s) <b>270</b> operation. A virtual compute instance may, for example, comprise one or more servers with a specified computational capacity (which may be specified by indicating the type and number of CPUs, the main memory size, and so on) and a specified software stack (e.g., a particular version of an operating system, which may in turn run on top of a hypervisor). A container may provide a virtual operation system or other operating environment for executing or implementing applications. A function may be implemented as one or more operations that are performed upon request or in response to an event, which may be automatically scaled to provide the appropriate number computing resources to perform the operations in accordance with the number requests or events. A number of different types of computing devices may be used singly or in combination to implement the compute instances, containers, and/or functions and of provider network <b>200</b> in different embodiments, including general purpose or special purpose computer servers, storage devices, network devices and the like. In some embodiments instance client(s) <b>270</b> or other any other user may be configured (and/or authorized) to direct network traffic to a compute instance.</p><p id="p-0074" num="0059">Compute instances, containers, and/or functions may operate or implement a variety of different services, such as application server instances, general purpose or special-purpose operating systems, services that support various interpreted or compiled programming languages such as Ruby, Perl, Python, C, C++ and the like, or high-performance computing services) suitable for performing client(s) <b>270</b> applications, without for example requiring the client(s) <b>270</b> to access an instance. Applications (or other software operated/implemented by a compute instance and may be specified by client(s), such as custom and/or off-the-shelf software.</p><p id="p-0075" num="0060">In some embodiments, compute instances, containers, and/or functions have different types or configurations based on expected uptime ratios. The uptime ratio of a particular compute instance may be defined as the ratio of the amount of time the instance is activated, to the total amount of time for which the instance is reserved. Uptime ratios may also be referred to as utilizations in some implementations. If a client expects to use a compute instance for a relatively small fraction of the time for which the instance is reserved (e.g., 30%-35% of a year-long reservation), the client may decide to reserve the instance as a Low Uptime Ratio instance, and pay a discounted hourly usage fee in accordance with the associated pricing policy. If the client expects to have a steady-state workload that requires an instance to be up most of the time, the client may reserve a High Uptime Ratio instance and potentially pay an even lower hourly usage fee, although in some embodiments the hourly fee may be charged for the entire duration of the reservation, regardless of the actual number of hours of use, in accordance with pricing policy. An option for Medium Uptime Ratio instances, with a corresponding pricing policy, may be supported in some embodiments as well, where the upfront costs and the per-hour costs fall between the corresponding High Uptime Ratio and Low Uptime Ratio costs.</p><p id="p-0076" num="0061">Compute instance configurations may also include compute instances, containers, and/or functions with a general or specific purpose, such as computational workloads for compute intensive applications (e.g., high-traffic web applications, ad serving, batch processing, video encoding, distributed analytics, high-energy physics, genome analysis, and computational fluid dynamics), graphics intensive workloads (e.g., game streaming, 3D application streaming, server-side graphics workloads, rendering, financial modeling, and engineering design), memory intensive workloads (e.g., high performance databases, distributed memory caches, in-memory analytics, genome assembly and analysis), and storage optimized workloads (e.g., data warehousing and cluster file systems). Size of compute instances, containers, and/or functions, such as a particular number of virtual CPU cores, memory, cache, storage, as well as any other performance characteristic. Configurations of compute instances, containers, and/or functions may also include their location, in a particular data center, availability zone, geographic, location, etc. . . . and (in the case of reserved compute instances, containers, and/or functions) reservation term length.</p><p id="p-0077" num="0062">In various embodiments, database services <b>230</b> may be various types of data processing services that perform general or specialized data processing functions (e.g., analytics, big data querying, time-series data, graph data, document data, relational data, non-relational data, structured data, semi-structured data, unstructured data, or any other type of data processing operation) over data that is stored across multiple storage locations, in some embodiments. For example, in at least some embodiments, database services <b>210</b> may include various types of database services (e.g., relational) for storing, querying, and updating data. Such services may be enterprise-class database systems that are scalable and extensible. Queries may be directed to a database in database service(s) <b>230</b> that is distributed across multiple physical resources, as discussed below, and the database system may be scaled up or down on an as needed basis, in some embodiments. The database system may work effectively with database schemas of various types and/or organizations, in different embodiments. In some embodiments, clients/subscribers may submit queries or other requests (e.g., requests to add data) in a number of ways, e.g., interactively via an SQL interface to the database system or via Application Programming Interfaces (APIs). In other embodiments, external applications and programs may submit queries using Open Database Connectivity (ODBC) and/or Java Database Connectivity (JDBC) driver interfaces to the database system.</p><p id="p-0078" num="0063">In some embodiments, database service(s) <b>230</b> may include services that process requests to data that is not stored in fully structured storage (e.g., non-relational or NoSQL databases). Database services <b>230</b> may access the data that is semi-structured or not-structured in storage, such as data objects of unstructured or semi-structured data in a separate data storage service, in one embodiment. In other embodiments, database services <b>230</b> may locally store, managed, and access semi-structured or not-structured data.</p><p id="p-0079" num="0064">In some embodiments, database services <b>220</b> may be various types of data processing services to perform different functions (e.g., query or other processing engines to perform functions such as anomaly detection, machine learning, data lookup, or any other type of data processing operation). For example, in at least some embodiments, database services <b>230</b> may include a map reduce service that creates clusters of processing nodes that implement map reduce functionality over data stored in one of data storage services <b>240</b>. Various other distributed processing architectures and techniques may be implemented by database services <b>230</b> (e.g., grid computing, sharding, distributed hashing, etc.). Note that in some embodiments, data processing operations may be implemented as part of data storage service(s) <b>230</b> (e.g., query engines processing requests for specified data).</p><p id="p-0080" num="0065">Data storage service(s) <b>240</b> may implement different types of data stores for storing, accessing, and managing data on behalf of clients <b>270</b> as a network-based service that enables clients <b>270</b> to operate a data storage system in a cloud or network computing environment. For example, one data storage service <b>230</b> may be implemented as a centralized data store so that other data storage services may access data stored in the centralized data store for processing and or storing within the other data storage services, in some embodiments. Such a data storage service <b>240</b> may be implemented as an object-based data store, and may provide storage and access to various kinds of object or file data stores for putting, updating, and getting various types, sizes, or collections of data objects or files. Such data storage service(s) <b>230</b> may be accessed via programmatic interfaces (e.g., APIs) or graphical user interfaces. A data storage service <b>240</b> may provide virtual block-based storage for maintaining data as part of data volumes that can be mounted or accessed similar to local block-based storage devices (e.g., hard disk drives, solid state drives, etc.) and may be accessed utilizing block-based data storage protocols or interfaces, such as internet small computer interface (i SCSI).</p><p id="p-0081" num="0066">In various embodiments, data stream and/or event services <b>250</b> may provide resources to ingest, buffer, and process streaming data in real-time. In some embodiments, data stream and/or event services <b>250</b> may act as an event bus or other communications/notifications for event driven systems or services (e.g., events that occur on provider network <b>200</b> services and/or on-premise systems or applications).</p><p id="p-0082" num="0067">Generally speaking, clients <b>270</b> may encompass any type of client configurable to submit network-based requests to provider network <b>200</b> via network <b>280</b>, including requests for materialized view management service <b>210</b> (e.g., a request to create a materialized view from different data sources of the other provider network services and identify one or more as a target data source). For example, a given client <b>270</b> may include a suitable version of a web browser, or may include a plug-in module or other type of code module that may execute as an extension to or within an execution environment provided by a web browser. Alternatively, a client <b>270</b> may encompass an application such as a database application (or user interface thereof), a media application, an office application or any other application that may make use of resources in in provider network <b>200</b> to implement various features, systems, or applications. (e.g., to store and/or access the data to implement various applications. In some embodiments, such an application may include sufficient protocol support (e.g., for a suitable version of Hypertext Transfer Protocol (HTTP)) for generating and processing network-based services requests without necessarily implementing full browser support for all types of network-based data. That is, client <b>270</b> may be an application may interact directly with provider network <b>200</b>. In some embodiments, client <b>270</b> may generate network-based services requests according to a Representational State Transfer (REST)-style network-based services architecture, a document- or message-based network-based services architecture, or another suitable network-based services architecture.</p><p id="p-0083" num="0068">In some embodiments, a client <b>270</b> may provide access to provider network <b>200</b> to other applications in a manner that is transparent to those applications. For example, client <b>270</b> may integrate with an operating system or file system to provide storage on one of data storage service(s) <b>240</b> (e.g., a block-based storage service). However, the operating system or file system may present a different storage interface to applications, such as a conventional file system hierarchy of files, directories and/or folders. In such an embodiment, applications may not need to be modified to make use of the storage system service model. Instead, the details of interfacing to the data storage service(s) <b>240</b> may be coordinated by client <b>270</b> and the operating system or file system on behalf of applications executing within the operating system environment.</p><p id="p-0084" num="0069">Clients <b>270</b> may convey network-based services requests (e.g., materialized view creation requests) to and receive responses from provider network <b>200</b> via network <b>280</b>. In various embodiments, network <b>280</b> may encompass any suitable combination of networking hardware and protocols necessary to establish network-based-based communications between clients <b>270</b> and provider network <b>200</b>. For example, network <b>280</b> may generally encompass the various telecommunications networks and service providers that collectively implement the Internet. Network <b>280</b> may also include private networks such as local area networks (LANs) or wide area networks (WANs) as well as public or private wireless networks. For example, both a given client <b>270</b> and provider network <b>200</b> may be respectively provisioned within enterprises having their own internal networks. In such an embodiment, network <b>280</b> may include the hardware (e.g., modems, routers, switches, load balancers, proxy servers, etc.) and software (e.g., protocol stacks, accounting software, firewall/security software, etc.) necessary to establish a networking link between given client <b>270</b> and the Internet as well as between the Internet and provider network <b>200</b>. It is noted that in some embodiments, clients <b>270</b> may communicate with provider network <b>200</b> using a private network rather than the public Internet.</p><p id="p-0085" num="0070"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a logical block diagram illustrating a materialized view management service that implements managed materialized views created from heterogeneous data sources, according to some embodiments. Client(s) <b>302</b> (which may be similar to client(s) <b>270</b> in <figref idref="DRAWINGS">FIG. <b>2</b></figref> above or other types of client systems, services or applications). Client(s) <b>302</b> may access materialized view management service <b>210</b> via interface <b>310</b>. Interface <b>310</b> may be a graphical user interface (e.g., implemented as a console or other graphical control view a website). Interface <b>310</b> may be implemented as a command line interface, in some embodiments. Interface <b>310</b> maybe implemented as one or multiple programmatic interfaces, (e.g., one or more APIs). As discussed with regard to <figref idref="DRAWINGS">FIGS. <b>4</b>-<b>7</b></figref>, various types of requests may be received and/or responses sent via interface <b>310</b>.</p><p id="p-0086" num="0071">Materialized view management service <b>210</b> may implement control plane <b>320</b>. Control plane <b>320</b> may implement various features for managing the resources and operations for creating and maintaining materialized views. For example, control plane <b>320</b> may implement various access control mechanisms or authentication techniques to ensure that requests to create materialized views are made with appropriate authorization (e.g., to create or delete a materialized view). Control plane <b>320</b> may implement various health or other system monitoring features to ensure that various features or components of materialized view management service are functioning correctly, repaired, or replaced. For example, control plane <b>320</b> may monitor a number nodes or instances used to implement view creation <b>340</b> and materialized view incremental maintenance engine(s), such as may be collected in pools or groups of instances, and replace, increase, or decrease the number of nodes or instances in order to meet demand or handle failures.</p><p id="p-0087" num="0072">As indicated in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, control plane <b>320</b> may implement view performance monitoring <b>322</b> in order to monitor the performance of creating and maintaining a materialized view, in some embodiments. For example, view performance monitoring <b>322</b> may collect or request performance metrics for change data capture, view computation, and view materialization to send the results to target data stores, and determine whether or not performance criteria for the view has been met. For example, performance criteria may include a lag time or other indicator for the time between when a change occurs at a source and when the change is included in an update made to a target. If the lag time exceeds a threshold amount of time (e.g., 10 minutes), then an adjustment event to reduce the lag time may be triggered. Other performance criteria may include the amount of data that is being received as a change (e.g., how many records, items or objects, or the size of data, such as 5 megabytes). Performance criteria may include criteria specified for the materialized view by a user, owner, developer, or operator via view interface <b>310</b>. In some embodiments, the specified requirements may include limitations or other restrictions on the utilization of some resources (e.g., a limit on the amount of read or write load placed on a data source or target).</p><p id="p-0088" num="0073">Control plane <b>320</b> may implement view performance adjustments to dynamically scale the resources associated with creating and maintaining a materialized view. In this way, a serverless experience can be provided, as the provisioning, management, allocation of resources may be handled by materialized view management service <b>210</b> (instead of by a user that is manually specifying the amount resources to implement for a materialized view. View performance adjustments may determine responsive actions to adjust materialized view creation and performance according to view performance monitoring <b>322</b> (e.g., according to the number and/or type of events detected). For example, view performance adjustments may increase (or decrease) the number of nodes assigned to view maintenance processing in order to keep pace with an increased number of changes received from data sources.</p><p id="p-0089" num="0074">In various embodiments, control plane <b>320</b> may maintain, update, and/or access managed view state. Managed view state may indicate the state of various materialized views as the progress between creation and maintenance phases as well as other state information that informs operations or workflows performed on behalf of a materialized view. For example, managed view state may indicate in state information for a materialized view that the target for that the last maintenance operation to update a materialized view occurred 10 minutes ago and that another check for updates should be performed. Managed view state may identify and/or provide information for various features of materialized view creation <b>340</b> and materialized view maintenance <b>350</b>.</p><p id="p-0090" num="0075">A view compatibility checker <b>326</b> may be implemented to detect incompatibility of a view definition with target data store's type system, in some embodiments. View compatibility checker <b>326</b> could alternatively be implemented as part of materialized view creation <b>340</b> and/or as part of run-time evaluations of materialized view incremental maintenance engine(s) <b>350</b>. Type registry management <b>328</b> may support requests to add or update type systems stored in type registry <b>334</b> as discussed in detail above with regard to <figref idref="DRAWINGS">FIG. <b>1</b></figref> and below with regard to <figref idref="DRAWINGS">FIG. <b>5</b></figref>. Schema viewer <b>329</b> may allow for type inspection according to different types as described below with regard to <figref idref="DRAWINGS">FIGS. <b>7</b> and <b>9</b></figref>.</p><p id="p-0091" num="0076">Materialized view creation <b>340</b> may handle requests to create a materialized view. For example, materialized view creation <b>340</b> may perform initial validation of a view, such as checking the string length and basic structure. In some embodiments, materialized view creation <b>340</b> may generate maintenance or other execution plan to create and update the materialized view. In some embodiments, materialized view creation <b>340</b> may store the maintenance or other execution plan along with other artifacts to facilitate the materialized view in managed view catalog <b>332</b>. In some embodiments, materialized view creation <b>340</b> may assign, provision, or initiate a materialized view incremental maintenance engine <b>350</b> to handle a materialized view (e.g., to obtain changes, generate view updates and store view updates to an out-bound log for the materialized view. Materialized view creation <b>340</b> may provide materialized view incremental maintenance engine(s) <b>350</b> assigned to a materialized view with the appropriate information (e.g., identifier for generated maintenance plan, identities of input and output logs for the data source(s) and target for the materialized view, etc.).</p><p id="p-0092" num="0077">In various embodiments, data store <b>330</b> may be implemented as part of materialized view management service <b>210</b>. For example, materialized view management service <b>332</b> may implement a managed view catalog <b>332</b>. Managed view catalog <b>332</b> may store information related to materialized views, including a name, definition, access controls or configuration, maintenance and/or other historical information to indicate the progress or performance of a materialized view (e.g., last time updated). Managed view catalog <b>332</b> may store various state information or other metadata, such as metadata to describe the mappings between change logs for in-bound changes from source connector(s) <b>360</b> and out-bound changes to target connector(s) <b>370</b>.</p><p id="p-0093" num="0078">Materialized view management service <b>210</b> may support via interface <b>310</b> various APIs or other implement data source connectors <b>360</b>, in various embodiments. Data source connectors <b>360</b> may communicate with and obtain changes from data source(s) <b>304</b>. In some embodiments, a data source connector <b>360</b> may facilitate a change capture protocol or interface for a particular type of data store (e.g., a My SQL connector, a data stream connector, an object store connector) for a corresponding one of data source(s) <b>304</b>. In some embodiments, data source connectors <b>360</b> are implemented as part of a service or storage system implement data source(s) <b>304</b>. As discussed above data source(s) <b>304</b> can be various services (or resources hosted within services) of provider network <b>200</b>.</p><p id="p-0094" num="0079">For example, data source connectors <b>360</b> may enable a changed data capture stream supported by a source database, and register as a recipient, authorized reader, or other component capable of obtaining updates to that source as a change stream. In some embodiments, the data source may be a data stream, and thus the data source connectors <b>360</b> may register or request to be a recipient of the data stream. In some embodiments, change data capture may poll for source changes. For example, data connector(s) <b>360</b> may record or maintain the state of previously received changes from a source (e.g., by timestamp, version identifier, etc.) and use the state to request changes that occurred since the last received state. The changes captured by data source connectors may be sent via interface <b>310</b> to a source-specific change log (e.g., an append-only change log implemented via a log-based database, ledger database, or other log-structured storage) in a format corresponding to the hub data model (e.g., in ION format) via which materialized view incremental creation engines <b>350</b> may read from the logs of corresponding sources contributing to a view.</p><p id="p-0095" num="0080">Source connectors <b>360</b> may report source progress or performance information to control plane <b>320</b>. In this way, control plane <b>320</b> can make performance determinations to adjust the performance of connectors, in some embodiments.</p><p id="p-0096" num="0081">In some embodiments, materialized view increment maintenance engine(s) <b>350</b> may obtain a maintenance plan or other execution plan for updating a created materialized view from data store <b>330</b> (although in other embodiments a maintenance or other execution plan may be generated by materialized view incremental maintenance engine(s) <b>350</b>). A maintenance plan may describe the various operations for combining changes to various updates received from the data sources to provide an updated view without regenerating the entire materialized view (e.g., without re-querying all sources to obtain all of the materialized view information). In some embodiments, view maintenance processing nodes may implement maintenance plan optimization to rewrite or utilize various features, such as intermediate results stored in intermediate tables and/or utilization local computational capabilities and storage, such as maintenance computation data (instead of using source computational storage and/or capabilities). In this way, view maintenance processing nodes can adapt to the capabilities of the data sources (e.g., supported or unsupported processing operations, such as supporting or not supporting joins, aggregations, etc.) or limitations on the data sources (e.g., read or write limitations on the data sources).</p><p id="p-0097" num="0082">Materialized view incremental maintenance engine(s) <b>350</b> may implement maintenance plan execution. In some embodiments, view maintenance plan execution may be a query engine or processor that can perform the maintenance plan to obtain the changed data (as well as other data needed to make the update). If, for instance, a change is to a value that is joined with other data sources, then even if the other data sources are unchanged, the change may still need to be joined with the data from the unchanged sources, so a query may be performed to obtain that unchanged data from the data sources (or in the event it is stored as part of maintenance computation, the local copy can be utilized). Materialized view incremental maintenance engine(s) <b>350</b> may store records (e.g., in hub data model format) to an outbound log of changes specific to the materialized view, in some embodiments.</p><p id="p-0098" num="0083">In some embodiments, materialized view incremental maintenance engine(s) <b>350</b> may rely upon external computation resources (e.g., compute function resource as discussed above with regard to <figref idref="DRAWINGS">FIG. <b>2</b></figref> of compute services <b>220</b>), which may perform an operation or determine a value used as part of updating a materialized view. Similarly, some data or query operations can be performed by data source resources, and thus queries, such as query <b>662</b>, may be performed as part of determining updates to a materialized view.</p><p id="p-0099" num="0084">In some embodiments, materialized view incremental maintenance engine(s) <b>350</b> may report progress and performance information to control plane <b>320</b>. In this way, control plane <b>320</b> can evaluate the performance of operations to determine updates and make adjustments to scale the resources allocated to maintaining the materialized view to satisfy performance criteria.</p><p id="p-0100" num="0085">In various embodiments, materialized view management service <b>210</b> may implement an interface <b>311</b> which may support requests or other interactions with target connector(s) <b>370</b>. Target connector(s) <b>370</b> may connect to and interact with a target for a materialized view. Similar to a data source connector <b>360</b>, a target connector <b>370</b> can be respectively implemented for different types of targets (e.g., a target connector for a data warehouse or a target connector for a NoSQL database). As discussed above materialized view target(s) <b>306</b> can be various services (or resources hosted within services) of provider network <b>200</b>. In some embodiments data source(s) <b>304</b> and/or materialized view target(s) <b>306</b> can be implemented partially or completely external to provider network <b>200</b> (e.g., at an on-premise network or at another provider service network). In some embodiments, materialized view management service <b>210</b> may allow for custom or user-implemented target or source connectors to be provided (e.g., uploaded via an interface and deployed for a requested materialized view) to customize the change data capture or materialized view export (e.g., from on-premise or custom data sources or targets).</p><p id="p-0101" num="0086">Once changes to a materialized view have been computed from the changes of a data source (e.g., from delta log records received in the one or more inbound logs for the corresponding data sources <b>304</b>), then changes to the materialized view may be materialized by materialized view management service <b>210</b>. For example, materialized view incremental maintenance engine(s) <b>350</b> may store the updates to a view-specific change log (e.g., an append-only change log implemented via a log-based database, ledger database, or other log-structured storage) in a format corresponding to the hub data model (e.g., in ION format) via which target connectors <b>370</b> implemented in the target data store service (or implemented interact specifically for the target data store) may read from the logs of corresponding sources contributing to a view. Target connectors <b>370</b> may be implemented to interact with a target for a materialized view by applying the described changes to the materialized view.</p><p id="p-0102" num="0087">For example, target connector(s) <b>370</b> may obtain the changes to be made to a materialized view, in various embodiments. In various embodiments, target connectors <b>370</b> may implement target-specified update translation. For example, target-specific update translation from the hub data model may be performed, including data type conversions, operation conversions, and/or generate the request parameters needed to perform an update request to make a corresponding change in the materialized view according to the interface of the target system. In some embodiments, target connector(s) <b>370</b> may enforce ordering constraints. In some embodiments, target connector(s) <b>370</b> may perform deduplication to prevent duplicate updates from being performed. For example, target connector(s) <b>370</b> may track the updates successfully performed (as discussed above) in order to prevent a failure from causing an already performed update from being re-performed.</p><p id="p-0103" num="0088">Materialized view management service <b>210</b> may operate in different phases for a materialized view, in some embodiments. <figref idref="DRAWINGS">FIG. <b>4</b></figref> is a sequence diagram illustrating interactions for creation and maintenance phases for a materialized view managed by a materialized view management service, according to some embodiments. For example, creation phase <b>402</b> may begin with a request to create a materialized view <b>430</b> received at materialized view <b>210</b> (e.g., via interface <b>310</b>). The creation request <b>430</b> may include or specify the data source(s), data target(s), and view definition that the materialized view is to provide, in some embodiments. In some embodiments, the creation request may provide the access credentials (e.g., user id, password, etc.) or other permissions to allow the creation of the materialized view and update of the materialized view in the target. In some embodiments, an identity and access management service may coordinate authentication of materialized view management service and other services for creation and maintenance of a materialized view.</p><p id="p-0104" num="0089">In some embodiments, a graphical interface may provide options of selectable data sources, operations to perform to determine a result from the selectable data sources, and selectable targets to which materialized view management service <b>210</b> is capable of accessing. Once the various materialized view definition parameters are selected, a create user interface element may be selected, which triggers the &#x201c;create managed materialized view request <b>430</b>&#x201d; (using the selected parameters and result definition). Alternatively an API may utilized, allowing for a query language or other notation (e.g., JSON, ION, etc.) to specify the data source(s), target(s), and result definition. Similar parameters or inputs can be provided by a command via a command line interface.</p><p id="p-0105" num="0090">Materialized view management service <b>210</b> may receive the request <b>430</b> and invoke the various features of a view creation process or workflow. For example, materialized view management service <b>210</b> may get source data from the data source connector(s) <b>410</b> (e.g., via the append-only log or an initial batch upload, snapshot, or other information used to generate the initial version of the materialized view). In some embodiments, a data source may push the data (e.g., a stream of data) to materialized view management service <b>210</b>. Alternatively, some data sources may allow for materialized view management service <b>210</b> to query or send requests to access the desired data for the materialized view (e.g., according to a result set definition for the materialized view). Materialized view management service <b>210</b> perform one or multiple requests to store the materialized view(s) <b>434</b> via target connector(s) <b>420</b>, in various embodiments. For example, materialize view management service <b>210</b> may store change log records or other information to an append-only log assigned to the materialized view and accessible to target connector(s) <b>420</b>.</p><p id="p-0106" num="0091">The requests to get source data <b>432</b> and store data <b>434</b> may continue until the materialized view is created. Then, the materialized view may begin maintenance phase <b>404</b>. Maintenance phase <b>404</b> may allow for materialized view management service <b>210</b> to get <b>452</b> (e.g., via the append-only logs for the various data sources) or otherwise respond to changes to the data sources (e.g., additional data, removed data, modified data, etc.) in order to compute or otherwise determine an update to a materialized view. For example, if a materialized view provides an aggregation function (e.g., summary, average, count, deviation, etc.) then materialized view management service <b>210</b> may add, divide, subtract, union, join, or other perform various other operations to determine updated values corresponding to the obtained changes. Materialized view management service <b>210</b> may then perform one or more requests to update the new version(s) of the materialized view(s) <b>454</b> to include those changes at via target connector(s) <b>420</b> (e.g., via updates to the append only log for the materialized view).</p><p id="p-0107" num="0092">Various requests or interactions with a materialized view management service may be supported to configure creation and maintenance of materialized view and/or obtain information for materialized views. <figref idref="DRAWINGS">FIG. <b>5</b></figref> is logical block diagram illustrating interactions supported by an example interface for a materialized view management service, according to some embodiments. As indicated at <b>510</b>, a view definition may be created and edit <b>510</b> via interface <b>310</b>. For example, the view definition may be entered via text editor, command line, and/or uploaded as a document (e.g., a JSON document). As indicated at <b>520</b>, interface <b>310</b> may support a request to perform a compatibility check for a view definition, as discussed above with regard to <figref idref="DRAWINGS">FIG. <b>1</b></figref> and below with regard to <figref idref="DRAWINGS">FIGS. <b>6</b>-<b>8</b></figref>. An indication of incompatibility (or no compatibility issues) may be provided, as indicated at <b>522</b>. In some embodiments, the response indicating incompatibility may include suggestions.</p><p id="p-0108" num="0093">As indicated at <b>530</b>, one or more mapping view(s) may be created from existing view(s), as discussed below with regard to <figref idref="DRAWINGS">FIG. <b>9</b></figref>. For example, a user may have created a view V. A user may want to target an additional database, DB2 and thus creates the mapping view M as:</p><p id="p-0109" num="0094">CREATE VIEW M AS</p><p id="p-0110" num="0095">SELECT CAST(d AS DECIMAL(10,2)) AS d</p><p id="p-0111" num="0096">CAST(a AS DB2::SUPER) AS a</p><p id="p-0112" num="0097">CAST(s AS VARCHAR(256)) AS s</p><p id="p-0113" num="0098">FROM V</p><p id="p-0114" num="0000">The DB2::SUPER type may be DB2's equivalent of ANY. An alternative to mapping view M may specify the mapping view with a schema on read functionality:</p><p id="p-0115" num="0099">CREATE VIEW SM</p><p id="p-0116" num="0100">FROM V</p><p id="p-0117" num="0101">AS SCHEMA (</p><p id="p-0118" num="0102">d DECIMAL(10,2),</p><p id="p-0119" num="0103">a DB2::SUPER,</p><p id="p-0120" num="0104">s VARCHAR(256)</p><p id="p-0121" num="0105">)</p><p id="p-0122" num="0106">In some embodiments, one (or more) violation views may be created, as indicated at <b>540</b>. A violation view may be created in various embodiments which may result in a logical violation when moving data from a source data store to a target data store (e.g., by losing some data or exhibiting an unusual schema). For example, if in the creation of the above map view, a user suspects that there are a few &#x201c;d's&#x201d; that cannot be cast to decimal and would like to keep track of them, as SUPER if possible, along with the associated s, a violation view may be created:</p><p id="p-0123" num="0107">CREATE VIEW Violating_d AS</p><p id="p-0124" num="0108">SELECT CAST(s AS VARCHAR(256)) AS s,<ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0109">CAST(d AS DB2::SUPER) AS d</li>    </ul>    </li></ul></p><p id="p-0125" num="0110">FROM V</p><p id="p-0126" num="0111">WHERE FAIL CAST(d AS DECIMAL(10,2))</p><p id="p-0127" num="0112">//the FAIL CAST can be emulated as NOT IS MISSING d AND</p><p id="p-0128" num="0113">//IS MISSING CAST(d AS DECIMAL(d))</p><p id="p-0129" num="0114">In some embodiments, violations may be handled as part of a materialized view maintenance engine <b>350</b> in <figref idref="DRAWINGS">FIG. <b>3</b></figref> or other component, which may report or send a notification that a violation has occurred, insert or add records to a violation view, among other techniques. For example, a request to create a violation view handler <b>550</b>, which may be implemented, as discussed in detail below with regard to <figref idref="DRAWINGS">FIG. <b>6</b></figref>. The violation view handler may be described using a script, language, or other set of instructions that may specify the various responsive actions related to violation views, for instance.</p><p id="p-0130" num="0115">As discussed above, a type system may be added or updated, as indicated at <b>560</b>. For example, a description of a type system may be received that specifies the various features of the type system, open, closed, applier, supplier, etc., using types of the hub data model (e.g., primitive, struct, nominal, opaque, etc.) Similarly, as discussed in detail below with regard to <figref idref="DRAWINGS">FIG. <b>7</b></figref>, type inspections may occur. In some embodiments, updates to a type system may trigger notifications or other workflows to identify impacted views (e.g., materialized, mapping, or violation). For example, a change to a type system to reflect a change in a data stores implementation of a data type (e.g., the data type size could be increased), may affect whether a violation occurs or if a different mapping to a different type should be applied.</p><p id="p-0131" num="0116"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a logical block diagram illustrating a materialized view incremental maintenance engine that implements a violation handler for managed materialized views, according to some embodiments. Materialized view incremental maintenance engine <b>610</b> may receive change data <b>602</b> and make view updates <b>604</b> according to view maintenance plan <b>620</b> (generated from a view definition) and, when violations occur, updates to a violation view, according to violation view plan <b>630</b> (generated from a violation view). A violation handler <b>640</b> may be specified as various scripts, components, or other criteria for different violation event(s) <b>642</b> that may trigger different responsive actions <b>644</b> (e.g., notifications, data processing, such as error correction, stop view maintenance, aggregation of violations, particular storage location for a violation view, such as the same location as a materialized view, etc.). Materialized view maintenance engine <b>610</b> may perform the responsive actions <b>606</b>.</p><p id="p-0132" num="0117"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is an example user interface for viewing data schemas with a type lens, according to some embodiments. For example, schema viewer <b>329</b> may provide an interface for users to search for table(s) <b>742</b> or other data, that is stored according to a data model of a data store that implements a respective type system. Type inspection view <b>720</b> may provide a schema view for the table, as indicated at <b>722</b>, which may be modified or translated according to different schemas according to type lens <b>744</b> (e.g., other available type systems of other data stores). Because the other type systems are described using types of the hub data model, such translations to provide a view of a table schema using a different type lens <b>744</b> can be performed (e.g., similar to compatibility checks and view generation as discussed above).</p><p id="p-0133" num="0118">Although <figref idref="DRAWINGS">FIGS. <b>2</b>-<b>7</b></figref> have been described and illustrated in the context of a provider network implementing a materialized view management service, the various components illustrated and described in <figref idref="DRAWINGS">FIGS. <b>2</b>-<b>7</b></figref> may be easily applied to other data processing systems that store data across different sources and targets. As such, <figref idref="DRAWINGS">FIGS. <b>2</b>-<b>7</b></figref> are not intended to be limiting as to other embodiments of a system that may implement registering type data systems to extend a hub data model for data processing. <figref idref="DRAWINGS">FIG. <b>8</b></figref> is a high-level flowchart illustrating various methods and techniques to implement registering additional type systems using a hub data model for data processing, according to some embodiments.</p><p id="p-0134" num="0119">Various different systems and devices may implement the various methods and techniques described below, either singly or working together. For example, a materialized view management service such as described above with regard to <figref idref="DRAWINGS">FIGS. <b>2</b>-<b>8</b></figref> may implement the various methods. Alternatively, a combination of different systems and devices may implement these methods. Therefore, the above examples and or any other systems or devices referenced as performing the illustrated method, are not intended to be limiting as to other different components, modules, systems, or configurations of systems and devices.</p><p id="p-0135" num="0120">As indicated at <b>810</b>, a description of a new type system for a data store, the new type system being defined from one or more types of a hub data model, may be received via an interface for a data processing system, in some embodiments. For example, as discussed above with regard to <figref idref="DRAWINGS">FIG. <b>1</b></figref>, a hub data model may include different primitive or other types that can be used to define new types in a new type system. These other types may include struct types, (or other types that support combinations of types), nominal types, and/or opaque types. The hub data model may be described in a schema language, such as ISL. Thus, the description of the new type system being defined from types of the hub data model may also be described in the same schema language, in some embodiments.</p><p id="p-0136" num="0121">As indicated at <b>820</b>, the description of the new type system may be added to a type registry for the data processing system that includes descriptions of multiple type systems for respective data stores. In some embodiments, access controls or other processing of the description of the types system may be implemented before adding the description to the type registry. For example, an access control may only allow certain users or requests to add a new type system that are associated with (or include) valid credentials indicating authorization to add the new type system. In another example, type system validation may be performed to parse, scan, or otherwise evaluate the description of the new type system for improper format, incorrect syntax, or other errors.</p><p id="p-0137" num="0122">As indicated at <b>830</b>, a data processing job may be performed that obtains data from a source data store that is one the respective data stores and stores the data into a target data store that is a different one of the respective data stores using the respective type systems in the type registry for the source data store and the target data store, where one of the respective type systems used to perform the data processing job is the new type system. As discussed above with regard to <figref idref="DRAWINGS">FIG. <b>1</b></figref>, adding new type systems to the type registry may allow for new data stores to serve as sources or targets for data processing jobs. Instead of requiring a developer to specify the mappings of a source data store into each possible target data store, the type systems of the source and targets in the registry can be used to map data from one type system to another (as both are defined using types of the hub data model).</p><p id="p-0138" num="0123">Because a hub data model will allow for different type systems to be involved in a data processing job, it may be beneficial for some users of a data processing system to view or otherwise be provided with a schema of data from a data store (e.g., a table schema describing the number of columns, names of columns, data types of columns, etc.). <figref idref="DRAWINGS">FIG. <b>9</b></figref> is a high-level flowchart illustrating various methods and techniques to inspect the type of a data schema according to a specified type lens, according to some embodiments. As indicated at <b>910</b>, a request may be received to view a schema of data from a data store according to a specified type lens, in some embodiments. For example, the request may include a parameter or other identifier that specifies one of a plurality of available type systems in a type system registry. A determination may be made as to whether the type lens identifies the type system of the data store, as indicated at <b>920</b>. For example, if the type lens specified matches the storage location of the data, then it can be determined that the type lens identifies the types system of the data store. If not, then the type lens may identify a different types system.</p><p id="p-0139" num="0124">If yes, then the schema of the data may be provided using the type system of the data store, as indicated at <b>930</b>. The schema may be obtained as-is from the data store utilizing an interface, instruction, or other command to access the data schema. If not, then a type registry may be accessed to translate the schema of the data using a type system from the type registry identified by the type lens, as indicated at <b>940</b>. For example, the data schema may be obtained, as discussed above, and then the data types specified in the schema may be remapped to their corresponding types in the type system corresponding to the type lens. As indicated at <b>950</b>, the translated schema of the data using the type system may be provided from the type registry. Providing translated schemas according to the type lens may allow a user to understand how data may be mapped to different potential target data stores. Moreover, a user can also understand those scenarios in which alternative mappings could be suggested or specified when specifying a data processing job (e.g., a view definition).</p><p id="p-0140" num="0125">As discussed above, when a violation view is created to capture violations of maintaining a materialized view, different ways to handle the captured violations may be beneficial in different scenarios. Giving users the flexibility to specify how violations may be handled, may allow users to better design applications that integrate materialized views generated using a data processing system that implements a hub data model. <figref idref="DRAWINGS">FIG. <b>10</b></figref> is a high-level flowchart illustrating various methods and techniques to implement a violation handler for a managed view, according to some embodiments. As indicated at <b>1010</b>, a request may be received to create a violation view handler for a violation view managed by a view management system, as indicated at <b>1010</b>. For example, the violation view (or multiple violation views) may be identified in the request along with various conditions or other criteria that trigger one or more responsive actions. Aggregation of violation views, for example may occur, as can transformation of those views via different mathematical or other operators to generate different view performance metrics may be specified. Other specified responsive actions may include actions to notify or alert different systems, and/or may provide a mechanism for stopping materialized view maintenance.</p><p id="p-0141" num="0126">As indicated at <b>1020</b>, the violation handler for the violation view may be enabled. For example, monitoring resource(s), such as one or more computing devices, or portions thereof (e.g. monitoring processes or threads) may be provisioned or assigned to check for violation handling events, in some embodiments.</p><p id="p-0142" num="0127">As indicated at <b>1030</b>, a violation event may be detected. Different criteria for different violation handling events may be implemented. For example, threshold values with respect to the number of violations, type of violations, and/or source of violations may be considered. As indicated at <b>1040</b>, responsive action(s) identified by the violation handler may be performed according to the detected violation handling event, in some embodiments. For example, the violation handler may include a mapping between different violation handling events and different responsive actions. A violation handling event may trigger more than one responsive action, in some embodiments, such as both an alert of a violation and an action to stop updating a materialized view. Violation handler may be enabled until a request to disable or update the violation handler is received, in some embodiments.</p><p id="p-0143" num="0128">The methods described herein may in various embodiments be implemented by any combination of hardware and software. For example, in one embodiment, the methods may be implemented by a computer system (e.g., a computer system as in <figref idref="DRAWINGS">FIG. <b>11</b></figref>) that includes one or more processors executing program instructions stored on a computer-readable storage medium coupled to the processors. The program instructions may be configured to implement the functionality described herein (e.g., the functionality of various servers and other components that implement the network-based virtual computing resource provider described herein). The various methods as illustrated in the figures and described herein represent example embodiments of methods. The order of any method may be changed, and various elements may be added, reordered, combined, omitted, modified, etc.</p><p id="p-0144" num="0129">Embodiments of registering additional type systems using a hub data model for data processing as described herein may be executed on one or more computer systems, which may interact with various other devices. One such computer system is illustrated by <figref idref="DRAWINGS">FIG. <b>11</b></figref>. In different embodiments, computer system <b>2000</b> may be any of various types of devices, including, but not limited to, a personal computer system, desktop computer, laptop, notebook, or netbook computer, mainframe computer system, handheld computer, workstation, network computer, a camera, a set top box, a mobile device, a consumer device, video game console, handheld video game device, application server, storage device, a peripheral device such as a switch, modem, router, or in general any type of computing device, computing node, compute node, computing system compute system, or electronic device.</p><p id="p-0145" num="0130">In the illustrated embodiment, computer system <b>2000</b> includes one or more processors <b>2010</b> coupled to a system memory <b>2020</b> via an input/output (I/O) interface <b>2030</b>. Computer system <b>2000</b> further includes a network interface <b>2040</b> coupled to I/O interface <b>2030</b>, and one or more input/output devices <b>2050</b>, such as cursor control device <b>2060</b>, keyboard <b>2070</b>, and display(s) <b>2080</b>. Display(s) <b>2080</b> may include standard computer monitor(s) and/or other display systems, technologies or devices. In at least some implementations, the input/output devices <b>2050</b> may also include a touch- or multi-touch enabled device such as a pad or tablet via which a user enters input via a stylus-type device and/or one or more digits. In some embodiments, it is contemplated that embodiments may be implemented using a single instance of computer system <b>2000</b>, while in other embodiments multiple such systems, or multiple nodes making up computer system <b>2000</b>, may host different portions or instances of embodiments. For example, in one embodiment some elements may be implemented via one or more nodes of computer system <b>2000</b> that are distinct from those nodes implementing other elements.</p><p id="p-0146" num="0131">In various embodiments, computer system <b>2000</b> may be a uniprocessor system including one processor <b>2010</b>, or a multiprocessor system including several processors <b>2010</b> (e.g., two, four, eight, or another suitable number). Processors <b>2010</b> may be any suitable processor capable of executing instructions. For example, in various embodiments, processors <b>2010</b> may be general-purpose or embedded processors implementing any of a variety of instruction set architectures (ISAs), such as the x86, PowerPC, SPARC, or MIPS ISAs, or any other suitable ISA. In multiprocessor systems, each of processors <b>2010</b> may commonly, but not necessarily, implement the same ISA.</p><p id="p-0147" num="0132">In some embodiments, at least one processor <b>2010</b> may be a graphics processing unit. A graphics processing unit or GPU may be considered a dedicated graphics-rendering device for a personal computer, workstation, game console or other computing or electronic device. Modern GPUs may be very efficient at manipulating and displaying computer graphics, and their highly parallel structure may make them more effective than typical CPUs for a range of complex graphical algorithms. For example, a graphics processor may implement a number of graphics primitive operations in a way that makes executing them much faster than drawing directly to the screen with a host central processing unit (CPU). In various embodiments, graphics rendering may, at least in part, be implemented by program instructions configured for execution on one of, or parallel execution on two or more of, such GPUs. The GPU(s) may implement one or more application programmer interfaces (APIs) that permit programmers to invoke the functionality of the GPU(s). Suitable GPUs may be commercially available from vendors such as NVIDIA Corporation, ATI Technologies (AMD), and others.</p><p id="p-0148" num="0133">System memory <b>2020</b> may store program instructions and/or data accessible by processor <b>2010</b>. In various embodiments, system memory <b>2020</b> may be implemented using any suitable memory technology, such as static random access memory (SRAM), synchronous dynamic RAM (SDRAM), nonvolatile/Flash-type memory, or any other type of memory. In the illustrated embodiment, program instructions and data implementing desired functions, such as those described above are shown stored within system memory <b>2020</b> as program instructions <b>2025</b> and data storage <b>2035</b>, respectively. In other embodiments, program instructions and/or data may be received, sent or stored upon different types of computer-accessible media or on similar media separate from system memory <b>2020</b> or computer system <b>2000</b>. Generally speaking, a non-transitory, computer-readable storage medium may include storage media or memory media such as magnetic or optical media, e.g., disk or CD/DVD-ROM coupled to computer system <b>2000</b> via I/O interface <b>2030</b>. Program instructions and data stored via a computer-readable medium may be transmitted by transmission media or signals such as electrical, electromagnetic, or digital signals, which may be conveyed via a communication medium such as a network and/or a wireless link, such as may be implemented via network interface <b>2040</b>.</p><p id="p-0149" num="0134">In one embodiment, I/O interface <b>2030</b> may coordinate I/O traffic between processor <b>2010</b>, system memory <b>2020</b>, and any peripheral devices in the device, including network interface <b>2040</b> or other peripheral interfaces, such as input/output devices <b>2050</b>. In some embodiments, I/O interface <b>2030</b> may perform any necessary protocol, timing or other data transformations to convert data signals from one component (e.g., system memory <b>2020</b>) into a format suitable for use by another component (e.g., processor <b>2010</b>). In some embodiments, I/O interface <b>2030</b> may include support for devices attached through various types of peripheral buses, such as a variant of the Peripheral Component Interconnect (PCI) bus standard or the Universal Serial Bus (USB) standard, for example. In some embodiments, the function of I/O interface <b>2030</b> may be split into two or more separate components, such as a north bridge and a south bridge, for example. In addition, in some embodiments some or all of the functionality of I/O interface <b>2030</b>, such as an interface to system memory <b>2020</b>, may be incorporated directly into processor <b>2010</b>.</p><p id="p-0150" num="0135">Network interface <b>2040</b> may allow data to be exchanged between computer system <b>2000</b> and other devices attached to a network, such as other computer systems, or between nodes of computer system <b>2000</b>. In various embodiments, network interface <b>2040</b> may support communication via wired or wireless general data networks, such as any suitable type of Ethernet network, for example; via telecommunications/telephony networks such as analog voice networks or digital fiber communications networks; via storage area networks such as Fibre Channel SANs, or via any other suitable type of network and/or protocol.</p><p id="p-0151" num="0136">Input/output devices <b>2050</b> may, in some embodiments, include one or more display terminals, keyboards, keypads, touchpads, scanning devices, voice or optical recognition devices, or any other devices suitable for entering or retrieving data by one or more computer system <b>2000</b>. Multiple input/output devices <b>2050</b> may be present in computer system <b>2000</b> or may be distributed on various nodes of computer system <b>2000</b>. In some embodiments, similar input/output devices may be separate from computer system <b>2000</b> and may interact with one or more nodes of computer system <b>2000</b> through a wired or wireless connection, such as over network interface <b>2040</b>.</p><p id="p-0152" num="0137">As shown in <figref idref="DRAWINGS">FIG. <b>11</b></figref>, memory <b>2020</b> may include program instructions <b>2025</b>, may implement the various methods and techniques as described herein, and data storage <b>2035</b>, comprising various data accessible by program instructions <b>2025</b>. In one embodiment, program instructions <b>2025</b> may include software elements of embodiments as described herein and as illustrated in the Figures. Data storage <b>2035</b> may include data that may be used in embodiments. In other embodiments, other or different software elements and data may be included.</p><p id="p-0153" num="0138">Those skilled in the art will appreciate that computer system <b>2000</b> is merely illustrative and is not intended to limit the scope of the techniques as described herein. In particular, the computer system and devices may include any combination of hardware or software that can perform the indicated functions, including a computer, personal computer system, desktop computer, laptop, notebook, or netbook computer, mainframe computer system, handheld computer, workstation, network computer, a camera, a set top box, a mobile device, network device, internet appliance, PDA, wireless phones, pagers, a consumer device, video game console, handheld video game device, application server, storage device, a peripheral device such as a switch, modem, router, or in general any type of computing or electronic device. Computer system <b>2000</b> may also be connected to other devices that are not illustrated, or instead may operate as a stand-alone system. In addition, the functionality provided by the illustrated components may in some embodiments be combined in fewer components or distributed in additional components. Similarly, in some embodiments, the functionality of some of the illustrated components may not be provided and/or other additional functionality may be available.</p><p id="p-0154" num="0139">Those skilled in the art will also appreciate that, while various items are illustrated as being stored in memory or on storage while being used, these items or portions of them may be transferred between memory and other storage devices for purposes of memory management and data integrity. Alternatively, in other embodiments some or all of the software components may execute in memory on another device and communicate with the illustrated computer system via inter-computer communication. Some or all of the system components or data structures may also be stored (e.g., as instructions or structured data) on a computer-accessible medium or a portable article to be read by an appropriate drive, various examples of which are described above. In some embodiments, instructions stored on a non-transitory, computer-accessible medium separate from computer system <b>2000</b> may be transmitted to computer system <b>2000</b> via transmission media or signals such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as a network and/or a wireless link. Various embodiments may further include receiving, sending or storing instructions and/or data implemented in accordance with the foregoing description upon a computer-accessible medium. Accordingly, the present invention may be practiced with other computer system configurations.</p><p id="p-0155" num="0140">It is noted that any of the distributed system embodiments described herein, or any of their components, may be implemented as one or more web services. For example, leader nodes within a data warehouse system may present data storage services and/or database services to clients as network-based services. In some embodiments, a network-based service may be implemented by a software and/or hardware system designed to support interoperable machine-to-machine interaction over a network. A network-based service may have an interface described in a machine-processable format, such as the Web Services Description Language (WSDL). Other systems may interact with the web service in a manner prescribed by the description of the network-based service's interface. For example, the network-based service may define various operations that other systems may invoke, and may define a particular application programming interface (API) to which other systems may be expected to conform when requesting the various operations.</p><p id="p-0156" num="0141">In various embodiments, a network-based service may be requested or invoked through the use of a message that includes parameters and/or data associated with the network-based services request. Such a message may be formatted according to a particular markup language such as Extensible Markup Language (XML), and/or may be encapsulated using a protocol such as Simple Object Access Protocol (SOAP). To perform a web services request, a network-based services client may assemble a message including the request and convey the message to an addressable endpoint (e.g., a Uniform Resource Locator (URL)) corresponding to the web service, using an Internet-based application layer transfer protocol such as Hypertext Transfer Protocol (HTTP).</p><p id="p-0157" num="0142">In some embodiments, web services may be implemented using Representational State Transfer (&#x201c;RESTful&#x201d;) techniques rather than message-based techniques. For example, a web service implemented according to a RESTful technique may be invoked through parameters included within an HTTP method such as PUT, GET, or DELETE, rather than encapsulated within a SOAP message.</p><p id="p-0158" num="0143">The various methods as illustrated in the FIGS. and described herein represent example embodiments of methods. The methods may be implemented in software, hardware, or a combination thereof. The order of method may be changed, and various elements may be added, reordered, combined, omitted, modified, etc.</p><p id="p-0159" num="0144">Various modifications and changes may be made as would be obvious to a person skilled in the art having the benefit of this disclosure. It is intended that the invention embrace all such modifications and changes and, accordingly, the above description to be regarded in an illustrative rather than a restrictive sense.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A system, comprising:<claim-text>at least one processor; and</claim-text><claim-text>a memory, storing program instructions that when executed by the at least one processor, cause the at least one processor to implement a view management system, the view management system configured to:<claim-text>receive, via an interface of the view management system, a description of a new type system for a data store, wherein the description of the new type system is defined from one or more types of a hub data model;</claim-text><claim-text>store the description of the new type system in a type registry for the data processing system, wherein the type registry comprises respective descriptions of a plurality of type systems for respective data stores;</claim-text><claim-text>receive a view definition that specifies a source data store; and</claim-text><claim-text>generate a view according to the view definition using the respective type systems in the type registry for the source data store and the target data store, wherein one of the respective type systems used to generate the view is the new type system.</claim-text></claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the new type system is an applier type system for the target data store.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the view management system is further configured to:<claim-text>receive a request to view a schema of data from the source data store according to a specified type lens, wherein the specified type lens identifies the new type system, and wherein the new type system is the respective type system for the target data store;</claim-text><claim-text>access the type registry to translate the schema of the data using the new type system in the type registry; and</claim-text><claim-text>provide the translated schema of the data using the new type system.</claim-text></claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the view management system is implemented as a materialized view management service offered by a provider network, wherein the source data store is one service offered by the provider network, and wherein the target data store is a different service offered by the provider network.</claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. A method, comprising:<claim-text>receiving, via an interface of a data processing system, a description of a new type system for a data store, wherein the description of the new type system is defined from one or more types of a hub data model;</claim-text><claim-text>adding the description of the new type system to a type registry for the data processing system, wherein the type registry comprises respective descriptions of a plurality of type systems for respective data stores; and</claim-text><claim-text>performing, by the data processing system, a data processing job that obtains data from a source data store that is one the respective data stores and stores the data into a target data store that is a different one of the respective data stores using the respective type systems in the type registry for the source data store and the target data store, wherein one of the respective type systems used to perform the data processing job is the new type system.</claim-text></claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the new type system is a supplier type system for the target data store.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, further comprising:<claim-text>receiving a request to view a schema of data from the source data store according to a specified type lens, wherein the specified type lens identifies the new type system, and wherein the new type system is the respective type system for the target data store;</claim-text><claim-text>accessing the type registry to translate the schema of the data using the new type system in the type registry; and</claim-text><claim-text>providing the translated schema of the data using the new type system.</claim-text></claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, further comprising updating the new type system in the type registry responsive to a request to update the new type system received via the interface.</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the description of the new type system indicates that the new type system is an open type system.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the new type system is applied to perform a compatibility check between a source data model and a target data model before performing the data processing job.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the description of the new type system includes a primitive type of the hub data model.</claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the data processing system is implemented as an Extract Transform Load (ETL) service offered by a provider network, wherein the source data store and the target data store are located within the provider network.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the data processing job is to maintain a materialized view at the target data store according to a view definition specified in a query language.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. One or more non-transitory, computer-readable storage media, storing program instructions that when executed on or across one or more computing devices cause the one or more computing devices to implement:<claim-text>receiving, via an interface of a data processing system, a description of a new type system for a data store, wherein the description of the new type system is defined from one or more types of a hub data model;</claim-text><claim-text>storing the description of the new type system in a type registry for the data processing system, wherein the type registry comprises respective descriptions of a plurality of type systems for respective data stores;</claim-text><claim-text>generating, by the data processing system, a plan to perform a data processing job that obtains data from a source data store that is one the respective data stores and stores the data into a target data store that is a different one of the respective data stores using the respective type systems in the type registry for the source data store and the target data store, wherein one of the respective type systems used to perform the data processing job is the new type system; and</claim-text><claim-text>executing, by the data processing system, the plan to perform the data processing job.</claim-text></claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The one or more non-transitory, computer-readable storage media of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the new type system is an applier type system for the target data store.</claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The one or more non-transitory, computer-readable storage media of <claim-ref idref="CLM-00014">claim 14</claim-ref>, storing further instructions that when executed on or across the one or more computing devices, cause the one or more computing devices to further implement:<claim-text>receiving a request to view a schema of data from the source data store according to a specified type lens, wherein the specified type lens identifies the new type system, and wherein the new type system is the respective type system for the target data store;</claim-text><claim-text>accessing the type registry to translate the schema of the data using the new type system in the type registry; and</claim-text><claim-text>providing the translated schema of the data using the new type system.</claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The one or more non-transitory, computer-readable storage media of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the description of the new type system indicates that the new type system is a closed type system.</claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The one or more non-transitory, computer-readable storage media of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the new type system is applied to perform a compatibility check between a source data model and a target data model before performing the data processing job.</claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The one or more non-transitory, computer-readable storage media of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the description of the new type system comprises a structural type that combines two or more primitive types of the hub data model.</claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The one or more non-transitory, computer-readable storage media of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the one or more computing devices are implemented as part of a materialized view management service, and wherein the data processing job is to maintain a materialized view at the target data store according to a view definition specified in a query language.</claim-text></claim></claims></us-patent-application>