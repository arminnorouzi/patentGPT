<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230005122A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230005122</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17374439</doc-number><date>20210713</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><priority-claims><priority-claim sequence="01" kind="national"><country>CN</country><doc-number>PCT/CN2021/103613</doc-number><date>20210630</date></priority-claim></priority-claims><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>T</subclass><main-group>7</main-group><subgroup>00</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>N</subclass><main-group>20</main-group><subgroup>20</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>K</subclass><main-group>9</main-group><subgroup>62</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>T</subclass><main-group>7</main-group><subgroup>0002</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>N</subclass><main-group>20</main-group><subgroup>20</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>K</subclass><main-group>9</main-group><subgroup>6256</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e61">IMAGE FORGERY DETECTION VIA PIXEL-METADATA CONSISTENCY ANALYSIS</invention-title><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>PayPal, Inc.</orgname><address><city>San Jose</city><state>CA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Peng</last-name><first-name>Shanshan</first-name><address><city>Singapore</city><country>SG</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Zhang</last-name><first-name>Jiazheng</first-name><address><city>Singapore</city><country>SG</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>Zhang</last-name><first-name>Jiyi</first-name><address><city>Singapore</city><country>SG</country></address></addressbook></inventor><inventor sequence="03" designation="us-only"><addressbook><last-name>Tang</last-name><first-name>Quan Jin Ferdinand</first-name><address><city>Singapore</city><country>SG</country></address></addressbook></inventor><inventor sequence="04" designation="us-only"><addressbook><last-name>Yu</last-name><first-name>Xiaodong</first-name><address><city>Singapore</city><country>SG</country></address></addressbook></inventor><inventor sequence="05" designation="us-only"><addressbook><last-name>Zhuo</last-name><first-name>Yuzhen</first-name><address><city>Singapore</city><country>SG</country></address></addressbook></inventor><inventor sequence="06" designation="us-only"><addressbook><last-name>Qian</last-name><first-name>Hong</first-name><address><city>Shanghai</city><country>CN</country></address></addressbook></inventor><inventor sequence="07" designation="us-only"><addressbook><last-name>Chen</last-name><first-name>Zhe</first-name><address><city>Singapore</city><country>SG</country></address></addressbook></inventor><inventor sequence="08" designation="us-only"><addressbook><last-name>Wen</last-name><first-name>Runmin</first-name><address><city>Shanghai</city><country>CN</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">Systems and/or techniques for facilitating image forgery detection via pixel-metadata consistency analysis are provided. In various embodiments, a system can receive an electronic image from a client device. In various cases, the system can obtain a pixel vector and/or an image metadata vector that correspond to the electronic image. In various aspects, the system can determine whether the electronic image is authentic or forged, based on analyzing the pixel vector and the image metadata vector via at least one machine learning model.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="90.34mm" wi="158.75mm" file="US20230005122A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="205.32mm" wi="154.18mm" orientation="landscape" file="US20230005122A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="197.36mm" wi="154.18mm" orientation="landscape" file="US20230005122A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="206.67mm" wi="154.18mm" orientation="landscape" file="US20230005122A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="239.52mm" wi="154.18mm" orientation="landscape" file="US20230005122A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="239.52mm" wi="154.18mm" orientation="landscape" file="US20230005122A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="206.67mm" wi="157.82mm" orientation="landscape" file="US20230005122A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="206.67mm" wi="157.82mm" orientation="landscape" file="US20230005122A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="236.05mm" wi="150.03mm" file="US20230005122A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="232.75mm" wi="157.06mm" file="US20230005122A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="232.75mm" wi="147.24mm" file="US20230005122A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">TECHNICAL FIELD</heading><p id="p-0002" num="0001">The subject disclosure relates generally to forgery detection, and more specifically to image forgery detection via pixel-metadata consistency analysis.</p><heading id="h-0002" level="1">BACKGROUND</heading><p id="p-0003" num="0002">Image forgery detection can be the task of determining whether an electronic image has been manually edited and/or otherwise tampered with. Thus, image forgery detection can be helpful to prevent certain types of fraud. Some existing techniques for facilitating image forgery detection include manual inspections and automated inspections that analyze image pixels directly. Manual inspections that analyze image pixels directly usually exhibit good fraud detection accuracy, but they are slow and expensive to perform. Existing automated inspections that analyze image pixels directly are much quicker than manual inspections, but they either are computationally expensive, have limited accuracy, and/or require substantial manual post-processing. Other existing techniques for facilitating image forgery detection include automated inspections that analyze image metadata, not image pixels, for traces/evidence of forgery. However, such existing automated techniques can fail since forgers can easily conceal such traces/evidence of forgery in image metadata.</p><p id="p-0004" num="0003">Accordingly, systems and/or techniques that can address one or more of these technical problems can be desirable.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0005" num="0004"><figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates a high-level block diagram of an example, non-limiting system that facilitates image forgery detection via pixel-metadata consistency analysis in accordance with one or more embodiments described herein.</p><p id="p-0006" num="0005"><figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates a high-level block diagram of an example, non-limiting system including a pixel vector and a metadata vector that facilitates image forgery detection via pixel-metadata consistency analysis in accordance with one or more embodiments described herein.</p><p id="p-0007" num="0006"><figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates a high-level block diagram of an example, non-limiting system including a machine learning model and a consistency vector that facilitates image forgery detection via pixel-metadata consistency analysis in accordance with one or more embodiments described herein.</p><p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. <b>4</b></figref> illustrates an example, non-limiting block diagram showing how a machine learning model can be leveraged to generate a consistency vector based on a pixel vector and a metadata vector in accordance with one or more embodiments described herein.</p><p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. <b>5</b></figref> illustrates an example, non-limiting block diagram showing how a machine learning model and a Gaussian mixture model can be leveraged to generate a consistency vector based on a pixel vector and a metadata vector in accordance with one or more embodiments described herein.</p><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. <b>6</b></figref> illustrates a high-level block diagram of an example, non-limiting system including a machine learning model and an authenticity classification that facilitates image forgery detection via pixel-metadata consistency analysis in accordance with one or more embodiments described herein.</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. <b>7</b></figref> illustrates a high-level block diagram of an example, non-limiting system including a validation message that facilitates image forgery detection via pixel-metadata consistency analysis in accordance with one or more embodiments described herein.</p><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>8</b></figref> illustrates a high-level flow diagram of an example, non-limiting computer-implemented method that facilitates image forgery detection via pixel-metadata consistency analysis in accordance with one or more embodiments described herein.</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. <b>9</b></figref> illustrates a block diagram of an example, non-limiting operating environment in which one or more embodiments described herein can be facilitated.</p><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. <b>10</b></figref> illustrates an example networking environment operable to execute various implementations described herein.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0004" level="1">DETAILED DESCRIPTION</heading><p id="p-0015" num="0014">The following detailed description is merely illustrative and is not intended to limit embodiments and/or application or uses of embodiments. Furthermore, there is no intention to be bound by any expressed or implied information presented in the preceding Background section, or in the Detailed Description section.</p><p id="p-0016" num="0015">One or more embodiments are now described with reference to the drawings, wherein like referenced numerals are used to refer to like elements throughout. In the following description, for purposes of explanation, numerous specific details are set forth in order to provide a more thorough understanding of the one or more embodiments. It is evident, however, in various cases, that the one or more embodiments can be practiced without these specific details.</p><p id="p-0017" num="0016">Image forgery detection can be the task of determining whether an electronic image (e.g., a computer file representing an image) has been manually edited and/or otherwise tampered with. So, image forgery detection can be helpful to prevent certain types of fraud. For example, in various cases, a person and/or entity can be required to provide and/or otherwise present an electronic image of a proof-of-identity document (e.g., a driver's license, a passport, a birth certificate) as a prerequisite to participating in a restricted activity (e.g., establishing an electronic account/profile such as a financial account). In some cases, the person and/or entity can be not authorized to participate in the restricted activity. However, the person and/or entity can have forged and/or tampered with the electronic image of the proof-of-identity document (e.g., can have manipulated the pixels of the electronic image via photo-editing software), such that the electronic image of the proof-of-identity document appears to indicate that the person and/or entity is authorized to participate in the restricted activity. To prevent the unauthorized person and/or entity from participating in the restricted activity, image forgery detection can be implemented.</p><p id="p-0018" num="0017">Some existing techniques for facilitating image forgery detection include manual inspections and/or automated inspections that analyze image pixels directly. Manual inspections that analyze raw image pixels usually exhibit good fraud detection accuracy, but they are slow and expensive to perform. Such manual inspections can include manually observing text fonts that are depicted in the electronic image and determining whether the text fonts are consistent with each other, manually observing different information blocks depicted in an electronic image and determining whether the information blocks are consistent with each other, and/or manually visually comparing an electronic image with a standardized template and determining whether the electronic image has any missing and/or misplaced parts. Unfortunately, it can take years to properly train a manual inspector. Moreover, even when properly trained, a manual inspector can take as long as several seconds to manually inspect an electronic image, which constitutes an excessive processing time.</p><p id="p-0019" num="0018">Existing automated techniques that analyze image pixels directly are much quicker than manual inspections. However, such existing automated techniques have their own significant disadvantages. For instance, some existing automated techniques implement deep learning models to analyze raw image pixels. Such deep learning model techniques can achieve high accuracy, but they require very large amounts of computational resources to function. Other existing automated techniques that analyze raw image pixels (e.g., Error Level Analysis, Color Filter Array, Local Noise Analysis) can consume fewer computational resources during inference than deep learning model techniques, but they can exhibit significantly reduced accuracy and/or can require significant post-processing.</p><p id="p-0020" num="0019">Other existing automated techniques can facilitate image forgery detection by analyzing image metadata, rather than raw image pixels. For instance, such existing automated techniques can include analyzing thumbnails, camera traces, compression signatures, decoding features, and/or quantization tables of an electronic image in search for traces of forgery. Although such existing automated techniques can achieve high accuracy of forgery detection, they can be easily sidestepped by forgers. This is due to the fact that forgers can easily manipulate image metadata so that any traces/evidence of forgery within the image metadata are eliminated.</p><p id="p-0021" num="0020">Accordingly, systems and/or techniques that can address one or more of these technical problems can be desirable.</p><p id="p-0022" num="0021">Various embodiments described herein can address one or more of these technical problems. One or more embodiments described herein include systems, computer-implemented methods, apparatus, and/or computer program products that can facilitate image forgery detection via pixel-metadata consistency analysis. In other words, various embodiments described herein can include a computerized tool (e.g., any suitable combination of computer-executable hardware and/or computer-executable software) that can electronically receive an electronic image (e.g., an image of a proof-of-identity document) and that can electronically analyze both the raw pixels of the electronic image and the metadata accompanying the electronic image. Based on both the raw pixels and the metadata, the computerized tool can electronically infer whether the electronic image is authentic or forged.</p><p id="p-0023" num="0022">As explained above, many existing automated techniques for facilitating image forgery detection take into consideration only the raw pixels of an electronic image and do not take into consider the metadata of the electronic image (e.g., Error Level Analysis, Color Filter Array, Local Noise Analysis). As also explained above, existing automated techniques for facilitating image forgery detection that do take into consideration image metadata are easily sidestepped by forgers (e.g., the image metadata can be maliciously edited so that any evidence of forgery in the metadata is erased).</p><p id="p-0024" num="0023">The inventors of various embodiments described herein realized that the robustness of image forgery detection can be improved when both raw pixels and metadata are taken into account. Specifically, in various cases, the computerized tool described herein can be considered as electronically predicting what metadata an electronic image should have, based on the raw pixels of the electronic image. In various instances, the computerized tool can also be considered as electronically comparing the predicted metadata with actual metadata of the electronic image. If the predicted metadata matches and/or is consistent with the actual metadata, the computerized tool can conclude that the electronic image is authentic. On the other hand, if the predicted metadata fails to match and/or is not consistent with the actual metadata, the computerized tool can conclude that the electronic image is not authentic (e.g., is forged). Accordingly, the computerized tool can identify a forged electronic image, even if the actual metadata has been maliciously modified to hide evidence of forgery.</p><p id="p-0025" num="0024">In various embodiments, a computerized tool as described herein can comprise a receiver component, a pre-processing component, a forgery component, and/or a transmitter component.</p><p id="p-0026" num="0025">In various embodiments, the receiver component of the computerized tool can electronically receive and/or can otherwise electronically access an electronic image. In various cases, the receiver component can electronically retrieve the electronic image from any suitable client device (e.g., a client desktop computer, a client laptop computer, a client smart phone). In various other cases, the computerized tool can electronically retrieve the electronic image from any other suitable data structure (e.g., graph data structure, relational data structure, hybrid data structure) that is electronically accessible to the receiver component, whether the data structure is centralized and/or decentralized, and/or whether the data structure is local to and/or remote from the receiver component. In any case, the receiver component can electronically access the electronic image, such that other components of the computerized tool can be able to interact with (e.g., read, write, copy, edit) the electronic image.</p><p id="p-0027" num="0026">In various aspects, the electronic image can comprise and/or otherwise be associated with a pixel vector and a metadata vector. In various instances, the pixel vector can be any suitable vector whose elements are scalars that numerically represent the pixel values of the electronic image. That is, the pixel vector can represent the raw pixels of the electronic image. In various cases, the metadata vector can be any suitable vector whose elements are scalars, vectors, matrices, tensors, and/or character strings that represent metadata information with which the electronic image is tagged. As a non-limiting example, the metadata vector can contain exchangeable image file format (Exif) tags that were embedded into and/or appended to the electronic image by an imaging device (e.g., camera) that captured the electronic image and/or by imaging software (e.g., Photoshop&#xae;) that opened and/or edited the electronic image. In various non-limiting examples, such Exif tags can include: image height as measured in number of pixels; image width as measured in number of pixels; timestamp marking time/date of creation; timestamp marking time/date of most recent editing; x resolution; y resolution; aperture value; color space; camera model that captured the electronic image; and/or software which created/edited the electronic image. Those having ordinary skill in the art will appreciate that any other suitable Exif tags can be implemented in various aspects.</p><p id="p-0028" num="0027">In various embodiments, the pre-processing component of the computerized tool can electronically generate, via a first machine learning model, a consistency vector based on both the pixel vector and the metadata vector. In various aspects, the consistency vector can be considered as representing and/or capturing a level of consistency between the pixel vector and the metadata vector. In various cases, the pre-processing component can leverage the first machine learning model in at least two different ways so as to generate the consistency vector.</p><p id="p-0029" num="0028">In one or more first embodiments, the first machine learning model of the pre-processing component can be configured and/or trained (e.g., via supervised training, unsupervised training, and/or reinforcement learning) to predict metadata tags based on raw pixels. That is, the first machine learning model of the pre-processing component can electronically receive as input the pixel vector of the electronic image and can electronically produce as output a predicted metadata vector based on the pixel vector. In various cases, the predicted metadata vector generated by the first machine learning model can be considered as representing the Exif tags that the electronic image should have, whereas the metadata vector obtained by the receiver component can be considered as representing the Exif tags that the electronic image actually does have.</p><p id="p-0030" num="0029">In various aspects, the predicted metadata vector can have the same dimensionality as the metadata vector. For example, if the metadata vector includes n Exif tags for any suitable positive integer n, then the first machine learning model can be configured to predict all n of the Exif tags of the electronic image. In various other aspects, the predicted metadata vector can have a smaller dimensionality than the metadata vector. For example, if the metadata vector includes n Exif tags, then the first machine learning model can be configured to predict m of the n Exif tags of the electronic image, for any suitable positive integers m&#x3c;n (e.g., there can be dozens or even hundreds of Exif tags in the metadata vector, and it can be the case that only some of such Exif tags are pertinent to forgery detection; accordingly, the first machine learning model can be configured/trained to predict the values of only those pertinent Exif tags).</p><p id="p-0031" num="0030">In various instances, the pre-processing component can then compute the consistency vector based on the predicted metadata vector and the metadata vector. As an example, the consistency vector can be obtained by concatenating the predicted metadata vector with the metadata vector. As another example, the predicted metadata vector can, in some cases, be subtracted from the metadata vector (e.g., if the predicted metadata vector includes m elements, it can be subtracted from the corresponding m elements of the metadata vector, leaving the remaining n-m elements of the metadata vector unchanged), and such difference can be concatenated with the metadata vector, thereby yielding the consistency vector.</p><p id="p-0032" num="0031">In such one or more first embodiments, the first machine learning model of the pre-processing component can exhibit any suitable artificial intelligence architecture. For example, in some cases, the first machine learning model can be a one-vs-rest classifier. In various other cases, the first machine learning model can exhibit any other suitable architecture (e.g., deep learning architecture including any suitable number of layers, any suitable numbers of neurons in various layers, any suitable activation functions in various neurons, and/or any suitable interneuron connectivity patterns).</p><p id="p-0033" num="0032">In such one or more first embodiments, the first machine learning model can be trained in any suitable fashion to predict metadata vectors based on pixel vectors. For example, a training dataset can comprise a set of training pixel vectors and set of ground truth metadata vectors that respectively correspond to the set of training pixel vectors. In various instances, the first machine learning model can have randomly initialized parameters (e.g., weights, biases). In various cases, the first machine learning model can receive as input a training pixel vector and can generate output based on the training pixel vector. In various aspects, the parameters of the first machine learning model can be iteratively updated via backpropagation based on an error between the output and a ground truth metadata vector corresponding to the inputted training pixel vector. When this is performed for each of the training pixel vectors in the set of training pixel vectors, the parameters of the first machine learning model can be iteratively optimized to predict metadata vectors from pixel vectors. Those having ordinary skill in the art will appreciate that such training can be conducted using any suitable number of epochs and/or any suitable batch sizes.</p><p id="p-0034" num="0033">In one or more second embodiments that are alternative to the one or more first embodiments, the first machine learning model of the pre-processing component can be configured and/or trained (e.g., via supervised training, unsupervised training, and/or reinforcement learning) to generate embedded representations based on raw pixels. More specifically, there can be a set of training pixel vectors that respectively correspond to a set of ground truth metadata vectors. In various aspects, the first machine learning model of the pre-processing component can be a triplet network, and the triplet network can be trained, via a triplet loss technique, to generate embeddings based on the set of training pixel vectors. That is, the first machine learning model can be configured to receive as input a training pixel vector and to produce as output a training embedding that represents the training pixel vector. In various cases, the training embedding can be any suitable vectorial representation of the training pixel vector that has fewer dimensions/elements than the training pixel vector. In various aspects, the first machine learning model can generate a training embedding for each training pixel vector in the set of training pixel vectors, thereby yielding a set of training embeddings that respectively correspond to the set of training pixel vectors.</p><p id="p-0035" num="0034">Since triplet loss can be utilized to train the first machine learning model, the Euclidean distances between two different training embeddings in the set of training embeddings can be related to the ground truth metadata vectors of the two different training pixel vectors that correspond to the two different training embeddings. For instance, if two training pixel vectors are known to have similar ground truth metadata vectors, the two training embeddings of those two training pixel vectors can be close to and/or near each other (e.g., can be separated by a Euclidean distance that is below any suitable threshold). On the other hand, if two training pixel vectors are known to have dissimilar ground truth metadata vectors, the two training embeddings of those two training pixel vectors can be far from and/or not near each other (e.g., can be separated by a Euclidean distance that is above any suitable threshold). In other words, the first machine learning model can be trained to assign embeddings to pixel vectors, where the embeddings of pixel vectors tend to be close to each other when the pixel vectors have similar metadata vectors, and where the embeddings of pixel vectors tend to be far from each other when the pixel vectors have dissimilar metadata vectors.</p><p id="p-0036" num="0035">As mentioned above, the set of training pixel vectors can respectively correspond to a set of ground truth metadata vectors. Since the set of training embeddings generated by the first machine learning model can likewise respectively correspond to the set of training pixel vectors, the set of ground truth metadata vectors can be considered as respectively corresponding to the set of training embeddings. In various instances, each of the set of training embeddings can be concatenated with a respective one of the set of ground truth metadata vectors, with the result being a set of concatenated vectors. In various aspects, the pre-processing component can electronically apply and/or otherwise fit a multivariate Gaussian mixture model to the set of concatenated vectors. Such application of the Gaussian mixture model can cause the pre-processing component to iteratively identify the parameters (e.g., centroid, covariance) of two different Gaussian distributions within the set of concatenated vectors, where a first Gaussian distribution represents authentic concatenated vectors, and where a second Gaussian distribution represents forged concatenated vectors.</p><p id="p-0037" num="0036">Now, consider again the pixel vector and the metadata vector obtained by the receiver component. In various cases, the pre-processing component can feed the pixel vector to the first machine learning model of the one or more second embodiments, thereby causing the first machine learning model to generate an embedding that represents the pixel vector. In various instances, the pre-processing component can concatenate the embedding with the metadata vector, thereby yielding a concatenated vector. In various aspects, the pre-processing component can then utilize the Gaussian mixture model that was fitted to the training data of the first machine learning model, so as to identify a first posterior probability that the concatenated vector belongs to the first Gaussian distribution (e.g., a likelihood that the concatenated vector is authentic), and so as to identify a second posterior probability that the concatenated vector belongs to the second Gaussian distribution (e.g., a likelihood that the concatenated vector is forged). In various cases, the two posterior probabilities can be formatted together as one posterior probabilities vector. In various aspects, the pre-processing component can concatenate the posterior probabilities vector with the metadata vector, and the result of such concatenation can be considered as the consistency vector.</p><p id="p-0038" num="0037">In any case, the pre-processing component can utilize the first machine learning model to generate the consistency vector based on the pixel vector and the metadata vector, where the consistency vector contains information that captures how consistent and/or inconsistent the pixel vector is with the metadata vector. Indeed, as mentioned above, in the one or more first embodiments, the first machine learning model can predict what the metadata vector should look like based on the pixel vector, and the consistency vector can be computed based on the predicted metadata vector and the metadata vector. As also mentioned above, in the one or more second embodiments, the first machine learning model can generate an embedding based on the pixel vector, the embedding can be concatenated with the metadata vector, posteriors of the concatenation can be computed based on a Gaussian mixture model that has been fitted to the training data of the first machine learning model, and the consistency vector can be computed based on the posteriors and the metadata vector.</p><p id="p-0039" num="0038">In various embodiments, the forgery component of the computerized tool can electronically determine, via a second machine learning model, whether the electronic image is forged or authentic, based on the consistency vector generated by the pre-processing component. That is, the second machine learning model can be trained and/or configured to receive as input the consistency vector and to produce as output an authenticity classification, where the authenticity classification indicates that the electronic image is authentic or forged. In various aspects, the second machine learning model can exhibit any suitable machine learning architecture (e.g., can be a deep learning model that includes any suitable number of layers, any suitable numbers of neurons in various layers, any suitable activation functions in various neurons, and/or any suitable interneuron connectivity patterns). As a specific non-limiting example, the second machine learning model can be an XGBoost classifier trained via supervised training.</p><p id="p-0040" num="0039">In various embodiments, the transmitter component of the computerized tool can electronically generate a validation message based on the authenticity classification generated by the forgery component. For example, if the authenticity classification indicates that the electronic image is authentic, the validation message can indicate that the electronic image has been successfully validated. On the other hand, if the authenticity classification indicates that the electronic image is forged, the validation message can indicate that the electronic image has failed to be successfully validated. In any case, the transmitter component can electronically transmit the validation message to the client device and/or the data structure from which the electronic image was obtained by the receiver component. In various instances, the transmitter component can electronically transmit the validation message to any other suitable computing device as desired.</p><p id="p-0041" num="0040">Accordingly, the computerized tool as described herein can electronically leverage both raw pixel data of an electronic image and Exif metadata of the electronic image, so as to determine whether the electronic image is authentic or forged. Note that the computerized tool can accurately detect forgery even in the presence of malicious modification of the metadata vector of the electronic image. Specifically, the consistency vector generated by the pre-processing component can be considered as containing information regarding what the metadata vector actually is, and, due to the functionalities of the pre-processing component, the consistency vector can further be considered as containing information regarding what the metadata vector should be given the pixel vector. Thus, if a forger attempts to evade detection by maliciously editing the metadata vector, the consistency vector can reveal and/or otherwise contain indications of such malicious editing, and the computerized tool can accordingly determine that the electronic image is forged. In stark contrast, as explained above, existing automated techniques simply cannot detect forgery in the presence of such malicious editing of the metadata vector.</p><p id="p-0042" num="0041">Various embodiments described herein can be employed to use hardware and/or software to solve problems that are highly technical in nature (e.g., to facilitate image forgery detection via pixel-metadata consistency analysis), that are not abstract and that cannot be performed as a set of mental acts by a human. Further, some of the processes performed can be performed by a specialized computer (e.g., trained machine learning models such as artificial neural networks, one-vs-rest classifiers, XGBoost models, Gaussian mixture models) for carrying out defined tasks related to image forgery detection via pixel-metadata consistency analysis.</p><p id="p-0043" num="0042">For example, some defined tasks of various embodiments described herein can include: accessing, by a device operatively coupled to a processor, an electronic image provided by a client device; identifying, by the device, a pixel vector and a metadata vector that correspond to the electronic image; and labeling, by the device, the electronic image as authentic or forged, based on analyzing the pixel vector and the metadata vector via at least one artificial intelligence algorithm.</p><p id="p-0044" num="0043">In various cases, such defined tasks can further include: executing, by the device, a first trained artificial intelligence algorithm on the pixel vector, wherein the first trained artificial intelligence algorithm generates a predicted metadata vector based on the pixel vector; concatenating, by the device, the predicted metadata vector with the metadata vector, thereby yielding a concatenated vector; and executing, by the device, a second trained artificial intelligence algorithm on the concatenated vector, wherein the second trained artificial intelligence algorithm classifies the electronic image as authentic or forged based on the concatenated vector.</p><p id="p-0045" num="0044">In various other cases, such defined tasks can further include: executing, by the device, a first trained artificial intelligence algorithm on the pixel vector, wherein the first trained artificial intelligence algorithm generates an embedding based on the pixel vector; concatenating, by the device, the embedding with the metadata vector, thereby yielding a first concatenated vector; applying, by the device, a Gaussian mixture model to the first concatenated vector, thereby yielding a vector of posterior probabilities; concatenating, by the device, the vector of posterior probabilities with the metadata vector, thereby yielding a second concatenated vector; and executing, by the device, a second trained artificial intelligence algorithm on the second concatenated vector, wherein the second trained artificial intelligence algorithm classifies the electronic image as authentic or forged based on the second concatenated vector.</p><p id="p-0046" num="0045">Such defined tasks are not performed manually by humans. Indeed, neither the human mind nor a human with pen and paper can electronically retrieve an electronic image from a client device, and/or electronically determine whether the electronic image is authentic or forged by electronically executing artificial intelligence algorithms and/or Gaussian mixture models on a pixel vector and a metadata vector of the electronic image. Instead, various embodiments described herein are inherently and inextricably tied to computer technology and cannot be implemented outside of a computing environment. Specifically, various embodiments can be considered as a computerized tool that utilizes machine learning models to analyze both raw pixel data and embedded metadata of an electronic image, so as to automatically infer whether the electronic image is forged. Such a computerized tool cannot be practicably implemented in any sensible way by human beings without computers.</p><p id="p-0047" num="0046">In various instances, embodiments described herein can integrate into a practical application the disclosed teachings regarding image forgery detection via pixel-metadata consistency analysis. Indeed, in various embodiments, the disclosed teachings can provide a computerized tool that can automatically evaluate the validity of an electronic image (e.g., an image of a driver's license, a passport, a visa) based on both the raw pixels of the electronic image and the Exif metadata appended to the electronic image. Specifically, the computerized tool can electronically receive and/or identify a pixel vector of the electronic image and an Exif metadata vector of the electronic image. In various cases, the computerized tool can, via a first machine learning model, electronically generate a consistency vector based on both the pixel vector and the Exif metadata vector. In some embodiments, the first machine learning model can predict what the Exif metadata should be based on the pixel vector, and such predicted Exif metadata can be concatenated with the actual Exif metadata vector of the electronic image, thereby yielding the consistency vector. In other embodiments, the first machine learning model can generate an embedding based on the pixel vector, the embedding can be concatenated with the Exif metadata vector of the electronic image, posteriors of the concatenation can be computed based on a Gaussian mixture model that has been fitted to data used to train the first machine learning model, and such posteriors can be concatenated with the Exif metadata vector of the electronic image, thereby yielding the consistency vector. Once the consistency vector is computed, the computerized tool can generate, via a second machine learning model, a binary authenticity classification based on the consistency vector. In various cases, the computerized tool can then take action based on the outputted authenticity classification (e.g., can transmit a failure and/or success message based on the classification, can permit and/or restrict access to sensitive data based on the classification). Such a computerized tool that can automatically evaluate the authenticity of an electronic image is certainly a useful and/or practical application of computers. Furthermore, in stark contrast to existing techniques, such a computerized tool can accurately detect forgery even when the Exif metadata vector of the electronic image has been maliciously edited by forgers in an attempt to evade detection. Because existing techniques do not rely on both raw pixel data and Exif metadata as described herein, they cannot detect forgery when the Exif metadata vector has been maliciously edited. Accordingly, the computerized tool as described herein constitutes a concrete and tangible technical improvement in the field of image forgery detection.</p><p id="p-0048" num="0047">Moreover, in various aspects, embodiments described herein can control real-world and/or tangible devices based on the disclosed teachings. For example, a computerized tool as described herein can electronically evaluate the authenticity of a real-world, tangible proof-of-identity document (e.g., a driver's license, a passport, a birth certificate) that is depicted in an electronic image via pixel-metadata consistency analysis, can electronically render successful validation messages and/or unsuccessful validation messages on any suitable computer screen/monitor based on the evaluated authenticity, and/or can grant and/or deny access to protected data based on the evaluated authenticity.</p><p id="p-0049" num="0048">It should be appreciated that the figures described herein are non-limiting examples of various embodiments.</p><p id="p-0050" num="0049"><figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates a high-level block diagram of an example, non-limiting system <b>100</b> that can facilitate image forgery detection via pixel-metadata consistency analysis in accordance with one or more embodiments described herein.</p><p id="p-0051" num="0050">As shown, a pixel-metadata consistency system <b>102</b> can be electronically integrated, via any suitable wired and/or wireless electronic connection, with a client device <b>104</b>. In various cases, the client device <b>104</b> can be any suitable computing device that can electronically capture and/or otherwise electronically store an image <b>106</b>. As some non-limiting examples, the client device <b>104</b> can be a desktop computer operated by any suitable client and/or entity (e.g., human and/or otherwise), a laptop computer operated by any suitable client and/or entity, and/or a smart phone operated by any suitable client and/or entity.</p><p id="p-0052" num="0051">In various aspects, the image <b>106</b> can be any suitable electronic image. In some cases, the image <b>106</b> can depict a proof-of-identity document, such as a driver's license of the client and/or entity that operates the client device <b>104</b>, a passport of the client and/or entity that operates the client device <b>104</b>, a birth certificate of the client and/or entity that operates the client device <b>104</b>, a student identification card of the client and/or entity that operates the client device <b>104</b>, an employment identification card of the client and/or entity that operates the client device <b>104</b>, and/or any other suitable document that purports to prove the identity of the client and/or entity that operates the client device <b>104</b> (and/or that purports to prove the identity of any other person and/or entity).</p><p id="p-0053" num="0052">In various instances, the image <b>106</b> can comprise pixel data that is formatted as a pixel vector (e.g., a vector of values exhibited by the pixels of the image <b>106</b>). Accordingly, the dimensionality of the pixel vector can be equal to and/or otherwise based on the number of pixels in the image <b>106</b> (e.g., if the image <b>106</b> has x pixels for any suitable positive integer x, the pixel vector can have x elements, one element per pixel).</p><p id="p-0054" num="0053">Furthermore, in various instances, the image <b>106</b> can comprise and/or otherwise be associated with metadata that is formatted into a metadata vector. In various aspects, the metadata vector can include any suitable number of any suitable Exif tags that pertain to the image <b>106</b> and/or that are otherwise generated by the camera and/or software that captured and/or created the image <b>106</b>. As some non-limiting examples, such metadata tags can include: height of the image <b>106</b>, width of the image <b>106</b>, orientation of the image <b>106</b>, date/time at which the image <b>106</b> was created/captured, date/time that the image <b>106</b> was recently edited, x-resolution of the image <b>106</b>, y-resolution of the image <b>106</b>, make and/or model of camera that captured the image <b>106</b>, software that captured and/or edited the image <b>106</b>, YCbCr positioning of the image <b>106</b>, resolution unit of the image <b>106</b>, aperture value of the camera that captured the image <b>106</b>, scene type of the image <b>106</b>, exposure bias value of the camera that captured the image <b>106</b>, exposure program of the camera that captured the image <b>106</b>, color space of the image <b>106</b>, unique identification number of the image <b>106</b>, maximum aperture value of the camera that captured the image <b>106</b>, brightness value of the image <b>106</b>, white balance mode of the camera that captured the image <b>106</b>, exposure mode of the camera that captured the image <b>106</b>, exposure time of the camera that captured the image <b>106</b>, whether flash was used by the camera that captured the image <b>106</b>, F-number of the camera that captured the image <b>106</b>, and/or ISO speed of the camera that captured the image <b>106</b>. The aforementioned are mere non-limiting examples of Exif metadata tags that can be included in the metadata vector of the image <b>106</b>. Those having ordinary skill in the art will appreciate that any other suitable metadata information (e.g., Exif metadata information and/or non-Exif metadata information), can be included in the metadata vector in various instances.</p><p id="p-0055" num="0054">In various aspects, it can be desired to determine whether the image <b>106</b> is authentic or forged. That is, it can be desired to infer whether some entity, such as the client and/or entity that operates the client device <b>104</b>, has tampered with and/or otherwise edited the image <b>106</b>. As described herein, the pixel-metadata consistency system <b>102</b> can facilitate such forgery detection.</p><p id="p-0056" num="0055">In various embodiments, the pixel-metadata consistency system <b>102</b> can comprise a processor <b>108</b> (e.g., computer processing unit, microprocessor) and a computer-readable memory <b>110</b> that is operably coupled to the processor <b>108</b>. The memory <b>110</b> can store computer-executable instructions which, upon execution by the processor <b>108</b>, can cause the processor <b>108</b> and/or other components of the pixel-metadata consistency system <b>102</b> (e.g., receiver component <b>112</b>, pre-processing component <b>114</b>, forgery component <b>116</b>, transmitter component <b>118</b>) to perform one or more acts. In various embodiments, the memory <b>110</b> can store computer-executable components (e.g., receiver component <b>112</b>, pre-processing component <b>114</b>, forgery component <b>116</b>, transmitter component <b>118</b>), and the processor <b>108</b> can execute the computer-executable components.</p><p id="p-0057" num="0056">In various embodiments, the pixel-metadata consistency system <b>102</b> can comprise a receiver component <b>112</b>. In some cases, the receiver component <b>112</b> can electronically retrieve and/or otherwise electronically access the image <b>106</b> from the client device <b>104</b>, such that the receiver component <b>112</b> can identify and/or obtain the pixel vector of the image <b>106</b> and the metadata vector of the image <b>106</b>. In some other cases, the receiver component <b>112</b> can electronically retrieve and/or otherwise electronically access the image <b>106</b> from any suitable centralized and/or decentralized data structure (not shown), whether remote from and/or local to the receiver component <b>112</b>, such that the receiver component <b>112</b> can identify and/or obtain the pixel vector of the image <b>106</b> and the metadata vector of the image <b>106</b>. In any case, the receiver component <b>112</b> can have electronic access to the pixel vector of the image <b>106</b> and to the metadata vector of the image <b>106</b>, such that other components of the pixel-metadata consistency system <b>102</b> can manipulate, analyze, and/or otherwise interact with the pixel vector and/or the metadata vector.</p><p id="p-0058" num="0057">In various embodiments, the pixel-metadata consistency system <b>102</b> can comprise a pre-processing component <b>114</b>. In various aspects, the pre-processing component <b>114</b> can electronically generate a consistency vector based on both the pixel vector and the metadata vector. In various instances, the consistency vector can be considered as containing information that conveys a level of consistency and/or inconsistency between the pixel vector and the metadata vector. In other words, the consistency vector can, in some cases, be considered as indicating whether, given the pixel vector, the metadata vector is as expected or is not as expected. To facilitate generation of the consistency vector, the pre-processing component <b>114</b> can leverage a first machine learning model. In various cases, the pre-processing component <b>114</b> can leverage the first machine learning model in at least two alternative fashions so as to compute the consistency vector.</p><p id="p-0059" num="0058">In one or more first embodiments, the first machine learning model can a one-vs-rest classifier that is trained and/or configured to predict image metadata based on image pixel data. In other words, the pre-processing component <b>114</b> can electronically input the pixel vector of the image <b>106</b> into the first machine learning model, and the first machine learning model can electronically produce as output a predicted metadata vector based on the pixel vector. In various instances, the predicted metadata vector can be considered as the metadata (e.g., the Exif tags) that the first machine learning model concludes that the image <b>106</b> should have, while the metadata vector received by the receiver component <b>112</b> can be considered as the metadata (e.g., the Exif tags) that the image <b>106</b> actually does have. In various aspects, the pre-processing component <b>114</b> can electronically compute the consistency vector based on the predicted metadata vector and the metadata vector. For example, the consistency vector can, in some cases, be equal to a concatenation of the predicted metadata vector and the metadata vector. As another example, the consistency vector can, in some cases, be equal to a concatenation of the metadata vector and a difference between the predicted metadata vector and the metadata vector. In any case, the consistency vector can include and/or contain information regarding what the metadata of the image <b>106</b> actually is and what the metadata of the image <b>106</b> should be.</p><p id="p-0060" num="0059">In one or more second embodiments, the first machine learning model can be a triplet network that is trained and/or configured to generate embedded representations based on image pixel data. In other words, there can be a set of training images, with each training image comprising a training pixel vector, a training metadata vector, and a ground truth authenticity label. In various cases, the first machine learning model can be trained on the training pixel vectors and the ground truth authenticity labels to generate embeddings. That is, the first machine learning model can receive as input a training pixel vector and can produce as output an embedding (e.g., any suitable vector) based on the training pixel vector. Because the first machine learning model can be a triplet network and can thus be trained via a triplet loss technique, the first machine learning model can respectively generate two different embeddings for two different training pixel vectors, where such two different embeddings can tend to be separated by a small (e.g., less than any suitable threshold value) Euclidean distance if the two different training pixel vectors have similar and/or the same ground truth metadata vectors, and where such two different embeddings can tend to be separated by a large (e.g., greater than any suitable threshold value) Euclidean distance if the two different training pixel vectors have dissimilar and/or very different ground truth metadata vectors. Once trained, the first machine learning model can generate an embedding for each training pixel vector. Moreover, each of such embeddings can be concatenated with a corresponding training metadata vector. In various aspects, a Gaussian mixture model can be applied and/or fitted to such concatenations, so as to identify centroids and/or covariances of two different Gaussian distributions: a first Gaussian distribution representing authentic images in the set of training images, and a second Gaussian distribution representing forged images in the set of training images.</p><p id="p-0061" num="0060">Accordingly, in various aspects, the pre-processing component <b>114</b> can electronically input the pixel vector of the image <b>106</b> into the first machine learning model, and the first machine learning model can electronically produce as output an embedding based on the pixel vector. In various instances, the pre-processing component <b>114</b> can concatenate the embedding with the metadata vector of the image <b>106</b>. In various cases, the pre-processing component <b>114</b> can then leverage the Gaussian mixture model mentioned above to compute posterior probabilities for the concatenation. Specifically, the pre-processing component <b>114</b> can compute a first posterior probability indicating a likelihood that the concatenation belongs to the first Gaussian distribution (e.g., indicating a likelihood that the image <b>106</b> is authentic), and the pre-processing component <b>114</b> can compute a second posterior probability indicating a likelihood that the concatenation belongs to the second Gaussian distribution (e.g., indicating a likelihood that the image <b>106</b> is forged). In various aspects, the first posterior probability and the second posterior probability can be formatted together into a single posterior probabilities vector (e.g., a vector having two scalar elements). In various instances, the pre-processing component <b>114</b> can electronically compute the consistency vector based on the posterior probabilities vector and the metadata vector. For example, the consistency vector can, in some cases, be equal to a concatenation of the posterior probabilities vector and the metadata vector.</p><p id="p-0062" num="0061">In various embodiments, the pixel-metadata consistency system <b>102</b> can comprise a forgery component <b>116</b>. In various aspects, the forgery component <b>116</b> can electronically determine, via a second machine learning model, whether the image <b>106</b> is authentic or forged, based on the consistency vector generated by the pre-processing component <b>114</b>. More specifically, the second machine learning model can be an XGBoost model that is trained and/or otherwise configured to infer image authenticity based on consistency vectors. Accordingly, in various instances, the forgery component <b>116</b> can electronically feed the consistency vector generated by the pre-processing component <b>114</b> as input to the second machine learning model, and the second machine learning model can electronically produce as output an authenticity classification that labels the image <b>106</b> as authentic or that labels the image <b>106</b> as forged. As mentioned above, the forgery component <b>116</b> can accurately classify the authenticity of the image <b>106</b>, even if the metadata vector of the image <b>106</b> has been maliciously tampered with (e.g., the first machine learning model as described herein can enable the consistency vector to include an indication of not just what the metadata of the image <b>106</b> actually is, but also an indication of what the metadata of the image <b>106</b> should be).</p><p id="p-0063" num="0062">In various embodiments, the pixel-metadata consistency system <b>102</b> can comprise a transmitter component <b>118</b>. In various aspects, the transmitter component <b>118</b> can electronically generate, in any suitable fashion, an authenticity report/notification that indicates and/or communicates the resulting authenticity classification determined by the forgery component <b>116</b>. In various cases, the transmitter component <b>118</b> can electronically transmit the authenticity report/notification to the client device <b>104</b>. In various other cases, the transmitter component <b>118</b> can electronically transmit the authenticity report/notification to any other suitable computing device (not shown), as desired.</p><p id="p-0064" num="0063"><figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates a high-level block diagram of an example, non-limiting system <b>200</b> including a pixel vector and a metadata vector that can facilitate image forgery detection via pixel-metadata consistency analysis in accordance with one or more embodiments described herein. As shown, the system <b>200</b> can, in some cases, comprise the same components as the system <b>100</b>, and can further comprise a pixel vector <b>202</b> and/or a metadata vector <b>204</b>.</p><p id="p-0065" num="0064">In various embodiments, the receiver component <b>112</b> can electronically receive the pixel vector <b>202</b> and/or the metadata vector <b>204</b> from the client device <b>104</b> (and/or from any other suitable computing device, not shown), where the pixel vector <b>202</b> and the metadata vector <b>204</b> can collectively define the image <b>106</b>. In various aspects, the pixel vector <b>202</b> can be a vector of any suitable dimensionality, the elements of which are scalars that represent the pixels of the image <b>106</b>. That is, the elements of the pixel vector <b>202</b> can be respective pixel values of the image <b>106</b>. In various instances, the metadata vector <b>204</b> can be a vector of any suitable dimensionality, the elements of which are scalars, vectors, matrices, tensors, and/or character strings that represent metadata tags of the image <b>106</b>. As an example, the metadata vector <b>204</b> can be an Exif vector. That is, the elements of the metadata vector <b>204</b> can be Exif attributes of the image <b>106</b>. As mentioned above, non-limiting examples of such Exif attributes can include: image height, image width, image orientation, date/time of creation/capture, date/time of editing, x/y resolution, camera make and/or camera model, editing software, YCbCr positioning, aperture value, maximum aperture value, exposure bias value, exposure program, color space, unique identification number, brightness value, white balance mode, exposure mode, exposure time, flash enabled, F-number, and/or ISO speed. It is to be understood that these are mere non-limiting examples of Exif metadata tags that can be included in the metadata vector <b>204</b>. Those having ordinary skill in the art will appreciate that any other suitable metadata information (e.g., Exif metadata information and/or non-Exif metadata information), can be included in the metadata vector <b>204</b>.</p><p id="p-0066" num="0065"><figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates a high-level block diagram of an example, non-limiting system <b>300</b> including a machine learning model and a consistency vector that can facilitate image forgery detection via pixel-metadata consistency analysis in accordance with one or more embodiments described herein. As shown, the system <b>300</b> can, in some cases, comprise the same components as the system <b>200</b>, and can further comprise a machine learning model <b>302</b> and/or a consistency vector <b>304</b>.</p><p id="p-0067" num="0066">In various embodiments, the pre-processing component <b>114</b> can electronically control, operate, and/or maintain the machine learning model <b>302</b>. In various instances, the machine learning model <b>302</b> can exhibit any suitable artificial intelligence architecture (e.g., deep learning model, support vector machine, regression model, ensemble model). In various cases, the pre-processing component <b>114</b> can electronically utilize the machine learning model <b>302</b> to generate the consistency vector <b>304</b>, based on both the pixel vector <b>202</b> and the metadata vector <b>204</b>. In various cases, the consistency vector <b>304</b> can be a vector of any suitable dimensionality, the elements of which collectively indicate how consistent and/or how inconsistent the metadata vector <b>204</b> is with the pixel vector <b>202</b>. In various aspects, there are at least two alternative and non-limiting ways in which the pre-processing component <b>114</b> can generate the consistency vector <b>304</b> via the machine learning model <b>302</b>. These two alternative and non-limiting ways are respectively described with respect to <figref idref="DRAWINGS">FIGS. <b>4</b>-<b>5</b></figref>.</p><p id="p-0068" num="0067"><figref idref="DRAWINGS">FIG. <b>4</b></figref> illustrates an example, non-limiting block diagram <b>400</b> showing how a machine learning model can be leveraged to generate a consistency vector based on a pixel vector and a metadata vector in accordance with one or more embodiments described herein. In other words, <figref idref="DRAWINGS">FIG. <b>4</b></figref> depicts a first example and non-limiting way in which the machine learning model <b>302</b> can be leveraged to generate the consistency vector <b>304</b> based on both the pixel vector <b>202</b> and the metadata vector <b>204</b>.</p><p id="p-0069" num="0068">In various embodiments that pertain to <figref idref="DRAWINGS">FIG. <b>4</b></figref>, the machine learning model <b>302</b> can be a one-vs-rest classifier that can be trained and/or otherwise configured to predict one or more metadata tags for an electronic image, based on raw pixel data of the electronic image. For example, consider a training dataset that comprises k training images, for any suitable positive integer k. In various instances, each of the training images can include a respectively corresponding training pixel vector, a respectively corresponding training metadata vector, and/or a respectively corresponding ground truth authenticity label. So, there can be k training pixel vectors, k training metadata vectors, and/or k ground truth authenticity labels, all respectively corresponding to each other.</p><p id="p-0070" num="0069">In various aspects, the internal parameters (e.g., weights, biases) of the machine learning model <b>302</b> can be randomly initialized. In various instances, for any given training pixel vector, the machine learning model <b>302</b> can receive as input the given training pixel vector and can produce as output a given predicted metadata vector that is based on the given training pixel vector. In various cases, the given predicted metadata vector can be considered as representing the metadata tags (e.g., Exif tags) which the machine learning model <b>302</b> believes that the given training pixel vector should have. However, when the machine learning model <b>302</b> has undergone no and/or little training, the given predicted metadata vector can be inaccurate. Accordingly, an error and/or loss can be computed between the given predicted metadata vector and a given training metadata vector that respectively corresponds to the given training pixel vector. In various aspects, such error and/or loss can be used to update the internal parameters of the machine learning model <b>302</b> through backpropagation. In various cases, this training procedure can be repeated for each of the k training pixel vectors, with the result being that the internal parameters of the machine learning model <b>302</b> can be iteratively optimized.</p><p id="p-0071" num="0070">After such training, the pre-processing component <b>114</b> can, in some aspects as shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref>, electronically feed the pixel vector <b>202</b> to the machine learning model <b>302</b>. In various instances, this can cause the machine learning model <b>302</b> to electronically generate as output a predicted metadata vector <b>402</b>. In various cases, the predicted metadata vector <b>402</b> can be considered as representing the Exif metadata tags which the machine learning model <b>302</b> believes should correspond to the pixel vector <b>202</b>. In other words, the predicted metadata vector <b>402</b> can be the Exif metadata tags which the image <b>106</b> should have. In various cases, the predicted metadata vector <b>402</b> can have the same dimensionality as the metadata vector <b>204</b> (e.g., the machine learning model <b>302</b> can be trained/configured to estimate values for all of the Exif metadata fields included in the metadata vector <b>204</b>, such that the predicted metadata vector <b>402</b> and the metadata vector <b>204</b> have the same number of elements). In various other cases, the predicted metadata vector <b>402</b> can have a smaller dimensionality than the metadata vector <b>204</b> (e.g., the machine learning model <b>302</b> can be trained/configured to estimate values for fewer than all of the Exif metadata fields included in the metadata vector <b>204</b>, such that the predicted metadata vector <b>402</b> has fewer elements than the metadata vector <b>204</b>). For instance, suppose that the metadata vector <b>204</b> includes <b>86</b> elements (e.g., <b>86</b> Exif tags). It can be the case that not all of those <b>86</b> elements are pertinent and/or relevant to predicting image forgery. Accordingly, the machine learning model <b>302</b> can be trained/configured to predict/estimate any suitable subset of those <b>86</b> elements when given the pixel vector <b>202</b> (e.g., in some cases, software in which the image <b>106</b> was edited/opened, camera make/model that captured the image <b>106</b>, and/or time/date of creation/editing of the image <b>106</b> can be considered as some Exif metadata tags that are most predictive of forgery, and so the machine learning model <b>302</b> can be configured to estimate those Exif metadata tags and not other Exif metadata tags).</p><p id="p-0072" num="0071">In any case, as shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref>, the pre-processing component <b>114</b> can electronically compute the consistency vector <b>304</b> based on the predicted metadata vector <b>402</b> and the metadata vector <b>204</b>. For example, the consistency vector <b>304</b> can be equal to a concatenation of the predicted metadata vector <b>402</b> and the metadata vector <b>204</b> (e.g., concatenating the predicted metadata vector <b>402</b> with the metadata vector <b>204</b> can yield the consistency vector <b>304</b>). As another example, the predicted metadata vector <b>402</b> can be subtracted from the metadata vector <b>204</b> to yield a difference vector, and the consistency vector <b>304</b> can be equal to a concatenation of the difference vector and the metadata vector <b>204</b> (e.g., subtracting the predicted metadata vector <b>402</b> from the metadata vector <b>204</b> and concatenating such difference with the metadata vector <b>204</b> can yield the consistency vector <b>304</b>). In various instances, the consistency vector <b>304</b> can be any other suitable function of the predicted metadata vector <b>402</b> and the metadata vector <b>204</b>.</p><p id="p-0073" num="0072">Although the above discussion indicates that the machine learning model <b>302</b> can be a one-vs-rest classifier, this is a mere non-limiting example. Those having ordinary skill in the art will appreciate that the machine learning model <b>302</b> can, in various cases, exhibit any other suitable machine learning architecture that can be trained/configured to predict metadata from raw pixel data.</p><p id="p-0074" num="0073"><figref idref="DRAWINGS">FIG. <b>5</b></figref> illustrates an example, non-limiting block diagram <b>500</b> showing how a machine learning model and a Gaussian mixture model can be leveraged to generate a consistency vector based on a pixel vector and a metadata vector in accordance with one or more embodiments described herein. In other words, <figref idref="DRAWINGS">FIG. <b>5</b></figref> depicts a second example and non-limiting way in which the machine learning model <b>302</b> can be leveraged to generate the consistency vector <b>304</b> based on both the pixel vector <b>202</b> and the metadata vector <b>204</b>.</p><p id="p-0075" num="0074">In various embodiments that pertain to <figref idref="DRAWINGS">FIG. <b>5</b></figref>, the machine learning model <b>302</b> can be a triplet network that can be trained and/or otherwise configured to produce embedded representations of an electronic image, based on raw pixel data of the electronic image. For example, consider again a training dataset that comprises k training images, for any suitable positive integer k. As above, each of the training images can include a respectively corresponding training pixel vector, a respectively corresponding training metadata vector, and/or a respectively corresponding ground truth authenticity label. So, there can be k training pixel vectors, k training metadata vectors, and/or k ground truth authenticity labels, all respectively corresponding to each other.</p><p id="p-0076" num="0075">In various aspects, the internal parameters (e.g., weights, biases) of the machine learning model <b>302</b> can be randomly initialized. In various instances, the machine learning model <b>302</b> can be trained via a triplet loss technique to generate embeddings (e.g., vector representations of any suitable dimensionalities) based on inputted pixel vectors. For example, for any first training pixel vector, the machine learning model <b>302</b> can receive as input the first training pixel vector and can produce as output a first embedding (e.g., a vector) that is based on the first training pixel vector. Next, the machine learning model can receive a second training pixel vector that is known to correspond to a ground truth metadata vector that is similar to and/or the same as that of the first training pixel vector, and the machine learning model <b>302</b> can produce a second embedding based on the second training pixel vector. Furthermore, the machine learning model can receive a third training pixel vector that is known to correspond to a ground truth metadata vector that is dissimilar to and/or highly different from that of the first training pixel vector, and the machine learning model <b>302</b> can produce a third embedding based on the third training pixel vector.</p><p id="p-0077" num="0076">At this point, a first error/loss can be computed between the first embedding and the second embedding, and a second error/loss can be computed between the first embedding and the third embedding. Since the first training pixel vector and the second training pixel vector have similar and/or the same ground truth metadata vectors, it can be desired that the first error/loss is minimized. That is, it can desired that the first embedding and the second embedding are close, near, and/or similar to each other. On the other hand, since the first training pixel vector and the third training pixel vector have very different and/or dissimilar ground truth metadata vectors, it can be desired that the second error/loss is maximized. That is, it can desired that the first embedding and the third embedding are far and/or different from each other. Thus, the first error/loss and the second error/loss can be used to facilitate backpropagation, so as to update the internal parameters of the machine learning model <b>302</b>. In various cases, this training procedure can be repeated for each of the k training pixel vectors, with the result being that the internal parameters of the machine learning model <b>302</b> can be iteratively optimized to generate embeddings based on pixel vectors.</p><p id="p-0078" num="0077">At this point, the machine learning model <b>302</b> can be considered as fully trained. In various instances, the machine learning model <b>302</b> can then generate an embedding for each of the k training pixel vectors, thereby yielding k embeddings. Since triplet loss can be used to train the machine learning model <b>302</b> as described above, those of the k embeddings that are near (e.g., in terms of Euclidean distance) to each other can be considered as likely to correspond to the same ground truth authenticity label, whereas those of the k embeddings that are far (e.g., in terms of Euclidean distance) from each other can be considered as likely to correspond to different ground truth authenticity labels. In various aspects, each of the k embeddings can then be concatenated with a respectively corresponding one of the k metadata vectors, thereby yielding k concatenated vectors.</p><p id="p-0079" num="0078">In various cases, a Gaussian mixture model <b>506</b> can be applied to the k concatenated vectors. As those having ordinary skill in the art will appreciate, when given a total set of data, multivariate Gaussian mixture modeling can be considered as a mathematical techniques for iteratively identifying (e.g., such as via expectation maximization) the parameters of multiple constituent Gaussian distributions that make up the total set of data. In this case, the Gaussian mixture model <b>506</b> can be applied to the k concatenations, and the result can be the estimation of the parameters (e.g., centroid and/or covariance) of two different Gaussians to which the k concatenations collectively belong. In various cases, a first Gaussian of the two different Gaussians can be considered as representing those of the k concatenations that are authentic (e.g., that correspond to ground truth authenticity labels that indicate authentic and/or not forged). In various cases, a second Gaussian of the two different Gaussians can be considered as representing those of the k concatenations that are forged (e.g., that correspond to ground truth authenticity labels that indicate forged and/or not authentic). In any case, once the Gaussian mixture model <b>506</b> is applied to the k concatenations, the centroids and/or covariances of both the first and second Gaussians can be estimated and/or known.</p><p id="p-0080" num="0079">At this point, the pre-processing component <b>114</b> can, in some aspects as shown in <figref idref="DRAWINGS">FIG. <b>5</b></figref>, electronically feed the pixel vector <b>202</b> to the machine learning model <b>302</b>. In various instances, this can cause the machine learning model <b>302</b> to electronically generate as output an embedding <b>502</b>. In various cases, the embedding <b>502</b> can be considered as a vector that represents the pixel vector <b>202</b>. In various cases, the embedding <b>502</b> can have any suitable dimensionality that is lesser than the dimensionality of the pixel vector <b>202</b>. In various aspects, as shown in <figref idref="DRAWINGS">FIG. <b>5</b></figref>, the pre-processing component <b>114</b> can electronically compute a concatenated vector <b>504</b> based on the embedding <b>502</b> and the metadata vector <b>204</b>. That is, concatenating the embedding <b>502</b> with the metadata vector <b>204</b> can yield the concatenated vector <b>504</b>.</p><p id="p-0081" num="0080">In various instances, the pre-processing component <b>114</b> can then apply the Gaussian mixture model <b>506</b> to the concatenated vector <b>504</b>, thereby yielding a posterior probabilities vector <b>508</b>. More specifically, as explained above, the Gaussian mixture model <b>506</b> can be fitted to the k concatenations generated by the machine learning model <b>302</b> during training, such that the centroids and/or covariances of the first and second Gaussians are estimated/known. Since the centroids and/or covariances of the first and second Gaussians are estimated/known, the pre-processing component <b>114</b> can compute a first posterior probability indicating a likelihood that the concatenated vector <b>504</b> belongs to the first Gaussian, and the pre-processing component <b>114</b> can also compute a second posterior probability indicating a likelihood that the concatenated vector <b>504</b> belongs to the second Gaussian. These two posterior probabilities can be formatted together as the posterior probabilities vector <b>508</b> (e.g., a first element of the posterior probabilities vector <b>508</b> can be equal to the first posterior probability, and a second element of the posterior probabilities vector <b>508</b> can be equal to the second posterior probability).</p><p id="p-0082" num="0081">In various instances, as shown, the pre-processing component <b>114</b> can then compute the consistency vector <b>304</b> based on the posterior probabilities vector <b>508</b> and the metadata vector <b>204</b>. For example, the consistency vector <b>304</b> can be equal to a concatenation of the posterior probabilities vector <b>508</b> and the metadata vector <b>204</b> (e.g., concatenating the posterior probabilities vector <b>508</b> with the metadata vector <b>204</b> can yield the consistency vector <b>304</b>). In various instances, the consistency vector <b>304</b> can be any other suitable function of the posterior probabilities vector <b>508</b> and the metadata vector <b>204</b>.</p><p id="p-0083" num="0082">Although the above discussion indicates that the machine learning model <b>302</b> can be a triplet network, this is a mere non-limiting example. Those having ordinary skill in the art will appreciate that the machine learning model <b>302</b> can, in various cases, exhibit any other suitable machine learning architecture that can be trained/configured to generate distance-based embeddings from raw pixel data.</p><p id="p-0084" num="0083"><figref idref="DRAWINGS">FIG. <b>6</b></figref> illustrates a high-level block diagram of an example, non-limiting system <b>600</b> including a machine learning model and an authenticity classification that can facilitate image forgery detection via pixel-metadata consistency analysis in accordance with one or more embodiments described herein. As shown, the system <b>600</b> can, in some cases, comprise the same components as the system <b>300</b>, and can further comprise a machine learning model <b>602</b> and/or an authenticity classification <b>604</b>.</p><p id="p-0085" num="0084">In various embodiments, the forgery component <b>116</b> can electronically control, operate, and/or maintain the machine learning model <b>602</b>. In various instances, the machine learning model <b>602</b> can exhibit any suitable artificial intelligence architecture (e.g., deep learning model, support vector machine, regression model, ensemble model). As a non-limiting example, the machine learning model <b>602</b> can be an XGBoost classifier that is trained in a supervised fashion to generate binary authenticity classifications based on consistency vectors as described herein. Accordingly, in various cases, the forgery component <b>116</b> can electronically utilize the machine learning model <b>602</b> to generate the authenticity classification <b>604</b>, based on the consistency vector <b>304</b>. That is, the forgery component <b>116</b> can electronically feed the consistency vector <b>304</b> as input into the machine learning model <b>602</b>, and the machine learning model <b>602</b> can electronically generate as output the authenticity classification <b>604</b>. In various cases, the authenticity classification <b>604</b> can be a binary label that indicates whether the consistency vector <b>304</b>, and thus the image <b>106</b>, is authentic or forged.</p><p id="p-0086" num="0085">Accordingly, the pixel-metadata consistency system <b>102</b> can electronically infer an authenticity status of the image <b>106</b>, by analyzing the pixel vector <b>202</b> and the metadata vector <b>204</b> with the machine learning model <b>302</b> and/or the machine learning model <b>602</b>. Furthermore, note that such authenticity status can be inferred, even if the metadata vector <b>204</b> has undergone malicious editing by a forger/hacker. More specifically, the functionality and/or operations performed by the pre-processing component <b>114</b> can ensure that the consistency vector <b>304</b> not only contains information regarding what Exif metadata the image <b>106</b> actually has (e.g., <b>204</b>), but also contains information regarding what Exif metadata the image <b>106</b> should have, given the pixel vector <b>202</b>. Because the consistency vector <b>304</b> represents what Exif metadata the image <b>106</b> should have, the forgery component <b>116</b> can detect fraud and/or forgery, even when evidence of such fraud/forgery has been maliciously erased from the metadata vector <b>204</b>. This constitutes a significant tangible improvement over existing image forgery detection techniques.</p><p id="p-0087" num="0086"><figref idref="DRAWINGS">FIG. <b>7</b></figref> illustrates a high-level block diagram of an example, non-limiting system <b>700</b> including a validation message that can facilitate image forgery detection via pixel-metadata consistency analysis in accordance with one or more embodiments described herein. As shown, the system <b>700</b> can, in some cases, comprise the same components as the system <b>600</b>, and can further comprise a validation message <b>702</b>.</p><p id="p-0088" num="0087">In various embodiments, the transmitter component <b>118</b> can electronically generate and/or otherwise prepare the validation message <b>702</b> based on the authenticity classification <b>604</b>. That is, the validation message <b>702</b> can include, convey, and/or summarize the authenticity classification <b>604</b>. In other words, the validation message <b>702</b> can be considered as a notification of the authenticity classification <b>604</b>. For instance, if the authenticity classification <b>604</b> indicates that the consistency vector <b>304</b>, and thus the image <b>106</b>, is authentic, the validation message <b>702</b> can indicate that the image <b>106</b> is authentic and/or that the image <b>106</b> has been successfully validated/verified. On the other hand, if the authenticity classification <b>604</b> indicates that the consistency vector <b>304</b>, and thus the image <b>106</b>, is forged, the validation message <b>702</b> can indicate that the image <b>106</b> is forged/fraudulent and/or that the image <b>106</b> has failed to be successfully validated/verified. In various aspects, the transmitter component <b>118</b> can electronically transmit the validation message <b>702</b> to the client device <b>104</b>, and/or to any other suitable computing device (not shown).</p><p id="p-0089" num="0088"><figref idref="DRAWINGS">FIG. <b>8</b></figref> illustrates a high-level flow diagram of an example, non-limiting computer-implemented method <b>800</b> that can facilitate image forgery detection via pixel-metadata consistency analysis in accordance with one or more embodiments described herein. In various cases, the pixel-metadata consistency system <b>102</b> can facilitate the computer-implemented method <b>800</b>.</p><p id="p-0090" num="0089">In various embodiments, act <b>802</b> can include accessing, by a device (e.g., <b>112</b>) operatively coupled to a processor, an electronic image (e.g., <b>106</b>) provided by a computing device (e.g., <b>104</b>).</p><p id="p-0091" num="0090">In various aspects, act <b>804</b> can include identifying, by the device (e.g., <b>112</b>), a pixel vector (e.g., <b>202</b>) and a metadata vector (e.g., <b>204</b>) that correspond to the electronic image.</p><p id="p-0092" num="0091">In various instances, act <b>806</b> can include labeling, by the device (e.g., <b>116</b>), where <b>604</b> can be considered as a label), the electronic image as authentic or forged, based on analyzing (e.g., via <b>114</b>) the pixel vector and the metadata vector via at least one artificial intelligence algorithm (e.g., <b>302</b> and/or <b>602</b>).</p><p id="p-0093" num="0092">Although not explicitly shown in <figref idref="DRAWINGS">FIG. <b>8</b></figref>, the analyzing the pixel vector and the metadata vector via the at least one artificial intelligence algorithm can comprise: executing, by the device (e.g., <b>114</b>), a first trained artificial intelligence algorithm (e.g., <b>302</b>) on the pixel vector, wherein the first trained artificial intelligence algorithm generates a predicted metadata vector (e.g., <b>402</b>) based on the pixel vector; concatenating, by the device (e.g., <b>114</b>), the predicted metadata vector with the metadata vector, thereby yielding a concatenated vector (e.g., <b>304</b>); and executing, by the device (e.g., <b>116</b>), a second trained artificial intelligence algorithm (e.g., <b>602</b>) on the concatenated vector, wherein the second trained artificial intelligence algorithm classifies the electronic image as authentic or forged (e.g., <b>604</b>) based on the concatenated vector. In various cases, the first trained artificial intelligence algorithm can be a one-vs-rest classifier, and the second trained artificial intelligence algorithm can be an XGBoost classifier.</p><p id="p-0094" num="0093">Although not explicitly shown in <figref idref="DRAWINGS">FIG. <b>8</b></figref>, the analyzing the pixel vector and the metadata vector via the at least one artificial intelligence algorithm can comprise: executing, by the device (e.g., <b>114</b>), a first trained artificial intelligence algorithm (e.g., <b>302</b>) on the pixel vector, wherein the first trained artificial intelligence algorithm generates an embedding (e.g., <b>502</b>) based on the pixel vector; concatenating, by the device (e.g., <b>114</b>), the embedding with the metadata vector, thereby yielding a first concatenated vector (e.g., <b>504</b>); applying, by the device (e.g., <b>114</b>), a Gaussian mixture model (e.g., <b>506</b>) to the first concatenated vector, thereby yielding a vector of posterior probabilities (e.g., <b>508</b>); concatenating, by the device (e.g., <b>114</b>), the vector of posterior probabilities with the metadata vector, thereby yielding a second concatenated vector (e.g., <b>304</b>); and executing, by the device (e.g., <b>116</b>), a second trained artificial intelligence algorithm (e.g., <b>602</b>) on the second concatenated vector, wherein the second trained artificial intelligence algorithm classifies the electronic image as authentic or forged (e.g., <b>604</b>) based on the second concatenated vector. In various cases, the first trained artificial intelligence algorithm can be a triplet network, and the second trained artificial intelligence algorithm can be an XGBoost classifier.</p><p id="p-0095" num="0094">Although not specifically shown in the figures, another computer-implemented method described herein can include the following: receiving, by a processor (e.g., <b>112</b>), an image (e.g., <b>106</b>) of a proof-of-identity document; identifying, by the processor (e.g., <b>112</b>), a pixel vector (e.g., <b>202</b>) and a metadata vector (e.g., <b>204</b>) that correspond to the image; and determining, by the processor (e.g., <b>116</b>), an authenticity (e.g., <b>604</b>) of the proof-of-identity document, based on analyzing (e.g., via <b>302</b> and/or <b>602</b>) the pixel vector and the metadata vector.</p><p id="p-0096" num="0095">In various cases, such computer-implemented method can further comprise: in response to determining that the proof-of-identity document is not authentic, generating, by the processor (e.g., <b>118</b>), a forgery notification (e.g., <b>702</b>).</p><p id="p-0097" num="0096">In various aspects, the processor can analyze the pixel vector and the metadata vector by: inputting, by the processor (e.g., <b>114</b>), the pixel vector to a first machine learning model (e.g., <b>302</b>), which outputs a predicted metadata vector (e.g., <b>402</b>); and inputting, by the processor (e.g., <b>116</b>), both the predicted metadata vector and the metadata vector to a second machine learning model (e.g., <b>602</b>), which outputs an authenticity label (e.g., <b>604</b>) corresponding to the proof-of-identity document.</p><p id="p-0098" num="0097">In various aspects, the processor can analyze the pixel vector and the metadata vector by: inputting, by the processor (e.g., <b>114</b>), the pixel vector to a first machine learning model (e.g., <b>302</b>), which outputs an embedding (e.g., <b>502</b>); applying, by the processor (e.g., <b>114</b>), a Gaussian mixture model (e.g., <b>506</b>) to the embedding, which outputs a vector of posteriors (e.g., <b>508</b>); and inputting, by the processor (e.g., <b>116</b>), both the metadata vector and the vector of posteriors to a second machine learning model (e.g., <b>602</b>), which classifies the proof-of-identity document as either authentic or forged.</p><p id="p-0099" num="0098">Various embodiments described herein include a computerized tool (e.g., <b>102</b>) that can facilitate image forgery detection via pixel-metadata consistency analysis. In various aspects, the computerized tool can generate a consistency vector (e.g., <b>304</b>) when given a pixel vector (e.g., <b>202</b>) and a metadata vector (e.g., <b>204</b>) of an image (e.g., <b>106</b>). Moreover, the computerized tool can binarily classify the image as authentic or forged, based on the consistency vector.</p><p id="p-0100" num="0099">As explained herein, the computerized tool can generate the consistency vector in at least two alternative ways. In a first way, a one-vs-rest classifier (e.g., <b>302</b> as shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref>) can be trained to take in pixel vectors and to predict metadata features (e.g., Exif tags) based on the pixel vectors. During inference time, when given an image (e.g., <b>106</b>) that has a pixel vector (e.g., <b>202</b>) and a metadata vector (e.g., <b>204</b>), the one-vs-rest classifier can predict metadata (e.g., <b>402</b>) for the image, based on the pixel vector. In various cases, the predicted metadata can be subtracted from the metadata vector and then concatenated with the metadata vector. Such result can be considered as the consistency vector (e.g., <b>304</b>).</p><p id="p-0101" num="0100">As recognized by the inventors, the intuition behind this first way of generating the consistency vector is as follows. The one-vs-rest classifier can learn to infer metadata information from raw pixels. Thus, if the predicted metadata features are inconsistent with the actual, readable metadata features that are appended to an image, this can indicate and/or suggest that the actual, readable metadata of the image has been maliciously edited and/or modified, which is a sign of forgery. In various cases, the difference between the predicted metadata and the actual, readable metadata can be considered as a good indication of pixel-metadata consistency.</p><p id="p-0102" num="0101">In various cases, the inventors recognized that the same intuition can be implemented in a second, alternative way. In various instances, a triplet network (e.g., <b>302</b> as shown in <figref idref="DRAWINGS">FIG. <b>5</b></figref>) can be trained to generate metadata embeddings (e.g., <b>502</b>) based on image pixels (e.g., <b>202</b>). In various aspects, the metadata embedding can be concatenated (e.g., yielding <b>504</b>) with the actual, readable metadata (e.g., <b>204</b>). Moreover, in various cases, Gaussian mixture modeling (e.g., <b>506</b>) can be applied, so as to extract posterior probabilities (e.g., <b>508</b>) of the concatenation, and such posterior probabilities can be concatenated with the actual, readable metadata to yield the consistency vector.</p><p id="p-0103" num="0102">In various cases, once the consistency vector is generated, the computerized tool can pass the consistency vector to a trained XGBoost classifier (e.g., <b>602</b>) for binary classification (e.g., forged vs. authentic).</p><p id="p-0104" num="0103">The inventors of various embodiments described herein experimentally verified the performance of such a computerized tool. The dataset that the inventors used contained 13,000 proof-of-identity image files, out of which about <b>700</b> were known to be forged and the remainder were known to be authentic. The inventors used 3,000 of such images for training of the computerized tool described herein and the remaining 10,000 images for evaluation of the computerized tool. The inventors found that implementation of such a computerized tool resulted in a 7% increase in recall, a 1% increase in F-score, and a reduction in false positive rate by 6.4% as compared to existing techniques. Accordingly, the computerized tool described herein certainly constitutes a useful and practical application of computers.</p><p id="p-0105" num="0104">Note that, although the herein disclosure mainly describes the pixel vector <b>202</b> as representing the entirety of the image <b>106</b>, this is a mere non-limiting example. Those having ordinary skill in the art will appreciate that, in various embodiments, multiple pixel vectors can be implemented, with each pixel vector representing a respectively corresponding patch of the image <b>106</b>. In such embodiments, multiple metadata vectors can likewise be implemented, with each metadata vector representing a respectively corresponding patch of the image <b>106</b>.</p><p id="p-0106" num="0105">To facilitate some of the above-described machine learning aspects of various embodiments of the subject innovation, consider the following discussion of artificial intelligence. Various embodiments of the present innovation herein can employ artificial intelligence (AI) to facilitate automating one or more features of the present innovation. The components can employ various AI-based schemes for carrying out various embodiments/examples disclosed herein. In order to provide for or aid in the numerous determinations (e.g., determine, ascertain, infer, calculate, predict, prognose, estimate, derive, forecast, detect, compute) of the present innovation, components of the present innovation can examine the entirety or a subset of the data to which it is granted access and can provide for reasoning about or determine states of the system and/or environment from a set of observations as captured via events and/or data. Determinations can be employed to identify a specific context or action, or can generate a probability distribution over states, for example. The determinations can be probabilistic; that is, the computation of a probability distribution over states of interest based on a consideration of data and events. Determinations can also refer to techniques employed for composing higher-level events from a set of events and/or data.</p><p id="p-0107" num="0106">Such determinations can result in the construction of new events or actions from a set of observed events and/or stored event data, whether or not the events are correlated in close temporal proximity, and whether the events and data come from one or several event and data sources. Components disclosed herein can employ various classification (explicitly trained (e.g., via training data) as well as implicitly trained (e.g., via observing behavior, preferences, historical information, receiving extrinsic information, and so on)) schemes and/or systems (e.g., support vector machines, neural networks, expert systems, Bayesian belief networks, fuzzy logic, data fusion engines, and so on) in connection with performing automatic and/or determined action in connection with the claimed subject matter. Thus, classification schemes and/or systems can be used to automatically learn and perform a number of functions, actions, and/or determinations.</p><p id="p-0108" num="0107">A classifier can map an input attribute vector, z=(z1, z2, z3, z4, zn), to a confidence that the input belongs to a class, as by f(z)=confidence(class). Such classification can employ a probabilistic and/or statistical-based analysis (e.g., factoring into the analysis utilities and costs) to determinate an action to be automatically performed. A support vector machine (SVM) can be an example of a classifier that can be employed. The SVM operates by finding a hyper-surface in the space of possible inputs, where the hyper-surface attempts to split the triggering criteria from the non-triggering events. Intuitively, this makes the classification correct for testing data that is near, but not identical to training data. Other directed and undirected model classification approaches include, e.g., na&#xef;ve Bayes, Bayesian networks, decision trees, neural networks, fuzzy logic models, and/or probabilistic classification models providing different patterns of independence, any of which can be employed. Classification as used herein also is inclusive of statistical regression that is utilized to develop models of priority.</p><p id="p-0109" num="0108">Those having ordinary skill in the art will appreciate that the herein disclosure describes non-limiting examples of various embodiments of the subject innovation. For ease of description and/or explanation, various portions of the herein disclosure utilize the term &#x201c;each&#x201d; when discussing various embodiments of the subject innovation. Those having ordinary skill in the art will appreciate that such usages of the term &#x201c;each&#x201d; are non-limiting examples. In other words, when the herein disclosure provides a description that is applied to &#x201c;each&#x201d; of some particular computerized object and/or component, it should be understood that this is a non-limiting example of various embodiments of the subject innovation, and it should be further understood that, in various other embodiments of the subject innovation, it can be the case that such description applies to fewer than &#x201c;each&#x201d; of that particular computerized object.</p><p id="p-0110" num="0109">In order to provide additional context for various embodiments described herein, <figref idref="DRAWINGS">FIG. <b>9</b></figref> and the following discussion are intended to provide a brief, general description of a suitable computing environment <b>900</b> in which the various embodiments of the embodiment described herein can be implemented. While the embodiments have been described above in the general context of computer-executable instructions that can run on one or more computers, those skilled in the art will recognize that the embodiments can be also implemented in combination with other program modules and/or as a combination of hardware and software.</p><p id="p-0111" num="0110">Generally, program modules include routines, programs, components, data structures, etc., that perform particular tasks or implement particular abstract data types. Moreover, those skilled in the art will appreciate that the inventive methods can be practiced with other computer system configurations, including single-processor or multiprocessor computer systems, minicomputers, mainframe computers, Internet of Things (IoT) devices, distributed computing systems, as well as personal computers, hand-held computing devices, microprocessor-based or programmable consumer electronics, and the like, each of which can be operatively coupled to one or more associated devices.</p><p id="p-0112" num="0111">The illustrated embodiments of the embodiments herein can be also practiced in distributed computing environments where certain tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules can be located in both local and remote memory storage devices.</p><p id="p-0113" num="0112">Computing devices typically include a variety of media, which can include computer-readable storage media, machine-readable storage media, and/or communications media, which two terms are used herein differently from one another as follows. Computer-readable storage media or machine-readable storage media can be any available storage media that can be accessed by the computer and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer-readable storage media or machine-readable storage media can be implemented in connection with any method or technology for storage of information such as computer-readable or machine-readable instructions, program modules, structured data or unstructured data.</p><p id="p-0114" num="0113">Computer-readable storage media can include, but are not limited to, random access memory (RAM), read only memory (ROM), electrically erasable programmable read only memory (EEPROM), flash memory or other memory technology, compact disk read only memory (CD ROM), digital versatile disk (DVD), Blu-ray disc (BD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, solid state drives or other solid state storage devices, or other tangible and/or non-transitory media which can be used to store desired information. In this regard, the terms &#x201c;tangible&#x201d; or &#x201c;non-transitory&#x201d; herein as applied to storage, memory or computer-readable media, are to be understood to exclude only propagating transitory signals per se as modifiers and do not relinquish rights to all standard storage, memory or computer-readable media that are not only propagating transitory signals per se.</p><p id="p-0115" num="0114">Computer-readable storage media can be accessed by one or more local or remote computing devices, e.g., via access requests, queries or other data retrieval protocols, for a variety of operations with respect to the information stored by the medium.</p><p id="p-0116" num="0115">Communications media typically embody computer-readable instructions, data structures, program modules or other structured or unstructured data in a data signal such as a modulated data signal, e.g., a carrier wave or other transport mechanism, and includes any information delivery or transport media. The term &#x201c;modulated data signal&#x201d; or signals refers to a signal that has one or more of its characteristics set or changed in such a manner as to encode information in one or more signals. By way of example, and not limitation, communication media include wired media, such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media.</p><p id="p-0117" num="0116">With reference again to <figref idref="DRAWINGS">FIG. <b>9</b></figref>, the example environment <b>900</b> for implementing various embodiments of the aspects described herein includes a computer <b>902</b>, the computer <b>902</b> including a processing unit <b>904</b>, a system memory <b>906</b> and a system bus <b>908</b>. The system bus <b>908</b> couples system components including, but not limited to, the system memory <b>906</b> to the processing unit <b>904</b>. The processing unit <b>904</b> can be any of various commercially available processors. Dual microprocessors and other multi processor architectures can also be employed as the processing unit <b>904</b>.</p><p id="p-0118" num="0117">The system bus <b>908</b> can be any of several types of bus structure that can further interconnect to a memory bus (with or without a memory controller), a peripheral bus, and a local bus using any of a variety of commercially available bus architectures. The system memory <b>906</b> includes ROM <b>910</b> and RAM <b>912</b>. A basic input/output system (BIOS) can be stored in a non-volatile memory such as ROM, erasable programmable read only memory (EPROM), EEPROM, which BIOS contains the basic routines that help to transfer information between elements within the computer <b>902</b>, such as during startup. The RAM <b>912</b> can also include a high-speed RAM such as static RAM for caching data.</p><p id="p-0119" num="0118">The computer <b>902</b> further includes an internal hard disk drive (HDD) <b>914</b> (e.g., EIDE, SATA), one or more external storage devices <b>916</b> (e.g., a magnetic floppy disk drive (FDD) <b>916</b>, a memory stick or flash drive reader, a memory card reader, etc.) and a drive <b>920</b>, e.g., such as a solid state drive, an optical disk drive, which can read or write from a disk <b>922</b>, such as a CD-ROM disc, a DVD, a BD, etc. Alternatively, where a solid state drive is involved, disk <b>922</b> would not be included, unless separate. While the internal HDD <b>914</b> is illustrated as located within the computer <b>902</b>, the internal HDD <b>914</b> can also be configured for external use in a suitable chassis (not shown). Additionally, while not shown in environment <b>900</b>, a solid state drive (SSD) could be used in addition to, or in place of, an HDD <b>914</b>. The HDD <b>914</b>, external storage device(s) <b>916</b> and drive <b>920</b> can be connected to the system bus <b>908</b> by an HDD interface <b>924</b>, an external storage interface <b>926</b> and a drive interface <b>928</b>, respectively. The interface <b>924</b> for external drive implementations can include at least one or both of Universal Serial Bus (USB) and Institute of Electrical and Electronics Engineers (IEEE) 1394 interface technologies. Other external drive connection technologies are within contemplation of the embodiments described herein.</p><p id="p-0120" num="0119">The drives and their associated computer-readable storage media provide nonvolatile storage of data, data structures, computer-executable instructions, and so forth. For the computer <b>902</b>, the drives and storage media accommodate the storage of any data in a suitable digital format. Although the description of computer-readable storage media above refers to respective types of storage devices, it should be appreciated by those skilled in the art that other types of storage media which are readable by a computer, whether presently existing or developed in the future, could also be used in the example operating environment, and further, that any such storage media can contain computer-executable instructions for performing the methods described herein.</p><p id="p-0121" num="0120">A number of program modules can be stored in the drives and RAM <b>912</b>, including an operating system <b>930</b>, one or more application programs <b>932</b>, other program modules <b>934</b> and program data <b>936</b>. All or portions of the operating system, applications, modules, and/or data can also be cached in the RAM <b>912</b>. The systems and methods described herein can be implemented utilizing various commercially available operating systems or combinations of operating systems.</p><p id="p-0122" num="0121">Computer <b>902</b> can optionally comprise emulation technologies. For example, a hypervisor (not shown) or other intermediary can emulate a hardware environment for operating system <b>930</b>, and the emulated hardware can optionally be different from the hardware illustrated in <figref idref="DRAWINGS">FIG. <b>9</b></figref>. In such an embodiment, operating system <b>930</b> can comprise one virtual machine (VM) of multiple VMs hosted at computer <b>902</b>. Furthermore, operating system <b>930</b> can provide runtime environments, such as the Java runtime environment or the .NET framework, for applications <b>932</b>. Runtime environments are consistent execution environments that allow applications <b>932</b> to run on any operating system that includes the runtime environment. Similarly, operating system <b>930</b> can support containers, and applications <b>932</b> can be in the form of containers, which are lightweight, standalone, executable packages of software that include, e.g., code, runtime, system tools, system libraries and settings for an application.</p><p id="p-0123" num="0122">Further, computer <b>902</b> can be enable with a security module, such as a trusted processing module (TPM). For instance with a TPM, boot components hash next in time boot components, and wait for a match of results to secured values, before loading a next boot component. This process can take place at any layer in the code execution stack of computer <b>902</b>, e.g., applied at the application execution level or at the operating system (OS) kernel level, thereby enabling security at any level of code execution.</p><p id="p-0124" num="0123">A user can enter commands and information into the computer <b>902</b> through one or more wired/wireless input devices, e.g., a keyboard <b>938</b>, a touch screen <b>940</b>, and a pointing device, such as a mouse <b>942</b>. Other input devices (not shown) can include a microphone, an infrared (IR) remote control, a radio frequency (RF) remote control, or other remote control, a joystick, a virtual reality controller and/or virtual reality headset, a game pad, a stylus pen, an image input device, e.g., camera(s), a gesture sensor input device, a vision movement sensor input device, an emotion or facial detection device, a biometric input device, e.g., fingerprint or iris scanner, or the like. These and other input devices are often connected to the processing unit <b>904</b> through an input device interface <b>944</b> that can be coupled to the system bus <b>908</b>, but can be connected by other interfaces, such as a parallel port, an IEEE 1394 serial port, a game port, a USB port, an IR interface, a BLUETOOTH&#xae; interface, etc.</p><p id="p-0125" num="0124">A monitor <b>946</b> or other type of display device can be also connected to the system bus <b>908</b> via an interface, such as a video adapter <b>948</b>. In addition to the monitor <b>946</b>, a computer typically includes other peripheral output devices (not shown), such as speakers, printers, etc.</p><p id="p-0126" num="0125">The computer <b>902</b> can operate in a networked environment using logical connections via wired and/or wireless communications to one or more remote computers, such as a remote computer(s) <b>950</b>. The remote computer(s) <b>950</b> can be a workstation, a server computer, a router, a personal computer, portable computer, microprocessor-based entertainment appliance, a peer device or other common network node, and typically includes many or all of the elements described relative to the computer <b>902</b>, although, for purposes of brevity, only a memory/storage device <b>952</b> is illustrated. The logical connections depicted include wired/wireless connectivity to a local area network (LAN) <b>954</b> and/or larger networks, e.g., a wide area network (WAN) <b>956</b>. Such LAN and WAN networking environments are commonplace in offices and companies, and facilitate enterprise-wide computer networks, such as intranets, all of which can connect to a global communications network, e.g., the Internet.</p><p id="p-0127" num="0126">When used in a LAN networking environment, the computer <b>902</b> can be connected to the local network <b>954</b> through a wired and/or wireless communication network interface or adapter <b>958</b>. The adapter <b>958</b> can facilitate wired or wireless communication to the LAN <b>954</b>, which can also include a wireless access point (AP) disposed thereon for communicating with the adapter <b>958</b> in a wireless mode.</p><p id="p-0128" num="0127">When used in a WAN networking environment, the computer <b>902</b> can include a modem <b>960</b> or can be connected to a communications server on the WAN <b>956</b> via other means for establishing communications over the WAN <b>956</b>, such as by way of the Internet. The modem <b>960</b>, which can be internal or external and a wired or wireless device, can be connected to the system bus <b>908</b> via the input device interface <b>944</b>. In a networked environment, program modules depicted relative to the computer <b>902</b> or portions thereof, can be stored in the remote memory/storage device <b>952</b>. It will be appreciated that the network connections shown are example and other means of establishing a communications link between the computers can be used.</p><p id="p-0129" num="0128">When used in either a LAN or WAN networking environment, the computer <b>902</b> can access cloud storage systems or other network-based storage systems in addition to, or in place of, external storage devices <b>916</b> as described above, such as but not limited to a network virtual machine providing one or more aspects of storage or processing of information. Generally, a connection between the computer <b>902</b> and a cloud storage system can be established over a LAN <b>954</b> or WAN <b>956</b> e.g., by the adapter <b>958</b> or modem <b>960</b>, respectively. Upon connecting the computer <b>902</b> to an associated cloud storage system, the external storage interface <b>926</b> can, with the aid of the adapter <b>958</b> and/or modem <b>960</b>, manage storage provided by the cloud storage system as it would other types of external storage. For instance, the external storage interface <b>926</b> can be configured to provide access to cloud storage sources as if those sources were physically connected to the computer <b>902</b>.</p><p id="p-0130" num="0129">The computer <b>902</b> can be operable to communicate with any wireless devices or entities operatively disposed in wireless communication, e.g., a printer, scanner, desktop and/or portable computer, portable data assistant, communications satellite, any piece of equipment or location associated with a wirelessly detectable tag (e.g., a kiosk, news stand, store shelf, etc.), and telephone. This can include Wireless Fidelity (Wi-Fi) and BLUETOOTH&#xae; wireless technologies. Thus, the communication can be a predefined structure as with a conventional network or simply an ad hoc communication between at least two devices.</p><p id="p-0131" num="0130"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a schematic block diagram of a sample computing environment <b>1000</b> with which the disclosed subject matter can interact. The sample computing environment <b>1000</b> includes one or more client(s) <b>1010</b>. The client(s) <b>1010</b> can be hardware and/or software (e.g., threads, processes, computing devices). The sample computing environment <b>1000</b> also includes one or more server(s) <b>1030</b>. The server(s) <b>1030</b> can also be hardware and/or software (e.g., threads, processes, computing devices). The servers <b>1030</b> can house threads to perform transformations by employing one or more embodiments as described herein, for example. One possible communication between a client <b>1010</b> and a server <b>1030</b> can be in the form of a data packet adapted to be transmitted between two or more computer processes. The sample computing environment <b>1000</b> includes a communication framework <b>1050</b> that can be employed to facilitate communications between the client(s) <b>1010</b> and the server(s) <b>1030</b>. The client(s) <b>1010</b> are operably connected to one or more client data store(s) <b>1020</b> that can be employed to store information local to the client(s) <b>1010</b>. Similarly, the server(s) <b>1030</b> are operably connected to one or more server data store(s) <b>1040</b> that can be employed to store information local to the servers <b>1030</b>.</p><p id="p-0132" num="0131">Various embodiments described herein may be a system, a method, an apparatus and/or a computer program product at any possible technical detail level of integration. The computer program product can include a computer readable storage medium (or media) having computer readable program instructions thereon for causing a processor to carry out aspects of various embodiments described herein. The computer readable storage medium can be a tangible device that can retain and store instructions for use by an instruction execution device. The computer readable storage medium can be, for example, but is not limited to, an electronic storage device, a magnetic storage device, an optical storage device, an electromagnetic storage device, a semiconductor storage device, or any suitable combination of the foregoing. A non-exhaustive list of more specific examples of the computer readable storage medium can also include the following: a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or Flash memory), a static random access memory (SRAM), a portable compact disc read-only memory (CD-ROM), a digital versatile disk (DVD), a memory stick, a floppy disk, a mechanically encoded device such as punch-cards or raised structures in a groove having instructions recorded thereon, and any suitable combination of the foregoing. A computer readable storage medium, as used herein, is not to be construed as being transitory signals per se, such as radio waves or other freely propagating electromagnetic waves, electromagnetic waves propagating through a waveguide or other transmission media (e.g., light pulses passing through a fiber-optic cable), or electrical signals transmitted through a wire.</p><p id="p-0133" num="0132">Computer readable program instructions described herein can be downloaded to respective computing/processing devices from a computer readable storage medium or to an external computer or external storage device via a network, for example, the Internet, a local area network, a wide area network and/or a wireless network. The network can comprise copper transmission cables, optical transmission fibers, wireless transmission, routers, firewalls, switches, gateway computers and/or edge servers. A network adapter card or network interface in each computing/processing device receives computer readable program instructions from the network and forwards the computer readable program instructions for storage in a computer readable storage medium within the respective computing/processing device. Computer readable program instructions for carrying out operations of various embodiments described herein can be assembler instructions, instruction-set-architecture (ISA) instructions, machine instructions, machine dependent instructions, microcode, firmware instructions, state-setting data, configuration data for integrated circuitry, or either source code or object code written in any combination of one or more programming languages, including an object oriented programming language such as Smalltalk, C++, or the like, and procedural programming languages, such as the &#x201c;C&#x201d; programming language or similar programming languages. The computer readable program instructions can execute entirely on the user's computer, partly on the user's computer, as a stand-alone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario, the remote computer can be connected to the user's computer through any type of network, including a local area network (LAN) or a wide area network (WAN), or the connection can be made to an external computer (for example, through the Internet using an Internet Service Provider). In some embodiments, electronic circuitry including, for example, programmable logic circuitry, field-programmable gate arrays (FPGA), or programmable logic arrays (PLA) can execute the computer readable program instructions by utilizing state information of the computer readable program instructions to personalize the electronic circuitry, in order to perform aspects of various embodiments described herein.</p><p id="p-0134" num="0133">Aspects of various embodiments are described herein with reference to flowchart illustrations and/or block diagrams of methods, apparatus (systems), and computer program products according to various embodiments described herein. It will be understood that each block of the flowchart illustrations and/or block diagrams, and combinations of blocks in the flowchart illustrations and/or block diagrams, can be implemented by computer readable program instructions. These computer readable program instructions can be provided to a processor of a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the processor of the computer or other programmable data processing apparatus, create means for implementing the functions/acts specified in the flowchart and/or block diagram block or blocks. These computer readable program instructions can also be stored in a computer readable storage medium that can direct a computer, a programmable data processing apparatus, and/or other devices to function in a particular manner, such that the computer readable storage medium having instructions stored therein comprises an article of manufacture including instructions which implement aspects of the function/act specified in the flowchart and/or block diagram block or blocks. The computer readable program instructions can also be loaded onto a computer, other programmable data processing apparatus, or other device to cause a series of operational acts to be performed on the computer, other programmable apparatus or other device to produce a computer implemented process, such that the instructions which execute on the computer, other programmable apparatus, or other device implement the functions/acts specified in the flowchart and/or block diagram block or blocks.</p><p id="p-0135" num="0134">The flowcharts and block diagrams in the Figures illustrate the architecture, functionality, and operation of possible implementations of systems, methods, and computer program products according to various embodiments described herein. In this regard, each block in the flowchart or block diagrams can represent a module, segment, or portion of instructions, which comprises one or more executable instructions for implementing the specified logical function(s). In some alternative implementations, the functions noted in the blocks can occur out of the order noted in the Figures. For example, two blocks shown in succession can, in fact, be executed substantially concurrently, or the blocks can sometimes be executed in the reverse order, depending upon the functionality involved. It will also be noted that each block of the block diagrams and/or flowchart illustration, and combinations of blocks in the block diagrams and/or flowchart illustration, can be implemented by special purpose hardware-based systems that perform the specified functions or acts or carry out combinations of special purpose hardware and computer instructions.</p><p id="p-0136" num="0135">While the subject matter has been described above in the general context of computer-executable instructions of a computer program product that runs on a computer and/or computers, those skilled in the art will recognize that this disclosure also can or can be implemented in combination with other program modules. Generally, program modules include routines, programs, components, data structures, etc. that perform particular tasks and/or implement particular abstract data types. Moreover, those skilled in the art will appreciate that the inventive computer-implemented methods can be practiced with other computer system configurations, including single-processor or multiprocessor computer systems, mini-computing devices, mainframe computers, as well as computers, hand-held computing devices (e.g., PDA, phone), microprocessor-based or programmable consumer or industrial electronics, and the like. The illustrated aspects can also be practiced in distributed computing environments in which tasks are performed by remote processing devices that are linked through a communications network. However, some, if not all aspects of this disclosure can be practiced on stand-alone computers. In a distributed computing environment, program modules can be located in both local and remote memory storage devices.</p><p id="p-0137" num="0136">As used in this application, the terms &#x201c;component,&#x201d; &#x201c;system,&#x201d; &#x201c;platform,&#x201d; &#x201c;interface,&#x201d; and the like, can refer to and/or can include a computer-related entity or an entity related to an operational machine with one or more specific functionalities. The entities disclosed herein can be either hardware, a combination of hardware and software, software, or software in execution. For example, a component can be, but is not limited to being, a process running on a processor, a processor, an object, an executable, a thread of execution, a program, and/or a computer. By way of illustration, both an application running on a server and the server can be a component. One or more components can reside within a process and/or thread of execution and a component can be localized on one computer and/or distributed between two or more computers. In another example, respective components can execute from various computer readable media having various data structures stored thereon. The components can communicate via local and/or remote processes such as in accordance with a signal having one or more data packets (e.g., data from one component interacting with another component in a local system, distributed system, and/or across a network such as the Internet with other systems via the signal). As another example, a component can be an apparatus with specific functionality provided by mechanical parts operated by electric or electronic circuitry, which is operated by a software or firmware application executed by a processor. In such a case, the processor can be internal or external to the apparatus and can execute at least a part of the software or firmware application. As yet another example, a component can be an apparatus that provides specific functionality through electronic components without mechanical parts, wherein the electronic components can include a processor or other means to execute software or firmware that confers at least in part the functionality of the electronic components. In an aspect, a component can emulate an electronic component via a virtual machine, e.g., within a cloud computing system.</p><p id="p-0138" num="0137">In addition, the term &#x201c;or&#x201d; is intended to mean an inclusive &#x201c;or&#x201d; rather than an exclusive &#x201c;or.&#x201d; That is, unless specified otherwise, or clear from context, &#x201c;X employs A or B&#x201d; is intended to mean any of the natural inclusive permutations. That is, if X employs A; X employs B; or X employs both A and B, then &#x201c;X employs A or B&#x201d; is satisfied under any of the foregoing instances. Moreover, articles &#x201c;a&#x201d; and &#x201c;an&#x201d; as used in the subject specification and annexed drawings should generally be construed to mean &#x201c;one or more&#x201d; unless specified otherwise or clear from context to be directed to a singular form. As used herein, the terms &#x201c;example&#x201d; and/or &#x201c;exemplary&#x201d; are utilized to mean serving as an example, instance, or illustration. For the avoidance of doubt, the subject matter disclosed herein is not limited by such examples. In addition, any aspect or design described herein as an &#x201c;example&#x201d; and/or &#x201c;exemplary&#x201d; is not necessarily to be construed as preferred or advantageous over other aspects or designs, nor is it meant to preclude equivalent exemplary structures and techniques known to those of ordinary skill in the art.</p><p id="p-0139" num="0138">As it is employed in the subject specification, the term &#x201c;processor&#x201d; can refer to substantially any computing processing unit or device comprising, but not limited to, single-core processors; single-processors with software multithread execution capability; multi-core processors; multi-core processors with software multithread execution capability; multi-core processors with hardware multithread technology; parallel platforms; and parallel platforms with distributed shared memory. Additionally, a processor can refer to an integrated circuit, an application specific integrated circuit (ASIC), a digital signal processor (DSP), a field programmable gate array (FPGA), a programmable logic controller (PLC), a complex programmable logic device (CPLD), a discrete gate or transistor logic, discrete hardware components, or any combination thereof designed to perform the functions described herein. Further, processors can exploit nano-scale architectures such as, but not limited to, molecular and quantum-dot based transistors, switches and gates, in order to optimize space usage or enhance performance of user equipment. A processor can also be implemented as a combination of computing processing units. In this disclosure, terms such as &#x201c;store,&#x201d; &#x201c;storage,&#x201d; &#x201c;data store,&#x201d; data storage,&#x201d; &#x201c;database,&#x201d; and substantially any other information storage component relevant to operation and functionality of a component are utilized to refer to &#x201c;memory components,&#x201d; entities embodied in a &#x201c;memory,&#x201d; or components comprising a memory. It is to be appreciated that memory and/or memory components described herein can be either volatile memory or nonvolatile memory, or can include both volatile and nonvolatile memory. By way of illustration, and not limitation, nonvolatile memory can include read only memory (ROM), programmable ROM (PROM), electrically programmable ROM (EPROM), electrically erasable ROM (EEPROM), flash memory, or nonvolatile random access memory (RAM) (e.g., ferroelectric RAM (FeRAM). Volatile memory can include RAM, which can act as external cache memory, for example. By way of illustration and not limitation, RAM is available in many forms such as synchronous RAM (SRAM), dynamic RAM (DRAM), synchronous DRAM (SDRAM), double data rate SDRAM (DDR SDRAM), enhanced SDRAM (ESDRAM), Synchlink DRAM (SLDRAM), direct Rambus RAM (DRRAM), direct Rambus dynamic RAM (DRDRAM), and Rambus dynamic RAM (RDRAM). Additionally, the disclosed memory components of systems or computer-implemented methods herein are intended to include, without being limited to including, these and any other suitable types of memory.</p><p id="p-0140" num="0139">What has been described above include mere examples of systems and computer-implemented methods. It is, of course, not possible to describe every conceivable combination of components or computer-implemented methods for purposes of describing this disclosure, but one of ordinary skill in the art can recognize that many further combinations and permutations of this disclosure are possible. Furthermore, to the extent that the terms &#x201c;includes,&#x201d; &#x201c;has,&#x201d; &#x201c;possesses,&#x201d; and the like are used in the detailed description, claims, appendices and drawings such terms are intended to be inclusive in a manner similar to the term &#x201c;comprising&#x201d; as &#x201c;comprising&#x201d; is interpreted when employed as a transitional word in a claim.</p><p id="p-0141" num="0140">The descriptions of the various embodiments have been presented for purposes of illustration, but are not intended to be exhaustive or limited to the embodiments disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the described embodiments. The terminology used herein was chosen to best explain the principles of the embodiments, the practical application or technical improvement over technologies found in the marketplace, or to enable others of ordinary skill in the art to understand the embodiments disclosed herein.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A system, comprising:<claim-text>a processor that executes computer-executable instructions stored in a computer-readable memory, which causes the processor to:<claim-text>receive, from a client device, an electronic image;</claim-text><claim-text>obtain a pixel vector and an image metadata vector that correspond to the electronic image; and</claim-text><claim-text>determine whether the electronic image is authentic or forged, based on analyzing the pixel vector and the image metadata vector via at least one machine learning model.</claim-text></claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the computer-executable instructions are further executable to cause the processor to:<claim-text>in response to determining that the electronic image is forged, transmit an unsuccessful validation message to the client device.</claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the analyzing the pixel vector and the image metadata vector via the at least one machine learning model comprises:<claim-text>executing a first trained machine learning model on the pixel vector, wherein the first trained machine learning model is configured to generate a predicted metadata vector based on the pixel vector;</claim-text><claim-text>concatenating the predicted metadata vector with the image metadata vector, thereby yielding a concatenated vector; and</claim-text><claim-text>executing a second trained machine learning model on the concatenated vector, wherein the second trained machine learning model is configured to classify the electronic image as authentic or forged based on the concatenated vector.</claim-text></claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The system of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the first trained machine learning model is a one-vs-rest classifier, and wherein the second trained machine learning model is an XGBoost classifier.</claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the analyzing the pixel vector and the image metadata vector via the at least one machine learning model comprises:<claim-text>executing a first trained machine learning model on the pixel vector, wherein the first trained machine learning model is configured to generate an embedding based on the pixel vector;</claim-text><claim-text>concatenating the embedding with the image metadata vector, thereby yielding a first concatenated vector;</claim-text><claim-text>applying a Gaussian mixture model to the first concatenated vector, thereby yielding a vector of posterior probabilities;</claim-text><claim-text>concatenating the vector of posterior probabilities with the image metadata vector, thereby yielding a second concatenated vector; and</claim-text><claim-text>executing a second trained machine learning model on the second concatenated vector, wherein the second trained machine learning model is configured to classify the electronic image as authentic or forged based on the second concatenated vector.</claim-text></claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The system of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the first trained machine learning model is a triplet network, and wherein the second trained machine learning model is an XGBoost classifier.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the image metadata vector is an Exif vector associated with the electronic image.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. A computer-implemented method, comprising:<claim-text>accessing, by a device operatively coupled to a processor, an electronic image provided by a computing device;</claim-text><claim-text>identifying, by the device, a pixel vector and a metadata vector that correspond to the electronic image; and</claim-text><claim-text>labeling, by the device, the electronic image as authentic or forged, based on analyzing the pixel vector and the metadata vector via at least one artificial intelligence algorithm.</claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The computer-implemented method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the analyzing the pixel vector and the metadata vector via the at least one artificial intelligence algorithm comprises:<claim-text>executing, by the device, a first trained artificial intelligence algorithm on the pixel vector, wherein the first trained artificial intelligence algorithm generates a predicted metadata vector based on the pixel vector;</claim-text><claim-text>concatenating, by the device, the predicted metadata vector with the metadata vector, thereby yielding a concatenated vector; and</claim-text><claim-text>executing, by the device, a second trained artificial intelligence algorithm on the concatenated vector, wherein the second trained artificial intelligence algorithm classifies the electronic image as authentic or forged based on the concatenated vector.</claim-text></claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The computer-implemented method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the first trained artificial intelligence algorithm is a one-vs-rest classifier, and wherein the second trained artificial intelligence algorithm is an XGBoost classifier.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The computer-implemented method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the analyzing the pixel vector and the metadata vector via the at least one artificial intelligence algorithm comprises:<claim-text>executing, by the device, a first trained artificial intelligence algorithm on the pixel vector, wherein the first trained artificial intelligence algorithm generates an embedding based on the pixel vector;</claim-text><claim-text>concatenating, by the device, the embedding with the metadata vector, thereby yielding a first concatenated vector;</claim-text><claim-text>applying, by the device, a Gaussian mixture model to the first concatenated vector, thereby yielding a vector of posterior probabilities;</claim-text><claim-text>concatenating, by the device, the vector of posterior probabilities with the metadata vector, thereby yielding a second concatenated vector; and</claim-text><claim-text>executing, by the device, a second trained artificial intelligence algorithm on the second concatenated vector, wherein the second trained artificial intelligence algorithm classifies the electronic image as authentic or forged based on the second concatenated vector.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The computer-implemented method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the first trained artificial intelligence algorithm is a triplet network, and wherein the second trained artificial intelligence algorithm is an XGBoost classifier.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The computer-implemented method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the metadata vector is an Exif vector that includes a camera model feature which identifies a type of camera that captured the electronic image.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The computer-implemented method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the metadata vector is an Exif vector that includes a software feature which identifies a type of software in which the electronic image was opened.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. A computer program product for facilitating image forgery detection via pixel-metadata consistency analysis, the computer program product comprising a computer-readable medium having program instructions embodied therewith, the program instructions executable by a processor to cause the processor to:<claim-text>receive, by the processor, an image of a proof-of-identity document;</claim-text><claim-text>identify, by the processor, a pixel vector and a metadata vector that correspond to the image; and</claim-text><claim-text>determine, by the processor, an authenticity of the proof-of-identity document, based on analyzing the pixel vector and the metadata vector.</claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The computer program product of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the program instructions are further executable to cause the processor to:<claim-text>in response to determining that the proof-of-identity document is not authentic, generate, by the processor, a forgery notification.</claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The computer program product of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the processor analyzes the pixel vector and the metadata vector by:<claim-text>inputting, by the processor, the pixel vector to a first machine learning model, which outputs a predicted metadata vector; and</claim-text><claim-text>inputting, by the processor, both the predicted metadata vector and the metadata vector to a second machine learning model, which outputs an authenticity label corresponding to the proof-of-identity document.</claim-text></claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The computer program product of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the first machine learning model is a one-vs-rest classifier.</claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The computer program product of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the processor analyzes the pixel vector and the metadata vector by:<claim-text>inputting, by the processor, the pixel vector to a first machine learning model, which outputs an embedding;</claim-text><claim-text>applying, by the processor, a Gaussian mixture model to the embedding, which outputs a vector of posteriors; and</claim-text><claim-text>inputting, by the processor, both the metadata vector and the vector of posteriors to a second machine learning model, which classifies the proof-of-identity document as either authentic or forged.</claim-text></claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The computer program product of <claim-ref idref="CLM-00019">claim 19</claim-ref>, wherein the first machine learning model is a triplet network.</claim-text></claim></claims></us-patent-application>