<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230007238A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230007238</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17809167</doc-number><date>20220627</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>105</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>132</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>137</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>176</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>105</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>132</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>137</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>176</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">USING UNREFINED MOTION VECTORS FOR PERFORMING DECODER-SIDE MOTION VECTOR DERIVATION</invention-title><us-related-documents><us-provisional-application><document-id><country>US</country><doc-number>63217164</doc-number><date>20210630</date></document-id></us-provisional-application></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>QUALCOMM Incorporated</orgname><address><city>San Diego</city><state>CA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Chen</last-name><first-name>Chun-Chi</first-name><address><city>San Diego</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Huang</last-name><first-name>Han</first-name><address><city>San Diego</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>Hsieh</last-name><first-name>Cheng-Teh</first-name><address><city>Del Mar</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="03" designation="us-only"><addressbook><last-name>Chien</last-name><first-name>Wei-Jung</first-name><address><city>San Diego</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="04" designation="us-only"><addressbook><last-name>Zhang</last-name><first-name>Zhi</first-name><address><city>Munich</city><country>DE</country></address></addressbook></inventor><inventor sequence="05" designation="us-only"><addressbook><last-name>Chang</last-name><first-name>Yao-Jen</first-name><address><city>San Diego</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="06" designation="us-only"><addressbook><last-name>Zhang</last-name><first-name>Yan</first-name><address><city>San Diego</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="07" designation="us-only"><addressbook><last-name>Seregin</last-name><first-name>Vadim</first-name><address><city>San Diego</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="08" designation="us-only"><addressbook><last-name>Karczewicz</last-name><first-name>Marta</first-name><address><city>San Diego</city><state>CA</state><country>US</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A device for decoding video data includes a memory configured to store video data; and one or more processors implemented in circuitry and configured to: determine a deterministic bounding box from which to retrieve reference samples of reference pictures of video data for performing decoder-side motion vector derivation (DMVD) for a current block of the video data; derive a motion vector for the current block according to DMVD using the reference samples within the deterministic bounding box; form a prediction block using the motion vector; and decode the current block using the prediction block.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="200.66mm" wi="85.51mm" file="US20230007238A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="245.36mm" wi="172.13mm" file="US20230007238A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="200.83mm" wi="111.08mm" orientation="landscape" file="US20230007238A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="245.03mm" wi="96.52mm" orientation="landscape" file="US20230007238A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="258.23mm" wi="151.89mm" orientation="landscape" file="US20230007238A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="250.95mm" wi="150.03mm" orientation="landscape" file="US20230007238A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="258.06mm" wi="155.70mm" orientation="landscape" file="US20230007238A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="238.34mm" wi="167.98mm" orientation="landscape" file="US20230007238A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="243.08mm" wi="162.14mm" orientation="landscape" file="US20230007238A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="251.63mm" wi="168.74mm" orientation="landscape" file="US20230007238A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="256.71mm" wi="169.16mm" orientation="landscape" file="US20230007238A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="258.06mm" wi="159.34mm" orientation="landscape" file="US20230007238A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="249.09mm" wi="126.07mm" file="US20230007238A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="245.45mm" wi="127.68mm" file="US20230007238A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00014" num="00014"><img id="EMI-D00014" he="251.71mm" wi="121.24mm" file="US20230007238A1-20230105-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><p id="p-0002" num="0001">This application claims the benefit of U.S. Provisional Application No. 63/217,164, filed Jun. 30, 2021, the entire contents of which are hereby incorporated by reference.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">TECHNICAL FIELD</heading><p id="p-0003" num="0002">This disclosure relates to video coding, including video encoding and video decoding.</p><heading id="h-0002" level="1">BACKGROUND</heading><p id="p-0004" num="0003">Digital video capabilities can be incorporated into a wide range of devices, including digital televisions, digital direct broadcast systems, wireless broadcast systems, personal digital assistants (PDAs), laptop or desktop computers, tablet computers, e-book readers, digital cameras, digital recording devices, digital media players, video gaming devices, video game consoles, cellular or satellite radio telephones, so-called &#x201c;smart phones,&#x201d; video teleconferencing devices, video streaming devices, and the like. Digital video devices implement video coding techniques, such as those described in the standards defined by MPEG-2, MPEG-4, ITU-T H.263, ITU-T H.264/MPEG-4, Part 10, Advanced Video Coding (AVC), ITU-T H.265/High Efficiency Video Coding (HEVC), ITU-T H.266/Versatile Video Coding (VVC), and extensions of such standards, as well as proprietary video codecs/formats such as AOMedia Video 1 (AV1) developed by the Alliance for Open Media. The video devices may transmit, receive, encode, decode, and/or store digital video information more efficiently by implementing such video coding techniques.</p><p id="p-0005" num="0004">Video coding techniques include spatial (intra-picture) prediction and/or temporal (inter-picture) prediction to reduce or remove redundancy inherent in video sequences. For block-based video coding, a video slice (e.g., a video picture or a portion of a video picture) may be partitioned into video blocks, which may also be referred to as coding tree units (CTUs), coding units (CUs) and/or coding nodes. Video blocks in an intra-coded (I) slice of a picture are encoded using spatial prediction with respect to reference samples in neighboring blocks in the same picture. Video blocks in an inter-coded (P or B) slice of a picture may use spatial prediction with respect to reference samples in neighboring blocks in the same picture or temporal prediction with respect to reference samples in other reference pictures. Pictures may be referred to as frames, and reference pictures may be referred to as reference frames.</p><heading id="h-0003" level="1">SUMMARY</heading><p id="p-0006" num="0005">In general, this disclosure describes techniques related to decoder-side motion vector derivation techniques (e.g., template matching, bilateral matching, decoder-side MV refinement, bi-directional optical flow). These techniques may be applied to any of the existing video codecs, such as ITU-T H.265/HEVC (High Efficiency Video Coding), ITU-T H.266/VVC (Versatile Video Coding), Essential Video Coding (EVC), in future video coding standards, or performed by AOMedia Video 1 (AV1) codecs.</p><p id="p-0007" num="0006">In one example, a method of decoding video data, the method comprising: determining a deterministic bounding box from which to retrieve reference samples of reference pictures of video data for performing decoder-side motion vector derivation (DMVD) for a current block of the video data; deriving a motion vector for the current block according to DMVD using the reference samples within the deterministic bounding box; forming a prediction block using the motion vector; and decoding the current block using the prediction block.</p><p id="p-0008" num="0007">In another example, a device for decoding video data includes a memory configured to store video data; and one or more processors implemented in circuitry and configured to: determine a deterministic bounding box from which to retrieve reference samples of reference pictures of video data for performing decoder-side motion vector derivation (DMVD) for a current block of the video data; derive a motion vector for the current block according to DMVD using the reference samples within the deterministic bounding box; form a prediction block using the motion vector; and decode the current block using the prediction block.</p><p id="p-0009" num="0008">In another example, a computer-readable storage medium has stored thereon instructions that, when executed, cause a processor to: determine a deterministic bounding box from which to retrieve reference samples of reference pictures of video data for performing decoder-side motion vector derivation (DMVD) for a current block of the video data; derive a motion vector for the current block according to DMVD using the reference samples within the deterministic bounding box; form a prediction block using the motion vector; and decode the current block using the prediction block.</p><p id="p-0010" num="0009">In another example, a device for decoding video data includes means for determining a deterministic bounding box from which to retrieve reference samples of reference pictures of video data for performing decoder-side motion vector derivation (DMVD) for a current block of the video data; means for deriving a motion vector for the current block according to DMVD using the reference samples within the deterministic bounding box; means for forming a prediction block using the motion vector; and decoding the current block using the prediction block.</p><p id="p-0011" num="0010">The details of one or more examples are set forth in the accompanying drawings and the description below. Other features, objects, and advantages will be apparent from the description, drawings, and claims.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">BRIEF DESCRIPTION OF DRAWINGS</heading><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram illustrating an example video encoding and decoding system that may perform the techniques of this disclosure.</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIGS. <b>2</b>A and <b>2</b>B</figref> are conceptual diagrams illustrating example spatial neighboring motion vector candidates for coding motion vectors in merge mode and advanced motion vector prediction (AMVP) mode.</p><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIGS. <b>3</b>A and <b>3</b>B</figref> are conceptual diagrams illustrating temporal motion vector prediction techniques.</p><p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a conceptual diagram illustrating template matching prediction for motion vector coding.</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a conceptual diagram illustrating motion vector difference (MVD) values for blocks in reference pictures having different temporal distances (TDs) to a current picture including a current block.</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a conceptual diagram illustrating an example in which two MVDs are mirrored regardless of temporal distances.</p><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is conceptual diagram illustrating an example of a 3&#xd7;3 square search pattern in a bilateral matching search range.</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a conceptual diagram illustrating an example of refining a motion vector using decoder-side motion vector refinement (DMVR).</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a block diagram illustrating an example video encoder that may perform the techniques of this disclosure.</p><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a block diagram illustrating an example video decoder that may perform the techniques of this disclosure.</p><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. <b>11</b></figref> is a conceptual diagram illustrating an example merge with motion vector difference (MMVD) search point.</p><p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. <b>12</b></figref> is a flowchart illustrating an example method for encoding a current block in accordance with the techniques of this disclosure.</p><p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. <b>13</b></figref> is a flowchart illustrating an example method for decoding a current block in accordance with the techniques of this disclosure.</p><p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. <b>14</b></figref> is a flowchart illustrating an example method for coding a current block using a motion vector derived and/or refined according to techniques of this disclosure.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0005" level="1">DETAILED DESCRIPTION</heading><p id="p-0026" num="0025">Video coding standards include ITU-T H.261, ISO/IEC MPEG-1 Visual, ITU-T H.262 or ISO/IEC MPEG-2 Visual, ITU-T H.263, ISO/IEC MPEG-4 Visual and ITU-T H.264 (also known as ISO/IEC MPEG-4 AVC), including its Scalable Video Coding (SVC) and Multi-view Video Coding (MVC) extensions.</p><p id="p-0027" num="0026">In addition, High Efficiency Video Coding (HEVC) or ITU-T H.265, including its range extension, multiview extension (MV-HEVC) and scalable extension (SHVC), has been developed by the Joint Collaboration Team on Video Coding (JCT-VC) as well as Joint Collaboration Team on 3D Video Coding Extension Development (JCT-3V) of ITU-T Video Coding Experts Group (VCEG) and ISO/IEC Motion Picture Experts Group (MPEG). The HEVC specification is available from phenix.int-evry.fr/jct/doc_end_user/documents/14_Vienna/wg11/JCTVC-N1003-v1.zip.</p><p id="p-0028" num="0027">ITU-T VCEG (Q6/16) and ISO/IEC MPEG (JTC 1/SC 29/WG 11) continues to study the potential need for standardization of future video coding technology with a compression capability that significantly exceeds that of the HEVC standard (including its current extensions and near-term extensions for screen content coding and high-dynamic-range coding). The groups work together on this exploration activity in a joint collaboration effort known as the Joint Video Exploration Team (JVET) to evaluate compression technology designs proposed by their experts in this area.</p><p id="p-0029" num="0028">Reference software, i.e., VVC Test Model 10 (VTM 10.0) is available from vcgit.hhi.fraunhofer.de/jvet/VVCSoftware_VTM. The ITU-T H.266/Versatile Video Coding (VVC) specification, Bross et al., Joint Video Experts Team (JVET) of ITU-T SG 16 WP 3 and ISO/IEC JTC 1/SC 29, 20th Meeting, by teleconference, 7-16 Oct. 2020, Document JVET-T2001-v1, available at jvet-experts.org/doc_end_user/documents/20_Teleconference/wg11/JVET-T2001-v1.zip. An algorithm description of VTM 10.0 is available from jvet-experts.org/doc_end_user/documents/20_Teleconference/wg11/JVET-T2002-v3.zip.</p><p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram illustrating an example video encoding and decoding system <b>100</b> that may perform the techniques of this disclosure. The techniques of this disclosure are generally directed to coding (encoding and/or decoding) video data. In general, video data includes any data for processing a video. Thus, video data may include raw, uncoded video, encoded video, decoded (e.g., reconstructed) video, and video metadata, such as signaling data.</p><p id="p-0031" num="0030">As shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, system <b>100</b> includes a source device <b>102</b> that provides encoded video data to be decoded and displayed by a destination device <b>116</b>, in this example. In particular, source device <b>102</b> provides the video data to destination device <b>116</b> via a computer-readable medium <b>110</b>. Source device <b>102</b> and destination device <b>116</b> may comprise any of a wide range of devices, including desktop computers, notebook (i.e., laptop) computers, mobile devices, tablet computers, set-top boxes, telephone handsets such as smartphones, televisions, cameras, display devices, digital media players, video gaming consoles, video streaming device, broadcast receiver devices, or the like. In some cases, source device <b>102</b> and destination device <b>116</b> may be equipped for wireless communication, and thus may be referred to as wireless communication devices.</p><p id="p-0032" num="0031">In the example of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, source device <b>102</b> includes video source <b>104</b>, memory <b>106</b>, video encoder <b>200</b>, and output interface <b>108</b>. Destination device <b>116</b> includes input interface <b>122</b>, video decoder <b>300</b>, memory <b>120</b>, and display device <b>118</b>. In accordance with this disclosure, video encoder <b>200</b> of source device <b>102</b> and video decoder <b>300</b> of destination device <b>116</b> may be configured to apply the techniques for using unrefined motion vectors to perform decoder-side motion vector derivation (DMVD). Thus, source device <b>102</b> represents an example of a video encoding device, while destination device <b>116</b> represents an example of a video decoding device. In other examples, a source device and a destination device may include other components or arrangements. For example, source device <b>102</b> may receive video data from an external video source, such as an external camera. Likewise, destination device <b>116</b> may interface with an external display device, rather than include an integrated display device.</p><p id="p-0033" num="0032">System <b>100</b> as shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref> is merely one example. In general, any digital video encoding and/or decoding device may perform techniques for using unrefined motion vectors to perform decoder-side motion vector derivation (DMVD). Source device <b>102</b> and destination device <b>116</b> are merely examples of such coding devices in which source device <b>102</b> generates coded video data for transmission to destination device <b>116</b>. This disclosure refers to a &#x201c;coding&#x201d; device as a device that performs coding (encoding and/or decoding) of data. Thus, video encoder <b>200</b> and video decoder <b>300</b> represent examples of coding devices, in particular, a video encoder and a video decoder, respectively. In some examples, source device <b>102</b> and destination device <b>116</b> may operate in a substantially symmetrical manner such that each of source device <b>102</b> and destination device <b>116</b> includes video encoding and decoding components. Hence, system <b>100</b> may support one-way or two-way video transmission between source device <b>102</b> and destination device <b>116</b>, e.g., for video streaming, video playback, video broadcasting, or video telephony.</p><p id="p-0034" num="0033">In general, video source <b>104</b> represents a source of video data (i.e., raw, uncoded video data) and provides a sequential series of pictures (also referred to as &#x201c;frames&#x201d;) of the video data to video encoder <b>200</b>, which encodes data for the pictures. Video source <b>104</b> of source device <b>102</b> may include a video capture device, such as a video camera, a video archive containing previously captured raw video, and/or a video feed interface to receive video from a video content provider. As a further alternative, video source <b>104</b> may generate computer graphics-based data as the source video, or a combination of live video, archived video, and computer-generated video. In each case, video encoder <b>200</b> encodes the captured, pre-captured, or computer-generated video data. Video encoder <b>200</b> may rearrange the pictures from the received order (sometimes referred to as &#x201c;display order&#x201d;) into a coding order for coding. Video encoder <b>200</b> may generate a bitstream including encoded video data. Source device <b>102</b> may then output the encoded video data via output interface <b>108</b> onto computer-readable medium <b>110</b> for reception and/or retrieval by, e.g., input interface <b>122</b> of destination device <b>116</b>.</p><p id="p-0035" num="0034">Memory <b>106</b> of source device <b>102</b> and memory <b>120</b> of destination device <b>116</b> represent general purpose memories. In some examples, memories <b>106</b>, <b>120</b> may store raw video data, e.g., raw video from video source <b>104</b> and raw, decoded video data from video decoder <b>300</b>. Additionally or alternatively, memories <b>106</b>, <b>120</b> may store software instructions executable by, e.g., video encoder <b>200</b> and video decoder <b>300</b>, respectively. Although memory <b>106</b> and memory <b>120</b> are shown separately from video encoder <b>200</b> and video decoder <b>300</b> in this example, it should be understood that video encoder <b>200</b> and video decoder <b>300</b> may also include internal memories for functionally similar or equivalent purposes. Furthermore, memories <b>106</b>, <b>120</b> may store encoded video data, e.g., output from video encoder <b>200</b> and input to video decoder <b>300</b>. In some examples, portions of memories <b>106</b>, <b>120</b> may be allocated as one or more video buffers, e.g., to store raw, decoded, and/or encoded video data.</p><p id="p-0036" num="0035">Computer-readable medium <b>110</b> may represent any type of medium or device capable of transporting the encoded video data from source device <b>102</b> to destination device <b>116</b>. In one example, computer-readable medium <b>110</b> represents a communication medium to enable source device <b>102</b> to transmit encoded video data directly to destination device <b>116</b> in real-time, e.g., via a radio frequency network or computer-based network. Output interface <b>108</b> may modulate a transmission signal including the encoded video data, and input interface <b>122</b> may demodulate the received transmission signal, according to a communication standard, such as a wireless communication protocol. The communication medium may comprise any wireless or wired communication medium, such as a radio frequency (RF) spectrum or one or more physical transmission lines. The communication medium may form part of a packet-based network, such as a local area network, a wide-area network, or a global network such as the Internet. The communication medium may include routers, switches, base stations, or any other equipment that may be useful to facilitate communication from source device <b>102</b> to destination device <b>116</b>.</p><p id="p-0037" num="0036">In some examples, source device <b>102</b> may output encoded data from output interface <b>108</b> to storage device <b>112</b>. Similarly, destination device <b>116</b> may access encoded data from storage device <b>112</b> via input interface <b>122</b>. Storage device <b>112</b> may include any of a variety of distributed or locally accessed data storage media such as a hard drive, Blu-ray discs, DVDs, CD-ROMs, flash memory, volatile or non-volatile memory, or any other suitable digital storage media for storing encoded video data.</p><p id="p-0038" num="0037">In some examples, source device <b>102</b> may output encoded video data to file server <b>114</b> or another intermediate storage device that may store the encoded video data generated by source device <b>102</b>. Destination device <b>116</b> may access stored video data from file server <b>114</b> via streaming or download.</p><p id="p-0039" num="0038">File server <b>114</b> may be any type of server device capable of storing encoded video data and transmitting that encoded video data to the destination device <b>116</b>. File server <b>114</b> may represent a web server (e.g., for a website), a server configured to provide a file transfer protocol service (such as File Transfer Protocol (FTP) or File Delivery over Unidirectional Transport (FLUTE) protocol), a content delivery network (CDN) device, a hypertext transfer protocol (HTTP) server, a Multimedia Broadcast Multicast Service (MBMS) or Enhanced MBMS (eMBMS) server, and/or a network attached storage (NAS) device. File server <b>114</b> may, additionally or alternatively, implement one or more HTTP streaming protocols, such as Dynamic Adaptive Streaming over HTTP (DASH), HTTP Live Streaming (HLS), Real Time Streaming Protocol (RTSP), HTTP Dynamic Streaming, or the like.</p><p id="p-0040" num="0039">Destination device <b>116</b> may access encoded video data from file server <b>114</b> through any standard data connection, including an Internet connection. This may include a wireless channel (e.g., a Wi-Fi connection), a wired connection (e.g., digital subscriber line (DSL), cable modem, etc.), or a combination of both that is suitable for accessing encoded video data stored on file server <b>114</b>. Input interface <b>122</b> may be configured to operate according to any one or more of the various protocols discussed above for retrieving or receiving media data from file server <b>114</b>, or other such protocols for retrieving media data.</p><p id="p-0041" num="0040">Output interface <b>108</b> and input interface <b>122</b> may represent wireless transmitters/receivers, modems, wired networking components (e.g., Ethernet cards), wireless communication components that operate according to any of a variety of IEEE 802.11 standards, or other physical components. In examples where output interface <b>108</b> and input interface <b>122</b> comprise wireless components, output interface <b>108</b> and input interface <b>122</b> may be configured to transfer data, such as encoded video data, according to a cellular communication standard, such as 4G, 4G-LTE (Long-Term Evolution), LTE Advanced, 5G, or the like. In some examples where output interface <b>108</b> comprises a wireless transmitter, output interface <b>108</b> and input interface <b>122</b> may be configured to transfer data, such as encoded video data, according to other wireless standards, such as an IEEE 802.11 specification, an IEEE 802.15 specification (e.g., ZigBee&#x2122;), a Bluetooth&#x2122; standard, or the like. In some examples, source device <b>102</b> and/or destination device <b>116</b> may include respective system-on-a-chip (SoC) devices. For example, source device <b>102</b> may include an SoC device to perform the functionality attributed to video encoder <b>200</b> and/or output interface <b>108</b>, and destination device <b>116</b> may include an SoC device to perform the functionality attributed to video decoder <b>300</b> and/or input interface <b>122</b>.</p><p id="p-0042" num="0041">The techniques of this disclosure may be applied to video coding in support of any of a variety of multimedia applications, such as over-the-air television broadcasts, cable television transmissions, satellite television transmissions, Internet streaming video transmissions, such as dynamic adaptive streaming over HTTP (DASH), digital video that is encoded onto a data storage medium, decoding of digital video stored on a data storage medium, or other applications.</p><p id="p-0043" num="0042">Input interface <b>122</b> of destination device <b>116</b> receives an encoded video bitstream from computer-readable medium <b>110</b> (e.g., a communication medium, storage device <b>112</b>, file server <b>114</b>, or the like). The encoded video bitstream may include signaling information defined by video encoder <b>200</b>, which is also used by video decoder <b>300</b>, such as syntax elements having values that describe characteristics and/or processing of video blocks or other coded units (e.g., slices, pictures, groups of pictures, sequences, or the like). Display device <b>118</b> displays decoded pictures of the decoded video data to a user. Display device <b>118</b> may represent any of a variety of display devices such as a liquid crystal display (LCD), a plasma display, an organic light emitting diode (OLED) display, or another type of display device.</p><p id="p-0044" num="0043">Although not shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, in some examples, video encoder <b>200</b> and video decoder <b>300</b> may each be integrated with an audio encoder and/or audio decoder, and may include appropriate MUX-DEMUX units, or other hardware and/or software, to handle multiplexed streams including both audio and video in a common data stream.</p><p id="p-0045" num="0044">Video encoder <b>200</b> and video decoder <b>300</b> each may be implemented as any of a variety of suitable encoder and/or decoder circuitry, such as one or more microprocessors, digital signal processors (DSPs), application specific integrated circuits (ASICs), field programmable gate arrays (FPGAs), discrete logic, software, hardware, firmware or any combinations thereof. When the techniques are implemented partially in software, a device may store instructions for the software in a suitable, non-transitory computer-readable medium and execute the instructions in hardware using one or more processors to perform the techniques of this disclosure. Each of video encoder <b>200</b> and video decoder <b>300</b> may be included in one or more encoders or decoders, either of which may be integrated as part of a combined encoder/decoder (CODEC) in a respective device. A device including video encoder <b>200</b> and/or video decoder <b>300</b> may comprise an integrated circuit, a microprocessor, and/or a wireless communication device, such as a cellular telephone.</p><p id="p-0046" num="0045">Video encoder <b>200</b> and video decoder <b>300</b> may operate according to a video coding standard, such as ITU-T H.265, also referred to as High Efficiency Video Coding (HEVC) or extensions thereto, such as the multi-view and/or scalable video coding extensions. Alternatively, video encoder <b>200</b> and video decoder <b>300</b> may operate according to other proprietary or industry standards, such as ITU-T H.266, also referred to as Versatile Video Coding (VVC). In other examples, video encoder <b>200</b> and video decoder <b>300</b> may operate according to a proprietary video codec/format, such as AOMedia Video 1 (AV1), extensions of AV1, and/or successor versions of AV1 (e.g., AV2). In other examples, video encoder <b>200</b> and video decoder <b>300</b> may operate according to other proprietary formats or industry standards. The techniques of this disclosure, however, are not limited to any particular coding standard or format. In general, video encoder <b>200</b> and video decoder <b>300</b> may be configured to perform the techniques of this disclosure in conjunction with any video coding techniques that use unrefined motion vectors to perform decoder-side motion vector derivation (DMVD).</p><p id="p-0047" num="0046">In general, video encoder <b>200</b> and video decoder <b>300</b> may perform block-based coding of pictures. The term &#x201c;block&#x201d; generally refers to a structure including data to be processed (e.g., encoded, decoded, or otherwise used in the encoding and/or decoding process). For example, a block may include a two-dimensional matrix of samples of luminance and/or chrominance data. In general, video encoder <b>200</b> and video decoder <b>300</b> may code video data represented in a YUV (e.g., Y, Cb, Cr) format. That is, rather than coding red, green, and blue (RGB) data for samples of a picture, video encoder <b>200</b> and video decoder <b>300</b> may code luminance and chrominance components, where the chrominance components may include both red hue and blue hue chrominance components. In some examples, video encoder <b>200</b> converts received RGB formatted data to a YUV representation prior to encoding, and video decoder <b>300</b> converts the YUV representation to the RGB format. Alternatively, pre- and post-processing units (not shown) may perform these conversions.</p><p id="p-0048" num="0047">This disclosure may generally refer to coding (e.g., encoding and decoding) of pictures to include the process of encoding or decoding data of the picture. Similarly, this disclosure may refer to coding of blocks of a picture to include the process of encoding or decoding data for the blocks, e.g., prediction and/or residual coding. An encoded video bitstream generally includes a series of values for syntax elements representative of coding decisions (e.g., coding modes) and partitioning of pictures into blocks. Thus, references to coding a picture or a block should generally be understood as coding values for syntax elements forming the picture or block.</p><p id="p-0049" num="0048">HEVC defines various blocks, including coding units (CUs), prediction units (PUs), and transform units (TUs). According to HEVC, a video coder (such as video encoder <b>200</b>) partitions a coding tree unit (CTU) into CUs according to a quadtree structure. That is, the video coder partitions CTUs and CUs into four equal, non-overlapping squares, and each node of the quadtree has either zero or four child nodes. Nodes without child nodes may be referred to as &#x201c;leaf nodes,&#x201d; and CUs of such leaf nodes may include one or more PUs and/or one or more TUs. The video coder may further partition PUs and TUs. For example, in HEVC, a residual quadtree (RQT) represents partitioning of TUs. In HEVC, PUs represent inter-prediction data, while TUs represent residual data. CUs that are intra-predicted include intra-prediction information, such as an intra-mode indication.</p><p id="p-0050" num="0049">As another example, video encoder <b>200</b> and video decoder <b>300</b> may be configured to operate according to VVC. According to VVC, a video coder (such as video encoder <b>200</b>) partitions a picture into a plurality of coding tree units (CTUs). Video encoder <b>200</b> may partition a CTU according to a tree structure, such as a quadtree-binary tree (QTBT) structure or Multi-Type Tree (MTT) structure. The QTBT structure removes the concepts of multiple partition types, such as the separation between CUs, PUs, and TUs of HEVC. A QTBT structure includes two levels: a first level partitioned according to quadtree partitioning, and a second level partitioned according to binary tree partitioning. A root node of the QTBT structure corresponds to a CTU. Leaf nodes of the binary trees correspond to coding units (CUs).</p><p id="p-0051" num="0050">In an MTT partitioning structure, blocks may be partitioned using a quadtree (QT) partition, a binary tree (BT) partition, and one or more types of triple tree (TT) (also called ternary tree (TT)) partitions. A triple or ternary tree partition is a partition where a block is split into three sub-blocks. In some examples, a triple or ternary tree partition divides a block into three sub-blocks without dividing the original block through the center. The partitioning types in MTT (e.g., QT, BT, and TT), may be symmetrical or asymmetrical.</p><p id="p-0052" num="0051">When operating according to the AV1 codec, video encoder <b>200</b> and video decoder <b>300</b> may be configured to code video data in blocks. In AV1, the largest coding block that can be processed is called a superblock. In AV1, a superblock can be either 128&#xd7;128 luma samples or 64&#xd7;64 luma samples. However, in successor video coding formats (e.g., AV2), a superblock may be defined by different (e.g., larger) luma sample sizes. In some examples, a superblock is the top level of a block quadtree. Video encoder <b>200</b> may further partition a superblock into smaller coding blocks. Video encoder <b>200</b> may partition a superblock and other coding blocks into smaller blocks using square or non-square partitioning. Non-square blocks may include N/2&#xd7;N, N&#xd7;N/2, N/4&#xd7;N, and N&#xd7;N/4 blocks. Video encoder <b>200</b> and video decoder <b>300</b> may perform separate prediction and transform processes on each of the coding blocks.</p><p id="p-0053" num="0052">AV1 also defines a tile of video data. A tile is a rectangular array of superblocks that may be coded independently of other tiles. That is, video encoder <b>200</b> and video decoder <b>300</b> may encode and decode, respectively, coding blocks within a tile without using video data from other tiles. However, video encoder <b>200</b> and video decoder <b>300</b> may perform filtering across tile boundaries. Tiles may be uniform or non-uniform in size. Tile-based coding may enable parallel processing and/or multi-threading for encoder and decoder implementations.</p><p id="p-0054" num="0053">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may use a single QTBT or MTT structure to represent each of the luminance and chrominance components, while in other examples, video encoder <b>200</b> and video decoder <b>300</b> may use two or more QTBT or MTT structures, such as one QTBT/MTT structure for the luminance component and another QTBT/MTT structure for both chrominance components (or two QTBT/MTT structures for respective chrominance components).</p><p id="p-0055" num="0054">Video encoder <b>200</b> and video decoder <b>300</b> may be configured to use quadtree partitioning, QTBT partitioning, MTT partitioning, superblock partitioning, or other partitioning structures.</p><p id="p-0056" num="0055">In some examples, a CTU includes a coding tree block (CTB) of luma samples, two corresponding CTBs of chroma samples of a picture that has three sample arrays, or a CTB of samples of a monochrome picture or a picture that is coded using three separate color planes and syntax structures used to code the samples. A CTB may be an N&#xd7;N block of samples for some value of N such that the division of a component into CTBs is a partitioning. A component may be an array or single sample from one of the three arrays (luma and two chroma) for a picture in 4:2:0, 4:2:2, or 4:4:4 color format, or an array or a single sample of the array for a picture in monochrome format. In some examples, a coding block is an M&#xd7;N block of samples for some values of M and N such that a division of a CTB into coding blocks is a partitioning.</p><p id="p-0057" num="0056">In HEVC, the largest coding unit in a slice is called a coding tree block (CTB) or coding tree unit (CTU). A CTB contains a quad-tree the nodes of which are coding units. The size of a CTB can be ranges from 16&#xd7;16 to 64&#xd7;64 in the HEVC main profile (although technically 8&#xd7;8 CTB sizes can be supported). A coding unit (CU) could be the same size of a CTB to as small as 8&#xd7;8. Each coding unit is coded with one mode, i.e., inter or intra. An inter-coded CU may be further partitioned into 2 or 4 prediction units (PUs) or become just one PU when further partitioning does not apply. When two PUs are present in one CU, the two Pus may be half size rectangles or two rectangle size with &#xbc; or &#xbe; size of the CU. When the CU is inter-coded, each PU has one set of motion information, which is derived with a unique inter prediction mode.</p><p id="p-0058" num="0057">The blocks (e.g., CTUs or CUs) may be grouped in various ways in a picture. As one example, a brick may refer to a rectangular region of CTU rows within a particular tile in a picture. A tile may be a rectangular region of CTUs within a particular tile column and a particular tile row in a picture. A tile column refers to a rectangular region of CTUs having a height equal to the height of the picture and a width specified by syntax elements (e.g., such as in a picture parameter set). A tile row refers to a rectangular region of CTUs having a height specified by syntax elements (e.g., such as in a picture parameter set) and a width equal to the width of the picture.</p><p id="p-0059" num="0058">In some examples, a tile may be partitioned into multiple bricks, each of which may include one or more CTU rows within the tile. A tile that is not partitioned into multiple bricks may also be referred to as a brick. However, a brick that is a true subset of a tile may not be referred to as a tile. The bricks in a picture may also be arranged in a slice. A slice may be an integer number of bricks of a picture that may be exclusively contained in a single network abstraction layer (NAL) unit. In some examples, a slice includes either a number of complete tiles or only a consecutive sequence of complete bricks of one tile.</p><p id="p-0060" num="0059">This disclosure may use &#x201c;N&#xd7;N&#x201d; and &#x201c;N by N&#x201d; interchangeably to refer to the sample dimensions of a block (such as a CU or other video block) in terms of vertical and horizontal dimensions, e.g., 16&#xd7;16 samples or 16 by 16 samples. In general, a 16&#xd7;16 CU has 16 samples in a vertical direction (y=16) and 16 samples in a horizontal direction (x=16). Likewise, an N&#xd7;N CU generally has N samples in a vertical direction and N samples in a horizontal direction, where N represents a nonnegative integer value. The samples in a CU may be arranged in rows and columns. Moreover, CUs need not necessarily have the same number of samples in the horizontal direction as in the vertical direction. For example, CUs may comprise N&#xd7;M samples, where M is not necessarily equal to N.</p><p id="p-0061" num="0060">Video encoder <b>200</b> encodes video data for CUs representing prediction and/or residual information, and other information. The prediction information indicates how the CU is to be predicted in order to form a prediction block for the CU. The residual information generally represents sample-by-sample differences between samples of the CU prior to encoding and the prediction block.</p><p id="p-0062" num="0061">To predict a CU, video encoder <b>200</b> may generally form a prediction block for the CU through inter-prediction or intra-prediction. Inter-prediction generally refers to predicting the CU from data of a previously coded picture, whereas intra-prediction generally refers to predicting the CU from previously coded data of the same picture. To perform inter-prediction, video encoder <b>200</b> may generate the prediction block using one or more motion vectors. Video encoder <b>200</b> may generally perform a motion search to identify a reference block that closely matches the CU, e.g., in terms of differences between the CU and the reference block. Video encoder <b>200</b> may calculate a difference metric using a sum of absolute difference (SAD), sum of squared differences (SSD), mean absolute difference (MAD), mean squared differences (MSD), or other such difference calculations to determine whether a reference block closely matches the current CU. In some examples, video encoder <b>200</b> may predict the current CU using uni-directional prediction or bi-directional prediction.</p><p id="p-0063" num="0062">Some examples of VVC also provide an affine motion compensation mode, which may be considered an inter-prediction mode. In affine motion compensation mode, video encoder <b>200</b> may determine two or more motion vectors that represent non-translational motion, such as zoom in or out, rotation, perspective motion, or other irregular motion types.</p><p id="p-0064" num="0063">To perform intra-prediction, video encoder <b>200</b> may select an intra-prediction mode to generate the prediction block. Some examples of VVC provide sixty-seven intra-prediction modes, including various directional modes, as well as planar mode and DC mode. In general, video encoder <b>200</b> selects an intra-prediction mode that describes neighboring samples to a current block (e.g., a block of a CU) from which to predict samples of the current block. Such samples may generally be above, above and to the left, or to the left of the current block in the same picture as the current block, assuming video encoder <b>200</b> codes CTUs and CUs in raster scan order (left to right, top to bottom).</p><p id="p-0065" num="0064">Video encoder <b>200</b> encodes data representing the prediction mode for a current block. For example, for inter-prediction modes, video encoder <b>200</b> may encode data representing which of the various available inter-prediction modes is used, as well as motion information for the corresponding mode. For uni-directional or bi-directional inter-prediction, for example, video encoder <b>200</b> may encode motion vectors using advanced motion vector prediction (AMVP) or merge mode. Video encoder <b>200</b> may use similar modes to encode motion vectors for affine motion compensation mode.</p><p id="p-0066" num="0065">AV1 includes two general techniques for encoding and decoding a coding block of video data. The two general techniques are intra prediction (e.g., intra frame prediction or spatial prediction) and inter prediction (e.g., inter frame prediction or temporal prediction). In the context of AV1, when predicting blocks of a current frame of video data using an intra prediction mode, video encoder <b>200</b> and video decoder <b>300</b> do not use video data from other frames of video data. For most intra prediction modes, video encoder <b>200</b> encodes blocks of a current frame based on the difference between sample values in the current block and predicted values generated from reference samples in the same frame. Video encoder <b>200</b> determines predicted values generated from the reference samples based on the intra prediction mode.</p><p id="p-0067" num="0066">Following prediction, such as intra-prediction or inter-prediction of a block, video encoder <b>200</b> may calculate residual data for the block. The residual data, such as a residual block, represents sample by sample differences between the block and a prediction block for the block, formed using the corresponding prediction mode. Video encoder <b>200</b> may apply one or more transforms to the residual block, to produce transformed data in a transform domain instead of the sample domain. For example, video encoder <b>200</b> may apply a discrete cosine transform (DCT), an integer transform, a wavelet transform, or a conceptually similar transform to residual video data. Additionally, video encoder <b>200</b> may apply a secondary transform following the first transform, such as a mode-dependent non-separable secondary transform (MDNSST), a signal dependent transform, a Karhunen-Loeve transform (KLT), or the like. Video encoder <b>200</b> produces transform coefficients following application of the one or more transforms.</p><p id="p-0068" num="0067">As noted above, following any transforms to produce transform coefficients, video encoder <b>200</b> may perform quantization of the transform coefficients. Quantization generally refers to a process in which transform coefficients are quantized to possibly reduce the amount of data used to represent the transform coefficients, providing further compression. By performing the quantization process, video encoder <b>200</b> may reduce the bit depth associated with some or all of the transform coefficients. For example, video encoder <b>200</b> may round an n-bit value down to an rn-bit value during quantization, where n is greater than m. In some examples, to perform quantization, video encoder <b>200</b> may perform a bitwise right-shift of the value to be quantized.</p><p id="p-0069" num="0068">Following quantization, video encoder <b>200</b> may scan the transform coefficients, producing a one-dimensional vector from the two-dimensional matrix including the quantized transform coefficients. The scan may be designed to place higher energy (and therefore lower frequency) transform coefficients at the front of the vector and to place lower energy (and therefore higher frequency) transform coefficients at the back of the vector. In some examples, video encoder <b>200</b> may utilize a predefined scan order to scan the quantized transform coefficients to produce a serialized vector, and then entropy encode the quantized transform coefficients of the vector. In other examples, video encoder <b>200</b> may perform an adaptive scan. After scanning the quantized transform coefficients to form the one-dimensional vector, video encoder <b>200</b> may entropy encode the one-dimensional vector, e.g., according to context-adaptive binary arithmetic coding (CABAC). Video encoder <b>200</b> may also entropy encode values for syntax elements describing metadata associated with the encoded video data for use by video decoder <b>300</b> in decoding the video data.</p><p id="p-0070" num="0069">To perform CABAC, video encoder <b>200</b> may assign a context within a context model to a symbol to be transmitted. The context may relate to, for example, whether neighboring values of the symbol are zero-valued or not. The probability determination may be based on a context assigned to the symbol.</p><p id="p-0071" num="0070">Video encoder <b>200</b> may further generate syntax data, such as block-based syntax data, picture-based syntax data, and sequence-based syntax data, to video decoder <b>300</b>, e.g., in a picture header, a block header, a slice header, or other syntax data, such as a sequence parameter set (SPS), picture parameter set (PPS), or video parameter set (VPS). Video decoder <b>300</b> may likewise decode such syntax data to determine how to decode corresponding video data.</p><p id="p-0072" num="0071">In this manner, video encoder <b>200</b> may generate a bitstream including encoded video data, e.g., syntax elements describing partitioning of a picture into blocks (e.g., CUs) and prediction and/or residual information for the blocks. Ultimately, video decoder <b>300</b> may receive the bitstream and decode the encoded video data.</p><p id="p-0073" num="0072">In general, video decoder <b>300</b> performs a reciprocal process to that performed by video encoder <b>200</b> to decode the encoded video data of the bitstream. For example, video decoder <b>300</b> may decode values for syntax elements of the bitstream using CABAC in a manner substantially similar to, albeit reciprocal to, the CABAC encoding process of video encoder <b>200</b>. The syntax elements may define partitioning information for partitioning of a picture into CTUs, and partitioning of each CTU according to a corresponding partition structure, such as a QTBT structure, to define CUs of the CTU. The syntax elements may further define prediction and residual information for blocks (e.g., CUs) of video data.</p><p id="p-0074" num="0073">The residual information may be represented by, for example, quantized transform coefficients. Video decoder <b>300</b> may inverse quantize and inverse transform the quantized transform coefficients of a block to reproduce a residual block for the block. Video decoder <b>300</b> uses a signaled prediction mode (intra- or inter-prediction) and related prediction information (e.g., motion information for inter-prediction) to form a prediction block for the block. Video decoder <b>300</b> may then combine the prediction block and the residual block (on a sample-by-sample basis) to reproduce the original block. Video decoder <b>300</b> may perform additional processing, such as performing a deblocking process to reduce visual artifacts along boundaries of the block.</p><p id="p-0075" num="0074">This disclosure may generally refer to &#x201c;signaling&#x201d; certain information, such as syntax elements. The term &#x201c;signaling&#x201d; may generally refer to the communication of values for syntax elements and/or other data used to decode encoded video data. That is, video encoder <b>200</b> may signal values for syntax elements in the bitstream. In general, signaling refers to generating a value in the bitstream. As noted above, source device <b>102</b> may transport the bitstream to destination device <b>116</b> substantially in real time, or not in real time, such as might occur when storing syntax elements to storage device <b>112</b> for later retrieval by destination device <b>116</b>.</p><p id="p-0076" num="0075"><figref idref="DRAWINGS">FIGS. <b>2</b>A and <b>2</b>B</figref> are conceptual diagrams illustrating example spatial neighboring motion vector candidates for coding motion vectors in merge mode and advanced motion vector prediction (AMVP) mode. In particular, <figref idref="DRAWINGS">FIG. <b>2</b>A</figref> depicts spatial neighboring motion vector (MV) candidates to PU<b>0</b> <b>130</b> for merge mode, while <figref idref="DRAWINGS">FIG. <b>2</b>B</figref> depicts spatial neighboring MV candidates to PU<b>0</b> <b>132</b> for AMVP mode.</p><p id="p-0077" num="0076">In the HEVC standard, there are two inter prediction modes, named merge (skip is considered as a special case of merge) and advanced motion vector prediction (AMVP) modes respectively for a prediction unit (PU). In either AMVP or merge mode, a motion vector (MV) candidate list is maintained for multiple motion vector predictors. The motion vector(s), as well as reference indices in the merge mode, of the current PU are generated by taking one candidate from the MV candidate list. The MV candidate list contains up to 5 candidates for the merge mode and only two candidates for the AMVP mode. A merge candidate may contain a set of motion information, e.g., motion vectors corresponding to both reference picture lists (list 0 and list 1) and the reference indices. If a merge candidate is identified by a merge index, the reference pictures used for the prediction of the current blocks, as well as the associated motion vectors are determined.</p><p id="p-0078" num="0077">On the other hand, under AMVP mode for each potential prediction direction from either list 0 or list 1, a reference index needs to be explicitly signaled, together with an MV predictor (MVP) index to the MV candidate list since the AMVP candidate contains only a motion vector. In AMVP mode, the predicted motion vectors can be further refined. The candidates for both modes are derived similarly from the same spatial and temporal neighboring blocks.</p><p id="p-0079" num="0078">According to HEVC, spatial MV candidates are derived from the neighboring blocks shown in <figref idref="DRAWINGS">FIGS. <b>2</b>A and <b>2</b>B</figref>, for a specific PU (PU<b>0</b>), although the methods generating the candidates from the blocks differ for merge and AMVP modes. In merge mode, up to four spatial MV candidates can be derived for PU<b>0</b> <b>130</b> with the orders showed on <figref idref="DRAWINGS">FIG. <b>2</b>A</figref> with numbers, and the order is the following: left (<b>0</b>, A<b>1</b>), above (<b>1</b>, B<b>1</b>), above right (<b>2</b>, B<b>0</b>), below left (<b>3</b>, A<b>0</b>), and above left (<b>4</b>, B<b>2</b>).</p><p id="p-0080" num="0079">In AVMP mode, the neighboring blocks are divided into two groups: left group consisting of the block <b>0</b> and <b>1</b>, and above group consisting of the blocks <b>2</b>, <b>3</b>, and <b>4</b> as shown in <figref idref="DRAWINGS">FIG. <b>2</b>B</figref>. For each group, the potential candidate in a neighboring block to PU<b>0</b> <b>132</b> referring to the same reference picture as that indicated by the signaled reference index has the highest priority to be chosen to form a final candidate of the group. It is possible that not all neighboring blocks contain a motion vector pointing to the same reference picture. Therefore, if such a candidate cannot be found, the first available candidate may be scaled to form the final candidate; thus, the temporal distance differences can be compensated.</p><p id="p-0081" num="0080"><figref idref="DRAWINGS">FIGS. <b>3</b>A and <b>3</b>B</figref> are conceptual diagrams illustrating temporal motion vector prediction (TMVP) techniques. In particular, <figref idref="DRAWINGS">FIG. <b>3</b>A</figref> depicts locations of a TMVP candidate for PU<b>0</b> <b>134</b>, labeled &#x201c;T,&#x201d; while <figref idref="DRAWINGS">FIG. <b>3</b>B</figref> depicts motion vector scaling based on temporal distances between pictures.</p><p id="p-0082" num="0081">If TMVP is enabled and a TMVP candidate is available, a video coder may add the TMVP candidate into the MV candidate list after the spatial MV candidates. The process of motion vector derivation for the TMVP candidate is the same for both merge and AMVP modes. However, the target reference index for the TMVP candidate in the merge mode may be set to 0.</p><p id="p-0083" num="0082">The primary block location for TMVP candidate derivation is the bottom right block outside of the collocated PU, as shown in <figref idref="DRAWINGS">FIG. <b>3</b>A</figref> as a block <b>136</b>A, to compensate the bias to the above and left blocks used to generate spatial neighboring candidates. However, if block <b>136</b>A is located outside of the current CTB row or motion information is not available, the TMVP candidate may be substituted with a center block of the PU, block <b>136</b>B.</p><p id="p-0084" num="0083">Motion vector for TMVP candidate is derived from the co-located PU of the co-located picture, indicated in the slice level. The motion vector for the co-located PU is called collocated MV. Similar to temporal direct mode in AVC, to derive the TMVP candidate motion vector, the co-located MV need to be scaled to compensate the temporal distance differences, as shown in <figref idref="DRAWINGS">FIG. <b>3</b>B</figref>.</p><p id="p-0085" num="0084">HEVC includes various other motion vector prediction techniques, e.g., as discussed below.</p><p id="p-0086" num="0085">It is assumed that the value of motion vectors is proportional to the distance of pictures in the presentation time. A motion vector associates two pictures, the reference picture, and the picture containing the motion vector (namely the containing picture). When a motion vector is utilized to predict the other motion vector, the distance of the containing picture and the reference picture is calculated based on the Picture Order Count (POC) values.</p><p id="p-0087" num="0086">For a motion vector to be predicted, both its associated containing picture and reference picture may be different. Therefore, a new distance (based on POC) is calculated. And the motion vector is scaled based on these two POC distances. For a spatial neighboring candidate, the containing pictures for the two motion vectors are the same, while the reference pictures are different. In HEVC, motion vector scaling applies to both TMVP and AMVP for spatial and temporal neighboring candidates.</p><p id="p-0088" num="0087">If a motion vector candidate list is not complete, artificial motion vector candidates may be generated and inserted at the end of the list until the list is full with candidates. In merge mode, there are two types of artificial MV candidates: combined candidate derived only for B-slices and zero candidates used only for AMVP if the first type does not provide enough artificial candidates. For each pair of candidates that are already in the candidate list and have necessary motion information, bi-directional combined motion vector candidates are derived by a combination of the motion vector of the first candidate referring to a picture in the list 0 and the motion vector of a second candidate referring to a picture in the list 1.</p><p id="p-0089" num="0088">Candidates from different blocks may happen to be the same, which decreases the efficiency of a merge/AMVP candidate list. A video coder may apply a pruning process to solve this problem. Using the pruning process, the video coder may compare one candidate against the others in the current candidate list to avoid inserting identical candidate in certain extent. To reduce the complexity, only a limited number of pruning process iterations may be applied, instead of comparing each potential one with all the other existing ones.</p><p id="p-0090" num="0089"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a conceptual diagram illustrating template matching (TM) prediction for motion vector coding. Template matching (TM) prediction is a special merge mode based on Frame-Rate Up Conversion (FRUC) techniques. With this mode, motion information of a current block (such as current CU <b>140</b>) is not signalled but derived at decoder side (e.g., by video decoder <b>300</b>). Video encoder <b>200</b> may also perform these techniques during motion compensation. TM is applied to both AMVP mode and regular merge mode. In AMVP mode, MVP candidate selection is determined based on template matching to pick up the one which reaches the minimal difference between current block template and reference block template. In regular merge mode, a TM mode flag is signalled to indicate the use of TM and then TM is applied to the merge candidate indicated by merge index for MV refinement.</p><p id="p-0091" num="0090">As shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref>, template matching may be used to derive motion information of current CU <b>140</b> by finding the closest match between a template (top and/or left neighboring blocks of the current CU) in current picture <b>142</b> and a block (same size to the template) in reference picture <b>144</b>. With an AMVP candidate selected based on initial matching error, its MVP is refined by template matching within search area <b>146</b>. With a merge candidate indicated by a signaled merge index, its merged MVs corresponding to L0 and L1 are refined independently by template matching and then the less accurate one is further refined again with the better one as a prior.</p><p id="p-0092" num="0091">When a motion vector points to a fractional sample position, motion compensated interpolation is needed. To reduce complexity, bi-linear interpolation instead of regular 8-tap DCT-IF interpolation is used for both template matching to generate templates on reference pictures. The matching cost C of template matching may be calculated as follows:</p><p id="p-0093" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>C</i>=SAD+<i>w</i>&#xb7;(|MV<sub>x</sub>-MV<sub>x</sub><sup>s</sup>|+|MV<sub>y</sub>-MV<sub>y</sub><sup>s</sup>|) &#x2003;&#x2003;(1)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0094" num="0092">In formula (1) above, w is a weighting factor which may be set to 4 (e.g., based on empirical testing), MV and MV<sup>s </sup>indicate the currently tested MV and the initial MV (i.e., a MVP candidate in AMVP mode or merged motion in merge mode), respectively. Sum of absolute difference (SAD) may be used as the matching cost of template matching.</p><p id="p-0095" num="0093">When TM is used, motion may be refined using luma samples only. The derived motion may be used for both luma and chroma for MC inter prediction. After the MV is decided, a final MC may be performed using an 8-tap interpolation filter for luma and a 4-tap interpolation filter for chroma.</p><p id="p-0096" num="0094">MV refinement is a pattern-based MV search with the criterion of template matching cost and a hierarchical structure. Two search patterns may be supported: a diamond search and a cross search for MV refinement. The hierarchical structure specifies an iterative process to refine MV, starting at a coarse MVD precision (e.g., quarter-pel) and ending at a fine one (e.g., &#x215b;-pel). The MV may be directly searched at quarter luma sample MVD precision with diamond pattern, followed by quarter luma sample MVD precision with cross pattern, and then this is followed by one-eighth luma sample MVD refinement with cross pattern. Search range 146 of MV refinement may be set equal to (&#x2212;8, +8) luma samples around the initial MV. When the current block is of bi-prediction, both MVs are refined independently, and then the best of which (in terms of matching cost) is set as a prior to further refine the other MV with BCW weight values.</p><p id="p-0097" num="0095"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a conceptual diagram illustrating motion vector difference (MVD) values for blocks in reference pictures having different temporal distances (TDs) to a current picture including current block <b>150</b>. Bilateral Matching (a.k.a., Bilateral Merge or BM) prediction is another merge mode based on Frame-Rate Up Conversion (FRUC) techniques. When a video coder (such as video encoder <b>200</b> or video decoder <b>300</b>) determines to apply the BM mode, the video coder may derive two initial motion vectors MV<b>0</b> and MV<b>1</b>. The video coder may code a merge candidate index representing the merge candidate in a constructed merge list. The video coder may perform a Bilateral Matching search around MV<b>0</b> and MV<b>1</b>. The video coder may derive the final MV<b>0</b>&#x2032; and MV<b>1</b>&#x2032; based on the minimum Bilateral Matching cost.</p><p id="p-0098" num="0096">The motion vector difference MVD<b>0</b> (denoted by MV<b>0</b>&#x2032;&#x2212;MV<b>0</b>) and MVD<b>1</b> (denoted by MV<b>1</b>&#x2032;&#x2212;MV<b>1</b>) pointing to reference blocks <b>152</b>, <b>154</b> may be proportional to the temporal distances (TD), e.g., TD<b>0</b> and TD<b>1</b>, between the current picture and the two reference pictures. The temporal distances may represent differences between picture order count (POC) values for the respective pictures. <figref idref="DRAWINGS">FIG. <b>5</b></figref> shows an example of MVD<b>0</b> and MVD<b>1</b>, where TD<b>1</b> is 4 times that of TD<b>0</b>.</p><p id="p-0099" num="0097"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a conceptual diagram illustrating an example in which two MVDs are mirrored regardless of temporal distances. <figref idref="DRAWINGS">FIG. <b>6</b></figref> depicts an optional design in which MVD<b>0</b> and MVD<b>1</b> are mirrored regardless of TD<b>0</b> and TD<b>1</b>. In the example of <figref idref="DRAWINGS">FIG. <b>6</b></figref>, MVD<b>0</b> and MVD<b>1</b> are mirrored, where TD<b>1</b> is 4 times of TD<b>0</b>.</p><p id="p-0100" num="0098"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is conceptual diagram illustrating an example of a 3&#xd7;3 square search pattern in a bilateral matching search range. According to bilateral matching, a video coder (such as video encoder <b>200</b> and video decoder <b>300</b>) may perform a local search around the initial MV<b>0</b> and MV<b>1</b> to derive the final MV<b>0</b>&#x2032; and MV<b>1</b>&#x2032;. The video coder may apply the local search to a 3&#xd7;3 square search pattern and loop through the search range [&#x2212;8, 8]. In each search iteration, the video coder may calculate the bilateral matching cost of the eight surrounding MVs in the search pattern and compare these costs to the bilateral matching cost of the center MV. The MV which has minimum bilateral matching cost becomes the new center MV in the next search iteration. The video coder may terminate the local search when the current center MV has a minimum cost within the 3&#xd7;3 square search pattern or the local search reaches the pre-defined maximum search iteration. <figref idref="DRAWINGS">FIG. <b>7</b></figref> shows an example of the 3&#xd7;3 square search pattern in the search range [&#x2212;8, 8].</p><p id="p-0101" num="0099"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a conceptual diagram illustrating an example of refining a motion vector using decoder-side motion vector refinement (DMVR) for current block <b>160</b>. To increase the accuracy of the MVs of the merge mode, a decoder side motion vector refinement (DMVR) is applied in VVC. Both video encoder <b>200</b> and video decoder <b>300</b> may perform the DMVR process. In bi-prediction operation, a refined MV is searched around initial MVs in the reference picture list L<b>0</b> and reference picture list L<b>1</b>. The video coder, according to the DMVR technique, calculates the distortion between two candidate blocks <b>162</b>A, <b>164</b>A in the reference picture list L<b>0</b> and list L<b>1</b>. As illustrated in <figref idref="DRAWINGS">FIG. <b>8</b></figref>, the SAD between candidate blocks <b>162</b>B, <b>164</b>B based on each MV candidate around the initial MV is calculated. The MV candidates <b>162</b>B, <b>164</b>B with the lowest SAD becomes the refined MV and used to generate the bi-predicted signal.</p><p id="p-0102" num="0100">The refined MV derived by DMVR process is used to generate the inter prediction samples and also used in temporal motion vector prediction for future pictures coding. While the original MV is used in deblocking process and also used in spatial motion vector prediction for future CU coding. DMVR is a subblock-based merge mode with a pre-defined maximum processing unit of 16&#xd7;16 luma samples. When the width and/or height of a CU are larger than 16 luma samples, the CU may be further split into subblocks with width and/or height equal to 16 luma samples.</p><p id="p-0103" num="0101">In DMVR, the search points are surrounding the initial MV and the MV offset obey the MV difference mirroring rule. In other words, any points that are checked by DMVR, denoted by candidate MV pair (MV<b>0</b>, MV<b>1</b>) obey the following two equations:</p><p id="p-0104" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>MV<b>0</b>&#x2032;=MV<b>0</b>+MV_offset<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0105" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>MV<b>1</b>&#x2032;=MV<b>1</b>&#x2212;MV_offset<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0106" num="0102">In the equations above, MV_offset represents the refinement offset between the initial MV and the refined MV in one of the reference pictures. The refinement search range is two integer luma samples from the initial MV. The searching includes the integer sample offset search stage and fractional sample refinement stage.</p><p id="p-0107" num="0103">A video coder may perform a 25 points full search for integer sample offset searching. The SAD of the initial MV pair is first calculated. If the SAD of the initial MV pair is smaller than a threshold, the integer sample stage of DMVR is terminated. Otherwise SADs of the remaining 24 points are calculated and checked in raster scanning order. The point with the smallest SAD is selected as the output of integer sample offset searching stage. To reduce the penalty of the uncertainty of DMVR refinement, it is proposed to favor the original MV during the DMVR process. The SAD between the reference blocks referred by the initial MV candidates is decreased by &#xbc; of the SAD value.</p><p id="p-0108" num="0104">The integer sample search is followed by fractional sample refinement. To save the calculational complexity, the fractional sample refinement is derived by using parametric error surface equation, instead of additional search with SAD comparison. The fractional sample refinement is conditionally invoked based on the output of the integer sample search stage. When the integer sample search stage is terminated with center having the smallest SAD in either the first iteration or the second iteration search, the fractional sample refinement is further applied.</p><p id="p-0109" num="0105">In parametric error surface based sub-pixel offsets estimation, the center position cost and the costs at four neighboring positions from the center are used to fit a 2-D parabolic error surface equation of the following form:</p><p id="p-0110" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>E</i><sub>x, y</sub><i>=A</i>(<i>x&#x2212;x</i><sub>min</sub>)<sup>2</sup><i>+B</i>(<i>y&#x2212;y</i><sub>min</sub>)<sup>2</sup><i>+C </i><?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0111" num="0000">where (x<sub>min</sub>, y<sub>min</sub>) corresponds to the fractional position with the least cost and C corresponds to the minimum cost value. Solving the above equations using the cost value of the five search points, the (x<sub>min</sub>, y<sub>min</sub>) may be computed as:</p><p id="p-0112" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>x</i><sub>min</sub>=(<i>E</i><sub>&#x2212;1,0</sub><i>&#x2212;E</i><sub>1,0</sub>)/2(<i>E</i><sub>&#x2212;1,0</sub><i>+E</i><sub>1,0</sub>&#x2212;2<i>E</i><sub>0,0</sub>)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0113" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>y</i><sub>min</sub>=(<i>E</i><sub>0,&#x2212;1</sub><i>&#x2212;E</i><sub>0,1</sub>)/2(<i>E</i><sub>0,&#x2212;1</sub><i>+E</i><sub>0,1</sub>&#x2212;2<i>E</i><sub>0,0</sub>)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0114" num="0106">The value of x<sub>min </sub>and y<sub>min </sub>may be automatically constrained to be between &#x2212;8 and 8, since all cost values are positive and the smallest value is E(0, 0). This corresponds to half pixel (pel) offset with 1/16th-pel MV accuracy in VVC. The computed fractional (x<sub>min</sub>, y<sub>min</sub>) are added to the integer distance refinement MV to get the sub-pixel accurate refinement delta MV.</p><p id="p-0115" num="0107">In VVC, the resolution of the MVs is 1/16 luma samples. The samples at the fractional position are interpolated using a 8-tap interpolation filter. In DMVR, the search points are surrounding the initial fractional-pel MV with integer sample offset, therefore the samples of those fractional position need to be interpolated for DMVR search process. To reduce the calculation complexity, the bi-linear interpolation filter is used to generate the fractional samples for the searching process in DMVR. Another important effect is that by using bi-linear filter is that with 2-sample search range, the DVMR does not access more reference samples compared to the normal motion compensation process. After the refined MV is attained with DMVR search process, the normal 8-tap interpolation filter is applied to generate the final prediction. In order to not access more reference samples to normal MC process, the samples, which is not needed for the interpolation process based on the original MV but is needed for the interpolation process based on the refined MV, may be padded from those available samples.</p><p id="p-0116" num="0108">In VVC, DMVR is enabled if the following conditions are all satisfied:<ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0109">CU level merge mode with bi-prediction MV</li>        <li id="ul0002-0002" num="0110">One reference picture is in the past and another reference picture is in the future with respect to the current picture</li>        <li id="ul0002-0003" num="0111">The distances (i.e., POC difference) from both reference pictures to the current picture are same</li>        <li id="ul0002-0004" num="0112">CU has more than 64 luma samples</li>        <li id="ul0002-0005" num="0113">Both CU height and CU width are larger than or equal to 8 luma samples</li>        <li id="ul0002-0006" num="0114">BCW weight index indicates equal weight</li>        <li id="ul0002-0007" num="0115">WP is not enabled for the current block</li>        <li id="ul0002-0008" num="0116">CIIP mode is not used for the current block</li>    </ul>    </li></ul></p><p id="p-0117" num="0117">This disclosure recognizes that there may be hardware implementation issues relating to the DMVD methods discussed above (e.g., TM, BM, DMVR, multi-pass DMVR (U.S. Provisional Application No. 63/129,221, filed Dec. 22, 2020)). In particular, this disclosure recognizes two major hardware implementation issues: spatial motion vector propagation and neighboring reconstruction sample accessing.</p><p id="p-0118" num="0118">Spatial motion vector propagation with refinement vector information to subsequent blocks for spatial motion vector prediction is a critical hardware implementation burden for all DMVD methods. Motion field reconstruction, reference sample fetching and motion compensation (i.e., all operations that requires accessing reference samples, such as interpolation process and DMVD methods) are usually separated in different pipeline stages and the first two have to be done several cycles (or a few CTUs) ahead of motion compensation to ensure reference samples are always ready on chip for interpolation. Since the refinement vector information is unknown during the first two stages, all three can only be done sequentially which breaks the pipeline design and increase decoding latency.</p><p id="p-0119" num="0119">One work-around solution is to fetch more reference samples to cover all possible ones that may be used during motion compensation; however, due to spatial MV prediction, the refinement motion information may carry over to subsequent blocks and accumulates spatially, resulting in an indeterminable size of reference samples to be fetched from reference pictures. As a result, there is nothing different from fetching everything from reference pictures that requires increasing on-chip memory buffer to keep them and would hurt cache hit ratio. Another work-around solution is to stop propagating refinement vector information to subsequent blocks in the current picture, at the risk of losing MV prediction efficiency significantly.</p><p id="p-0120" num="0120">Accessing neighboring reconstruction samples for template matching to generate a current block template also incurs longer latency in decoding. Without template matching, inter blocks can be reconstructed independently regardless of neighboring block reconstruction (unlike intra block which has to wait for neighboring block reconstruction to perform intra prediction). However, template matching requires accessing neighboring reconstructed samples, which implies that certain inter-dependency is introduced to current block and neighboring block reconstruction in inter prediction, resulting in increase of decoding latency.</p><p id="p-0121" num="0121">Video encoder <b>200</b> and video decoder <b>300</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref> and of <figref idref="DRAWINGS">FIGS. <b>9</b> and <b>10</b></figref> below may be configured to perform techniques that may overcome these issues.</p><p id="p-0122" num="0122">In one example, video encoder <b>200</b> and video decoder <b>300</b> may be configured with a constrained search range for DMVD. While referred to as &#x201c;decoder-side motion vector derivation,&#x201d; it should be understood that video encoder <b>200</b> may also perform DMVD techniques, such that video data used for reference by video encoder <b>200</b> accurately reflects the video data decoded and used for reference by video decoder <b>300</b>. In particular, video encoder <b>200</b> includes a decoder loop as well, during which DMVD techniques may be performed. Thus, both video encoder <b>200</b> and video decoder <b>300</b> may perform DMVD techniques of this disclosure.</p><p id="p-0123" num="0123">A search range constraint may be imposed on decoder-side motion vector derivation (DMVD) techniques (such as TM, BM, DMVR, multi-pass DMVR) performed by video encoder <b>200</b> and video decoder <b>300</b> to limit the number of reference samples fetched from reference frames within a deterministic bounding box, which contains the largest possible reference area of a reference picture. Without loss of generality, the following discussion includes description only of the uni-prediction case. However, the same techniques can be directly applied to bi-prediction cases.</p><p id="p-0124" num="0124"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a block diagram illustrating an example video encoder <b>200</b> that may perform the techniques of this disclosure. <figref idref="DRAWINGS">FIG. <b>9</b></figref> is provided for purposes of explanation and should not be considered limiting of the techniques as broadly exemplified and described in this disclosure. For purposes of explanation, this disclosure describes video encoder <b>200</b> according to the techniques of VVC (ITU-T H.266, under development) and HEVC (ITU-T H.265). However, the techniques of this disclosure may be performed by video encoding devices that are configured to other video coding standards and video coding formats, such as AV1 and successors to the AV1 video coding format.</p><p id="p-0125" num="0125">In the example of <figref idref="DRAWINGS">FIG. <b>9</b></figref>, video encoder <b>200</b> includes video data memory <b>230</b>, mode selection unit <b>202</b>, residual generation unit <b>204</b>, transform processing unit <b>206</b>, quantization unit <b>208</b>, inverse quantization unit <b>210</b>, inverse transform processing unit <b>212</b>, reconstruction unit <b>214</b>, filter unit <b>216</b>, decoded picture buffer (DPB) <b>218</b>, and entropy encoding unit <b>220</b>. Any or all of video data memory <b>230</b>, mode selection unit <b>202</b>, residual generation unit <b>204</b>, transform processing unit <b>206</b>, quantization unit <b>208</b>, inverse quantization unit <b>210</b>, inverse transform processing unit <b>212</b>, reconstruction unit <b>214</b>, filter unit <b>216</b>, DPB <b>218</b>, and entropy encoding unit <b>220</b> may be implemented in one or more processors or in processing circuitry. For instance, the units of video encoder <b>200</b> may be implemented as one or more circuits or logic elements as part of hardware circuitry, or as part of a processor, ASIC, or FPGA. Moreover, video encoder <b>200</b> may include additional or alternative processors or processing circuitry to perform these and other functions.</p><p id="p-0126" num="0126">Video data memory <b>230</b> may store video data to be encoded by the components of video encoder <b>200</b>. Video encoder <b>200</b> may receive the video data stored in video data memory <b>230</b> from, for example, video source <b>104</b> (<figref idref="DRAWINGS">FIG. <b>1</b></figref>). DPB <b>218</b> may act as a reference picture memory that stores reference video data for use in prediction of subsequent video data by video encoder <b>200</b>. Video data memory <b>230</b> and DPB <b>218</b> may be formed by any of a variety of memory devices, such as dynamic random access memory (DRAM), including synchronous DRAM (SDRAM), magnetoresistive RAM (MRAM), resistive RAM (RRAM), or other types of memory devices. Video data memory <b>230</b> and DPB <b>218</b> may be provided by the same memory device or separate memory devices. In various examples, video data memory <b>230</b> may be on-chip with other components of video encoder <b>200</b>, as illustrated, or off-chip relative to those components.</p><p id="p-0127" num="0127">In this disclosure, reference to video data memory <b>230</b> should not be interpreted as being limited to memory internal to video encoder <b>200</b>, unless specifically described as such, or memory external to video encoder <b>200</b>, unless specifically described as such. Rather, reference to video data memory <b>230</b> should be understood as reference memory that stores video data that video encoder <b>200</b> receives for encoding (e.g., video data for a current block that is to be encoded). Memory <b>106</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref> may also provide temporary storage of outputs from the various units of video encoder <b>200</b>.</p><p id="p-0128" num="0128">The various units of <figref idref="DRAWINGS">FIG. <b>9</b></figref> are illustrated to assist with understanding the operations performed by video encoder <b>200</b>. The units may be implemented as fixed-function circuits, programmable circuits, or a combination thereof. Fixed-function circuits refer to circuits that provide particular functionality, and are preset on the operations that can be performed. Programmable circuits refer to circuits that can be programmed to perform various tasks, and provide flexible functionality in the operations that can be performed. For instance, programmable circuits may execute software or firmware that cause the programmable circuits to operate in the manner defined by instructions of the software or firmware. Fixed-function circuits may execute software instructions (e.g., to receive parameters or output parameters), but the types of operations that the fixed-function circuits perform are generally immutable. In some examples, one or more of the units may be distinct circuit blocks (fixed-function or programmable), and in some examples, one or more of the units may be integrated circuits.</p><p id="p-0129" num="0129">Video encoder <b>200</b> may include arithmetic logic units (ALUs), elementary function units (EFUs), digital circuits, analog circuits, and/or programmable cores, formed from programmable circuits. In examples where the operations of video encoder <b>200</b> are performed using software executed by the programmable circuits, memory <b>106</b> (<figref idref="DRAWINGS">FIG. <b>1</b></figref>) may store the instructions (e.g., object code) of the software that video encoder <b>200</b> receives and executes, or another memory within video encoder <b>200</b> (not shown) may store such instructions.</p><p id="p-0130" num="0130">Video data memory <b>230</b> is configured to store received video data. Video encoder <b>200</b> may retrieve a picture of the video data from video data memory <b>230</b> and provide the video data to residual generation unit <b>204</b> and mode selection unit <b>202</b>. Video data in video data memory <b>230</b> may be raw video data that is to be encoded.</p><p id="p-0131" num="0131">Mode selection unit <b>202</b> includes a motion estimation unit <b>222</b>, a motion compensation unit <b>224</b>, and an intra-prediction unit <b>226</b>. Mode selection unit <b>202</b> may include additional functional units to perform video prediction in accordance with other prediction modes. As examples, mode selection unit <b>202</b> may include a palette unit, an intra-block copy unit (which may be part of motion estimation unit <b>222</b> and/or motion compensation unit <b>224</b>), an affine unit, a linear model (LM) unit, or the like.</p><p id="p-0132" num="0132">Mode selection unit <b>202</b> generally coordinates multiple encoding passes to test combinations of encoding parameters and resulting rate-distortion values for such combinations. The encoding parameters may include partitioning of CTUs into CUs, prediction modes for the CUs, transform types for residual data of the CUs, quantization parameters for residual data of the CUs, and so on. Mode selection unit <b>202</b> may ultimately select the combination of encoding parameters having rate-distortion values that are better than the other tested combinations.</p><p id="p-0133" num="0133">Video encoder <b>200</b> may partition a picture retrieved from video data memory <b>230</b> into a series of CTUs, and encapsulate one or more CTUs within a slice. Mode selection unit <b>202</b> may partition a CTU of the picture in accordance with a tree structure, such as the MTT structure, QTBT structure. superblock structure, or the quad-tree structure described above. As described above, video encoder <b>200</b> may form one or more CUs from partitioning a CTU according to the tree structure. Such a CU may also be referred to generally as a &#x201c;video block&#x201d; or &#x201c;block.&#x201d;</p><p id="p-0134" num="0134">In general, mode selection unit <b>202</b> also controls the components thereof (e.g., motion estimation unit <b>222</b>, motion compensation unit <b>224</b>, and intra-prediction unit <b>226</b>) to generate a prediction block for a current block (e.g., a current CU, or in HEVC, the overlapping portion of a PU and a TU). For inter-prediction of a current block, motion estimation unit <b>222</b> may perform a motion search to identify one or more closely matching reference blocks in one or more reference pictures (e.g., one or more previously coded pictures stored in DPB <b>218</b>). In particular, motion estimation unit <b>222</b> may calculate a value representative of how similar a potential reference block is to the current block, e.g., according to sum of absolute difference (SAD), sum of squared differences (SSD), mean absolute difference (MAD), mean squared differences (MSD), or the like. Motion estimation unit <b>222</b> may generally perform these calculations using sample-by-sample differences between the current block and the reference block being considered. Motion estimation unit <b>222</b> may identify a reference block having a lowest value resulting from these calculations, indicating a reference block that most closely matches the current block.</p><p id="p-0135" num="0135">Motion estimation unit <b>222</b> may form one or more motion vectors (MVs) that defines the positions of the reference blocks in the reference pictures relative to the position of the current block in a current picture. Motion estimation unit <b>222</b> may then provide the motion vectors to motion compensation unit <b>224</b>. For example, for uni-directional inter-prediction, motion estimation unit <b>222</b> may provide a single motion vector, whereas for bi-directional inter-prediction, motion estimation unit <b>222</b> may provide two motion vectors.</p><p id="p-0136" num="0136">Motion compensation unit <b>224</b> may be configured to perform any of the various decoder-side motion vector derivation (DMVD) techniques of this disclosure. While referred to as &#x201c;decoder-side,&#x201d; it should be understood that video encoder <b>200</b> may also perform these techniques, such that reference blocks identified by the derived/refined motion vectors are the same. The term &#x201c;decoder-side&#x201d; is used because the decoder (e.g., video decoder <b>300</b>) is able to derive/refine motion vectors for blocks using one or more various techniques without additional information signaled by video encoder <b>200</b>.</p><p id="p-0137" num="0137">In accordance with techniques of this disclosure, motion compensation unit <b>224</b> may determine a deterministic bounding box from which to retrieve reference samples of reference pictures (e.g., stored in DPB <b>218</b>) for performing DMVD for a current block of video data. The deterministic bounding box may be the same size for any of the various DMVD techniques, e.g., each of template matching (TM), bilateral merge (BM), decoder-side motion vector refinement (DMVR), and/or multi-pass DMVR.</p><p id="p-0138" num="0138">To determine the deterministic bounding box, motion compensation unit <b>224</b> may initially retrieve an unrefined motion vector from a neighboring block to the current block. The unrefined motion vector may be a motion vector that was encoded (and stored) for the neighboring block using data in the bitstream, without having been refined using any of the various DMVD techniques. Thus, motion compensation unit <b>224</b> may refine the motion vector for the neighboring block prior to encoding the neighboring block, but may use the unrefined version of the motion vector for the neighboring block to determine the deterministic bounding box for the current block.</p><p id="p-0139" num="0139">Using the unrefined motion vector for the neighboring block, motion compensation unit <b>224</b> may identify a center sample of the deterministic bounding box in a reference picture. If the center sample is at position (x, y) in the reference picture, the deterministic bounding box may have vertices of (x&#x2212;N, y&#x2212;N), (x&#x2212;N, y+N), (x+N, y&#x2212;N), and (x+N, y+N), where N is a positive integer value. N may be a preconfigured value, a value calculated according to a multiple of an internal motion vector storage precision, or a value video encoder <b>200</b> signals in the bitstream (e.g., in a sequence parameter set (SPS), picture parameter set (PPS), slice header information, block header information, or the like). Again, N may be the same for each of the various DMVD techniques.</p><p id="p-0140" num="0140">Motion compensation unit <b>224</b> may then perform any of the various DMVD techniques of this disclosure (or other DMVD-like techniques), performing a refinement search within the deterministic bounding box. Motion compensation unit <b>224</b> may perform a motion field reconstruction stage using one or more unrefined motion vectors of previously coded blocks to the current block, then perform a reference sample fetching stage using the one or more unrefined motion vectors to retrieve reference samples within the deterministic bounding box. Motion compensation unit <b>224</b> may then perform the DMVD techniques using the retrieved reference samples.</p><p id="p-0141" num="0141">In some examples, when motion compensation unit <b>224</b> performs TM, motion compensation unit <b>224</b> may use only neighboring reconstruction samples to form a current block template.</p><p id="p-0142" num="0142">Ultimately, after deriving or refining one or more motion vectors using one or more DMVD techniques of this disclosure, motion compensation unit <b>224</b> may obtain reference samples to generate a prediction block using the motion vectors. Formation of the prediction block may be performed during a motion compensation stage. For example, motion compensation unit <b>224</b> may retrieve data of the reference block using the motion vector. As another example, if the motion vector has fractional sample precision, motion compensation unit <b>224</b> may interpolate values for the prediction block according to one or more interpolation filters. Moreover, for bi-directional inter-prediction, motion compensation unit <b>224</b> may retrieve data for two reference blocks identified by respective motion vectors and combine the retrieved data, e.g., through sample-by-sample averaging or weighted averaging.</p><p id="p-0143" num="0143">When operating according to the AV1 video coding format, motion estimation unit <b>222</b> and motion compensation unit <b>224</b> may be configured to encode coding blocks of video data (e.g., both luma and chroma coding blocks) using translational motion compensation, affine motion compensation, overlapped block motion compensation (OBMC), and/or compound inter-intra prediction.</p><p id="p-0144" num="0144">As another example, for intra-prediction, or intra-prediction coding, intra-prediction unit <b>226</b> may generate the prediction block from samples neighboring the current block. For example, for directional modes, intra-prediction unit <b>226</b> may generally mathematically combine values of neighboring samples and populate these calculated values in the defined direction across the current block to produce the prediction block. As another example, for DC mode, intra-prediction unit <b>226</b> may calculate an average of the neighboring samples to the current block and generate the prediction block to include this resulting average for each sample of the prediction block.</p><p id="p-0145" num="0145">When operating according to the AV1 video coding format, intra prediction unit <b>226</b> may be configured to encode coding blocks of video data (e.g., both luma and chroma coding blocks) using directional intra prediction, non-directional intra prediction, recursive filter intra prediction, chroma-from-luma (CFL) prediction, intra block copy (IBC), and/or color palette mode. Mode selection unit <b>202</b> may include additional functional units to perform video prediction in accordance with other prediction modes.</p><p id="p-0146" num="0146">Mode selection unit <b>202</b> provides the prediction block to residual generation unit <b>204</b>. Residual generation unit <b>204</b> receives a raw, uncoded version of the current block from video data memory <b>230</b> and the prediction block from mode selection unit <b>202</b>. Residual generation unit <b>204</b> calculates sample-by-sample differences between the current block and the prediction block. The resulting sample-by-sample differences define a residual block for the current block. In some examples, residual generation unit <b>204</b> may also determine differences between sample values in the residual block to generate a residual block using residual differential pulse code modulation (RDPCM). In some examples, residual generation unit <b>204</b> may be formed using one or more subtractor circuits that perform binary subtraction.</p><p id="p-0147" num="0147">In examples where mode selection unit <b>202</b> partitions CUs into PUs, each PU may be associated with a luma prediction unit and corresponding chroma prediction units. Video encoder <b>200</b> and video decoder <b>300</b> may support PUs having various sizes. As indicated above, the size of a CU may refer to the size of the luma coding block of the CU and the size of a PU may refer to the size of a luma prediction unit of the PU. Assuming that the size of a particular CU is 2N&#xd7;2N, video encoder <b>200</b> may support PU sizes of 2N&#xd7;2N or N&#xd7;N for intra prediction, and symmetric PU sizes of 2N&#xd7;2N, 2N&#xd7;N, N&#xd7;2N, N&#xd7;N, or similar for inter prediction. Video encoder <b>200</b> and video decoder <b>300</b> may also support asymmetric partitioning for PU sizes of 2N&#xd7;nU, 2N&#xd7;nD, nL&#xd7;2N, and nR&#xd7;2N for inter prediction.</p><p id="p-0148" num="0148">In examples where mode selection unit <b>202</b> does not further partition a CU into PUs, each CU may be associated with a luma coding block and corresponding chroma coding blocks. As above, the size of a CU may refer to the size of the luma coding block of the CU. The video encoder <b>200</b> and video decoder <b>300</b> may support CU sizes of 2N&#xd7;2N, 2N&#xd7;N, or N&#xd7;2N.</p><p id="p-0149" num="0149">For other video coding techniques such as an intra-block copy mode coding, an affine-mode coding, and linear model (LM) mode coding, as some examples, mode selection unit <b>202</b>, via respective units associated with the coding techniques, generates a prediction block for the current block being encoded. In some examples, such as palette mode coding, mode selection unit <b>202</b> may not generate a prediction block, and instead generate syntax elements that indicate the manner in which to reconstruct the block based on a selected palette. In such modes, mode selection unit <b>202</b> may provide these syntax elements to entropy encoding unit <b>220</b> to be encoded.</p><p id="p-0150" num="0150">As described above, residual generation unit <b>204</b> receives the video data for the current block and the corresponding prediction block. Residual generation unit <b>204</b> then generates a residual block for the current block. To generate the residual block, residual generation unit <b>204</b> calculates sample-by-sample differences between the prediction block and the current block.</p><p id="p-0151" num="0151">Transform processing unit <b>206</b> applies one or more transforms to the residual block to generate a block of transform coefficients (referred to herein as a &#x201c;transform coefficient block&#x201d;). Transform processing unit <b>206</b> may apply various transforms to a residual block to form the transform coefficient block. For example, transform processing unit <b>206</b> may apply a discrete cosine transform (DCT), a directional transform, a Karhunen-Loeve transform (KLT), or a conceptually similar transform to a residual block. In some examples, transform processing unit <b>206</b> may perform multiple transforms to a residual block, e.g., a primary transform and a secondary transform, such as a rotational transform. In some examples, transform processing unit <b>206</b> does not apply transforms to a residual block.</p><p id="p-0152" num="0152">When operating according to AV1, transform processing unit <b>206</b> may apply one or more transforms to the residual block to generate a block of transform coefficients (referred to herein as a &#x201c;transform coefficient block&#x201d;). Transform processing unit <b>206</b> may apply various transforms to a residual block to form the transform coefficient block. For example, transform processing unit <b>206</b> may apply a horizontal/vertical transform combination that may include a discrete cosine transform (DCT), an asymmetric discrete sine transform (ADST), a flipped ADST (e.g., an ADST in reverse order), and an identity transform (IDTX). When using an identity transform, the transform is skipped in one of the vertical or horizontal directions. In some examples, transform processing may be skipped.</p><p id="p-0153" num="0153">Quantization unit <b>208</b> may quantize the transform coefficients in a transform coefficient block, to produce a quantized transform coefficient block. Quantization unit <b>208</b> may quantize transform coefficients of a transform coefficient block according to a quantization parameter (QP) value associated with the current block. Video encoder <b>200</b> (e.g., via mode selection unit <b>202</b>) may adjust the degree of quantization applied to the transform coefficient blocks associated with the current block by adjusting the QP value associated with the CU. Quantization may introduce loss of information, and thus, quantized transform coefficients may have lower precision than the original transform coefficients produced by transform processing unit <b>206</b>.</p><p id="p-0154" num="0154">Inverse quantization unit <b>210</b> and inverse transform processing unit <b>212</b> may apply inverse quantization and inverse transforms to a quantized transform coefficient block, respectively, to reconstruct a residual block from the transform coefficient block. Reconstruction unit <b>214</b> may produce a reconstructed block corresponding to the current block (albeit potentially with some degree of distortion) based on the reconstructed residual block and a prediction block generated by mode selection unit <b>202</b>. For example, reconstruction unit <b>214</b> may add samples of the reconstructed residual block to corresponding samples from the prediction block generated by mode selection unit <b>202</b> to produce the reconstructed block.</p><p id="p-0155" num="0155">Filter unit <b>216</b> may perform one or more filter operations on reconstructed blocks. For example, filter unit <b>216</b> may perform deblocking operations to reduce blockiness artifacts along edges of CUs. Operations of filter unit <b>216</b> may be skipped, in some examples.</p><p id="p-0156" num="0156">When operating according to AV1, filter unit <b>216</b> may perform one or more filter operations on reconstructed blocks. For example, filter unit <b>216</b> may perform deblocking operations to reduce blockiness artifacts along edges of CUs. In other examples, filter unit <b>216</b> may apply a constrained directional enhancement filter (CDEF), which may be applied after deblocking, and may include the application of non-separable, non-linear, low-pass directional filters based on estimated edge directions. Filter unit <b>216</b> may also include a loop restoration filter, which is applied after CDEF, and may include a separable symmetric normalized Wiener filter or a dual self-guided filter.</p><p id="p-0157" num="0157">Video encoder <b>200</b> stores reconstructed blocks in DPB <b>218</b>. For instance, in examples where operations of filter unit <b>216</b> are not performed, reconstruction unit <b>214</b> may store reconstructed blocks to DPB <b>218</b>. In examples where operations of filter unit <b>216</b> are performed, filter unit <b>216</b> may store the filtered reconstructed blocks to DPB <b>218</b>. Motion estimation unit <b>222</b> and motion compensation unit <b>224</b> may retrieve a reference picture from DPB <b>218</b>, formed from the reconstructed (and potentially filtered) blocks, to inter-predict blocks of subsequently encoded pictures. In addition, intra-prediction unit <b>226</b> may use reconstructed blocks in DPB <b>218</b> of a current picture to intra-predict other blocks in the current picture.</p><p id="p-0158" num="0158">In general, entropy encoding unit <b>220</b> may entropy encode syntax elements received from other functional components of video encoder <b>200</b>. For example, entropy encoding unit <b>220</b> may entropy encode quantized transform coefficient blocks from quantization unit <b>208</b>. As another example, entropy encoding unit <b>220</b> may entropy encode prediction syntax elements (e.g., motion information for inter-prediction or intra-mode information for intra-prediction) from mode selection unit <b>202</b>. Entropy encoding unit <b>220</b> may perform one or more entropy encoding operations on the syntax elements, which are another example of video data, to generate entropy-encoded data. For example, entropy encoding unit <b>220</b> may perform a context-adaptive variable length coding (CAVLC) operation, a CABAC operation, a variable-to-variable (V<b>2</b>V) length coding operation, a syntax-based context-adaptive binary arithmetic coding (SBAC) operation, a Probability Interval Partitioning Entropy (PIPE) coding operation, an Exponential-Golomb encoding operation, or another type of entropy encoding operation on the data. In some examples, entropy encoding unit <b>220</b> may operate in bypass mode where syntax elements are not entropy encoded.</p><p id="p-0159" num="0159">Video encoder <b>200</b> may output a bitstream that includes the entropy encoded syntax elements needed to reconstruct blocks of a slice or picture. In particular, entropy encoding unit <b>220</b> may output the bitstream.</p><p id="p-0160" num="0160">In accordance with AV1, entropy encoding unit <b>220</b> may be configured as a symbol-to-symbol adaptive multi-symbol arithmetic coder. A syntax element in AV1 includes an alphabet of N elements, and a context (e.g., probability model) includes a set of N probabilities. Entropy encoding unit <b>220</b> may store the probabilities as n-bit (e.g., 15-bit) cumulative distribution functions (CDFs). Entropy encoding unit <b>22</b> may perform recursive scaling, with an update factor based on the alphabet size, to update the contexts.</p><p id="p-0161" num="0161">The operations described above are described with respect to a block. Such description should be understood as being operations for a luma coding block and/or chroma coding blocks. As described above, in some examples, the luma coding block and chroma coding blocks are luma and chroma components of a CU. In some examples, the luma coding block and the chroma coding blocks are luma and chroma components of a PU.</p><p id="p-0162" num="0162">In some examples, operations performed with respect to a luma coding block need not be repeated for the chroma coding blocks. As one example, operations to identify a motion vector (MV) and reference picture for a luma coding block need not be repeated for identifying a MV and reference picture for the chroma blocks. Rather, the MV for the luma coding block may be scaled to determine the MV for the chroma blocks, and the reference picture may be the same. As another example, the intra-prediction process may be the same for the luma coding block and the chroma coding blocks.</p><p id="p-0163" num="0163">In this manner, video encoder <b>200</b> represents an example of a video encoder including a memory configured to store video data; and one or more processors implemented in circuitry and configured to: determine a deterministic bounding box from which to retrieve reference samples of reference pictures of video data for performing decoder-side motion vector derivation (DMVD) for a current block of the video data; derive a motion vector for the current block according to DMVD using the reference samples within the deterministic bounding box; form a prediction block using the motion vector; and decode the current block using the prediction block.</p><p id="p-0164" num="0164"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a block diagram illustrating an example video decoder <b>300</b> that may perform the techniques of this disclosure. <figref idref="DRAWINGS">FIG. <b>10</b></figref> is provided for purposes of explanation and is not limiting on the techniques as broadly exemplified and described in this disclosure. For purposes of explanation, this disclosure describes video decoder <b>300</b> according to the techniques of VVC (ITU-T H.266, under development) and HEVC (ITU-T H.265). However, the techniques of this disclosure may be performed by video coding devices that are configured to other video coding standards.</p><p id="p-0165" num="0165">In the example of <figref idref="DRAWINGS">FIG. <b>10</b></figref>, video decoder <b>300</b> includes coded picture buffer (CPB) memory <b>320</b>, entropy decoding unit <b>302</b>, prediction processing unit <b>304</b>, inverse quantization unit <b>306</b>, inverse transform processing unit <b>308</b>, reconstruction unit <b>310</b>, filter unit <b>312</b>, and decoded picture buffer (DPB) <b>314</b>. Any or all of CPB memory <b>320</b>, entropy decoding unit <b>302</b>, prediction processing unit <b>304</b>, inverse quantization unit <b>306</b>, inverse transform processing unit <b>308</b>, reconstruction unit <b>310</b>, filter unit <b>312</b>, and DPB <b>314</b> may be implemented in one or more processors or in processing circuitry. For instance, the units of video decoder <b>300</b> may be implemented as one or more circuits or logic elements as part of hardware circuitry, or as part of a processor, ASIC, or FPGA. Moreover, video decoder <b>300</b> may include additional or alternative processors or processing circuitry to perform these and other functions.</p><p id="p-0166" num="0166">Prediction processing unit <b>304</b> includes motion compensation unit <b>316</b> and intra-prediction unit <b>318</b>. Prediction processing unit <b>304</b> may include additional units to perform prediction in accordance with other prediction modes. As examples, prediction processing unit <b>304</b> may include a palette unit, an intra-block copy unit (which may form part of motion compensation unit <b>316</b>), an affine unit, a linear model (LM) unit, or the like. In other examples, video decoder <b>300</b> may include more, fewer, or different functional components.</p><p id="p-0167" num="0167">When operating according to AV1, compensation unit <b>316</b> may be configured to decode coding blocks of video data (e.g., both luma and chroma coding blocks) using translational motion compensation, affine motion compensation, OBMC, and/or compound inter-intra prediction, as described above. Intra prediction unit <b>318</b> may be configured to decode coding blocks of video data (e.g., both luma and chroma coding blocks) using directional intra prediction, non-directional intra prediction, recursive filter intra prediction, CFL, intra block copy (IBC), and/or color palette mode, as described above.</p><p id="p-0168" num="0168">CPB memory <b>320</b> may store video data, such as an encoded video bitstream, to be decoded by the components of video decoder <b>300</b>. The video data stored in CPB memory <b>320</b> may be obtained, for example, from computer-readable medium <b>110</b> (<figref idref="DRAWINGS">FIG. <b>1</b></figref>). CPB memory <b>320</b> may include a CPB that stores encoded video data (e.g., syntax elements) from an encoded video bitstream. Also, CPB memory <b>320</b> may store video data other than syntax elements of a coded picture, such as temporary data representing outputs from the various units of video decoder <b>300</b>. DPB <b>314</b> generally stores decoded pictures, which video decoder <b>300</b> may output and/or use as reference video data when decoding subsequent data or pictures of the encoded video bitstream. CPB memory <b>320</b> and DPB <b>314</b> may be formed by any of a variety of memory devices, such as dynamic random access memory (DRAM), including synchronous DRAM (SDRAM), magnetoresistive RAM (MRAM), resistive RAM (RRAM), or other types of memory devices. CPB memory <b>320</b> and DPB <b>314</b> may be provided by the same memory device or separate memory devices. In various examples, CPB memory <b>320</b> may be on-chip with other components of video decoder <b>300</b>, or off-chip relative to those components.</p><p id="p-0169" num="0169">Additionally or alternatively, in some examples, video decoder <b>300</b> may retrieve coded video data from memory <b>120</b> (<figref idref="DRAWINGS">FIG. <b>1</b></figref>). That is, memory <b>120</b> may store data as discussed above with CPB memory <b>320</b>. Likewise, memory <b>120</b> may store instructions to be executed by video decoder <b>300</b>, when some or all of the functionality of video decoder <b>300</b> is implemented in software to be executed by processing circuitry of video decoder <b>300</b>.</p><p id="p-0170" num="0170">The various units shown in <figref idref="DRAWINGS">FIG. <b>10</b></figref> are illustrated to assist with understanding the operations performed by video decoder <b>300</b>. The units may be implemented as fixed-function circuits, programmable circuits, or a combination thereof. Similar to <figref idref="DRAWINGS">FIG. <b>9</b></figref>, fixed-function circuits refer to circuits that provide particular functionality, and are preset on the operations that can be performed. Programmable circuits refer to circuits that can be programmed to perform various tasks, and provide flexible functionality in the operations that can be performed. For instance, programmable circuits may execute software or firmware that cause the programmable circuits to operate in the manner defined by instructions of the software or firmware. Fixed-function circuits may execute software instructions (e.g., to receive parameters or output parameters), but the types of operations that the fixed-function circuits perform are generally immutable. In some examples, one or more of the units may be distinct circuit blocks (fixed-function or programmable), and in some examples, one or more of the units may be integrated circuits.</p><p id="p-0171" num="0171">Video decoder <b>300</b> may include ALUs, EFUs, digital circuits, analog circuits, and/or programmable cores formed from programmable circuits. In examples where the operations of video decoder <b>300</b> are performed by software executing on the programmable circuits, on-chip or off-chip memory may store instructions (e.g., object code) of the software that video decoder <b>300</b> receives and executes.</p><p id="p-0172" num="0172">Entropy decoding unit <b>302</b> may receive encoded video data from the CPB and entropy decode the video data to reproduce syntax elements. Prediction processing unit <b>304</b>, inverse quantization unit <b>306</b>, inverse transform processing unit <b>308</b>, reconstruction unit <b>310</b>, and filter unit <b>312</b> may generate decoded video data based on the syntax elements extracted from the bitstream.</p><p id="p-0173" num="0173">In general, video decoder <b>300</b> reconstructs a picture on a block-by-block basis. Video decoder <b>300</b> may perform a reconstruction operation on each block individually (where the block currently being reconstructed, i.e., decoded, may be referred to as a &#x201c;current block&#x201d;).</p><p id="p-0174" num="0174">Entropy decoding unit <b>302</b> may entropy decode syntax elements defining quantized transform coefficients of a quantized transform coefficient block, as well as transform information, such as a quantization parameter (QP) and/or transform mode indication(s). Inverse quantization unit <b>306</b> may use the QP associated with the quantized transform coefficient block to determine a degree of quantization and, likewise, a degree of inverse quantization for inverse quantization unit <b>306</b> to apply. Inverse quantization unit <b>306</b> may, for example, perform a bitwise left-shift operation to inverse quantize the quantized transform coefficients. Inverse quantization unit <b>306</b> may thereby form a transform coefficient block including transform coefficients.</p><p id="p-0175" num="0175">After inverse quantization unit <b>306</b> forms the transform coefficient block, inverse transform processing unit <b>308</b> may apply one or more inverse transforms to the transform coefficient block to generate a residual block associated with the current block. For example, inverse transform processing unit <b>308</b> may apply an inverse DCT, an inverse integer transform, an inverse Karhunen-Loeve transform (KLT), an inverse rotational transform, an inverse directional transform, or another inverse transform to the transform coefficient block.</p><p id="p-0176" num="0176">Furthermore, prediction processing unit <b>304</b> generates a prediction block according to prediction information syntax elements that were entropy decoded by entropy decoding unit <b>302</b>. For example, if the prediction information syntax elements indicate that the current block is inter-predicted, motion compensation unit <b>316</b> may generate the prediction block. In this case, the prediction information syntax elements may indicate a reference picture in DPB <b>314</b> from which to retrieve a reference block, as well as a motion vector identifying a location of the reference block in the reference picture relative to the location of the current block in the current picture. Motion compensation unit <b>316</b> may generally perform the inter-prediction process in a manner that is substantially similar to that described with respect to motion compensation unit <b>224</b> (<figref idref="DRAWINGS">FIG. <b>9</b></figref>).</p><p id="p-0177" num="0177">In accordance with techniques of this disclosure, motion compensation unit <b>316</b> may determine a deterministic bounding box from which to retrieve reference samples of reference pictures (e.g., stored in DPB <b>314</b>) for performing DMVD for a current block of video data. The deterministic bounding box may be the same size for any of the various DMVD techniques, e.g., each of template matching (TM), bilateral merge (BM), decoder-side motion vector refinement (DMVR), and/or multi-pass DMVR.</p><p id="p-0178" num="0178">To determine the deterministic bounding box, motion compensation unit <b>316</b> may initially retrieve an unrefined motion vector from a neighboring block to the current block. The unrefined motion vector may be a motion vector that was encoded (and stored) for the neighboring block using data in the bitstream, without having been refined using any of the various DMVD techniques. Thus, motion compensation unit <b>316</b> may refine the motion vector for the neighboring block prior to encoding the neighboring block, but may use the unrefined version of the motion vector for the neighboring block to determine the deterministic bounding box for the current block.</p><p id="p-0179" num="0179">Using the unrefined motion vector for the neighboring block, motion compensation unit <b>316</b> may identify a center sample of the deterministic bounding box in a reference picture. If the center sample is at position (x, y) in the reference picture, the deterministic bounding box may have vertices of (x&#x2212;N, y&#x2212;N), (x&#x2212;N, y+N), (x+N, y&#x2212;N), and (x+N, y+N), where N is a positive integer value. N may be a preconfigured value, a value calculated according to a multiple of an internal motion vector storage precision, or a value video encoder <b>200</b> signals in the bitstream (e.g., in a sequence parameter set (SPS), picture parameter set (PPS), slice header information, block header information, or the like). Again, N may be the same for each of the various DMVD techniques.</p><p id="p-0180" num="0180">Motion compensation unit <b>316</b> may then perform any of the various DMVD techniques of this disclosure (or other DMVD-like techniques), performing a refinement search within the deterministic bounding box. Motion compensation unit <b>316</b> may perform a motion field reconstruction stage using one or more unrefined motion vectors of previously coded blocks to the current block, then perform a reference sample fetching stage using the one or more unrefined motion vectors to retrieve reference samples within the deterministic bounding box. Motion compensation unit <b>316</b> may then perform the DMVD techniques using the retrieved reference samples.</p><p id="p-0181" num="0181">In some examples, when motion compensation unit <b>316</b> performs TM, motion compensation unit <b>316</b> may use only neighboring reconstruction samples to form a current block template.</p><p id="p-0182" num="0182">Ultimately, after deriving or refining one or more motion vectors using one or more DMVD techniques of this disclosure, motion compensation unit <b>316</b> may obtain reference samples to generate a prediction block using the motion vectors. Formation of the prediction block may be performed during a motion compensation stage. For example, motion compensation unit <b>316</b> may retrieve data of the reference block using the motion vector. As another example, if the motion vector has fractional sample precision, motion compensation unit <b>316</b> may interpolate values for the prediction block according to one or more interpolation filters. Moreover, for bi-directional inter-prediction, motion compensation unit <b>316</b> may retrieve data for two reference blocks identified by respective motion vectors and combine the retrieved data, e.g., through sample-by-sample averaging or weighted averaging.</p><p id="p-0183" num="0183">As another example, if the prediction information syntax elements indicate that the current block is intra-predicted, intra-prediction unit <b>318</b> may generate the prediction block according to an intra-prediction mode indicated by the prediction information syntax elements. Again, intra-prediction unit <b>318</b> may generally perform the intra-prediction process in a manner that is substantially similar to that described with respect to intra-prediction unit <b>226</b> (<figref idref="DRAWINGS">FIG. <b>9</b></figref>). Intra-prediction unit <b>318</b> may retrieve data of neighboring samples to the current block from DPB <b>314</b>.</p><p id="p-0184" num="0184">Reconstruction unit <b>310</b> may reconstruct the current block using the prediction block and the residual block. For example, reconstruction unit <b>310</b> may add samples of the residual block to corresponding samples of the prediction block to reconstruct the current block.</p><p id="p-0185" num="0185">Filter unit <b>312</b> may perform one or more filter operations on reconstructed blocks. For example, filter unit <b>312</b> may perform deblocking operations to reduce blockiness artifacts along edges of the reconstructed blocks. Operations of filter unit <b>312</b> are not necessarily performed in all examples.</p><p id="p-0186" num="0186">Video decoder <b>300</b> may store the reconstructed blocks in DPB <b>314</b>. For instance, in examples where operations of filter unit <b>312</b> are not performed, reconstruction unit <b>310</b> may store reconstructed blocks to DPB <b>314</b>. In examples where operations of filter unit <b>312</b> are performed, filter unit <b>312</b> may store the filtered reconstructed blocks to DPB <b>314</b>. As discussed above, DPB <b>314</b> may provide reference information, such as samples of a current picture for intra-prediction and previously decoded pictures for subsequent motion compensation, to prediction processing unit <b>304</b>. Moreover, video decoder <b>300</b> may output decoded pictures (e.g., decoded video) from DPB <b>314</b> for subsequent presentation on a display device, such as display device <b>118</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0187" num="0187">In this manner, video decoder <b>300</b> represents an example of a video decoder including a memory configured to store video data; and one or more processors implemented in circuitry and configured to: determine a deterministic bounding box from which to retrieve reference samples of reference pictures of video data for performing decoder-side motion vector derivation (DMVD) for a current block of the video data; derive a motion vector for the current block according to DMVD using the reference samples within the deterministic bounding box; form a prediction block using the motion vector; and decode the current block using the prediction block.</p><p id="p-0188" num="0188"><figref idref="DRAWINGS">FIG. <b>11</b></figref> is a conceptual diagram illustrating an example merge with motion vector difference (MMVD) search point. Certain techniques of this disclosure, which may be performed by video encoder <b>200</b> and video decoder <b>300</b> above, are described with respect to <figref idref="DRAWINGS">FIG. <b>11</b></figref>. In particular, a bounding box may be represented as a function of at least the following three aspects:<ul id="ul0003" list-style="none">    <li id="ul0003-0001" num="0000">    <ul id="ul0004" list-style="none">        <li id="ul0004-0001" num="0189">the unrefined MV (i.e., v<b>0</b> in <figref idref="DRAWINGS">FIG. <b>11</b></figref>) inferred from a causal neighboring block that carries no refinement vector information self-derived by DMVD methods or inferred;</li>        <li id="ul0004-0002" num="0190">the search range size (denoted as SR which specifies that a given DMVD method can search toward each direction centered at a given initial search point within a N-pixel range at most, where N is predefined by using 2<sup>&#x2212;4</sup>, 2<sup>&#x2212;3</sup>, 2<sup>&#x2212;2</sup>, 2<sup>&#x2212;1</sup>,1,2,3,4,5,6,7,8, . . . times internal MV storage precision (e.g., 4 in HEVC, 16 in VVC) or signalled per picture/subpicture/slice/tile) of DMVD method used in the current block (i.e., the second block in current frame depicted in <figref idref="DRAWINGS">FIG. <b>11</b></figref>);</li>        <li id="ul0004-0003" num="0191">interpolation filter lengths (denoted as L).</li>    </ul>    </li></ul></p><p id="p-0189" num="0192">Without loss of simplicity, <figref idref="DRAWINGS">FIG. <b>11</b></figref> serves as an example to describe the constrained search range. It is assumed that there is a first block in the current frame for which a video coder (video encoder <b>200</b> or video decoder <b>300</b>) infers a MV (i.e., v<b>0</b>) from its neighboring block and self-derive its refinement vector information (i.e., d<b>0</b>) through a DMVD method. Further, the video coder infers, for a second block (which is the current block) motion information from the first block and derives refinement vector information (i.e., d<b>1</b>) through a DMVD method. The video coder may perform the final motion compensation according to v<b>0</b>+d<b>0</b> and v<b>0</b>+d<b>0</b>+d<b>1</b> respectively for the two blocks. If there is a third block for which the video coder infers motion information from the second block, a final MV can be represented as v<b>0</b>+(&#x3a3;i&#x3f5;{0,1}di)+d<b>2</b>. These d<b>0</b>, d<b>1</b>, d<b>2</b>, . . . terms are used only for motion compensation and are not necessarily used for determining the search range.</p><p id="p-0190" num="0193">Unlike conventional DMVD, which is premised upon a video coder determining that a final neighboring block (e.g., v<b>0</b>+d<b>0</b>) is the center to form an anticipated search range (i.e., [v<b>0</b>+d<b>0</b>&#x2212;(SR, SR), v<b>0</b>+d<b>0</b>+(SR, SR)] shown in <figref idref="DRAWINGS">FIG. <b>11</b></figref>), this example does not propagate the refined motion vectors to the next blocks. Instead, the video coder determines its actual search range based solely on the unrefined version (i.e., v<b>0</b>) of inferred neighboring block motion. Therefore, the actual search range can be represented by [v<b>0</b>&#x2212;(SR, SR), v<b>0</b>+(SR, SR)]. Since none of the refinement vector information is carried over from neighboring blocks, the reference samples to be fetched for the current block become deterministic, which is of size (W+L+2SR)&#xd7;(H+L+<b>2</b>SR), where W and H are width and height of the current block, respectively. In this manner, the search range center may be identified by an unrefined motion vector of a neighboring block.</p><p id="p-0191" num="0194">The following examples describe various extensions to the constrained search range, which may be used alone or in various combinations:<ul id="ul0005" list-style="none">    <li id="ul0005-0001" num="0000">    <ul id="ul0006" list-style="none">        <li id="ul0006-0001" num="0195">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may perform DMVD to start from any MV within the actual search range, and limit the MV refinement to the actual search range. For example, video encoder <b>200</b> and video decoder <b>300</b> may start from where v<b>0</b>+d<b>0</b> points to within the actual search range.</li>        <li id="ul0006-0002" num="0196">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may perform DMVD starting from where v<b>0</b> points to within the actual search range.</li>        <li id="ul0006-0003" num="0197">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may further clip the search range size to the overlapped area between the anticipated search range and the actual search range.</li>        <li id="ul0006-0004" num="0198">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may perform DMVD with a full search pattern within the actual search range or the overlapped area between the anticipated search range and the actual search range.</li>        <li id="ul0006-0005" num="0199">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may fetch a number of reference samples less than (W+L+2SR)&#xd7;(H+L+<b>2</b>SR), such as (W+L&#x2032;+2SR)&#xd7;(H+L&#x2032;+2SR) where L&#x2032;&#x3f5; [0, 1, 2, . . . , L], and perform the same padding method as frame-level reference sample padding does to extend the size of (W+L&#x2032;+2SR)&#xd7;(H+L&#x2032;+2SR) to be (W+L+2SR)&#xd7;(H+L+2SR).</li>        <li id="ul0006-0006" num="0200">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may further be configured to implement a more restrictive constraint on BM, DMVR, and multi-pass DMVR for each of the derived refinement motion information to be within their respective actual search range. Since they are featured with symmetric refinement vectors between two reference pictures in bi-prediction case, the accessible area may sometimes be more restricted than the actual search range. For example, these DMVD methods cannot search toward the right direction for L<b>1</b> MV if the inferred unrefined MV of L<b>0</b> already reaches the left boundary of its actual search range (and thus it cannot search toward its left direction). That is, because the search may not start at the center of the search area, a search may proceed from a point identified by one motion vector toward one side of the search area and another search may proceed from a different point identified by a different motion vector toward the other side of the search area. This may avoid certain boundary search points. Additionally or alternatively, the video coder may perform motion vector clipping for a motion vector that crosses the search area boundary (deterministic bounding box).</li>        <li id="ul0006-0007" num="0201">In another example, the feature of symmetric refinement vectors can be relaxed by MV clipping when one of the inferred unrefined MV hits a boundary of its actual search range, while the others are not. For example, these DMVD methods can search toward the right direction for L<b>1</b> MV even if the inferred unrefined MV of L<b>0</b> already reaches the left boundary of its actual search range, because the MV or L<b>0</b> derived during the search process is always clipped to the nearest available position before DMVD matching cost is computed.</li>        <li id="ul0006-0008" num="0202">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may clip the derived refinement vector information of the two-pass BDOF (a sub-process of multi-pass DMVR described in U.S. Provisional Application No. 63/129,221, filed Dec. 22, 2020), when out-of-range condition (that is the final motion compensation would go beyond the actual search range) occurs on either one of the reference picture.        <ul id="ul0007" list-style="none">            <li id="ul0007-0001" num="0203">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may reset the derived refinement vector information of the two-pass BDOF to be zero vectors.</li>            <li id="ul0007-0002" num="0204">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may clip the derived refinement vector information independently for each reference pictures.</li>            <li id="ul0007-0003" num="0205">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may find a minimum value (rn), shared across reference pictures, to be added on top of the derived refinement vector information of a reference picture and subtracted from that of the other reference picture to ensure the out-of-range condition does not occur on both reference pictures. This may ensure that a motion vector difference (delta) that is found using BDOF may remain symmetric for both reference blocks. Suppose, for example, that a motion vector points to an out-of-bounds area, and &#x201c;vector m&#x201d; is the minimal delta vector that the motion vector needs to point back into the search area. The out of bounds motion vector plus vector m can ensure that the out-of-bound condition does not happen, and vector m may then be fed to the other motion vector to ensure symmetry.</li>        </ul>        </li>        <li id="ul0006-0009" num="0206">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may align the search range over all DMVD methods. Since only one SR is used, video encoder <b>200</b> and video decoder <b>300</b> do not need to identify the DMVD method used for certain blocks before computing the size of reference samples to be fetched from reference pictures.</li>        <li id="ul0006-0010" num="0207">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may unify the search range of all DMVD methods cascading in multi-pass DMVR to be within [v<b>0</b>&#x2212;(SR, SR), v<b>0</b>+(SR, SR)], so that video encoder <b>200</b> and video decoder <b>300</b> do not need to identify which DMVR method is used. Multi-pass DMVR generally uses a larger search range before computing the size of reference samples to be fetched from reference pictures.</li>        <li id="ul0006-0011" num="0208">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may further be configured with a restriction on the self-derived refinement vector information (e.g., d<b>1</b>) that avoids no refinement condition from happening when the DMVD method is TM. In the other words, the input MVs to TM cannot be identical to the output MVs. Another example imposes the restriction only when TM performs search for a uni-prediction block.</li>    </ul>    </li></ul></p><p id="p-0192" num="0209">In the various DMVD methods (e.g., TM, BM, DMVR, and multi-pass DMVR), the video coder derives refinement vector information at the motion compensation stage. Thus, the refinement vector information is an unknown term during motion field reconstruction and reference sample fetching stages. This is the key point behind the techniques discussed above to limit the search range to be [v<b>0</b>&#x2212;(SR, SR), v<b>0</b>+(SR, SR)]. Thus, no matter how &#x3a3;<sub>i</sub>di accumulates across spatial blocks, the actual search range is always bounded.</p><p id="p-0193" num="0210">Additionally or alternatively, video encoder <b>200</b> and video decoder <b>300</b> may be configured with a constraint on spatial motion vector prediction to avoid using refinement vector information to reconstruct a motion field of coded blocks. In this example, unrefined MVs may be propagated to subsequent blocks for spatial motion vector prediction during motion field reconstruction stage and reference sample fetching stage, while refined MVs (i.e., the unrefined MVs plus inferred refinement vector information such as d<b>0</b> of the second block in <figref idref="DRAWINGS">FIG. <b>11</b></figref> from the same neighboring block(s) and self-derived refinement vector information, such as d<b>1</b> when performed) are carried over to subsequent blocks only in motion compensation stage. Thus, the unrefined motion vector may be used both for motion vector propagation and for motion vector inference. A neighboring refined motion vector may be inferable during a motion compensation stage, such that sequential motion compensation may be performed across blocks/CUs.</p><p id="p-0194" num="0211">Since the refinement vector information in unknown before motion compensation stage, video encoder <b>200</b> and video decoder <b>300</b> may have to fetch more reference sample according to the configuration of SR and L&#x2032; introduced above. Therefore, during reference sample fetching stage, no matter the current block carries refinement vector information inferred from its neighboring blocks, derived by itself or a combination of both, the maximum number of fetched reference samples are bounded to (W+L&#x2032;+2SRmax)&#xd7;(H+L&#x2032;+2SRmax), where the SRmax is the maximum one of all supported DMVR methods in a codec. The same amount of reference samples may be retrieved as in DMVD were to be performed for the block.</p><p id="p-0195" num="0212">These techniques may be applied to extend the constrained search range, as follows:<ul id="ul0008" list-style="none">    <li id="ul0008-0001" num="0000">    <ul id="ul0009" list-style="none">        <li id="ul0009-0001" num="0213">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may construct AMVP and merge candidate lists based on the unrefined MVs from neighboring blocks. Therefore, the unrefined MVs may be used to perform the pruning process and to reconstruct the motion field of the current picture.</li>        <li id="ul0009-0002" num="0214">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may use only unrefined MVs to generate the constructed candidates of Affine AMVP, Affine merge, and Affine MMVD merge modes. The refinement vector information is used neither in motion vector reconstruction stage, reference fetching stage (i.e., independent of L&#x2032; and SR<sub>max</sub>) and motion compensation stage.</li>        <li id="ul0009-0003" num="0215">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may use only unrefined MVs to be its motion source vector (i.e., the left spatial candidate motion) of subblock TMVP mode.</li>        <li id="ul0009-0004" num="0216">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may allow other inter prediction modes (e.g., MMVD, CIIP, OBMC, multi-hypothesis prediction) to use refined MVs inferred from neighboring blocks during motion compensation stage. Another example allows some inter prediction modes (e.g., MMVD, CIIP, OBMC, multi-hypothesis prediction) to use unrefined MVs inferred from neighboring blocks during motion compensation stage.</li>        <li id="ul0009-0005" num="0217">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may store only refined MVs for subsequent frame to perform temporal motion vector prediction.        <ul id="ul0010" list-style="none">            <li id="ul0010-0001" num="0218">In another example, video encoder <b>200</b> and video decoder <b>300</b> may store only unrefined MVs for subsequent frame to perform temporal MV prediction.</li>            <li id="ul0010-0002" num="0219">In both examples, video encoder <b>200</b> and video decoder <b>300</b> may apply these techniques to deblocking filtering to compute boundary strength.</li>        </ul>        </li>    </ul>    </li></ul></p><p id="p-0196" num="0220">Additionally or alternatively, video encoder <b>200</b> and video decoder <b>300</b> may be configured with a constraint on accessing neighboring reconstruction samples for a current block template generation. Video encoder <b>200</b> and video decoder <b>300</b> may be prevented from accessing neighboring reconstruction samples to form a current block template for template matching. Instead, video encoder <b>200</b> and video decoder <b>300</b> may be configured with any of the following various replacement techniques:<ul id="ul0011" list-style="none">    <li id="ul0011-0001" num="0000">    <ul id="ul0012" list-style="none">        <li id="ul0012-0001" num="0221">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may use the refined MVs inferred from neighboring blocks to the current block to generate a prediction block (that is collocated with the current block templates) to replace current block templates. The interpolation filters that are used respectively to generate the prediction-based current block template and search area samples need not always be the same. Thus, video encoder <b>200</b> and video decoder <b>300</b> may generate the current block template using the inferred refined motion vector from the merge candidate list.</li>        <li id="ul0012-0002" num="0222">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may access all neighboring blocks and uses their motion information (that were used in motion compensation stage) to generate a prediction block to replace the current block templates. Unlike the previous example, this example forms the prediction block with multiple patches because causal neighboring blocks surrounding the current block usually have different motion. That is, in this example, all of the motion vectors of the neighboring blocks may be used directly if they are within the area of the current block template. Sometimes, neighboring blocks may be intra-coded (or coded by some other pre-defined set of prediction modes). This exception case may be handled in the following techniques.        <ul id="ul0013" list-style="none">            <li id="ul0013-0001" num="0223">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may discard these intra blocks and not count the discarded intra blocks in the computation process of template matching cost.</li>            <li id="ul0013-0002" num="0224">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may fill MVs for these neighboring intra blocks by padding through nearest available MVs.</li>            <li id="ul0013-0003" num="0225">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may fill MVs for these neighboring intra blocks by performing bilinear interpolation based on two nearest available MVs.</li>            <li id="ul0013-0004" num="0226">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may bypass the refinement process of TM when there are too many intra-coded blocks in the immediately causal neighboring area of the current block. A ratio is pre-defined, such as if one, two or three quarters of samples of the entire current block templates are collocated with intra-coded blocks, then TM is bypassed.</li>            <li id="ul0013-0005" num="0227">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may disable the use of either one of above and left template blocks. If a template block is collocated with a certain amount of intra-coded sample over a pre-defined ratio, then this template block is disabled and is not used in TM.</li>        </ul>        </li>        <li id="ul0012-0003" num="0228">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may perform template matching based solely on either one of the above and left template blocks if the refined MVs inferred from spatial neighboring blocks.        <ul id="ul0014" list-style="none">            <li id="ul0014-0001" num="0229">When the inferred spatial neighboring block is from the above (or above-right) relative to the current block, only above template may be used in template matching.</li>            <li id="ul0014-0002" num="0230">When the inferred spatial neighboring block is from the left (or bottom-left) relative to the current block, only left template may be used in template matching.</li>        </ul>        </li>        <li id="ul0012-0004" num="0231">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may add partial residual reconstruction information into the current block templates as an approximation to the actual ones, as follows:        <ul id="ul0015" list-style="none">            <li id="ul0015-0001" num="0232">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may add a reconstructed DC value of each neighboring transform units (TUs) on top of the collocated patches of the current block template.</li>            <li id="ul0015-0002" num="0233">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may, when DCT is not used according to MTS mode selection for a neighboring TU, nothing is added on top of the collocated patches of the current block template.</li>            <li id="ul0015-0003" num="0234">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may, when LFNST is used, perform the LFNST to compute quantized coefficients and the DC coefficient, which may be reconstructed and added on top of the collocated patches of the current block template.</li>            <li id="ul0015-0004" num="0235">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may, when LFNST is used, use the first coefficient of LFNST as if the first coefficient were the actual quantized DC coefficient, and then this LFNST coefficient may be inversely transform-quantized to get an estimate of DC value which is then added on top of the collocated patches of the current block template.</li>            <li id="ul0015-0005" num="0236">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may, no matter LMCS is enabled or not, add the reconstructed or estimated DC value directly on top of the collocated patches of the current block template.</li>        </ul>        </li>        <li id="ul0012-0005" num="0237">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may, when LMCS is enabled, not add the reconstructed or estimated DC value on top of the collocated patches of the current block template. On the contrary, the collocated patch is converted through forward LMCS conversion, added with the reconstructed or estimated DC value, and then converted back through inverse LMCS conversion.</li>    </ul>    </li></ul></p><p id="p-0197" num="0238">In some examples, video encoder <b>200</b> and video decoder <b>300</b> may be configured to avoid using neighboring samples using certain modes for their coding in the template. Such samples can be treated as unavailable. In other words, only the neighboring samples using the prediction modes which are allowed can be utilized in the template. The unavailable samples can be replaced with available samples. In another example, if there is any unavailable sample in the template, the template matching refinement is not applied.</p><p id="p-0198" num="0239">The disallowed prediction modes may include the modes that use any sort of propagation or require sequential block processing, for example:<ul id="ul0016" list-style="none">    <li id="ul0016-0001" num="0000">    <ul id="ul0017" list-style="none">        <li id="ul0017-0001" num="0240">Intra prediction</li>        <li id="ul0017-0002" num="0241">Intra block copy prediction</li>        <li id="ul0017-0003" num="0242">Decode side derived methods, such as template matching or similar</li>        <li id="ul0017-0004" num="0243">Illumination compensation methods</li>    </ul>    </li></ul></p><p id="p-0199" num="0244"><figref idref="DRAWINGS">FIG. <b>12</b></figref> is a flowchart illustrating an example method for encoding a current block in accordance with the techniques of this disclosure. The current block may comprise a current CU. Although described with respect to video encoder <b>200</b> (<figref idref="DRAWINGS">FIGS. <b>1</b> and <b>9</b></figref>), it should be understood that other devices may be configured to perform a method similar to that of <figref idref="DRAWINGS">FIG. <b>12</b></figref>.</p><p id="p-0200" num="0245">In this example, video encoder <b>200</b> initially predicts the current block (<b>350</b>). For example, video encoder <b>200</b> may form a prediction block for the current block. In particular, video encoder <b>200</b> may perform inter-prediction to predict the block, including performing decoder-side motion vector derivation (DMVD) according to any of the various techniques of this disclosure, alone or in any combination, to form a motion vector for the current block. Video encoder <b>200</b> may then form a prediction block using the motion vector. Video encoder <b>200</b> may then calculate a residual block for the current block (<b>352</b>). To calculate the residual block, video encoder <b>200</b> may calculate a difference between the original, uncoded block and the prediction block for the current block. Video encoder <b>200</b> may then transform the residual block and quantize transform coefficients of the residual block (<b>354</b>). Next, video encoder <b>200</b> may scan the quantized transform coefficients of the residual block (<b>356</b>). During the scan, or following the scan, video encoder <b>200</b> may entropy encode the transform coefficients (<b>358</b>). For example, video encoder <b>200</b> may encode the transform coefficients using CAVLC or CABAC. Video encoder <b>200</b> may then output the entropy encoded data of the block (<b>360</b>).</p><p id="p-0201" num="0246">Video encoder <b>200</b> may also decode the current block after encoding the current block, to use the decoded version of the current block as reference data for subsequently coded data (e.g., in inter- or intra-prediction modes). Thus, video encoder <b>200</b> may inverse quantize and inverse transform the coefficients to reproduce the residual block (<b>362</b>). Video encoder <b>200</b> may combine the residual block with the prediction block to form a decoded block (<b>364</b>). Video encoder <b>200</b> may then store the decoded block in DPB <b>218</b> (<b>366</b>).</p><p id="p-0202" num="0247"><figref idref="DRAWINGS">FIG. <b>13</b></figref> is a flowchart illustrating an example method for decoding a current block of video data in accordance with the techniques of this disclosure. The current block may comprise a current CU. Although described with respect to video decoder <b>300</b> (<figref idref="DRAWINGS">FIGS. <b>1</b> and <b>10</b></figref>), it should be understood that other devices may be configured to perform a method similar to that of <figref idref="DRAWINGS">FIG. <b>13</b></figref>.</p><p id="p-0203" num="0248">Video decoder <b>300</b> may receive entropy encoded data for the current block, such as entropy encoded prediction information and entropy encoded data for transform coefficients of a residual block corresponding to the current block (<b>370</b>). Video decoder <b>300</b> may entropy decode the entropy encoded data to determine prediction information for the current block and to reproduce transform coefficients of the residual block (<b>372</b>). Video decoder <b>300</b> may predict the current block (<b>374</b>), e.g., using an inter-prediction mode as indicated by the prediction information for the current block, to calculate a prediction block for the current block. In particular, video decoder <b>300</b> may perform inter-prediction to predict the block, including performing decoder-side motion vector derivation (DMVD) according to any of the various techniques of this disclosure, alone or in any combination, to form a motion vector for the current block. Video decoder <b>300</b> may then form a prediction block using the motion vector. Video decoder <b>300</b> may then inverse scan the reproduced transform coefficients (<b>376</b>), to create a block of quantized transform coefficients. Video decoder <b>300</b> may then inverse quantize the transform coefficients and apply an inverse transform to the transform coefficients to produce a residual block (<b>378</b>). Video decoder <b>300</b> may ultimately decode the current block by combining the prediction block and the residual block (<b>380</b>).</p><p id="p-0204" num="0249"><figref idref="DRAWINGS">FIG. <b>14</b></figref> is a flowchart illustrating an example method for coding a current block using a motion vector derived and/or refined according to techniques of this disclosure. The method of <figref idref="DRAWINGS">FIG. <b>14</b></figref> may be performed by video encoder <b>200</b> (e.g., during step <b>350</b> of the method of <figref idref="DRAWINGS">FIG. <b>12</b></figref>) or by video decoder <b>300</b> (e.g., during step <b>374</b> of the method of <figref idref="DRAWINGS">FIG. <b>13</b></figref>). For purposes of example, the method of <figref idref="DRAWINGS">FIG. <b>14</b></figref> is explained with respect to video decoder <b>300</b>, although certain examples are also explained with respect to video encoder <b>200</b>.</p><p id="p-0205" num="0250">Initially, video decoder <b>300</b> may code (decode) motion information for a neighboring block defining a neighboring block motion vector (NBMV) (<b>400</b>). For example, video decoder <b>300</b> may decode a merge index or AMVP motion information. Video decoder <b>300</b> may then use the decoded motion information to form an unrefined motion vector as the NBMV for the neighboring block. Video decoder <b>300</b> may store the unrefined motion vector with the neighboring block as the unrefined NBMV. Furthermore, video decoder <b>300</b> may refine the NBMV (e.g., using any of the various DMVD techniques of this disclosure) to form a refined NBMV (<b>402</b>) and predict and code the neighboring block using the refined NBMV (<b>404</b>). When performed by video encoder <b>200</b>, video encoder <b>200</b> may encode the motion information.</p><p id="p-0206" num="0251">Video decoder <b>300</b> may then retrieve the unrefined NBMV stored with the neighboring block and determine a deterministic boundary box for the current block using the unrefined NBMV (<b>406</b>). That is, the unrefined NBMV may point to a center sample of the deterministic bounding box. Video decoder <b>300</b> may further determine that the deterministic boundary box extends N samples above, below, to the left, and to the right of the center sample, where N may be a positive integer value that is the same for any of the various DMVD techniques.</p><p id="p-0207" num="0252">Video decoder <b>300</b> may further retrieve reference samples within the deterministic bounding box (<b>408</b>) from a reference picture. Video decoder <b>300</b> may also perform DMVD using the retrieved reference samples within the deterministic bounding box (<b>410</b>) to form a DMVD-generated motion vector for the current block. Video decoder <b>300</b> may then generate a prediction block using the DMVD-generated motion vector (<b>412</b>). Video decoder <b>300</b> may then code (decode) the current block using the prediction block (<b>414</b>). For example, video decoder <b>300</b> may decode quantized transform coefficients from the bitstream, inverse quantize and inverse transform the quantized transform coefficients to form a residual block, then combine samples of the prediction block with co-located samples of the residual block to ultimately decode (reconstruct) the current block. Video encoder <b>200</b> may both encode and decode/reconstruct the current block using the prediction block, e.g., by calculating a residual block as sample-by-sample differences between the current block and the prediction block, transform and quantize the residual block, and encode the resulting quantized transform coefficients of the residual block. Video encoder <b>200</b> may decode the block in a manner substantially similar to that discussed with respect to video decoder <b>300</b> above.</p><p id="p-0208" num="0253">In this manner, the method of <figref idref="DRAWINGS">FIG. <b>3</b></figref> represents an example of a method of coding (e.g., encoding or decoding) a block of video data including determining a deterministic bounding box from which to retrieve reference samples of reference pictures of video data for performing decoder-side motion vector derivation (DMVD) for a current block of the video data; deriving a motion vector for the current block according to DMVD using the reference samples within the deterministic bounding box; forming a prediction block using the motion vector; and decoding the current block using the prediction block.d</p><p id="p-0209" num="0254">Certain techniques of this disclosure are summarized in the following clauses:</p><p id="p-0210" num="0255">Clause 1: A method of decoding video data, the method comprising: determining a deterministic bounding box from which to retrieve reference samples of reference pictures of video data for performing decoder-side motion vector derivation (DMVD) for a current block of the video data; deriving a motion vector for the current block according to DMVD using the reference samples within the deterministic bounding box; forming a prediction block using the motion vector; and decoding the current block using the prediction block.</p><p id="p-0211" num="0256">Clause 2: The method of clause 1, wherein deriving the motion vector comprises: inferring an unrefined motion vector from a neighboring block to the current block; and refining the unrefined motion vector to form the motion vector for the current block.</p><p id="p-0212" num="0257">Clause 3: The method of any of clauses 1 and 2, wherein determining the deterministic bounding box comprises: inferring an unrefined motion vector for the current block from a neighboring block to the current block; and determining the deterministic bounding box as having an area including samples within N samples of a sample indicated by the unrefined motion vector.</p><p id="p-0213" num="0258">Clause 4: The method of clause 3, wherein N is a predefined value determined according to a multiple of an internal motion vector storage precision.</p><p id="p-0214" num="0259">Clause 5: The method of any of clauses 1-4, wherein determining the deterministic bounding box comprises determining the deterministic bounding box according to an interpolation filter length for DMVD.</p><p id="p-0215" num="0260">Clause 6: The method of any of clauses 1-5, wherein deriving the motion vector comprises performing a motion search starting within the deterministic bounding box.</p><p id="p-0216" num="0261">Clause 7: The method of any of clauses 1-6, wherein DMVD comprises one of template matching (TM), bilateral merge (BM), decoder-side motion vector refinement (DMVR), or multi-pass DMVR.</p><p id="p-0217" num="0262">Clause 8: A method of decoding video data, the method comprising: deriving a motion vector for a current block of video data according to decoder-side motion vector derivation (DVMD), including: performing a motion field reconstruction stage using one or more unrefined motion vectors of previously coded blocks to the current block; and performing a reference sample fetching stage using the one or more unrefined motion vectors of the previously coded blocks; performing a motion compensation stage for the current block using one or more refined motion vectors of the previously coded blocks to generate a prediction block for the current block; and decoding the current block using the prediction block.</p><p id="p-0218" num="0263">Clause 9: A method comprising a combination of the method of any of clauses 1-7 and the method of clause 8.</p><p id="p-0219" num="0264">Clause 10: The method of any of clauses 8 and 9, further comprising generating a motion vector candidate list for the current block using the one or more unrefined motion vectors of the previously coded blocks.</p><p id="p-0220" num="0265">Clause 11: A method of decoding video data, the method comprising: deriving a motion vector for a current block of video data according to template matching (TM) for decoder-side motion vector derivation (DVMD), including using only neighboring reconstruction samples to form a current block template for TM; generating a prediction block for the current block using the motion vector; and decoding the current block using the prediction block.</p><p id="p-0221" num="0266">Clause 12: A method comprising a combination of the method of any of clauses 1-10 and the method of clause 11.</p><p id="p-0222" num="0267">Clause 13: The method of any of clauses 1-12, further comprising encoding the current block prior to decoding the current block.</p><p id="p-0223" num="0268">Clause 14: A device for decoding video data, the device comprising one or more means for performing the method of any of clauses 1-13.</p><p id="p-0224" num="0269">Clause 15: The device of clause 14, wherein the one or more means comprise one or more processors implemented in circuitry.</p><p id="p-0225" num="0270">Clause 16: The device of any of clauses 14 and 15, further comprising a display configured to display the decoded video data.</p><p id="p-0226" num="0271">Clause 17: The device of any of clauses 14-16, wherein the device comprises one or more of a camera, a computer, a mobile device, a broadcast receiver device, or a set-top box.</p><p id="p-0227" num="0272">Clause 18: The device of clause 14-17, further comprising a memory configured to store the video data.</p><p id="p-0228" num="0273">Clause 19: A computer-readable storage medium having stored thereon instructions that, when executed, cause a processor of a device for decoding video data to perform the method of any of clauses 1-13.</p><p id="p-0229" num="0274">Clause 20: A device for decoding video data, the device comprising: means for determining a deterministic bounding box from which to retrieve reference samples of reference pictures of video data for performing decoder-side motion vector derivation (DMVD) for a current block of the video data; means for deriving a motion vector for the current block according to DMVD using the reference samples within the deterministic bounding box; means for forming a prediction block using the motion vector; and decoding the current block using the prediction block.</p><p id="p-0230" num="0275">Clause 21: A device for decoding video data, the device comprising: means for deriving a motion vector for a current block of video data according to decoder-side motion vector derivation (DVMD), including: means for performing a motion field reconstruction stage using one or more unrefined motion vectors of previously coded blocks to the current block; and means for performing a reference sample fetching stage using the one or more unrefined motion vectors of the previously coded blocks; means for performing a motion compensation stage for the current block using one or more refined motion vectors of the previously coded blocks to generate a prediction block for the current block; and means for decoding the current block using the prediction block.</p><p id="p-0231" num="0276">Clause 22: A device for decoding video data, the device comprising: means for deriving a motion vector for a current block of video data according to template matching (TM) for decoder-side motion vector derivation (DVMD), including using only neighboring reconstruction samples to form a current block template for TM; means for generating a prediction block for the current block using the motion vector; and means for decoding the current block using the prediction block.</p><p id="p-0232" num="0277">Clause 23: A method of decoding video data, the method comprising: determining a deterministic bounding box from which to retrieve reference samples of reference pictures of video data for performing decoder-side motion vector derivation (DMVD) for a current block of the video data; deriving a motion vector for the current block according to DMVD using the reference samples within the deterministic bounding box; forming a prediction block using the motion vector; and decoding the current block using the prediction block.</p><p id="p-0233" num="0278">Clause 24: The method of clause 23, wherein deriving the motion vector comprises: retrieving an unrefined motion vector from a neighboring block to the current block; and refining the unrefined motion vector to form the motion vector for the current block.</p><p id="p-0234" num="0279">Clause 25: The method of clause 23, wherein determining the deterministic bounding box comprises: decoding motion information for a neighboring block to the current block, the motion information including data defining a neighboring block motion vector; and using the neighboring block motion vector to determine the deterministic bounding block.</p><p id="p-0235" num="0280">Clause 26: The method of clause 25, further comprising: refining the neighboring block motion vector to form a refined neighboring block motion vector; and predicting the neighboring block using the refined neighboring block motion vector.</p><p id="p-0236" num="0281">Clause 27: The method of clause 25, wherein determining the deterministic bounding box comprises determining the deterministic bounding box as having an area including samples within N samples of a sample indicated by the neighboring block motion vector.</p><p id="p-0237" num="0282">Clause 28: The method of clause 27, wherein N is a predefined value determined according to a multiple of an internal motion vector storage precision.</p><p id="p-0238" num="0283">Clause 29: The method of clause 27, wherein N is the same for each of template matching (TM), bilateral merge (BM), decoder-side motion vector refinement (DMVR), or multi-pass DMVR.</p><p id="p-0239" num="0284">Clause 30: The method of clause 23, wherein determining the deterministic bounding box comprises determining the deterministic bounding box according to an interpolation filter length for DMVD.</p><p id="p-0240" num="0285">Clause 31: The method of clause 23, wherein deriving the motion vector comprises performing a motion search starting within the deterministic bounding box.</p><p id="p-0241" num="0286">Clause 32: The method of clause 23, wherein DMVD comprises one of template matching (TM), bilateral merge (BM), decoder-side motion vector refinement (DMVR), or multi-pass DMVR.</p><p id="p-0242" num="0287">Clause 33: The method of clause 23, wherein deriving the motion vector comprises: performing a motion field reconstruction stage using one or more unrefined motion vectors of previously coded blocks to the current block; and performing a reference sample fetching stage using the one or more unrefined motion vectors of the previously coded blocks, and wherein forming the prediction block comprises performing a motion compensation stage for the current block using one or more refined motion vectors of the previously coded blocks to generate the prediction block for the current block.</p><p id="p-0243" num="0288">Clause 34: The method of clause 33, further comprising generating a motion vector candidate list for the current block using the one or more unrefined motion vectors of the previously coded blocks.</p><p id="p-0244" num="0289">Clause 35: The method of clause 23, wherein deriving the motion vector for the current block according to DMVD comprises deriving the motion vector for the current block according to template matching (TM), including using only neighboring reconstruction samples to form a current block template for TM.</p><p id="p-0245" num="0290">Clause 36: The method of clause 23, further comprising encoding the current block prior to decoding the current block.</p><p id="p-0246" num="0291">Clause 37: A device for decoding video data, the device comprising: a memory configured to store video data; and one or more processors implemented in circuitry and configured to: determine a deterministic bounding box from which to retrieve reference samples of reference pictures of video data for performing decoder-side motion vector derivation (DMVD) for a current block of the video data; derive a motion vector for the current block according to DMVD using the reference samples within the deterministic bounding box; form a prediction block using the motion vector; and decode the current block using the prediction block.</p><p id="p-0247" num="0292">Clause 38: The device of clause 37, wherein to derive the motion vector, the one or more processors are configured to: retrieve an unrefined motion vector from a neighboring block to the current block; and refine the unrefined motion vector to form the motion vector for the current block.</p><p id="p-0248" num="0293">Clause 39: The device of clause 37, wherein to determine the deterministic bounding box, the one or more processors are configured to: decode motion information for a neighboring block to the current block, the motion information including data defining a neighboring block motion vector; and use the neighboring block motion vector to determine the deterministic bounding block.</p><p id="p-0249" num="0294">Clause 40: The device of clause 39, wherein the one or more processors are further configured to: refine the neighboring block motion vector to form a refined neighboring block motion vector; and predict the neighboring block using the refined neighboring block motion vector.</p><p id="p-0250" num="0295">Clause 41: The device of clause 39, wherein the one or more processors are configured to determine the deterministic bounding box as having an area including samples within N samples of a sample indicated by the neighboring block motion vector.</p><p id="p-0251" num="0296">Clause 42: The device of clause 41, wherein N is a predefined value determined according to a multiple of an internal motion vector storage precision.</p><p id="p-0252" num="0297">Clause 43: The device of clause 41, wherein N is the same for each of template matching (TM), bilateral merge (BM), decoder-side motion vector refinement (DMVR), or multi-pass DMVR.</p><p id="p-0253" num="0298">Clause 44: The device of clause 37, wherein the one or more processors are configured to determine the deterministic bounding box according to an interpolation filter length for DMVD.</p><p id="p-0254" num="0299">Clause 45: The device of clause 37, wherein to derive the motion vector, the one or more processors are configured to perform a motion search starting within the deterministic bounding box.</p><p id="p-0255" num="0300">Clause 46: The device of clause 37, wherein DMVD comprises one of template matching (TM), bilateral merge (BM), decoder-side motion vector refinement (DMVR), or multi-pass DMVR.</p><p id="p-0256" num="0301">Clause 47: The device of clause 37, wherein to derive the motion vector, the one or more processors are configured to: perform a motion field reconstruction stage using one or more unrefined motion vectors of previously coded blocks to the current block; and perform a reference sample fetching stage using the one or more unrefined motion vectors of the previously coded blocks, and wherein to form the prediction block, the one or more processors are configured to perform a motion compensation stage for the current block using one or more refined motion vectors of the previously coded blocks to generate the prediction block for the current block.</p><p id="p-0257" num="0302">Clause 48: The device of clause 47, wherein the one or more processors are configured to generate a motion vector candidate list for the current block using the one or more unrefined motion vectors of the previously coded blocks.</p><p id="p-0258" num="0303">Clause 49: The device of clause 37, wherein the one or more processors are configured to derive the motion vector for the current block according to template matching (TM), including using only neighboring reconstruction samples to form a current block template for TM.</p><p id="p-0259" num="0304">Clause 50: The device of clause 37, wherein the one or more processors are further configured to encode the current block prior to decoding the current block.</p><p id="p-0260" num="0305">Clause 51: The device of clause 37, further comprising a display configured to display the decoded video data.</p><p id="p-0261" num="0306">Clause 52: The device of clause 37, wherein the device comprises one or more of a camera, a computer, a mobile device, a broadcast receiver device, or a set-top box.</p><p id="p-0262" num="0307">Clause 53: A computer-readable storage medium having stored thereon instructions that, when executed, cause a processor to: determine a deterministic bounding box from which to retrieve reference samples of reference pictures of video data for performing decoder-side motion vector derivation (DMVD) for a current block of the video data; derive a motion vector for the current block according to DMVD using the reference samples within the deterministic bounding box; form a prediction block using the motion vector; and decode the current block using the prediction block.</p><p id="p-0263" num="0308">Clause 54: The computer-readable storage medium of clause 53, wherein the instructions that cause the processor to derive the motion vector comprise instructions that cause the processor to: perform a motion field reconstruction stage using one or more unrefined motion vectors of previously coded blocks to the current block; and perform a reference sample fetching stage using the one or more unrefined motion vectors of the previously coded blocks, and wherein the instructions that cause the processor to form the prediction block comprise instructions that cause the processor to perform a motion compensation stage for the current block using one or more refined motion vectors of the previously coded blocks to generate the prediction block for the current block.</p><p id="p-0264" num="0309">Clause 55: The computer-readable storage medium of clause 53, wherein the instructions that cause the processor to derive the motion vector for the current block according to DMVD comprise instructions that cause the processor to derive the motion vector for the current block according to template matching (TM), including using only neighboring reconstruction samples to form a current block template for TM.</p><p id="p-0265" num="0310">Clause 56: A device for decoding video data, the device comprising: means for determining a deterministic bounding box from which to retrieve reference samples of reference pictures of video data for performing decoder-side motion vector derivation (DMVD) for a current block of the video data; means for deriving a motion vector for the current block according to DMVD using the reference samples within the deterministic bounding box; means for forming a prediction block using the motion vector; and decoding the current block using the prediction block.</p><p id="p-0266" num="0311">Clause 57: The device of clause 56, wherein the means for deriving the motion vector comprises: means for performing a motion field reconstruction stage using one or more unrefined motion vectors of previously coded blocks to the current block; and means for performing a reference sample fetching stage using the one or more unrefined motion vectors of the previously coded blocks, and wherein the means for forming the prediction block comprises means for performing a motion compensation stage for the current block using one or more refined motion vectors of the previously coded blocks to generate the prediction block for the current block.</p><p id="p-0267" num="0312">Clause 58: The device of clause 56, wherein the means for deriving the motion vector for the current block according to DMVD comprises means for deriving the motion vector for the current block according to template matching (TM), including using only neighboring reconstruction samples to form a current block template for TM.</p><p id="p-0268" num="0313">Clause 59: A method of decoding video data, the method comprising: determining a deterministic bounding box from which to retrieve reference samples of reference pictures of video data for performing decoder-side motion vector derivation (DMVD) for a current block of the video data; deriving a motion vector for the current block according to DMVD using the reference samples within the deterministic bounding box; forming a prediction block using the motion vector; and decoding the current block using the prediction block.</p><p id="p-0269" num="0314">Clause 60: The method of clause 59, wherein deriving the motion vector comprises: retrieving an unrefined motion vector from a neighboring block to the current block; and refining the unrefined motion vector to form the motion vector for the current block.</p><p id="p-0270" num="0315">Clause 61: The method of any of clauses 59 and 60, wherein determining the deterministic bounding box comprises: decoding motion information for a neighboring block to the current block, the motion information including data defining a neighboring block motion vector; and using the neighboring block motion vector to determine the deterministic bounding block.</p><p id="p-0271" num="0316">Clause 62: The method of clause 61, further comprising: refining the neighboring block motion vector to form a refined neighboring block motion vector; and predicting the neighboring block using the refined neighboring block motion vector.</p><p id="p-0272" num="0317">Clause 63: The method of any of clauses 61 and 62, wherein determining the deterministic bounding box comprises determining the deterministic bounding box as having an area including samples within N samples of a sample indicated by the neighboring block motion vector.</p><p id="p-0273" num="0318">Clause 64: The method of clause 63, wherein N is a predefined value determined according to a multiple of an internal motion vector storage precision.</p><p id="p-0274" num="0319">Clause 65: The method of any of clauses 63 and 64, wherein N is the same for each of template matching (TM), bilateral merge (BM), decoder-side motion vector refinement (DMVR), or multi-pass DMVR.</p><p id="p-0275" num="0320">Clause 66: The method of any of clauses 59-65, wherein determining the deterministic bounding box comprises determining the deterministic bounding box according to an interpolation filter length for DMVD.</p><p id="p-0276" num="0321">Clause 67: The method of any of clauses 59-66, wherein deriving the motion vector comprises performing a motion search starting within the deterministic bounding box.</p><p id="p-0277" num="0322">Clause 68: The method of any of clauses 59-67, wherein DMVD comprises one of template matching (TM), bilateral merge (BM), decoder-side motion vector refinement (DMVR), or multi-pass DMVR.</p><p id="p-0278" num="0323">Clause 69: The method of any of clauses 59-68, wherein deriving the motion vector comprises: performing a motion field reconstruction stage using one or more unrefined motion vectors of previously coded blocks to the current block; and performing a reference sample fetching stage using the one or more unrefined motion vectors of the previously coded blocks, and wherein forming the prediction block comprises performing a motion compensation stage for the current block using one or more refined motion vectors of the previously coded blocks to generate the prediction block for the current block.</p><p id="p-0279" num="0324">Clause 70: The method of clause 69, further comprising generating a motion vector candidate list for the current block using the one or more unrefined motion vectors of the previously coded blocks.</p><p id="p-0280" num="0325">Clause 71: The method of any of clauses 59-70, wherein deriving the motion vector for the current block according to DMVD comprises deriving the motion vector for the current block according to template matching (TM), including using only neighboring reconstruction samples to form a current block template for TM.</p><p id="p-0281" num="0326">Clause 72: The method of any of clauses 59-71, further comprising encoding the current block prior to decoding the current block.</p><p id="p-0282" num="0327">Clause 73: A device for decoding video data, the device comprising: a memory configured to store video data; and one or more processors implemented in circuitry and configured to: determine a deterministic bounding box from which to retrieve reference samples of reference pictures of video data for performing decoder-side motion vector derivation (DMVD) for a current block of the video data; derive a motion vector for the current block according to DMVD using the reference samples within the deterministic bounding box; form a prediction block using the motion vector; and decode the current block using the prediction block.</p><p id="p-0283" num="0328">Clause 74: The device of clause 73, wherein to derive the motion vector, the one or more processors are configured to: retrieve an unrefined motion vector from a neighboring block to the current block; and refine the unrefined motion vector to form the motion vector for the current block.</p><p id="p-0284" num="0329">Clause 75: The device of any of clauses 73 and 74, wherein to determine the deterministic bounding box, the one or more processors are configured to: decode motion information for a neighboring block to the current block, the motion information including data defining a neighboring block motion vector; and use the neighboring block motion vector to determine the deterministic bounding block.</p><p id="p-0285" num="0330">Clause 76: The device of clause 75, wherein the one or more processors are further configured to: refine the neighboring block motion vector to form a refined neighboring block motion vector; and predict the neighboring block using the refined neighboring block motion vector.</p><p id="p-0286" num="0331">Clause 77: The device of any of clauses 75 and 76, wherein the one or more processors are configured to determine the deterministic bounding box as having an area including samples within N samples of a sample indicated by the neighboring block motion vector.</p><p id="p-0287" num="0332">Clause 78: The device of clause 77, wherein N is a predefined value determined according to a multiple of an internal motion vector storage precision.</p><p id="p-0288" num="0333">Clause 79: The device of any of clauses 77 and 78, wherein N is the same for each of template matching (TM), bilateral merge (BM), decoder-side motion vector refinement (DMVR), or multi-pass DMVR.</p><p id="p-0289" num="0334">Clause 80: The device of any of clauses 73-79, wherein the one or more processors are configured to determine the deterministic bounding box according to an interpolation filter length for DMVD.</p><p id="p-0290" num="0335">Clause 81: The device of any of clauses 73-80, wherein to derive the motion vector, the one or more processors are configured to perform a motion search starting within the deterministic bounding box.</p><p id="p-0291" num="0336">Clause 82: The device of any of clauses 73-81, wherein DMVD comprises one of template matching (TM), bilateral merge (BM), decoder-side motion vector refinement (DMVR), or multi-pass DMVR.</p><p id="p-0292" num="0337">Clause 83: The device of any of clauses 73-82, wherein to derive the motion vector, the one or more processors are configured to: perform a motion field reconstruction stage using one or more unrefined motion vectors of previously coded blocks to the current block; and perform a reference sample fetching stage using the one or more unrefined motion vectors of the previously coded blocks, and wherein to form the prediction block, the one or more processors are configured to perform a motion compensation stage for the current block using one or more refined motion vectors of the previously coded blocks to generate the prediction block for the current block.</p><p id="p-0293" num="0338">Clause 84: The device of clause 83, wherein the one or more processors are configured to generate a motion vector candidate list for the current block using the one or more unrefined motion vectors of the previously coded blocks.</p><p id="p-0294" num="0339">Clause 85: The device of any of clauses 73-84, wherein the one or more processors are configured to derive the motion vector for the current block according to template matching (TM), including using only neighboring reconstruction samples to form a current block template for TM.</p><p id="p-0295" num="0340">Clause 86: The device of any of clauses 73-85, wherein the one or more processors are further configured to encode the current block prior to decoding the current block.</p><p id="p-0296" num="0341">Clause 87: The device of any of clauses 73-86, further comprising a display configured to display the decoded video data.</p><p id="p-0297" num="0342">Clause 88: The device of any of clauses 73-87, wherein the device comprises one or more of a camera, a computer, a mobile device, a broadcast receiver device, or a set-top box.</p><p id="p-0298" num="0343">Clause 89: A computer-readable storage medium having stored thereon instructions that, when executed, cause a processor to: determine a deterministic bounding box from which to retrieve reference samples of reference pictures of video data for performing decoder-side motion vector derivation (DMVD) for a current block of the video data; derive a motion vector for the current block according to DMVD using the reference samples within the deterministic bounding box; form a prediction block using the motion vector; and decode the current block using the prediction block.</p><p id="p-0299" num="0344">Clause 90: The computer-readable storage medium of clause 89, wherein the instructions that cause the processor to derive the motion vector comprise instructions that cause the processor to: perform a motion field reconstruction stage using one or more unrefined motion vectors of previously coded blocks to the current block; and perform a reference sample fetching stage using the one or more unrefined motion vectors of the previously coded blocks, and wherein the instructions that cause the processor to form the prediction block comprise instructions that cause the processor to perform a motion compensation stage for the current block using one or more refined motion vectors of the previously coded blocks to generate the prediction block for the current block.</p><p id="p-0300" num="0345">Clause 91: The computer-readable storage medium of any of clauses 89 and 90, wherein the instructions that cause the processor to derive the motion vector for the current block according to DMVD comprise instructions that cause the processor to derive the motion vector for the current block according to template matching (TM), including using only neighboring reconstruction samples to form a current block template for TM.</p><p id="p-0301" num="0346">Clause 92: A device for decoding video data, the device comprising: means for determining a deterministic bounding box from which to retrieve reference samples of reference pictures of video data for performing decoder-side motion vector derivation (DMVD) for a current block of the video data; means for deriving a motion vector for the current block according to DMVD using the reference samples within the deterministic bounding box; means for forming a prediction block using the motion vector; and decoding the current block using the prediction block.</p><p id="p-0302" num="0347">Clause 93: The device of clause 92, wherein the means for deriving the motion vector comprises: means for performing a motion field reconstruction stage using one or more unrefined motion vectors of previously coded blocks to the current block; and means for performing a reference sample fetching stage using the one or more unrefined motion vectors of the previously coded blocks, and wherein the means for forming the prediction block comprises means for performing a motion compensation stage for the current block using one or more refined motion vectors of the previously coded blocks to generate the prediction block for the current block.</p><p id="p-0303" num="0348">Clause 94: The device of any of clauses 92 and 93, wherein the means for deriving the motion vector for the current block according to DMVD comprises means for deriving the motion vector for the current block according to template matching (TM), including using only neighboring reconstruction samples to form a current block template for TM.</p><p id="p-0304" num="0349">It is to be recognized that depending on the example, certain acts or events of any of the techniques described herein can be performed in a different sequence, may be added, merged, or left out altogether (e.g., not all described acts or events are necessary for the practice of the techniques). Moreover, in certain examples, acts or events may be performed concurrently, e.g., through multi-threaded processing, interrupt processing, or multiple processors, rather than sequentially.</p><p id="p-0305" num="0350">In one or more examples, the functions described may be implemented in hardware, software, firmware, or any combination thereof. If implemented in software, the functions may be stored on or transmitted over as one or more instructions or code on a computer-readable medium and executed by a hardware-based processing unit. Computer-readable media may include computer-readable storage media, which corresponds to a tangible medium such as data storage media, or communication media including any medium that facilitates transfer of a computer program from one place to another, e.g., according to a communication protocol. In this manner, computer-readable media generally may correspond to (1) tangible computer-readable storage media which is non-transitory or (2) a communication medium such as a signal or carrier wave. Data storage media may be any available media that can be accessed by one or more computers or one or more processors to retrieve instructions, code and/or data structures for implementation of the techniques described in this disclosure. A computer program product may include a computer-readable medium.</p><p id="p-0306" num="0351">By way of example, and not limitation, such computer-readable storage media can comprise RAM, ROM, EEPROM, CD-ROM or other optical disk storage, magnetic disk storage, or other magnetic storage devices, flash memory, or any other medium that can be used to store desired program code in the form of instructions or data structures and that can be accessed by a computer. Also, any connection is properly termed a computer-readable medium. For example, if instructions are transmitted from a website, server, or other remote source using a coaxial cable, fiber optic cable, twisted pair, digital subscriber line (DSL), or wireless technologies such as infrared, radio, and microwave, then the coaxial cable, fiber optic cable, twisted pair, DSL, or wireless technologies such as infrared, radio, and microwave are included in the definition of medium. It should be understood, however, that computer-readable storage media and data storage media do not include connections, carrier waves, signals, or other transitory media, but are instead directed to non-transitory, tangible storage media. Disk and disc, as used herein, includes compact disc (CD), laser disc, optical disc, digital versatile disc (DVD), floppy disk and Blu-ray disc, where disks usually reproduce data magnetically, while discs reproduce data optically with lasers. Combinations of the above should also be included within the scope of computer-readable media.</p><p id="p-0307" num="0352">Instructions may be executed by one or more processors, such as one or more digital signal processors (DSPs), general purpose microprocessors, application specific integrated circuits (ASICs), field programmable gate arrays (FPGAs), or other equivalent integrated or discrete logic circuitry. Accordingly, the terms &#x201c;processor&#x201d; and &#x201c;processing circuitry,&#x201d; as used herein may refer to any of the foregoing structures or any other structure suitable for implementation of the techniques described herein. In addition, in some aspects, the functionality described herein may be provided within dedicated hardware and/or software modules configured for encoding and decoding, or incorporated in a combined codec. Also, the techniques could be fully implemented in one or more circuits or logic elements.</p><p id="p-0308" num="0353">The techniques of this disclosure may be implemented in a wide variety of devices or apparatuses, including a wireless handset, an integrated circuit (IC) or a set of ICs (e.g., a chip set). Various components, modules, or units are described in this disclosure to emphasize functional aspects of devices configured to perform the disclosed techniques, but do not necessarily require realization by different hardware units. Rather, as described above, various units may be combined in a codec hardware unit or provided by a collection of interoperative hardware units, including one or more processors as described above, in conjunction with suitable software and/or firmware.</p><p id="p-0309" num="0354">Various examples have been described. These and other examples are within the scope of the following claims.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A method of decoding video data, the method comprising:<claim-text>determining a deterministic bounding box from which to retrieve reference samples of reference pictures of video data for performing decoder-side motion vector derivation (DMVD) for a current block of the video data;</claim-text><claim-text>deriving a motion vector for the current block according to DMVD using the reference samples within the deterministic bounding box;</claim-text><claim-text>forming a prediction block using the motion vector; and</claim-text><claim-text>decoding the current block using the prediction block.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein deriving the motion vector comprises:<claim-text>retrieving an unrefined motion vector from a neighboring block to the current block; and</claim-text><claim-text>refining the unrefined motion vector to form the motion vector for the current block.</claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein determining the deterministic bounding box comprises:<claim-text>decoding motion information for a neighboring block to the current block, the motion information including data defining a neighboring block motion vector; and</claim-text><claim-text>using the neighboring block motion vector to determine the deterministic bounding block.</claim-text></claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, further comprising:<claim-text>refining the neighboring block motion vector to form a refined neighboring block motion vector; and</claim-text><claim-text>predicting the neighboring block using the refined neighboring block motion vector.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein determining the deterministic bounding box comprises determining the deterministic bounding box as having an area including samples within N samples of a sample indicated by the neighboring block motion vector.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein N is a predefined value determined according to a multiple of an internal motion vector storage precision.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein N is the same for each of template matching (TM), bilateral merge (BM), decoder-side motion vector refinement (DMVR), or multi-pass DMVR.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein determining the deterministic bounding box comprises determining the deterministic bounding box according to an interpolation filter length for DMVD.</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein deriving the motion vector comprises performing a motion search starting within the deterministic bounding box.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein DMVD comprises one of template matching (TM), bilateral merge (BM), decoder-side motion vector refinement (DMVR), or multi-pass DMVR.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>,<claim-text>wherein deriving the motion vector comprises:<claim-text>performing a motion field reconstruction stage using one or more unrefined motion vectors of previously coded blocks to the current block; and</claim-text><claim-text>performing a reference sample fetching stage using the one or more unrefined motion vectors of the previously coded blocks, and</claim-text></claim-text><claim-text>wherein forming the prediction block comprises performing a motion compensation stage for the current block using one or more refined motion vectors of the previously coded blocks to generate the prediction block for the current block.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, further comprising generating a motion vector candidate list for the current block using the one or more unrefined motion vectors of the previously coded blocks.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein deriving the motion vector for the current block according to DMVD comprises deriving the motion vector for the current block according to template matching (TM), including using only neighboring reconstruction samples to form a current block template for TM.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising encoding the current block prior to decoding the current block.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. A device for decoding video data, the device comprising:<claim-text>a memory configured to store video data; and</claim-text><claim-text>one or more processors implemented in circuitry and configured to:<claim-text>determine a deterministic bounding box from which to retrieve reference samples of reference pictures of video data for performing decoder-side motion vector derivation (DMVD) for a current block of the video data;</claim-text><claim-text>derive a motion vector for the current block according to DMVD using the reference samples within the deterministic bounding box;</claim-text><claim-text>form a prediction block using the motion vector; and</claim-text><claim-text>decode the current block using the prediction block.</claim-text></claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The device of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein to derive the motion vector, the one or more processors are configured to:<claim-text>retrieve an unrefined motion vector from a neighboring block to the current block; and</claim-text><claim-text>refine the unrefined motion vector to form the motion vector for the current block.</claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The device of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein to determine the deterministic bounding box, the one or more processors are configured to:<claim-text>decode motion information for a neighboring block to the current block, the motion information including data defining a neighboring block motion vector; and</claim-text><claim-text>use the neighboring block motion vector to determine the deterministic bounding block.</claim-text></claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The device of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the one or more processors are further configured to:<claim-text>refine the neighboring block motion vector to form a refined neighboring block motion vector; and</claim-text><claim-text>predict the neighboring block using the refined neighboring block motion vector.</claim-text></claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The device of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the one or more processors are configured to determine the deterministic bounding box as having an area including samples within N samples of a sample indicated by the neighboring block motion vector.</claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The device of <claim-ref idref="CLM-00019">claim 19</claim-ref>, wherein N is a predefined value determined according to a multiple of an internal motion vector storage precision.</claim-text></claim><claim id="CLM-00021" num="00021"><claim-text><b>21</b>. The device of <claim-ref idref="CLM-00019">claim 19</claim-ref>, wherein N is the same for each of template matching (TM), bilateral merge (BM), decoder-side motion vector refinement (DMVR), or multi-pass DMVR.</claim-text></claim><claim id="CLM-00022" num="00022"><claim-text><b>22</b>. The device of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the one or more processors are configured to determine the deterministic bounding box according to an interpolation filter length for DMVD.</claim-text></claim><claim id="CLM-00023" num="00023"><claim-text><b>23</b>. The device of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein to derive the motion vector, the one or more processors are configured to perform a motion search starting within the deterministic bounding box.</claim-text></claim><claim id="CLM-00024" num="00024"><claim-text><b>24</b>. The device of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein DMVD comprises one of template matching (TM), bilateral merge (BM), decoder-side motion vector refinement (DMVR), or multi-pass DMVR.</claim-text></claim><claim id="CLM-00025" num="00025"><claim-text><b>25</b>. The device of <claim-ref idref="CLM-00015">claim 15</claim-ref>,<claim-text>wherein to derive the motion vector, the one or more processors are configured to:<claim-text>perform a motion field reconstruction stage using one or more unrefined motion vectors of previously coded blocks to the current block; and</claim-text><claim-text>perform a reference sample fetching stage using the one or more unrefined motion vectors of the previously coded blocks, and</claim-text></claim-text><claim-text>wherein to form the prediction block, the one or more processors are configured to perform a motion compensation stage for the current block using one or more refined motion vectors of the previously coded blocks to generate the prediction block for the current block.</claim-text></claim-text></claim><claim id="CLM-00026" num="00026"><claim-text><b>26</b>. The device of <claim-ref idref="CLM-00025">claim 25</claim-ref>, wherein the one or more processors are configured to generate a motion vector candidate list for the current block using the one or more unrefined motion vectors of the previously coded blocks.</claim-text></claim><claim id="CLM-00027" num="00027"><claim-text><b>27</b>. The device of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the one or more processors are configured to derive the motion vector for the current block according to template matching (TM), including using only neighboring reconstruction samples to form a current block template for TM.</claim-text></claim><claim id="CLM-00028" num="00028"><claim-text><b>28</b>. The device of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the one or more processors are further configured to encode the current block prior to decoding the current block.</claim-text></claim><claim id="CLM-00029" num="00029"><claim-text><b>29</b>. The device of <claim-ref idref="CLM-00015">claim 15</claim-ref>, further comprising a display configured to display the decoded video data.</claim-text></claim><claim id="CLM-00030" num="00030"><claim-text><b>30</b>. The device of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the device comprises one or more of a camera, a computer, a mobile device, a broadcast receiver device, or a set-top box.</claim-text></claim><claim id="CLM-00031" num="00031"><claim-text><b>31</b>. A computer-readable storage medium having stored thereon instructions that, when executed, cause a processor to:<claim-text>determine a deterministic bounding box from which to retrieve reference samples of reference pictures of video data for performing decoder-side motion vector derivation (DMVD) for a current block of the video data;</claim-text><claim-text>derive a motion vector for the current block according to DMVD using the reference samples within the deterministic bounding box;</claim-text><claim-text>form a prediction block using the motion vector; and</claim-text><claim-text>decode the current block using the prediction block.</claim-text></claim-text></claim><claim id="CLM-00032" num="00032"><claim-text><b>32</b>. The computer-readable storage medium of <claim-ref idref="CLM-00031">claim 31</claim-ref>,<claim-text>wherein the instructions that cause the processor to derive the motion vector comprise instructions that cause the processor to:<claim-text>perform a motion field reconstruction stage using one or more unrefined motion vectors of previously coded blocks to the current block; and</claim-text><claim-text>perform a reference sample fetching stage using the one or more unrefined motion vectors of the previously coded blocks, and</claim-text></claim-text><claim-text>wherein the instructions that cause the processor to form the prediction block comprise instructions that cause the processor to perform a motion compensation stage for the current block using one or more refined motion vectors of the previously coded blocks to generate the prediction block for the current block.</claim-text></claim-text></claim><claim id="CLM-00033" num="00033"><claim-text><b>33</b>. The computer-readable storage medium of <claim-ref idref="CLM-00031">claim 31</claim-ref>, wherein the instructions that cause the processor to derive the motion vector for the current block according to DMVD comprise instructions that cause the processor to derive the motion vector for the current block according to template matching (TM), including using only neighboring reconstruction samples to form a current block template for TM.</claim-text></claim><claim id="CLM-00034" num="00034"><claim-text><b>34</b>. A device for decoding video data, the device comprising:<claim-text>means for determining a deterministic bounding box from which to retrieve reference samples of reference pictures of video data for performing decoder-side motion vector derivation (DMVD) for a current block of the video data;</claim-text><claim-text>means for deriving a motion vector for the current block according to DMVD using the reference samples within the deterministic bounding box;</claim-text><claim-text>means for forming a prediction block using the motion vector; and</claim-text><claim-text>decoding the current block using the prediction block.</claim-text></claim-text></claim><claim id="CLM-00035" num="00035"><claim-text><b>35</b>. The device of <claim-ref idref="CLM-00034">claim 34</claim-ref>,<claim-text>wherein the means for deriving the motion vector comprises:<claim-text>means for performing a motion field reconstruction stage using one or more unrefined motion vectors of previously coded blocks to the current block; and</claim-text><claim-text>means for performing a reference sample fetching stage using the one or more unrefined motion vectors of the previously coded blocks, and</claim-text></claim-text><claim-text>wherein the means for forming the prediction block comprises means for performing a motion compensation stage for the current block using one or more refined motion vectors of the previously coded blocks to generate the prediction block for the current block.</claim-text></claim-text></claim><claim id="CLM-00036" num="00036"><claim-text><b>36</b>. The device of <claim-ref idref="CLM-00034">claim 34</claim-ref>, wherein the means for deriving the motion vector for the current block according to DMVD comprises means for deriving the motion vector for the current block according to template matching (TM), including using only neighboring reconstruction samples to form a current block template for TM.</claim-text></claim></claims></us-patent-application>