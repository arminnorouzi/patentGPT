<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004418A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004418</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17931353</doc-number><date>20220912</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>455</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>50</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>54</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>45558</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>5077</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>45545</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>545</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>2009</main-group><subgroup>4557</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>2009</main-group><subgroup>45595</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>2009</main-group><subgroup>45587</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">Formally Verified Trusted Computing Base with Active Security and Policy Enforcement</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>17500728</doc-number><date>20211013</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11442770</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17931353</doc-number></document-id></child-doc></relation></continuation><us-provisional-application><document-id><country>US</country><doc-number>63091294</doc-number><date>20201013</date></document-id></us-provisional-application></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>BedRock Systems, Inc.</orgname><address><city>San Mateo</city><state>CA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Ismael</last-name><first-name>Osman Abdoul</first-name><address><city>Annapolis</city><state>MD</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Aziz</last-name><first-name>Ashar</first-name><address><city>Coral Gables</city><state>FL</state><country>US</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>Pfoh</last-name><first-name>Jonas</first-name><address><city>Dresden</city><country>DE</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A formally verified trusted computing base with active security and policy enforcement is described. The formally verified trusted computing base includes a formally verified microkernel and multiple formally verified hyper-processes including a virtual machine monitor (VMM), virtual machine introspection (VMI), policy enforcers including an active security policy enforcer (ASPE), and a virtual switch. The active security and policy enforcement continuously monitors for semantic behavior detection or policy violations and enforces the policies at the virtualization layer. Further, policies can be attached to the network layer to provide granular control of the communication of the computing device.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="181.44mm" wi="98.47mm" file="US20230004418A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="254.34mm" wi="170.86mm" orientation="landscape" file="US20230004418A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="230.72mm" wi="158.83mm" orientation="landscape" file="US20230004418A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="231.14mm" wi="100.50mm" file="US20230004418A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="199.73mm" wi="107.36mm" file="US20230004418A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="248.75mm" wi="141.39mm" file="US20230004418A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="249.60mm" wi="148.59mm" file="US20230004418A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="236.39mm" wi="103.55mm" file="US20230004418A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="238.51mm" wi="103.55mm" file="US20230004418A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="259.08mm" wi="170.86mm" orientation="landscape" file="US20230004418A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="256.62mm" wi="170.86mm" orientation="landscape" file="US20230004418A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="161.37mm" wi="159.17mm" orientation="landscape" file="US20230004418A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="254.34mm" wi="169.67mm" orientation="landscape" file="US20230004418A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="254.34mm" wi="169.25mm" orientation="landscape" file="US20230004418A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading><p id="p-0002" num="0001">This application is a continuation of U.S. application Ser. No. 17/500,728, filed Oct. 13, 2021, which claims the benefit of U.S. Provisional Application No. 63/091,294, filed Oct. 13, 2020, which is hereby incorporated by reference.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">FIELD</heading><p id="p-0003" num="0002">Embodiments of the invention relate to the field of virtualization; and more specifically, to a formally verified trusted computing base with active security and policy enforcement.</p><heading id="h-0003" level="1">BACKGROUND</heading><p id="p-0004" num="0003">Virtualization makes it possible for multiple operating systems (OSs) to run concurrently on a single host system without those OSs needing to be aware of the others. The single physical host machine is multiplexed into virtual machines (VMs) on top of which unmodified OSs (referred to as guest OSs) can run. Conventional implementations include a software abstraction layer between the hardware (which may support full virtualization) and the hosted operating system(s). The virtualization layer translates between virtual devices and the physical devices of the platform. In a fully virtualized environment, a guest operating system (OS) can run a virtual machine without any modifications and is typically unaware that it is being virtualized. Paravirtualization is a technique that makes a guest OS aware of its virtualization environment and requires hooks to a guest OS which requires access to its source code, or a binary translation be performed.</p><p id="p-0005" num="0004">Although virtualization relies on hardware support, a software component called a microkernel runs directly on the hardware of the host machine and exposes the VM to the guest OS. The microkernel is typically the most privileged component of the virtual environment. The microkernel abstracts from the underlying hardware platform and isolates components running on top of it. A virtual machine monitor (VMM) manages the interactions between virtual machines and the physical resources of the host system. The VMM exposes an interface that resembles physical hardware to its virtual machine, thereby giving the guest OS the illusion of running on a bare-metal platform. As compared to the microkernel, the VMM is a deprivileged user component whereas the microkernel is a privileged kernel component.</p><p id="p-0006" num="0005">Virtual Machine Introspection (VMI) is a technique conventionally used to observe hardware states and events and can be used to extrapolate the software state of the host. VMI leverages the property of a VMM that has access to all the state of a virtual machine including the CPU state, memory, and I/O device state.</p><heading id="h-0004" level="1">SUMMARY</heading><p id="p-0007" num="0006">A formally verified trusted computing base with active security and policy enforcement is described. The formally verified trusted computing base includes a formally verified microkernel and multiple formally verified hyper-processes including a virtual machine monitor (VMM), virtual machine introspection (VMI), policy enforcers including an active security policy enforcer (ASPE), and a virtual switch. The active security and policy enforcement continuously monitors for semantic behavior detection or policy violations and enforces the policies at the virtualization layer. Further, policies can be attached to the network layer to provide granular control of the communication of the computing device.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0008" num="0007">The invention may best be understood by referring to the following description and accompanying drawings that are used to illustrate embodiments of the invention. In the drawings:</p><p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram that illustrates an exemplary architecture for a formally verified trusted computing base with active security and policy enforcement, according to an embodiment.</p><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a block diagram that illustrates policy enforcement according to some embodiment.</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a flow diagram that illustrates exemplary operations for enforcing a policy according to an embodiment.</p><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a flow diagram that illustrates exemplary operations for enforcing register protection according to an embodiment.</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a flow diagram that illustrates exemplary operations for enforcing a process access policy according to an embodiment.</p><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a flow diagram that illustrates exemplary operations for enforcing a driver access policy according to an embodiment.</p><p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a flow diagram that illustrates exemplary operations for enforcing a data structure integrity policy according to an embodiment.</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a flow diagram that illustrates exemplary operations for enforcing code integrity policy according to an embodiment.</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a block diagram that shows an exemplary implementation for the formally verified trusted computing base as shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref> for an ARM architecture.</p><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a block diagram that shows an exemplary implementation for the formally verified trusted computing base as shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref> for an x86 architecture.</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>11</b></figref> is a flow chart that illustrates an exemplary method of formal verification that may be used in some embodiments.</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>12</b></figref> illustrates an example use of the formally verified trusted computing base with active security and policy enforcement, according to an embodiment.</p><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. <b>13</b></figref> illustrates an example use of the formally verified trusted computing base with active security and policy enforcement, according to an embodiment.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0006" level="1">DESCRIPTION OF EMBODIMENTS</heading><p id="p-0022" num="0021">A formally verified trusted computing base with active security and policy enforcement is described. The formally verified trusted computing base includes a formally verified microkernel and multiple formally verified hyper-processes including a virtual machine monitor (VMM), virtual machine introspection (VMI), policy enforcers including an active security policy enforcer (ASPE), and a virtual switch. The virtualized system can run unmodified guest operating systems without recompiling the kernel or any application. The fundamental hardware abstraction layer can leverage hardware features while concealing them from the unmodified guest operating system, thereby increasing system security.</p><p id="p-0023" num="0022">In an embodiment, there is a one-to-one mapping from a guest operating system or application to a VMM, VMI, and ASPE construct. This provides for better isolation properties (e.g., process and memory segregation) as compared to conventional virtualized systems that have a many-to-one mapping from guest operating systems to a VMM/VMI construct. This separation helps protect against microarchitecture-based side channel attacks. Further, this separation provides assurance in a multi-tenant environment that essential forensic data and telemetries are not leaked between the guest operating systems.</p><p id="p-0024" num="0023">The formally verified trusted computing base isolates assets, and monitors and enforces policy on all resources, APIs, and communication. The virtualized system controls the basic primitives of compute for the physical computing device: control flow, memory, and time. The virtualized system has visibility to everything the virtual machine does without having to change the guest operating system or the guest application, and without having to deploy any software within the guest operating system or guest application. Thus, the virtualized system is isolated from the attack surface of the guest VM.</p><p id="p-0025" num="0024">In an embodiment, the formally verified microkernel implements a capability-based system that ensures that resources can be accessed only when explicitly enabled. In such an embodiment, each piece of executing code and resource requires explicit authorization in the form of a granted capability to access a hardware resource or code resource.</p><p id="p-0026" num="0025">The virtualized system performs active security and policy enforcement. In an embodiment, the active security policy enforcement continuously monitors for semantic behavior detection or policy violations and enforces the policies at the virtualization layer. Thus, the active security and policy enforcement protects and enforces the behavior of the guest operating systems or guest applications, even within a contested environment. The active security policy enforcement includes performing introspection on hardware resources (e.g., CPUs, GPUs, memory, I/O devices such as USB, disk storage, network devices, etc.), monitoring application and OS behavior, and/or monitoring code and data integrity. VMI is used for creating detailed forensics for gesture machines, virtual services, and hardware resources. In combination with deep semantic information about the guest operating systems or guest applications, fine-grained policies can be enforced, which can block malicious behavior from instruction level to application behavior, for example.</p><p id="p-0027" num="0026">The policies may be different for different guest operating systems or applications. For instance, a policy for a first guest operating system may allow network communication whereas a policy for a second guest operating system may not allow network communication. Policies may be configured locally on the system or may be received remotely and dynamically. For instance, if it is determined that there is a domain that is serving malware, a remote server can transmit a policy to the virtualized system that prevents access to that particular domain. Thus, as an example, the network policies and enforcement at a virtual switch of the virtualized system allow for granular control of the communication of the computing device.</p><p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram that illustrates an exemplary architecture for a formally verified trusted computing base with active security and policy enforcement, according to an embodiment. The computing device <b>100</b> may be any type of computing device such as a desktop computer, a laptop computer, a server computer, a mobile device such as a smartphone or tablet, a wearable device, a set-top box, a medical computing device, a gaming device, an internet-of-things (IoT) device, or any other computing device that can implement a virtualized system. The computing device <b>100</b> executes a hypervisor <b>105</b>.</p><p id="p-0029" num="0028">The virtualized system includes one or more guest operating systems <b>110</b>A-N and guest applications <b>111</b>A-N respectively running on top of one or more virtual machines <b>108</b>A-N respectively. The guest OS and applications may be unmodified. In an embodiment, each virtual machine has a separate virtual machine monitor (VMM) with virtual machine introspection (VMI) and separate active security policies, which ensures maximum process and memory segregation. Thus, the VMM <b>115</b>A, VMI <b>116</b>A, and the active security policy enforcer <b>117</b>A are dedicated for the guest operating system <b>110</b>A and guest applications <b>111</b>A running on the virtual machine <b>108</b>A; and the VMM <b>115</b>N, VMI <b>116</b>N, and the active security policy enforcer <b>117</b>N are dedicated for the guest OS <b>110</b>N and guest applications <b>111</b>N running on the virtual machine <b>108</b>N. This separation provides a level of protection even against bugs in the hardware as the memory of each VM is mapped into a specific isolated memory space and no memory from other VMMs and their VMs can be read.</p><p id="p-0030" num="0029">Each VMM runs as a user-level application in an address space on top of the microkernel <b>160</b> and supports the execution of the guest OS (e.g., an unmodified guest OS) running in a virtual machine. Each VMM emulates sensitive instructions and provides virtual devices. Each VMM manages the guest-physical memory of its associated virtual machine by mapping a subset of its own address space into the host address space of the VM. Each VMM can translate the guest virtual addresses to guest physical addresses. Each VMM can configure/modify access permissions of individual guest physical addresses in the system's second level address translation tables (slats). Each VMM can also map any of its I/O ports and memory-mapped I/O (MMIO) regions into the virtual machine to grant direct access to a hardware device. For example, a VMM creates a dedicated portal for each event type and sets the transfer descriptor in the portals such that the microkernel <b>160</b> transmits only the architectural state required for handling the particular event. For example, the VMM configures the portal corresponding to the CPUID instruction with a transfer descriptor that includes only the general-purpose registers, instruction pointer, and instruction length.</p><p id="p-0031" num="0030">When a VM-exit event occurs, the microkernel <b>160</b> sends a message to the portal corresponding to the VM-exit event and transfers the requested architectural state of the virtual CPU to the handler execution context in the VMM. The VMM determines the type of virtualization event from the portal that was called and then executes the correct handler function. To emulate instructions such as CPUID, the VMM loads the general-purpose registers with new values and advances the instruction pointer to point behind the instruction that caused the VM exit. The VMM transmits the updated state to the microkernel <b>160</b> and the virtual CPU can resume execution.</p><p id="p-0032" num="0031">Each VMM provides one or more virtual devices for its guest OS. Each virtual device is modeled as a software state machine that mimics the behavior of the corresponding hardware device. When an instruction reads from or writes to an I/O port or memory-mapped I/O register, the VMM updates the state machine of the corresponding device model in a like way as the physical hardware device would update its internal state. When a guest OS wants to perform an operation such as a disk read, the VMM contacts the device driver for the host device to deliver the data.</p><p id="p-0033" num="0032">If a virtual CPU performs a memory-mapped I/O access, a VM-exit event occurs. The microkernel <b>160</b> sends a fault message to the corresponding VMM because the region of guest-physical memory corresponding to the disk controller is not mapped in the host address space of the virtual machine. The VMM decodes the instruction and determines that the instruction accesses the virtual disk controller. By executing the instruction, the VMM updates the state machine of the disk model. After the guest operating system has programmed the command register of the virtual disk controller to read a block, the VMM sends a message to the disk server to request the data. The device driver in the disk server programs the physical disk controller with a command to read the block into memory. The disk driver requests a direct memory access (DMA) transfer of the data directly into the memory of the virtual machine. It then returns control back to the VMM, which resumes the virtual machine. Once the block has been read from disk, the disk controller generates an interrupt to signal completion. The disk server writes completion records for all finished requests into a region of memory shared with the VMM. Once the VMM has received a notification message that disk operations have completed, it updates the state machine of the device model to reflect the completion and signals an interrupt at the virtual interrupt controller. During the next VM exit, the VMM injects the pending interrupt into the virtual machine.</p><p id="p-0034" num="0033">A particular VMM has full visibility into the entire guest state of its corresponding virtual machine including hardware state (e.g., CPU state (e.g., registers), GPU state (e.g., registers), memory, I/O device state such as the contents of storage devices (e.g., hard disks), network card state, register state of I/O controllers, etc.), application and OS behavior, and code and data integrity. Virtual Machine Introspection (VMI) is performed to inspect the guest and has visibility of every system call, resource access, and application/process launch and termination. For example, the VMM can program the hardware to trap certain events which can be used by the VMI to take and inspect the guest's state at that moment. Thus, the VMM can inspect all interactions between the guest software and the underlying hardware.</p><p id="p-0035" num="0034">The microkernel <b>160</b> of the hypervisor <b>105</b> may be a lightweight microkernel running at the most privileged level as required by its role to abstract hardware resources (e.g., the CPU) with a minimum interface, and may have less than 10 kloc of code. The hardware <b>180</b> of the computing device <b>100</b> includes one or more central processing units (CPUs) <b>182</b>, one or more graphics processing units (GPUs) <b>184</b>, one or more memory units <b>186</b> (e.g., volatile memory such as SRAM or DRAM), and one or more input/output devices <b>188</b> such as one or more non-volatile storage devices, one or more human interface devices, etc. The hardware components are exemplary and there may be fewer pieces and/or different pieces of hardware included in the system. For instance, the hardware <b>180</b> may not include a GPU. Sitting atop the hardware <b>180</b> is the firmware <b>178</b>. The firmware <b>178</b> may include CPU microcode, platform BIOS, etc.</p><p id="p-0036" num="0035">The microkernel <b>160</b> drives the interrupt controllers of the computing device <b>100</b> and a scheduling timer. The microkernel <b>160</b> also controls the memory-management unit (MMU) and input-output memory-management unit (IOMMU) if available on the computing device <b>100</b>. The microkernel <b>160</b> implements a capability-based interface. In an embodiment, the microkernel <b>160</b> is organized around several kernel objects including the protection domain <b>162</b>, execution context <b>164</b>, scheduling context <b>166</b>, portals <b>168</b>, and semaphores <b>170</b>. For each new kernel object, the microkernel <b>160</b> installs a capability that refers to that object in the capability space of the creator protection domain <b>162</b>. A capability is opaque and immutable to the user, and they cannot be inspected, modified, or addressed directly. Applications access a capability through a capability selector which may be an integral number that serves as an index into the protection domain's capability space. The use of capabilities leads to fine-grained access control and supports the design principle of least privilege among all components. In an embodiment, the interface to the microkernel <b>160</b> uses capabilities for all operations which means that each protection domain <b>162</b> can only access kernel objects for which it holds the corresponding capabilities.</p><p id="p-0037" num="0036">The protection domain <b>162</b> kernel object implements spatial isolation. The protection domain <b>162</b> acts as a resource container and abstracts the differences between a user application and a virtual machine. Each protection domain <b>162</b> may include three spaces: the memory space <b>172</b> that manages the page table, the I/O space <b>174</b> that manages the I/O permission bitmap, and a capability space that controls access to kernel objects.</p><p id="p-0038" num="0037">The execution context <b>164</b> represents the activities in a protection domain. Execution contexts <b>164</b> abstract from the differences between threads and virtual CPUs and/or GPUs. Each execution context <b>164</b> can execute program code, manipulate data, and use portals to send messages to other execution contexts <b>164</b>. Each execution context <b>164</b> has its own CPU/FPU register state and/or GPU register state.</p><p id="p-0039" num="0038">The scheduling context <b>166</b> is used by the microkernel <b>160</b> to enforce temporal separation. Scheduling contexts <b>166</b> couple a time quantum with a priority and ensure that no execution context <b>164</b> can monopolize the CPU. The priority of a scheduling context <b>166</b> reflects its importance. The time quantum facilitates round-robin scheduling among scheduling contexts <b>166</b> with equal importance.</p><p id="p-0040" num="0039">The portals <b>168</b> govern communication between protection domains <b>162</b>. Each portal <b>168</b> represents a dedicated entry point into the protection domain <b>162</b> in which the portal <b>168</b> was created. The creator can subsequently grant other protection domains <b>162</b> access to the portal <b>168</b> to establish a cross-domain communication channel.</p><p id="p-0041" num="0040">The semaphores <b>170</b> enable synchronization between execution contexts <b>164</b> on the same or on different processors or cores by selectively blocking and unblocking execution contexts <b>164</b>. The microkernel <b>160</b> uses the semaphores <b>170</b> to signal the occurrence of hardware interrupts to user applications. Access to a semaphore is controlled by a semaphore object capability.</p><p id="p-0042" num="0041">Running on top of the microkernel <b>160</b> are multiple hyper-processes. Each hyper-process runs as a separate protected and microkernel <b>160</b> enforced memory and process space, outside of the privilege level of the microkernel <b>160</b>. In an embodiment, each hyper-process is formally verified. Some of these hyper-processes communicate with the microkernel <b>160</b> such as the master controller <b>150</b>. The master controller <b>150</b> controls the operation of the virtualization such as memory allocation, execution time allotment, virtual machine creation, and/or inter-process communication. For instance, the master controller <b>150</b> controls the capabilities allocation and distribution <b>152</b> and the hyperprocesses lifecycle management <b>154</b> that manages the lifecycle of hyper-processes.</p><p id="p-0043" num="0042">A capability is a reference to a resource, plus associated auxiliary data such as access permissions. A null capability does not refer to anything and carries no permissions. An object capability is stored in the object space of a protection domain and refers to a kernel object. A protection domain object capability refers to a protection domain. An execution context object capability refers to an execution context. A scheduling context object capability refers to a scheduling context. A portal object capability refers to a portal. A semaphore object capability refers to a semaphore. A memory object capability is stored in the memory space of a protection domain. An I/O object capability is stored in the I/O port space of a protection domain and refers to an I/O port.</p><p id="p-0044" num="0043">The remote manager <b>120</b> is a single point of contact for external network communication for the computing device <b>100</b>. The remote manager <b>120</b> defines the network identity of the computing device <b>100</b> by implementing the TCP/IP stack and may also implement the TLS service for cryptographic protocols designed to provide secure communications over the network. In an embodiment, the remote manager <b>120</b> validates the network communication (an attestation of both endpoints).</p><p id="p-0045" num="0044">The virtual switch <b>126</b> implements a virtual switch element. The virtual switch <b>126</b> emulates a physical network element and allows for external network communication for guest operating systems or guest applications depending on the network configuration. The virtual switch <b>126</b> may also allow network communication between guest operating systems or guest applications depending on the configuration of the virtual switch <b>126</b>. Although the term &#x201c;switch&#x201d; has been used, in some embodiments the virtual switch <b>126</b> can see through L7 of the OSI model. As will be described in greater detail later herein, virtual network policies may be applied to the virtual switch <b>126</b>.</p><p id="p-0046" num="0045">The service manager <b>128</b> allows hyper-processes to register an interface (functions that they implement) associated with a universally unique identifier (UUID). For example, the device drivers <b>140</b> may register a serial driver with the service manager <b>128</b> to provide a universal asynchronous receiver-transmitter (UART) service with its UUID. The I/O multiplexer <b>136</b> (e.g., a UART multiplexer) can request the service manager <b>128</b> access to that service to use the serial port.</p><p id="p-0047" num="0046">The authorization and authentication hyper-process <b>130</b> defines user credentials with their associated role for access control to all the exported functions of the virtualized system.</p><p id="p-0048" num="0047">The management service <b>121</b> exposes the management functions to the outside world. The management service <b>121</b> exposes an application programming interface (API) that can be consumed by third party device managers. The exposed functions may include inventory, monitoring, and telemetry, for example. The management service <b>121</b> may also be used for configuring policies.</p><p id="p-0049" num="0048">The virtual compute functions <b>132</b> implement the lifecycle of the VM including creating a VM, destroying a VM, starting a VM, stopping a VM, freezing a VM, creating a snapshot of the VM, and/or migrating the VM. The I/O multiplexer <b>136</b> is used to multiplex I/O device resources to multiple guests. As described above, the I/O multiplexer <b>136</b> can request the service manager <b>128</b> for access to a registered interface to use the particular I/O device.</p><p id="p-0050" num="0049">The platform manager <b>138</b> provides access to the shared and specific hardware resources of a device, such as clocks that are used by multiple drivers, or power. A hyper-process cannot directly shutdown or slow down a CPU core since it may be shared by other hyper-processes. Instead, the platform manager <b>138</b> is the single point of decision for those requests. Thus, if a hyper-process wants to shut down or slow down a CPU core, for instance, that hyper-process would send a request to the platform manager <b>138</b> which would then make a decision on the request.</p><p id="p-0051" num="0050">The device drivers <b>140</b> control access to the drivers of the computing device <b>100</b>. The device drivers may include a driver for a storage device, network adapter, sound card, printer (if installed), video card, USB device(s), UART devices, etc.</p><p id="p-0052" num="0051">Active security with policy enforcement may be performed by the virtualized system according to an embodiment. The active security and policy enforcement is performed in coordination with the policy manager <b>122</b> and one or more policy enforcers such as the active security policy enforcers <b>117</b>A-<b>117</b>N (using the VMI <b>116</b>A-<b>116</b>N respectively), the virtual network policy enforcer <b>124</b>, and the hardware and firmware policy enforcer <b>134</b>. In an embodiment, the policies that can be enforced includes active security policies, virtual network policies, and/or hardware and/or firmware policies. The policies may be formally verified.</p><p id="p-0053" num="0052">An active security policy enforces the behavior of a guest OS or guest application. Example active security policies include: process allowance, process denial, driver allowance, driver denial, directory allowance, directory denial, file type allowance, file type denial, I/O device allowance, I/O device denial, limiting the number of writes to a particular register and/or limiting the values that can be in a particular register, and protecting a memory page (e.g., limiting writes or reads to specific memory pages, ensuring the memory is not executed).</p><p id="p-0054" num="0053">A virtual network policy enforces the behavior of the network of the computing device <b>100</b> (e.g., affects transmitting data outside of the computing device <b>100</b> and/or receiving data into the computing device <b>100</b>). Example virtual network policies include: source/destination MAC address allow/deny lists, source/destination IP address allow/deny lists; domain allow/deny lists, port allow/deny lists, protocol allow/deny lists, physical layer allow/deny lists (e.g., if a network adapter is available for a particular process or guest application), L4-L7 policies (e.g., traffic must be encrypted; traffic must be encrypted according to a certain cryptographic protocol, etc.), and documents subject to a data loss prevention (DLP) policy. These are example policies and other policies may be created that affect transmitting data outside of the computing device <b>100</b> and/or receiving external data into the computing device <b>100</b>.</p><p id="p-0055" num="0054">Hardware or firmware policies enforce configurations of host hardware configurations/functions and/or host firmware configuration. For instance, a policy may be enforced to require a particular BIOS configuration.</p><p id="p-0056" num="0055">Enforcement of some of the policies may use VMI. A VMI hyper-process is used to inspect the corresponding guest from the outside of the guest. The VMI hyper-process has access to the state of the guest including the CPU(s) <b>182</b>, GPU(s) <b>184</b>, memory <b>186</b>, and I/O devices <b>188</b> in which the guest is using. A VMI hyper-process may include a semantic layer to bridge the semantic gap including reconstructing the information that the guest operating system has outside of the guest within the VMI hyper-process. For instance, the semantic layer identifies the guest operating system and makes the location of its symbols and functions available to the VMI hyper-process. In some embodiments, the VMI hyper-process monitors the system calls of the guest. A system call facilitates communication between the kernel and user space within an OS. The VMI hyper-process may request the corresponding VMM to trap one or more system calls to the VMI hyper-process.</p><p id="p-0057" num="0056">The policy manager <b>122</b> manages policies for the virtualized system as will be described in greater detail below. As an example, a policy may dictate which drivers may be loaded in the guest kernel; or a policy may dictate which guests can be in the same virtual local area network (VLAN). The policies may include active security policies, virtual network policies, and/or hardware and/or firmware policies. The policies may be different for different guest operating systems or applications. For instance, a policy for a first guest operating system may allow network communication whereas a policy for a second guest operating system may not allow network communication.</p><p id="p-0058" num="0057">The policies may be configured locally using the management service <b>121</b> and/or remotely using the remote manager <b>120</b> or may be configured locally on the computing device <b>100</b>. For instance, if it is determined that there is a domain that is serving malware, a remote server can transmit a policy to the remote manager <b>120</b> that specifies that access to that particular domain should be prevented. The remote manager <b>120</b> then sends the policies to the policy manager <b>122</b>. The policy manager <b>122</b> installs the policies to one or more policy enforcement points that are referred to as policy enforcers. Example policy enforcers include the active security policy enforcers <b>117</b>A-<b>117</b>N, the virtual network policy enforcer <b>124</b>, and the hardware and firmware policy enforcer <b>134</b>. The policies may be received and installed dynamically.</p><p id="p-0059" num="0058">The policies may have a user component and/or a time component. For instance, a virtual network policy may specify that a particular domain cannot be reached at a certain time of the day (e.g., overnight). As another example, a virtual network policy may specify that a particular application is allowed network connectivity at only certain times during the day. As another example, a virtual network policy may specify the domains in which a particular user of the guest operating system can access or cannot access, which may be different from another virtual network policy for another user of the guest operating system. As another example, a hardware policy may specify that a particular file or directory cannot be accessed by a guest operating system or application (or potentially a process) during a specific time.</p><p id="p-0060" num="0059">The virtual network policy enforcer <b>124</b> enforces virtual network policies for the network of the computing device <b>100</b>. The virtual network policies are attached to the virtual switch <b>126</b>. The virtual network policies and their enforcement at the virtual switch <b>126</b> allow for granular control of the communication of the computing device <b>100</b> including communication between guest operating systems or guest applications of the virtualized layer and/or external communication from the computing device <b>100</b> and/or external communication into the computing device <b>100</b>. In an embodiment, any or all communication destined for a device external to the computing device <b>100</b> and/or all communication received from a device external to the computing device <b>100</b> can be subject to a virtual network policy.</p><p id="p-0061" num="0060">A virtual network policy may be configured to be specific to a particular process or application. For instance, a virtual network policy may be configured so that a web browser process may only be allowed access to specific ports and/or specific IP addresses or domains.</p><p id="p-0062" num="0061">The virtual network policies may have a user component and/or a time component. For instance, a virtual network policy may specify that a particular domain cannot be reached at a certain time of the day (e.g., overnight). As another example, a virtual network policy may specify that a particular application is allowed network connectivity at only certain times during the day. As another example, a virtual network policy may specify the domains in which a particular user of the guest operating system can access or cannot access, which may be different from another virtual network policy for another user of the guest operating system.</p><p id="p-0063" num="0062">The policy manager <b>122</b> may also configure the virtual switch <b>126</b> through the virtual network policy enforcer <b>124</b>. For instance, the policy manager <b>122</b> may send a network configuration to the virtual network policy enforcer <b>124</b> for configuring virtual Ethernet devices and assigning them to particular VMs, configuring virtual LANs and assigning particular virtual Ethernet devices, etc. The virtual network policy enforcer <b>124</b> in turn configures the virtual switch <b>126</b> accordingly.</p><p id="p-0064" num="0063">The policies may include hardware and/or firmware policies for enforcing configuration of host hardware configurations/functions and host firmware configuration and function. The hardware and/or firmware policies may be enforced by the hardware and firmware policy enforcer <b>134</b>. A hardware policy may affect one or more of the CPU(s) <b>182</b>, GPU(s) <b>184</b>, memory <b>186</b>, and/or one or more I/O devices <b>188</b>. As an example, a policy may be enforced to require a particular BIOS configuration.</p><p id="p-0065" num="0064">The preceding example policies are exemplary and not exhaustive. Other types of policies may be implemented by the virtualization layer.</p><p id="p-0066" num="0065">The policy manager <b>122</b> manages active security policies for the virtualized system as described herein. In an embodiment, the policy manager <b>122</b> is event driven. For instance, the policy manager <b>122</b> enforces policy statements that indicate what action to take when a specified event occurs. The policy manager <b>122</b> may push event policies to policy enforcers such as the active security policy enforcers <b>117</b>A-<b>117</b>N, the virtual network policy enforcer <b>124</b>, and/or the hardware and firmware policy enforcer <b>134</b>, that may result in the policy enforcers generating and transmitting events to the policy manager <b>122</b>. As an example, the policy manager <b>122</b> may enforce a policy that defines if a certain event is received, the policy manager <b>122</b> is to isolate the isolating VM from the network. For instance, the policy manager <b>122</b> may instruct a particular VMI to enforce a process allow list and to generate a process event if the allow list is violated (a process not on the allow list is created) and transmit the event to the policy manager <b>122</b> (or the policy manager <b>122</b> could poll the policy enforcers for events). Upon receipt of such a process event, the policy manager <b>122</b> may issue an action request to the virtual network policy enforcer <b>124</b> to cause the virtual switch <b>126</b> to remove the VM from the network (e.g., prevent the VM from accessing the network).</p><p id="p-0067" num="0066">In an embodiment, a policy for a policy enforcer takes the form of: &#x3c;EVENT&#x3e;, [&#x3c;ARG[0]&#x3e;, . . . ], do [&#x3c;ACTION[0]&#x3e;, . . . ]. The Event parameter defines the name of the event, the Argument list defines the arguments provided to the event producer, and the Action list defines one or more actions the policy enforcer takes if the event is produced. By way of example, a file allow list event policy may be defined to apply to a particular process (e.g., which may be identified by a directory that contains the executable file in question), allow that process to read files from a particular directory, and allow that process to read files with a particular file extension, and if that process attempts to read files from either a different directory or from that directory but with a different file extension, the policy enforcer may execute the one or more actions (such as sending an event to the policy manager <b>122</b>, blocking the attempted read, etc.).</p><p id="p-0068" num="0067">In an embodiment, a policy for the policy manager <b>122</b> takes the form of: on &#x3c;EVENT&#x3e; if &#x3c;FILTER&#x3e; do [&#x3c;ACTION&#x3e;, . . . ]. A filter, which is optional in some embodiments, allows for further conditions to be put on the event. A filter could be a function that always returns true if the condition(s) are satisfied. For instance, a filter could be defined that returns true only once an event has been received a certain number of times (e.g., five times) and potentially over a certain time period. This allows the policy manager <b>122</b> to make stateful decisions that may be shared across rules. The policy manager <b>122</b> may take one or more actions as defined in the action list of the policy. Each action may be defined by a tuple that takes the form of: (executor, action). The executor specifies which entity should carry out the specified action. The executor may be the policy manager <b>122</b> itself or a particular policy enforcer (e.g., active security policy enforcer, virtual network policy enforcer, hardware and firmware policy enforcer). The policy statements and actions in the access list are typically considered in order.</p><p id="p-0069" num="0068">An action to be performed may be requested as an action request. An action request is an asynchronous request made by the policy manager <b>122</b>. An action request includes the action requested and may include one or more parameters to specify how to execute the action. For example, a Kill Task action may include a process identifier (pid) parameter that specifies which task to terminate. Depending on the particular action, action requests can be sent to policy enforcers (e.g., ASPE, virtual network policy enforcer, hardware and firmware policy enforcer) or be carried out by the policy manager <b>122</b> itself. For instance, a log event action request may be performed by the policy manager <b>122</b> itself. Policy enforcers accept action requests and perform the requested actions. Performing an action may cause one or more additional actions to be performed. For instance, an active security policy enforcer may offer a Kill Task action, and the virtual network policy enforcer <b>124</b> may offer an update VLAN configuration action. An action request may result in the generation of new events, which can be sent to the policy manager <b>122</b>. These can be sent asynchronously and the policy manager <b>122</b> may consider these for its own policy.</p><p id="p-0070" num="0069">Some events may require the policy enforcer to wait for acknowledgement before proceeding. In such a case, the policy manager <b>122</b> responds to the event with an acknowledgement action for which the policy enforcer waits to receive before continuing.</p><p id="p-0071" num="0070">In an embodiment, the policy manager <b>122</b> pushes a new or updated policy to a policy enforcer or revokes an existing policy installed at a policy enforcer by sending an update policy action to the policy enforcer. The update policy action includes the policy for the particular policy enforcer.</p><p id="p-0072" num="0071">In some embodiments, communication between the policy manager <b>122</b> and policy enforcers uses a publish/subscribe model. For instance, events and action requests can be assigned a unique message ID and handlers can be registered in the policy manager <b>122</b> to handle incoming events and handlers can be registered in the policy enforcers to handle action requests.</p><p id="p-0073" num="0072"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a block diagram that illustrates policy enforcement according to some embodiment. The policy manager <b>122</b> receives policy configuration <b>210</b>. The received policy configuration <b>210</b> can be received from local configuration (e.g., through an API, command line interface (CLI), etc.) or received remotely. The policy configuration <b>210</b> may be an active security policy, a virtual network policy, a hardware or firmware policy, or other policy that affects the operation of the virtualized system. The policy configuration <b>210</b> may be a policy that is applicable to each guest OS or guest application, or may be specific to one or more virtual machines, guest operating systems, guest applications, and/or guest processes. The policy configuration <b>210</b> may specify the virtual machine, guest operating system, guest application, and/or guest process for which the policy is applicable. The policy manager <b>122</b> determines where to install the policy in question.</p><p id="p-0074" num="0073">In some embodiments, the policy manager <b>122</b> pushes a new or updated policy to the determined policy enforcer by sending an update policy action to that policy enforcer. The policy manager <b>122</b> can also revoke a policy associated with a specific policy enforcer by sending an update policy action to that policy enforcer. As represented in <figref idref="DRAWINGS">FIG. <b>2</b></figref>, the policy manager <b>122</b> pushes an event policy <b>215</b> to the active security policy enforcer <b>117</b>A, pushes a network policy/configuration <b>220</b> to the virtual network policy enforcer <b>124</b>, and pushes a hardware and/or firmware policy <b>224</b> to the hardware and firmware policy enforcer <b>134</b>. These policies include the action requested (e.g., to install or update a policy) and may include one or more parameters to specify how to execute the action (e.g., what process for which the policy is applicable, what guest operating system or guest application for which the policy is applicable, etc.).</p><p id="p-0075" num="0074">The policy enforcers receive and install the policies. For instance, after receiving the network policy/configuration <b>220</b> from the policy manager <b>122</b>, the virtual network policy enforcer <b>124</b> installs the network configuration <b>222</b> to the virtual switch <b>126</b>. The configuration may be for configuring VLANs, assigning virtual Ethernet devices, creating/updating allow/deny lists for source/destination ports, creating/updating allow/deny lists for source/destination IP addresses, creating/updating allow/deny lists for protocol(s), creating/updating allow/deny lists for certain port numbers, rate limiting from any port, and/or disconnecting any port.</p><p id="p-0076" num="0075">In the case of the hardware and firmware policy enforcer <b>134</b>, after receiving the hardware and/or firmware policy/configuration <b>224</b>, the hardware and firmware policy enforcer <b>134</b> installs the firmware configuration <b>226</b> to the firmware <b>178</b> and installs the hardware configuration <b>228</b> to the hardware <b>180</b>. An example firmware configuration may be used for updating or enabling a firmware secure boot configuration. By way of example, a hardware policy may cause a hardware device to be unavailable to a particular guest operating system or guest application.</p><p id="p-0077" num="0076">In the case of the active security policy enforcer <b>117</b>A, the installed policy may take the form of &#x3c;EVENT&#x3e;, [&#x3c;ARG[0]&#x3e;, . . . ], do [&#x3c;ACTION[0]&#x3e;, . . . ]. The active security policy enforcer <b>117</b>A determines how to monitor the system to determine if the arguments of the event are met. For instance, if the active security policy includes determining whether a specific file was accessed by a particular process, the active security policy enforcer <b>117</b>A may use the VMI <b>116</b>A to introspect the kernel to determine if the specific file has been accessed. The active security policy enforcer <b>117</b>A sends an introspection command <b>225</b> through the VMI <b>116</b>A to the VMM <b>115</b>A to introspect the guest. The VMM <b>115</b>A in turn programs the hardware. For instance, the VMM <b>115</b>A programs the hardware to trap certain events. The VMM <b>115</b>A sends an introspection response <b>230</b> to the active security policy enforcer <b>117</b>A through the VMI <b>116</b>A. The introspection response <b>230</b> (sometimes referred to as a callback) may report that the event has occurred. The active security policy enforcer <b>117</b>A receives the reporting of the event and determines whether the policy event received from the policy manager <b>122</b> has been met. If so, the active security policy enforcer <b>117</b>A transmits the event message <b>235</b> to the policy manager <b>122</b>.</p><p id="p-0078" num="0077">Based on the event message, the policy manager <b>122</b> determines whether a policy has been violated and if so, what action(s) to take. The policy manager <b>122</b> may transmit action requests to policy enforcers, such as after an event has been detected in the system. For example, the action request <b>240</b> may be sent to the active security policy enforcer <b>117</b>A, and the action request <b>245</b> may be sent to the virtual network policy enforcer <b>124</b>. The action request is a synchronous request and includes the action requested and may include one or more parameters to specify how to execute the action. For example, a Kill Task action may include a process identifier (pid) parameter that specifies which task to terminate. Depending on the particular action, action requests can be sent to policy enforcers (e.g., ASPE, virtual network policy enforcer, hardware and firmware policy enforcer) or be carried out by the policy manager <b>122</b> itself. For instance, a log event action request may be performed by the policy manager <b>122</b> itself. Policy enforcers accept action requests and perform the requested actions.</p><p id="p-0079" num="0078"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a flow diagram that illustrates exemplary operations for enforcing a policy according to an embodiment. The operations of <figref idref="DRAWINGS">FIG. <b>3</b></figref> are described with the exemplary embodiment of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. However, the operations of <figref idref="DRAWINGS">FIG. <b>3</b></figref> can be performed by embodiments different from that of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, and the embodiment of <figref idref="DRAWINGS">FIG. <b>1</b></figref> can perform operations different from the operations of <figref idref="DRAWINGS">FIG. <b>3</b></figref>.</p><p id="p-0080" num="0079">At operation <b>310</b>, the policy manager <b>122</b> receives policy configuration for an active security policy. The received configuration may be received from a user or administrator of the computing device <b>100</b>, and the received configuration may be received locally or remotely through the management service <b>121</b>. The received configuration may also be received dynamically as part of an updated policy through the management service <b>121</b>. The received policy configuration may specify which guest the policy is for. The received policy configuration may define the name of the event (if the arguments are satisfied), a set of one or more arguments that are used to determine whether the event occurs, and a set of one or more actions that are taken if the event occurs.</p><p id="p-0081" num="0080">Next, at operation <b>315</b>, the policy manager <b>122</b> transmits a policy corresponding to the configuration to an active security policy enforcer <b>117</b> coupled with a VMM <b>115</b> that uses VMI <b>116</b>. As described above, if there are multiple active security policy enforcers, the policy configuration may specify which active security policy enforcer the policy is for. In some embodiments, the policy is transmitted as an action request to the active security policy enforcer <b>117</b>.</p><p id="p-0082" num="0081">The active security policy enforcer <b>117</b> that receives the policy installs the policy. At operation <b>320</b>, the active security policy enforcer <b>117</b> causes the corresponding VMI <b>116</b> to monitor the hardware <b>180</b>. For example, a policy may be enforced that says that a particular process cannot be run. The VMI <b>116</b> may cause the VMM <b>115</b> to set a breakpoint that is triggered when that particular process is attempted to be executed and to generate and send an event back to the VMI <b>116</b>.</p><p id="p-0083" num="0082">Next, at operation <b>325</b>, the active security policy enforcer <b>117</b> determines whether the policy in question has been triggered (e.g., whether the policy has been violated). As described above, there may be multiple arguments that must be satisfied before the policy enforcement is triggered. If the policy enforcement is triggered, then at operation <b>330</b> the active security policy enforcer <b>117</b> performs the one or more actions specified in the event policy. If the action is to report the event, the reporting of the event is sent to the policy manager <b>122</b>. Other actions may be to kill a process, stop an action, send an alert, etc.</p><p id="p-0084" num="0083">If one of the actions is to report the event, then at operation <b>335</b>, the policy manager <b>122</b> receives the reporting of the event from the active security policy enforcer <b>117</b>. Next, at operation <b>340</b>, the policy manager <b>122</b> performs one or more actions as specified in the policy. The one or more actions may include logging the violation of the policy, blocking the action, removing the offending process, guest operating system, and/or virtual machine from the network, killing the offending process, guest operating system, and/or virtual machine, etc.</p><p id="p-0085" num="0084">As an exemplary policy, a register protection policy may be enforced by the virtualized system. The register protection policy may be created to protect CPU register(s) in one or more ways. For instance, a policy may be created that specifies the number of times a CPU register may be written. As another example, a policy may be created that specifies the value(s) a CPU register may have. As another example, a policy may be created that specifies (through the application of a bitmask) which bits of the CPU register the previous two policies should affect.</p><p id="p-0086" num="0085">In an embodiment, upon the start of the policy manager <b>122</b> or after the policy configuration is received by the policy manager <b>122</b>, the policy manager <b>122</b> pushes a policy to a particular one of the active security policy enforcers <b>117</b>A-<b>117</b>N for which the policy is to apply. The decision on what guest operating system or application for which the policy is to apply may depend on the configuration of the computing device <b>100</b>. The policy may specify the number of times a CPU register may be written, the values a CPU register may have, and/or which bits of the CPU register the previous two policies should affect. For the purposes of this example, the policy manager <b>122</b> pushes the register protection policy to the active security policy enforcer <b>117</b>A.</p><p id="p-0087" num="0086">The active security policy enforcer <b>117</b>A communicates with the corresponding VMM <b>115</b>A to request that writes to any specified register(s) are trapped to the VMI <b>116</b>A. For instance, the active security policy enforcer <b>117</b>A transmits an introspection command <b>225</b> through the VMI <b>116</b>A to the VMM <b>115</b>A to monitor one or more specified register(s) and trap them to the VMI <b>116</b>A. The VMM <b>115</b>A in turn translates the request to a hardware request. For instance, the VMM <b>115</b>A programs the CPU <b>182</b> to serve those requests. The CPU <b>182</b> causes writes to those specified register(s) to be trapped to the requesting VMM <b>115</b>A. Subsequently, the VMM <b>115</b>A receives these register write traps and then passes these event(s) to the corresponding VMI <b>116</b>A. Upon each event, the active security policy enforcer <b>117</b>A stores the relevant state and determines whether the policy has been violated. For instance, if the policy is a limit on the number of writes to a specified register, the active security policy enforcer <b>117</b>A determines the number of writes to that register. If the policy specifies the possible value(s) that the register may have, the active security policy enforcer <b>117</b>A compares the value of the pending write to the register against the possible values. If the policy has been violated, one or more remedial actions are taken. For instance, the violation may be logged and/or the write may be blocked.</p><p id="p-0088" num="0087"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a flow diagram that illustrates exemplary operations for enforcing register protection according to an embodiment. The operations of <figref idref="DRAWINGS">FIG. <b>4</b></figref> are described with the exemplary embodiment of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. However, the operations of <figref idref="DRAWINGS">FIG. <b>4</b></figref> can be performed by embodiments different from that of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, and the embodiment of <figref idref="DRAWINGS">FIG. <b>1</b></figref> can perform operations different from the operations of <figref idref="DRAWINGS">FIG. <b>4</b></figref>.</p><p id="p-0089" num="0088">At operation <b>410</b>, the policy manager <b>122</b> receives configuration for protecting one or more registers. The received configuration may be received from a user or administrator of the computing device <b>100</b>, and the received configuration may be received locally or remotely through the management service <b>121</b>. The received configuration may specify the number of times a register may be written, the value(s) a register may have, and/or which bits of the register the previous two policies should affect. The received configuration may also specify the guest operating system or guest application for which the policy applies.</p><p id="p-0090" num="0089">Next, at operation <b>415</b>, the policy manager <b>122</b> transmits a policy that corresponds to the configuration to an active security policy enforcer <b>117</b> coupled with a VMM <b>115</b> that uses VMI <b>116</b>. In an embodiment, the policy manager <b>122</b> pushes the policy to that active security policy enforcer <b>117</b> as an action request. Next, at operation <b>420</b>, the receiving active security policy enforcer <b>117</b> requests the VMM <b>115</b> to trap any write(s) to the specified register(s) to the VMI <b>116</b>. Then, at operation <b>425</b>, the VMM <b>115</b> programs the hardware (e.g., the CPU <b>182</b>) to cause a write to the specified register(s) to be trapped to the VMI <b>116</b>. Subsequently, when a write to the specified register(s) is being attempted, a register write trap will occur.</p><p id="p-0091" num="0090">After registering for the write trap, the system continuously monitors for the write trap until the configuration is changed and/or the operating system or virtual machine is shut down. At operation <b>430</b>, if a register write trap is received at the VMI <b>116</b>, then operation moves to operation <b>435</b>. If a register write trap is received, the event is passed to the active security policy enforcer <b>117</b> that determines, at operation <b>435</b>, whether the write violates the policy configuration. For instance, if the policy configuration specified that the value of the register could only be one of a set of values and the value being written is not one of those values, then the policy would be violated. As another example, if the policy configuration specified a number of times the register could be written, the active security policy enforcer <b>117</b> determines whether this write would exceed that specified number, which would then be a violation of the policy. If the write does not violate the policy, then flow moves back to operation <b>430</b>. If the write violates the policy, then operation <b>440</b> is performed where one or more remedial actions are taken. For instance, the violation can be logged and/or the write can be blocked.</p><p id="p-0092" num="0091">As an exemplary policy, a process allow list policy may be enforced by the virtualized system. The process allow list policy may be created to specify which processes are allowed to be run on the system. The process allow list policy may be received from a user or administrator of the computing device <b>100</b>, and the received configuration may be received locally or remotely through the management service <b>121</b>. The received configuration may identify the process(es) that are allowed to run for a particular guest OS. The processes may be identified by their name, or by the complete path of the binary of the process and a secure hash of the target binary.</p><p id="p-0093" num="0092">In an embodiment, upon the start of the policy manager <b>122</b> or after the policy configuration is received by the policy manager <b>122</b>, the policy manager <b>122</b> pushes a policy to a particular one of the active security policy enforcers <b>117</b>A-<b>117</b>N for which the process allow list is to apply. The decision on what guest operating system or application for which the policy is to apply may depend on the configuration of the computing device <b>100</b>. For the purposes of this example, the policy manager <b>122</b> pushes a process allow list policy to the active security policy enforcer <b>117</b>A. The policy manager <b>122</b> may also push the profile of the target system to the active security policy enforcer <b>117</b>A, which defines information such as the location of functions within the target kernel. The semantic layer in the VMI <b>116</b> uses the provided profile to identify the kernel running in the guest system. Once identified, VMI <b>116</b> places a VMI breakpoint on the system calls that are responsible for starting new processes. For instance, in the case of Linux, this would be the execve system call. From this point forward, any attempt by the guest to start a new process will be trapped by VMI <b>116</b>. In addition, VMI <b>116</b> will be able to determine the name of the application that should be started, since this information is generally passed as an argument to the process creation system calls that VMI intercepts.</p><p id="p-0094" num="0093">When a new process is created at the guest, VMI <b>116</b> uses the process allow list to determine whether the process is allowed to run or violates the policy. For this purpose, VMI <b>116</b> may compare the name of the application that should be run against the list of processes on the process allow list. If the name of the binary is contained in the allow list, execution will continue normally, and the process will run. Otherwise, if the process is not contained in the process allow list, VMI <b>116</b> takes remedial action(s). For instance, the violation may be logged and/or the process may be blocked from running by shortcutting the system call and directly returning to the caller with a permission denied error code.</p><p id="p-0095" num="0094"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a flow diagram that illustrates exemplary operations for enforcing a process allow list policy according to an embodiment. The operations of <figref idref="DRAWINGS">FIG. <b>5</b></figref> are described with the exemplary embodiment of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. However, the operations of <figref idref="DRAWINGS">FIG. <b>5</b></figref> can be performed by embodiments different from that of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, and the embodiment of <figref idref="DRAWINGS">FIG. <b>1</b></figref> can perform operations different from the operations of <figref idref="DRAWINGS">FIG. <b>5</b></figref>.</p><p id="p-0096" num="0095">At operation <b>510</b>, the policy manager <b>122</b> receives configuration for a process allow list policy. The received configuration may be received from a user or administrator of the computing device <b>100</b>, and the received configuration may be received locally or remotely through the management service <b>121</b>. The received configuration may identify the process(es) on the process allow list. The received configuration may also specify the guest operating system or guest application for which the policy applies.</p><p id="p-0097" num="0096">Next, at operation <b>515</b>, the policy manager <b>122</b> transmits a policy that corresponds to the configuration to an active security policy enforcer <b>117</b> coupled with a VMM <b>115</b> that uses VMI <b>116</b>. In an embodiment, the policy manager <b>122</b> pushes the policy to that active security policy enforcer <b>117</b> as an action request. The policy manager <b>122</b> may also push the profile of the target system that allows the active security policy enforcer <b>117</b> to identify the guest operating system and make the location of its symbols and functions available to the VMI <b>116</b>.</p><p id="p-0098" num="0097">Next, at operation <b>520</b>, the receiving active security policy enforcer <b>117</b> consumes the allow list policy at a process filter. Then, at operation <b>525</b>, the active security policy enforcer <b>117</b> identifies the guest virtual address of the system call(s) that create process(es). For example, the semantic library may be consulted for the location of the process creation function in the guest OS. After locating the guest virtual address of the system call(s) that create processes, at operation <b>530</b>, those virtual address(es) are translated to physical address(es). For instance, the virtual address of the process creation function is translated into a physical address. Next, at operation <b>535</b>, the active security policy enforcer <b>117</b> requests the VMM <b>115</b> to set a breakpoint trap on the translated physical address(es). Next, at operation <b>540</b>, the VMM <b>115</b> instructs the corresponding VM <b>108</b> to set the breakpoints within the guest OS <b>110</b>.</p><p id="p-0099" num="0098">When a breakpoint is hit (e.g., the process creation function in the guest OS <b>110</b> is called), the VMM <b>115</b> generates an event that is sent to the VMI <b>116</b>. In this example, this event is called a process creation breakpoint event. At operation <b>545</b>, the active security policy enforcer <b>117</b> determines whether a process creation breakpoint event has been received at the VMI <b>116</b>. The process may loop at operation <b>545</b> until the policy has been removed from the system or until such an event is received. If a process creation breakpoint event has been received, then at operation <b>550</b> the active security policy enforcer <b>117</b> parses the function arguments of the process creation system calls to extract the name of the process that is about to run. Next, at operation <b>555</b>, the active security policy enforcer <b>117</b> determines whether the process being launched is on the process allow list. For instance, the active security policy enforcer <b>117</b> compares the name of the process that is about to run against the allow list. If the process that is being launched is on the process allow list, then the process will be allowed to run at operation <b>565</b>. If the process that is being launched is not on the process allow list, then one or more remediation steps are taken at operation <b>560</b>. For example, the violation may be logged and/or the process creation call may be blocked (e.g., a permission denied error code may be returned to the caller).</p><p id="p-0100" num="0099">Although <figref idref="DRAWINGS">FIG. <b>5</b></figref> described the use of a process allow list, a process deny list policy can also be used. In such a case, operations like <figref idref="DRAWINGS">FIG. <b>5</b></figref> are performed with the exception that instead of checking whether the process being launched is on the allow list, a determination is made whether the process being launched is on the deny list. If the process is on the deny list, then remediation steps are taken. If the process is not on the deny list, then the process is allowed to run.</p><p id="p-0101" num="0100">Thus, process allow list policies and/or process deny list policies can be enforced in the virtualization stack, thus isolating it from attack. These embodiments can be used for any unmodified guest OS. Unlike conventional solutions that provide little to no configuration options and instead try to automatically identify malicious or benign binaries that lead to false positives and false negatives, embodiments described herein allow a user or administrator of the system to have complete control over which processes will be blocked and which will be able to run (no false positives and no false negatives). This allows for customization for the environment of the user or administrator.</p><p id="p-0102" num="0101">As another exemplary policy, a driver allow list policy may be enforced by the virtualized system. The driver allow list policy may be created to specify which drivers are allowed to be loaded on the system. The driver allow list policy may be received from a user or administrator of the computing device <b>100</b>, and the received configuration may be received locally or remotely through the management service <b>121</b>. The received configuration may identify the driver(es) that are allowed to be loaded for a particular guest OS. The drivers may be identified by their name, or by the complete path of the driver and a secure hash of the driver.</p><p id="p-0103" num="0102">In an embodiment, upon the start of the policy manager <b>122</b> or after the policy configuration is received by the policy manager <b>122</b>, the policy manager <b>122</b> pushes a policy to a particular one of the active security policy enforcers <b>117</b>A-<b>117</b>N for which the driver allow list is to apply. The decision on what guest operating system or application for which the policy is to apply may depend on the configuration of the computing device <b>100</b>. For the purposes of this example, the policy manager <b>122</b> pushes a driver allow list policy to the active security policy enforcer <b>117</b>. The policy manager <b>122</b> may also push the profile of the target system to the active security policy enforcer <b>117</b>, which defines information such as the location of functions within the target kernel. The semantic layer in the VMI <b>116</b> uses the provided profile to identify the kernel running in the guest system. Once identified, VMI <b>116</b> places a VMI breakpoint on the system calls that are responsible for loading new drivers. For instance, in the case of Linux, this would be the init_module system call. From this point forward, any attempt by the guest to load a new driver will be trapped by VMI <b>116</b>. In addition, VMI <b>116</b> will be able to determine the name of the driver that should be loaded, since this information is generally passed as an argument to the driver load system calls that VMI <b>116</b> intercepts.</p><p id="p-0104" num="0103">When a new driver is attempted to be loaded at the guest, VMI <b>116</b> uses the driver allow list to determine whether the driver is allowed to load or violates the policy. For this purpose, VMI <b>116</b> may compare the name of the driver that should be loaded against the list of drivers on the drivers allow list. If the name of the driver is contained in the allow list, execution will continue normally, and the driver will be loaded. Otherwise, if the driver is not contained in the driver allow list, VMI <b>116</b> takes remedial action(s). For instance, the violation may be logged and/or the driver may be blocked from running by shortcutting the system call and directly returning to the caller with a permission denied error code.</p><p id="p-0105" num="0104"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a flow diagram that illustrates exemplary operations for enforcing a driver allow list policy according to an embodiment. The operations of <figref idref="DRAWINGS">FIG. <b>6</b></figref> are described with the exemplary embodiment of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. However, the operations of <figref idref="DRAWINGS">FIG. <b>6</b></figref> can be performed by embodiments different from that of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, and the embodiment of <figref idref="DRAWINGS">FIG. <b>1</b></figref> can perform operations different from the operations of <figref idref="DRAWINGS">FIG. <b>6</b></figref>.</p><p id="p-0106" num="0105">At operation <b>610</b>, the policy manager <b>122</b> receives configuration for a driver allow list policy. The received configuration may be received from a user or administrator of the computing device <b>100</b>, and the received configuration may be received locally or remotely through the management service <b>121</b>. The received configuration may identify the driver(s) on the driver allow list. The received configuration may also specify the guest operating system or guest application for which the policy applies.</p><p id="p-0107" num="0106">Next, at operation <b>615</b>, the policy manager <b>122</b> transmits a policy that corresponds to the configuration to an active security policy enforcer <b>117</b> coupled with a VMM <b>115</b> that uses VMI <b>116</b>. In an embodiment, the policy manager <b>122</b> pushes the policy to that active security policy enforcer <b>117</b> as an action request. The policy manager <b>122</b> may also push the profile of the target system that allows the active security policy enforcer <b>117</b> to identify the guest operating system and make the location of its symbols and functions available to the VMI <b>116</b>.</p><p id="p-0108" num="0107">Next, at operation <b>620</b>, the receiving active security policy enforcer <b>117</b> consumes the allow list policy at a driver filter. Then, at operation <b>625</b>, the active security policy enforcer <b>117</b> identifies the guest virtual address of the system call(s) that load drivers. For example, the semantic library may be consulted for the location of the driver load system calls (e.g., init_module system call). After locating the guest virtual address of the system call(s) that load drivers, at operation <b>630</b>, those virtual address(es) are translated to physical address(es). For instance, the virtual address of the driver loading system call is translated into a physical address. Next, at operation <b>635</b>, the active security policy enforcer <b>117</b> requests the VMM <b>115</b> to set a breakpoint trap on the translated physical address(es). Next, at operation <b>640</b>, the VMM <b>115</b> instructs the corresponding VM <b>108</b> to set the breakpoints within the guest OS <b>110</b>.</p><p id="p-0109" num="0108">When a breakpoint is hit (e.g., the driver loading system call in the guest OS <b>110</b> is called), the VMM <b>115</b> generates an event that is sent to the VMI <b>116</b>. In this example, this event is called a driver load breakpoint event. At operation <b>645</b>, the active security policy enforcer <b>117</b> determines whether a driver load breakpoint event has been received at the VMI <b>116</b>. The process may loop at operation <b>645</b> until the policy has been removed from the system or until such an event is received. If a driver load breakpoint event has been received, then at operation <b>650</b> the active security policy enforcer <b>117</b> parses the function arguments of the driver loading system calls to extract the name of the driver that is to be loaded. Next, at operation <b>655</b>, the active security policy enforcer <b>117</b> determines whether the driver that is to be loaded is on the driver allow list. For instance, the active security policy enforcer <b>117</b> compares the name of the driver that is to be loaded against the allow list. If the driver that is to be loaded is on the driver allow list, then the driver will be allowed to load at operation <b>665</b>. If the driver that is to be loaded is not on the driver allow list, then one or more remediation steps are taken at operation <b>660</b>. For example, the violation may be logged and/or the driver load system call may be blocked (e.g., a permission denied error code may be returned to the caller).</p><p id="p-0110" num="0109">Although <figref idref="DRAWINGS">FIG. <b>6</b></figref> described the use of a driver allow list, a driver deny list policy can also be used. In such a case, operations like <figref idref="DRAWINGS">FIG. <b>6</b></figref> are performed with the exception that instead of checking whether the driver that is to be loaded is on the allow list, a determination is made whether the driver to be loaded is on the deny list. If that driver is on the deny list, then remediation steps are taken. If the driver is not on the deny list, then the driver is allowed to load.</p><p id="p-0111" num="0110">Thus, driver allow list policies and/or driver deny list policies can be enforced in the virtualization stack, thus isolating it from attack. These embodiments can be used for any unmodified guest OS. Unlike conventional solutions that provide little to no configuration options and instead rely on certificates to determine whether a driver is trustworthy, embodiments described herein allow a user or administrator of the system to have complete control over which drivers will be blocked and which will be able to load. This allows for customization for the environment of the user or administrator.</p><p id="p-0112" num="0111">As another exemplary policy, a data structure integrity policy may be enforced by the virtualized system. The data structure integrity policy may be created to specify which in-guest data structure(s) are to be integrity protected, with or without the assistance of the virtual machine. The data structure integrity policy may be received from a user or administrator of the computing device <b>100</b>, and the received configuration may be received locally or remotely through the management service <b>121</b>. The received configuration may identify the data structure(s) that are to be integrity protected. The configuration may specify the memory access permissions to be enforced. The configuration may also specify the action that should be taken in case of a policy violation.</p><p id="p-0113" num="0112">In an embodiment, upon the start of the policy manager <b>122</b> or after the policy configuration is received by the policy manager <b>122</b>, the policy manager <b>122</b> pushes a policy to a particular one of the active security policy enforcers <b>117</b>A-<b>117</b>N for which the data structure integrity policy is to apply. The decision on what guest operating system or application for which the policy is to apply may depend on the configuration of the computing device <b>100</b>. For the purposes of this example, the policy manager <b>122</b> pushes a data structure integrity policy to the active security policy enforcer <b>117</b>. The policy manager <b>122</b> may also push the profile of the target system to the active security policy enforcer <b>117</b>, which defines information such as the location (in the guest virtual memory) of the given data structures. The semantic layer in the VMI <b>116</b> uses the provided profile to identify the guest operating system and the guest virtual addresses of the identified data structures for which integrity is to be protected.</p><p id="p-0114" num="0113">By leveraging VMM, the active security policy enforcer <b>117</b> can use VMI <b>116</b> to configure the provided memory access permissions in the second level address translation tables to enforce unauthorized accesses to the particular data structure. Each time the guest violates the policy, a memory access violation event is received and the active security policy enforcer <b>117</b> takes one or more actions according to the configuration. For instance, the violation may be logged (the memory permission may be at least temporarily granted and the instruction that generated the memory violation may be single-stepped) and execution continues, or the violation may be logged and the process terminated.</p><p id="p-0115" num="0114"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a flow diagram that illustrates exemplary operations for enforcing a data structure integrity policy according to an embodiment. The operations of <figref idref="DRAWINGS">FIG. <b>7</b></figref> are described with the exemplary embodiment of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. However, the operations of <figref idref="DRAWINGS">FIG. <b>7</b></figref> can be performed by embodiments different from that of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, and the embodiment of <figref idref="DRAWINGS">FIG. <b>1</b></figref> can perform operations different from the operations of <figref idref="DRAWINGS">FIG. <b>7</b></figref>.</p><p id="p-0116" num="0115">At operation <b>710</b>, the policy manager <b>122</b> receives configuration for a data structure integrity policy. The received configuration may be received from a user or administrator of the computing device <b>100</b>, and the received configuration may be received locally or remotely through the management service <b>121</b>. The received configuration may identify the data structure(s) to integrity protect. The configuration may specify the memory access permissions to be enforced. The configuration may also specify the action that should be taken in case of a policy violation. The received configuration may also specify the guest operating system or guest application for which the policy applies.</p><p id="p-0117" num="0116">Next, at operation <b>715</b>, the policy manager <b>122</b> transmits a policy that corresponds to the configuration to an active security policy enforcer <b>117</b> coupled with a VMM <b>115</b> that uses VMI <b>116</b>. In an embodiment, the policy manager <b>122</b> pushes the policy to that active security policy enforcer <b>117</b> as an action request. The policy manager <b>122</b> may also push the profile of the target system that allows the active security policy enforcer <b>117</b> to identify the guest operating system to the VMI <b>116</b>.</p><p id="p-0118" num="0117">Next, at operation <b>720</b>, the receiving active security policy enforcer <b>117</b> consumes the data structure integrity policy at a data integrity monitor. Then, at operation <b>725</b>, the active security policy enforcer <b>117</b> determines the guest virtual address(es) of the location(s) of the data structure(s) identified in the data structure integrity policy. Next, at operation <b>730</b>, those virtual address(es) are translated to physical address(es). Next, at operation <b>735</b>, the active security policy enforcer <b>117</b> requests the VMM <b>115</b> to make pages on which those physical address(es) reside non-writable. Next, at operation <b>740</b>, the VMM <b>115</b> updates the second level address translation tables to make the pages non-writable. The VMI <b>116</b> will be notified each time the guest violates the configured memory access permissions when accessing the identified data structures. Thus, if a memory access violation is received, the VMM <b>115</b> generates an event that is sent to the VMI <b>116</b>. In this example, the event is called a memory access violation event. At operation <b>745</b>, the active security policy enforcer <b>117</b> determines whether a memory access violation event has been received at the VMI <b>116</b>. The process may loop at operation <b>745</b> until the policy has been removed from the system or until such an event is received. If a memory access violation event has been received, then at operation <b>750</b> the active security policy enforcer <b>117</b> determines if the violation is a write to one of the specified data structures. If the violation is not a write to one of the specified data structures, in an embodiment the flow moves back to operation <b>745</b>. If the violation is a write to one of the specified data structures, then one or more remediation steps are taken at operation <b>755</b>. For instance, the violation may be logged (the memory permission may be at least temporarily granted and the instruction that generated the memory violation may be single-stepped) and execution continues, or the violation may be logged and the process terminated.</p><p id="p-0119" num="0118">Thus, data structure integrity can be enforced in the virtualization stack, thus isolating it from attack. These embodiments can be used for any unmodified guest OS. Example data structures that may be protected include the system call table or the interrupt vector table, which can be abused by adversaries to take control over the system.</p><p id="p-0120" num="0119">As another exemplary policy, a code integrity policy may be enforced by the virtualized system. The code integrity policy may be created to protect a set of code regions, such as system call handlers. The policy configuration may specify a list of code functions, the integrity of which is to be protected using virtualization techniques described herein. The code integrity policy may be received from a user or administrator of the computing device <b>100</b>, and the received configuration may be received locally or remotely through the management service <b>121</b>. The received configuration may identify the list of code functions that are to be integrity protected. The configuration may specify the memory access permissions to be enforced. The configuration may also specify the action that should be taken in case of a policy violation.</p><p id="p-0121" num="0120">In an embodiment, upon the start of the policy manager <b>122</b> or after the policy configuration is received by the policy manager, the policy manager <b>122</b> pushes a policy to a particular one of the active security policy enforcers <b>117</b>A-<b>117</b>N for which the code integrity policy is to apply. The decision on what guest operating system or application for which the policy is to apply may depend on the configuration of the computing device <b>100</b>. For the purposes of this example, the policy manager <b>122</b> pushes a code integrity policy to the active security policy enforcer <b>117</b>. The policy manager <b>122</b> may also push the profile of the target system to the active security policy enforcer <b>117</b>, which defines information such as the location (in the guest virtual memory) of the code regions. The semantic layer in the VMI <b>116</b> uses the provided profile to identify the guest operating system and the guest virtual addresses of the identified code regions for which integrity is to be protected.</p><p id="p-0122" num="0121">By leveraging VMM, the active security policy enforcer <b>117</b> can use VMI <b>116</b> to configure the provided memory access permissions in the second level address translation tables to enforce unauthorized accesses to the particular code. Each time the guest violates the policy, a memory access violation event is received and the active security policy enforcer <b>117</b> takes one or more actions according to the configuration. For instance, the violation may be logged (the memory permission may be at least temporarily granted and the instruction that generated the memory violation may be single-stepped) and execution continues, or the violation may be logged and the process terminated.</p><p id="p-0123" num="0122"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a flow diagram that illustrates exemplary operations for enforcing code integrity policy according to an embodiment. The operations of <figref idref="DRAWINGS">FIG. <b>8</b></figref> are described with the exemplary embodiment of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. However, the operations of <figref idref="DRAWINGS">FIG. <b>8</b></figref> can be performed by embodiments different from that of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, and the embodiment of <figref idref="DRAWINGS">FIG. <b>1</b></figref> can perform operations different from the operations of <figref idref="DRAWINGS">FIG. <b>8</b></figref>.</p><p id="p-0124" num="0123">At operation <b>810</b>, the policy manager <b>122</b> receives configuration for a code integrity policy. The received configuration may be received from a user or administrator of the computing device <b>100</b>, and the received configuration may be received locally or remotely through the management service <b>121</b>. The received configuration may identify a list of code functions to integrity protect. The configuration may specify the memory access permissions to be enforced. The configuration may also specify the action that should be taken in case of a policy violation. The received configuration may also specify the guest operating system or guest application for which the policy applies.</p><p id="p-0125" num="0124">Next, at operation <b>815</b>, the policy manager <b>122</b> transmits a policy that corresponds to the configuration to an active security policy enforcer <b>117</b> coupled with a VMM <b>115</b> that uses VMI <b>116</b>. In an embodiment, the policy manager <b>122</b> pushes the policy to that active security policy enforcer <b>117</b> as an action request. The policy manager <b>122</b> may also push the profile of the target system that allows the active security policy enforcer <b>117</b> to identify the guest operating system to the VMI <b>116</b>.</p><p id="p-0126" num="0125">Next, at operation <b>820</b>, the receiving active security policy enforcer <b>117</b> consumes the code integrity policy at a data integrity monitor. Then, at operation <b>825</b>, the active security policy enforcer <b>117</b> determines the guest virtual address(es) of the location(s) of the code region(s) identified in the code integrity policy. Next, at operation <b>830</b>, those virtual address(es) are translated to physical address(es). Next, at operation <b>835</b>, the active security policy enforcer <b>117</b> requests the VMM <b>115</b> to make pages on which those physical address(es) reside non-writable. Next, at operation <b>840</b>, the VMM <b>115</b> updates the second level address translation tables to make the pages non-writable. The VMI <b>116</b> will be notified each time the guest violates the configured memory access permissions when accessing the identified code regions. Thus, if a memory access violation is received, the VMM <b>115</b> generates an event that is sent to the VMI <b>116</b>. In this example, the event is called a memory access violation event. At operation <b>845</b>, the active security policy enforcer <b>117</b> determines whether a memory access violation event has been received at the VMI <b>116</b>. The process may loop at operation <b>845</b> until the policy has been removed from the system or until such an event is received. If a memory access violation event has been received, then at operation <b>850</b> the active security policy enforcer <b>117</b> determines if the violation is a write to one of the specified code regions. If it is, then one or more remediation steps are taken at operation <b>855</b>. For instance, the violation may be logged (the memory permission may be at least temporarily granted and the instruction that generated the memory violation may be single-stepped) and execution continues, or the violation may be logged and the process terminated. Thus, code integrity can be enforced in the virtualization stack, thus isolating it from attack. These embodiments can be used for any unmodified guest OS. If the violation is not a write to one of the specified code regions, then in an embodiment the flow moves back to operation <b>845</b>.</p><p id="p-0127" num="0126">The exemplary architecture shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref> can be used in different hardware architectures including ARM architectures and x86 architectures. For example, <figref idref="DRAWINGS">FIG. <b>9</b></figref> is a block diagram that shows an exemplary implementation for the formally verified trusted computing base as shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref> for an ARM architecture, and <figref idref="DRAWINGS">FIG. <b>10</b></figref> is a block diagram that shows an exemplary implementation for the formally verified trusted computing base as shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref> for an x86 architecture.</p><p id="p-0128" num="0127">The exemplary implementation shown in <figref idref="DRAWINGS">FIG. <b>9</b></figref> is for an ARM architecture. The computing device <b>900</b> is a computing device like the computing device <b>100</b> and has an ARM architecture (e.g., ARMv8). ARM defines different levels of privilege as exception levels. Each exception level is numbered, and the higher levels of privilege have higher numbers. Exception level 0 (EL0) is known as the application privilege level. All the hypervisor components except for the microkernel <b>160</b> are in the exception level 0. The applications <b>910</b>A-<b>910</b>N executing within the virtual machines <b>908</b>A-<b>908</b>N are also in exception level 0. The OS kernels <b>911</b>A-<b>911</b>N executing within the virtual machines 908A-908N are in exception level 1 (EL1), which is the rich OS exception level. The formally verified microkernel <b>160</b> is in exception level 2 (EL2), which is the hypervisor privilege level. The firmware <b>178</b> and the hardware <b>180</b> are at exception level 3 (EL3), which is the firmware privilege level and the highest privilege level. The trusted execution environment (TEE) <b>915</b> is at the exception level 0 and 1 for the trusted services and kernel respectively.</p><p id="p-0129" num="0128">The exemplary implementation shown in <figref idref="DRAWINGS">FIG. <b>10</b></figref> is for an x86 architecture. The computing device <b>1000</b> is a computing device like the computing device <b>100</b> and has an x86 architecture. The x86 architecture defines four protection rings but most modern architectures use two privilege levels, rings 0 and 3 and may run in guest or host mode. For instance, the guest OS kernels <b>1011</b>A-<b>1011</b>N running in the virtual machines <b>1008</b>A-<b>1008</b>N respectively run in the most privileged level (guest kernel mode, ring 0), and the guest applications <b>1010</b>A-<b>1010</b>N run in a lesser privileged level (guest user mode, ring 3). The formally verified microkernel <b>160</b> runs in the most privileged level of the host (host kernel mode, ring 0), and the other components of the hypervisor run in a lesser privileged level (host user mode, ring 3).</p><p id="p-0130" num="0129">Multiple components of the virtualization layer are formally verified components in some embodiments. Formal verification proves (or disproves) the correctness of intended code using formal methods of mathematics. Formal verification guarantees that a system is free of programming errors. <figref idref="DRAWINGS">FIG. <b>11</b></figref> is a flow chart that illustrates an exemplary method of formal verification that may be used in some embodiments. A model <b>1105</b> of the code <b>1115</b> is created. The model <b>1105</b> is the functional implementation corresponding to the code <b>1115</b>. The specification <b>1110</b> is a formal specification of the properties of the code <b>1115</b> expressed in a mathematical language. The code <b>1115</b> itself may be coded in a way that is architecture to be formally verified. The tools <b>1120</b> may include tools for converting the code <b>1115</b> into file(s) suitable for an interactive theorem prover <b>1135</b>. The properties <b>1130</b> include any security properties or any theorems used for proving the code <b>1115</b>. If the proof <b>1125</b> fails at block <b>1140</b>, then the code <b>1115</b> is not formally verified. If the proof is verified, then the code <b>1115</b> is deemed to be formally verified <b>1145</b>.</p><p id="p-0131" num="0130"><figref idref="DRAWINGS">FIG. <b>12</b></figref> illustrates an example use of the formally verified trusted computing base with active security and policy enforcement, according to an embodiment. The computing device <b>1200</b> is like the computing device <b>100</b>. However, in the example shown in <figref idref="DRAWINGS">FIG. <b>12</b></figref>, there are two virtual machines <b>1208</b>A and <b>1208</b>B that are running, where the virtual machine <b>1208</b>A has an unmodified guest operating system and applications <b>1210</b>A, and the virtual machine <b>1208</b>B has a piece of software installed to assist in the active security policy enforcement (the active security policy enforcer <b>1217</b>B). Thus, the policy enforcement including the active security policy enforcement that impacts the guest operating system and applications <b>1210</b>A are performed by the virtualization system like as described with respect to <figref idref="DRAWINGS">FIG. <b>1</b></figref>. However, the active security policy enforcement for the guest operating system and applications <b>1210</b>B are performed in coordination with the guest. In such a case, memory encryption may be in use for the guest operating system and applications <b>1210</b>B such that outside of the guest there is no visibility of the memory. In an embodiment, the active security policy enforcer <b>1217</b>B is an image of the active security policy enforcer <b>117</b>B. The active security policy enforcer <b>117</b>B controls the active security policy enforcer <b>1217</b>B. For instance, the active security policy enforcer <b>117</b>B communicates active security policies to the active security policy enforcer <b>1217</b>B. The active security policy enforcer <b>1217</b>B may also perform VMI and provide at least read or write to the main memory of the guest.</p><p id="p-0132" num="0131"><figref idref="DRAWINGS">FIG. <b>13</b></figref> illustrates an example use of the formally verified trusted computing base with active security and policy enforcement, according to an embodiment. The computing device <b>1300</b> is like the computing device <b>100</b>. However, in the example shown in <figref idref="DRAWINGS">FIG. <b>13</b></figref>, the virtual machine <b>1308</b> includes an unmodified OS <b>1310</b> running in guest kernel mode and a notification agent <b>1312</b> that runs in the guest user mode space. The notification agent <b>1312</b> is used to notify a user of an event that has been detected by the virtualization system. The policy manager <b>122</b> may communicate with the notification agent <b>1312</b>. The event may be those in which the user has configured some interest in receiving and/or that an administrator of the system has configured. For instance, a popup may occur when a violation of a policy has occurred such as a detection of malware. Although <figref idref="DRAWINGS">FIG. <b>13</b></figref> illustrates a single virtual machine, there may be notification agents running on multiple virtual machines at the same time.</p><p id="p-0133" num="0132">The techniques shown in the figures can be implemented using code and data stored and executed on one or more computing devices. Such computing devices store and communicate (internally and/or with other electronic devices over a network) code and data using computer-readable media, such as non-transitory computer-readable storage media (e.g., magnetic disks; optical disks; random access memory; read only memory; flash memory devices; phase-change memory) and transitory computer-readable communication media (e.g., electrical, optical, acoustical or other form of propagated signals&#x2014;such as carrier waves, infrared signals, digital signals). In addition, such computing devices typically include a set of one or more hardware processors coupled to one or more other components, such as one or more I/O devices (e.g., storage devices (non-transitory machine-readable storage media), a keyboard, a touchscreen, a display, and/or network connections). The coupling of the set of processors and other components is typically through one or more busses and bridges (also termed as bus controllers). Thus, the storage device of a given computing device typically stores code and/or data for execution on the set of one or more processors of that computing device.</p><p id="p-0134" num="0133">In the preceding description, numerous specific details are set forth to provide a more thorough understanding of the present invention. It will be appreciated, however, by one skilled in the art that the invention may be practiced without such specific details. In other instances, control structures, gate level circuits and full software instruction sequences have not been shown in detail in order not to obscure the invention. Those of ordinary skill in the art, with the included descriptions, will be able to implement appropriate functionality without undue experimentation.</p><p id="p-0135" num="0134">References in the specification to &#x201c;one embodiment,&#x201d; &#x201c;an embodiment,&#x201d; &#x201c;an example embodiment,&#x201d; etc., indicate that the embodiment described may include a particular feature, structure, or characteristic, but every embodiment may not necessarily include the feature, structure, or characteristic. Moreover, such phrases are not necessarily referring to the same embodiment. Further, when a particular feature, structure, or characteristic is described in connection with an embodiment, it is submitted that it is within the knowledge of one skilled in the art to affect such feature, structure, or characteristic in connection with other embodiments whether explicitly described.</p><p id="p-0136" num="0135">Bracketed text and blocks with dashed borders (e.g., large dashes, small dashes, dot-dash, and dots) may be used herein to illustrate optional operations that add additional features to embodiments of the invention. However, such notation should not be taken to mean that these are the only options or optional operations, and/or that blocks with solid borders are not optional in certain embodiments of the invention.</p><p id="p-0137" num="0136">In the preceding description and the claims, the terms &#x201c;coupled&#x201d; and &#x201c;connected,&#x201d; along with their derivatives, may be used. These terms are not intended as synonyms for each other. &#x201c;Coupled&#x201d; is used to indicate that two or more elements, which may or may not be in direct physical or electrical contact with each other, co-operate or interact with each other. &#x201c;Connected&#x201d; is used to indicate the establishment of communication between two or more elements that are coupled with each other.</p><p id="p-0138" num="0137">While the flow diagrams in the figures show a particular order of operations performed by certain embodiments of the invention, such order is exemplary (e.g., alternative embodiments may perform the operations in a different order, combine certain operations, overlap certain operations, etc.).</p><p id="p-0139" num="0138">While the invention has been described in terms of several embodiments, those skilled in the art will recognize that the invention is not limited to the embodiments described, can be practiced with modification and alteration within the spirit and scope of the appended claims. The description is thus to be regarded as illustrative instead of limiting.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A computing device, comprising:<claim-text>a plurality of hardware resources including a set of one or more hardware processors, memory, and storage devices, wherein the storage devices include instructions that when executed by the set of hardware processors, cause the computing device to operate a virtualized system, the virtualized system including:<claim-text>a set of one or more virtual machines (VMs) that execute one or more guest operating systems;</claim-text><claim-text>a formally verified microkernel running in a most privileged level to abstract hardware resources of the computing device;</claim-text><claim-text>a plurality of formally verified hyper-processes including:<claim-text>a set of one or more virtual machine monitors (VMMs) corresponding to the set of one or more VMs respectively, wherein a particular VMM manages interactions between the corresponding VM and physical resources of the computing device;</claim-text><claim-text>a set of one or more active security policy enforcers corresponding to the set of one or more VMMs respectively, wherein each active security policy enforcer uses virtual machine introspection (VMI) for introspection of at least some of the hardware resources including one or more hardware processors, wherein each active security policy enforcer enforces a plurality of policies based at least in part on the introspection;</claim-text><claim-text>a virtual switch coupled with each of the VMMs, wherein the virtual switch is not directly coupled with any of the set of VMs, wherein a virtual network policy enforcer enforces a set of one or more network policies at the virtual switch that affect communication of the one or more guest operating systems.</claim-text></claim-text></claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The computing device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein policies are dynamically received remotely and installed to the set of one or more active security policy enforcers.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The computing device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the plurality of formally verified hyper-processes further includes a policy manager that manages policies for the virtualized system.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The computing device of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the policy manager is configured to receive events from the set of active security policy enforcers, and wherein the policy manager is configured to disconnect network access from one of the guest operating systems upon a particular policy violation.</claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The computing device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the plurality of formally verified hyper-processes further includes a hardware and firmware policy enforcer.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The computing device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein one of the plurality of policies is a process allow policy that indicates a set of one or more processes that are allowed to be executed by a particular one of the one or more guest operating systems.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The computing device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein at least one of the one or more VMs that executes a guest operating system includes a local active security policy enforcer that can interact with encrypted memory used by the guest operating system.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The computing device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein at least one of the one or more VMs includes a notification agent running in guest user mode space, wherein the notification agent is configured to notify a user of a detected event including a violation of policy.</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. A method in a computing device, comprising:<claim-text>executing a formally verified microkernel in a most privileged level to abstract hardware resources of the computing device;</claim-text><claim-text>executing a set of one or more virtual machine monitors (VMMs) as a user-level application in an address space on top of the formally verified microkernel that each support execution of a guest operating system running in a virtual machine (VM), wherein a particular VMM manages interactions between the corresponding VM and hardware resources of the computing device;</claim-text><claim-text>continuously monitoring at least a portion of the hardware resources of the computing device, wherein the continuously monitoring includes performing virtual machine introspection (VMI) on at least the portion of the hardware resources of the computing device outside of the guest operating system;</claim-text><claim-text>determining, from the continuously monitoring, a violation of a policy; and</claim-text><claim-text>responsive to the determination of the violation of policy, taking one or more remedial steps.</claim-text></claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, further comprising:<claim-text>enforcing one or more virtual network policies at a virtual switch for granular control of network communication of the computing device.</claim-text></claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the virtual switch is coupled with the set of one or more virtual machine monitors and is not directly coupled with any VM.</claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the one or more VMMs are formally verified.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the policy is configured by an administrator of the computing device.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the policy is received dynamically from a remote server.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. A non-transitory machine-readable storage medium that provides instructions that, if executed by a processor of a computing device, will cause said processor to carry out the following operations:<claim-text>executing a formally verified microkernel in a most privileged level to abstract hardware resources of the computing device;</claim-text><claim-text>executing a set of one or more virtual machine monitors (VMMs) as a user-level application in an address space on top of the formally verified microkernel that each support execution of a guest operating system running in a virtual machine (VM), wherein a particular VMM manages interactions between the corresponding VM and hardware resources of the computing device;</claim-text><claim-text>continuously monitoring at least a portion of the hardware resources of the computing device, wherein the continuously monitoring includes performing virtual machine introspection (VMI) on at least the portion of the hardware resources of the computing device outside of the guest operating system;</claim-text><claim-text>determining, from the continuously monitoring, a violation of a policy; and</claim-text><claim-text>responsive to the determination of the violation of policy, taking one or more remedial steps.</claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The transitory machine-readable storage medium of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the operations further comprise:<claim-text>enforcing one or more virtual network policies at a virtual switch for granular control of network communication of the computing device.</claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The transitory machine-readable storage medium of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the virtual switch is coupled with the set of one or more virtual machine monitors and is not directly coupled with any VM.</claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The transitory machine-readable storage medium of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the VMMs are formally verified.</claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The transitory machine-readable storage medium of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the policy is configured by an administrator of the computing device.</claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The transitory machine-readable storage medium of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the policy is received dynamically from a remote server</claim-text></claim></claims></us-patent-application>