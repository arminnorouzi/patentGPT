<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004543A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004543</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17930214</doc-number><date>20220907</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>22</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>2455</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>182</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>28</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>16</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>2282</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>24554</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>182</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>28</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>162</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>24552</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">FLAT OBJECT STORAGE NAMESPACE IN AN OBJECT STORAGE SYSTEM</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>16853980</doc-number><date>20200421</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11442916</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17930214</doc-number></document-id></child-doc></relation></continuation></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>NetApp, Inc.</orgname><address><city>San Jose</city><state>CA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Jernigan, IV</last-name><first-name>Richard Parvin</first-name><address><city>Sewickley</city><state>PA</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Cox</last-name><first-name>Roger Warren</first-name><address><city>Los Altos</city><state>CA</state><country>US</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A system, method, and machine-readable storage medium for maintaining an object storage system data are provided. In some embodiments, an object manager may receive a request to perform an operation on an object. The object storage system includes a first database of a first type and a second database of a second type. The object manager may identify a first record stored in the first database. The first record includes a name marker indicating a range of object names covered by the second database and includes a file handle referencing the second database. The range of object names includes the object name. Additionally, the object manager may identify a second record stored in the second database. The second record includes the object name and includes a file handle referencing the object. The object manager may perform the operation on the object in accordance with the request.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="187.28mm" wi="158.75mm" file="US20230004543A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="247.82mm" wi="193.72mm" file="US20230004543A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="209.97mm" wi="190.25mm" file="US20230004543A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="232.41mm" wi="177.29mm" file="US20230004543A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="230.80mm" wi="205.40mm" file="US20230004543A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="234.78mm" wi="198.37mm" file="US20230004543A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="233.76mm" wi="160.78mm" file="US20230004543A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="246.30mm" wi="182.12mm" file="US20230004543A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="217.09mm" wi="154.52mm" file="US20230004543A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="186.86mm" wi="151.38mm" file="US20230004543A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading><p id="p-0002" num="0001">The present application is a continuation of U.S. patent application Ser. No. 16/853,980, filed on Apr. 21, 2020, the disclosure of which is hereby incorporated herein by reference in its entirety.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">TECHNICAL FIELD</heading><p id="p-0003" num="0002">The present description relates to maintaining an object namespace, and more specifically, to a system, method, and machine-readable storage medium for maintaining objects and their object names in a distributed storage system for cost savings, efficiency, and/or load balancing.</p><heading id="h-0003" level="1">BACKGROUND</heading><p id="p-0004" num="0003">Networks and distributed storage allow data and storage space to be shared between devices located anywhere a connection is available. These implementations may range from a single machine offering a shared drive over a home network to an enterprise-class cloud storage array with multiple copies of data distributed throughout the world. Larger implementations may incorporate Network Attached Storage (NAS) devices, Storage Area Network (SAN) devices, and other configurations of storage elements and controllers to provide data and manage its flow. Storage nodes or servers in storage networks generally store data across multiple data storage devices that together include a data container, which may also be referred to herein as an aggregate. Storage nodes may employ various forms of local data storage devices, such as hard disk drives, solid state drives, flash drives, or tape devices, as well as remote data storage devices, such as cloud storage devices or repositories, for example.</p><p id="p-0005" num="0004">The data storage devices may host one or more data stores or volumes within the aggregates, which are associated with file systems that define an overall logical arrangement of storage space in a storage network. Clients may store content in a distributed storage system. For example, a client may store hundreds, thousands, or millions (or more) of objects in the distributed storage system. Objects may be identified by their names, and the distributed storage system may also store object names of the objects. As the number of objects stored in the distributed storage system continues to grow, it may be difficult to store the objects and their names in an efficient manner. For example, if a single database stores a collection of the object names, all namespace requests may be transmitted to the single database, potentially creating an access bottleneck for these requests. Additionally, the single database may serve as a single point of failure if the system crashes. Current approaches have limitations in their ability for maintaining objects and their object names in a distributed storage system.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0006" num="0005">The present disclosure is best understood from the following detailed description when read with the accompanying figures.</p><p id="p-0007" num="0006"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram illustrating a clustered network environment in accordance with one or more aspects of the present disclosure.</p><p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is an illustrative example of a data storage system in accordance with one or more aspects of the present disclosure.</p><p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a flow diagram of a method of storing an object in an object storage system in accordance with one or more aspects of the present disclosure.</p><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a block diagram illustrating an object storage system that processes a request to store an object in accordance with one or more aspects of the present disclosure.</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is another block diagram illustrating an object storage system that processes a request to store an object in accordance with one or more aspects of the present disclosure.</p><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a flow diagram of a method of splitting a chapter database into two partitioned chapter databases in accordance with one or more aspects of the present disclosure.</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a block diagram illustrating a chapter database split into two partitioned chapter databases in accordance with one or more aspects of the present disclosure.</p><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a flow diagram of a method of merging two peer chapter databases into a single chapter database in accordance with one or more aspects of the present disclosure.</p><p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a flow diagram of a method of performing an operation on an object in accordance with one or more aspects of the present disclosure.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0005" level="1">DETAILED DESCRIPTION</heading><p id="p-0016" num="0015">All examples and illustrative references are non-limiting and should not be used to limit the claims to specific implementations and embodiments described herein and their equivalents. For simplicity, reference numbers may be repeated between various examples. This repetition is for clarity only and does not dictate a relationship between the respective embodiments, unless noted otherwise. Finally, in view of this disclosure, features described in relation to one aspect or embodiment may be applied to other disclosed aspects or embodiments of the disclosure, even though not specifically shown in the drawings or described in the text.</p><p id="p-0017" num="0016">Network attached storage (NAS) protocols (e.g., Network File System (NFS) protocol, Common Internet File System (CIFS) protocol, and the like) organize content in terms of files and directories. A directory may contain both files and subdirectories, which may themselves contain files and subdirectories. Further, a root directory may contain the top level and indicate a NAS namespace. For example, a caller may reach any file by specifying the names of the series of directories (starting at the root) that lead to where the file's own name is kept, and then finally the filename itself leads to the content. Additionally, a caller may rename files and directories&#x2014;essentially rearranging the namespace while leaving the content itself largely unchanged.</p><p id="p-0018" num="0017">Object storage, on the other hand, may implement a different way of organizing its content. For example, an object storage environment typically does not contain directories or files. Instead, the object storage environment may include objects, and each object is given a name which is unique within the entire object namespace or a bucket, which may refer to a discrete container that stores a collection of objects. For example, object names do not contain any sort of implicit hierarchy. In this example, the NAS-familiar character &#x2018;/&#x2019; (if it appears at all) is no different from any other letter or digit.</p><p id="p-0019" num="0018">Customers may store objects in an object storage system and access the objects based on their object names. The object storage system may store hundreds, thousands, millions, or billions of objects and their object names. An object stored in the object storage system may be identified by its object name (rather than by, for example, a directory). A single database may store the collection of object names and reside on one machine. The single database, however, may be a single point of failure and/or a performance bottleneck for accessing objects in the object storage system.</p><p id="p-0020" num="0019">It may be desirable for workloads in the object storage system to be distributed across the cluster. Additionally, it may be desirable for common object-storage protocols to efficiently respond to requests that specify a full object name (e.g., a request &#x201c;Create an object named &#x2018;xyz&#x2019; and put a first set of data in the object,&#x201d; a request &#x201c;Read the data in object &#x2018;abed&#x2019; and provide a response with the read data&#x201d;, and the like). These protocols may expect to be able to iterate the namespace, starting at any filename and proceeding in a predetermined (e.g., alphabetical) order. Additionally, it may be desirable for an object storage system (e.g., for an enterprise-scale product) to manage object counts in the hundreds of billions (or more), maintaining both the objects themselves and their namespace. For example, it may be desirable for the namespace to remain constantly sorted and rapidly accessible for lookup, create, delete, and enumeration operations.</p><p id="p-0021" num="0020">The present disclosure provides techniques for efficiently identifying a location at which a given object's name is stored (if at all) in the object storage system along with its content. As will be discussed further below, a table-of-contents (TOC) database may reference one or more chapter databases, where a collection of the one or more chapter databases serve a lookup workflow for identifying a particular object name out of potentially hundreds, thousands, millions, or billions of object names stored in the object storage system. A top-level TOC database may encode the top levels of a namespace lookup tree, providing a mapping table that demonstrates which chapters are responsible for which portions of the overall namespace. Records included in the TOC database may provide a key (name marker) to value (chapter database identity) mapping.</p><p id="p-0022" num="0021">Hierarchically below the TOC database may be a collection of chapter databases, which may include at least one chapter database (up to millions). The collection of chapter databases may include separate, but related, chapter databases that collectively act as a larger namespace. The collection of chapter databases may enumerate the object names in sorted order. For example, each chapter database covers all object names that are stored within a discrete range of the collective namespace and maps each known object name to a location in the cluster where the corresponding object is stored. The collection of chapter databases may allow efficient storage of object names in a sorted order and maintenance of objects in the object storage system.</p><p id="p-0023" num="0022">Each of the TOC and chapter databases operates with a large amount of independence from its peers. For example, chapter databases may answer create, delete, and enumeration queries typically without stalling to disclose what their peers are processing. In this way, the collective namespace may be stored using a wide array of independent databases stored on multiple volumes, and together they can service an enormous amount of namespace traffic in parallel. Each database may be responsible for its own integrity and its own resiliency in the face of service outages. In some examples, the TOC database may be internally replicated (e.g., identical copies are stored on multiple volumes for redundancy), while the chapter databases are not (for performance), though other configuration choices may be implemented based on different requirements.</p><p id="p-0024" num="0023">Additionally, the collection of chapter databases may be stored on different machines or nodes to avoid having a single point of failure and performance bottleneck when attempting to access the chapter databases. An advantage of distributing the collection of chapter databases on different machines or nodes may provide opportunities to distribute or re-distribute the workload over time. For example, if a chapter database is created, it may be desirable to store the chapter database at an underutilized volume to increase its activity and assist in processing the workload. Accordingly, requests to perform operations on objects may be balanced across the clustered network environment <b>100</b>. The chapter databases may be implicitly and/or continually distributed among a collection of nodes, which can then operate more or less independently for most of the traffic.</p><p id="p-0025" num="0024">Additionally or alternatively, using the TOC database and chapter databases may advantageously provide for breaking up the responsibility for tracking billions of objects into a collection of small chapter databases. Accordingly, rather than funnel each namespace request to a single database, the namespace requests may be distributed across the object storage system.</p><p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram illustrating a clustered network environment <b>100</b> in accordance with one or more aspects of the present disclosure. The clustered network environment <b>100</b> includes data storage systems <b>102</b> and <b>104</b> that are coupled over a cluster fabric <b>106</b>, such as a computing network embodied as a private InfiniBand, Fiber Channel (FC), or Ethernet network facilitating communication between the data storage systems <b>102</b> and <b>104</b> (and one or more modules, components, etc. therein, such as, nodes <b>116</b> and <b>118</b>, for example). For example, the data storage systems <b>102</b> and <b>104</b> may be coupled via an internal switch (e.g., networking switch). The data storage systems <b>102</b> and <b>104</b> may be computing devices that interact with other components via, for example, the cluster fabric <b>106</b>. It will be appreciated that while two data storage systems <b>102</b> and <b>104</b> and nodes <b>116</b> and <b>118</b> are illustrated in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, any suitable number of such components is contemplated.</p><p id="p-0027" num="0026">In an example, nodes <b>116</b>, <b>118</b> include storage controllers (e.g., node <b>116</b> may include a primary or local storage controller, and node <b>118</b> may include a secondary or remote storage controller) that provide client devices, such as host devices <b>108</b> and <b>110</b>, with access to data stored within data storage devices <b>128</b> and <b>130</b>. Similarly, unless specifically provided otherwise herein, the same is true for other modules, elements, features, items, etc. referenced herein and/or illustrated in the accompanying drawings. That is, a particular number of components, modules, elements, features, items, etc. disclosed herein is not meant to be interpreted in a limiting manner.</p><p id="p-0028" num="0027">It will be further appreciated that clustered networks are not limited to any particular geographic areas and can be clustered locally and/or remotely. Thus, in an embodiment, a clustered network can be distributed over a plurality of storage systems and/or nodes located in a plurality of geographic locations; while in an embodiment a clustered network can include data storage systems (e.g., <b>102</b>, <b>104</b>) residing in a same geographic location (e.g., in a single onsite rack of data storage devices).</p><p id="p-0029" num="0028">In the example illustrated in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, one or more host devices <b>108</b>, <b>110</b> which may include, for example, client devices, personal computers (PCs), computing devices used for storage (e.g., storage servers), and other computers or peripheral devices (e.g., printers), are coupled to the respective data storage systems <b>102</b>, <b>104</b> by storage network connections <b>112</b>, <b>114</b>. A network connection <b>112</b>, <b>114</b> may include a local area network (LAN) or wide area network (WAN), for example, that utilizes NAS protocols, such as a CIFS protocol or an NFS protocol to exchange data packets, a Storage Area Network (SAN) protocol, such as Small Computer System Interface (SCSI) or Fiber Channel Protocol (FCP), an object protocol, such as AMAZON S3&#xae;, etc.</p><p id="p-0030" num="0029">The host devices <b>108</b>, <b>110</b> may be general-purpose computers running applications, and may interact with the data storage systems <b>102</b>, <b>104</b> using a client/server model for exchange of information. For example, the host device <b>108</b> may request data from the data storage system <b>102</b>, <b>104</b> (e.g., data on a storage device managed by a network storage control configured to process input/output (I/O) commands issued by the host device for the storage device), and the data storage system <b>102</b>, <b>104</b> may return results of the request to the host device via the storage network connection <b>112</b>, <b>114</b>.</p><p id="p-0031" num="0030">The nodes <b>116</b>, <b>118</b> on clustered data storage systems <b>102</b>, <b>104</b> may include network or host nodes that are interconnected as a cluster to provide data storage and management services, such as to an enterprise having remote locations, cloud storage, etc., for example. Such a node in the clustered network environment <b>100</b> may be a device attached to the network as a connection point, redistribution point, or communication endpoint, for example. A node may send, receive, and/or forward information over a network communications channel, and may include any device that meets any or all of these criteria. An example of a node may be a data storage and management server attached to a network, where the server may include a general purpose computer or a computing device particularly configured to operate as a server in a data storage and management system.</p><p id="p-0032" num="0031">In an example, a first cluster of nodes such as the nodes <b>116</b>, <b>118</b> (e.g., a first set of storage controllers configured to provide access to a first storage aggregate including a first logical grouping of one or more storage devices) may be located on a first storage site. A second cluster of nodes, not illustrated, may be located at a second storage site (e.g., a second set of storage controllers configured to provide access to a second storage aggregate including a second logical grouping of one or more storage devices). The first cluster of nodes and the second cluster of nodes may be configured according to a disaster recovery configuration where a surviving cluster of nodes provides switchover access to storage devices of a disaster cluster of nodes in the event a disaster occurs at a disaster storage site including the disaster cluster of nodes (e.g., the first cluster of nodes provides client devices with switchover data access to storage devices of the second storage aggregate in the event a disaster occurs at the second storage site).</p><p id="p-0033" num="0032">As illustrated in the clustered network environment <b>100</b>, nodes <b>116</b>, <b>118</b> may include various functional components that coordinate to provide a distributed storage architecture for the cluster. For example, the nodes <b>116</b>, <b>118</b> may include network modules <b>120</b>, <b>122</b> and disk modules <b>124</b>, <b>126</b>. The network modules <b>120</b>, <b>122</b> may be configured to allow the nodes <b>116</b>, <b>118</b> (e.g., network storage controllers) to connect with host devices <b>108</b>, <b>110</b> over the storage network connections <b>112</b>, <b>114</b>, for example, allowing the host devices <b>108</b>, <b>110</b> to access data stored in the distributed storage system. Further, the network modules <b>120</b>, <b>122</b> may provide connections with one or more other components through the cluster fabric <b>106</b>. For example, in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the network module <b>120</b> of the node <b>116</b> may access a second data storage device (e.g., data storage device <b>130</b>) by sending a request through the disk module <b>126</b> of the node <b>118</b>.</p><p id="p-0034" num="0033">The network module <b>120</b> and the disk module <b>124</b> may be referred to as being local to each other because each of these components resides in the same node <b>116</b> and/or communications between these components may be transmitted and received without transmitting the communications over a network (e.g., the fabric <b>106</b>). Similarly, the network module <b>122</b> and the disk module <b>126</b> may be referred to as being local to each other because each of these components resides in the same node <b>118</b> and/or communications between these components may be transmitted and received without transmitting the communications over a network (e.g., the fabric <b>106</b>).</p><p id="p-0035" num="0034">Additionally, the network module <b>120</b> and the disk module <b>126</b> may be referred to as being remote from each other because these components reside in different nodes and/or communications between these components are transmitted and received by transmitting the communications over a network (e.g., the fabric <b>106</b>). Similarly, the network module <b>122</b> and the disk module <b>124</b> may be referred to as being remote from each other because these components reside in different nodes and/or communications between these components are transmitted and received by transmitting the communications over a network (e.g., the fabric <b>106</b>).</p><p id="p-0036" num="0035">Disk modules <b>124</b>, <b>126</b> may be configured to connect one or more data storage devices <b>128</b>, <b>130</b>, such as disks or arrays of disks, flash memory, or some other form of data storage, to the nodes <b>116</b>, <b>118</b>. The nodes <b>116</b>, <b>118</b> may be interconnected by the cluster fabric <b>106</b>, for example, allowing respective nodes in the cluster to access data on data storage devices <b>128</b>, <b>130</b> connected to different nodes in the cluster. Disk modules <b>124</b>, <b>126</b> may communicate with the data storage devices <b>128</b>, <b>130</b> according to the SAN protocol, such as SCSI or FCP, for example. As seen from an operating system on nodes <b>116</b>, <b>118</b>, the data storage devices <b>128</b>, <b>130</b> may appear as locally attached to the operating system. Accordingly, different nodes <b>116</b>, <b>118</b>, etc. may access data blocks through the operating system, rather than expressly requesting abstract files.</p><p id="p-0037" num="0036">It should be appreciated that, while the clustered network environment <b>100</b> illustrates an equal number of network and disk modules, other embodiments may include a differing number of these modules. For example, there may be a plurality of network and disk modules interconnected in a cluster that does not have a one-to-one correspondence between the network and disk modules. That is, different nodes may have a different number of network and disk modules, and the same node may have a different number of network modules than disk modules.</p><p id="p-0038" num="0037">Further, host devices <b>108</b>, <b>110</b> may be networked with the nodes <b>116</b>, <b>118</b> in the cluster, over the storage networking connections <b>112</b>, <b>114</b>. As an example, respective host devices <b>108</b>, <b>110</b> that are networked to a cluster may request services (e.g., exchanging of information in the form of data packets) of nodes <b>116</b>, <b>118</b> in the cluster, and the nodes <b>116</b>, <b>118</b> may return results of the requested services to the host devices <b>108</b>, <b>110</b>. In an embodiment, the host devices <b>108</b>, <b>110</b> may exchange information with the network modules <b>120</b>, <b>122</b> residing in the nodes <b>116</b>, <b>118</b> (e.g., network hosts) in the data storage systems <b>102</b>, <b>104</b>.</p><p id="p-0039" num="0038">A data storage device may include one or more volumes. In an embodiment, the data storage devices <b>128</b>, <b>130</b> include volumes <b>132</b>, <b>134</b> which may include an implementation of storage of information onto disk drives or disk arrays or other storage (e.g., flash) as a file system for data, for example. In an example, a disk array may include all traditional hard drives, all flash drives, or a combination of traditional hard drives and flash drives. Volumes may span a portion of a disk, a collection of disks, or portions of disks, for example, and typically define an overall logical arrangement of file storage on disk space in the storage system.</p><p id="p-0040" num="0039">Volumes are typically configured in formats that may be associated with particular storage systems, and respective volume formats typically include features that provide functionality to the volumes, such as providing an ability for volumes to form clusters. For example, a first storage system may utilize a first format for their volumes, and a second storage system may utilize a second format for their volumes, where the first and second formats are different from each other.</p><p id="p-0041" num="0040">In the clustered network environment <b>100</b>, the host devices <b>108</b>, <b>110</b> may utilize the data storage systems <b>102</b>, <b>104</b> to store and retrieve data from the volumes <b>132</b>, <b>134</b>. For example, the host device <b>108</b> may send data packets to the network module <b>120</b> in the node <b>116</b> within data storage system <b>102</b>. The node <b>116</b> may forward the data to the data storage device <b>128</b> using the disk module <b>124</b>, where the data storage device <b>128</b> includes the volume <b>132</b>. In this example, the host device <b>108</b> may access the volume <b>132</b>, to store and/or retrieve data, using the data storage system <b>102</b> connected by the storage network connection <b>112</b>. Further, the host device <b>110</b> may exchange data with the network module <b>122</b> in the node <b>118</b> within the data storage system <b>104</b> (e.g., which may be remote from the data storage system <b>102</b>). The node <b>118</b> may forward the data to the data storage device <b>130</b> using the disk module <b>126</b>, thereby accessing volume <b>134</b> associated with the data storage device <b>130</b>. While host device <b>108</b> is illustrated as communicating with data storage system <b>102</b>, and similarly host device <b>110</b> with data storage system <b>104</b>, the host devices <b>108</b>, <b>110</b> may communicate via the network (e.g., via fabric <b>106</b>) with other storage systems without requiring traversal through data storage systems <b>102</b>, <b>104</b> respectively (as just one example). Thus, if data storage system <b>102</b> is down, then the host device <b>108</b> may still access data via storage system <b>104</b> or some other cluster at another site.</p><p id="p-0042" num="0041">An object storage system may be part of the clustered network environment <b>100</b>. An object manager <b>160</b> may maintain objects (e.g., store objects, read from objects, modifications of objects, and/or removal of objects) stored in the object storage system along with the objects' names. The object manager <b>160</b> may be coupled to the fabric <b>106</b> and may communicate with the data storage system <b>102</b> via the network module <b>120</b> and/or communicate with the data storage system <b>104</b> via the network module <b>122</b>.</p><p id="p-0043" num="0042">In some examples, aspects of the object manager <b>160</b> may be incorporated into the data storage systems <b>102</b>, <b>104</b>. For example, aspects of the object manager <b>160</b> may be incorporated into the nodes <b>116</b>, <b>118</b> (e.g., in the network modules <b>120</b>, <b>122</b> or the disk module <b>124</b>, <b>126</b>). The object manager <b>160</b> is shown as a box with dashed lines, indicating that the object manager <b>160</b> may be incorporated into the network module <b>120</b>, the disk module <b>124</b>, the network module <b>122</b>, and/or the disk module <b>126</b>. The object storage system may maintain objects (e.g., hundreds of billions of objects) and further maintain a flat object storage namespace that stores the objects' names in the object storage system. An object name may uniquely identify an individual object that is stored in the object storage system. A flat namespace may refer to a namespace that is not hierarchical. For example, subdirectory levels are not recognized or respected. In this example, the &#x201c;/&#x201d; character in an object name (if it appears at all) does not indicate anything about the structure of the namespace and is treated like any other character.</p><p id="p-0044" num="0043">In an embodiment, a volume may include stored data as one or more files that reside in a hierarchical directory structure within the volume. In an embodiment, volumes may also, or alternatively, include stored data as a distributed database including a TOC database and one or more chapter databases. The one or more chapter databases may store a collection of object names included in a flat object storage namespace within the volumes. The volumes may span multiple nodes that are interconnected (e.g., via the fabric <b>106</b>). The host devices <b>108</b>, <b>110</b> may perform efficient searches that match all object names beginning with a specified string. Additionally, the object manager <b>160</b> may iterate the flat object storage namespace in alphabetically sorted order starting from any point in the namespace.</p><p id="p-0045" num="0044">The TOC database <b>136</b> may be stored at the storage device <b>128</b>. For example, the TOC database <b>136</b> may be stored at the volume <b>132</b> (or at the volume <b>134</b>). The network module <b>120</b>, <b>122</b> may receive from the disk module <b>124</b>, <b>126</b> selected records from the TOC database <b>136</b>, which the network module <b>120</b>, <b>122</b> may then keep in memory as a cache to assist the network module <b>120</b>, <b>122</b> efficiently process future requests. The dashed lines around the TOC database <b>136</b> may indicate that the network module <b>120</b> is caching some information from the TOC database <b>136</b>. The chapter database <b>138</b> is stored in a volume <b>132</b> and is coupled to the disk module <b>124</b>. Additionally, a chapter database may be replicated for redundancy. The TOC database and chapter databases are discussed further below in relation to, for example, aspects of <figref idref="DRAWINGS">FIGS. <b>2</b>-<b>9</b></figref>.</p><p id="p-0046" num="0045"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is an illustrative example of a data storage system <b>200</b> (e.g., data storage system <b>102</b>, <b>104</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref>), in accordance with one or more aspects of the present disclosure. The data storage system <b>200</b> includes a node <b>202</b> (e.g., nodes <b>116</b>, <b>118</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref>), and a data storage device <b>234</b> (e.g., data storage devices <b>128</b>, <b>130</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref>). The node <b>202</b> may be a general purpose computer, for example, or some other computing device particularly configured to operate as a storage server. A host device <b>205</b> (e.g., host device <b>108</b>, <b>110</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref>) may be connected to the node <b>202</b> over a network <b>216</b>, for example, to provide access to files and/or other data stored on the data storage device <b>234</b>. The node <b>202</b> may include a storage controller that provides client devices, such as the host device <b>205</b>, with access to data stored within data storage device <b>234</b>.</p><p id="p-0047" num="0046">The data storage device <b>234</b> can include mass storage devices, such as disks <b>224</b>, <b>226</b>, <b>228</b> of a disk array <b>218</b>, <b>220</b>, <b>222</b>. It will be appreciated that the techniques and systems, described herein, are not limited by the example illustrated in <figref idref="DRAWINGS">FIG. <b>2</b></figref>. For example, disks <b>224</b>, <b>226</b>, <b>228</b> may include any type of mass storage devices, including but not limited to magnetic disk drives, flash memory (e.g., SSDs), and any other similar media adapted to store information, including, for example, data (D) and/or parity (P) information.</p><p id="p-0048" num="0047">The node <b>202</b> includes one or more processors <b>204</b>, a memory <b>206</b>, a network adapter <b>210</b>, a cluster access adapter <b>212</b>, and a storage adapter <b>214</b> interconnected by a system bus <b>242</b>. The network adapter <b>210</b> may correspond to and/or be an example of the network module <b>120</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref>. The storage adapter <b>214</b> may correspond to and/or be an example of the disk module <b>124</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref>. The data storage system <b>200</b> also includes an operating system <b>208</b> installed in the memory <b>206</b> of the node <b>202</b> that can, for example, implement a Redundant Array of Independent (or Inexpensive) Disks (RAID) optimization technique, or error correction coding (to name just a few examples), to optimize a reconstruction process of data of a failed disk in an array. The operating system <b>208</b> may manage communications for the data storage system <b>200</b>, and communications between other data storage systems that may be in a clustered network, such as attached to a cluster fabric <b>215</b> (e.g., cluster fabric <b>106</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref>). Thus, the node <b>202</b>, such as a network storage controller, can respond to host device requests to manage data on the data storage device <b>234</b> (e.g., or additional clustered devices) in accordance with these host device requests.</p><p id="p-0049" num="0048">The operating system <b>208</b> may include several modules or &#x201c;layers&#x201d; executed by one or both of the network adapter <b>210</b> or the storage adapter <b>214</b>. These layers may include a file system <b>240</b> that keeps track of objects and object namespaces stored in the storage devices and manages read/write operations (e.g., executes read/write operations on storage in response to client requests). The operating system <b>208</b> may establish one or more file systems on the data storage system <b>200</b>, where a file system can include software code and data structures that implement a persistent namespace of files and directories, for example. The file system may logically organize stored information as a non-hierarchical structure for files/directories/objects at the storage devices. Each &#x201c;on disk&#x201d; file may be implemented as a set of blocks configured to store information, such as text. These data blocks may be organized within a volume block number (VBN) space that is maintained by one or more databases accessible by the storage operating system <b>208</b>. The file system may also assign each data block in the file a corresponding &#x201c;file offset&#x201d; or a file block number (FBN). The file system may assign sequences of FBNs on a per-file basis, whereas VBNs may be assigned over a larger volume address space. The file system may organize the data blocks within the VBN space as a logical volume. The file system may be composed of a contiguous range of VBNs from zero to n, for a file system of size n&#x2212;1 blocks, where n is a number greater than 1. In an example, when a new data storage device (not shown) is added to a clustered network system, the operating system <b>208</b> is informed where, in an existing directory tree, new files associated with the new data storage device are to be stored. This is often referred to as &#x201c;mounting&#x201d; a file system.</p><p id="p-0050" num="0049">In the example data storage system <b>200</b>, memory <b>206</b> may include storage locations that are addressable by the processors <b>204</b> and network adapter <b>210</b>, cluster access adapter <b>212</b>, and/or storage adapter <b>214</b> for storing related software application code and data structures. The processors <b>204</b>, the network adapter <b>210</b>, the cluster access adapter <b>212</b>, and/or the storage adapter <b>214</b> may, for example, include processing elements and/or logic circuitry configured to execute the software code and manipulate the data structures. The operating system <b>208</b>, portions of which are typically resident in the memory <b>206</b> and executed by the processing elements, functionally organizes the storage system by, among other things, invoking storage operations in support of a file service implemented by the storage system. It will be apparent that other processing and memory mechanisms, including various computer readable media, may be used for storing and/or executing application instructions pertaining to the techniques described herein. For example, the operating system may also utilize one or more control files (not shown) to aid in the provisioning of virtual machines.</p><p id="p-0051" num="0050">The network adapter <b>210</b> includes the mechanical, electrical and signaling circuitry for connecting the data storage system <b>200</b> to the host device <b>205</b> over the network <b>216</b>, which may include, among other things, a point-to-point connection or a shared medium, such as a LAN. The host device <b>205</b> may be a general-purpose computer configured to execute applications. As described above, the host device <b>205</b> may interact with the data storage system <b>200</b> in accordance with a client/host model of information delivery.</p><p id="p-0052" num="0051">The storage adapter <b>214</b> cooperates with the operating system <b>208</b> executing on the node <b>202</b> to access information requested by the host device <b>205</b> (e.g., access data on a storage device managed by a network storage controller). The information may be stored on any type of attached array of writeable media such as magnetic disk drives, flash memory, and/or any other similar media adapted to store information. In the example data storage system <b>200</b>, the information may be stored in data blocks on the disks <b>224</b>, <b>226</b>, <b>228</b>. The storage adapter <b>214</b> can include input/output (I/O) interface circuitry that couples to the disks over an I/O interconnect arrangement, such as a storage area network (SAN) protocol (e.g., Small Computer System Interface (SCSI), iSCSI, hyperSCSI, Fiber Channel Protocol (FCP)). The information may be retrieved by the storage adapter <b>214</b> and, in some examples, processed by the one or more processors <b>204</b> (or the storage adapter <b>214</b> itself) prior to being forwarded over the system bus <b>242</b> to the network adapter <b>210</b> (and/or the cluster access adapter <b>212</b> if sending to another node in the cluster) where the information is formatted into a data packet and returned to the host device <b>205</b> over the network <b>216</b> (and/or returned to another node attached to the cluster over the cluster fabric <b>215</b>).</p><p id="p-0053" num="0052">In an embodiment, storage of information on disk arrays <b>218</b>, <b>220</b>, <b>222</b> can be implemented as one or more storage volumes <b>230</b>, <b>232</b> that include a cluster of disks <b>224</b>, <b>226</b>, <b>228</b> defining an overall logical arrangement of disk space. The disks <b>224</b>, <b>226</b>, <b>228</b> that include one or more volumes may be organized as one or more groups of RAIDs (while in other examples, error correction coding may be used). As an example, volume <b>230</b> includes an aggregate of disk arrays <b>218</b> and <b>220</b>, which include the cluster of disks <b>224</b> and <b>226</b>. In an example, to facilitate access to disks <b>224</b>, <b>226</b>, <b>228</b>, the operating system <b>208</b> may implement a file system (e.g., write anywhere file system) that logically organizes the information as a non-hierarchical structure of files on the disks. Accordingly, respective files may be implemented as a set of disk blocks configured to store information, whereas databases may be implemented to store information about the files and where they are stored.</p><p id="p-0054" num="0053">Whatever the underlying physical configuration within this data storage system <b>200</b>, data can be stored as files within physical and/or virtual volumes, which can be associated with respective volume identifiers, such as file system identifiers (FSIDs), which can be 32-bits in length in one example. A physical volume corresponds to at least a portion of physical storage devices whose address, addressable space, location, etc. does not change, such as at least some of one or more data storage devices <b>234</b> (e.g., a Redundant Array of Independent (or Inexpensive) Disks (RAID system)). In some examples, the location of the physical volume does not change in that the (range of) address(es) used to access it may generally remain constant. A virtual volume, in contrast, may be stored over an aggregate of disparate portions of different physical storage devices. The virtual volume may be a collection of different available portions of different physical storage device locations, such as some available space from each of the disks <b>224</b>, <b>226</b>, and/or <b>228</b>, and is not &#x201c;tied&#x201d; to any one particular storage device. Accordingly, a virtual volume may be said to include a layer of abstraction or virtualization, which allows it to be resized and/or flexible in some regards.</p><p id="p-0055" num="0054">Further, a virtual volume may include one or more logical unit numbers (LUNs) <b>238</b> and/or directories <b>236</b>. The LUNs <b>238</b> may be characterized as constituting a virtual disk or drive upon which data within the virtual volume may be stored within the aggregate. LUNs may be referred to as virtual drives, such that they emulate a hard drive from a general purpose computer, while they actually include data blocks stored in various parts of a volume.</p><p id="p-0056" num="0055">One or more data storage devices <b>234</b> may have one or more physical ports, where each physical port may be assigned a target address (e.g., SCSI target address). To represent respective volumes stored on a data storage device, a target address on the data storage device <b>234</b> may be used to identify one or more LUNs <b>238</b>. For example, when the node <b>202</b> connects to a volume <b>230</b>, <b>232</b> through the storage adapter <b>214</b>, a connection between the node <b>202</b> and the one or more LUNs <b>238</b> underlying the volume is created. Additionally or alternatively, respective target addresses may identify multiple LUNs, such that a target address may represent multiple volumes. The I/O interface, which may be implemented as circuitry and/or software in the storage adapter <b>214</b> or as executable code residing in memory <b>206</b> and executed by the processors <b>204</b>, for example, may connect to volume <b>230</b> by using one or more addresses that identify the one or more LUNs <b>238</b>.</p><p id="p-0057" num="0056">An object storage system may include the data storage system <b>200</b>, which may be part of the clustered network environment <b>100</b>. A volume may have a plurality of inodes, where each inode may be associated with a plurality of storage blocks. If an object is created and stored in the object storage system, the node <b>202</b> may store the object across one or more blocks. An inode may reference or point to the actual object data by referencing or pointing to the one or more blocks storing the object. An inode may be uniquely identified in the clustered network environment <b>100</b> by its file handle, which may be composed of a volume identifier that identifies a volume and an inode number within the volume. The file handle may include a generation number field that indicates how many times this particular inode has been consumed. An inode may be consumed and then freed, and then consumed again for a new purpose. Each time an inode is reused, the generation number may be increased. Accordingly, if a host device attempts to access an object using a stale generation number, then the access request may fail.</p><p id="p-0058" num="0057">The object storage system may include a database of a first type and one or more databases of a second type. The database of the first type may be a TOC database, and a database of the second type may be a chapter database. As shown in <figref idref="DRAWINGS">FIG. <b>2</b></figref>, the virtual volume may store the TOC database <b>136</b>, the chapter database <b>138</b>, and/or one or more objects <b>290</b>. The TOC database may provide an overview of the number of chapter databases in a collection of chapter databases and the location of these chapter databases. For example, the TOC database may store one or more entries or records, each record including a name marker and a chapter database file handle. The name marker may indicate a range of object names covered by a given chapter database, and the chapter database file handle may reference a location at which the chapter database is stored. Additionally, the chapter databases may store one or more entries or records, each record including an object name and an object file handle. The object name may identify an object, and the object file handle may reference a location at which the object is stored.</p><p id="p-0059" num="0058">A chapter database may cover a discrete and continuous range of object names. A chapter database that covers a range of object names may also be referred to as a chapter database that owns, is responsible for, or includes the range of object names. In an example, if an object name is within the flat object storage namespace, exactly one chapter owns the object name. In other words, there may be a one-to-one relationship between an object name and a chapter database. If the chapter database includes an object name, then the chapter database may store a reference to a location at which the object identified by the object name is stored. In some examples, the flat object storage namespace includes an object name and the data corresponding to the object name is not accessible via the disk module. For example, the data may be archived off-site or is using a shared single-instance-storage with other content elsewhere.</p><p id="p-0060" num="0059">A chapter database that covers an object name may not necessarily include the object name. For example, the chapter database may cover the range of object names &#x201c;A-G,&#x201d; but not include an object name that falls within this range and is requested by a host device. In this example, the object having the object name has not yet been created and saved in the object storage system or is identified by a different object name. The collection of chapter databases serves the overall workload for maintaining (e.g., creating, reading from, writing to, destroying, and the like) objects and their object names. For example, the collection of chapter databases may include an ordered enumeration of all object names within the flat object storage namespace. If the collection of chapter databases were to be concatenated and laid out semantically from beginning to end, the collection of chapter databases would represent the entire object namespace.</p><p id="p-0061" num="0060">The decision of where to store a chapter database may have long-term ramifications on the object storage system. For example, if the object manager <b>160</b> stores a chapter database at a particular volume, that particular volume may receive more traffic compared to before the chapter database was stored at the particular volume.</p><p id="p-0062" num="0061">The object manager <b>160</b> may perform operations that include looking up an object name in the namespace and then reading data from the corresponding object. Such operations may be accomplished quicker if the chapter database covering the range of object names including the object's name and the object were stored at the same volume. For example, a chapter database may reside at a first volume, and the object manager <b>160</b> may determine that, upon looking up the desired object name, the object is stored at a second volume different from the first volume. In this example, performing the operation may result in an additional latency compared to if the chapter database and the object were to reside at the same volume. The completion time for performing an operation that involves referencing multiple volumes as part of a single task may be longer than for performing same-volume operations.</p><p id="p-0063" num="0062">The object manager <b>160</b> may estimate the probability of a particular object being on the same volume as its corresponding chapter database. As a chapter database splits into two and/or merges with another chapter database, the collective namespace responsibility may flow from one volume to another volume. For example, a disk module may receive a rush of new &#x201c;Aardvark-&#x201d; related objects to store in an initial chapter database responsible for all &#x201c;A-&#x201d; object names. After the disk module performs some number of new object-create actions (and allocating inodes from the chapter database's own local volume for each one), the object manager <b>160</b> may determine to split the chapter database into two partitioned chapter databases. The object manager <b>160</b> may store a first one of the two partitioned chapter databases at the chapter database's local volume and may store a second one of the two partitioned chapter databases at a volume different from the chapter database's local volume. Accordingly, about half of the names in the Aardvark-filled chapter database may be stored in the second partitioned database that differs from where its objects were allocated, while the object names in the first new partitioned database may still be co-located on this volume. In this example, about half of the objects identified by the object names are &#x201c;local&#x201d; to the chapter database and about half of the objects identified by the object names are &#x201c;remote&#x201d; from the chapter database.</p><p id="p-0064" num="0063">Additionally, each of the two new partitioned chapter databases may be only half-full of object names and ready to accept new Aardvark-related names from the host device <b>205</b> (or any other host device). If the pattern continues and the host device <b>205</b> (or any other host device) writes more Aardvark-related names, then each of the two new partitioned chapter database may accept a flood of new names in the namespace. In some examples, the object manager <b>160</b> may allocate new inodes that are local to a particular chapter database. If both partitioned chapter databases receive new object names in this namespace evenly and they each grow to a point where the object manager <b>160</b> determines that they should be split again, the first chapter database (the chapter database that is local to the original objects) may have one hundred percent local object names, and the second chapter database (the chapter database that is remote from the original objects) may have approximately fifty percent local object names. The collective result may be that seventy-five percent (an average of the one hundred percent local object names and the fifty percent local object names) of the objects in this storage container may, at this moment, be stored on the same volume as their corresponding portion of the namespace. This pattern may continue and provide approximately a two-thirds locality for objects.</p><p id="p-0065" num="0064"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a flow diagram of a method <b>300</b> of storing an object in an object storage system in accordance with one or more aspects of the present disclosure. Blocks of the method <b>300</b> can be executed by a computing device (e.g., a processor, processing circuit, the storage operating system <b>208</b>, the network adapter <b>210</b>, the cluster access adapter <b>212</b>, the storage adapter <b>214</b>, and/or other suitable component, such as of the node <b>202</b> in <figref idref="DRAWINGS">FIG. <b>2</b></figref>). For example, the data storage system (e.g., data storage system <b>102</b>, <b>104</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref> or the data storage system <b>200</b> in <figref idref="DRAWINGS">FIG. <b>2</b></figref>) may utilize one or more components, such as the nodes <b>116</b>, <b>118</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the network modules <b>120</b>, <b>122</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the disk modules <b>124</b>, <b>126</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the data storage devices <b>128</b>, <b>130</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, to execute the blocks of the method <b>300</b>. As illustrated, the method <b>300</b> includes a number of enumerated blocks, but embodiments of the method <b>300</b> may include additional blocks before, after, and in between the enumerated blocks. In some embodiments, one or more of the enumerated blocks may be omitted or performed in a different order.</p><p id="p-0066" num="0065"><figref idref="DRAWINGS">FIG. <b>4</b></figref> will be discussed relative to <figref idref="DRAWINGS">FIG. <b>3</b></figref> (and vice versa) to better understand concepts related to storing an object in an object storage system. <figref idref="DRAWINGS">FIG. <b>4</b></figref> is a block diagram illustrating an object storage system <b>400</b> that processes a request to store an object in the object storage system in accordance with one or more aspects of the present disclosure. The object storage system <b>400</b> includes the data storage device <b>102</b>, the node <b>116</b>, the network module <b>120</b>, the disk module <b>124</b>, the TOC database <b>136</b>, the object manager <b>160</b>, the data storage device <b>128</b>, the volume <b>132</b>, and the chapter database <b>138</b>, as discussed in relation to <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0067" num="0066">Additionally, it should be understood that aspects of the object manager <b>160</b> may be incorporated in the data storage system <b>102</b> (e.g., in the network module <b>120</b> and/or the disk module <b>124</b>). In the present disclosure, reference to an object manager <b>160</b> performing an action (e.g., receiving, transmitting, determining, storing, etc.) may refer to the data storage system (e.g., or one or more components within the data storage system <b>102</b> such as the node <b>116</b>, the network module <b>120</b>, disk module <b>124</b>, data storage device <b>128</b>, and the like) performing such action.</p><p id="p-0068" num="0067">Referring to <figref idref="DRAWINGS">FIG. <b>3</b></figref>, at block <b>302</b>, the method <b>300</b> includes receiving, by an object manager <b>160</b> from a client, a request to store a first object having an object name into an object storage system. As illustrated in <figref idref="DRAWINGS">FIG. <b>4</b></figref>, the host device <b>108</b> may transmit a store request <b>402</b> to the data storage system <b>102</b>. The store request <b>402</b> may be a request to store an object <b>404</b> having an object name <b>406</b> into the object storage system <b>400</b>, which may be part of the clustered network environment <b>100</b>. The network module <b>120</b> may receive the store request <b>402</b> from the host device <b>108</b>.</p><p id="p-0069" num="0068">Referring back to <figref idref="DRAWINGS">FIG. <b>3</b></figref>, at block <b>304</b>, the method <b>300</b> includes searching, by the object manager <b>160</b>, a TOC database for a first record that includes a name marker and a chapter database file handle, the name marker indicating a range of object names covered by a chapter database, the chapter database file handle referencing a first location at which the chapter database is stored, the first location being in a first volume in a first data storage device, and the range of object names including the object name.</p><p id="p-0070" num="0069">In <figref idref="DRAWINGS">FIG. <b>4</b></figref>, the network module <b>120</b> may cache, in memory, some records from the TOC database <b>136</b> that the network module <b>122</b> received in response to its communications with the disk module <b>124</b>. The cached records may assist the networking module to handle requests associated with objects (e.g., read, store, and/or write requests) efficiently, as discussed in the present disclosure. In some examples, each query, iteration, insert, or delete operation may be resolved against the TOC database <b>136</b> to identify which chapter database is responsible for the operation. As will be discussed in more detail, the TOC database <b>136</b> may be slow changing. For example, as the namespace grows, fewer split and merge operations on the chapter databases may occur, potentially resulting in fewer changes (e.g., additions or removal of records) to the TOC database <b>136</b>. These properties (e.g., a high rate of read and a low or decreasing rate of change) make the TOC database an excellent candidate for caching.</p><p id="p-0071" num="0070">By caching the contents of the TOC database <b>136</b> and invalidating that cache under particular conditions (e.g., when the TOC database <b>136</b> changes), a typical operation may bypass actually loading the TOC database <b>136</b> itself and instead may use the cache to identify the correct chapter database quickly. Moreover, it may be unnecessary to cache the entire TOC database <b>136</b> all the time. For example, a dynamic cache may store routing hints (e.g., records indicating that a particular range of object names (e.g., names between A- and D-)) should be routed to a particular chapter database. By sorting these hints when available, the object manager <b>160</b> may determine which chapter database is appropriate for looking up (or creating, enumerating from, deleting, and the like) a given object name. If no matching hints are available, the host device may consult the actual TOC database <b>136</b> and thereby build a new hint to put into its table of routing hints.</p><p id="p-0072" num="0071">The network module <b>120</b> has direct access to a database if the network module <b>120</b> may access the database without an intermediary. The TOC database <b>136</b> may reference one or more chapter databases, which collectively represents a flat object storage namespace storing a complete collection of object names that identify objects belonging to a client in the object storage system. The network module <b>120</b> may cache one or more records stored in the TOC database <b>136</b>. The TOC database <b>136</b> may include one or more records, each record including a name marker that indicates a range of object names covered by a given chapter database and further including a chapter database file handle that references a location at which the given chapter database is stored. For example, the TOC database <b>136</b> includes a first column &#x201c;Name Marker&#x201d; <b>412</b> indicating a range of object names and further includes a second column &#x201c;Chapter_DB_File_Handle&#x201d; <b>414</b> storing two parameters. Each record in the TOC database <b>136</b> may indicate a mutually exclusive range of object names compared to each other. A first parameter &#x201c;VID&#x201d; represents a volume identifier that identifies a particular volume that stores a given chapter database, and a second parameter &#x201c;InodeID&#x201d; represents an inode identifier that identifies a particular inode within the particular volume. The chapter database is stored at the particular inode, which is stored within the particular volume.</p><p id="p-0073" num="0072">A number of records in the TOC database <b>136</b> may indicate the number of chapter databases in the collection of chapter databases. The TOC database <b>136</b> includes a single entry or record <b>416</b> including a name marker &#x201c;*&#x201d; (stored in the first column &#x201c;Name Marker&#x201d; <b>412</b>) and a chapter database file handle &#x3c;VID_<b>132</b>, InodeID_<b>418</b>&#x3e; (stored in the second column &#x201c;Chapter_DB_File_Handle&#x201d; <b>414</b>). The name marker &#x201c;*&#x201d; represents a wild card (e.g., the range of object names includes all alphanumeric symbols) and accordingly indicates that a single chapter database stores the complete flat namespace of the collection of object names. The chapter database file handle &#x3c;VID_<b>132</b>, InodeID_<b>418</b>&#x3e; corresponds to the name marker &#x201c;*&#x201d; and references the chapter database <b>138</b>, which is stored at an inode <b>418</b> (identified by the InodeID_<b>418</b>) within a volume <b>132</b> (identified by the VID_<b>132</b>). A name marker corresponds to a chapter database file handle if they are both stored in the same record. The TOC database <b>136</b> references the chapter database <b>138</b>, which is stored at a location referenced by the chapter database file handle &#x3c;VID_<b>132</b>, InodeID_<b>418</b>&#x3e;. In other words, the chapter database file handle &#x3c;VID_<b>132</b>, InodeID_<b>418</b>&#x3e; references an inode <b>418</b> identified by the InodeID_<b>418</b> within the volume <b>132</b> identified by the VID_<b>132</b>. The data stored in the column &#x201c;Chapter_DB_File_Handle&#x201d; <b>414</b> may be a memory address of the inode <b>418</b> and/or a pointer to the inode <b>418</b> within the volume <b>132</b>. For example, a reference <b>417</b> is shown from the chapter database file handle &#x3c;VID_<b>132</b>, InodeID_<b>418</b>&#x3e; to the inode <b>418</b> within the volume <b>132</b> in the data storage device <b>128</b>.</p><p id="p-0074" num="0073">The network module <b>120</b> may be unable to directly access the data storage device <b>128</b>. The network module <b>120</b> does not have direct access to a data storage device if the network module <b>120</b> is unable to access the data storage device without an intermediary. For example, the network module <b>120</b> may be unable to access the chapter database <b>138</b> without using disk module <b>124</b> as an intermediary.</p><p id="p-0075" num="0074">The network module <b>120</b> may determine, based on the chapter database file handle specified in the record <b>416</b>, that the chapter database <b>138</b> is stored in the data storage device <b>128</b>. Additionally, the network module <b>120</b> may determine that the disk module <b>124</b> accesses data within the data storage device <b>128</b>. For example, the disk module <b>124</b> owns the volumes (e.g., volume <b>132</b>) residing in the data storage device <b>128</b>. To access the data storage device <b>128</b>, the network module <b>120</b> may transmit a request to the data storage device <b>128</b> via the disk module <b>124</b>.</p><p id="p-0076" num="0075">In some examples, the disk module <b>124</b> and/or the data storage device <b>128</b> communicate in a protocol different from the host device <b>108</b>. In an example, the host device <b>108</b> may communicate with the data storage system <b>102</b> via a first protocol, such as an object protocol (e.g., AMAZON S3&#xae;), and the disk module <b>124</b> and/or the data storage device <b>128</b> may communicate with components using a second protocol different from the first protocol. For example, the network module <b>120</b> may receive the store request <b>402</b> in the first protocol, which is indicated by a first pattern shown corresponding to the store request <b>402</b> and translate the store request <b>402</b> into an internal messaging format that is understandable by the disk module <b>124</b> and/or the data storage device <b>128</b>. The network module <b>120</b> may translate the store request <b>402</b> into a store request <b>420</b> that is in the second protocol (e.g., an internal messaging format), as indicated by the second pattern corresponding to the store request <b>420</b>. The disk module <b>124</b> may receive the store request <b>420</b> and access the data storage device <b>128</b> in accordance with the store request <b>420</b>. In other examples, the first and second protocols are the same, and network module <b>120</b> transmits the store request <b>402</b> to the disk module <b>124</b> without translation of the request into another protocol.</p><p id="p-0077" num="0076">Referring back to <figref idref="DRAWINGS">FIG. <b>3</b></figref>, at block <b>306</b>, the method <b>300</b> includes searching, by the object manager <b>106</b>, the chapter database for a second record including the object name. Each chapter database may cover a discrete and continuous range of object names in the flat namespace.</p><p id="p-0078" num="0077">In <figref idref="DRAWINGS">FIG. <b>4</b></figref>, the chapter database <b>138</b> may include one or more entries or records, each record including an object name and further including an object file handle that references a location at which the object identified by the object name is stored. For example, the chapter database <b>138</b> includes a first column &#x201c;Object Name&#x201d; <b>422</b> storing one or more object names and further includes a second column &#x201c;Object_File_Handle&#x201d; <b>424</b> storing two parameters. A first parameter &#x201c;VID&#x201d; represents a volume identifier that identifies a particular volume that stores an object identified by the corresponding object name, and a second parameter &#x201c;InodeID&#x201d; represents an inode identifier that identifies a particular inode within the particular volume. The object is stored at the particular inode, which is stored within the particular volume.</p><p id="p-0079" num="0078">Referring back to <figref idref="DRAWINGS">FIG. <b>3</b></figref>, at block <b>308</b>, the method <b>300</b> includes determining whether any record in the chapter database <b>138</b> includes the object name. If a record in the chapter database <b>138</b> includes the object name, then the object name has already been taken and would not uniquely identify the object. In this instance, the method <b>300</b> may proceed to block <b>310</b>. At block <b>310</b>, the method <b>300</b> includes sending, by the object manager <b>160</b>, an error message to the client, the error message indicating that another object having the object name has already been stored in the object storage system. The object manager <b>160</b> may provide the error message along with a request to the client for a different name for the object.</p><p id="p-0080" num="0079">In contrast, if no record in the chapter database includes the object name, then the object name is unique within the flat namespace and accordingly may be stored in the object storage system to identify the object. If the object name is within the flat namespace, the on name would be stored in the chapter database covering the range of object names including the object name. In this instance, the method <b>300</b> may proceed to block <b>312</b>. At block <b>312</b>, the method <b>300</b> includes allocating, by the object manager <b>160</b>, storage at a second location for storing the first object, the second location being in a second volume in a second data storage device.</p><p id="p-0081" num="0080">At block <b>314</b>, the method <b>300</b> includes storing, by the object manager <b>160</b>, the first object at the second location. The first location at which the chapter database is stored may include a first volume and a first inode. In an example, the second location at which the object is stored may include the first volume and a second inode different from the first inode, as shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref>. In <figref idref="DRAWINGS">FIG. <b>4</b></figref>, the disk module <b>124</b> receives the store request <b>420</b> from the network module <b>120</b> and proceeds to execute actions to store the object <b>404</b> into the object storage system <b>400</b>. To reduce latency, it may be desirable for the object manager <b>160</b> to store the object <b>404</b> at the same volume <b>132</b> where the chapter database <b>138</b> is stored. For example, the disk module <b>124</b> may determine to store the object <b>404</b> as an inode <b>426</b> within the volume <b>132</b>. The disk module <b>124</b>, for example, may store the object <b>404</b> across one or more blocks in the inode <b>426</b>. In another example, the second location at which the object is stored may include a second volume different from the first volume. In this example, the chapter database and the object are stored at different volumes.</p><p id="p-0082" num="0081">Referring back to <figref idref="DRAWINGS">FIG. <b>3</b></figref>, at block <b>316</b>, the method <b>300</b> includes inserting, by the object manager <b>160</b>, the second record including the object name and an object file handle into the chapter database, the object file handle referencing the second location.</p><p id="p-0083" num="0082">In <figref idref="DRAWINGS">FIG. <b>4</b></figref>, the disk module <b>124</b> may insert a record <b>430</b> into the chapter database <b>138</b> in accordance with the store request <b>420</b> and storage of the object <b>404</b> at the second location. The chapter database <b>138</b> includes a record <b>430</b> including an object name &#x201c;OBName_<b>406</b>&#x201d; (corresponding to object name <b>406</b> and stored in the first column &#x201c;Object Name&#x201d; <b>422</b>) that identifies the object <b>404</b> and further includes an object file handle &#x3c;VID_<b>132</b>, InodeID_<b>426</b>&#x3e; (stored in the second column &#x201c;Object_File_Handle&#x201d; <b>424</b>) that references the corresponding object <b>404</b>. An object file handle corresponds to an object if the object file handle and the object name that identifies the object are both stored in the same record. In other words, the chapter database <b>138</b> references the object <b>404</b>, which is stored at a location referenced by the corresponding object file handle &#x3c;VID_<b>132</b>, InodeID_<b>426</b>&#x3e;. The object file handle &#x3c;VID_<b>132</b>, InodeID_<b>426</b>&#x3e; references an inode <b>426</b> identified by the InodeID_<b>426</b> within the volume <b>132</b> identified by the VID_<b>132</b>. The data stored in the column &#x201c;Object_File_Handle&#x201d; <b>424</b> may be a memory address of the inode <b>426</b> and/or a pointer to the inode <b>426</b> within the volume <b>132</b>. For example, a reference <b>432</b> is shown from the object file handle &#x3c;VID_<b>132</b>, InodeID_<b>426</b>&#x3e; to the inode <b>426</b> within the volume <b>132</b>.</p><p id="p-0084" num="0083">After the object <b>404</b> is stored in the object storage system <b>400</b>, the number of records in the chapter database <b>138</b> may increase by one. By routing a request (e.g., the store request <b>402</b>) directly to a particular disk module (e.g., disk module <b>124</b>), the disk module may consult the chapter database to execute actions in accordance with the request without involving other disk modules or data storage devices in the clustered network environment <b>100</b>. Such routing may be performed for numerous disk modules and data storage devices, with each one processing a small workload. Such distribution of workload may help balance servicing these types of requests across the clustered network environment <b>100</b>.</p><p id="p-0085" num="0084">In the example illustrated in <figref idref="DRAWINGS">FIG. <b>4</b></figref>, the TOC database <b>136</b> and the chapter database <b>138</b> are stored in the same data storage system <b>102</b>. Accordingly, the network module <b>120</b> transmits the store request (e.g., store request <b>402</b> or store request <b>420</b>) to a local disk module (e.g., disk module <b>124</b>) for storage of the object <b>404</b>. A network module is local to a disk module if they reside in the same node. Additionally, a network module is local to a data storage device if they reside in the same data storage system. The data storage system <b>102</b> (e.g., the network module <b>120</b> and the disk module <b>124</b>) may service the host device <b>108</b>'s request faster compared to if the network module <b>120</b> were to transmit the store request to a disk module across a network (e.g., fabric <b>106</b>) for storage of the object. In other examples, the network module <b>120</b> may transmit the store request (e.g., store request <b>402</b> or store request <b>420</b>) to a disk module residing in a data storage system different from the data storage system <b>102</b>. For example, the network module <b>120</b> may transmit the store request to the disk module <b>126</b> residing in the data storage system <b>104</b> (e.g., as illustrated in <figref idref="DRAWINGS">FIG. <b>1</b></figref>).</p><p id="p-0086" num="0085"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a block diagram illustrating an object storage system <b>500</b> that processes a request to store an object in the object storage system <b>500</b> in accordance with one or more aspects of the present disclosure. The object storage system <b>500</b> may be part of the clustered network environment <b>100</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref>. The object storage system <b>500</b> includes the data storage system <b>102</b>, the node <b>116</b>, the network module <b>120</b>, the disk module <b>124</b>, the TOC database <b>136</b>, the object manager <b>160</b>, the volume <b>132</b>, the data storage system <b>104</b>, the node <b>118</b>, the network module <b>122</b>, the disk module <b>126</b>, the chapter database <b>138</b>, and the volume <b>134</b>, as discussed in relation to <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0087" num="0086">Additionally, it should be understood that aspects of the object manager <b>160</b> may be incorporated in the data storage system <b>102</b> (e.g., in the network module <b>120</b> and/or the disk module <b>124</b>) and/or in the data storage system <b>104</b> (e.g., in the network module <b>122</b> and/or the disk module <b>126</b>). In the present disclosure, reference to an object manager <b>160</b> performing an action (e.g., receiving, transmitting, determining, storing, etc.) may refer to the data storage system (e.g., or one or more components within the data storage system <b>102</b> such as the node <b>116</b>, the network module <b>120</b>, disk module <b>124</b>, data storage device <b>128</b>, one or more components within the data storage system <b>104</b> such as the node <b>118</b>, the network module <b>122</b>, disk module <b>126</b>, data storage device <b>130</b>, and/or the like) performing such action.</p><p id="p-0088" num="0087">In <figref idref="DRAWINGS">FIG. <b>5</b></figref>, the network module <b>120</b> may cache, in memory, some records from the TOC database <b>136</b> that the network module <b>122</b> received in response to its communications with the disk module <b>124</b>. The cached records may assist the networking module to handle requests associated with objects (e.g., read, store, and/or write requests) efficiently, as discussed in the present disclosure. In <figref idref="DRAWINGS">FIG. <b>5</b></figref>, the TOC database <b>136</b> includes a record <b>516</b> including the name marker &#x201c;*&#x201d; (stored in the first column &#x201c;Name Marker&#x201d; <b>412</b>) and a chapter database file handle &#x3c;VID_<b>134</b>, InodeID_<b>510</b>&#x3e; (stored in the second column &#x201c;Chapter_DB_File_Handle&#x201d; <b>414</b>). Accordingly, the TOC database <b>136</b> references the chapter database <b>138</b>, which in the example is stored at an inode <b>510</b> (identified by the InodeID_<b>510</b>) within a volume <b>134</b> (identified by the VID_<b>134</b>) in the data storage device <b>130</b>.</p><p id="p-0089" num="0088">The network module <b>120</b> may determine that the chapter database <b>138</b> is stored in the data storage device <b>130</b>, which resides in the data storage system <b>104</b>. The network module <b>120</b> may determine that the disk module <b>126</b> has direct access to the data storage device <b>130</b> and may accordingly transmit the store request <b>420</b> to the disk module <b>126</b> (rather than to the disk module <b>124</b> as shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref>). In this example, the disk module <b>126</b> may receive the store request <b>420</b> and allocate storage at the inode <b>526</b> within the volume <b>134</b> for storing the object <b>404</b>. After the object <b>404</b> is stored at the inode <b>526</b>, the object manager <b>160</b> may insert a record <b>530</b> into the chapter database. The record <b>530</b> includes the object name <b>406</b> (&#x201c;OBName_<b>406</b>&#x201d;) of the object <b>404</b> and an object file handle &#x3c;VID_<b>134</b>, InodeID_<b>526</b>&#x3e; that references the object <b>404</b>.</p><p id="p-0090" num="0089">The volume <b>134</b> may have been selected to store the chapter database <b>138</b> because, for example, at the time the chapter database <b>138</b> was created, the volume <b>134</b> had a low utilization rate or high storage capacity. By storing chapter databases at such volumes, the workload may be distributed across the clustered network environment <b>100</b>.</p><p id="p-0091" num="0090">As objects are created and/or destroyed in the object storage system, the chapter databases may be updated accordingly. As more objects are stored into a chapter database, the chapter database may continue to grow in size. For example, if an object is created, then a record corresponding to the create operation may be inserted into the chapter database. Conversely, as more objects are removed from a chapter database, the chapter database may shrink in size. For example, if an object is deleted from the object storage system, then a record corresponding to the delete operation may be removed from the chapter database. The number of records in a chapter database may grow or shrink based on the number of objects created and/or deleted.</p><p id="p-0092" num="0091">Additionally, as chapter databases grow and/or shrink, the flat namespace may adapt to the ongoing workload experienced in the clustered network environment <b>100</b>. The range of object names may be provided in a sorted and continuous order. In some examples, the semantic range of any particular chapter database may change over time. For example, a chapter database may cover a first range of object names, but as objects referenced by the chapter database are added and/or removed, the chapter database may cover a second range of object names different from the first range. In some examples, the semantic range of a given chapter database may be fixed and immutable. After a period of time, if the given chapter database has become too large, the object manger <b>160</b> may split the given chapter database into two or more partitioned chapter databases, remove a TOC entry referencing the given chapter database from the TOC, and replace the TOC entry with new TOC entries for each of these new partitioned chapter databases. The object manager <b>160</b> may assign each partitioned chapter database to cover a specific sub-portion of the original or given chapter database's range, and after creation each of these partitioned chapter database's assigned range of object names may be likewise immutable until the object manager <b>160</b> splits the partitioned chapter database.</p><p id="p-0093" num="0092">Similarly, if the object manager <b>160</b> merges two or more sibling chapter databases to form a new combined chapter database, then the new combined chapter database may cover all of those siblings' range of object names. Additionally, the object manager <b>160</b> may replace the TOC entries referencing any of the sibling chapter databases with a combined TOC entry that references the new combined chapter database. The namespace range that is covered by the new combined chapter database may be immutable for its own lifetime.</p><p id="p-0094" num="0093">Rather than allow chapter databases to grow unhindered, it may be desirable to split large chapter databases when they have attained a certain number of records. In an example, if a number of records stored in an original chapter database satisfies a split threshold (e.g., is greater than the split threshold), then the original chapter database may be split into two partitioned chapter databases. Each of the two partitioned chapter databases may store a subset of the records in the original chapter database, with the two partitioned chapter databases storing, in total, the complete number of records initially stored in the original chapter database. Accordingly, each of the partitioned chapter databases stores fewer records (e.g., is smaller) than the original chapter database. Although an original chapter database has been described as being split into two partitioned chapter databases, it should be understood that the original chapter database may be split into two or more partitioned chapter databases (e.g., three, four, five, or more). Details on splitting a chapter database are provided in, for example, aspects of <figref idref="DRAWINGS">FIGS. <b>6</b> and <b>7</b></figref>.</p><p id="p-0095" num="0094">In another example, if a number of records stored in a first chapter database and a number of records stored in a second chapter database satisfies a merge threshold, then the first chapter database may be merged with the second chapter database (or the second chapter database with the first chapter database) to create a combined chapter database. For example, a number of records stored in a chapter database may satisfy the merge threshold if the number is less than the merge threshold. The merger of the first and second chapter databases may create the combined chapter database, which stores a complete set of records initially stored in the first and second chapter databases. Accordingly, the combined chapter database stores more records (e.g., is larger) than either of the first and second chapter databases alone. Details on merging two chapter databases are provided in, for example, aspects of <figref idref="DRAWINGS">FIG. <b>8</b></figref>.</p><p id="p-0096" num="0095"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a flow diagram of a method <b>600</b> of splitting a chapter database into two partitioned chapter databases in accordance with one or more aspects of the present disclosure. Blocks of the method <b>600</b> can be executed by a computing device (e.g., a processor, processing circuit, the storage operating system <b>208</b>, the network adapter <b>210</b>, the cluster access adapter <b>212</b>, the storage adapter <b>214</b>, and/or other suitable component, such as of the node <b>202</b> in <figref idref="DRAWINGS">FIG. <b>2</b></figref>). For example, the data storage system (e.g., data storage system <b>102</b>, <b>104</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref> or the data storage system <b>200</b> in <figref idref="DRAWINGS">FIG. <b>2</b></figref>) may utilize one or more components, such as the nodes <b>116</b>, <b>118</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the network modules <b>120</b>, <b>122</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the disk modules <b>124</b>, <b>126</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the data storage devices <b>128</b>, <b>130</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, to execute the blocks of the method <b>600</b>. As illustrated, the method <b>600</b> includes a number of enumerated blocks, but embodiments of the method <b>600</b> may include additional blocks before, after, and in between the enumerated blocks. In some embodiments, one or more of the enumerated blocks may be omitted or performed in a different order.</p><p id="p-0097" num="0096"><figref idref="DRAWINGS">FIG. <b>7</b></figref> will be discussed relative to <figref idref="DRAWINGS">FIG. <b>6</b></figref> (and vice versa) to better understand concepts related to splitting a chapter database into two partitioned chapter databases. <figref idref="DRAWINGS">FIG. <b>7</b></figref> is a block diagram illustrating an object storage system <b>700</b> that splits a chapter database into two partitioned chapter databases in accordance with one or more aspects of the present disclosure. The object storage system <b>700</b> may be part of the clustered network environment <b>100</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref>. The object storage system <b>700</b> includes the TOC database <b>136</b> and the volume <b>132</b>, as discussed in relation to <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0098" num="0097">Referring to <figref idref="DRAWINGS">FIG. <b>6</b></figref>, at block <b>602</b>, the method <b>600</b> includes determining, by an object manager <b>160</b>, that an original chapter database having a plurality of records satisfies a split threshold, the original chapter database being stored at a first location, and the original chapter database being referenced by a TOC database and covering a range of object names. In an example, a chapter database satisfies the split threshold if the chapter database includes more records than the split threshold. In another example, a chapter database satisfies the split threshold if the chapter database includes M more records than its peers, where M is a percentage greater than twenty-five (e.g., M is about thirty-three percent or about fifty percent). For example, the object manager <b>160</b> may determine that the original chapter database satisfies the split threshold if the size of the original chapter database is about thirty-three percent or larger than the size of its peers.</p><p id="p-0099" num="0098">In some examples, the object manager <b>160</b> compares the number of records in a chapter database against the number of records in a TOC database. If a chapter database's record count is M percentage higher than the TOC's record count, then the object manager <b>160</b> may determine that the chapter database is too large and satisfies the split threshold. In <figref idref="DRAWINGS">FIG. <b>7</b></figref>, the TOC database <b>136</b> references the chapter database <b>138</b>, which is stored as the inode <b>418</b> in the volume <b>132</b> and may cover the complete flat namespace associated with a client. The chapter database <b>138</b> includes a plurality of records <b>702</b> and may be an example of the original database, as discussed in relation to block <b>602</b>. In an example, the split threshold may be ten records, and the chapter database <b>138</b> satisfies the split threshold if the chapter database <b>138</b> includes a greater number of records than the split threshold. In this example, the chapter database <b>138</b> satisfies the split threshold because the chapter database <b>138</b> includes fourteen records (more than ten records).</p><p id="p-0100" num="0099">Referring to <figref idref="DRAWINGS">FIG. <b>6</b></figref>, at block <b>604</b>, the method <b>600</b> includes partitioning, by the object manager <b>160</b>, the plurality of records into a first subset of records and a second subset of records. The contents of the original chapter database are apportioned to the new partitioned databases. In an example, a midpoint record in the TOC database is selected, and all records below that midpoint are placed in a first chapter database and all records at or above that midpoint are placed in a second chapter database. The two partitioned chapter databases may be considered immediate siblings of each other within the object namespace, and together they occupy the same logical niche in the overall namespace as the original chapter database. The new partitioned databases are discussed further below.</p><p id="p-0101" num="0100">For example, in <figref idref="DRAWINGS">FIG. <b>7</b></figref>, the object manager <b>160</b> may partition the plurality of records <b>702</b> into a first subset of records <b>704</b> and a second subset of records <b>706</b>. The object manager <b>160</b> may partition the plurality of records in about half, with the first and second subsets of records including the same number of records or having at most one more record than the other. This is merely an example, and the object manager <b>160</b> may partition the plurality of records such that the first and second subsets of records have a difference of P records, where P is any number greater than one.</p><p id="p-0102" num="0101">Referring to <figref idref="DRAWINGS">FIG. <b>6</b></figref>, at block <b>606</b>, the method <b>600</b> includes storing, by the object manager <b>160</b>, a first chapter database at a second location, the first chapter database including the first subset of records and covering a first subrange of the range of object names. In <figref idref="DRAWINGS">FIG. <b>7</b></figref>, a chapter database <b>710</b> may be an example of the first chapter database in block <b>606</b>. The chapter database <b>710</b> includes the first subset of records <b>704</b> and covers a first subrange &#x201c;A-J&#x201d; of object names. The object manager <b>160</b> may determine that the second location is at an inode <b>726</b> within a volume <b>724</b>. The object manager <b>160</b> may select the volume <b>724</b> for storage of the chapter database <b>710</b> because the volume <b>724</b> is, for example, underutilized and/or has a large amount of unused storage compared to other volumes in the cluster. In some examples, the first location and the second location are the same and are associated with the same volume. In some examples, the first location and the second location are different and are associated with different volumes.</p><p id="p-0103" num="0102">Referring to <figref idref="DRAWINGS">FIG. <b>6</b></figref>, at block <b>608</b>, the method <b>600</b> includes storing, by the object manager <b>160</b>, a second chapter database at a third location, the second chapter database including the second subset of records and covering a second subrange of the range of object names. In <figref idref="DRAWINGS">FIG. <b>7</b></figref>, a chapter database <b>712</b> may be an example of the second chapter database in block <b>608</b>. The chapter database <b>712</b> includes the second subset of records <b>706</b> and covers a second subrange &#x201c;K-X&#x201d; of object names. The object manager <b>160</b> may determine that the third location is at an inode <b>730</b> within a volume <b>728</b>. The object manager <b>160</b> may select the volume <b>728</b> for storage of the chapter database <b>712</b> because the volume <b>728</b> is, for example, underutilized and/or has a large amount of unused storage compared to other volumes in the cluster. In some examples, the first location and the third location are the same and are associated with the same volume. In some examples, the first location and the third location are different and are associated with different volumes.</p><p id="p-0104" num="0103">The object manager <b>160</b> may determine nodes and/or volumes that are underutilized and/or have a lot of unused storage. As the workload continues to evolve and more objects are added to the object storage system, chapter databases may grow. A large chapter database may be split into the first and second chapter databases, as discussed above in relation to blocks <b>604</b> and <b>606</b>, and the object manager <b>160</b> may determine to store each of these chapter databases at volumes and/or data storage devices that are underutilized and/or have a lot of unused storage to keep the overall workload distributed about evenly among the nodes and volumes in the clustered network environment <b>100</b>.</p><p id="p-0105" num="0104">Referring to <figref idref="DRAWINGS">FIG. <b>6</b></figref>, at block <b>610</b>, the method <b>600</b> includes updating, by the object manager <b>160</b>, an original record in the TOC database that references the original chapter database to store a first name marker and a first chapter database file handle, the first name marker indicating the first subrange and the first chapter database file handle referencing the second location. In some examples, updating the original record in the TOC database may include removing the original record and inserting a record in the TOC database, the inserted record including the first name marker and the first chapter database file handle.</p><p id="p-0106" num="0105">In <figref idref="DRAWINGS">FIG. <b>7</b></figref>, the chapter databases <b>710</b> and <b>712</b> may replace the chapter database <b>138</b>. Collectively, the chapter databases <b>710</b> and <b>712</b> are responsible for the same range of object names for which the original chapter database is responsible. Before the chapter database <b>138</b> is split, the TOC database <b>136</b> references the chapter database <b>138</b>. After the chapter database <b>138</b> is split, the object manager <b>160</b> may update the TOC database <b>136</b> to reference the chapter databases <b>710</b> and <b>712</b>. The object manager <b>160</b> may update the record <b>416</b> in the TOC database <b>136</b> to a record <b>720</b>, which stores a name marker &#x201c;A-J&#x201d; indicating a first subrange of object names and further stores a chapter database file handle &#x3c;VID_<b>724</b>, InodeID_<b>726</b>&#x3e; that references an inode <b>726</b> (identified by InodeID_<b>726</b>) in a volume <b>724</b> (identified by VID_<b>724</b>). The TOC database <b>136</b> may be updated to the TOC database <b>714</b>. The chapter database <b>710</b> is stored at the inode <b>726</b> in the volume <b>724</b> and is referenced by the record <b>720</b> in the TOC database <b>714</b>.</p><p id="p-0107" num="0106">Referring to <figref idref="DRAWINGS">FIG. <b>6</b></figref>, at block <b>612</b>, the method <b>600</b> includes inserting, by the object manager <b>160</b>, a second record into the TOC database, the second record including a second name marker and a second chapter database file handle, the second name marker indicating the second subrange and the second chapter database file handle referencing the third location. In <figref idref="DRAWINGS">FIG. <b>7</b></figref>, after the chapter database <b>138</b> is split, the object manager <b>160</b> may insert a record <b>722</b> into the TOC database <b>714</b>. The record <b>722</b> in the TOC database <b>714</b> includes a name marker &#x201c;K-Z&#x201d; indicating a second subrange of object names and further includes a chapter database file handle &#x3c;VID_<b>728</b>, InodeID_<b>730</b>&#x3e; that references an inode <b>730</b> (identified by InodeID_<b>730</b>) in a volume <b>728</b> (identified by VID_<b>728</b>). The chapter database <b>712</b> is stored at the inode <b>730</b> in the volume <b>728</b> and is referenced by the record <b>722</b> in the TOC database <b>714</b>.</p><p id="p-0108" num="0107">Referring to <figref idref="DRAWINGS">FIG. <b>6</b></figref>, at block <b>614</b>, the method <b>600</b> includes deleting, by the object manager <b>160</b>, the original chapter database. In <figref idref="DRAWINGS">FIG. <b>7</b></figref>, the two chapter databases <b>710</b> and <b>712</b> may replace the single chapter database <b>138</b>. Accordingly, the object manager <b>160</b> may delete the chapter database <b>138</b>.</p><p id="p-0109" num="0108">Each of the first location at which the original chapter database was stored, the second location at which the first chapter database is stored, and the third location at which the second chapter database is stored may be located in the same volume or different volumes as each other and/or may be located in the same data storage device or different data storage devices as each other. The object manager <b>160</b> may determine, based on conditions of the clustered network environment <b>100</b>, the first, second, and third locations. The conditions may include, for example, a function of the activity level of the overall cluster, storage load (amount of usage on each volume) of a volume, and the like.</p><p id="p-0110" num="0109">For example, the object manager <b>160</b> may select, based on an activity level of a set of volumes, a volume of the set of volumes as being the first, second, and/or third location. By selecting a volume that is not as active as other volumes in the set for storing the chapter database, the volume's activity level may be increased and the volume may participate in processing the workload. Accordingly, such selection may assist in distributing the workload across the cluster.</p><p id="p-0111" num="0110">In some examples, the object manager <b>160</b> may perform further actions to adjust the use of the split mechanism. For example, the object manager <b>160</b> may categorize a first set of chapter databases as red databases and categorize a second set of chapter databases as green databases. The type of categorizing (red, green, etc.) is by way of example only; other types of categorizations may be used for same effect herein. In an example, a red database does not accept new object names for storage. A red database instead splits itself into two partitioned chapter databases, each partitioned chapter database being categorized as a green database. A green database is ready to store new object names. If a green database grows and is split into two partitioned chapter databases, both of the partitioned chapter databases are categorized as red databases. Similar processes may be performed for merging chapter databases, if applicable.</p><p id="p-0112" num="0111">Referring back to <figref idref="DRAWINGS">FIG. <b>7</b></figref> as an example, the object manager <b>160</b> may categorize the chapter database <b>138</b> as a green database, which may be split into the two partitioned chapter databases <b>710</b> and <b>712</b>. The object manager <b>160</b> may categorize each of the two partitioned chapter databases <b>710</b> and <b>712</b> as a red database that does not accept new objects/object names. To use a red database, the object manager <b>160</b> may split the red database into two partitioned chapter databases that are categorized as green databases. For example, if the object manager <b>160</b> receives a request to store an object having an object name &#x201c;Fort Lauderdale&#x201d; into the object storage system, the object manager <b>160</b> may split the chapter database <b>710</b> into two partitioned chapter databases and categorize them as green databases. The object manager <b>160</b> may store the object name into the appropriate partitioned chapter database that covers a range of object names including &#x201c;Fort Lauderdale&#x201d; (e.g., &#x201c;A-C&#x201d;). Each of the two partitioned chapter databases may accept the storage of object names and may split and/or merge at a later point, as discussed in the present disclosure.</p><p id="p-0113" num="0112">The use of the red and green categorization may provide for increased locality between the chapter database and the corresponding objects. For example, if an original chapter database is split in accordance with the red and green chapter database categorization, the original chapter database is effectively split into four partitioned chapter databases instead of the initial two partitioned chapter databases as discussed relative to <figref idref="DRAWINGS">FIG. <b>6</b></figref>.</p><p id="p-0114" num="0113">Accordingly, the original chapter database is partitioned into the two red chapter databases (partitioned databases) and the two green chapter databases (partitioned databases), resulting in each of the partitioned databases being about half the size that it would otherwise be. At each stage, one partitioned chapter database may be allocated locally, and one partitioned chapter database may be allocated remotely. For example, when a large green chapter database is split into four smaller green chapter databases, two of those green chapter databases may still be located on the same volume (with one-hundred percent local content) as the objects referenced by the original chapter database and two of those green chapter databases may be located on a different volume (with zero percent local content) as the objects referenced by the original chapter database.</p><p id="p-0115" num="0114">Each of the green chapter databases may be, for example, a quarter full and ready to absorb three times as much new content as it already contains. Accordingly, a green chapter database may grow substantially larger before splitting again. Before the green chapter database is split again, the object manager <b>160</b> may allocate inodes local to the chapter database for storing the new objects. Accordingly, the new content may be one hundred percent local to the objects. Accordingly, when these four new green databases (partitioned databases) have all become full, two of these green databases may contain one-hundred percent local content and the other two green databases may contain seventy-five percent local content&#x2014;collectively representing 87.5% locality.</p><p id="p-0116" num="0115">In some examples, when the object manager <b>160</b> splits an original chapter database into two partitioned chapter databases, it may be unnecessary to allocate one partitioned chapter database remotely. For example, under some circumstances, both partitioned chapter databases may be stored at inodes in the same volume as the one storing the objects, yielding one-hundred percent local content for both partitioned chapter databases. The object manager <b>160</b> may determine to store both partitioned chapter databases locally, for example, if the object manager <b>160</b> determines that the overall level of ingest activity on all nodes is very high (e.g., there is a good probability that other chapter databases will independently also choose to grow locally), keeping overall traffic distributed among all nodes.</p><p id="p-0117" num="0116">In some examples, chapter databases may have a small number of records. When a chapter database becomes too small (e.g., by satisfying a merge threshold), it may be merged with another small chapter database. For example, the object manager <b>160</b> may compare the number of records included in a chapter database with the number of records included in the TOC database. If the object manager <b>160</b> determines that the chapter database's record count has less than a percentage threshold (e.g., about fifty percent or sixty-six percent) of the TOC database's record count, then the object manager <b>160</b> may determine to merge the chapter database with another chapter database. It should be understood that this is an example, and the object manager <b>160</b> may merge sibling database for other reasons. The merged chapter databases may be immediate siblings of each other within the namespace and may cover a consecutive and discrete range of object names. The object manager <b>160</b> may merge the two peer chapter databases together, create a combined chapter database, and write all the records from the two peer chapter databases into the combined chapter database. Accordingly, the object manager <b>160</b> may remove the two peer chapter databases from the object storage system and update the TOC database by removing those records containing references to the two peer chapter databases. Additionally, the object manager <b>160</b> may insert a new record including a name marker indicating a range of objects covered by both the peer chapter databases and further including a chapter database file handle that references the combined chapter database. After these actions, the TOC database includes one fewer record than before the merger.</p><p id="p-0118" num="0117"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a flow diagram of a method <b>800</b> of merging two peer chapter databases into a single combined chapter database in accordance with one or more aspects of the present disclosure. Blocks of the method <b>800</b> can be executed by a computing device (e.g., a processor, processing circuit, the storage operating system <b>208</b>, the network adapter <b>210</b>, the cluster access adapter <b>212</b>, the storage adapter <b>214</b>, and/or other suitable component, such as of the node <b>202</b> in <figref idref="DRAWINGS">FIG. <b>2</b></figref>). For example, the data storage system (e.g., data storage system <b>102</b>, <b>104</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref> or the data storage system <b>200</b> in <figref idref="DRAWINGS">FIG. <b>2</b></figref>) may utilize one or more components, such as the nodes <b>116</b>, <b>118</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the network modules <b>120</b>, <b>122</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the disk modules <b>124</b>, <b>126</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the data storage devices <b>128</b>, <b>130</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, to execute the blocks of the method <b>800</b>. As illustrated, the method <b>800</b> includes a number of enumerated blocks, but embodiments of the method <b>800</b> may include additional blocks before, after, and in between the enumerated blocks. In some embodiments, one or more of the enumerated blocks may be omitted or performed in a different order.</p><p id="p-0119" num="0118">At block <b>802</b>, the method <b>800</b> includes determining, by an object manager, that a first chapter database including a first set of records satisfies a first merge threshold, the first chapter database being stored at a first location, and the first chapter database being referenced by a TOC database and covering a first range of object names.</p><p id="p-0120" num="0119">At block <b>804</b>, the method <b>800</b> includes determining, by the object manager, that a second chapter database including a second set of records satisfies a second merge threshold, the second chapter database being stored at a second location, and the second chapter database being referenced by the TOC database and covering a second range of object names. The first and the second merge thresholds may be the same or different from each other.</p><p id="p-0121" num="0120">At block <b>806</b>, the method <b>800</b> includes merging, by the object manager, the first and second chapter databases into a combined chapter database, the combined chapter database including the first and second sets of records and covering the first and second ranges of object names, and the combined chapter database being referenced by the TOC database and stored at a third location. The object manager <b>160</b> may determine that the third location is at an inode within a volume that is underutilized and/or has a large amount of unused storage compared to other volumes in the cluster.</p><p id="p-0122" num="0121">At block <b>808</b>, the method <b>800</b> includes updating, by the object manager, a first record in the TOC database that references the first chapter database to store a name marker and a first chapter database file handle, the name marker indicating the first and second ranges of objects, and the first chapter database file handle referencing the third location. In some examples, updating the first record in the TOC database may include removing the first record and inserting a record in the TOC database, the inserted record including the name marker and the first chapter database file handle. For example, the first chapter database has been merged with the second chapter database, and the first record is no longer needed and accordingly is removed.</p><p id="p-0123" num="0122">At block <b>810</b>, the method <b>800</b> includes removing, by the object manager, a second record in the TOC database, the second record including a second chapter database file handle that references the second location. The second chapter database has been merged with the first chapter database, and the second record is no longer needed and accordingly is removed.</p><p id="p-0124" num="0123">Each of the first location at which the first chapter database was stored, the second location at which the second chapter database was stored, and the third location at which the combined chapter database is stored may be located in the same volume or different volumes as each other and/or may be located in the same data storage device or different data storage devices as each other. The object manager <b>160</b> may determine, based on conditions of the clustered network environment <b>100</b>, the first, second, and third locations. The conditions may include, for example, a function of the activity level of the overall cluster, storage load (amount of usage on each volume) of a volume, and the like.</p><p id="p-0125" num="0124">For example, the object manager <b>160</b> may select, based on an activity level of a set of volumes, a volume of the set of volumes as being the first, second, and/or third location. By selecting a volume that is not as active as other volumes in the set for storing the chapter database, the volume's activity level may be increased and the volume may participate in processing the workload. Accordingly, such selection may assist in distributing the workload across the cluster.</p><p id="p-0126" num="0125">Architecturally, it may be desirable for chapter databases to have approximately as many records as each other. If any chapter database has grown to the point where it is substantially larger than its peers, then there is a risk that this chapter database may become overly busy. For example, if a chapter database stores a larger percentage of object names than its peers, there is a greater probability that the chapter database will likewise receive a proportionally higher amount of work to do. Similarly, a large chapter database may represent a resiliency concern in that rebuilding a large database after a failure is more time-consuming that rebuilding a small database. A failure may occur, for example, if the chapter database has a problem with its index.</p><p id="p-0127" num="0126">Likewise, it may be desirable for the TOC database to have approximately as many records as the chapter databases has and for similar reasons as discussed above. In some examples, the object manager <b>160</b> may desire to maintain a square root relationship between the TOC database and the chapter databases. For example, if the overall collective namespace includes N objects, then the object manager <b>160</b> may desire for the namespace to be stored among approximately sqrt(N) separate chapter databases, each containing approximately sqrt(N) object-name records. To illustrate with a numeric example, if the object storage system stores a million objects (1,000,000), the object manager <b>160</b> may determine that the TOC database should store approximately a thousand (1,000) records (the square root of one million is one thousand) and each chapter database should store approximately a thousand (1,000) records, resulting in all the databases in the object storage system being approximately the same size.</p><p id="p-0128" num="0127">Some degree of variability from the square root relationship may apply to reduce the number of split and/or merge operations, which are typically expensive operations. For example, rather than split a chapter database when it reaches 1,000 records (as one example number of records), the object manager <b>160</b> may allow the chapter database to grow up to 1,500 records (as one example number of records), exceeding the square root relationship by a substantial margin. It may be desirable to allow an original chapter database to grow past the square root number (e.g., 1,000 records) to reduce the number of times a resulting partitioned chapter database is merged with another chapter database and/or give the original chapter database time to grow before the split. In another example, rather than merge two peer chapter databases when they reach below 500 records (as one example number of records), the object manager <b>160</b> may allow the chapter database to get down to fifty to seventy percent of the merge threshold, before merging the chapter database with another chapter database. For example, once the two peer chapter databases are merged into a combined chapter database, it may be likely that the combined chapter database satisfies the split threshold.</p><p id="p-0129" num="0128">A record may be inserted into the TOC database when a chapter database grows large enough to be split into two peer chapter databases, and a record may be removed from the TOC database when two chapter databases are merged into a single chapter database. Accordingly, the TOC database may be slow to change, and it may be desirable for a network module (e.g., the network module <b>120</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref>) to cache records from the TOC database to assist the network module efficiency process future requests associated with objects.</p><p id="p-0130" num="0129">The split and merger operations discussed, for example, in relation to <figref idref="DRAWINGS">FIGS. <b>6</b>, <b>7</b>, and <b>8</b></figref> may be expensive operations that occur with less frequency as the overall namespace grows. For example, a database with ten billion objects may have approximately 100,000 separate chapter databases, each with approximately 100,000 records. The object manager <b>160</b> may determine to not split a chapter database unless it grows to a record threshold (e.g., about 130,000 to about 150,000 records) having a significant amount of new content. While a smaller namespace (e.g., one with about 10,000 names) may have only about one hundred chapter databases, each including one hundred records, the object manager <b>160</b> may split the chapter database again after receiving, for example, thirty new object names. To constrain the costs of these divisions when the namespace is small, the object manager <b>160</b> may restrict a chapter database from splitting until it has at least about a first threshold number (e.g., about 1,000) of object names. Additionally or alternatively, to constrain the costs of these mergers, the object manager <b>160</b> may restrict chapter databases from merging until they have fall below a second number (e.g., about 500) of object names. In this way, the object manager <b>160</b> may limit the number of split and merge operations that a small namespace database would normally suffer, in circumstances where the collective namespace is small enough that a single chapter database may be capable of accomplishing all namespace-related tasks on its own. For example, a 1,000-record database may easily stay in a node's memory and may be manipulated very quickly.</p><p id="p-0131" num="0130">In some examples, a host device may transmit a request to the data storage system to perform an operation on an object stored in the object storage system. The TOC database and the one or more chapter databases referenced by the TOC database may enable the object storage system to maintain objects and the names that identify them in an efficient and effective manner.</p><p id="p-0132" num="0131"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a flow diagram of a method <b>900</b> of performing an operation on an object in accordance with one or more aspects of the present disclosure. Blocks of the method <b>900</b> can be executed by a computing device (e.g., a processor, processing circuit, the storage operating system <b>208</b>, the network adapter <b>210</b>, the cluster access adapter <b>212</b>, the storage adapter <b>214</b>, and/or other suitable component, such as of the node <b>202</b> in <figref idref="DRAWINGS">FIG. <b>2</b></figref>). For example, the data storage system (e.g., data storage system <b>102</b>, <b>104</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref> or the data storage system <b>200</b> in <figref idref="DRAWINGS">FIG. <b>2</b></figref>) may utilize one or more components, such as the nodes <b>116</b>, <b>118</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the network modules <b>120</b>, <b>122</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the disk modules <b>124</b>, <b>126</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the data storage devices <b>128</b>, <b>130</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, to execute the blocks of the method <b>900</b>. As illustrated, the method <b>900</b> includes a number of enumerated blocks, but embodiments of the method <b>900</b> may include additional blocks before, after, and in between the enumerated blocks. In some embodiments, one or more of the enumerated blocks may be omitted or performed in a different order.</p><p id="p-0133" num="0132"><figref idref="DRAWINGS">FIG. <b>5</b></figref> will be discussed relative to <figref idref="DRAWINGS">FIG. <b>9</b></figref> (and vice versa) to better understand concepts related to performing an operation on an object in an object storage system.</p><p id="p-0134" num="0133">In <figref idref="DRAWINGS">FIG. <b>9</b></figref>, at block <b>902</b>, the method <b>900</b> includes receiving, by an object manager <b>160</b>, a request to perform an operation on an object having an object name, the object being stored in an object storage system that includes a first database of a first type and one or more databases of a second type. The first type may be a TOC database, and the second type may be a chapter database. The first database may be a cache storing one or more records from the TOC database. In <figref idref="DRAWINGS">FIG. <b>5</b></figref>, the network module <b>120</b> may receive the request to perform the operation. The operation may be, for example, a write operation that writes data to the object, a read operation that reads data from the object, or a delete operation that deletes the object from the object storage system.</p><p id="p-0135" num="0134">Referring to <figref idref="DRAWINGS">FIG. <b>9</b></figref>, at block <b>904</b>, the method <b>900</b> includes identifying, by the object manager, a first record stored in the first database, the first record including a name marker indicating a range of object names covered by a second database of the second type and a first file handle referencing a first location at which the second database is stored, and the range of object names including the object name. In <figref idref="DRAWINGS">FIG. <b>5</b></figref>, the network module <b>120</b> may search the TOC database <b>136</b> for a record including a name marker that indicates a range of object names including the object name. The record <b>516</b> includes a name marker &#x201c;*&#x201d;, which indicates that the corresponding chapter database <b>138</b> covers the range of object names including the object name. The chapter database file handle references a location at which the chapter database <b>138</b> is stored. Based on the location, the network module <b>120</b> may determine that the chapter database <b>138</b> is stored at the data storage device <b>130</b>.</p><p id="p-0136" num="0135">In some examples, the network module <b>120</b> may be unable to access a data storage device or a chapter database without an intermediary (e.g., a disk module that is coupled to and accesses the chapter database). In <figref idref="DRAWINGS">FIG. <b>5</b></figref>, the network module <b>120</b> may determine that the disk module <b>126</b> accesses the data storage device <b>130</b> and accordingly may transmit the request to perform the operation to the disk module <b>126</b>.</p><p id="p-0137" num="0136">Referring to <figref idref="DRAWINGS">FIG. <b>9</b></figref>, at block <b>906</b>, the method <b>900</b> includes identifying, by the object manager, a second record stored in the second database, the second record including the object name and including a second file handle referencing a second location at which the object is stored. In <figref idref="DRAWINGS">FIG. <b>5</b></figref>, a record <b>530</b> in the chapter database <b>138</b> includes the object name <b>406</b> (&#x201c;OBName_<b>406</b>&#x201d;) of the object <b>404</b> and an object file handle &#x3c;VID_<b>134</b>, InodeID_<b>526</b>&#x3e; that references the object <b>404</b>. The record <b>530</b> may correspond to the second record stored in the second chapter database.</p><p id="p-0138" num="0137">At block <b>908</b>, the method <b>900</b> includes performing, by the object manager, the operation on the object in accordance with the request. For example, if the operation is a write operation, the corresponding disk module may write data to the object. If the operation is a read operation, the corresponding disk module may read data from the object. If the operation is a delete operation, the corresponding disk module may delete data from the object. If the operation is a delete operation, the corresponding disk module may remove the object from the object storage system.</p><p id="p-0139" num="0138">The present embodiments can take the form of an entirely hardware embodiment, an entirely software embodiment, or an embodiment containing both hardware and software elements. Accordingly, it is understood that any operation of the computing systems of computing architecture <b>100</b> may be implemented by the respective computing system using corresponding instructions stored on or in a non-transitory computer readable medium accessible by the processing system. For the purposes of this description, a tangible computer-usable or computer-readable medium can be any apparatus that can store the program for use by or in connection with the instruction execution system, apparatus, or device. The medium may include non-volatile memory including magnetic storage, solid-state storage, optical storage, cache memory, and RAM.</p><p id="p-0140" num="0139">Thus, the present disclosure provides a system, method, and machine-readable storage medium for processing an operation on an object in a clustered networking environment. In some embodiments, the method includes receiving, by an object manager, a request to perform an operation on an object having an object name, the object being stored in an object storage system that includes a first database of a first type and one or more databases of a second type; identifying, by the object manager, a first record stored in the first database, the first record including a name marker indicating a range of object names covered by a second database of the second type and a first file handle referencing a first location at which the second database is stored, and the range of object names including the object name; identifying, by the object manager, a second record stored in the second database, the second record including the object name and including a second file handle referencing a second location at which the object is stored; and performing, by the object manager, the operation on the object in accordance with the request.</p><p id="p-0141" num="0140">In some examples, the operation may be at least one of a write operation, a read operation, or a delete operation. In some examples, the method also includes storing the object at the second location in response to a request to store the object in the object storage system. In some examples, the method also includes partitioning the second database storing a plurality of records into a third database and a fourth database in response to a determination that a size of the second database exceeds a split threshold, the third database storing a first subset of the plurality of records, and the fourth database storing a second subset of the plurality of records. In some examples, the method also includes updating the first record in the first database in response to a determination that the second database has been partitioned into a third database and a fourth database, the updated first record including an updated name marker and an updated file handle, the updated name marker indicating that the third database of the second type covers a subset of the range of object names, and the updated file handle referencing a third location at which the third database is stored.</p><p id="p-0142" num="0141">In some examples, the method also includes inserting a third record into the first database in response to a determination that the second database has been partitioned into a third database and a fourth database, the third record including a second name marker and a third file handle, the second name marker indicating that the third database covers a subset of the range of object names, and the third file handle referencing a third location at which the third database is stored. In some examples, the one or more databases of the second type represents a flat namespace storing one or more object names. In some examples, the second database and the object are stored at a same volume.</p><p id="p-0143" num="0142">In yet further embodiments, the non-transitory machine-readable medium has instructions for performing the method of processing an operation on an object, including machine executable code, which when executed by at least one machine, causes the machine to: receive, by an object manager, a request to perform the operation on the object having an object name, wherein an object storage system includes a first database of a first type and a second database of a second type; search, by the object manager, the first database for a first record including a name marker and a first file handle, the name marker indicating a range of object names covered by the second database, the first file handle referencing the second database, and the range of object names including the object name; search, by the object manager, the second database for a second record including the object name and including a second file handle, the second file handle referencing the object; and perform, by the object manager, the operation on the object in accordance with the request.</p><p id="p-0144" num="0143">In some examples, the operation is at least one of a write operation, a read operation, or a delete operation. In some examples, the second database and the object are stored at a common volume. In some examples, the non-transitory machine-readable medium has instructions for performing the method of processing an operation on an object, including machine executable code, which when executed by at least one machine, causes the machine to merge the second database with a third database to create a fourth database in response to a determination that a size of the second database is less than a first merge threshold and a size of the third database is less than a second merge threshold. The first and second merge thresholds may be the same or different from each other. In some examples, the non-transitory machine-readable medium has instructions for performing the method of processing an operation on an object, including machine executable code, which when executed by at least one machine, causes the machine to partition the second database storing a plurality of records into a third database and a fourth database in response to a determination that a size of the second database exceeds a split threshold, wherein the third database stores a first subset of the plurality of records, and the fourth database stores a second subset of the plurality of records. In some examples, the non-transitory machine-readable medium has instructions for performing the method of processing an operation on an object, including machine executable code, which when executed by at least one machine, causes the machine to remove the second database from the object storage system after the second database is partitioned into a third database and a fourth database.</p><p id="p-0145" num="0144">In yet further embodiments, the computing device includes a memory containing a machine-readable medium comprising machine executable code having stored thereon instructions for performing a method of storing an object in an object storage system and a processor coupled to the memory. The processor is configured to execute the machine executable code to: receive, by an object manager, a request to store the object in the object storage system, the object have an object name, and the object storage system including a first database of a first type and one or more databases of a second type; identify, by the object manager, a first record stored in the first database, the first record including a name marker indicating a range of object names covered by a second database of the second type and a chapter database file handle referencing a first location at which the second database is stored, and the range of object names including the object name; store, by the object manager, the object at a second location; and insert, by the object manager, a second record into the second database, the second record including the object name and an object file handle, and the object file handle referencing the second location.</p><p id="p-0146" num="0145">In some examples, the processor may be configured to execute the machine executable code to allocate, by the object manager, storage at the second location for storing the object. In some examples, the second database and the object are stored at different inodes within a same volume. In some examples, the second database and the object are stored at different volumes. In some examples, the one or more databases of the second type represents a flat namespace storing one or more object names.</p><p id="p-0147" num="0146">The foregoing outlines features of several embodiments so that those skilled in the art may better understand the aspects of the present disclosure. Those skilled in the art should appreciate that they may readily use the present disclosure as a basis for designing or modifying other processes and structures for carrying out the same purposes and/or achieving the same advantages of the embodiments introduced herein. Those skilled in the art should also realize that such equivalent constructions do not depart from the spirit and scope of the present disclosure, and that they may make various changes, substitutions, and alterations herein without departing from the spirit and scope of the present disclosure.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A method performed by an object storage system, the method comprising:<claim-text>maintaining a first database and a second database, wherein, for a first object being stored in the object storage system,<claim-text>the first database stores a first record, which includes a first name marker indicating a range of object names covered by the second database and a first volume identifier referencing a first volume and a first inode, within the first volume, indicating a first location at which the second database is stored, and the range of object names including an object name of the first object, and</claim-text><claim-text>the second database stores a second record, the second record including the object name and including a second volume identifier referencing a second volume and a second inode, within the second volume, indicating a second location at which the first object is stored in the object storage system;</claim-text></claim-text><claim-text>determining that the second database satisfies a split threshold; and</claim-text><claim-text>partitioning a plurality of records of the second database into a first subset of records and a second subset of records in response to the split threshold being satisfied.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein partitioning the plurality of records of the second database comprises:<claim-text>storing a third database including the first subset of records and covering a first sub range of the range of object names, the third database storing the second record; and</claim-text><claim-text>storing a fourth database including the second subset of records and covering a second sub range of the range of object names.</claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, further comprising:<claim-text>updating the first record to store a second name marker indicating the first sub range and to reference a third inode, within the first volume, indicating a third location at which the third database is stored.</claim-text></claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, further comprising:<claim-text>inserting a third record into the first database, the third record storing a third name marker indicating the second sub range and referencing a fourth inode, within the first volume, indicating a fourth location at which the fourth database is stored.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>deleting the second database after partitioning the second database and generating at least a third database.</claim-text></claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the second database represents a flat namespace storing a plurality of object names.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>wherein determining that the second database satisfies the split threshold includes determining that the plurality of records is greater than a threshold quantity of records.</claim-text></claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. A method performed by an object storage system, the method comprising:<claim-text>accessing a first database and a second database, wherein, for a first object being stored in the object storage system,<claim-text>the first database stores a first record, which includes a first name marker indicating a first range of object names covered by the second database and a first volume identifier referencing a first volume and a first inode, within the first volume, indicating a first location at which the second database is stored, and the first range of object names including an object name of the first object, and</claim-text><claim-text>the second database stores a second record, the second record including the object name and including a second volume identifier referencing a second volume and a second inode, within the second volume, indicating a second location at which the first object is stored in the object storage system;</claim-text></claim-text><claim-text>determining that the second database satisfies a first merge threshold; and</claim-text><claim-text>merging the second database into a combined database in response to the first merge threshold being satisfied.</claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein merging the second database into the combined database comprises:<claim-text>merging the second database with a third database to create the combined database in response to a determination that a size of the second database is less than the first merge threshold and a size of the third database is less than a second merge threshold, the third database and the combined database being chapter databases.</claim-text></claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, further comprising:<claim-text>determining that a third database satisfies a second merge threshold; and</claim-text><claim-text>merging the second database and the third database to create the combined database in response to the second merge threshold being satisfied.</claim-text></claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, further comprising:<claim-text>determining that a third database satisfies a second merge threshold, wherein the third database covers a second range of object names; and</claim-text><claim-text>merging the second database and the third database to create the combined database in response to the second merge threshold being satisfied, wherein the combined database covers the first range of object names and the second range of object names.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, further comprising:<claim-text>updating the first record to store a second name marker indicating the first range of object names and the second range of object names.</claim-text></claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The method of <claim-ref idref="CLM-00012">claim 12</claim-ref>, further comprising:<claim-text>removing a third record from the first database, the third record corresponding to the third database.</claim-text></claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the second database represents a flat namespace storing a plurality of object names.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, further comprising:<claim-text>caching a plurality of further records of a table-of-contents (TOC) database into the first database.</claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. A method performed by an object storage system, the method comprising:<claim-text>accessing a table-of-contents (TOC) database and a first chapter database, wherein, for a first object being stored in the object storage system,<claim-text>the TOC database stores a first record, which includes a first name marker indicating a range of object names covered by the first chapter database and a first volume identifier referencing a first volume and a first inode, within the first volume, indicating a first location at which the first chapter database is stored, and the range of object names including an object name of the first object, and</claim-text><claim-text>the first chapter database stores a second record, the second record including the object name and including a second volume identifier referencing a second volume and a second inode, within the second volume, indicating a second location at which the first object is stored in the object storage system;</claim-text></claim-text><claim-text>determining that the first chapter database satisfies a split threshold; and</claim-text><claim-text>partitioning a plurality of records of the first chapter database into a first subset of records and a second subset of records in response to the split threshold being satisfied.</claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The method of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein partitioning the plurality of records of the first chapter database comprises:<claim-text>storing a second chapter database including the first subset of records and covering a first sub range of the range of object names, the second chapter database storing the second record; and</claim-text><claim-text>storing a third chapter database including the second subset of records and covering a second sub range of the range of object names.</claim-text></claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The method of <claim-ref idref="CLM-00017">claim 17</claim-ref>, further comprising:<claim-text>updating the first record to store a second name marker indicating the first sub range and to reference a third inode, within the first volume, indicating a third location at which the second chapter database is stored.</claim-text></claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The method of <claim-ref idref="CLM-00018">claim 18</claim-ref>, further comprising:<claim-text>inserting a third record into the TOC database, the third record storing a third name marker indicating the second sub range and referencing a fourth inode, within the first volume, indicating a fourth location at which the third chapter database is stored.</claim-text></claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The method of <claim-ref idref="CLM-00016">claim 16</claim-ref>, further comprising:<claim-text>deleting the first chapter database after partitioning the first chapter database and generating at least a second chapter database.</claim-text></claim-text></claim></claims></us-patent-application>