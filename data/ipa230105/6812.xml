<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230006813A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230006813</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17856629</doc-number><date>20220701</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>L</subclass><main-group>9</main-group><subgroup>08</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>28</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>21</main-group><subgroup>62</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>L</subclass><main-group>9</main-group><subgroup>085</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>285</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>21</main-group><subgroup>6227</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">ENCRYPTED INFORMATION RETRIEVAL</invention-title><us-related-documents><us-provisional-application><document-id><country>US</country><doc-number>63218120</doc-number><date>20210702</date></document-id></us-provisional-application></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Google LLC</orgname><address><city>Mountain View</city><state>CA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Fox-Epstein</last-name><first-name>Eli Simon</first-name><address><city>Los Angeles</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Yeo</last-name><first-name>Kevin Wei Li</first-name><address><city>New York City</city><state>NY</state><country>US</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">Methods, systems, and computer readable medium facilitating encrypted information retrieval. Methods can include receiving a batch of queries that includes queries to special buckets in each database shard. Query results responsive to the batch of queries are transmitted to the client device. The query results includes server-encrypted secret shares obtained from the special buckets. Client-encrypted versions of the secret shares are received. A full set of server-encrypted secret shares is transmitted to the client device, which is encrypted by the client device to create a full set of client-server-encrypted secret shares. The client device is classified based on how many of the secret shares are included in both of the client-encrypted secret shares received from the client device and the full set of client-server-encrypted secret shares received from the client device.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="94.83mm" wi="158.75mm" file="US20230006813A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="188.38mm" wi="135.72mm" orientation="landscape" file="US20230006813A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="250.02mm" wi="201.76mm" file="US20230006813A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="175.77mm" wi="148.51mm" file="US20230006813A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="242.32mm" wi="182.29mm" file="US20230006813A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="190.08mm" wi="148.51mm" file="US20230006813A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="181.61mm" wi="133.35mm" orientation="landscape" file="US20230006813A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading><p id="p-0002" num="0001">This application claims the benefit under 35 U.S.C. &#xa7; 119(e) of U.S. patent application Ser. No. 63/218,120, entitled &#x201c;ENCRYPTED INFORMATION RETRIEVAL,&#x201d; filed Jul. 2, 2021. The disclosure of the foregoing application is incorporated herein by reference in its entirety for all purposes.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">BACKGROUND</heading><p id="p-0003" num="0002">This specification relates to data processing and information retrieval.</p><p id="p-0004" num="0003">User devices and content platforms such as content distributors can query content providers in order to retrieve information stored by the content providers. However, there can be situations when it is not in the interest of the content platforms to reveal any details to the content providers about what information is being queried. In other situations, it may not be in the interest of the content providers to reveal any details to the content platforms about other information that is stored on the computing systems of the content providers.</p><heading id="h-0003" level="1">SUMMARY</heading><p id="p-0005" num="0004">In general, one innovative aspect of the subject matter described in this specification can be embodied in methods that include the actions of receiving, at a server device and from a client device, a batch of queries that includes queries to special buckets in each database shard, among multiple database shards, being queried by the batch of queries, wherein the special buckets include server-encrypted secret shares generated by the server; generating, by the server device, a set of query results responsive to the batch of queries, wherein the set of query results includes the server-encrypted secret shares obtained from the special buckets queried by the batch of queries; transmitting, by the server device and to the client device, the set of query results; receiving, at the server device and from the client device, client-encrypted secret shares, wherein the client-encrypted secret shares are client encrypted versions of the secret shares that were included in the set of query results transmitted to the client device; transmitting, by the server device and to the client device, a full set of server-encrypted secret shares, wherein the full set of server-encrypted secret shares includes more server-encrypted secret shares than the set of query results; receiving, at the server device and from the client device, a full set of client-server-encrypted secret shares, wherein the full set of client-server-encrypted secret shares are client encrypted versions of the full set of server-encrypted secret shares that were transmitted to the client device; determining, by the server device, how many of the secret shares are included in both of the client-encrypted secret shares received from the client device and the full set of client-server-encrypted secret shares received from the client device; and classifying, by the server device, the client device based on how many of the secret share are included in both of the client-encrypted secret shares received from the client device and the full set of client-server-encrypted secret shares received from the client device.</p><p id="p-0006" num="0005">Other implementations of this aspect include corresponding apparatus, systems, and computer programs, configured to perform the aspects of the methods, encoded on computer storage devices. These and other implementations can each optionally include one or more of the following features.</p><p id="p-0007" num="0006">Methods can include removing, by the server device, the server decryption from the full set of client-server-encrypted secret shares received from the client device to obtain a full set of client-encrypted secret shares. Determining how many of the secret shares are included in both of the client-encrypted secret shares received from the client device and the full set of client-server-encrypted secret shares received from the client device can include comparing the client-encrypted secret shares received from the client device to the full set of client-encrypted secret shares obtained by removing the server decryption from the full set of client-server-encrypted secret shares.</p><p id="p-0008" num="0007">Classifying the client device can include determining that the client device is malicious based on the comparison indicating that fewer than a required number of the secret shares are included in both of the client-encrypted secret shares received from the client device and the full set of client-encrypted secret shares obtained by removing the server decryption from the full set of client-server-encrypted secret shares.</p><p id="p-0009" num="0008">Methods can include receiving, from the client device, a set of client-encrypted entity identifiers; encrypting, by the server, the set of client-encrypted entity identifiers to create a set of sever-client-encrypted identifiers; and transmitting, by the server, the set of server-client-encrypted identifiers to the client device.</p><p id="p-0010" num="0009">Methods can include generating a partitioned database in which a database is partitioned into the multiple database shards each having a shard identifier that logically distinguishes each database shard from other database shards, and database entries in each database shard are partitioned into buckets having a bucket identifier that logically distinguishes each bucket in the shard from other buckets in the shard.</p><p id="p-0011" num="0010">Methods can include adding a special bucket to each shard; including, in each special bucket, special data that is known to the server device, but not the client device; and after each query to a given shard, updating the special data in the special bucket of the given shard to maintain privacy of the information contained in the special bucket of the given shard.</p><p id="p-0012" num="0011">Methods can include generating, by the client device, a set of queries using the set of server-client-encrypted identifiers; generating, by the client device, a set of decryption keys using the set of server-client-encrypted identifiers; encrypting, by the client device, the set of queries to create the batch of client-encrypted queries.</p><p id="p-0013" num="0012">The subject matter described in this specification can be implemented in particular embodiments so as to realize one or more of the following advantages. The techniques and methods described in this specification describe techniques for retrieving data from databases while preserving both client and server privacy. This allows a client to query a server without revealing any details to the server about the data that is being queried. Simultaneously, when the client is querying the server does not reveal any details regarding contents of the database that are not queried by the client. In contrast existing techniques of querying a server generally includes encrypting the entire server database and providing the encrypted database to the client for querying. This approach requires significantly more computational resources since the size of the database is generally large. Other approaches of querying the server includes providing an index of the database to the client and receiving a selection of indexes from the client that does not allow for server and client privacy. Furthermore, the subject matter of this application can ensure the client devices are adhering to the agreed upon protocol, for example, by ensuring that the client device is submitting the appropriate number of padding queries, which helps ensure that privacy of the queried data is maintained.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram of an example environment in which content is distributed and presented to a user device.</p><p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a swim lane diagram of an example process of retrieving content by a client from a server.</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a flow diagram of an example process of partitioning the server database.</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a flow diagram of an example process of generating a query from server encrypted identifiers.</p><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a flow diagram of an example process of processing queries by a server.</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a block diagram of an example computer system.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0005" level="1">DETAILED DESCRIPTION</heading><p id="p-0020" num="0019">This specification relates to data processing and information retrieval. In particular, the techniques and methods described in this specification describe techniques for retrieving data from databases while preserving both client and server privacy. For example, if the client queries a server database, the client does not reveal any details to the server about the data that is being queried (also referred to as client query privacy). Simultaneously the server does not reveal to the client any details regarding contents of the database that are not queried by the client (also referred to as server database privacy). These techniques enable batch processing of queries to provide for a more efficient information retrieval system that also protects user privacy. For example, user privacy is protected by ensuring that a server being queried cannot learn information about the users that a client is querying the server about, and also prevents the client from learning other information about the users that may be stored by the server.</p><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram of an example environment <b>100</b> in which content is distributed and presented to a user device. The example environment <b>100</b> includes a network <b>102</b>, such as a local area network (LAN), a wide area network (WAN), the Internet, or a combination thereof. The network <b>102</b> connects content platforms <b>106</b>, and content providers <b>110</b>. The example environment <b>100</b> may include many different content providers <b>110</b>, content platforms <b>106</b>, and user devices <b>104</b>.</p><p id="p-0022" num="0021">A user device <b>104</b> is an electronic device that is capable of requesting and receiving content over the network <b>102</b>. Example user devices <b>104</b> include personal computers, mobile communication devices, digital assistant devices, and other devices that can send and receive data over the network <b>102</b>. A user device <b>104</b> typically includes an operating system <b>112</b> that is primarily responsible for managing the device hardware and software resources such as applications. The user device <b>104</b> also includes a device storage <b>120</b> to store data temporarily or permanently based on the particular implementation, application, and use case. A user device <b>104</b> typically includes user applications <b>116</b> and <b>117</b>, such as a web browser or an email client, to facilitate the sending and receiving of data over the network <b>102</b>, but native applications executed by the user device <b>104</b> can also facilitate the sending and receiving of content over the network <b>102</b>. Examples of content presented at a user device <b>104</b> include webpages, word processing documents, portable document format (PDF) documents, images, videos, and search results pages and digital ads.</p><p id="p-0023" num="0022">A content platform <b>106</b> is a computing platform that enables distribution of content. Example content platforms <b>106</b> include search engines, social media platforms, news platforms, data aggregator platforms, or other content sharing platforms. Each content platform <b>106</b> may be operated by a content platform service provider. The content platform <b>106</b> may present content provided by one or more content providers <b>110</b>. In the above example, the news platform may present content created by different authors and provided by one or more content providers <b>110</b>. As another example, the content platform <b>106</b> may be a data aggregator platform that does not publish any of its own content, but aggregates and presents news articles provided by different news websites (i.e., content providers <b>110</b>).</p><p id="p-0024" num="0023">In some implementations, the content platform <b>106</b> can distribute digital content to one or more users. For example, the content platform <b>106</b> can let one or more users subscribe to and/or register with the content platform <b>106</b>. In response, the content platform <b>106</b> can retrieve digital content from the content providers <b>110</b> and provide the retrieved content to the user devices <b>104</b> of users. The content provider <b>110</b> includes a data storage device (also referred to as a database) that stores digital content in the form of key-value pairs. For example, the database of the content provider <b>110</b> can include multiple keys and for each key, a corresponding value that is retrieved by the content platform <b>106</b>.</p><p id="p-0025" num="0024">In some implementations, the content platform <b>106</b> can assign an identifier to each user so that the content platform can distinguish between the users. In some implementations, the content platform <b>106</b> can use information provided by the one or more users and/or the user devices as the unique identifier. For example, the content platform <b>106</b> can use, as the unique identifier, an electronic mail identifier (email id) provided by a user, a cell phone number provided by a user, or a media access control (MAC) address of the user device <b>104</b> of the user. In some implementations, the content platform <b>106</b> can assign an identifier to a group of two or more users based on the characteristics of the users in the group of users. For example, the content platform <b>106</b> can assign to a group of users a common identifier based on similar interests in the context of digital content accessed by the users. In another example, users can be assigned to a group and can be assigned a common identifier based on the subscriptions with the digital content. In some implementations, the content platform <b>106</b> can assign multiple identifiers to a single user. For example, the content platform <b>106</b> can assign both email id and a cell phone number as an identifier for a user.</p><p id="p-0026" num="0025">To retrieve digital content from the content providers <b>110</b>, the content platform <b>106</b> and the content provider <b>110</b> implements an information retrieval technique that ensures data privacy in a way that the content platform <b>106</b> does not reveal any details to the content providers <b>110</b> about what information is being queried. The retrieval technique further ensures that the content providers <b>110</b> does not reveal any details to the content platforms <b>106</b> about other information that is stored on the computing systems of the content providers <b>110</b>. While this specification refers to content providers <b>110</b> and content platforms <b>106</b>, the information retrieval techniques discussed herein can be used by any two systems that want to exchange information in a privacy preserving manner. The information retrieval techniques are further explained with reference to <figref idref="DRAWINGS">FIG. <b>2</b></figref>, and entities that are requesting information from a database are referred to as clients and the entities that maintain the database of information, and return information stored in the database are referred to as servers.</p><p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a swim lane diagram of an example process <b>200</b> of retrieving content by a client from a server. Operations of the process <b>200</b> can be implemented, for example, by the client <b>202</b> and the server <b>204</b>. Operations of the process <b>200</b> can also be implemented as instructions stored on one or more computer readable media, which may be non-transitory, and execution of the instructions by one or more data processing apparatus can cause the one or more data processing apparatus to perform the operations of the process <b>200</b>.</p><p id="p-0028" num="0027">The server implements a database (also referred to as server database) that stores digital content in the form of a mapping between key and value (referred to as a key-value pair). A key can be an identifier and/or a pointer for a value that is the digital content that is being queried by the client. A database can include multiple keys and for each key a respective value corresponding to the key. For example, the server can include, in the database, multiple keys where each key can uniquely identify one or more users of the clients for which the client is retrieving content from the server. In another example, the server can include, in the database, keys that do not necessarily identify users. In such implementations, the value of the corresponding key is data that the server allows clients to query based on other factors such as client permissions or user permissions granted to the client or the user respectively.</p><p id="p-0029" num="0028">In some implementations, the key of the key-value pair of the server database is associated with the identifier that was assigned to the users by the clients. While querying the server, the client provides the server with a query that includes the identifiers in a way that the details of the identifiers are not disclosed to the server. As explained further in the document, the server can select content (e.g., data of any kind) from the server database based on the identifier even though the identifiers are masked from the server.</p><p id="p-0030" num="0029">The client <b>202</b> obtains unique identifiers (<b>212</b>). For example, the client <b>202</b> can provide digital content to one or more users. To uniquely identify the one or more users, the client <b>202</b> can assign an identifier to each of the one or more users. In some implementations, the client <b>202</b> can use information provided by the one or more users and/or the user devices <b>104</b> as the identifiers for the one or more users and/or user devices <b>104</b>. For example, the client <b>202</b> can use, as a unique identifier, an electronic mail identifier (email-id or email address), cell phone number, or media access control (MAC) address of the user devices <b>104</b>. The client can be any computing system that requests information from another system (e.g., a server system) that stores information or maintains a database.</p><p id="p-0031" num="0030">The client <b>202</b> device encrypts the identifiers (<b>214</b>). To prevent the server <b>204</b> from accessing the identifiers of the users in plaintext, the client <b>202</b> encrypts the identifiers using a deterministic and commutative encryption technique to generate an encrypted form of the identifiers (referred to as &#x201c;client encrypted identifiers&#x201d;). In general, a commutative encryption is a kind of an encryption that enables a plaintext to be encrypted more than once using different entity's encryption keys. In this system, decryption is not required before the encryption/re-encryption processes. Moreover, the resulting ciphertext (also referred to as encrypted text) can be decrypted by the designated decryption techniques without considering the order of the encryption keys used in the encryption/re-encryption processes. In other words, the order of keys used in encryption and in decryption do not affect the computational result, and allow one encrypting party (e.g., a client <b>202</b>) to remove their encryption even after another party (e.g., a server) has applied further encryption to data that was encrypted by the first encrypting party.</p><p id="p-0032" num="0031">The client <b>202</b> transmits the client encrypted identifiers to the server <b>204</b> (<b>216</b>). For example, after encrypting the identifiers, the client <b>202</b> transmits the client encrypted identifiers to the server <b>204</b> over the network <b>102</b>.</p><p id="p-0033" num="0032">The server <b>204</b> encrypts the client encrypted identifiers (<b>218</b>). In some implementations, after receiving the client encrypted identifiers from the client <b>202</b>, the server <b>204</b> re-encrypts (e.g., further encrypts) the client encrypted identifiers using a deterministic and commutative encryption technique to generate an encrypted form of the client encrypted identifiers (referred to as &#x201c;server &#x26; client encrypted identifiers&#x201d;). In other words, the server <b>204</b> adds another layer of encryption on the client encrypted identifiers. Note that the server <b>204</b> does not have access to the identifiers in plaintext because the identifiers were already encrypted by the client <b>202</b>, and the server <b>204</b> does not have the decryption key.</p><p id="p-0034" num="0033">The server <b>204</b> transmits the server &#x26; client encrypted identifiers back to the client <b>202</b> (<b>220</b>). For example, after generating the server &#x26; client encrypted identifiers, the server <b>204</b> transmits the server &#x26; client encrypted identifiers of the one or more users to the client <b>202</b> over the network <b>102</b>.</p><p id="p-0035" num="0034">The server <b>204</b> encrypts the database (<b>222</b>). The server <b>204</b> can encrypt the database at any time prior to performing homomorphic operations on the database. The server <b>204</b> can also encrypt the database prior to receipt of one or more queries constructed by the client <b>202</b> after the client <b>202</b> receives the server &#x26; client encrypted identifiers. For example, as the server <b>204</b> is building the database, or adding information to the database, the server can encrypt the data being stored in the database before homomorphic encryption is applied to the data. In some implementations, the server <b>204</b> encrypts the server database using an encryption technique such as an Advanced Encryption Standard (AES). For example, the server <b>204</b> encrypts the value of each key-value pair of the server database using the AES encryption technique based on an AES-key generated using the HMAC-based Extract-and-Expand Key Derivation Function (HKDF) and the corresponding key of the key-value pair. Each key of the key-value pair of the server database is further replaced by an integer (referred to as a record key) that is generated using a hash function (e.g., SHA256) that maps the key to an integer within the range [0, n) where n is a tunable parameter known to both the server <b>204</b> and the client <b>202</b>. This results in a record key-AES encrypted value pair in place of each of the key-value pair in the database.</p><p id="p-0036" num="0035">The hash function can further utilize cryptographic salt added to each key of the key-value pair before hashing. In some implementations, the cryptographic salt is also known to the client <b>202</b> that can be used by the client <b>202</b> while encrypting the queries.</p><p id="p-0037" num="0036">The server <b>204</b> partitions the database (<b>224</b>). In some implementations, the server partitions the database into shards and each shard into buckets. This is further explained with reference to <figref idref="DRAWINGS">FIG. <b>3</b></figref>.</p><p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a flow diagram of an example process <b>300</b> of partitioning the database into shards and buckets. Operations of the process <b>300</b> can be implemented, for example, by the server <b>204</b> that includes any entity that implements a database that stores retrievable data. Operations of the process <b>300</b> can also be implemented as instructions stored on one or more computer readable media, which may be non-transitory, and execution of the instructions by one or more data processing apparatus can cause the one or more data processing apparatus to perform the operations of the process <b>300</b>.</p><p id="p-0039" num="0038">The server <b>204</b> partitions the database into P shards (<b>302</b>). For example, by deriving shard indexes from record keys by using the same technique used by the client to derive shard indexes. Each shard may include multiple record key-AES encrypted value pairs.</p><p id="p-0040" num="0039">The server <b>204</b> partitions each shard into buckets (<b>304</b>). In some implementations, the server <b>204</b> partitions each shard into even smaller partitions called buckets by deriving a bucket-id for each record key in a shard using the same technique that the client used. For example, shard index and the bucket-id can be computed as the remainder and the integer quotient respectively when the converted number is divided by P. Observe that this yields at most n/P buckets per shard.</p><p id="p-0041" num="0040">After partitioning each shard into multiple buckets, the AES encrypted values of the record key-AES encrypted value pairs are stored inside each bucket such that the record key of the record key-AES encrypted value pairs indexes both the shard and the bucket inside the shard. It should be noted that the server <b>204</b> uses the same methodology as the client <b>202</b> to derive a shard number and bucket-id from each key of the key-value pair in the server database.</p><p id="p-0042" num="0041">The server <b>204</b> adds a special bucket to each shard (<b>306</b>). In some implementations, the server adds an additional bucket (referred to as a special bucket) in each shard. Each special bucket of a shard contains data (referred to as special data) that is known only to the server. For example, if a server database has <b>10</b> shards, then each of the <b>10</b> shards will include a special bucket and each special bucket will have a unique special data. The special data can be used, for example, to ensure that the client queried an agreed upon number of the special buckets with queries, as discussed in more detail below. In some implementations, the server <b>204</b> can update the special data of each special bucket after executing a query from the client <b>202</b> so as to maintain privacy regarding the contents of the bucket thereby preventing even a remote possibility of the client <b>202</b> or any entity over the network <b>102</b> to use that information to sabotage the validation of the client queries described later. In some implementations, the server can add more than one special bucket in each shard.</p><p id="p-0043" num="0042">In some implementations, the server <b>204</b> places the special bucket in a position that is known to the client <b>202</b>. In other words, the bucket-id of the special bucket is either predefined by the client <b>202</b> and the server <b>204</b> or is provided to the client <b>202</b> by the server <b>204</b> at some point during interactions between the client and server. For example, the server <b>204</b> can alter the bucket-id at different time-stamps and notify the bucket-id of the special bucket to the client <b>202</b> using secure cryptographic protocols. In some implementations, the server <b>204</b> can have a different bucket-id for the special bucket for different shards. In such implementations, the server <b>204</b> can notify the bucket-id of the special bucket for each shard of the server database.</p><p id="p-0044" num="0043">The server <b>204</b> combines and serializes the encrypted values (<b>308</b>). At this stage, the special bucket included in step <b>306</b> is processed in a similar manner as a regular bucket, although, in some implementations, the contents of the special bucket change on a per-query basis. The server <b>204</b> concatenates the AES encrypted values of each non-special bucket or the special data of the special buckets into a bytestring. For example, if a particular bucket includes 3 AES encrypted values, the 3 AES encrypted values are concatenated one after the other to generate a bytestring. The server <b>204</b> identifies the offset values (index location of the bytestring) of the AES encrypted values and encrypts the offset values using an encryption technique such as AES based on the corresponding record keys. For example, if the bytestring includes <b>3</b> AES encrypted values of uniform length, the server encrypts the offset values of each of the <b>3</b> AES encrypted values in the bytestring using AES based on the respective record key of the record key-AES encrypted value pair. After generating the encrypted offset values, the server <b>203</b> prepends the encrypted offset values to the bytestring. The server <b>204</b> further prepends the number of AES encrypted values to the bytestring. In this example, the server <b>204</b> prepends the value 3 to the bytestring. The server <b>204</b> further splits the bytestring into chunks of c bytes each where c is an integer known in advance to both the client and the server. The c-byte chunks can be further indexed based on their relative position in the bytestring. For example, if c=1, a bucket B can be represented as B=[&#x201c;p&#x201d;,&#x201c;q&#x201d;,&#x201c;r&#x201d;,&#x201c;s&#x201d;] where &#x201c;pqrs&#x201d; can be the bytestring that is split into c-byte chunks &#x201c;p&#x201d;, &#x201c;q&#x201d;, &#x201c;r&#x201d; and &#x201c;s&#x201d; having indices 1-4 in the bucket respectively. In another example, if c=2, a bucket B can be represented as B=[&#x201c;pq&#x201d;,&#x201c;rs&#x201d;,&#x201c;tu&#x201d;,&#x201c;v&#x201d;] where &#x201c;pqrstuv&#x201d; can be the bytestring that is split into c-byte chunks &#x201c;pq&#x201d;, &#x201c;rs&#x201d;, &#x201c;tu&#x201d; and &#x201c;v&#x201d; having indices 1-4 in the bucket respectively.</p><p id="p-0045" num="0044">Now returning to <figref idref="DRAWINGS">FIG. <b>2</b></figref>, the client <b>202</b> removes the prior client encryption from the server &#x26; client encrypted identifiers (<b>226</b>). In some implementations, after receiving the server &#x26; client encrypted identifiers, the client <b>202</b> uses techniques to decrypt (or remove) the encryption that was performed by the client <b>202</b> in step <b>214</b> to generate &#x201c;server encrypted identifiers&#x201d; for each of the one or more users. Note that the client <b>202</b> is able to remove client encryption since the encryption techniques are commutative in nature. Also note that the server encrypted identifiers that are generated after removing the client encryption are identifiers encrypted by the server using the commutative and deterministic encryption technique. In other words, after the client <b>202</b> removes the original encryption that was applied to the identifiers, the identifiers remain encrypted by the server, and are then only server encrypted versions of the client identifiers, which are used by the client <b>202</b> to generate queries that will be submitted to the server <b>204</b> to request information corresponding to the identifiers.</p><p id="p-0046" num="0045">In some implementations, steps <b>214</b>-<b>220</b> and <b>226</b> of the process <b>200</b> can be implemented using an oblivious pseudo random function (also referred to as an Oblivious PRF or OPRF). An Oblivious PRF is a protocol between a server holding a key to a pseudo random function (PRF) and a client holding an input. At the end of the server-client interaction, the client learns the output of the OPRF on its input provided by the client and nothing else. The server learns nothing about the client's input or the OPRF output.</p><p id="p-0047" num="0046">To facilitate creation of the queries, the client <b>202</b> generates a shard index and a bucket identifier for each server encrypted identifier (<b>228</b>). In some implementations, the client <b>202</b> implements a hashing technique to generate a query that can include a shard index and a bucket identifier (also referred to as a bucket-id). An example hashing technique of generating the query is further explained with reference to <figref idref="DRAWINGS">FIG. <b>4</b></figref>.</p><p id="p-0048" num="0047"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a flow diagram of an example process <b>400</b> of generating a query from the server encrypted identifiers. Operations of the process <b>400</b> can be implemented, for example, by the client <b>202</b> that includes any entity that implements the techniques described in this document to retrieve content from another entity. Operations of the process <b>400</b> can also be implemented as instructions stored on one or more computer readable media which may be non-transitory, and execution of the instructions by one or more data processing apparatus can cause the one or more data processing apparatus to perform the operations of the process <b>400</b>.</p><p id="p-0049" num="0048"><figref idref="DRAWINGS">FIG. <b>4</b></figref> explains the process <b>400</b> of generating a query using an example identifier <b>450</b> (john.smith@example.com). After processing the identifier <b>450</b> using step <b>226</b> of the process <b>200</b>, the server encrypted identifier <b>460</b> of the identifier <b>450</b> is represented as SERV_ENC{john.smith@example.com}:=adhf8f2g&#x26;34!d0sfgn2 where SERV_ENC is the server encryption of the server &#x26; client encrypted identifiers after the client <b>202</b> removes the client encryption of step <b>214</b> and &#x201c;adhf8f2g&#x26;34!d0sfgn2&#x201d; is the ciphertext of the identifier <b>450</b>.</p><p id="p-0050" num="0049">The client <b>202</b> hashes the server encrypted identifiers to generate an unsigned integer (<b>410</b>). In some implementations, the client <b>202</b> can implement a hash function that is configured to process the server encrypted identifier <b>460</b> to generate an unsigned integer <b>470</b>. This can be represented as HASH_FN[SERV_ENC{john.smith@example.com}]:=324423510001001110 where HASH_FN is the hash function implemented by the client <b>202</b> and &#x201c;324423510001001110&#x201d; is the unsigned integer. The hash function (also referred to as a Cryptographic Hash Function) can be any one-way function which is practically infeasible to invert or reverse and that can be used to map data of arbitrary size to a fixed-size value. Examples of such hash functions can include MD5 message-digest algorithm, Secure Hash Algorithm 1, 2 and 3.</p><p id="p-0051" num="0050">The client <b>202</b> converts the unsigned integer into a converted number that is within a specified range (<b>420</b>). In some implementations, the client <b>202</b> can implement a conversion function that is configured to process the unsigned integer <b>470</b> to generate a converted number <b>480</b> that is within a specified range. Since the hash function and the conversion function are known to both the client <b>202</b> and the server <b>204</b>, the range of the converted number generated using the conversion function is pre-specified. In this example, the converted number <b>480</b> is represented as CONV[HASH_FN[SERV_ENC{john.smith@example.com}]]:=324425 where CONY is the conversion function implemented by the client <b>202</b>. As an example, one way to convert an unsigned integer into a number between 0 and 9999 is to use the remainder of the unsigned integer divided by 10000.</p><p id="p-0052" num="0051">The client <b>202</b> splits the converted number into a shard index and a bucket-id (<b>430</b>). The shard index will be a number between 0 and P&#x2212;1, where P is the number of shards. The bucket-id will range between 0 and n/P&#x2212;1, where n is the largest value that the converted number <b>480</b> generated in step <b>420</b> can take. In some implementations, the client <b>202</b> splits the converted number <b>480</b> generated in step <b>420</b> into two parts such that the first part is the shard index and the second part is the bucket-id. For example, if n is the largest value that the converted number <b>480</b> can take, the number of bits required to represent the number n is log<sub>2</sub>n bits. In such a scenario, if P is a power of 2 where P=2K, the client <b>202</b> can use the first K bits as the shard index and the remaining, log<sub>2</sub>n&#x2212;K bits can be used as a bucket-id. In this example, the client <b>202</b> splits the converted number <b>480</b> into two parts as depicted in <figref idref="DRAWINGS">FIG. <b>3</b></figref> as result <b>490</b> such that the shard index is 32 and the bucket-id is 4425. In another implementation, if P represents the number of shards, the shard index can be computed as the remainder when the converted number is divided by P. In this case, the bucket-id can be computed as the integer quotient when the converted number is divided by P. In this case, if P=100 then shard index 25 and bucket-id 3244.</p><p id="p-0053" num="0052">Returning back to the process <b>200</b>, the client <b>202</b> uses the process <b>400</b> to generate a query for each of the server encrypted identifiers of the one or more users. For example, each query that is generated for each identifier will include the shard index and the bucket id created using the server encrypted identifier, as discussed above.</p><p id="p-0054" num="0053">The client <b>202</b> generates decryption keys using each server encrypted identifier (<b>230</b>). In some implementations, the client <b>202</b> can generate a decryption key for each of the server encrypted identifiers. For example, the client <b>202</b> can implement a HMAC-based Extract-and-Expand Key Derivation Function (HKDF) which is a hash-based message authentication code (HMAC) cryptographic key derivation function (KDF) for expanding a key into one or more cryptographically strong secret keys. For example, the client <b>202</b> can use the HKDF to process the server encrypted identifier to generate a decryption key.</p><p id="p-0055" num="0054">The client <b>202</b> generates and encrypts queries (<b>232</b>). In some implementations, the client <b>202</b> uses the bucket-id computed using the process <b>300</b> to generate an indicator vector of length n/P where the element with index equal to the bucket-id is 1 and the other elements are 0 (recalling that P is the number of shards and n/P is the number of distinct bucket-ids). In some implementations, the indicator vector can be compressed using well-known compression techniques. In some implementations, the client <b>202</b> can encrypt the indicator vector corresponding to each of the server encrypted identifiers using a fully homomorphic encryption (FHE) technique to generate a corresponding FHE encrypted bucket vector. In general, homomorphic encryption is a form of encryption that permits users to perform computations on its encrypted data without first decrypting it. These resulting computations are left in an encrypted form which, when decrypted, result in an identical output to that produced had the operations been performed on the unencrypted data. Properties of FHE can include addition, multiplication and absorption. To illustrate, if {x} denotes a FHE of x, then the addition {x}+{y} can yield {x+y} without revealing x, y or x+y. Similarly, the multiplication {x}*{y} can yield {xy} without revealing x, y or xy and the absorption {x}*y can yield {xy} without revealing x. In some implementations, the properties of FHE can include the ability to convert an encrypted vector into a specified number of separate encrypted values (one for each item in the vector) without revealing any details about the items in the vector.</p><p id="p-0056" num="0055">After encrypting the indicator vector, the client <b>202</b> can generate a query that includes a shard index and a corresponding FHE encrypted bucket vector. The query can be denoted as FHE QUERY (database, query) where the database represents a data storage that stores a mapping of key and value i.e., the database stores multiple keys and for each key a corresponding value.</p><p id="p-0057" num="0056">The client <b>202</b> generates padding queries (<b>234</b>). In general, the number of unique identifiers for which the client <b>202</b> is retrieving data from the server database is less than the number of unique identifiers in the server database. In some implementations, in order to mask the true queries and their distribution to the shards generated in step <b>232</b> of the process <b>200</b> from the server <b>204</b>, the client <b>202</b> can generate padding queries that can be transmitted to the server <b>204</b>. The client <b>202</b> can determine the number of padding queries required, for example, based on information provided by the server <b>204</b>. For example, the server <b>204</b> can specify that a certain number of padding queries (e.g., 99 padding queries or another appropriate number of padding queries) is required to be generated and submitted by the client <b>202</b> for each real query being submitted by the client <b>202</b>. The number of padding queries required to be submitted in various ways. For example, the number of padding queries can be done using theoretical or experimental approaches to pick a fixed number of queries per shard to issue, or even heuristically or arbitrarily selected by an entity (e.g., an administrator) of the server <b>204</b>. In another example, assume that the server database is partitioned into 5 shards and that the server <b>204</b> and client <b>202</b> have agreed on 3 queries per shard i.e., the client <b>202</b> can transmit a maximum of 3 queries for each shard. Further assume that the client <b>202</b> generates 7 real queries that are distributed as 0 real queries for the first shard, 3 real queries for the second shard, 1 real query for the third shard, 2 real queries for the fourth shard and 1 real query for the fifth shard. In this example, the client <b>202</b> needs to generate a total of 8 padding queries that can be computed using the following equation</p><p id="p-0058" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>Number of padding queries=(Number of shards*Number of queries per shard)&#x2212;number of real queries<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0059" num="0000">The number of padding queries generated by the client <b>202</b> are distributed as 3 padding queries for the first shard, 0 padding queries for the second shard, 2 padding queries for the third shard, 1 padding queries for the fourth shard and 2 padding queries for the fifth shard.</p><p id="p-0060" num="0057">In some implementations, the client <b>202</b> uses the bucket-id of the special buckets added by the server <b>204</b> computed using the process <b>300</b> to generate an indicator vector for the special buckets. Similar to the step <b>232</b> of the process <b>200</b>, the indicator vector for the special buckets can be compressed using well-known compression techniques and encrypted using a fully homomorphic encryption (FHE) technique to generate a corresponding FHE encrypted bucket vector for the special buckets.</p><p id="p-0061" num="0058">In some implementations, each padding query is directed to the special buckets of the shards being queried by the real queries (e.g., queries generated using the identifiers). For example, to query the database in a privacy preserving manner, the client may be required to generate 99 padding queries for each real query. In this example, each of the 99 padding queries will be formed such that they are directed to the special buckets, and will be queries for the special data contained in the special buckets. In some implementations, the special data can be random values or other data. As discussed further below, each padding query will return a different special data stored in one of the special buckets, which can be used by the server to ensure that the client device generated the required number of padding queries (e.g., by comparing the special data returned in response to the queries to the full set of special data known to the server). If the special data in each of the special buckets is different, then if the number of distinct special data provided to the client matches the number of padding queries required to be created by the client device, the server can conclude that the client <b>202</b> is not compromised and/or malicious.</p><p id="p-0062" num="0059">The client <b>202</b> transmits the query to the server <b>204</b> (<b>236</b>). For example, after generating the queries for each of the server encrypted identifiers and the padding queries, the client <b>202</b> transmits the full set of queries to the server <b>204</b> over the network <b>102</b>. In some implementations, multiple queries are sent to the server in a batch, such that the server can process the queries at the same time (e.g., in a batch process).</p><p id="p-0063" num="0060">The server <b>204</b> processes the queries (<b>238</b>). At this stage, the real queries and the padding queries are processed in a similar way. Note that the server <b>204</b> has no information to identify the real queries from the padding queries. In some implementations, the server <b>204</b> can process the queries using an optimized batch process that reduces the resource consumption required to retrieve content from the database. The optimized process can be implemented in a manner that facilitates concurrent processing by splitting the database into smaller chunks (referred to as shards and identified using shard index), and processing them in parallel on multiple computing systems thereby reducing the computational resources required to retrieve content from the database. This is further explained with reference to <figref idref="DRAWINGS">FIG. <b>5</b></figref>.</p><p id="p-0064" num="0061"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a flow diagram of an example process <b>500</b> of processing queries. Operations of the process <b>500</b> can be implemented, for example, by the server <b>204</b> that includes any entity that implements a database from where content is being retrieved. Operations of the process <b>500</b> can also be implemented as instructions stored on one or more computer readable media which may be non-transitory, and execution of the instructions by one or more data processing apparatus can cause the one or more data processing apparatus to perform the operations of the process <b>500</b>.</p><p id="p-0065" num="0062">For each query, the server <b>204</b> identifies the shard using the shard-index of the query (<b>502</b>). As mentioned before with reference to step <b>232</b> and <b>234</b> of the process <b>200</b>, each query includes a shard index and a corresponding FHE encrypted bucket vector. After receiving a query, the server <b>204</b> identifies a particular shard based on the shard index of the query. For example, if the shard index of the query is 32, the server identifies the 32nd shard based on the shard indexes of the server database. Furthermore, the system can be designed so that each of the shards is selected the exact same number of times to prevent any information about the queries from being gleaned based on the shards queried.</p><p id="p-0066" num="0063">For each query, the server <b>204</b> queries each bucket in the shard and generates a list of FHE encrypted values (<b>504</b>). In some implementations, the server <b>204</b> queries each bucket of the particular shard identified by the shard index using the FHE encrypted bucket vector from the query. For example, if there are 32 buckets in a shard that was identified using the shard-index from the query, the server <b>204</b> will query each of the 32 buckets.</p><p id="p-0067" num="0064">There are a variety of ways that buckets can be queries, and any appropriate bucket querying technique can be used. For example, the server <b>204</b> performs an oblivious expansion operation on the FHE encrypted bucket vector from the query to obtain an FHE encrypted value for the particular bucket. Then it performs a separate FHE absorption operation between the FHE encrypted value for the particular bucket and each c-byte chunk in the bucket. This can be logically explained with the following non-limiting example.</p><p id="p-0068" num="0065">Assume that there are 4 buckets in the particular shard. Further, assume that the 1st bucket has the following chunks [&#x201c;A&#x201d;, &#x201c;B&#x201d;, &#x201c;C&#x201d;, &#x201c;D&#x201d;]. Similarly the 2nd, the 3rd and the 4th bucket has the following chunks [&#x201c;E&#x201d;, &#x201c;F&#x201d;, &#x201c;G&#x201d;], [&#x201c;H&#x201d;] and [&#x201c;I&#x201d;, &#x201c;J&#x201d;, &#x201c;K&#x201d;] respectively. Further, assume that the indicator vector is [0, 1, 0, 0]. An absorption operation will generate FHE encrypted values of chunks with index 1 across all four buckets that can be represented as [0, &#x201c;E&#x201d;, 0, 0]. Similarly FHE encrypted values of chunks with indices 2-4 across all four buckets are [0, &#x201c;F&#x201d;, 0, 0], [0, &#x201c;G&#x201d;, 0, 0] and [0, 0, 0, 0] respectively.</p><p id="p-0069" num="0066">In some implementations, the server <b>204</b> can aggregate the values of the FHE encrypted values of the bucket vector and the c-byte chunks using the FHE addition operation across all buckets and generate a list of FHE encrypted values. In other words, all entries in the set of triples described previously with the same query and chunk_index are combined into one by summing the FHE values. For example, the aggregation operation on the values of the FHE encrypted values of the bucket vector and the c-byte chucks with a particular index, for example, index 1 will select the chunk &#x201c;E&#x201d; from among all chunks having index 1 across all four buckets of the shard. Similarly the aggregated values of the chunks at the 2nd, the 3rd and the 4th indices are &#x201c;F&#x201d;,&#x201c;G&#x201d; and 0 respectively across all buckets of the shard. The server <b>204</b> after selecting the chunks from buckets, the server <b>204</b> can generate a list of FHE encrypted values and transmits the list to the client <b>202</b>. For example, the server can generate a list [&#x201c;E&#x201d;, &#x201c;F&#x201d;, &#x201c;G&#x201d;] of FHE encrypted values that were selected using the absorption operation and transmit the list to the client <b>202</b>. As mentioned above, the server <b>204</b> has no way of identifying the real queries from the padding queries. Therefore, the padding queries are processed in the same way as the real queries, and the server <b>204</b> selects the special data from the special buckets for the corresponding shards based on the padding queries. The structure of the padding queries is pre-specified so that querying the shard with the padding query results in the server returning the special data in response to the padding query.</p><p id="p-0070" num="0067">The process <b>500</b> is implemented in a way that multiple queries are processed in parallel on multiple computing systems. In some implementations, a map reduce process can be used that enables all queries to be processed as a batch of queries, which reduces the time required to generate a response to the queries, and saves processing resources relative to processing each query individually. For example, assume that the database is partitioned into n buckets by hashing keys and that the buckets are partitioned into shards based on leading k bits. In this example, the server can partition the queries by shard based on the provided shard index that is submitted with each query. The server can then fan out each query to an FHE value per (existing) bucket in its shard by decompressing the encrypted bucket selector. Within each shard, each bucket is joined with the FHE values from the queries for the bucket. For each bucket: for each pair in the cartesian product of FHE values from queries and chunks of the bucket, perform an FHE absorption. The output of this step is a multimap from (query_id, chunk_index) pairs to FHE-encrypted values. The values are aggregated using FHE addition as the aggregator. This has the same output format as the previous step, except that it's not a multimap&#x2014;each key has exactly one FHE value. A list of encrypted values sorted by chunk_index is aggregated, and the output format is a map from query to a list of FHE-encrypted values. By providing the same number of queries per shard and with appropriate sharding, the computational costs can be reduced by having many shards without revealing any information about the distribution of queries. Now returning back to <figref idref="DRAWINGS">FIG. <b>2</b></figref>.</p><p id="p-0071" num="0068">The server <b>204</b> transmits the list of FHE encrypted values to the client <b>202</b> (<b>240</b>). The server <b>204</b> after generating the list of FHE encrypted values of the bucket vector and the c-byte chunks for each queries, transmits the one or more lists to the client <b>202</b> over the network <b>102</b>.</p><p id="p-0072" num="0069">The client <b>202</b> decrypts the FHE encryption (<b>242</b>). In some implementations, after receiving the lists of FHE encrypted values of the bucket vector and the c-byte chunks for each of the queries transmitted by the client <b>202</b>, the client <b>202</b> can segregate the FHE encrypted values for the padding queries from the real queries because the client device knows which queries were padding queries. At this point the client can use the decryption keys that were generated in step <b>230</b> of the process <b>200</b> to decrypt the FHE encryption to obtain the value of the key-value pair that was queried and was originally stored on the server database. While decrypting the FHE encrypted values, the client <b>202</b> also obtains the special data that was retrieved from the server database for each of the padding queries transmitted by client <b>202</b> in step <b>236</b>. The special data that was retrieved from the server database for each of the padding queries is all together referred to as a retrieved set of special data.</p><p id="p-0073" num="0070">The server <b>204</b> encrypts the special data of each special bucket (<b>244</b>). In some implementations, the server <b>202</b> encrypts the special data of each special bucket using a commutative encryption technique (either deterministic or non-deterministic) to generate a corresponding server encrypted special data. This generates a universal set of server encrypted special data that includes encrypted values of each unique special data from each unique special bucket added by the server <b>204</b>. The server <b>204</b> can encrypt the universal set of server encrypted special data at any point before or after receiving the queries from the client device <b>202</b>.</p><p id="p-0074" num="0071">The server <b>204</b> transmits the server encrypted special data to the client <b>202</b> (<b>246</b>). The server <b>204</b> after generating the universal set of server encrypted special data, transmits the universal set to the client <b>202</b> over the network <b>102</b>. The client <b>202</b> is unable to decrypt the universal set of server-encrypted special data, but as discussed below, the client <b>202</b> can apply further encryption that will allow the server to compare client encrypted versions of the special data that were returned to the client device <b>202</b> in the query results returned to the client device <b>202</b> responsive to processing the queries with the universal set of server encrypted special data.</p><p id="p-0075" num="0072">The client <b>202</b> encrypts the server encrypted special data to create client server encrypted special data (<b>248</b>). In some implementations, after receiving the universal set of server encrypted special data from the server <b>204</b>, the client <b>202</b> re-encrypts (e.g., further encrypts) the server encrypted special data of the universal set using a deterministic and commutative encryption technique to generate an encrypted form of the server encrypted special data (referred to as &#x201c;client &#x26; server encrypted special data&#x201d;). This generates a universal set of client &#x26; server encrypted special data. Generally, the universal set of client &#x26; server encrypted special data will include more special data than the retrieved set of special data that are provided to the client device <b>202</b> in response to the queries. More specifically, the universal set of client &#x26; server encrypted special data will contain as many special data as the total number of queries that includes both real queries and padding queries.</p><p id="p-0076" num="0073">The client <b>202</b> transmits the universal set of client &#x26; server encrypted special data to the server <b>204</b> (<b>250</b>). The server <b>204</b> receives the universal set of client &#x26; server encrypted special data, and as discussed below, processes the universal set of client &#x26; server encrypted special data to determine whether the client device <b>202</b> used the required number of padding queries (e.g., a specified number of padding queries for each real query).</p><p id="p-0077" num="0074">The server <b>204</b> removes the prior server encryption from the universal set of client &#x26; server encrypted special data to obtain a universal set of client encrypted special data (<b>252</b>). After receiving the universal set of client &#x26; server encrypted special data, the server <b>204</b> uses techniques to decrypt (or remove) the encryption that was performed by the server <b>204</b> in step <b>244</b>. Once the server removes the previously applied server encryption from each of the client &#x26; server encrypted special data in the universal set of client &#x26; server encrypted special data, the result is the full set of client encrypted universal set of client encrypted special data. The universal set of client encrypted special data includes special data of each unique special bucket that is encrypted using client encryption, but not server encryption. In some implementations, steps <b>244</b>-<b>252</b> of the process <b>200</b> can be implemented using an Oblivious PRF. It should be noted that steps <b>244</b>-<b>252</b> of the process <b>200</b> can be performed at any point after the server <b>204</b> has added the additional buckets. For example, after step <b>306</b> of the process <b>300</b>.</p><p id="p-0078" num="0075">The client <b>202</b> encrypts the special data retrieved from the server database to generate client-encrypted special data (<b>254</b>). In some implementations, the client <b>202</b>, after obtaining the retrieved set of special data, encrypts each of the special data in the retrieved set using the same commutative encryption technique as used in step <b>248</b> of the process <b>200</b> to generate a retrieved set of client encrypted special data. The retrieved set of client encrypted special data does not include any server encryption, and therefore, can be compared to the universal set of client encrypted special data to determine how many matches occur without revealing the underlying special data, because revealing the underlying special data could reveal to the server which queries were padding queries. The number of matches can be used, for example, by the server to ensure that the client device is adhering to the agreed upon protocol without requiring the client device to reveal the information it actually submitted in the queries. For example, as described below, the server device can validate that the client device has submitted the agreed upon minimum number of padding queries based on the number of matches identified. This ensures that the client device is submitting a sufficient number of padding queries, which helps ensure the privacy of the underlying data being queried by client devices.</p><p id="p-0079" num="0076">The client <b>202</b> transmits the client encrypted special data to the server <b>204</b> (<b>256</b>). The server <b>204</b> receives the retrieved set of client encrypted special data over the network <b>102</b>, and further processes the client encrypted special data, as discussed below.</p><p id="p-0080" num="0077">The server <b>204</b> compares and validates the client queries (<b>258</b>). In some implementations, after receiving the retrieved set of client encrypted special data, the server <b>204</b> checks whether the client encrypted special data is a proper subset of the universal set of client encrypted special data generated in step <b>252</b> of the process <b>200</b>. In other words, the server <b>204</b> checks whether each of the client encrypted special data in the retrieved set is included in the universal set of client encrypted special data. Although the server <b>204</b> cannot access the underlying special data in either the universal set of client encrypted special data or the retrieved set of client encrypted special data generated using the special data provided to the client <b>202</b> in the query results, the server <b>204</b> can compare the encrypted versions to determine whether the underlying data matches. If there are one or more client encrypted special data that are in the retrieved set and not the universal set, the server <b>204</b> can conclude that the client <b>202</b> is compromised and/or malicious because it did not submit the required number of padding queries. In some implementations, the server <b>204</b> can compute the cardinality of intersection of the retrieved set of client encrypted special data and the full set of client encrypted special data. If the cardinality of the intersection is not equal to the number of padding queries (known to the server), the server <b>204</b> can conclude that the client <b>202</b> is compromised and/or malicious.</p><p id="p-0081" num="0078">In some implementations, the server <b>204</b> can withhold some information after concluding that the client <b>202</b> is compromised and/or malicious to prevent the client <b>202</b> from accessing the data that was retrieved from the server database. For example, the server <b>204</b> can add another layer of encryption to the values of the key-value pairs of the server database using any known encryption techniques based on an encryption key that is known only to the server <b>204</b>. If the server <b>204</b> concludes that the client <b>202</b> was compromised and/or malicious, the server <b>204</b> will not transmit the encryption key to the client <b>202</b> thereby preventing the client from accessing the retrieved data in cleartext. On the contrary if the server <b>204</b> concludes that the client <b>202</b> is not compromised and/or malicious, the server <b>204</b> will transmit the encryption key to the client <b>202</b> thereby allowing the client <b>202</b> to access the retrieved data in cleartext. In another example, the server <b>204</b> can withhold the cryptographic salt used by the HKDF to derive AES keys.</p><p id="p-0082" num="0079">In some implementations, the server <b>204</b> can validate whether the client <b>202</b> is not compromised or malicious by implementing a secret sharing scheme such as a Shamir's Secret Sharing (SSS). In such implementations, the server <b>204</b> generates secret shares of a secret data that is known only to the server <b>204</b>. The server <b>204</b> includes a secret share into the special bucket of each shard, such that for each query, the server <b>204</b> is placing a secret share into the special bucket for each shard. As noted above, the secret share included in each bucket can be changed on a per-query basis. Similar to how the client retrieved special data corresponding to each of the padding queries in step <b>242</b>, the client <b>202</b> retrieves secret shares corresponding to each of the padding queries. The client <b>202</b> tries to reconstruct the secret data using the retrieved secret shares and transmits the secret data to the server <b>204</b>. The server <b>204</b> after receiving the secret data, compares the secret data received from the client <b>202</b> to the secret data that was originally known only to the server <b>204</b>. If the two secret data do not match, the server <b>204</b> can conclude that the client <b>202</b> is compromised and/or malicious. The parameters of the secret sharing scheme should be chosen in a way that only if the client <b>202</b> honestly queries for the special data as specified, the client <b>202</b> can then retrieve the encoded secret.</p><p id="p-0083" num="0080"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a block diagram of an example computer system <b>600</b> that can be used to perform operations described above. The system <b>600</b> includes a processor <b>610</b>, a memory <b>620</b>, a storage device <b>630</b>, and an input/output device <b>640</b>. Each of the components <b>610</b>, <b>620</b>, <b>630</b>, and <b>640</b> can be interconnected, for example, using a system bus <b>650</b>. The processor <b>610</b> is capable of processing instructions for execution within the system <b>600</b>. In some implementations, the processor <b>610</b> is a single-threaded processor. In another implementation, the processor <b>610</b> is a multi-threaded processor. The processor <b>610</b> is capable of processing instructions stored in the memory <b>620</b> or on the storage device <b>630</b>.</p><p id="p-0084" num="0081">The memory <b>620</b> stores information within the system <b>600</b>. In one implementation, the memory <b>620</b> is a computer-readable medium. In some implementations, the memory <b>620</b> is a volatile memory unit. In another implementation, the memory <b>620</b> is a non-volatile memory unit.</p><p id="p-0085" num="0082">The storage device <b>630</b> is capable of providing mass storage for the system <b>600</b>. In some implementations, the storage device <b>630</b> is a computer-readable medium. In various different implementations, the storage device <b>630</b> can include, for example, a hard disk device, an optical disk device, a storage device that is shared over a network by multiple computing devices (e.g., a cloud storage device), or some other large capacity storage device.</p><p id="p-0086" num="0083">The input/output device <b>640</b> provides input/output operations for the system <b>600</b>. In some implementations, the input/output device <b>640</b> can include one or more of a network interface devices, e.g., an Ethernet card, a serial communication device, e.g., and RS-232 port, and/or a wireless interface device, e.g., and 802.11 card. In another implementation, the input/output device can include driver devices configured to receive input data and send output data to external devices 560, e.g., keyboard, printer and display devices. Other implementations, however, can also be used, such as mobile computing devices, mobile communication devices, set-top box television client devices, etc.</p><p id="p-0087" num="0084">Although an example processing system has been described in <figref idref="DRAWINGS">FIG. <b>5</b></figref>, implementations of the subject matter and the functional operations described in this specification can be implemented in other types of digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them.</p><p id="p-0088" num="0085">Embodiments of the subject matter and the operations described in this specification can be implemented in digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions, encoded on computer storage media (or medium) for execution by, or to control the operation of, data processing apparatus. Alternatively, or in addition, the program instructions can be encoded on an artificially-generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus. A computer storage medium can be, or be included in, a computer-readable storage device, a computer-readable storage substrate, a random or serial access memory array or device, or a combination of one or more of them. Moreover, while a computer storage medium is not a propagated signal, a computer storage medium can be a source or destination of computer program instructions encoded in an artificially-generated propagated signal. The computer storage medium can also be, or be included in, one or more separate physical components or media (e.g., multiple CDs, disks, or other storage devices).</p><p id="p-0089" num="0086">The operations described in this specification can be implemented as operations performed by a data processing apparatus on data stored on one or more computer-readable storage devices or received from other sources.</p><p id="p-0090" num="0087">The term &#x201c;data processing apparatus&#x201d; encompasses all kinds of apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, a system on a chip, or multiple ones, or combinations, of the foregoing. The apparatus can include special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit). The apparatus can also include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, a cross-platform runtime environment, a virtual machine, or a combination of one or more of them. The apparatus and execution environment can realize various different computing model infrastructures, such as web services, distributed computing and grid computing infrastructures.</p><p id="p-0091" num="0088">A computer program (also known as a program, software, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, declarative or procedural languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, object, or other unit suitable for use in a computing environment. A computer program may, but need not, correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub-programs, or portions of code). A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.</p><p id="p-0092" num="0089">The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform actions by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).</p><p id="p-0093" num="0090">Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are a processor for performing actions in accordance with instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks. However, a computer need not have such devices. Moreover, a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device (e.g., a universal serial bus (USB) flash drive), to name just a few. Devices suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.</p><p id="p-0094" num="0091">To provide for interaction with a user, embodiments of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input. In addition, a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user; for example, by sending web pages to a web browser on a user's client device in response to requests received from the web browser.</p><p id="p-0095" num="0092">Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back-end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front-end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification, or any combination of one or more such back-end, middleware, or front-end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (&#x201c;LAN&#x201d;) and a wide area network (&#x201c;WAN&#x201d;), an inter-network (e.g., the Internet), and peer-to-peer networks (e.g., ad hoc peer-to-peer networks).</p><p id="p-0096" num="0093">The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other. In some embodiments, a server transmits data (e.g., an HTML page) to a client device (e.g., for purposes of displaying data to and receiving user input from a user interacting with the client device). Data generated at the client device (e.g., a result of the user interaction) can be received from the client device at the server.</p><p id="p-0097" num="0094">While this specification contains many specific implementation details, these should not be construed as limitations on the scope of any inventions or of what may be claimed, but rather as descriptions of features specific to particular embodiments of particular inventions. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.</p><p id="p-0098" num="0095">Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In certain circumstances, multitasking and parallel processing may be advantageous. Moreover, the separation of various system components in the embodiments described above should not be understood as requiring such separation in all embodiments, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.</p><p id="p-0099" num="0096">Thus, particular embodiments of the subject matter have been described. Other embodiments are within the scope of the following claims. In some cases, the actions recited in the claims can be performed in a different order and still achieve desirable results. In addition, the processes depicted in the accompanying figures do not necessarily require the particular order shown, or sequential order, to achieve desirable results. In certain implementations, multitasking and parallel processing may be advantageous.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A method, comprising:<claim-text>receiving, at a server device and from a client device, a batch of queries that includes queries to special buckets in each database shard, among multiple database shards, being queried by the batch of queries, wherein the special buckets include server-encrypted secret shares generated by the server;</claim-text><claim-text>generating, by the server device, a set of query results responsive to the batch of queries, wherein the set of query results includes the server-encrypted secret shares obtained from the special buckets queried by the batch of queries;</claim-text><claim-text>transmitting, by the server device and to the client device, the set of query results;</claim-text><claim-text>receiving, at the server device and from the client device, client-encrypted secret shares, wherein the client-encrypted secret shares are client encrypted versions of the secret shares that were included in the set of query results transmitted to the client device;</claim-text><claim-text>transmitting, by the server device and to the client device, a full set of server-encrypted secret shares, wherein the full set of server-encrypted secret shares includes more server-encrypted secret shares than the set of query results;</claim-text><claim-text>receiving, at the server device and from the client device, a full set of client-server-encrypted secret shares, wherein the full set of client-server-encrypted secret shares are client encrypted versions of the full set of server-encrypted secret shares that were transmitted to the client device;</claim-text><claim-text>determining, by the server device, how many of the secret shares are included in both of the client-encrypted secret shares received from the client device and the full set of client-server-encrypted secret shares received from the client device; and</claim-text><claim-text>classifying, by the server device, the client device based on how many of the secret shares are included in both of the client-encrypted secret shares received from the client device and the full set of client-server-encrypted secret shares received from the client device.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>removing, by the server device, the server decryption from the full set of client-server-encrypted secret shares received from the client device to obtain a full set of client-encrypted secret shares, wherein determining how many of the secret shares are included in both of the client-encrypted secret shares received from the client device and the full set of client-server-encrypted secret shares received from the client device comprises comparing the client-encrypted secret shares received from the client device to the full set of client-encrypted secret shares obtained by removing the server decryption from the full set of client-server-encrypted secret shares.</claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein classifying the client device comprises determining that the client device is malicious based on the comparison indicating that fewer than a required number of the secret shares are included in both of the client-encrypted secret shares received from the client device and the full set of client-encrypted secret shares obtained by removing the server decryption from the full set of client-server-encrypted secret shares.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, further comprising:<claim-text>receiving, from the client device, a set of client-encrypted entity identifiers;</claim-text><claim-text>encrypting, by the server, the set of client-encrypted entity identifiers to create a set of sever-client-encrypted identifiers;</claim-text><claim-text>transmitting, by the server, the set of server-client-encrypted identifiers to the client device.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, further comprising:<claim-text>generating a partitioned database in which a database is partitioned into the multiple database shards each having a shard identifier that logically distinguishes each database shard from other database shards, and database entries in each database shard are partitioned into buckets having a bucket identifier that logically distinguishes each bucket in the shard from other buckets in the shard.</claim-text></claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, further comprising:<claim-text>adding a special bucket to each shard;</claim-text><claim-text>including, in each special bucket, special data that is known to the server device, but not the client device; and</claim-text><claim-text>after each query to a given shard, updating the special data in the special bucket of the given shard to maintain privacy of the information contained in the special bucket of the given shard.</claim-text></claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref>, further comprising:<claim-text>generating, by the client device, a set of queries using the set of server-client-encrypted identifiers;</claim-text><claim-text>generating, by the client device, a set of decryption keys using the set of server-client-encrypted identifiers;</claim-text><claim-text>encrypting, by the client device, the set of queries to create the batch of client-encrypted queries.</claim-text></claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. A system comprising:<claim-text>a database configured to store data; and</claim-text><claim-text>a server device configured to process queries using the database and execute instructions that cause the server device to perform operations comprising:<claim-text>receiving, from a client device, a batch of queries that includes queries to special buckets in each database shard, among multiple database shards, being queried by the batch of queries, wherein the special buckets include server-encrypted secret shares generated by the server;</claim-text><claim-text>generating a set of query results responsive to the batch of queries, wherein the set of query results includes the server-encrypted secret shares obtained from the special buckets queried by the batch of queries;</claim-text><claim-text>transmitting, to the client device, the set of query results;</claim-text><claim-text>receiving, the client device, client-encrypted secret shares, wherein the client-encrypted secret shares are client encrypted versions of the secret shares that were included in the set of query results transmitted to the client device;</claim-text><claim-text>transmitting, to the client device, a full set of server-encrypted secret shares, wherein the full set of server-encrypted secret shares includes more server-encrypted secret shares than the set of query results;</claim-text><claim-text>receiving, from the client device, a full set of client-server-encrypted secret shares, wherein the full set of client-server-encrypted secret shares are client encrypted versions of the full set of server-encrypted secret shares that were transmitted to the client device;</claim-text><claim-text>determining how many of the secret shares are included in both of the client-encrypted secret shares received from the client device and the full set of client-server-encrypted secret shares received from the client device; and</claim-text><claim-text>classifying the client device based on how many of the secret shares are included in both of the client-encrypted secret shares received from the client device and the full set of client-server-encrypted secret shares received from the client device.</claim-text></claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The system of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the instructions cause the server device to perform operations further comprising:<claim-text>removing the server decryption from the full set of client-server-encrypted secret shares received from the client device to obtain a full set of client-encrypted secret shares, wherein determining how many of the secret shares are included in both of the client-encrypted secret shares received from the client device and the full set of client-server-encrypted secret shares received from the client device comprises comparing the client-encrypted secret shares received from the client device to the full set of client-encrypted secret shares obtained by removing the server decryption from the full set of client-server-encrypted secret shares.</claim-text></claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The system of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein classifying the client device comprises determining that the client device is malicious based on the comparison indicating that fewer than a required number of the secret shares are included in both of the client-encrypted secret shares received from the client device and the full set of client-encrypted secret shares obtained by removing the server decryption from the full set of client-server-encrypted secret shares.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The system of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the instructions cause the server device to perform operations further comprising:<claim-text>receiving a set of client-encrypted entity identifiers;</claim-text><claim-text>encrypting the set of client-encrypted entity identifiers to create a set of sever-client-encrypted identifiers;</claim-text><claim-text>transmitting the set of server-client-encrypted identifiers to the client device.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The system of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the instructions cause one or more processors to perform operations comprising:<claim-text>generating a partitioned database in which a database is partitioned into the multiple database shards each having a shard identifier that logically distinguishes each database shard from other database shards, and database entries in each database shard are partitioned into buckets having a bucket identifier that logically distinguishes each bucket in the shard from other buckets in the shard.</claim-text></claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The system of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the instructions cause the one or more processors to perform operations comprising:<claim-text>adding a special bucket to each shard;</claim-text><claim-text>including, in each special bucket, special data that is known to the server device, but not the client device; and</claim-text><claim-text>after each query to a given shard, updating the special data in the special bucket of the given shard to maintain privacy of the information contained in the special bucket of the given shard.</claim-text></claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The system of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the client device is configured to perform operations comprising:<claim-text>generating a set of queries using the set of server-client-encrypted identifiers;</claim-text><claim-text>generating a set of decryption keys using the set of server-client-encrypted identifiers;</claim-text><claim-text>encrypting the set of queries to create the batch of client-encrypted queries.</claim-text></claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. A non-transitory computer readable medium storing instructions that, upon execution by one or more data processing apparatus, cause the one or more data processing apparatus to perform operations comprising:<claim-text>receiving, from a client device, a batch of queries that includes queries to special buckets in each database shard, among multiple database shards, being queried by the batch of queries, wherein the special buckets include server-encrypted secret shares generated by a server;<claim-text>generating a set of query results responsive to the batch of queries, wherein the set of query results includes the server-encrypted secret shares obtained from the special buckets queried by the batch of queries;</claim-text><claim-text>transmitting, to the client device, the set of query results;</claim-text><claim-text>receiving, from the client device, client-encrypted secret shares, wherein the client-encrypted secret shares are client encrypted versions of the secret shares that were included in the set of query results transmitted to the client device;</claim-text><claim-text>transmitting, to the client device, a full set of server-encrypted secret shares, wherein the full set of server-encrypted secret shares includes more server-encrypted secret shares than the set of query results;</claim-text><claim-text>receiving, from the client device, a full set of client-server-encrypted secret shares, wherein the full set of client-server-encrypted secret shares are client encrypted versions of the full set of server-encrypted secret shares that were transmitted to the client device;</claim-text><claim-text>determining how many of the secret shares are included in both of the client-encrypted secret shares received from the client device and the full set of client-server-encrypted secret shares received from the client device; and</claim-text><claim-text>classifying the client device based on how many of the secret shares are included in both of the client-encrypted secret shares received from the client device and the full set of client-server-encrypted secret shares received from the client device.</claim-text></claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The non-transitory computer readable medium of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the instructions cause the one or more data processing apparatus to perform operations further comprising:<claim-text>removing the server decryption from the full set of client-server-encrypted secret shares received from the client device to obtain a full set of client-encrypted secret shares, wherein determining how many of the secret shares are included in both of the client-encrypted secret shares received from the client device and the full set of client-server-encrypted secret shares received from the client device comprises comparing the client-encrypted secret shares received from the client device to the full set of client-encrypted secret shares obtained by removing the server decryption from the full set of client-server-encrypted secret shares.</claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The non-transitory computer readable medium of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein classifying the client device comprises determining that the client device is malicious based on the comparison indicating that fewer than a required number of the secret shares are included in both of the client-encrypted secret shares received from the client device and the full set of client-encrypted secret shares obtained by removing the server decryption from the full set of client-server-encrypted secret shares.</claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The non-transitory computer readable medium of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the instructions cause the one or more data processing apparatus to perform operations further comprising:<claim-text>receiving a set of client-encrypted entity identifiers;</claim-text><claim-text>encrypting the set of client-encrypted entity identifiers to create a set of sever-client-encrypted identifiers;</claim-text><claim-text>transmitting the set of server-client-encrypted identifiers to the client device.</claim-text></claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The non-transitory computer readable medium of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein the instructions cause one or more data processing apparatus to perform operations comprising:<claim-text>generating a partitioned database in which a database is partitioned into the multiple database shards each having a shard identifier that logically distinguishes each database shard from other database shards, and database entries in each database shard are partitioned into buckets having a bucket identifier that logically distinguishes each bucket in the shard from other buckets in the shard.</claim-text></claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The non-transitory computer readable medium of <claim-ref idref="CLM-00019">claim 19</claim-ref>, wherein the instructions cause the one or more data processing apparatus to perform operations comprising:<claim-text>adding a special bucket to each shard;</claim-text><claim-text>including, in each special bucket, special data that is known to the server device, but not the client device; and</claim-text><claim-text>after each query to a given shard, updating the special data in the special bucket of the given shard to maintain privacy of the information contained in the special bucket of the given shard.</claim-text></claim-text></claim></claims></us-patent-application>