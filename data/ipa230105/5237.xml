<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230005238A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230005238</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17943922</doc-number><date>20220913</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20220101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>V</subclass><main-group>10</main-group><subgroup>40</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20220101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>V</subclass><main-group>10</main-group><subgroup>25</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20220101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>V</subclass><main-group>10</main-group><subgroup>46</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>7</main-group><subgroup>18</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20220101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>V</subclass><main-group>10</main-group><subgroup>50</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20220101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>V</subclass><main-group>10</main-group><subgroup>40</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20220101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>V</subclass><main-group>10</main-group><subgroup>25</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20220101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>V</subclass><main-group>10</main-group><subgroup>46</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>7</main-group><subgroup>18</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20220101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>V</subclass><main-group>10</main-group><subgroup>507</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20220101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>V</subclass><main-group>10</main-group><subgroup>473</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">PIXEL-LEVEL BASED MICRO-FEATURE EXTRACTION</invention-title><us-related-documents><division><relation><parent-doc><document-id><country>US</country><doc-number>16931921</doc-number><date>20200717</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11468660</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17943922</doc-number></document-id></child-doc></relation></division><continuation><relation><parent-doc><document-id><country>US</country><doc-number>16033264</doc-number><date>20180712</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>10755131</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>16931921</doc-number></document-id></child-doc></relation></continuation><continuation><relation><parent-doc><document-id><country>US</country><doc-number>15461139</doc-number><date>20170316</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>10049293</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>16033264</doc-number></document-id></child-doc></relation></continuation><continuation><relation><parent-doc><document-id><country>US</country><doc-number>12543141</doc-number><date>20090818</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>9633275</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>15461139</doc-number></document-id></child-doc></relation></continuation><us-provisional-application><document-id><country>US</country><doc-number>61096031</doc-number><date>20080911</date></document-id></us-provisional-application></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Intellective Ai, Inc.</orgname><address><city>Dallas</city><state>TX</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>COBB</last-name><first-name>Wesley Kenneth</first-name><address><city>The Woodlands</city><state>TX</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>GOTTUMUKKAL</last-name><first-name>Rajkiran K.</first-name><address><city>Houston</city><state>TX</state><country>US</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>SAITWAL</last-name><first-name>Kishor Adinath</first-name><address><city>Houston</city><state>TX</state><country>US</country></address></addressbook></inventor><inventor sequence="03" designation="us-only"><addressbook><last-name>SEOW</last-name><first-name>Ming-Jung</first-name><address><city>The Woodlands</city><state>TX</state><country>US</country></address></addressbook></inventor><inventor sequence="04" designation="us-only"><addressbook><last-name>XU</last-name><first-name>Gang</first-name><address><city>Katy</city><state>TX</state><country>US</country></address></addressbook></inventor><inventor sequence="05" designation="us-only"><addressbook><last-name>RISINGER</last-name><first-name>Lon W.</first-name><address><city>Katy</city><state>TX</state><country>US</country></address></addressbook></inventor><inventor sequence="06" designation="us-only"><addressbook><last-name>GRAHAM</last-name><first-name>Jeff</first-name><address><city>League City</city><state>TX</state><country>US</country></address></addressbook></inventor></inventors></us-parties><assignees><assignee><addressbook><orgname>Intellective Ai, Inc.</orgname><role>02</role><address><city>Dallas</city><state>TX</state><country>US</country></address></addressbook></assignee></assignees></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">Techniques are disclosed for extracting micro-features at a pixel-level based on characteristics of one or more images. Importantly, the extraction is unsupervised, i.e., performed independent of any training data that defines particular objects, allowing a behavior-recognition system to forgo a training phase and for object classification to proceed without being constrained by specific object definitions. A micro-feature extractor that does not require training data is adaptive and self-trains while performing the extraction. The extracted micro-features are represented as a micro-feature vector that may be input to a micro-classifier which groups objects into object type clusters based on the micro-feature vectors.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="116.33mm" wi="128.10mm" file="US20230005238A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="210.74mm" wi="149.78mm" orientation="landscape" file="US20230005238A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="209.04mm" wi="166.54mm" orientation="landscape" file="US20230005238A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="178.31mm" wi="130.13mm" file="US20230005238A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="224.87mm" wi="145.29mm" file="US20230005238A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="197.02mm" wi="157.56mm" file="US20230005238A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="163.66mm" wi="79.25mm" file="US20230005238A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="186.86mm" wi="79.42mm" file="US20230005238A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="190.42mm" wi="130.13mm" file="US20230005238A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="180.00mm" wi="79.33mm" file="US20230005238A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="179.07mm" wi="98.38mm" file="US20230005238A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="186.52mm" wi="79.33mm" file="US20230005238A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="177.46mm" wi="79.25mm" file="US20230005238A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="201.34mm" wi="152.74mm" file="US20230005238A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00014" num="00014"><img id="EMI-D00014" he="202.35mm" wi="79.33mm" file="US20230005238A1-20230105-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00015" num="00015"><img id="EMI-D00015" he="179.75mm" wi="165.18mm" file="US20230005238A1-20230105-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00016" num="00016"><img id="EMI-D00016" he="182.54mm" wi="79.42mm" file="US20230005238A1-20230105-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00017" num="00017"><img id="EMI-D00017" he="177.80mm" wi="75.18mm" file="US20230005238A1-20230105-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00018" num="00018"><img id="EMI-D00018" he="166.37mm" wi="79.33mm" file="US20230005238A1-20230105-D00018.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00019" num="00019"><img id="EMI-D00019" he="161.04mm" wi="79.42mm" file="US20230005238A1-20230105-D00019.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00020" num="00020"><img id="EMI-D00020" he="183.56mm" wi="96.01mm" file="US20230005238A1-20230105-D00020.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00021" num="00021"><img id="EMI-D00021" he="205.66mm" wi="79.50mm" file="US20230005238A1-20230105-D00021.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading><p id="p-0002" num="0001">This application is a Division of and claims priority to U.S. patent application Ser. No. 16/931,921 filed Jul. 17, 2020, which is a Continuation of U.S. patent application Ser. No. 16/033,264, filed Jul. 12, 2018, issued as U.S. Pat. No. 10,755,131 on Aug. 25, 2020, which in turn is a Continuation of U.S. patent application Ser. No. 15/461,139, filed Mar. 16, 2017, issued as U.S. Pat. No. 10,049,293 on Aug. 14, 2018, which in turn is a Continuation of U.S. patent application Ser. No. 12/543,141, filed Aug. 18, 2009, issued as U.S. Pat. No. 9,633,275 on Apr. 25, 2017, and which in turn claims priority to and benefit of U.S. Provisional Patent Application No. 61/096,031, filed Sep. 11, 2008; the entire contents of each of the aforementioned applications are herein expressly incorporated by reference in their entireties.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">FIELD</heading><p id="p-0003" num="0002">Embodiments of the disclosure provide techniques for extracting pixel-level micro-features from image data. More specifically, embodiments of the disclosure relate to techniques for producing a micro-feature vector for the image data that is used to classify objects depicted in the image data.</p><heading id="h-0003" level="1">BACKGROUND</heading><p id="p-0004" num="0003">Some currently available video surveillance systems provide simple object recognition capabilities.</p><heading id="h-0004" level="1">SUMMARY</heading><p id="p-0005" num="0004">Some video surveillance systems may be configured to classify a group of pixels (referred to as a &#x201c;blob&#x201d;) in a given frame as being a particular object (e.g., a person or vehicle). Once identified, a &#x201c;blob&#x201d; may be tracked from frame-to-frame in order to follow the &#x201c;blob&#x201d; moving through the scene over time, e.g., a person walking across the field of vision of a video surveillance camera. Further, such systems may be configured to determine the type of object that the &#x201c;blob&#x201d; is. However, such surveillance systems typically require that the objects which may be recognized by the system to be defined in advance. Thus, in practice, these systems rely on predefined definitions for objects to evaluate a video sequence. In other words, unless the underlying system includes a description for a particular object, i.e., has been trained, the system is generally incapable of recognizing that type of object. This results in surveillance systems with recognition capabilities that are labor intensive and prohibitively costly to maintain or adapt for different specialized applications. Accordingly, currently available video surveillance systems are often unable to identify objects, events, behaviors, or patterns as being &#x201c;normal&#x201d; or &#x201c;abnormal&#x201d; by observing what happens in the scene over time; instead, such systems rely on static object definitions.</p><p id="p-0006" num="0005">Further, the static patterns recognized by available video surveillance systems are frequently either under inclusive (i.e., the pattern is too specific to recognize many instances of a given object) or over inclusive (i.e., the pattern is general enough to trigger many false positives). In some cases, the sensitivity of may be adjusted to help improve the recognition process, however, this approach fundamentally relies on the ability of the system to recognize predefined patterns for objects. As a result, by restricting the range of objects that a system may recognize using a predefined set of patterns, many available video surveillance systems have been of limited (on simply highly specialized) usefulness.</p><p id="p-0007" num="0006">Embodiments of the disclosure relate to techniques for a classifier component to extract pixel-level micro-features of images. The pixel-level micro-features may be used to classify objects independent of any object definition data, i.e., without training.</p><p id="p-0008" num="0007">One embodiment of the disclosure includes a computer-implemented method for extracting pixel-level micro-features from image data captured by a video camera. The method may generally include receiving the image data, identifying a foreground patch that depicts a foreground object, processing the foreground patch to compute a micro-feature value based on at least one pixel-level characteristic of the foreground patch, where the micro-feature value is computed independent of training data that defines a plurality of object types, and generating a micro-feature vector that includes the micro-feature value. The method may also include classifying the foreground object as depicting an object type as based on the micro-feature vector.</p><p id="p-0009" num="0008">Another embodiment of the disclosure includes a computer-readable storage medium containing a program which, when executed by a processor, performs an operation for extracting pixel-level micro-features from image data captured by a video camera. The operation may generally include receiving the image data, identifying a foreground patch that depicts a foreground object, processing the foreground patch to compute a micro-feature value based on at least one pixel-level characteristic of the foreground patch, where the micro-feature value is computed independent of training data that defines a plurality of object types, and generating a micro-feature vector that includes the micro-feature value. The operation may also include classifying the foreground object as depicting an object type as based on the micro-feature vector.</p><p id="p-0010" num="0009">Still another embodiment includes a system having a video input source configured to provide image data. The system may also include processor and a memory containing a program, which, when executed on the processor is configured to perform an operation for extracting pixel-level micro-features from the image data provided by the video input source. The operation may generally include receiving the image data, identifying a foreground patch that depicts a foreground object, processing the foreground patch to compute a micro-feature value based on at least one pixel-level characteristic of the foreground patch, where the micro-feature value is computed independent of training data that defines a plurality of object types, and generating a micro-feature vector that includes the micro-feature value. The operation may also include classifying the foreground object as depicting an object type as based on the micro-feature vector.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0011" num="0010">So that the manner in which the above recited features, advantages, and objects of the present disclosure are attained and can be understood in detail, a more particular description of the disclosure, briefly summarized above, may be had by reference to the embodiments illustrated in the appended drawings.</p><p id="p-0012" num="0011">It is to be noted, however, that the appended drawings illustrate only example embodiments of this disclosure and are therefore not to be considered limiting of its scope, for the disclosure may admit to other equally effective embodiments.</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates components of a video analysis system, according to one embodiment of the disclosure.</p><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. <b>2</b></figref> further illustrates components of the video analysis system shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, according to one embodiment of the present disclosure.</p><p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. <b>3</b>A</figref> illustrates an example of a context processor component of the video analysis system shown in <figref idref="DRAWINGS">FIG. <b>2</b></figref>, according to one embodiment of the disclosure.</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. <b>3</b>B</figref> illustrates a method for extracting pixel-level based micro-features, according to one embodiment of the disclosure.</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>4</b>A</figref> illustrates a graphical representation of foreground patches and corresponding hue distribution graphs, according to one embodiment of the disclosure.</p><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>4</b>B</figref> illustrates a method for computing a micro-feature value based on the pixel-level hue characteristic, according to one embodiment of the disclosure.</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>4</b>C</figref> illustrates a method for computing a micro-feature value based on the pixel-level magnitude-saturation ratio characteristic, according to one embodiment of the disclosure.</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>4</b>D</figref> illustrates a graphical representation of foreground patches and corresponding orientation lines, according to one embodiment of the disclosure.</p><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. <b>4</b>E</figref> illustrates a method for computing a micro-feature value based on the pixel-level orientation characteristic, according to one embodiment of the disclosure.</p><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. <b>4</b>F</figref> illustrates a graphical representation of foreground patches and corresponding bounding boxes, according to one embodiment of the disclosure.</p><p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. <b>4</b>G</figref> illustrates a method for computing a micro-feature value based on a pixel-level bounding box characteristic, according to one embodiment of the disclosure.</p><p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. <b>4</b>H</figref> illustrates another method for computing a micro-feature value based on the pixel-level bounding box characteristic, according to one embodiment of the disclosure.</p><p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. <b>5</b>A</figref> illustrates a graphical representation of foreground patches and corresponding pixel distribution graphs, according to one embodiment of the disclosure.</p><p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. <b>5</b>B</figref> illustrates a method for computing a micro-feature value based on pixel-level distribution characteristic, according to one embodiment of the disclosure.</p><p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. <b>6</b>A</figref> illustrates a graphical representation of foreground patches and a corresponding star skeleton, according to one embodiment of the disclosure.</p><p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. <b>6</b>B</figref> illustrates a method for computing a micro-feature value based on the pixel-level star skeleton characteristic, according to one embodiment of the disclosure.</p><p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. <b>7</b>A</figref> illustrates a graphical representation of a foreground patch and corresponding per-pixel gradients, according to one embodiment of the disclosure.</p><p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. <b>7</b>B</figref> illustrates a method for computing a micro-feature value based on the pixel-level gradient characteristic, according to one embodiment of the disclosure.</p><p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. <b>7</b>C</figref> illustrates a method for computing a micro-feature value based on the pixel-level covariance matrix characteristic, according to one embodiment of the disclosure.</p><p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. <b>7</b>D</figref> illustrates a graphical representation of the periodic and aperiodic changes in a given sequence of foreground patches, according to one embodiment of the disclosure.</p><p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. <b>7</b>E</figref> illustrates a method for computing a micro-feature value based on the pixel-level periodic and aperiodic change characteristic, according to one embodiment of the disclosure.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0006" level="1">DETAILED DESCRIPTION</heading><p id="p-0034" num="0033">Embodiments of the disclosure extract micro-features of one or more images based on pixel-level characteristics. The extraction is unsupervised, i.e., performed independent of any training data that defines particular objects, allowing a behavior-recognition system to forgo a training phase and for object classification to proceed without being constrained by specific object definitions. A micro-feature extractor that does not require training data is adaptive and self-trains while performing the extraction. The extracted micro-features are heuristic features of foreground patches depicting objects and are represented as a micro-feature vector that is input to a micro-classifier which identifies particular object types.</p><p id="p-0035" num="0034">The micro-feature extractor and micro-classifier may be included within a behavior-recognition system which may be configured to identify, learn, and recognize patterns of behavior by observing and evaluating events depicted by a sequence of video frames. In a particular embodiment, the behavior-recognition system may include both a computer vision engine and a machine learning engine. The computer vision engine may be configured to receive and evaluate a stream of video frames. Each frame may include data representing the color, grayscale, and/or intensity values for each pixel in the frame. A frame of video may be characterized using multiple color channels (e.g., a radiance value between 0-255 and a set of red, green, and blue (RGB) color channels values, each between 0-255). Further, the computer vision engine may generate a background image by observing the scene over a number of video frames. For example, consider a video camera trained on a stretch of a highway. In such a case, the background would include the roadway surface, the medians, any guard rails or other safety devices, and traffic control devices, etc., that are visible to the camera. Vehicles traveling on the roadway (and any other person or thing engaging in some activity) that are visible to the camera would represent scene foreground objects.</p><p id="p-0036" num="0035">The computer vision engine may compare the pixel values for a given frame with the background image and identify objects as they appear and move about the scene. Typically, when a group of pixels in the scene (referred to as a &#x201c;blob&#x201d; or &#x201c;patch&#x201d;) is observed with appearance values that differ substantially from the background image, that region is identified as a foreground patch that likely depicts a foreground object. As described in greater detail below, pixel-level characteristics of the foreground patch are computed and used to extract pixel-level micro-features that are represented as a micro-feature vector. The micro-feature vector corresponding to the foreground patch may be evaluated to allow the system to distinguish among different types of foreground objects (e.g., a vehicle or a person) on the basis of the micro features. Further, the computer vision engine may identify features (e.g., height/width in pixels, color values, shape, area, pixel distributions, and the like) used to track the object from frame-to-frame. Further still, the computer vision engine may derive a variety of information while tracking the object from frame-to-frame, e.g., position, current (and projected) trajectory, direction, orientation, velocity, rigidity, acceleration, size, and the like. In one embodiment, the computer vision outputs this information and/or the micro-feature vector as a stream describing a collection of kinematic information related to each foreground patch in the video frames.</p><p id="p-0037" num="0036">Data output from the computer vision engine may be supplied to the machine learning engine. In one embodiment, the machine learning engine may evaluate the context events to generate &#x201c;primitive events&#x201d; describing object behavior. Each primitive event may provide some semantic meaning to a group of one or more context events. For example, assume a camera records a car entering a scene, and that the car turns and parks in a parking spot. In such a case, the computer vision engine could initially recognize the car as a foreground object; classify it as being a vehicle, and output kinematic data describing the position, movement, speed, etc., of the car in the context event stream. In turn, a primitive event detector could generate a stream of primitive events from the context event stream such as &#x201c;vehicle appears,&#x201d; vehicle turns,&#x201d; &#x201c;vehicle slowing,&#x201d; and &#x201c;vehicle stops&#x201d; (once the kinematic information about the car indicated a speed of 0). As events occur, and re-occur, the machine learning engine may create, encode, store, retrieve, and reinforce patterns representing the events observed to have occurred, e.g., long-term memories representing a higher-level abstraction of a car parking in the scene&#x2014;generated from the primitive events underlying the higher-level abstraction. Further still, patterns representing an event of interest may result in alerts passed to users of the behavioral recognition system.</p><p id="p-0038" num="0037">In the following, reference is made to embodiments of the disclosure. However, it should be understood that the invention/disclosure is not limited to any specifically described embodiment. Instead, any combination of the following features and elements, whether related to different embodiments or not, is contemplated to implement and practice the disclosure. Furthermore, in various embodiments the disclosure provides numerous advantages over the prior art. However, although embodiments of the disclosure may achieve advantages over other possible solutions and/or over the prior art, whether or not a particular advantage is achieved by a given embodiment is not limiting of the disclosure. Thus, the following aspects, features, embodiments and advantages are merely illustrative and are not considered elements or limitations of the appended claims except where explicitly recited in a claim(s). Likewise, reference to &#x201c;the invention&#x201d; shall not be construed as a generalization of any inventive subject matter disclosed herein and shall not be considered to be an element or limitation of the appended claims except where explicitly recited in a claim(s).</p><p id="p-0039" num="0038">One embodiment of the disclosure is implemented as a program product for use with a computer system. The program(s) of the program product defines functions of the embodiments (including the methods described herein) and can be contained on a variety of computer-readable storage media. Examples of computer-readable storage media include (i) non-writable storage media (e.g., read-only memory devices within a computer such as CD-ROM or DVD-ROM disks readable by an optical media drive) on which information is permanently stored; (ii) writable storage media (e.g., floppy disks within a diskette drive or hard-disk drive) on which alterable information is stored. Such computer-readable storage media, when carrying computer-readable instructions that direct the functions of the present disclosure, are embodiments of the present disclosure. Other examples media include communications media through which information is conveyed to a computer, such as through a computer or telephone network, including wireless communications networks.</p><p id="p-0040" num="0039">In general, the routines executed to implement the embodiments of the disclosure can be part of an operating system or a specific application, component, program, module, object, or sequence of instructions. The computer program of the present disclosure is comprised typically of a multitude of instructions that will be translated by the native computer into a machine-readable format and hence executable instructions. Also, programs are comprised of variables and data structures that either reside locally to the program or are found in memory or on storage devices. In addition, various programs described herein may be identified based upon the application for which they are implemented in a specific embodiment of the disclosure. However, it should be appreciated that any particular program nomenclature that follows is used merely for convenience, and thus the invention should not be limited to use solely in any specific application identified and/or implied by such nomenclature.</p><p id="p-0041" num="0040"><figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates components of a video analysis and behavior-recognition system <b>100</b>, according to one embodiment of the present disclosure. As shown, the behavior-recognition system <b>100</b> includes a video input source <b>105</b>, a network <b>110</b>, a computer system <b>115</b>, and input and output devices <b>118</b> (e.g., a monitor, a keyboard, a mouse, a printer, and the like). The network <b>110</b> may transmit video data recorded by the video input <b>105</b> to the computer system <b>115</b>. Illustratively, the computer system <b>115</b> includes a CPU <b>120</b>, storage <b>125</b> (e.g., a disk drive, optical disk drive, floppy disk drive, and the like), and a memory <b>130</b> containing both a computer vision engine <b>135</b> and a machine learning engine <b>140</b>. As described in greater detail below, the computer vision engine <b>135</b> and the machine learning engine <b>140</b> may provide software applications configured to analyze a sequence of video frames provided by the video input <b>105</b>.</p><p id="p-0042" num="0041">Network <b>110</b> receives video data (e.g., video stream(s), video images, or the like) from the video input source <b>105</b>. The video input source <b>105</b> may be a video camera, a VCR, DVR, DVD, computer, web-cam device, or the like. For example, the video input source <b>105</b> may be a stationary video camera aimed at a certain area (e.g., a subway station, a parking lot, a building entry/exit, etc.), which records the events taking place therein. Generally, the area visible to the camera is referred to as the &#x201c;scene.&#x201d; The video input source <b>105</b> may be configured to record the scene as a sequence of individual video frames at a specified frame-rate (e.g., 24 frames per second), where each frame includes a fixed number of pixels (e.g., 320&#xd7;240). Each pixel of each frame may specify a color value (e.g., an RGB value) or grayscale value (e.g., a radiance value between 0-255). Further, the video stream may be formatted using known such formats e.g., MPEG2, MJPEG, MPEG4, H.263, H.264, and the like.</p><p id="p-0043" num="0042">The computer vision engine <b>135</b> may be configured to analyze this raw information to identify foreground patches depicting active objects in the video stream, extract micro-features, and derive a variety of metadata regarding the actions and interactions of such objects, and supply this information to a machine learning engine <b>140</b>. In turn, the machine learning engine <b>140</b> may be configured to classify the objects, evaluate, observe, learn and remember details regarding events (and types of events) that transpire within the scene over time.</p><p id="p-0044" num="0043">In one embodiment, the machine learning engine <b>140</b> receives the video frames and the data generated by the computer vision engine <b>135</b>. The machine learning engine <b>140</b> may be configured to analyze the received data, classify objects, build semantic representations of events depicted in the video frames, detect patterns, and, ultimately, to learn from these observed patterns to identify normal and/or abnormal events. Additionally, data describing whether a normal/abnormal behavior/event has been determined and/or what such behavior/event is may be provided to output devices <b>118</b> to issue alerts, for example, an alert message presented on a GUI interface screen. In general, the computer vision engine <b>135</b> and the machine learning engine <b>140</b> both process video data in real-time. However, time scales for processing information by the computer vision engine <b>135</b> and the machine learning engine <b>140</b> may differ. For example, in one embodiment, the computer vision engine <b>135</b> processes the received video data frame-by-frame, while the machine learning engine <b>140</b> processes data every N-frames. In other words, while the computer vision engine <b>135</b> analyzes each frame in real-time to derive a set of information about what is occurring within a given frame, the machine learning engine <b>140</b> is not constrained by the real-time frame rate of the video input.</p><p id="p-0045" num="0044">Note, however, <figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates merely one possible arrangement of the behavior-recognition system <b>100</b>. For example, although the video input source <b>105</b> is shown connected to the computer system <b>115</b> via the network <b>110</b>, the network <b>110</b> is not always present or needed (e.g., the video input source <b>105</b> may be directly connected to the computer system <b>115</b>). Further, various components and modules of the behavior-recognition system <b>100</b> may be implemented in other systems. For example, in one embodiment, the computer vision engine <b>135</b> may be implemented as a part of a video input device (e.g., as a firmware component wired directly into a video camera). In such a case, the output of the video camera may be provided to the machine learning engine <b>140</b> for analysis. Similarly, the output from the computer vision engine <b>135</b> and machine learning engine <b>140</b> may be supplied over computer network <b>110</b> to other computer systems. For example, the computer vision engine <b>135</b> and machine learning engine <b>140</b> may be installed on a server system and configured to process video from multiple input sources (i.e., from multiple cameras). In such a case, a client application <b>250</b> running on another computer system may request (or receive) the results of over network <b>110</b>.</p><p id="p-0046" num="0045"><figref idref="DRAWINGS">FIG. <b>2</b></figref> further illustrates components of the computer vision engine <b>135</b> and the machine learning engine <b>140</b> first illustrated in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, according to one embodiment of the present disclosure. As shown, the computer vision engine <b>135</b> includes a background/foreground (BG/FG) component <b>205</b>, a tracker component <b>210</b>, and a context processor component <b>220</b>. Collectively, the components <b>205</b>, <b>210</b>, and <b>220</b> provide a pipeline for processing an incoming sequence of video frames supplied by the video input source <b>105</b> (indicated by the solid arrows linking the components). Additionally, the output of one component may be provided to multiple stages of the component pipeline (as indicated by the dashed arrows). In one embodiment, the components <b>205</b>, <b>210</b>, and <b>220</b> may each provide a software module configured to provide the functions described herein. Of course one of ordinary skill in the art will recognize that the components <b>205</b>, <b>210</b>, and <b>220</b> may be combined (or further subdivided) to suit the needs of a particular case.</p><p id="p-0047" num="0046">In one embodiment, the BG/FG component <b>205</b> may be configured to separate each frame of video provided by the video input source <b>105</b> into a stationary or static part (the scene background) and a collection of volatile parts (the scene foreground). The frame itself may include a two-dimensional array of pixel values for multiple channels (e.g., RGB channels for color video or grayscale channel or radiance channel for black and white video). The BG/FG component <b>205</b> may be configured to generate a mask used to identify which pixels of the scene have been determined to depict scene foreground and, conversely, which pixels have been determined to depict scene background. The BG/FG component <b>205</b> then identifies groups of pixels in the scene that contain a portion of scene foreground (referred to as a foreground &#x201c;blob&#x201d; or &#x201c;patch&#x201d;) and supplies this information to subsequent stages of the pipeline. Additionally, portions of the scene determined to depict scene background maybe used to update pixel values in a background image modeling the scene.</p><p id="p-0048" num="0047">The tracker component <b>210</b> may receive the foreground patches produced by the BG/FG component <b>205</b> and generate computational models for the patches. The tracker component <b>210</b> may be configured to use this information, and each successive frame of raw-video, to attempt to track the motion of the objects depicted by the foreground patches as they move about the scene.</p><p id="p-0049" num="0048">The context processor component <b>220</b> may receive the output from other stages of the pipeline (i.e., the tracked objects and the background and foreground models). Using this information, the context processor <b>220</b> may be configured to generate a stream of micro-feature vectors corresponding to foreground patches tracked (by tracker component <b>210</b>). For example, the context processor component <b>220</b> may evaluate a foreground patch from frame-to-frame and output micro-feature vectors including values representing the foreground patch's hue entropy, magnitude-saturation ratio, orientation angle, pixel area, aspect ratio, groupiness (based on the pixel-level spatial distribution), legged-ness, motion vector orientation, rigidity/animateness, periodicity of motion, etc. Additionally, the context processor component <b>220</b> may output a stream of context events describing that foreground patch's height, width (in pixels), position (as a 2D coordinate in the scene), acceleration, velocity, orientation angle, etc. The computer vision engine <b>135</b> may take the outputs of the components <b>205</b>, <b>210</b>, and <b>220</b> describing the motions and actions of the tracked foreground patches in the scene and supply this information to the machine learning engine <b>140</b>.</p><p id="p-0050" num="0049">In some systems, the computer vision engine is configured to classify each tracked object as being one of a known category of objects using training data that defines a plurality of object types. For example, an estimator/identifier component may be included within the computer vision engine to classify a tracked object as being a &#x201c;person,&#x201d; a &#x201c;vehicle,&#x201d; an &#x201c;unknown,&#x201d; or an &#x201c;other.&#x201d; In this context, the classification of &#x201c;other&#x201d; represents an affirmative assertion that the object is neither a &#x201c;person&#x201d; nor a &#x201c;vehicle.&#x201d; Additionally, the estimator/identifier component may identify characteristics of the tracked object, e.g., for a person, a prediction of gender, an estimation of a pose (e.g., standing or sitting) or an indication of whether the person is carrying an object. Such an estimator/identifier component is provided with training data that specifies a plurality of objects that is used to perform the classification.</p><p id="p-0051" num="0050">In contrast, systems that do not include an estimator/identifier component, such the computer vision engine <b>135</b> shown in <figref idref="DRAWINGS">FIG. <b>2</b></figref>, the classification of objects is performed by the micro-feature classifier <b>221</b> in the machine learning engine <b>140</b> using the micro-feature vectors that are produced by the computer vision engine <b>135</b> independent of any training data. By processing the foreground patches independent of training data, extraction and classification may begin earlier and can adapt to recognize a variety of different object types dependent on the specific image data. In particular, since the range of object types is not defined by training data the range is also not restricted. When micro-features are used to classify, objects with similar micro-feature vectors are grouped together in object type clusters. In some embodiments, the micro-feature classifier <b>221</b> may use a combination of a self-organizing map (SOM) adaptive resonance theory (ART) network to assign micro-feature vectors to clusters. In such a case, each cluster represents a distinct object type, without the distinct types having to be defined in advance. Additionally, in some embodiments the behavior recognition system <b>100</b> may be configured to present the foreground objects in a particular object type cluster to a user in order to allow the user to specify an object type label for the cluster.</p><p id="p-0052" num="0051">As is known, a SOM-ART network provides a specialized neural network configured to create object type clusters from a group of inputs, e.g., micro-features vectors. Each object type cluster itself may be characterized by a mean and a variance from a prototype input representing that cluster. The prototype is generated first, as a copy of the input vector used to create a new object type cluster. Subsequently, prototype may be updated as new inputs are mapped to that object type cluster. Additionally, an object type cluster may be characterized by how many input vectors have been used to update that object type cluster&#x2014;after it is initially created. Typically, the more input vectors that map to a given object type cluster, the more significant that object type cluster.</p><p id="p-0053" num="0052">For example, a SOM-ART network may receive a micro-feature vector as input and either update an existing cluster or create a new object type cluster, as determined using a choice test and a vigilance test for the ART network. The choice and vigilance tests are used to evaluate the micro-feature vector passed to the ART network. The choice test provides a ranking of the existing object type clusters, relative to the micro-feature vector input data. Once ranked, the vigilance test evaluates the existing object type clusters to determine whether to map the foreground patch to a given object type cluster. If no object type cluster is found to update using the data supplied to the input layer, evaluated sequentially using the ranked object type clusters, then a new object type cluster is created. That is, once a pattern is found (i.e., the input &#x201c;matches&#x201d; an existing cluster according to the choice and vigilance tests), the prototype for that object type cluster is updated based on the values of the input micro-feature vector. Otherwise, if the micro-feature vector does not match any available object type cluster (using the vigilance test), a new object type cluster is created by storing a new pattern similar to the micro-feature vector. Subsequent micro-feature vectors that most closely resemble the new object type cluster (relative to the others) are then used to update that object type cluster.</p><p id="p-0054" num="0053">In one embodiment, the primitive event detector <b>212</b> may be configured to receive the output of the computer vision engine <b>135</b> (i.e., the video images, the micro-feature vectors, and context event stream) and generate a sequence of primitive events&#x2014;labeling the observed actions or behaviors in the video with semantic meaning. For example, assume the micro-feature classifier <b>221</b> has classified a foreground object as being a member of an object type cluster including vehicles based on the context event stream and/or micro-feature vectors received from the computer vision engine <b>135</b>. The primitive event detector <b>212</b> may generate a semantic symbol stream that is output to the semantics component <b>242</b>, providing a simple linguistic description of actions engaged in by the foreground object. For example, a sequence of primitive events related to observations of the computer vision engine <b>135</b> occurring at a parking lot could include formal language vectors representing the following: &#x201c;vehicle appears in scene,&#x201d; &#x201c;vehicle moves to a given location,&#x201d; &#x201c;vehicle stops moving,&#x201d; &#x201c;person appears proximate to vehicle,&#x201d; &#x201c;person moves,&#x201d; person leaves scene&#x201d; &#x201c;person appears in scene,&#x201d; &#x201c;person moves proximate to vehicle,&#x201d; &#x201c;person disappears,&#x201d; &#x201c;vehicle starts moving,&#x201d; and &#x201c;vehicle disappears.&#x201d; As described in greater detail below, the primitive event stream may be supplied to excite the perceptual associative memory <b>230</b>.</p><p id="p-0055" num="0054">Illustratively, the machine learning engine <b>140</b> includes a long-term memory <b>225</b>, a perceptual memory <b>230</b>, an episodic memory <b>235</b>, a workspace <b>240</b>, codelets <b>245</b>, and a mapper component <b>211</b>. In one embodiment, the perceptual memory <b>230</b>, the episodic memory <b>235</b>, and the long-term memory <b>225</b> are used to identify patterns of behavior, evaluate events that transpire in the scene, and encode and store observations. Generally, the perceptual memory <b>230</b> receives the output of the computer vision engine <b>135</b> (e.g., the context event stream and micro-feature vectors) and a primitive event stream generated by primitive event detector <b>212</b>. The episodic memory <b>235</b> stores data representing observed events with details related to a particular episode, e.g., information describing time and space details related on an event. That is, the episodic memory <b>235</b> may encode specific details of a particular event, i.e., &#x201c;what and where&#x201d; something occurred within a scene, such as a particular vehicle (car A) moved to a location believed to be a parking space (parking space 5) at 9:43 AM.</p><p id="p-0056" num="0055">The long-term memory <b>225</b> may store data generalizing events observed in the scene. To continue with the example of a vehicle parking, the long-term memory <b>225</b> may encode information capturing observations and generalizations learned by an analysis of the behavior of objects in the scene such as &#x201c;vehicles tend to park in a particular place in the scene,&#x201d; &#x201c;when parking vehicles tend to move a certain speed,&#x201d; and &#x201c;after a vehicle parks, people tend to appear in the scene proximate to the vehicle,&#x201d; etc. Thus, the long-term memory <b>225</b> stores observations about what happens within a scene with much of the particular episodic details stripped away. In this way, when a new event occurs, memories from the episodic memory <b>235</b> and the long-term memory <b>225</b> may be used to relate and understand a current event, i.e., the new event may be compared with past experience, leading to both reinforcement, decay, and adjustments to the information stored in the long-term memory <b>225</b>, over time.</p><p id="p-0057" num="0056">Generally, the workspace <b>240</b> provides a computational engine for the machine learning engine <b>140</b>. For example, the workspace <b>240</b> may be configured to copy information from the perceptual memory <b>230</b>, retrieve relevant memories from the episodic memory <b>235</b> and the long-term memory <b>225</b>, select and invoke the execution of one of codelets <b>245</b>. In one embodiment, each codelet <b>245</b> is a software program configured to evaluate different sequences of events and to determine how one sequence may follow (or otherwise relate to) another (e.g., a finite state machine). More generally, the codelet may provide a software module configured to detect interesting patterns from the streams of data fed to the machine learning engine. In turn, the codelet <b>245</b> may create, retrieve, reinforce, or modify memories in the episodic memory <b>235</b> and the long-term memory <b>225</b>. By repeatedly scheduling codelets <b>245</b> for execution, copying memories and percepts to/from the workspace <b>240</b>, the machine learning engine <b>140</b> performs a cognitive cycle used to observe, and learn, about patterns of behavior that occur within the scene.</p><p id="p-0058" num="0057"><figref idref="DRAWINGS">FIG. <b>3</b>A</figref> illustrates an example of the context processor component <b>220</b> of the video analysis system shown in <figref idref="DRAWINGS">FIG. <b>2</b></figref>, according to one embodiment of the disclosure. As stated, the context processor component <b>220</b> may be configured to receive image data <b>305</b> including background and foreground patches with corresponding object identifiers <b>315</b> from video input source <b>105</b> and BG/FG component <b>205</b>. Rather than specifying an object type, the object identifier <b>315</b> uniquely identifies each foreground patch. The context processor component <b>220</b> also receives tracking information from tracker component <b>210</b>. That is, the tracking information is used to follow an object as it moves about the scene&#x2014;allowing the context processor component <b>220</b> to relate the depiction of the object in one frame to the depiction of that object in subsequent frames. Context processor component <b>220</b> includes a characteristic computation unit <b>310</b>, micro-feature extractor <b>320</b>, and threshold values <b>325</b>. The characteristic computation unit <b>310</b> is configured to process the image data and produce pixel-level characteristic(s) <b>330</b>. The pixel-level characteristic(s) <b>330</b> may include hue values, saturation values, magnitude values, orientation of a major axis of the foreground patch, a foreground patch bounding box, area of the foreground patch, horizontal and vertical pixel distribution, a star skeleton and corresponding angles, per-pixel position gradients, covariance matrices, frequency spectrums, and the like, for the foreground patches.</p><p id="p-0059" num="0058">The micro-feature extractor <b>320</b> receives the pixel level characteristic(s) <b>330</b> and computes micro-feature values that are output as elements of the micro-feature vectors <b>300</b>. Examples of micro-feature values include values representing the foreground patch's hue entropy, magnitude-saturation ratio, orientation angle, pixel area, aspect ratio, groupiness (based on the pixel-level spatial distribution), legged-ness, verticality (based on per-pixel gradients), animateness, periodicity of motion, etc. Valid micro-feature values may range in value from 0 to 1 (inclusive) and &#x2212;1 may be used to represent an invalid micro-feature value that should not be used for classification. The micro-feature values may be represented in a floating point format.</p><p id="p-0060" num="0059">Threshold values <b>325</b> stores values that are used by the micro-feature extractor <b>320</b> to determine whether or not a valid micro-feature value may be computed. When a valid micro-feature value cannot be computed, according to the threshold value for that particular micro-feature, the micro-feature value is set to a predetermined value, e.g., &#x2212;1. The threshold values for each particular micro-feature may be programmed. Examples of threshold values include a minimum area of a foreground patch, a minimum height or width of a bounding box, the minimum speed for being able to compute the moving angle of a tracked object.</p><p id="p-0061" num="0060"><figref idref="DRAWINGS">FIG. <b>3</b>B</figref> illustrates a method for extracting pixel-level based micro-features, according to one embodiment of the disclosure. As shown, the method begins at step <b>350</b> where the image data and an object identifier are received by characteristic computation unit <b>310</b>. At step <b>355</b> the characteristic computation unit <b>310</b> identifies a region of pixels that includes the foreground patch identified by the BG/FG component <b>205</b>. The region may be a bounding box that is minimally-sized to include the foreground patch or a larger region that includes the foreground patch. At step <b>360</b> the characteristic computation unit <b>310</b> determines one or more pixel-level characteristics for the region of pixels and outputs the pixel-level characteristics to the micro-feature extractor <b>320</b>.</p><p id="p-0062" num="0061">At step <b>365</b> the micro-feature extractor <b>320</b> determines if a threshold value provided by threshold values <b>325</b> is met for the region of pixels, and, if not, at step <b>370</b> the micro-feature value is set to &#x2212;1. Otherwise, at step <b>375</b>, the micro-feature value is computed, as described further herein. At step <b>380</b> the micro-feature extractor <b>320</b> determines if another micro-feature value should be computed, and, if so, then steps <b>365</b> and step <b>370</b> or <b>375</b> are repeated to produce each additional micro-feature value. The computation of specific micro-features may be enabled or disabled.</p><p id="p-0063" num="0062">When the micro-feature extractor <b>320</b> determines that all of the micro-feature values have been computed in step <b>380</b>, the micro-feature extractor <b>320</b> proceeds to step <b>385</b> and outputs a micro-feature vector for the foreground patch that includes each of the computed micro-feature values as an element in the vector. At step <b>390</b> the machine-learning engine <b>140</b> classifies the foreground patch into an object type cluster using the micro-feature vector <b>390</b>. Typically, it is expected that foreground patches depicting different instances of the same object type (e.g., vehicles) will have similar micro-feature vector values. By using a variety of the different micro-features, a greater number of different object type clusters may be generated to allow the micro-feature classifier to more accurately distinguish between different types of foreground objects present in a given scene. That is, the micro-feature classifier allows the system to distinguish between vehicles and people, without having to rely on predefined descriptions or definitions of these object types.</p><p id="p-0064" num="0063"><figref idref="DRAWINGS">FIG. <b>4</b>A</figref> illustrates a graphical representation of foreground patches <b>405</b> and <b>425</b> and corresponding hue (color) distribution graphs <b>410</b> and <b>415</b>, according to one embodiment of the disclosure. Pixel region <b>400</b> includes a foreground patch <b>405</b> depicting a first foreground object. The different patterns for different portions of the foreground patch <b>405</b> indicate different hues. The hue distribution graph <b>410</b> indicates a pixel count for each of the different hues within the foreground patch <b>405</b>. Pixel region <b>420</b> includes a foreground patch <b>425</b> depicting a second foreground object that should be grouped into a different object type cluster than the first foreground object. Again, the different patterns for different portions of the foreground patch <b>425</b> indicate different hues and the hue distribution graph <b>415</b> indicates a pixel count for each of the different hues within the foreground patch <b>425</b>. Notice that the hues shown in hue distribution graph <b>415</b> have a wider hue variation compared with the hues shown in hue distribution graph <b>410</b>. Based on the analysis of many images and image sequences, foreground patches corresponding to vehicles have lower hue entropy, i.e, have more uniform color, compared with foreground patches corresponding to people. Therefore, hue entropy is a micro-feature value that may contribute to classifying the foreground patch into a particular object type cluster over another object type cluster. Similarly, a measure of shininess or specular reflectivity of the foreground patch may be used to distinguish between different types of objects observed in a scene. Shininess may be indicated by the ratio of color magnitude to saturation.</p><p id="p-0065" num="0064"><figref idref="DRAWINGS">FIG. <b>4</b>B</figref> illustrates a method for computing a micro-feature value based on the pixel-level hue characteristic, according to one embodiment of the disclosure. As shown, one method for performing step <b>375</b> of <figref idref="DRAWINGS">FIG. <b>3</b>B</figref> begins at step <b>430</b> where the characteristic computation unit <b>310</b> outputs the pixel-level characteristic of hue values for the foreground patch. At step <b>432</b> the micro-feature extractor <b>320</b> computes the hue entropy for the foreground patch. The following equation (Equation 1) may be used to compute the hue entropy value:</p><p id="p-0066" num="0000"><maths id="MATH-US-00001" num="00001"><math overflow="scroll"> <mrow>  <mrow>   <mi>Entropy</mi>   <mo>&#x2261;</mo>   <mrow>    <munderover>     <mo>&#x2211;</mo>     <mrow>      <mi>k</mi>      <mo>=</mo>      <mn>1</mn>     </mrow>     <mi>N</mi>    </munderover>    <mrow>     <msub>      <mi>P</mi>      <mi>k</mi>     </msub>     <mo>&#x2062;</mo>     <mrow>      <msub>       <mi>log</mi>       <mn>2</mn>      </msub>      <mo>(</mo>      <msub>       <mi>P</mi>       <mi>k</mi>      </msub>      <mo>)</mo>     </mrow>     <mo>/</mo>     <msub>      <mi>log</mi>      <mn>2</mn>     </msub>     <mo>&#x2062;</mo>     <mi>N</mi>    </mrow>   </mrow>  </mrow>  <mo>,</mo> </mrow></math></maths></p><p id="p-0067" num="0000">where N is the number of pixels in the foreground patch and P is the hue. The hue entropy value is a normalized value between 0 and 1. At step <b>434</b> the micro-feature extractor <b>320</b> sets the micro-feature value to the computed entropy value for the foreground patch. The computed hue entropy value is included as an element of a micro-feature vector with an object identifier corresponding to the foreground patch.</p><p id="p-0068" num="0065"><figref idref="DRAWINGS">FIG. <b>4</b>C</figref> illustrates a method for computing a micro-feature value based on the pixel-level magnitude-saturation ratio (shininess or specular reflectivity) characteristic, according to one embodiment of the disclosure. In addition to hue, colors include a magnitude and saturation components that may be used to compute a micro-feature value. The characteristic computation unit <b>310</b> performs gray-channel equalization on the foreground patch to produce magnitude and saturation values as a pixel-level characteristic. As shown, another method for performing step <b>375</b> of FIG. <b>3</b>B begins at step <b>440</b> where the micro-feature extractor <b>320</b> receives magnitude and saturation values from the characteristic computation unit <b>310</b>. At step <b>442</b> the micro-feature extractor <b>320</b> computes the per-pixel magnitude and the per-pixel saturation to produce an ensemble of magnitude-saturation ratios for the foreground patch. At step <b>444</b> the micro-feature extractor <b>320</b> computes a normalized magnitude-saturation ratio using the ensemble of magnitude-saturation ratios for the foreground patch. At step <b>446</b> the micro-feature extractor <b>320</b> sets the micro-feature value to the computed normalized magnitude-saturation ratio for the foreground patch. The computed normalized magnitude-saturation ratio value is included as an element of a micro-feature vector with an object identifier corresponding to the foreground patch.</p><p id="p-0069" num="0066"><figref idref="DRAWINGS">FIG. <b>4</b>D</figref> illustrates a graphical representation of foreground patches <b>405</b> and <b>425</b> and corresponding orientation lines <b>450</b> and <b>460</b>, according to one embodiment of the disclosure. Again, pixel region <b>400</b> includes a foreground patch <b>405</b> depicting a first foreground object and pixel region <b>420</b> includes a foreground patch <b>425</b> depicting a second foreground object that should be classified in a different object type cluster than the first foreground object. The orientation lines <b>450</b> and <b>460</b> indicate an orientation of the foreground patch <b>405</b> and <b>425</b>, respectively, relative to a horizontal axis <b>452</b> and a vertical axis <b>454</b>. Notice that the orientation line <b>450</b> is more closely aligned with the horizontal axis <b>452</b>, in contrast with the orientation line <b>460</b> that is more closely aligned with the vertical axis <b>454</b>. Based on the analysis of many images and image sequences, foreground patches corresponding to vehicles are more likely to be horizontally oriented, compared with foreground patches corresponding to people that are more likely to be vertically oriented. Therefore, major axis alignment is a micro-feature value that may contribute to classifying the foreground patch into a particular object type cluster over another object type cluster.</p><p id="p-0070" num="0067"><figref idref="DRAWINGS">FIG. <b>4</b>E</figref> illustrates a method for computing a micro-feature value based on the pixel-level orientation characteristic, according to one embodiment of the disclosure. As shown, another method for performing step <b>375</b> of <figref idref="DRAWINGS">FIG. <b>3</b>B</figref> begins at step <b>462</b> where the micro-feature extractor <b>320</b> determines the major axis alignment of the foreground based on the orientation line that is provided by the characteristic computation unit <b>310</b>. At step <b>464</b> the micro-feature extractor <b>320</b> computes the absolute value of the cosine of the angle of alignment for the orientation line. At step <b>466</b> the micro-feature extractor <b>320</b> sets the micro-feature value to the absolute value of the computed cosine of the angle of alignment for the orientation line of the foreground patch. The absolute value of the computed cosine of the angle of alignment is included as an element of a micro-feature vector with an object identifier corresponding to the foreground patch.</p><p id="p-0071" num="0068"><figref idref="DRAWINGS">FIG. <b>4</b>F</figref> illustrates a graphical representation of foreground patches <b>405</b> and <b>425</b> and corresponding bounding boxes <b>470</b> and <b>475</b>, according to one embodiment of the disclosure. Bounding box <b>470</b> has a height <b>471</b> and width <b>473</b> encloses foreground patch <b>405</b> and bounding box <b>475</b> has a height <b>477</b> and width <b>479</b> that encloses foreground patch <b>425</b>. Notice that foreground patch <b>405</b> covers more pixels within bounding box <b>470</b> compared with the number of pixels within the bounding box <b>475</b> that are covered by the foreground patch <b>425</b>. Based on the analysis of many images and image sequences, foreground patches corresponding to vehicles are more likely to be have a greater normalized area (area of the foreground object divided by the area of the bounding box), compared with foreground patches corresponding to people that are more likely to have a smaller normalized area. Therefore, normalized area is a micro-feature value that may contribute to classifying the foreground patch into a particular object type cluster over another object type cluster.</p><p id="p-0072" num="0069">Similarly, notice that the aspect ratio (height/width) of the bounding box <b>470</b> is lower (shorter) compared with the aspect ratio of the bounding box <b>475</b>. Based on the analysis of many images and image sequences, foreground patches corresponding to vehicles are more likely to be have a lower aspect ratios, compared with foreground patches corresponding to people that are more likely to have a higher (taller) aspect ratios. Therefore, aspect ratio is a micro-feature value that may contribute to classifying the foreground patch into a particular object type cluster over another object type cluster.</p><p id="p-0073" num="0070"><figref idref="DRAWINGS">FIG. <b>4</b>G</figref> illustrates a method for computing a micro-feature value based on the foreground patch area characteristic, according to one embodiment of the disclosure. As shown, another method for performing step <b>375</b> of <figref idref="DRAWINGS">FIG. <b>3</b>B</figref> begins at step <b>472</b> where the micro-feature extractor <b>320</b> determines the area of the bounding box (pixel region) that is provided by the characteristic computation unit <b>310</b>. At step <b>474</b> where the micro-feature extractor <b>320</b> determines the area of the foreground patch. At step <b>476</b> the micro-feature extractor <b>320</b> computes the normalized area of the foreground patch by dividing the area of the foreground patch by the area of the bounding box. At step <b>478</b> the micro-feature extractor <b>320</b> sets the micro-feature value to the computed normalized area of the foreground patch. The computed normalized area value is included as an element of a micro-feature vector with an object identifier corresponding to the foreground patch.</p><p id="p-0074" num="0071"><figref idref="DRAWINGS">FIG. <b>4</b>H</figref> illustrates a method for computing a micro-feature value based on the bounding box aspect area characteristic, according to one embodiment of the disclosure. As shown, another method for performing step <b>375</b> of <figref idref="DRAWINGS">FIG. <b>3</b>B</figref> begins at step <b>482</b> where the micro-feature extractor <b>320</b> determines the aspect ratio of the foreground patch based on the bounding box (pixel region) that is provided by the characteristic computation unit <b>310</b>. The height may be dived by the width or the width may be divided by the height to compute the aspect ratio of the bounding box. At step <b>483</b> the aspect ratio is normalized. At step <b>484</b> the micro-feature extractor <b>320</b> sets the micro-feature value to the computed (normalized) aspect ratio of the foreground patch. The computed aspect ratio value is included as an element of a micro-feature vector with an object identifier corresponding to the foreground patch.</p><p id="p-0075" num="0072"><figref idref="DRAWINGS">FIG. <b>5</b>A</figref> illustrates a graphical representation of foreground patches <b>500</b> and <b>505</b> and corresponding pixel distribution graphs <b>510</b>, <b>512</b>, <b>515</b>, and <b>517</b>, according to one embodiment of the disclosure. Pixel region <b>520</b> includes a foreground patch <b>500</b> depicting a first foreground object. The horizontal distribution graph <b>510</b> indicates a count of pixels covered by the foreground patch <b>500</b> for each of the different positions along the horizontal axis. The vertical distribution graph <b>512</b> indicates a count of pixels covered by the foreground patch <b>500</b> for each of the different positions along the vertical axis. Pixel region <b>525</b> includes a foreground patch <b>505</b> depicting a second foreground object that should be classified into a different object type cluster than the first foreground object. The horizontal distribution graph <b>515</b> indicates a count of pixels covered by the foreground patch <b>505</b> for each of the different positions along the horizontal axis. The vertical distribution graph <b>517</b> indicates a count of pixels covered by the foreground patch <b>505</b> for each of the different positions along the vertical axis. Notice that the horizontal pixel distribution of the foreground patch <b>500</b> shown in horizontal distribution graph <b>510</b> has a single local maximum (peak) compared with the horizontal pixel distribution of the foreground patch <b>505</b> shown in horizontal distribution graph <b>515</b> which has three distinct local maximums. Based on the analysis of many images and image sequences, foreground patches corresponding to multiple objects (object groups) have multiple local maximums in at least one of the horizontal or vertical distribution graphs, compared with foreground patches corresponding to a single object. Therefore, horizontal and vertical pixel distribution (groupiness) is a micro-feature value that may contribute to classifying the foreground patch into a particular object type cluster over another object type cluster or over individual objects.</p><p id="p-0076" num="0073"><figref idref="DRAWINGS">FIG. <b>5</b>B</figref> illustrates a method for computing a micro-feature value based on the pixel distribution characteristic, according to one embodiment of the disclosure. As shown, another method for performing step <b>375</b> of <figref idref="DRAWINGS">FIG. <b>3</b>B</figref> begins at step <b>530</b> where the micro-feature extractor <b>320</b> receives the horizontal pixel distribution of the foreground patch that is determined by the characteristic computation unit <b>310</b>. At step <b>535</b> the micro-feature extractor <b>320</b> receives the vertical pixel distribution of the foreground patch that is determined by the characteristic computation unit <b>310</b>. At step <b>540</b> the micro-feature extractor <b>320</b> computes the groupiness value based on the distribution. The groupiness value is computed using the following equation, (number of vertical peaks+number of horizontal peaks&#x2212;2)/5. For a single object the equation will produce a groupiness value of 0 (number of vertical peaks=number of horizontal peaks=1). For multiple objects consisting of 6 individual objects the equation will produce a groupiness value of 1 (for example, number of vertical peaks=6, number of horizontal peaks=1, produces a value of 1). When the computed groupiness value is greater than 1 it is clamped to 1. Note that the denominator of 5 may be changed to a different number to tune the micro-feature extractor <b>320</b>.</p><p id="p-0077" num="0074">At step <b>550</b> the micro-feature extractor <b>320</b> sets the micro-feature value to the computed groupiness value of the foreground patch. The computed groupiness value is included as an element of a micro-feature vector with an object identifier corresponding to the foreground patch.</p><p id="p-0078" num="0075"><figref idref="DRAWINGS">FIG. <b>6</b>A</figref> illustrates a graphical representation of foreground patch <b>600</b> within pixel region <b>610</b> and a corresponding star skeleton <b>620</b>, according to one embodiment of the disclosure. The characteristic computation unit <b>310</b> determines a centroid <b>605</b> of the foreground patch <b>600</b>. The centroid <b>605</b> is a position that is identified by first obtaining the perimeter or boundary of a mask of the foreground patch <b>600</b>. The average of the x-axis coordinates and the y-axis coordinates are computed and are the position of the centroid <b>605</b>.</p><p id="p-0079" num="0076">A segment is generated extending from the centroid to points on the outside of the foreground patch <b>600</b>. The points are determined by computing the distance from each point on the boundary from the centroid. A vector is formed using the computed distances and each local maxima of the vector corresponds to a point. Each pair of neighboring segments defines an angle, e.g., angles <b>612</b>, <b>613</b>, <b>614</b>, and <b>615</b>. Notice that the angles defined by points positioned below the centroid <b>605</b> correspond to &#x201c;legs&#x201d; of the foreground patch <b>600</b>. A legged-ness value may be computed based on measurements of these angles. Based on the analysis of many images and image sequences, foreground patches corresponding to two or more legs have a high legged-ness value, compared with foreground patches corresponding to an object have no legs or a single leg. Therefore, legged-ness is a micro-feature value that may contribute to classifying the foreground patch into a particular object type cluster over another object type cluster.</p><p id="p-0080" num="0077"><figref idref="DRAWINGS">FIG. <b>6</b>B</figref> illustrates a method for computing a micro-feature value based on the star skeleton characteristic, according to one embodiment of the disclosure. As shown, another method for performing step <b>375</b> of <figref idref="DRAWINGS">FIG. <b>3</b>B</figref> begins at step <b>635</b> where the micro-feature extractor <b>320</b> receives the star skeleton of the foreground patch that is generated by the characteristic computation unit <b>310</b>. At step <b>640</b> the micro-feature extractor <b>320</b> computes the angles between neighboring star segments of points that are below the centroid. In some embodiments, angles that are less than 20 degrees or greater than 140 degrees are set to a value of 0 since a small angle between legs may be inaccurate and it is unnatural to have a large angle between legs. Angles that are between 20 and 140 degrees (inclusive) are scaled to produce scaled angles. In some embodiments scaled angles for angles between 20 and 80 degrees are computed as, scaled_angle=(angle&#x2212;20)/60 and scaled angles for angles between 80 and 140 degrees are computed as scaled_angle=(140&#x2212;angle)/60.</p><p id="p-0081" num="0078">At step <b>645</b> the micro-feature extractor <b>320</b> computes the legged-ness value based on the distribution. The legged-ness value may be computed by summing each scaled angle divided by a denominator equal to the number of scaled angles being summed. A legged-ness value that is greater than 1 may be clamped to 1. In some embodiments the denominator may be changed to tune the micro-feature extractor <b>320</b>. At step <b>650</b> the micro-feature extractor <b>320</b> sets the micro-feature value to the computed legged-ness value of the foreground patch. The legged-ness value may be measured over several frames to accurately characterize the foreground patch. The computed legged-ness value is included as an element of a micro-feature vector with an object identifier corresponding to the foreground patch.</p><p id="p-0082" num="0079"><figref idref="DRAWINGS">FIG. <b>7</b>A</figref> illustrates a graphical representation of foreground patches <b>705</b> and corresponding per-pixel gradients <b>710</b>, according to one embodiment of the disclosure. A frame pixel region <b>700</b> includes the foreground patch <b>705</b> depicting a first foreground object. The computed per-pixel gradients (dx/dy) <b>710</b> is a graph indicating the instantaneous pixel-level gradients for the foreground patches <b>705</b>. The horizontal gradients of a patch (dx) are computed by filtering the patch with [&#x2212;1 0 1]. The vertical gradients (dy) are computed by filtering the patch with</p><p id="p-0083" num="0000"><maths id="MATH-US-00002" num="00002"><math overflow="scroll"> <mrow>  <mrow>   <mo>[</mo>   <mtable>    <mtr>     <mtd>      <mn>1</mn>     </mtd>    </mtr>    <mtr>     <mtd>      <mn>0</mn>     </mtd>    </mtr>    <mtr>     <mtd>      <mrow>       <mo>-</mo>       <mn>1</mn>      </mrow>     </mtd>    </mtr>   </mtable>   <mo>]</mo>  </mrow>  <mo>.</mo> </mrow></math></maths></p><p id="p-0084" num="0080">As shown in <figref idref="DRAWINGS">FIG. <b>7</b>A</figref>, the pixel-level gradients indicate that the first foreground object is moving in a horizontal direction. Based on the analysis of many images, foreground patches of foreground objects in the same object type cluster as the first foreground object have horizontal per-pixel gradients, compared with foreground patches of foreground objects that depict humans that have vertical per-pixel gradients. Therefore, per-pixel gradients are a micro-feature value that may contribute to classifying the foreground patch into a particular object type cluster over another object type cluster.</p><p id="p-0085" num="0081"><figref idref="DRAWINGS">FIG. <b>7</b>B</figref> illustrates a method for computing a micro-feature value based on the per-pixel gradients characteristic, according to one embodiment of the disclosure. As shown, another method for performing step <b>375</b> of <figref idref="DRAWINGS">FIG. <b>3</b>B</figref> begins at step <b>740</b> where the micro-feature extractor <b>320</b> receives the per-pixel gradients of a frame pixel region including the foreground patch from the characteristic computation unit <b>310</b>. At step <b>745</b> the micro-feature extractor <b>320</b> computes the verticality value based on the per-pixel gradients. The verticality value is computed by summing the number of pixels having gradient angles between 171 and 180 degrees. The sum is normalized by norm_ver=(width/3)*0.2)*height&#x2212;(height/3)*0.2*2), where width and height are dimensions of the foreground patch. The norm_ver value may be modified to tune the micro-feature extractor <b>320</b>. At step <b>750</b> the micro-feature extractor <b>320</b> sets the micro-feature value to the computed verticality value of the foreground patch. The verticality value may be measured over several frames to accurately characterize the foreground patch. The computed verticality value is included as an element of a micro-feature vector with an object identifier corresponding to the foreground patch.</p><p id="p-0086" num="0082"><figref idref="DRAWINGS">FIG. <b>7</b>C</figref> illustrates a method for computing a micro-feature value based on the covariance matrix characteristic, according to one embodiment of the disclosure. Similar to the per-pixel gradients, a change in silhouette of a foreground patch may be used to distinguish between different object types. Foreground patches that depict people tend to have a high animateness (highly changing silhouette) compared with foreground patches that depict vehicles which are more rigid (no or small changes to the silhouette). The animateness may be indicated by the change in position of the pixels within the foreground patch. A covariance matrix is determined for each new frame pixel region that indicates the change in position for each pixel in the foreground patch. Therefore, an animateness value that is computed using covariance matrices is a micro-feature value that may contribute to classifying the foreground patch into a particular object type cluster over another object type cluster.</p><p id="p-0087" num="0083">As shown, another method for performing step <b>375</b> of <figref idref="DRAWINGS">FIG. <b>3</b>B</figref> begins at step <b>756</b> where the micro-feature extractor <b>320</b> receives a covariance matrix for the foreground patch that is generated by the characteristic computation unit <b>310</b>. At step <b>758</b> the micro-feature extractor <b>320</b> computes the animateness value using the covariance matrix. The animateness is computes as the accumulated changing rate of the covariance matrix. The following equation (Equation 2) provides the definition of the covariance matrix for the foreground patch, where {x<sub>k</sub>, y<sub>k</sub>|k=1, . . . , N} are silhouette pixel positions in the foreground patch image.</p><p id="p-0088" num="0000"><maths id="MATH-US-00003" num="00003"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mrow>      <mi>Covariance</mi>      <mo>&#x2261;</mo>      <mrow>       <mo>[</mo>       <mtable>        <mtr>         <mtd>          <msub>           <mi>C</mi>           <mi>xx</mi>          </msub>         </mtd>         <mtd>          <msub>           <mi>C</mi>           <mrow>            <mi>x</mi>            <mo>&#x2062;</mo>            <mi>y</mi>           </mrow>          </msub>         </mtd>        </mtr>        <mtr>         <mtd>          <msub>           <mi>C</mi>           <mrow>            <mi>y</mi>            <mo>&#x2062;</mo>            <mi>x</mi>           </mrow>          </msub>         </mtd>         <mtd>          <msub>           <mi>C</mi>           <mrow>            <mi>y</mi>            <mo>&#x2062;</mo>            <mi>y</mi>           </mrow>          </msub>         </mtd>        </mtr>       </mtable>       <mo>]</mo>      </mrow>     </mrow>     <mo>,</mo>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mrow>      <mi>Equ</mi>      <mo>.</mo>      <mtext>   </mtext>      <mn>2</mn>     </mrow>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths><maths id="MATH-US-00003-2" num="00003.2"><math overflow="scroll"> <mi>where</mi></math></maths><maths id="MATH-US-00003-3" num="00003.3"><math overflow="scroll"> <mrow>  <mrow>   <msub>    <mi>C</mi>    <mrow>     <mi>x</mi>     <mo>&#x2062;</mo>     <mi>x</mi>    </mrow>   </msub>   <mo>&#x2261;</mo>   <mrow>    <mfrac>     <mn>1</mn>     <mrow>      <mi>N</mi>      <mo>-</mo>      <mn>1</mn>     </mrow>    </mfrac>    <mo>&#x2062;</mo>    <mrow>     <munderover>      <mo>&#x2211;</mo>      <mrow>       <mi>k</mi>       <mo>=</mo>       <mn>1</mn>      </mrow>      <mi>N</mi>     </munderover>     <msup>      <mrow>       <mo>(</mo>       <mrow>        <msub>         <mi>x</mi>         <mi>k</mi>        </msub>        <mo>-</mo>        <msub>         <mi>x</mi>         <mi>mean</mi>        </msub>       </mrow>       <mo>)</mo>      </mrow>      <mn>2</mn>     </msup>    </mrow>   </mrow>  </mrow>  <mo>,</mo> </mrow></math></maths><maths id="MATH-US-00003-4" num="00003.4"><math overflow="scroll"> <mrow>  <mrow>   <msub>    <mi>c</mi>    <mrow>     <mi>y</mi>     <mo>&#x2062;</mo>     <mi>y</mi>    </mrow>   </msub>   <mo>&#x2261;</mo>   <mrow>    <mfrac>     <mn>1</mn>     <mrow>      <mi>N</mi>      <mo>-</mo>      <mn>1</mn>     </mrow>    </mfrac>    <mo>&#x2062;</mo>    <mrow>     <munderover>      <mo>&#x2211;</mo>      <mrow>       <mi>k</mi>       <mo>=</mo>       <mn>1</mn>      </mrow>      <mi>N</mi>     </munderover>     <msup>      <mrow>       <mo>(</mo>       <mrow>        <msub>         <mi>y</mi>         <mi>k</mi>        </msub>        <mo>-</mo>        <msub>         <mi>y</mi>         <mi>mean</mi>        </msub>       </mrow>       <mo>)</mo>      </mrow>      <mn>2</mn>     </msup>    </mrow>   </mrow>  </mrow>  <mo>,</mo>  <mi>and</mi> </mrow></math></maths><maths id="MATH-US-00003-5" num="00003.5"><math overflow="scroll"> <mrow>  <msub>   <mi>C</mi>   <mrow>    <mi>x</mi>    <mo>&#x2062;</mo>    <mi>y</mi>   </mrow>  </msub>  <mo>&#x2261;</mo>  <msub>   <mi>C</mi>   <mrow>    <mi>x</mi>    <mo>&#x2062;</mo>    <mi>y</mi>   </mrow>  </msub>  <mo>&#x2261;</mo>  <mrow>   <mfrac>    <mn>1</mn>    <mrow>     <mi>N</mi>     <mo>-</mo>     <mn>1</mn>    </mrow>   </mfrac>   <mo>&#x2062;</mo>   <mrow>    <munderover>     <mo>&#x2211;</mo>     <mrow>      <mi>k</mi>      <mo>=</mo>      <mn>1</mn>     </mrow>     <mi>N</mi>    </munderover>    <mrow>     <mrow>      <mo>(</mo>      <mrow>       <msub>        <mi>x</mi>        <mi>k</mi>       </msub>       <mo>-</mo>       <msub>        <mi>x</mi>        <mi>mean</mi>       </msub>      </mrow>      <mo>)</mo>     </mrow>     <mo>&#x2062;</mo>     <mrow>      <mrow>       <mo>(</mo>       <mrow>        <msub>         <mi>y</mi>         <mi>k</mi>        </msub>        <mo>-</mo>        <msub>         <mi>y</mi>         <mi>mean</mi>        </msub>       </mrow>       <mo>)</mo>      </mrow>      <mo>.</mo>     </mrow>    </mrow>   </mrow>  </mrow> </mrow></math></maths></p><p id="p-0089" num="0084">The following equation (Equation 3) may be used to compute a metric distance between covariance matrices:</p><p id="p-0090" num="0000"><maths id="MATH-US-00004" num="00004"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mrow>      <mrow>       <mi>Distance</mi>       <mo>&#x2062;</mo>       <mtext>   </mtext>       <mrow>        <mo>(</mo>        <mrow>         <msub>          <mi>COV</mi>          <mn>1</mn>         </msub>         <mo>,</mo>         <msub>          <mi>COV</mi>          <mn>2</mn>         </msub>        </mrow>        <mo>)</mo>       </mrow>      </mrow>      <mo>&#x2261;</mo>      <msqrt>       <mrow>        <munder>         <mover>          <mo>&#x2211;</mo>          <mn>2</mn>         </mover>         <mrow>          <mi>k</mi>          <mo>=</mo>          <mn>1</mn>         </mrow>        </munder>        <mrow>         <msup>          <mi>ln</mi>          <mn>2</mn>         </msup>         <mo>&#x2062;</mo>         <mrow>          <msub>           <mi>S</mi>           <mi>k</mi>          </msub>          <mo>(</mo>          <mrow>           <msub>            <mi>COV</mi>            <mn>1</mn>           </msub>           <mo>,</mo>           <msub>            <mi>COV</mi>            <mn>2</mn>           </msub>          </mrow>          <mo>)</mo>         </mrow>        </mrow>       </mrow>      </msqrt>     </mrow>     <mo>,</mo>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mrow>      <mi>Equ</mi>      <mo>.</mo>      <mtext>   </mtext>      <mn>3</mn>     </mrow>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0091" num="0000">Where {S<sub>1</sub>(COV<sub>1</sub>, COV<sub>2</sub>), {S<sub>2</sub>(COV<sub>1</sub>, COV<sub>2</sub>)} are the generalized eigenvalues of the covariance matrices, COV<sub>1 </sub>and COV<sub>2</sub>. The following equation (Equation 4) may be used to compute the animateness value:</p><p id="p-0092" num="0000"><maths id="MATH-US-00005" num="00005"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mrow>      <mi>Animateness</mi>      <mo>&#x2062;</mo>      <mtext>   </mtext>      <mrow>       <mo>(</mo>       <mrow>        <mi>time</mi>        <mo>&#x2261;</mo>        <mi>t</mi>       </mrow>       <mo>)</mo>      </mrow>     </mrow>     <mo>&#x2261;</mo>     <mrow>      <mfrac>       <mn>1</mn>       <mi>t</mi>      </mfrac>      <mo>&#x2062;</mo>      <mrow>       <munderover>        <mo>&#x2211;</mo>        <mrow>         <mi>k</mi>         <mo>=</mo>         <mn>1</mn>        </mrow>        <mrow>         <mi>t</mi>         <mo>-</mo>         <mn>1</mn>        </mrow>       </munderover>       <mtext>   </mtext>       <mrow>        <mi>Distance</mi>        <mo>&#x2062;</mo>        <mtext>   </mtext>        <mrow>         <mrow>          <mo>(</mo>          <mrow>           <msub>            <mi>COV</mi>            <mrow>             <mi>k</mi>             <mo>+</mo>             <mn>1</mn>            </mrow>           </msub>           <mo>,</mo>           <msub>            <mi>COV</mi>            <mi>k</mi>           </msub>          </mrow>          <mo>)</mo>         </mrow>         <mo>.</mo>        </mrow>       </mrow>      </mrow>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mrow>      <mi>Equ</mi>      <mo>.</mo>      <mtext>   </mtext>      <mn>4</mn>     </mrow>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0093" num="0000">The following equation (Equation 5) may be used to compute the normalized animateness value:</p><p id="p-0094" num="0000"><maths id="MATH-US-00006" num="00006"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mrow>      <mi>Animateness</mi>      <mo>&#x2062;</mo>      <mtext>   </mtext>      <mrow>       <mo>(</mo>       <mrow>        <mi>time</mi>        <mo>&#x2261;</mo>        <mi>t</mi>       </mrow>       <mo>)</mo>      </mrow>     </mrow>     <mo>&#x2261;</mo>     <mfrac>      <mrow>       <mo>[</mo>       <mrow>        <mrow>         <mi>Animateness</mi>         <mo>&#x2062;</mo>         <mtext>   </mtext>         <mrow>          <mo>(</mo>          <mrow>           <mi>time</mi>           <mo>&#x2261;</mo>           <mi>t</mi>          </mrow>          <mo>)</mo>         </mrow>        </mrow>        <mo>&#x2261;</mo>        <mrow>         <mo>-</mo>         <msub>          <mi>A</mi>          <mi>min</mi>         </msub>        </mrow>       </mrow>       <mo>]</mo>      </mrow>      <mrow>       <msub>        <mi>A</mi>        <mi>max</mi>       </msub>       <mo>-</mo>       <msub>        <mi>A</mi>        <mi>min</mi>       </msub>      </mrow>     </mfrac>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mrow>      <mi>Equ</mi>      <mo>.</mo>      <mtext>   </mtext>      <mn>5</mn>     </mrow>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0095" num="0085">At step <b>760</b> the micro-feature extractor <b>320</b> sets the micro-feature value to the computed animateness value of the foreground patch. The animateness value may be measured over several frames to accurately characterize the foreground patch. The computed animateness value is included as an element of a micro-feature vector with an object identifier corresponding to the foreground patch.</p><p id="p-0096" num="0086"><figref idref="DRAWINGS">FIG. <b>7</b>D</figref> illustrates a graphical representation of the auto-correlation spectrum of foreground patches, according to one embodiment of the disclosure. The auto-correlation of a first foreground object is shown in foreground patch auto-correlation <b>762</b>. The auto-correlation spectrum of a second foreground object is shown in foreground patch auto-correlation <b>764</b>. Notice that the periodic movement of the first foreground object that depicts a person is a higher frequency or periodicity compared with the periodic movement of the second foreground object that depicts a vehicle. Based on the analysis of many images and image sequences, foreground patches depicting vehicles have no periodicity, compared with foreground patches depicting people that have higher periodicity. Therefore, the periodic motion is a micro-feature value that may contribute to classifying the foreground patch into a particular object type cluster over another object type cluster.</p><p id="p-0097" num="0087"><figref idref="DRAWINGS">FIG. <b>7</b>E</figref> illustrates a method for computing a micro-feature value based on the frequency spectrum characteristic, according to one embodiment of the disclosure. As shown, another method for performing step <b>375</b> of <figref idref="DRAWINGS">FIG. <b>3</b>B</figref> begins at step <b>772</b> where the micro-feature extractor <b>320</b> receives a sequence of raw foreground patches that are prepared by the characteristic computation unit <b>310</b>. At step <b>775</b> the micro-feature extractor <b>320</b> computes the self-similarity matrix of the sequence of raw foreground patches. At step <b>777</b> the micro-feature extractor <b>320</b> computes the auto-correlation of the self-similarity matrix. At step <b>780</b> the micro-feature extractor <b>320</b> computes a periodicity value, using techniques known to those skilled in the art, based on the auto-correlation of the self-similarity matrix. At step <b>785</b> the micro-feature extractor <b>320</b> sets the micro-feature value to the computed periodicity value of the foreground patch. The periodicity value may be measured over several frames to accurately characterize the foreground patch. The computed periodicity value is included as an element of a micro-feature vector with an object identifier corresponding to the foreground patch.</p><p id="p-0098" num="0088">Advantageously, embodiments of the disclosure may be used as part of a computer vision engine to extract micro-features from individual pixel regions and pixel regions in a sequence of video frames and produce micro-feature vectors. Importantly, the computer vision engine requires no training in order to perform the micro-feature extraction. The machine learning engine receives the micro-feature vectors and performs micro-classification to group the foreground patches into object type clusters. Computation of each of the different micro-feature values may be enabled and disabled and threshold values may be programmed to determine whether or not a valid micro-feature value is output for each foreground patch.</p><p id="p-0099" num="0089">While the foregoing is directed to embodiments of the present disclosure, other and further embodiments of the disclosure may be devised without departing from the basic scope thereof, and the scope thereof is determined by the claims that follow.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-math idrefs="MATH-US-00001" nb-file="US20230005238A1-20230105-M00001.NB"><img id="EMI-M00001" he="8.13mm" wi="76.20mm" file="US20230005238A1-20230105-M00001.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00002" nb-file="US20230005238A1-20230105-M00002.NB"><img id="EMI-M00002" he="8.81mm" wi="76.20mm" file="US20230005238A1-20230105-M00002.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00003 MATH-US-00003-2 MATH-US-00003-3 MATH-US-00003-4 MATH-US-00003-5" nb-file="US20230005238A1-20230105-M00003.NB"><img id="EMI-M00003" he="38.44mm" wi="76.20mm" file="US20230005238A1-20230105-M00003.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00004" nb-file="US20230005238A1-20230105-M00004.NB"><img id="EMI-M00004" he="9.14mm" wi="76.20mm" file="US20230005238A1-20230105-M00004.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00005" nb-file="US20230005238A1-20230105-M00005.NB"><img id="EMI-M00005" he="8.13mm" wi="76.20mm" file="US20230005238A1-20230105-M00005.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00006" nb-file="US20230005238A1-20230105-M00006.NB"><img id="EMI-M00006" he="6.01mm" wi="76.20mm" file="US20230005238A1-20230105-M00006.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A method, comprising:<claim-text>identifying, via a processor, a plurality of foreground objects depicted in a sequence of video frames;</claim-text><claim-text>for each foreground object from the plurality of foreground objects, deriving feature data for that foreground object from each video frame from the sequence of video frames that depicts the foreground object;</claim-text><claim-text>generating, via the processor and based on the derived feature data of a first foreground object from the plurality of foreground objects, an object type model;</claim-text><claim-text>correlating, via the processor, the derived feature data of a second foreground object from the plurality of foreground objects with the object type model; and</claim-text><claim-text>in response to the correlating the derived feature data for the second foreground object with the object type model, assigning an object type identifier to the second foreground object to indicate that the second foreground object is an instance of an object type associated with the object type model.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the object type model includes an adaptive resonance theory (ART) network.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the generating the object type model includes generating a cluster in an adaptive resonance theory (ART) network based on the derived feature data of the first foreground object.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the correlating the derived feature data of the second foreground object with the object type model includes mapping the derived feature data of the second foreground object to a cluster in an adaptive resonance theory (ART) network.</claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising updating the object type model based on the derived feature data of the second foreground object.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the derived feature data for each foreground object from the plurality of foreground objects includes static data characterizing that foreground object in the sequence of video frames that depicts the foreground object.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the derived feature data for each foreground object from the plurality of foreground objects includes kinematic data characterizing that foreground object in the sequence of video frames that depicts the foreground object.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. A non-transitory, processor-readable medium storing instructions that, when executed by a processor, cause the processor to:<claim-text>for each foreground object from a plurality of foreground objects depicted in a sequence of video frames, derive feature data for that foreground object from each video frame from the sequence of video frames that depicts the foreground object;</claim-text><claim-text>generate, based on the derived feature data of a first foreground object from the plurality of foreground objects, an object type model;</claim-text><claim-text>correlate the derived feature data of a second foreground object from the plurality of foreground objects with the object type model; and</claim-text><claim-text>in response to the correlating the derived feature data for the second foreground object with the object type model, assign an object type identifier to the second foreground object to indicate that the second foreground object is an instance of an object type associated with the object type model.</claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The non-transitory, processor-readable medium of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the object type model includes an adaptive resonance theory (ART) network.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The non-transitory, processor-readable medium of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the instructions to generate the object type model include instructions to generate a cluster in an adaptive resonance theory (ART) network based on the derived feature data of the first foreground object.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The non-transitory, processor-readable medium of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the instructions to correlate the derived feature data of the second foreground object with the object type model include instructions to map the derived feature data of the second foreground object to a cluster in an adaptive resonance theory (ART) network.</claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The non-transitory, processor-readable medium of <claim-ref idref="CLM-00008">claim 8</claim-ref>, further storing instructions to cause the processor to update the object type model based on the derived feature data of the second foreground object.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The non-transitory, processor-readable medium of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the derived feature data for each foreground object from the plurality of foreground objects includes static data characterizing that foreground object in the sequence of video frames that depicts the foreground object.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The non-transitory, processor-readable medium of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the derived feature data for each foreground object from the plurality of foreground objects includes kinematic data characterizing that foreground object in the sequence of video frames that depicts the foreground object.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. A system, comprising:<claim-text>a processor; and</claim-text><claim-text>a memory operably coupled to the processor and storing instructions that, when executed by the processor, cause the processor to:<claim-text>for each foreground object from a plurality of foreground objects depicted in a sequence of video frames, derive feature data for that foreground object from each video frame from the sequence of video frames that depicts the foreground object;</claim-text><claim-text>generate, based on the derived feature data of a first foreground object from the plurality of foreground objects, an object type model;</claim-text><claim-text>correlate the derived feature data of a second foreground object from the plurality of foreground objects with the object type model that includes an adaptive resonance theory (ART) network; and</claim-text><claim-text>in response to the correlating the derived feature data for the second foreground object with the object type model, assign an object type identifier to the second foreground object to indicate that the second foreground object is an instance of an object type associated with the object type model.</claim-text></claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The system of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the memory further stores instructions to cause the processor to output, to a machine learning engine, kinematic data based on the object type identifier, the kinematic data describing a behavior of the second foreground object.</claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The system of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the instructions to generate the object type model include instructions to generate a cluster in the ART network based on the derived feature data of the first foreground object.</claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The system of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the instructions to correlate the derived feature data of the second foreground object with the object type model include instructions to map the derived feature data of the second foreground object to a cluster in the ART network.</claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The system of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the memory further stores instructions to cause the processor to update the object type model based on the derived feature data of the second foreground object.</claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The system of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the derived feature data for each foreground object from the plurality of foreground objects depicted in the sequence of video frames includes at least one of static data or kinematic data characterizing that foreground object in the sequence of video frames that depicts the foreground object.</claim-text></claim></claims></us-patent-application>