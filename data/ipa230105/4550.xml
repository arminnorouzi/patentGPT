<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004551A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004551</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17568173</doc-number><date>20220104</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><priority-claims><priority-claim sequence="01" kind="national"><country>VN</country><doc-number>1-2021-04085</doc-number><date>20210702</date></priority-claim></priority-claims><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>23</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>17</main-group><subgroup>18</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>2365</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>17</main-group><subgroup>18</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e61">METHOD OF PROCESSING AND STORING DATA FOR REAL TIME ANOMALY DETECTION PROBLEM</invention-title><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>VIETTEL GROUP</orgname><address><city>Ha Noi City</city><country>VN</country></address></addressbook><residence><country>VN</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Cao</last-name><first-name>Dang Sao</first-name><address><city>Dien Chau District</city><country>VN</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Tran</last-name><first-name>Van Thuyet</first-name><address><city>Kien Xuong District</city><country>VN</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>Nguyen</last-name><first-name>Duc Hieu</first-name><address><city>Hung Ha District</city><country>VN</country></address></addressbook></inventor><inventor sequence="03" designation="us-only"><addressbook><last-name>Nguyen</last-name><first-name>Dinh Tam</first-name><address><city>Vinh City</city><country>VN</country></address></addressbook></inventor></inventors></us-parties><assignees><assignee><addressbook><orgname>VIETTEL GROUP</orgname><role>03</role><address><city>Ha Noi City</city><country>VN</country></address></addressbook></assignee></assignees></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">The method of processing and storing data for real time anomaly detection including steps: step 1: building a historical database over time, mean and standard deviation database; step 2: make a selection number of blocks and number of points in one block, divide historical data into equal-sized blocks and build formulas to calculate average, standard deviation of each data block and the whole data; Step 3: create a data mapping process that runs independently to read collected data, normalize data and interact with the in-memory database to write data history over time; step 4: perform data anomaly detection of new incoming data with mean, standard deviation of historical data already stored in database on read-only memory (RAM).</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="106.26mm" wi="158.75mm" file="US20230004551A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="217.85mm" wi="166.54mm" file="US20230004551A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="218.69mm" wi="167.30mm" file="US20230004551A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="122.00mm" wi="166.79mm" file="US20230004551A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">FIELD OF THE INVENTION</heading><p id="p-0002" num="0001">The invention relates to the method of processing and storing data for real time anomaly detection problem. The method proposed in the present invention is used on the basis of anomaly detection technology and is applied in the field of real time computing.</p><heading id="h-0002" level="1">TECHNICAL STATUS OF THE INVENTION</heading><p id="p-0003" num="0002">Typically, the data processing and storing method for real time anomaly detection is represented by the following simplified steps:</p><p id="p-0004" num="0003">Step 1: incoming data will be stored in the database.</p><p id="p-0005" num="0004">Step 2: perform a comparison of the incoming data with past data points to conclude whether the incoming data is anomalous or not and then issue warnings.</p><p id="p-0006" num="0005">However, as the number of historical data points to be used for comparison increases, three problems arise:</p><p id="p-0007" num="0006">One is that the computer needs to store a large amount of historical data on random access memory or read-only memory (RAM) while the amount of RAM is limited.</p><p id="p-0008" num="0007">The second is that the requirement to retrieve historical data from the database is continuously costly and leads to database failure in the long run.</p><p id="p-0009" num="0008">The third is the increased computation time, while for the real time anomaly detection problem (the problem of time constraints from the occurrence of an event until the system responds to that event), the computation time of basic operations needs to reach a certain speed or time limit.</p><p id="p-0010" num="0009">The method of processing and storing data for real time anomaly detection problem solves the above three problems well. Respond to real time anomalous data detection and provide treatment for similar problems that can be applied to speed up computation.</p><heading id="h-0003" level="1">THE TECHNICAL NATURE OF THE INVENTION</heading><p id="p-0011" num="0010">The purpose of the present invention is to provide a method of processing and storing data for real time anomaly detection problem. This method increases computing power many times over (depending on how data storage and computation are divided on RAM read-only memory).</p><p id="p-0012" num="0011">To achieve the foregoing, the present invention provides a method of processing and storing data for real time anomaly detection problem with the following specific implementation steps:</p><p id="p-0013" num="0012">Step 1: build a historical database over time, a database of mean and standard deviation. More specifically: the data after coming to the system will be saved to the database according to the timestamp, after the specified time periods, the data will be averaged and saved to the database.</p><p id="p-0014" num="0013">Step 2: make a selection number of blocks and number of points in one block, divide the historical data into blocks of equal size and build a formula to calculate the mean, the standard deviation of each data block and the mean, the median standard deviation of the whole data:</p><p id="p-0015" num="0014">In fact, the detection of data anomalies using different algorithms requires different data processing and storage. For algorithms that require the use of the mean and the median standard deviation of historical data to make an outlier assessment, the following steps apply:</p><p id="p-0016" num="0015">Step 2.1: divide historical data into equal blocks, namely: suppose historical data to be averaged, standard deviation is n&#xd7;m data points, we divide into m data blocks, each block contain n points data.</p><p id="p-0017" num="0016">Step 2.2: determine the number of historical data points to use.</p><p id="p-0018" num="0017">Step 2.3: construct formulas to calculate the mean, the standard deviation of data blocks and the mean, the median standard deviation of the whole data.</p><p id="p-0019" num="0018">Step 3: create an independently running data mapping process that reads collected data, normalizes the data, and interacts with the in-memory database to write historical data according to time.</p><p id="p-0020" num="0019">Step 4: process the calculation of the mean, the standard deviation of the data blocks and the mean, the median standard deviation of the whole data and store it in the database on read-only memory (RAM).</p><p id="p-0021" num="0020">To perform anomaly detection according to the data division in step 2. We use two independent processes: the process of calculating the mean, the standard deviation, and performing the calculation when n points have been collected data for that block and for all historical data is shown in step 4.1; anomalous data detection real time process reads the data in real time and checks whether the data point is anomalous performed in step 4.2.</p><p id="p-0022" num="0021">Step 4.1: process the calculation of the mean, the standard deviation of the data blocks and the mean, the median standard deviation the whole data and save it in the database with the data structure as Table 2, and are stored directly on RAM:</p><p id="p-0023" num="0022">The process of calculating the mean, standard deviation is scheduled to execute after n&#xd7;t time because the data is written to the database in t time period, so after n&#xd7;t time we proceed with the following next steps.</p><p id="p-0024" num="0023">Step 4.1.1: read the historical data of the last n points in the database stored in Step 3.</p><p id="p-0025" num="0024">Step 4.1.2: calculate the mean and standard deviation of the n points obtained.</p><p id="p-0026" num="0025">Step 4.1.3: calculate the mean, the median standard deviation of all historical data stored in the database: based on the mean, the standard deviation of up to m&#x2212;1 previously calculated data blocks and the mean, the standard deviation of the nearest n points using the formulas established in Step 2.3.</p><p id="p-0027" num="0026">Step 4.1.4: store the last n-point mean, the nearest n-point standard deviation, the mean of all historical data, and the median standard deviation of all historical data into a datastructured database Table 2 to query.</p><p id="p-0028" num="0027">Step 4.2: anomaly real time process reads real time data from the database and performs anomaly detection.</p><p id="p-0029" num="0028">Then, because in Step 4.1, the mean, the median standard deviation of historical data has been calculated, it is not necessary to recalculate them each time the incoming data is available. It will to speed up anomaly detection computation and real time response to the problem.</p><p id="p-0030" num="0029">This solution helps to solve the problem of real time calculation of both anomalous data detection, avoiding hard drive scanning and database file opening and closing many times.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0031" num="0030">In order to describe the invention in a more coherent, clear and understandable manner, the figures below depict parts of the invention:</p><p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. <b>1</b></figref>: Describe the data flow processed in the real time anomaly detection system.</p><p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. <b>2</b></figref>: Describe the processing flow that maps data from the source to the database.</p><p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. <b>3</b></figref>: Describes the division of historical data into smaller blocks to handle averaging over each block and over the data as a whole.</p><p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. <b>4</b></figref>: Describe the real time progress of detecting anomalous data at a specific time.</p><p id="p-0036" num="0035"><figref idref="DRAWINGS">FIG. <b>5</b></figref>: Describe the real time data processing flow of the anomaly detection system using the data averaging algorithm.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0005" level="1">DETAILED DESCRIPTION</heading><p id="p-0037" num="0036">In the Anomaly Detection System, it is the detection of abnormal data occurring in the system, the requirement is that the anomaly should be detected as soon as possible to minimize the risk of impact to the system or in other words real time detection.</p><p id="p-0038" num="0037">The method of processing and storing data for real time anomaly detection problem proposed in the present invention consists of sequential implementation steps detailed below:</p><p id="p-0039" num="0038">Step 1: build a historical database over time, a database of mean and standard deviation.</p><p id="p-0040" num="0039">Refer to <figref idref="DRAWINGS">FIG. <b>1</b></figref>, which describes the flow of data processed in a real time anomaly detection system, and <figref idref="DRAWINGS">FIG. <b>2</b></figref>, which describes the processing flow that maps data from the source to the database.</p><p id="p-0041" num="0040">System data is collected by agents installed on the server including information such as percentage of central processor usage, percentage of internal memory used, network latency, etc. that will be stored on a centralized messaging system to task different systems using the same data source. Thanks to an independently running Process Mapping Data, it reads data from the centralized messaging system, normalizes the data, and interacts with the on-memory database management system (in-memory database) to write data over time.</p><p id="p-0042" num="0041">The content of the data includes: the time the data was written, the source of the data to be written, the value of the data to be written.</p><p id="p-0043" num="0042">When a record is sent to the messaging system, the Data Mapping Process writes the data to the database with the following structure:</p><p id="p-0044" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 1</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Historical data table over time.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="49pt" align="left"/><colspec colname="2" colwidth="56pt" align="left"/><colspec colname="3" colwidth="98pt" align="left"/><tbody valign="top"><row><entry/><entry>Field name</entry><entry>Datatype</entry><entry>Meaning</entry></row><row><entry/><entry namest="offset" nameend="3" align="center" rowsep="1"/></row><row><entry/><entry>Id</entry><entry>Integer</entry><entry>Table primary key, integer</entry></row><row><entry/><entry/><entry/><entry>data type, unique identifier</entry></row><row><entry/><entry/><entry/><entry>of the data</entry></row><row><entry/><entry>Timestamp</entry><entry>Milliseconds</entry><entry>The time the data was</entry></row><row><entry/><entry/><entry/><entry>written, has the time data</entry></row><row><entry/><entry/><entry/><entry>type</entry></row><row><entry/><entry>Source</entry><entry>String</entry><entry>Data information to be</entry></row><row><entry/><entry/><entry/><entry>written, has a string data</entry></row><row><entry/><entry/><entry/><entry>type</entry></row><row><entry/><entry>Value</entry><entry>Real</entry><entry>Received data value,</entry></row><row><entry/><entry/><entry/><entry>has real numeric data type</entry></row><row><entry/><entry namest="offset" nameend="3" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0045" num="0043">In addition, it is necessary to build a database storage structure for the mean and standard deviation values of historical data points as follows:</p><p id="p-0046" num="0000"><tables id="TABLE-US-00002" num="00002"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 2</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Table of mean and standard deviation.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="98pt" align="left"/><colspec colname="2" colwidth="42pt" align="left"/><colspec colname="3" colwidth="77pt" align="left"/><tbody valign="top"><row><entry>Field name</entry><entry>Datatype</entry><entry>Meaning</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row><row><entry>Id</entry><entry>Integer</entry><entry>Table primary key,</entry></row><row><entry/><entry/><entry>integer data type, unique</entry></row><row><entry/><entry/><entry>identifier</entry></row><row><entry>Timestamp</entry><entry>Milliseconds</entry><entry>Historical mean data</entry></row><row><entry/><entry/><entry>logging time, with time</entry></row><row><entry/><entry/><entry>data type</entry></row><row><entry>Mean</entry><entry>Real</entry><entry>Mean of all necessary</entry></row><row><entry/><entry/><entry>historical data, with real</entry></row><row><entry/><entry/><entry>number data type</entry></row><row><entry>Median_standard_deviation</entry><entry>Real</entry><entry>Median of block standard</entry></row><row><entry/><entry/><entry>deviations of all</entry></row><row><entry/><entry/><entry>historical data, with data</entry></row><row><entry/><entry/><entry>type real</entry></row><row><entry>Nearest_block_mean</entry><entry>Real</entry><entry>Last received data</entry></row><row><entry/><entry/><entry>block mean,</entry></row><row><entry/><entry/><entry>with real numeric</entry></row><row><entry/><entry/><entry>data type</entry></row><row><entry>Nearest_block_std</entry><entry>Real</entry><entry>The most recent received</entry></row><row><entry/><entry/><entry>data block standard</entry></row><row><entry/><entry/><entry>deviation value, has a</entry></row><row><entry/><entry/><entry>real numeric data type</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0047" num="0044">Step 2: make a selection number of blocks and number of points in one block, divide the historical data into equal sized blocks and build formulas to calculate the mean, standard deviation of each data block and the whole data:</p><p id="p-0048" num="0045">From the starting idea of dividing historical data into smaller blocks to facilitate real time anomaly detection calculations, the calculation of the mean, the standard deviation is done as follows: with the mean, the average of n&#xd7;m data points is equal to the average of the arithmetic mean of m blocks, where each block has n data points; with standard deviation, averaging the standard deviation of m blocks, where each block has n data points, will calculate that block standard deviation. Specifically, the method of dividing data blocks and calculating the average, standard deviation of each block and the whole data includes the following steps:</p><p id="p-0049" num="0046">Step 2.1: Divide historical data into equal blocks: assuming the historical data to be averaged is n&#xd7;m data points, we divide it into m data blocks, each containing n data points. The choice of two parameters n and m depends on the characteristics of each different data type, based on the requirement between the data processing speed and the data average used to detect the outlier data. For example, when we divide more blocks (m large) and each block has a large number of points (n large), the data processing speed will be slower, and the comparison of new incoming data with the data average will be less accurate.</p><p id="p-0050" num="0047">Step 2.2: determine the historical data points to use, these points are past data from the present time, assuming those points denoted by</p><p id="p-0051" num="0048">a<sub>11</sub>, a<sub>21</sub>, . . . , a<sub>n1</sub>, a<sub>12</sub>, a<sub>22</sub>, . . . , a<sub>n2 </sub>. . . , a<sub>1m</sub>, a<sub>2m</sub>, . . . , a<sub>nm </sub>are the first data point, the second data point, . . . , the n&#xd7;m data point respectively.</p><p id="p-0052" num="0049">Step 2.3: The mean (denoted by mean) is calculated by adding all the data points and dividing the result by the number of data points, and the median standard deviation (denoted by median_std) is calculated as the median of the standard deviations of the smaller blocks, respectively. Here is the formula:</p><p id="p-0053" num="0000"><maths id="MATH-US-00001" num="00001"><math overflow="scroll"> <mrow>  <mi>mean</mi>  <mo>=</mo>  <mrow>   <mfrac>    <mrow>     <msub>      <mi>a</mi>      <mrow>       <mn>1</mn>       <mo>&#x2062;</mo>       <mn>1</mn>      </mrow>     </msub>     <mo>+</mo>     <msub>      <mi>a</mi>      <mrow>       <mn>2</mn>       <mo>&#x2062;</mo>       <mn>1</mn>      </mrow>     </msub>     <mo>+</mo>     <mo>&#x2026;</mo>     <mo>+</mo>     <msub>      <mi>a</mi>      <mi>nm</mi>     </msub>    </mrow>    <mrow>     <mi>n</mi>     <mo>&#xd7;</mo>     <mi>m</mi>    </mrow>   </mfrac>   <mo>=</mo>   <mtext>&#x2028;</mtext>   <mrow>    <mfrac>     <mtable>      <mtr>       <mtd>        <mrow>         <mfrac>          <mrow>           <msub>            <mi>a</mi>            <mrow>             <mn>1</mn>             <mo>&#x2062;</mo>             <mn>1</mn>            </mrow>           </msub>           <mo>+</mo>           <msub>            <mi>a</mi>            <mrow>             <mn>2</mn>             <mo>&#x2062;</mo>             <mn>1</mn>            </mrow>           </msub>           <mo>+</mo>           <mo>&#x2026;</mo>           <mo>+</mo>           <msub>            <mi>a</mi>            <mrow>             <mi>n</mi>             <mo>&#x2062;</mo>             <mn>1</mn>            </mrow>           </msub>          </mrow>          <mi>n</mi>         </mfrac>         <mo>+</mo>         <mfrac>          <mrow>           <msub>            <mi>a</mi>            <mrow>             <mn>1</mn>             <mo>&#x2062;</mo>             <mn>2</mn>            </mrow>           </msub>           <mo>+</mo>           <msub>            <mi>a</mi>            <mrow>             <mn>2</mn>             <mo>&#x2062;</mo>             <mn>2</mn>            </mrow>           </msub>           <mo>+</mo>           <mo>&#x2026;</mo>           <mo>+</mo>           <msub>            <mi>a</mi>            <mrow>             <mi>n</mi>             <mo>&#x2062;</mo>             <mn>2</mn>            </mrow>           </msub>          </mrow>          <mi>n</mi>         </mfrac>         <mo>+</mo>        </mrow>       </mtd>      </mtr>      <mtr>       <mtd>        <mrow>         <mo>&#x2026;</mo>         <mo>+</mo>         <mfrac>          <mrow>           <msub>            <mi>a</mi>            <mrow>             <mn>1</mn>             <mo>&#x2062;</mo>             <mi>m</mi>            </mrow>           </msub>           <mo>+</mo>           <msub>            <mi>a</mi>            <mrow>             <mn>2</mn>             <mo>&#x2062;</mo>             <mi>m</mi>            </mrow>           </msub>           <mo>+</mo>           <mo>&#x2026;</mo>           <mo>+</mo>           <msub>            <mi>a</mi>            <mrow>             <mi>n</mi>             <mo>&#x2062;</mo>             <mi>m</mi>            </mrow>           </msub>          </mrow>          <mi>n</mi>         </mfrac>        </mrow>       </mtd>      </mtr>     </mtable>     <mi>m</mi>    </mfrac>    <mo>=</mo>    <mfrac>     <mrow>      <mrow>       <mi>mean_block</mi>       <mo>&#x2062;</mo>       <mo>_</mo>       <mo>&#x2062;</mo>       <mn>1</mn>      </mrow>      <mo>+</mo>      <mrow>       <mi>mean_block</mi>       <mo>&#x2062;</mo>       <mo>_</mo>       <mo>&#x2062;</mo>       <mn>2</mn>      </mrow>      <mo>+</mo>      <mo>&#x2026;</mo>      <mo>+</mo>      <mrow>       <mi>mean_block</mi>       <mo>&#x2062;</mo>       <mi>_m</mi>      </mrow>     </mrow>     <mi>m</mi>    </mfrac>   </mrow>  </mrow> </mrow></math></maths><maths id="MATH-US-00001-2" num="00001.2"><math overflow="scroll"> <mrow>  <mtext>                </mtext>  <mrow>   <mi>median_std</mi>   <mo>=</mo>   <mrow>    <mi>median</mi>    <mo>(</mo>    <mrow>     <mrow>      <mi>std_block</mi>      <mo>&#x2062;</mo>      <mo>_</mo>      <mo>&#x2062;</mo>      <mn>1</mn>     </mrow>     <mo>,</mo>     <mrow>      <mi>std_block</mi>      <mo>&#x2062;</mo>      <mo>_</mo>      <mo>&#x2062;</mo>      <mn>2</mn>     </mrow>     <mo>,</mo>     <mo>&#x2026;</mo>     <mtext>   </mtext>     <mo>,</mo>     <mrow>      <mi>std_block</mi>      <mo>&#x2062;</mo>      <mi>_m</mi>     </mrow>    </mrow>    <mo>)</mo>   </mrow>  </mrow> </mrow></math></maths></p><p id="p-0054" num="0000">In which, the standard deviation of each block (denoted by std_block_i) is calculated according to the following formula:</p><p id="p-0055" num="0000"><maths id="MATH-US-00002" num="00002"><math overflow="scroll"> <mrow>  <mrow>   <mi>std_block</mi>   <mo>&#x2062;</mo>   <mi>_i</mi>  </mrow>  <mo>=</mo>  <msqrt>   <mfrac>    <mrow>     <msubsup>      <mo>&#x2211;</mo>      <mrow>       <mi>k</mi>       <mo>=</mo>       <mn>1</mn>      </mrow>      <mi>n</mi>     </msubsup>     <msup>      <mrow>       <semantics definitionURL="">        <mo>&#x2758;</mo>        <annotation encoding="Mathematica">"\[LeftBracketingBar]"</annotation>       </semantics>       <mrow>        <msub>         <mi>a</mi>         <mi>ki</mi>        </msub>        <mo>-</mo>        <mrow>         <mi>mean_block</mi>         <mo>&#x2062;</mo>         <mi>_i</mi>        </mrow>       </mrow>       <semantics definitionURL="">        <mo>&#x2758;</mo>        <annotation encoding="Mathematica">"\[RightBracketingBar]"</annotation>       </semantics>      </mrow>      <mn>2</mn>     </msup>    </mrow>    <mrow>     <mi>n</mi>     <mo>-</mo>     <mn>1</mn>    </mrow>   </mfrac>  </msqrt> </mrow></math></maths></p><p id="p-0056" num="0050">Refer to <figref idref="DRAWINGS">FIG. <b>3</b></figref>, which depicts the breakdown of historical data into smaller blocks to handle the arithmetic mean, standard deviation per block, and the mean, median standard deviation over the entire data set.</p><p id="p-0057" num="0051">Step 3: Data mapping process (called Process Mapping Data) runs independently to read the collected data. Because the data collected by the agents is often in a raw form (usually in json format&#x2014;javascript object notation) including many different fields, we need to separate the data into the required fields for anomaly detection and normalization of data to real number format. Post-normalized data is written to the in-memory database by the process over time. The data in the database has a data structure like Table 1.</p><p id="p-0058" num="0052">Step 4: Perform anomaly detection of incoming data with the mean, the median standard deviation of historical data already stored in the database on read-only memory (RAM).</p><p id="p-0059" num="0053">To perform anomaly detection according to the data division in step 2. We use two independent processes: The process of calculating the mean, the standard deviation, performing the calculation when n points have been collected data for that block and for all historical data is shown in step 4.1; Anomalous data detection real time process reads the data in real time and checks whether the data point is anomalous performed in step 4.2. As follows:</p><p id="p-0060" num="0054">Step 4.1: process the calculation of the mean, the standard deviation of the data blocks, the mean, the median standard deviation of the whole data and save it in the database for the mean, the standard deviation values with the data structure as Table 2, and are stored directly on RAM:</p><p id="p-0061" num="0055">The process of calculating the mean, standard deviation is scheduled to execute after n&#xd7;t time because the data is written to the database in t time period, so after n&#xd7;t time we proceed the next steps.</p><p id="p-0062" num="0056">Step 4.1.1: read historical data for the last n points in the database stored in step 3.</p><p id="p-0063" num="0057">Step 4.1.2: calculate the mean and standard deviation of the n points obtained.</p><p id="p-0064" num="0058">Step 4.1.3: calculate the mean of all historical data blocks stored on the database: based on the mean, standard deviations of up to m&#x2212;1 previously calculated data blocks, and the mean, standard deviation of the nearest n points, we can calculate the mean and the median standard deviation of all historical data using the formulas established in step 2.3.</p><p id="p-0065" num="0059">Step 4.1.4: save the last n point mean, the nearest n point standard deviation, the mean of all historical data, and the median standard deviation of all historical data into a structured database Table 2 to query.</p><p id="p-0066" num="0060">Step 4.2: anomaly real time process reads real time data from the database and performs anomaly detection:</p><p id="p-0067" num="0061">Existing data will be checked for anomalous condition by parametric method based on statistics, namely algorithm based on mean and historical data standard deviation as follows:</p><p id="p-0068" num="0062">Let x<sub>current </sub>be the current value of the data obtained, mean and median_std are mean, median standard deviation of the most recent historical data from the current data point calculated in step 4.1.3, respectively. Then:<ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0063">x<sub>current </sub>is anomalous if</li>        <li id="ul0002-0002" num="0064">x<sub>current</sub>&#x3c;mean&#x2212;factor&#xd7;median_std</li>        <li id="ul0002-0003" num="0065">or x<sub>current</sub>&#x3e;mean+factor&#xd7;median_std</li>    </ul>    </li></ul></p><p id="p-0069" num="0066">In which, factor will be determined by the empirical rule, usually taken as 3.</p><p id="p-0070" num="0067">If x<sub>current </sub>is an abnormal data point, it will be saved in the database and sent directly to the alarm system so that the operator of the network system will check and correct the error.</p><p id="p-0071" num="0068">Refer to <figref idref="DRAWINGS">FIG. <b>4</b></figref>, which describes the real time process of detecting anomalous data at a specific time, and <figref idref="DRAWINGS">FIG. <b>5</b></figref>, which describes the real time data processing flow of the anomaly detection system. When new data arrives at the anomaly detection system, the real time processor process will perform a mean, median standard deviation read of the historical data from the in-memory database (in-memory database), then compare the newly arrived data with the average of that historical data and finally make a conclusion whether the data point is abnormal or not, if so, issue a warning to the system warning.</p><heading id="h-0006" level="1">EFFECTIVENESS OF THE INVENTION</heading><p id="p-0072" num="0069">Solve the problem of real time anomaly detection, anomaly response time&#x3c;1 minute (from anomaly appearance time to giving warning).</p><p id="p-0073" num="0070">Save on storage costs on RAM and don't have to scan the hard drive repeatedly.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-math idrefs="MATH-US-00001 MATH-US-00001-2" nb-file="US20230004551A1-20230105-M00001.NB"><img id="EMI-M00001" he="32.77mm" wi="76.20mm" file="US20230004551A1-20230105-M00001.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00002" nb-file="US20230004551A1-20230105-M00002.NB"><img id="EMI-M00002" he="8.81mm" wi="76.20mm" file="US20230004551A1-20230105-M00002.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. Method of processing and storing data of real time anomaly detection problem with specific steps as follows:<claim-text>step 1: build a historical in-memory database over time, a database of mean and standard deviation;</claim-text><claim-text>step 2: make a selection number of blocks and number of points in one block, divide the historical data into equal sized blocks and build a formula to calculate a mean, standard deviation of each data block and the mean, the median standard deviation of the whole data;</claim-text><claim-text>step 2.1: divide historical data into equal blocks;</claim-text><claim-text>step 2.2: determine the historical data points to use;</claim-text><claim-text>step 2.3: construct formulas to calculate the mean, the standard deviation of data blocks and the mean, the median standard deviation of the whole data;</claim-text><claim-text>step 3: create an independently running data mapping process that reads collected data, normalizes the data, and interacts with the in-memory database to write historical data according to time;</claim-text><claim-text>step 4: perform data anomaly detection of incoming data with the mean, median standard deviation of historical data already stored in the in-memory database on read-only memory (RAM); using two independent processes: the mean, standard deviation calculation process when n data points have been collected for that block and for all historical data shown in step 4.1; real time process that detects anomaly data reads data in real time and checks whether the data point is anomalous doing in step 4.2;</claim-text><claim-text>step 4.1: process the calculation of the mean, the standard deviation of the last data blocks and the mean, the median standard deviation of the whole data, and save it in the in-memory database for the mean, the standard deviation value with the data structure as shown in the table below</claim-text></claim-text><claim-text><tables id="TABLE-US-00003" num="00003"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="98pt" align="left"/><colspec colname="2" colwidth="42pt" align="left"/><colspec colname="3" colwidth="77pt" align="left"/><thead><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row><row><entry>Field name</entry><entry>Datatype</entry><entry>Meaning</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>Id</entry><entry>Integer</entry><entry>Table primary key,</entry></row><row><entry/><entry/><entry>integer data type, unique</entry></row><row><entry/><entry/><entry>identifier</entry></row><row><entry>Timestamp</entry><entry>Milliseconds</entry><entry>Historical mean data</entry></row><row><entry/><entry/><entry>logging time, with time</entry></row><row><entry/><entry/><entry>data type</entry></row><row><entry>Mean</entry><entry>Real</entry><entry>Mean of all necessary</entry></row><row><entry/><entry/><entry>historical data, with real</entry></row><row><entry/><entry/><entry>number data type</entry></row><row><entry>Median_standard_deviation</entry><entry>Real</entry><entry>Median of block standard</entry></row><row><entry/><entry/><entry>deviations of all</entry></row><row><entry/><entry/><entry>historical data,</entry></row><row><entry/><entry/><entry>with data type real</entry></row><row><entry>Nearest_block_mean</entry><entry>Real</entry><entry>Last received data block</entry></row><row><entry/><entry/><entry>mean, with real numeric</entry></row><row><entry/><entry/><entry>data type</entry></row><row><entry>Nearest_block_std</entry><entry>Real</entry><entry>The most recent received</entry></row><row><entry/><entry/><entry>data block standard</entry></row><row><entry/><entry/><entry>deviation value, has a</entry></row><row><entry/><entry/><entry>real numeric data type,</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></claim-text><claim-text>and are store directly on RAM;<claim-text>step 4.1.1: read historical data for the last n points in the database stored in step 3;</claim-text><claim-text>step 4.1.2: calculate the mean and standard deviation of the n points obtained;</claim-text><claim-text>step 4.1.3: calculate the mean of all historical data blocks stored on the database;</claim-text><claim-text>step 4.1.4: save the last n point mean, the nearest n point standard deviation, the mean of all historical data, and the median standard deviation of all historical data into a structured database Table 2 to query; and</claim-text><claim-text>step 4.2: real time anomaly detection process reads real time data from the in-memory database and performs anomaly detection.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The method of processing and storing data for real time anomaly detection problem according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, in which:<claim-text>at step 1, build a historical in-memory database over time, a database of mean and standard deviation, the structure of the in-memory database is in the form of tables as follows:</claim-text></claim-text><claim-text><tables id="TABLE-US-00004" num="00004"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 1</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Historical data table over time</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="49pt" align="left"/><colspec colname="2" colwidth="56pt" align="left"/><colspec colname="3" colwidth="98pt" align="left"/><tbody valign="top"><row><entry/><entry>Field name</entry><entry>Datatype</entry><entry>Meaning</entry></row><row><entry/><entry namest="offset" nameend="3" align="center" rowsep="1"/></row><row><entry/><entry>Id</entry><entry>Integer</entry><entry>Table primary key, integer</entry></row><row><entry/><entry/><entry/><entry>data type, unique identifier</entry></row><row><entry/><entry/><entry/><entry>of the data</entry></row><row><entry/><entry>Timestamp</entry><entry>Milliseconds</entry><entry>The time the data was</entry></row><row><entry/><entry/><entry/><entry>written, has the time data</entry></row><row><entry/><entry/><entry/><entry>type</entry></row><row><entry/><entry>Source</entry><entry>String</entry><entry>Data information to be</entry></row><row><entry/><entry/><entry/><entry>written, has a string data</entry></row><row><entry/><entry/><entry/><entry>type</entry></row><row><entry/><entry>Value</entry><entry>Real</entry><entry>Received data value, has</entry></row><row><entry/><entry/><entry/><entry>real numeric data type</entry></row><row><entry/><entry namest="offset" nameend="3" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></claim-text><claim-text><tables id="TABLE-US-00005" num="00005"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 2</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Table of mean and standard deviation.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="98pt" align="left"/><colspec colname="2" colwidth="42pt" align="left"/><colspec colname="3" colwidth="77pt" align="left"/><tbody valign="top"><row><entry>Field name</entry><entry>Datatype</entry><entry>Meaning</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row><row><entry>Id</entry><entry>Integer</entry><entry>Table primary key,</entry></row><row><entry/><entry/><entry>integer data type, unique</entry></row><row><entry/><entry/><entry>identifier</entry></row><row><entry>Timestamp</entry><entry>Milliseconds</entry><entry>Historical mean data</entry></row><row><entry/><entry/><entry>logging time, with time</entry></row><row><entry/><entry/><entry>data type</entry></row><row><entry>Mean</entry><entry>Real</entry><entry>Mean of all necessary</entry></row><row><entry/><entry/><entry>historical data, with real</entry></row><row><entry/><entry/><entry>number data type</entry></row><row><entry>Median_standard_deviation</entry><entry>Real</entry><entry>Median of block standard</entry></row><row><entry/><entry/><entry>deviations of all</entry></row><row><entry/><entry/><entry>historical data, with data</entry></row><row><entry/><entry/><entry>type real</entry></row><row><entry>Nearest_block_mean</entry><entry>Real</entry><entry>Last received data block</entry></row><row><entry/><entry/><entry>mean, with real numeric</entry></row><row><entry/><entry/><entry>data type</entry></row><row><entry>Nearest_block_std</entry><entry>Real</entry><entry>The most recent received</entry></row><row><entry/><entry/><entry>data block standard</entry></row><row><entry/><entry/><entry>deviation value, has a</entry></row><row><entry/><entry/><entry>real numeric data type</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The method of processing and storing data for real time anomaly detection problem according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, in which:<claim-text>at step 2, divide historical data into equal blocks, namely: suppose historical data to be mean, standard deviation is n&#xd7;m data points, divide into m data blocks, each block contains n points data, Then determine the number of historical data points to use.</claim-text></claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The method of processing and storing data for real time anomaly detection problem according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, in which:<claim-text>at step 2, build formulas to calculate mean, standard deviation of block data and mean, median standard deviation of whole data.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The method of processing and storing data for real time anomaly detection problem according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, in which:<claim-text>at step 3, the independently running data mapping process remove null data, standardize data suitable data type in a Table 1 below as:</claim-text></claim-text><claim-text><tables id="TABLE-US-00006" num="00006"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 1</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Historical data table over time.</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="49pt" align="left"/><colspec colname="2" colwidth="56pt" align="left"/><colspec colname="3" colwidth="98pt" align="left"/><tbody valign="top"><row><entry/><entry>Field name</entry><entry>Datatype</entry><entry>Meaning</entry></row><row><entry/><entry namest="offset" nameend="3" align="center" rowsep="1"/></row><row><entry/><entry>Id</entry><entry>Integer</entry><entry>Table primary key, integer</entry></row><row><entry/><entry/><entry/><entry>data type, unique identifier</entry></row><row><entry/><entry/><entry/><entry>of the data</entry></row><row><entry/><entry>Timestamp</entry><entry>Milliseconds</entry><entry>The time the data was</entry></row><row><entry/><entry/><entry/><entry>written, has the time data</entry></row><row><entry/><entry/><entry/><entry>type</entry></row><row><entry/><entry>Source</entry><entry>String</entry><entry>Data information to be</entry></row><row><entry/><entry/><entry/><entry>written, has a string data</entry></row><row><entry/><entry/><entry/><entry>type</entry></row><row><entry/><entry>Value</entry><entry>Real</entry><entry>Received data value, has</entry></row><row><entry/><entry/><entry/><entry>real numeric data type</entry></row><row><entry/><entry namest="offset" nameend="3" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The method of processing and storing data for real time anomaly detection problem according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, in which:<claim-text>at step 4, this step using two independent processes: the mean, standard deviation calculation process; the real time anomaly detection process that detects anomaly data.</claim-text></claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The method of processing and storing data for real time anomaly detection problem according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, in which:<claim-text>at step 4, the mean, standard deviation calculation process is scheduled to execute after n&#xd7;t time because the data is written to the database in t time period.</claim-text></claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The method of processing and storing data for real time anomaly detection according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, in which:<claim-text>at step 4, in process to calculate the mean, standard deviation problem contains the first small step: read historical data for the last n points in the database stored in Step 3.</claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The method of processing and storing data for real time anomaly detection problem according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, in which:<claim-text>at step 4, in process to calculate the mean, standard deviation contains the second small step: calculate the mean and standard deviation of the n points obtained.</claim-text></claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The method of processing and storing data for real time anomaly detection problem according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, in which:<claim-text>at step 4, in process to calculate the mean, standard deviation contains the third sub-step: calculate the mean, the median standard deviation of all historical data blocks stored on the database: based on the mean, standard deviations of up to m&#x2212;1 previously calculated data blocks, and the mean, standard deviation of the nearest n points, The mean and the median standard deviation of all historical data using the formulas established in step 2.3.</claim-text></claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The method of processing and storing data for real time anomaly detection problem according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, in which:<claim-text>at step 4, in process to calculate the mean, standard deviation contains four sub-steps: save the last n point mean, the nearest n point standard deviation, the mean of all historical data, and the median standard deviation of all historical data into the above table data structured database to query.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The method of processing and storing data for real time anomaly detection problem according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, in which:<claim-text>at step 4, in real time anomaly detection process, build a formula for detecting anomalous data.</claim-text></claim-text></claim></claims></us-patent-application>