<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230005188A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230005188</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17822651</doc-number><date>20220826</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>T</subclass><main-group>9</main-group><subgroup>00</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>597</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>T</subclass><main-group>9</main-group><subgroup>001</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>597</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">QUANTIZED DEPTHS FOR PROJECTION POINT CLOUD COMPRESSION</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>16593994</doc-number><date>20191005</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11430155</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17822651</doc-number></document-id></child-doc></relation></continuation><us-provisional-application><document-id><country>US</country><doc-number>62742192</doc-number><date>20181005</date></document-id></us-provisional-application><us-provisional-application><document-id><country>US</country><doc-number>62781539</doc-number><date>20181218</date></document-id></us-provisional-application></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Apple Inc.</orgname><address><city>Cupertino</city><state>CA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Tourapis</last-name><first-name>Alexandros</first-name><address><city>Los Gatos</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Robinet</last-name><first-name>Fabrice A.</first-name><address><city>Sunnyvale</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>Kim</last-name><first-name>Jungsun</first-name><address><city>San Jose</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="03" designation="us-only"><addressbook><last-name>Mammou</last-name><first-name>Khaled</first-name><address><city>Danville</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="04" designation="us-only"><addressbook><last-name>Valentin</last-name><first-name>Valery G.</first-name><address><city>San Jose</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="05" designation="us-only"><addressbook><last-name>Su</last-name><first-name>Yeping</first-name><address><city>Cupertino</city><state>CA</state><country>US</country></address></addressbook></inventor></inventors></us-parties><assignees><assignee><addressbook><orgname>Apple Inc.</orgname><role>02</role><address><city>Cupertino</city><state>CA</state><country>US</country></address></addressbook></assignee></assignees></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A system comprises an encoder configured to compress attribute information and/or spatial information for a point cloud and/or a decoder configured to decompress compressed attribute and/or spatial information for the point cloud. The encoder is configured to convert a point cloud into an image based representation. The encoder packs patch images into an image frame and fills empty spaces in the image frame with a padding. The encoder is also configured to determine quantized minimum depths and/or maximum depths patch images in the image frames, wherein depth information is signaled relative to the quantized minimum depth.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="152.32mm" wi="158.75mm" file="US20230005188A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="98.47mm" wi="163.49mm" file="US20230005188A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="254.85mm" wi="151.05mm" orientation="landscape" file="US20230005188A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="245.28mm" wi="147.91mm" orientation="landscape" file="US20230005188A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="239.78mm" wi="147.91mm" orientation="landscape" file="US20230005188A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="242.91mm" wi="141.56mm" orientation="landscape" file="US20230005188A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="234.95mm" wi="143.68mm" file="US20230005188A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="132.33mm" wi="169.08mm" file="US20230005188A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="238.17mm" wi="165.27mm" file="US20230005188A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="238.68mm" wi="145.88mm" file="US20230005188A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="222.17mm" wi="156.13mm" file="US20230005188A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="131.91mm" wi="155.28mm" file="US20230005188A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="131.91mm" wi="155.28mm" file="US20230005188A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="254.85mm" wi="151.05mm" orientation="landscape" file="US20230005188A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00014" num="00014"><img id="EMI-D00014" he="249.26mm" wi="144.70mm" orientation="landscape" file="US20230005188A1-20230105-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00015" num="00015"><img id="EMI-D00015" he="241.72mm" wi="135.21mm" orientation="landscape" file="US20230005188A1-20230105-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00016" num="00016"><img id="EMI-D00016" he="120.65mm" wi="143.68mm" file="US20230005188A1-20230105-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00017" num="00017"><img id="EMI-D00017" he="261.03mm" wi="163.75mm" orientation="landscape" file="US20230005188A1-20230105-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00018" num="00018"><img id="EMI-D00018" he="260.69mm" wi="150.28mm" orientation="landscape" file="US20230005188A1-20230105-D00018.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00019" num="00019"><img id="EMI-D00019" he="238.08mm" wi="165.95mm" orientation="landscape" file="US20230005188A1-20230105-D00019.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00020" num="00020"><img id="EMI-D00020" he="249.43mm" wi="156.21mm" orientation="landscape" file="US20230005188A1-20230105-D00020.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00021" num="00021"><img id="EMI-D00021" he="243.92mm" wi="168.32mm" orientation="landscape" file="US20230005188A1-20230105-D00021.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00022" num="00022"><img id="EMI-D00022" he="248.16mm" wi="167.05mm" orientation="landscape" file="US20230005188A1-20230105-D00022.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00023" num="00023"><img id="EMI-D00023" he="253.07mm" wi="165.95mm" orientation="landscape" file="US20230005188A1-20230105-D00023.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00024" num="00024"><img id="EMI-D00024" he="258.06mm" wi="168.99mm" orientation="landscape" file="US20230005188A1-20230105-D00024.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00025" num="00025"><img id="EMI-D00025" he="170.69mm" wi="67.48mm" file="US20230005188A1-20230105-D00025.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00026" num="00026"><img id="EMI-D00026" he="130.22mm" wi="143.68mm" file="US20230005188A1-20230105-D00026.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00027" num="00027"><img id="EMI-D00027" he="170.26mm" wi="67.48mm" file="US20230005188A1-20230105-D00027.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00028" num="00028"><img id="EMI-D00028" he="271.61mm" wi="149.94mm" orientation="landscape" file="US20230005188A1-20230105-D00028.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00029" num="00029"><img id="EMI-D00029" he="260.69mm" wi="142.41mm" orientation="landscape" file="US20230005188A1-20230105-D00029.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00030" num="00030"><img id="EMI-D00030" he="197.61mm" wi="88.90mm" orientation="landscape" file="US20230005188A1-20230105-D00030.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00031" num="00031"><img id="EMI-D00031" he="219.12mm" wi="67.48mm" file="US20230005188A1-20230105-D00031.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00032" num="00032"><img id="EMI-D00032" he="242.91mm" wi="160.36mm" file="US20230005188A1-20230105-D00032.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00033" num="00033"><img id="EMI-D00033" he="194.48mm" wi="105.58mm" file="US20230005188A1-20230105-D00033.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00034" num="00034"><img id="EMI-D00034" he="106.34mm" wi="105.58mm" file="US20230005188A1-20230105-D00034.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00035" num="00035"><img id="EMI-D00035" he="251.63mm" wi="157.48mm" orientation="landscape" file="US20230005188A1-20230105-D00035.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00036" num="00036"><img id="EMI-D00036" he="227.33mm" wi="152.65mm" orientation="landscape" file="US20230005188A1-20230105-D00036.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00037" num="00037"><img id="EMI-D00037" he="122.77mm" wi="140.89mm" file="US20230005188A1-20230105-D00037.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00038" num="00038"><img id="EMI-D00038" he="244.43mm" wi="166.62mm" file="US20230005188A1-20230105-D00038.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00039" num="00039"><img id="EMI-D00039" he="241.30mm" wi="172.04mm" file="US20230005188A1-20230105-D00039.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00040" num="00040"><img id="EMI-D00040" he="161.97mm" wi="150.03mm" file="US20230005188A1-20230105-D00040.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00041" num="00041"><img id="EMI-D00041" he="158.75mm" wi="144.02mm" file="US20230005188A1-20230105-D00041.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00042" num="00042"><img id="EMI-D00042" he="222.25mm" wi="130.98mm" file="US20230005188A1-20230105-D00042.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00043" num="00043"><img id="EMI-D00043" he="241.89mm" wi="161.63mm" orientation="landscape" file="US20230005188A1-20230105-D00043.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00044" num="00044"><img id="EMI-D00044" he="164.93mm" wi="130.98mm" file="US20230005188A1-20230105-D00044.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00045" num="00045"><img id="EMI-D00045" he="158.75mm" wi="143.76mm" file="US20230005188A1-20230105-D00045.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00046" num="00046"><img id="EMI-D00046" he="146.05mm" wi="143.76mm" file="US20230005188A1-20230105-D00046.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00047" num="00047"><img id="EMI-D00047" he="190.50mm" wi="156.38mm" file="US20230005188A1-20230105-D00047.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">PRIORITY CLAIM</heading><p id="p-0002" num="0001">This application is a continuation of U.S. patent application Ser. No. 16/593,994, filed Oct. 5, 2019, which claims benefit of priority to U.S. Provisional Application Ser. No. 62/742,192, filed Oct. 5, 2018; and U.S. Provisional Application Ser. No. 62/781,539, filed Dec. 18, 2018. All three of which are incorporated herein by reference in their entirety.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">BACKGROUND</heading><heading id="h-0003" level="1">Technical Field</heading><p id="p-0003" num="0002">This disclosure relates generally to compression and decompression of point clouds comprising a plurality of points, each having associated spatial information and attribute information.</p><heading id="h-0004" level="1">Description of the Related Art</heading><p id="p-0004" num="0003">Various types of sensors, such as light detection and ranging (LIDAR) systems, 3-D-cameras, 3-D scanners, etc. may capture data indicating positions of points in three-dimensional space, for example positions in the X, Y, and Z planes. Also, such systems may further capture attribute information in addition to spatial information for the respective points, such as color information (e.g. RGB values), texture information, intensity attributes, reflectivity attributes, motion related attributes, modality attributes, or various other attributes. In some circumstances, additional attributes may be assigned to the respective points, such as a time-stamp when the point was captured. Points captured by such sensors may make up a &#x201c;point cloud&#x201d; comprising a set of points each having associated spatial information and one or more associated attributes. In some circumstances, a point cloud may include thousands of points, hundreds of thousands of points, millions of points, or even more points. Also, in some circumstances, point clouds may be generated, for example in software, as opposed to being captured by one or more sensors. In either case, such point clouds may include large amounts of data and may be costly and time-consuming to store and transmit.</p><heading id="h-0005" level="1">SUMMARY OF EMBODIMENTS</heading><p id="p-0005" num="0004">In some embodiments, a system includes one or more sensors configured to capture points that collectively make up a point cloud, wherein each of the points comprises spatial information identifying a spatial location of the respective point and attribute information defining one or more attributes associated with the respective point.</p><p id="p-0006" num="0005">The system also includes an encoder configured to compress the attribute and/or spatial information of the points. To compress the attribute and/or spatial information, the encoder is configured to determine, for the point cloud, a plurality of patches, each corresponding to portions of the point cloud, wherein each patch comprises points with surface normal vectors that deviate from one another less than a threshold amount. The encoder is further configured to, for each patch, generate a patch image comprising the set of points corresponding to the patch projected onto a patch plane and generate another patch image comprising d information, such as depth information, for the set of points corresponding to the patch, wherein the geometry information comprises depths of the points in a direction perpendicular to the patch plane.</p><p id="p-0007" num="0006">For example, the geometry patch image corresponding to the patch projected onto a patch plane may depict the points of the point cloud included in the patch in two directions, such as an X and Y direction. The points of the point cloud may be projected onto a patch plane approximately perpendicular to a normal vector, normal to a surface of the point cloud at the location of the patch. Also, for example, the geometry patch image comprising depth information for the set of points included in the patch may depict depth information, such as depth distances in a Z direction. To depict the depth information, the geometry patch image may include a parameter that varies in intensity based on the depth of points in the point cloud at a particular location in the patch image. For example, the geometry patch image depicting depth information may have a same shape as the attribute patch image representing attributes of points projected onto the patch plane. However, the geometry information patch image may be an image comprising image attributes, such as one or more colors, that vary in intensity based on depth, wherein the intensity of the one or more image attributes corresponds to a depth of a corresponding point of the point cloud at a location in the geometry patch image where the image attribute is displayed in the geometry patch image depicting depth. For example, points that are closer to the patch plane may be encoded as darker values in the patch image depicting depth and points that are further away from the patch plane may be encoded as lighter values in the patch image depicting depth, for example in a monochromatic patch image depicting depth. Thus, the depth information patch image when aligned with other patch images representing attribute values for points projected onto the patch plane may indicate the relative depths of the points projected onto the patch plane, based on respective image attribute intensities at locations in the geometry patch image that correspond to locations of the points in the other patch images comprising point cloud points projected onto the patch plane.</p><p id="p-0008" num="0007">The encoder is further configured to pack generated patch images (including a depth patch image and, optionally, one or more additional patch images for one or more other attributes) for each of the determined patches into one or more image frames and encode the one or more image frames. In some embodiments, the encoder may utilize various image or video encoding techniques to encode the one or more image frames. For example, the encoder may utilize a video encoder in accordance with the High Efficiency Video Coding (HEVC/H.265) standard or other suitable standards such as, the Advanced Video Coding (AVC/H.265) standard, the AOMedia Video 1 (AV1) video coding format produced by the Alliance for Open Media (AOM), etc. In some embodiments, the encoder may utilize an image encoder in accordance with a Motion Picture Experts Group (MPEG), a Joint Photography Experts Group (JPEG) standard, an International Telecommunication Union-Telecommunication standard (e.g. ITU-T standard), etc.</p><p id="p-0009" num="0008">In some embodiments, a decoder is configured to receive one or more encoded image frames comprising patch images for a plurality of patches of a compressed point cloud, wherein, for each patch, the one or more encoded image frames comprise: a patch image comprising a set of points of the patch projected onto a patch plane and a patch image comprising depth information for the set of points of the patch, wherein the depth information indicates depths of the points of the patch in a direction perpendicular to the patch plane. In some embodiments, a depth patch image may be packed into an image frame with other attribute patch images. For example, a decoder may receive one or more image frames comprising packed patch images as generated by the encoder described above. At least one of the image frames may have been down-scaled at an encoder, and the decoder may up-scale the down-scaled image frame, in a 2D video domain.</p><p id="p-0010" num="0009">The decoder is further configured to video decode the one or more video encoded image frames comprising the patch images. In some embodiments, the decoder may utilize a video decoder in accordance with the High Efficiency Video Coding (HEVC) standard or other suitable standards such as, the Advanced Video Coding (AVC) standard, the AOMedia Video 1 (AV1) video coding format, etc. In some embodiments, the decoder may utilize an image decoder in accordance with a Motion Picture Experts Group (MPEG) or a Joint Photography Experts Group (JPEG) standard, etc.</p><p id="p-0011" num="0010">The decoder is further configured to receive or determine relationship information indicating relationships between the respective attribute patch images, depth patch images, and/or image frames. For example, the decoder may receive relationship information in a compressed point cloud file, wherein the relationship information was determined by an encoder. Also, in some embodiments, the decoder may determine relationship information based on information included in a compressed point cloud file, such as an occupancy map and/or auxiliary information for the compressed point cloud. In some embodiments, the decoder may utilize the received or determined relationship information to adjust one or more parameters used to video decode the video encoded image frames.</p><p id="p-0012" num="0011">The decoder is further configured to determine, for each patch, spatial information for the set of points of the patch based, at least in part, on the attribute patch image comprising the set of points of the patch projected onto the patch plane and the geometry patch image comprising the depth information for the set of points of the patch, and generate a reconstructed version of the compressed point cloud based, at least in part, on the determined spatial information for the plurality of patches and the attribute information included in the patches.</p><p id="p-0013" num="0012">In some embodiments, a method includes receiving one or more encoded image frames comprising patch images for a plurality of patches of a compressed point cloud, wherein, for each patch, the one or more encoded image frames comprise: an attribute patch image comprising a set of points of the patch projected onto a patch plane and a geometry patch image comprising depth information for the set of points of the patch, wherein the depth information indicates depths of the points of the patch in a direction perpendicular to the patch plane. The method further includes receiving an occupancy map for the one or more image frames. The method further includes decoding the one or more encoded image frames comprising the patch images. Additionally, the method included up-scaling one or more of the image frames that were previously down-scaled. The up-scaling is performed in the 2D domain prior to reconstructing a 3D representation of the compressed point cloud. In some embodiments, decoding may be performed in accordance with the High Efficiency Video Coding (HEVC) standard or other suitable standards such as, the Advanced Video Coding (AVC) standard, an AOMedia Video 1 (AV1) video coding format, etc. In some embodiments, decoding may be performed in accordance with a Motion Picture Experts Group (MPEG) or a Joint Photography Experts Group (JPEG) standard, etc.</p><p id="p-0014" num="0013">The method further includes determining, for each patch, spatial information for the set of points of the patch based, at least in part, on the patch image comprising the set of points of the patch projected onto the patch plane and the patch image comprising the depth information for the set of points of the patch, and generating a reconstructed representation of the compressed point cloud based, at least in part, on the determined spatial information for the plurality of patches.</p><p id="p-0015" num="0014">In some embodiments, a non-transitory computer-readable medium stores program instructions that, when executed by one or more processors, cause the one or more processors to implement an encoder as described herein to compress geometry and attribute information of a point cloud.</p><p id="p-0016" num="0015">In some embodiments, a non-transitory computer-readable medium stores program instructions that, when executed by one or more processors, cause the one or more processors to implement a decoder as described herein to decompress geometry and attribute information of a point cloud.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0006" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates a system comprising a sensor that captures information for points of a point cloud and an encoder that compresses spatial information and attribute information of the point cloud, where the compressed spatial and attribute information is sent to a decoder, according to some embodiments.</p><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>2</b>A</figref> illustrates components of an encoder for encoding intra point cloud frames, according to some embodiments.</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>2</b>B</figref> illustrates components of a decoder for decoding intra point cloud frames, according to some embodiments.</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>2</b>C</figref> illustrates components of an encoder for encoding inter point cloud frames, according to some embodiments.</p><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. <b>2</b>D</figref> illustrates components of a decoder for decoding inter point cloud frames, according to some embodiments.</p><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. <b>3</b>A</figref> illustrates an example patch segmentation process, according to some embodiments.</p><p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. <b>3</b>B</figref> illustrates an example image frame comprising packed patch images and padded portions, according to some embodiments.</p><p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. <b>3</b>C</figref> illustrates an example image frame comprising patch portions and padded portions, according to some embodiments.</p><p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. <b>3</b>D</figref> illustrates a point cloud being projected onto multiple projections, according to some embodiments.</p><p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. <b>3</b>E</figref> illustrates a point cloud being projected onto multiple parallel projections, according to some embodiments.</p><p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. <b>3</b>F</figref> illustrates an example occupancy map, according to some embodiments.</p><p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. <b>3</b>G</figref> illustrates an example image frame comprising patches and padding, according to some embodiments.</p><p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. <b>3</b>H</figref> illustrates an example image frame comprising patches and smoothed padding, according to some embodiments.</p><p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. <b>3</b>I</figref> illustrates example neighborhood arrangements that may be used to determine a value of a pixel in a pad smoothing operation, according to some embodiments.</p><p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. <b>3</b>J</figref> illustrates an example transfer function for converting depth values (e g minimum or maximum) to quantized depth values, according to some embodiments.</p><p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. <b>3</b>K</figref> illustrates an example transfer function for converting depth values (e g minimum or maximum) to quantized depth values, according to some embodiments.</p><p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. <b>4</b>A</figref> illustrates components of an encoder for encoding intra point cloud frames with color conversion, according to some embodiments.</p><p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. <b>4</b>B</figref> illustrates components of an encoder for encoding inter point cloud frames with color conversion, according to some embodiments.</p><p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. <b>4</b>C</figref> illustrates components of a closed-loop color conversion module, according to some embodiments.</p><p id="p-0036" num="0035"><figref idref="DRAWINGS">FIG. <b>4</b>D</figref> illustrates an example process for determining a quality metric for a point cloud upon which an operation has been performed, according to some embodiments.</p><p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. <b>5</b>A</figref> illustrates components of an encoder that includes geometry, texture, and/or other attribute downscaling, according to some embodiments.</p><p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. <b>5</b>B</figref> illustrates components of a decoder that includes geometry, texture, and/or other attribute upscaling, according to some embodiments.</p><p id="p-0039" num="0038"><figref idref="DRAWINGS">FIG. <b>5</b>C</figref> illustrates rescaling from the perspective of an encoder, according to some embodiments.</p><p id="p-0040" num="0039"><figref idref="DRAWINGS">FIG. <b>5</b>D</figref> illustrates rescaling from the perspective of a decoder, according to some embodiments.</p><p id="p-0041" num="0040"><figref idref="DRAWINGS">FIG. <b>5</b>E</figref> illustrates an example open loop rescaling, according to some embodiments.</p><p id="p-0042" num="0041"><figref idref="DRAWINGS">FIG. <b>5</b>F</figref> illustrates an example closed loop rescaling, according to some embodiments.</p><p id="p-0043" num="0042"><figref idref="DRAWINGS">FIG. <b>5</b>G</figref> illustrates an example closed loop rescaling with multiple attribute layers, according to some embodiments.</p><p id="p-0044" num="0043"><figref idref="DRAWINGS">FIG. <b>5</b>H</figref> illustrates an example of video level spatiotemporal scaling, according to some embodiments.</p><p id="p-0045" num="0044"><figref idref="DRAWINGS">FIG. <b>5</b>I</figref> illustrates an example closed loop rescaling with spatiotemporal scaling, according to some embodiments.</p><p id="p-0046" num="0045"><figref idref="DRAWINGS">FIG. <b>5</b>J</figref> illustrates a process of encoding/compressing image frames of a point cloud using down-scaling, according to some embodiments.</p><p id="p-0047" num="0046"><figref idref="DRAWINGS">FIG. <b>5</b>K</figref> illustrates a process of determining to down-scaling image frames using open-loop or closed-loop down-scaling, according to some embodiments.</p><p id="p-0048" num="0047"><figref idref="DRAWINGS">FIG. <b>5</b>L</figref> illustrates a process of decoding/decompressing image frames of a point cloud using up-scaling, according to some embodiments.</p><p id="p-0049" num="0048"><figref idref="DRAWINGS">FIG. <b>6</b>A</figref> illustrates components of an encoder that further includes pre-video compression texture processing and/or filtering and pre video compression geometry processing/filtering, according to some embodiments.</p><p id="p-0050" num="0049"><figref idref="DRAWINGS">FIG. <b>6</b>B</figref> illustrates components of a decoder that further includes post video decompression texture processing and/or filtering and post video decompression geometry processing/filtering, according to some embodiments.</p><p id="p-0051" num="0050"><figref idref="DRAWINGS">FIG. <b>6</b>C</figref> illustrates, a bit stream structure for a compressed point cloud, according to some embodiments.</p><p id="p-0052" num="0051"><figref idref="DRAWINGS">FIG. <b>6</b>D</figref> illustrates a process for generating video encoded image frames for patches of a point cloud taking into account relationship information between the patches packed into the image frames, according to some embodiments.</p><p id="p-0053" num="0052"><figref idref="DRAWINGS">FIG. <b>6</b>E</figref> illustrates a process for generating video encoded image frames taking into account pooled distortion for a set of patches corresponding to a same set of points, according to some embodiments.</p><p id="p-0054" num="0053"><figref idref="DRAWINGS">FIG. <b>6</b>F</figref> illustrates a process for generating video encoded image frames taking into account patch edges, according to some embodiments.</p><p id="p-0055" num="0054"><figref idref="DRAWINGS">FIG. <b>6</b>G</figref> illustrates a process for reconstructing a point cloud based on video encoded image frames comprising patches of the point cloud, wherein relationship information between the patches packed into the image frames is taken into account, according to some embodiments.</p><p id="p-0056" num="0055"><figref idref="DRAWINGS">FIG. <b>6</b>H</figref> illustrates a process of upscaling a patch image included in an image frame taking into account edges of the patch image determined based on received or determined relationship information for the patches, according to some embodiments.</p><p id="p-0057" num="0056"><figref idref="DRAWINGS">FIG. <b>6</b>I</figref> illustrates an example application where an attribute plane is up-scaled using its corresponding geometry information and the geometry extracted edges, according to some embodiments.</p><p id="p-0058" num="0057"><figref idref="DRAWINGS">FIG. <b>7</b>A</figref> illustrates an example of a point cloud compression network abstraction layer (PCCNAL) unit based bit stream, according to some embodiments.</p><p id="p-0059" num="0058"><figref idref="DRAWINGS">FIG. <b>7</b>B</figref> illustrates an example of a PCCNAL units grouped by picture order count (POC), according to some embodiments.</p><p id="p-0060" num="0059"><figref idref="DRAWINGS">FIG. <b>7</b>C</figref> illustrates an example of a PCCNAL unit grouped by type, according to some embodiments.</p><p id="p-0061" num="0060"><figref idref="DRAWINGS">FIG. <b>8</b>A</figref> illustrates a process for compressing attribute and spatial information of a point cloud, according to some embodiments.</p><p id="p-0062" num="0061"><figref idref="DRAWINGS">FIG. <b>8</b>B</figref> illustrates a process for decompressing attribute and spatial information of a point cloud, according to some embodiments.</p><p id="p-0063" num="0062"><figref idref="DRAWINGS">FIG. <b>8</b>C</figref> illustrates patch images being generated and packed into an image frame to compress attribute and spatial information of a point cloud, according to some embodiments.</p><p id="p-0064" num="0063"><figref idref="DRAWINGS">FIG. <b>9</b></figref> illustrates patch images being generated and packed into an image frame to compress attribute and spatial information of a moving or changing point cloud, according to some embodiments.</p><p id="p-0065" num="0064"><figref idref="DRAWINGS">FIG. <b>10</b></figref> illustrates a decoder receiving image frames comprising patch images, patch information, and an occupancy map, and generating a decompressed representation of a point cloud, according to some embodiments.</p><p id="p-0066" num="0065"><figref idref="DRAWINGS">FIG. <b>11</b>A</figref> illustrates an encoder, adjusting encoding based on one or more masks for a point cloud, according to some embodiments.</p><p id="p-0067" num="0066"><figref idref="DRAWINGS">FIG. <b>11</b>B</figref> illustrates a decoder, adjusting decoding based on one or more masks for a point cloud, according to some embodiments.</p><p id="p-0068" num="0067"><figref idref="DRAWINGS">FIG. <b>12</b>A</figref> illustrates more detail regarding compression of an occupancy map, according to some embodiments.</p><p id="p-0069" num="0068"><figref idref="DRAWINGS">FIG. <b>12</b>B</figref> illustrates example blocks and traversal patterns for compressing an occupancy map, according to some embodiments.</p><p id="p-0070" num="0069"><figref idref="DRAWINGS">FIG. <b>12</b>C</figref> illustrates more detail regarding compression of an occupancy map, according to some embodiments.</p><p id="p-0071" num="0070"><figref idref="DRAWINGS">FIG. <b>13</b></figref> illustrates compressed point cloud information being used in a 3-D telepresence application, according to some embodiments.</p><p id="p-0072" num="0071"><figref idref="DRAWINGS">FIG. <b>14</b></figref> illustrates compressed point cloud information being used in a virtual reality application, according to some embodiments.</p><p id="p-0073" num="0072"><figref idref="DRAWINGS">FIG. <b>15</b></figref> illustrates an example computer system that may implement an encoder or decoder, according to some embodiments.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><p id="p-0074" num="0073">This specification includes references to &#x201c;one embodiment&#x201d; or &#x201c;an embodiment.&#x201d; The appearances of the phrases &#x201c;in one embodiment&#x201d; or &#x201c;in an embodiment&#x201d; do not necessarily refer to the same embodiment. Particular features, structures, or characteristics may be combined in any suitable manner consistent with this disclosure.</p><p id="p-0075" num="0074">&#x201c;Comprising.&#x201d; This term is open-ended. As used in the appended claims, this term does not foreclose additional structure or steps. Consider a claim that recites: &#x201c;An apparatus comprising one or more processor units . . . &#x201d; Such a claim does not foreclose the apparatus from including additional components (e.g., a network interface unit, graphics circuitry, etc.).</p><p id="p-0076" num="0075">&#x201c;Configured To.&#x201d; Various units, circuits, or other components may be described or claimed as &#x201c;configured to&#x201d; perform a task or tasks. In such contexts, &#x201c;configured to&#x201d; is used to connote structure by indicating that the units/circuits/components include structure (e.g., circuitry) that performs those task or tasks during operation. As such, the unit/circuit/component can be said to be configured to perform the task even when the specified unit/circuit/component is not currently operational (e.g., is not on). The units/circuits/components used with the &#x201c;configured to&#x201d; language include hardware&#x2014;for example, circuits, memory storing program instructions executable to implement the operation, etc. Reciting that a unit/circuit/component is &#x201c;configured to&#x201d; perform one or more tasks is expressly intended not to invoke 35 U.S.C. &#xa7; 112(f), for that unit/circuit/component. Additionally, &#x201c;configured to&#x201d; can include generic structure (e.g., generic circuitry) that is manipulated by software and/or firmware (e.g., an FPGA or a general-purpose processor executing software) to operate in manner that is capable of performing the task(s) at issue. &#x201c;Configure to&#x201d; may also include adapting a manufacturing process (e.g., a semiconductor fabrication facility) to fabricate devices (e.g., integrated circuits) that are adapted to implement or perform one or more tasks.</p><p id="p-0077" num="0076">&#x201c;First,&#x201d; &#x201c;Second,&#x201d; etc. As used herein, these terms are used as labels for nouns that they precede, and do not imply any type of ordering (e.g., spatial, temporal, logical, etc.). For example, a buffer circuit may be described herein as performing write operations for &#x201c;first&#x201d; and &#x201c;second&#x201d; values. The terms &#x201c;first&#x201d; and &#x201c;second&#x201d; do not necessarily imply that the first value must be written before the second value.</p><p id="p-0078" num="0077">&#x201c;Based On.&#x201d; As used herein, this term is used to describe one or more factors that affect a determination. This term does not foreclose additional factors that may affect a determination. That is, a determination may be solely based on those factors or based, at least in part, on those factors. Consider the phrase &#x201c;determine A based on B.&#x201d; While in this case, B is a factor that affects the determination of A, such a phrase does not foreclose the determination of A from also being based on C. In other instances, A may be determined based solely on B.</p><heading id="h-0007" level="1">DETAILED DESCRIPTION</heading><p id="p-0079" num="0078">As data acquisition and display technologies have become more advanced, the ability to capture point clouds comprising thousands or millions of points in 2-D or 3-D space, such as via LIDAR systems, has increased. Also, the development of advanced display technologies, such as virtual reality or augmented reality systems, has increased potential uses for point clouds. However, point cloud files are often very large and may be costly and time-consuming to store and transmit. For example, communication of point clouds over private or public networks, such as the Internet, may require considerable amounts of time and/or network resources, such that some uses of point cloud data, such as real-time uses, may be limited. Also, storage requirements of point cloud files may consume a significant amount of storage capacity of devices storing the point cloud files, which may also limit potential applications for using point cloud data.</p><p id="p-0080" num="0079">In some embodiments, an encoder may be used to generate a compressed point cloud to reduce costs and time associated with storing and transmitting large point cloud files. In some embodiments, a system may include an encoder that compresses attribute and/or spatial information of a point cloud file such that the point cloud file may be stored and transmitted more quickly than non-compressed point clouds and in a manner that the point cloud file may occupy less storage space than non-compressed point clouds. In some embodiments, compression of attributes of points in a point cloud may enable a point cloud to be communicated over a network in real-time or in near real-time. For example, a system may include a sensor that captures attribute information about points in an environment where the sensor is located, wherein the captured points and corresponding attributes make up a point cloud. The system may also include an encoder that compresses the captured point cloud attribute information. The compressed attribute information of the point cloud may be sent over a network in real-time or near real-time to a decoder that decompresses the compressed attribute information of the point cloud. The decompressed point cloud may be further processed, for example to make a control decision based on the surrounding environment at the location of the sensor. The control decision may then be communicated back to a device at or near the location of the sensor, wherein the device receiving the control decision implements the control decision in real-time or near real-time. In some embodiments, the decoder may be associated with an augmented reality system and the decompressed attribute information may be displayed or otherwise used by the augmented reality system. In some embodiments, compressed attribute information for a point cloud may be sent with compressed spatial information for points of the point cloud. In other embodiments, spatial information and attribute information may be separately encoded and/or separately transmitted to a decoder.</p><p id="p-0081" num="0080">In some embodiments, a system may include a decoder that receives one or more sets of point cloud data comprising compressed attribute information via a network from a remote server or other storage device that stores the one or more point cloud files. For example, a 3-D display, a holographic display, or a head-mounted display may be manipulated in real-time or near real-time to show different portions of a virtual world represented by point clouds. In order to update the 3-D display, the holographic display, or the head-mounted display, a system associated with the decoder may request point cloud data from the remote server based on user manipulations of the displays, and the point cloud data may be transmitted from the remote server to the decoder and decoded by the decoder in real-time or near real-time. The displays may then be updated with updated point cloud data responsive to the user manipulations, such as updated point attributes.</p><p id="p-0082" num="0081">In some embodiments, a system, may include one or more LIDAR systems, 3-D cameras, 3-D scanners, etc., and such sensor devices may capture spatial information, such as X, Y, and Z coordinates for points in a view of the sensor devices. In some embodiments, the spatial information may be relative to a local coordinate system or may be relative to a global coordinate system (for example, a Cartesian coordinate system may have a fixed reference point, such as a fixed point on the earth, or may have a non-fixed local reference point, such as a sensor location).</p><p id="p-0083" num="0082">In some embodiments, such sensors may also capture attribute information for one or more points, such as color attributes, texture attributes, reflectivity attributes, velocity attributes, acceleration attributes, time attributes, modalities, and/or various other attributes. In some embodiments, other sensors, in addition to LIDAR systems, 3-D cameras, 3-D scanners, etc., may capture attribute information to be included in a point cloud. For example, in some embodiments, a gyroscope or accelerometer, may capture motion information to be included in a point cloud as an attribute associated with one or more points of the point cloud. For example, a vehicle equipped with a LIDAR system, a 3-D camera, or a 3-D scanner may include the vehicle's direction and speed in a point cloud captured by the LIDAR system, the 3-D camera, or the 3-D scanner. For example, when points in a view of the vehicle are captured they may be included in a point cloud, wherein the point cloud includes the captured points and associated motion information corresponding to a state of the vehicle when the points were captured.</p><heading id="h-0008" level="1">Example System Arrangement</heading><p id="p-0084" num="0083"><figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates a system comprising a sensor that captures information for points of a point cloud and an encoder that compresses attribute information of the point cloud, where the compressed attribute information is sent to a decoder, according to some embodiments.</p><p id="p-0085" num="0084">System <b>100</b> includes sensor <b>102</b> and encoder <b>104</b>. Sensor <b>102</b> captures a point cloud <b>110</b> comprising points representing structure <b>106</b> in view <b>108</b> of sensor <b>102</b>. For example, in some embodiments, structure <b>106</b> may be a mountain range, a building, a sign, an environment surrounding a street, or any other type of structure. In some embodiments, a captured point cloud, such as captured point cloud <b>110</b>, may include spatial and attribute information for the points included in the point cloud. For example, point A of captured point cloud <b>110</b> comprises X, Y, Z coordinates and attributes <b>1</b>, <b>2</b>, and <b>3</b>. In some embodiments, attributes of a point may include attributes such as R, G, B color values, a velocity at the point, an acceleration at the point, a reflectance of the structure at the point, a time stamp indicating when the point was captured, a string-value indicating a modality when the point was captured, for example &#x201c;walking&#x201d;, or other attributes. The captured point cloud <b>110</b> may be provided to encoder <b>104</b>, wherein encoder <b>104</b> generates a compressed version of the point cloud (compressed attribute information <b>112</b>) that is transmitted via network <b>114</b> to decoder <b>116</b>. In some embodiments, a compressed version of the point cloud, such as compressed attribute information <b>112</b>, may be included in a common compressed point cloud that also includes compressed spatial information for the points of the point cloud or, in some embodiments, compressed spatial information and compressed attribute information may be communicated as separate sets of data.</p><p id="p-0086" num="0085">In some embodiments, encoder <b>104</b> may be integrated with sensor <b>102</b>. For example, encoder <b>104</b> may be implemented in hardware or software included in a sensor device, such as sensor <b>102</b>. In other embodiments, encoder <b>104</b> may be implemented on a separate computing device that is proximate to sensor <b>102</b>.</p><heading id="h-0009" level="1">Example Intra-3D Frame Encoder</heading><p id="p-0087" num="0086"><figref idref="DRAWINGS">FIG. <b>2</b>A</figref> illustrates components of an encoder for encoding intra point cloud frames, according to some embodiments. In some embodiments, the encoder described above in regard to <figref idref="DRAWINGS">FIG. <b>1</b></figref> may operate in a similar manner as encoder <b>200</b> described in <figref idref="DRAWINGS">FIG. <b>2</b>A</figref> and encoder <b>250</b> described in <figref idref="DRAWINGS">FIG. <b>2</b>C</figref>.</p><p id="p-0088" num="0087">The encoder <b>200</b> receives uncompressed point cloud <b>202</b> and generates compressed point cloud information <b>204</b>. In some embodiments, an encoder, such as encoder <b>200</b>, may receive the uncompressed point cloud <b>202</b> from a sensor, such as sensor <b>102</b> illustrated in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, or, in some embodiments, may receive the uncompressed point cloud <b>202</b> from another source, such as a graphics generation component that generates the uncompressed point cloud in software, as an example.</p><p id="p-0089" num="0088">In some embodiments, an encoder, such as encoder <b>200</b>, includes decomposition into patches module <b>206</b>, packing module <b>208</b>, spatial image generation module <b>210</b>, texture image generation module <b>212</b>, and attribute information generation module <b>214</b>. In some embodiments, an encoder, such as encoder <b>200</b>, also includes image frame padding module <b>216</b>, video compression module <b>218</b> and multiplexer <b>224</b>. In addition, in some embodiments an encoder, such as encoder <b>200</b>, may include an occupancy map compression module, such as occupancy map compression module <b>220</b>, and an auxiliary patch information compression module, such as auxiliary patch information compression module <b>222</b>. In some embodiments, an encoder, such as encoder <b>200</b>, converts a 3D point cloud into an image-based representation along with some meta data (e.g., occupancy map and patch info) necessary to convert the compressed point cloud back into a decompressed point cloud.</p><p id="p-0090" num="0089">In some embodiments, the conversion process decomposes the point cloud into a set of patches (e.g., a patch is defined as a contiguous subset of the surface described by the point cloud), which may be overlapping or not, such that each patch may be described by a depth field with respect to a plane in 2D space. More details about the patch decomposition process are provided above with regard to <figref idref="DRAWINGS">FIGS. <b>3</b>A-<b>3</b>C</figref>.</p><p id="p-0091" num="0090">After or in conjunction with the patches being determined for the point cloud being compressed, a 2D sampling process is performed in planes associated with the patches. The 2D sampling process may be applied in order to approximate each patch with a uniformly sampled point cloud, which may be stored as a set of 2D patch images describing the geometry/texture/attributes of the point cloud at the patch location. The &#x201c;Packing&#x201d; module <b>208</b> may store the 2D patch images associated with the patches in a single (or multiple) 2D images, referred to herein as &#x201c;image frames&#x201d; or &#x201c;video image frames.&#x201d; In some embodiments, a packing module, such as packing module <b>208</b>, may pack the 2D patch images such that the packed 2D patch images do not overlap (even though an outer bounding box for one patch image may overlap an outer bounding box for another patch image). Also, the packing module may pack the 2D patch images in a way that minimizes non-used images pixels of the image frame.</p><p id="p-0092" num="0091">In some embodiments, &#x201c;Geometry/Texture/Attribute generation&#x201d; modules, such as modules <b>210</b>, <b>212</b>, and <b>214</b>, generate 2D patch images associated with the geometry/texture/attributes, respectively, of the point cloud at a given patch location. As noted before, a packing process, such as performed by packing module <b>208</b>, may leave some empty spaces between 2D patch images packed in an image frame. Also, a padding module, such as image frame padding module <b>216</b>, may fill in such areas in order to generate an image frame that may be suited for 2D video and image codecs.</p><p id="p-0093" num="0092">In some embodiments, an occupancy map (e.g., binary information describing for each pixel or block of pixels whether the pixel or block of pixels are padded or not) may be generated and compressed, for example by occupancy map compression module <b>220</b>. The occupancy map may be sent to a decoder to enable the decoder to distinguish between padded and non-padded pixels of an image frame.</p><p id="p-0094" num="0093">Note that other metadata associated with patches may also be sent to a decoder for use in the decompression process. For example, patch information indicating sizes and shapes of patches determined for the point cloud and packed in an image frame may be generated and/or encoded by an auxiliary patch-information compression module, such as auxiliary patch-information compression module <b>222</b>. In some embodiments one or more image frames may be encoded by a video encoder, such as video compression module <b>218</b>. In some embodiments, a video encoder, such as video compression module <b>218</b>, may operate in accordance with the High Efficiency Video Coding (HEVC) standard or other suitable video encoding standard. In some embodiments, encoded video images, encoded occupancy map information, and encoded auxiliary patch information may be multiplexed by a multiplexer, such as multiplexer <b>224</b>, and provided to a recipient as compressed point cloud information, such as compressed point cloud information <b>204</b>.</p><p id="p-0095" num="0094">In some embodiments, an occupancy map may be encoded and decoded by a video compression module, such as video compression module <b>218</b>. This may be done at an encoder, such as encoder <b>200</b>, such that the encoder has an accurate representation of what the occupancy map will look like when decoded by a decoder. Also, variations in image frames due to lossy compression and decompression may be accounted for by an occupancy map compression module, such as occupancy map compression module <b>220</b>, when determining an occupancy map for an image frame. In some embodiments, various techniques may be used to further compress an occupancy map, such as described in <figref idref="DRAWINGS">FIGS. <b>12</b>A-<b>12</b>B</figref>.</p><heading id="h-0010" level="1">Example Intra 3D Frame Decoder</heading><p id="p-0096" num="0095"><figref idref="DRAWINGS">FIG. <b>2</b>B</figref> illustrates components of a decoder for decoding intra point cloud frames, according to some embodiments. Decoder <b>230</b> receives compressed point cloud information <b>204</b>, which may be the same compressed point cloud information <b>204</b> generated by encoder <b>200</b>. Decoder <b>230</b> generates reconstructed point cloud <b>246</b> based on receiving the compressed point cloud information <b>204</b>.</p><p id="p-0097" num="0096">In some embodiments, a decoder, such as decoder <b>230</b>, includes a de-multiplexer <b>232</b>, a video decompression module <b>234</b>, an occupancy map decompression module <b>236</b>, and an auxiliary patch-information decompression module <b>238</b>. Additionally a decoder, such as decoder <b>230</b> includes a point cloud generation module <b>240</b>, which reconstructs a point cloud based on patch images included in one or more image frames included in the received compressed point cloud information, such as compressed point cloud information <b>204</b>. In some embodiments, a decoder, such as decoder <b>203</b>, further comprises a smoothing filter, such as smoothing filter <b>244</b>. In some embodiments, a smoothing filter may smooth incongruences at edges of patches, wherein data included in patch images for the patches has been used by the point cloud generation module to recreate a point cloud from the patch images for the patches. In some embodiments, a smoothing filter may be applied to the pixels located on the patch boundaries to alleviate the distortions that may be caused by the compression/decompression process.</p><heading id="h-0011" level="1">Example Inter 3D Frame Encoder</heading><p id="p-0098" num="0097"><figref idref="DRAWINGS">FIG. <b>2</b>C</figref> illustrates components of an encoder for encoding inter point cloud frames, according to some embodiments. An inter point cloud encoder, such as inter point cloud encoder <b>250</b>, may encode an image frame, while considering one or more previously encoded/decoded image frames as references.</p><p id="p-0099" num="0098">In some embodiments, an encoder for inter point cloud frames, such as encoder <b>250</b>, includes a point cloud re-sampling module <b>252</b>, a 3-D motion compensation and delta vector prediction module <b>254</b>, a spatial image generation module <b>256</b>, a texture image generation module <b>258</b>, and an attribute image generation module <b>260</b>. In some embodiments, an encoder for inter point cloud frames, such as encoder <b>250</b>, may also include an image padding module <b>262</b> and a video compression module <b>264</b>. An encoder for inter point cloud frames, such as encoder <b>250</b>, may generate compressed point cloud information, such as compressed point cloud information <b>266</b>. In some embodiments, the compressed point cloud information may reference point cloud information previously encoded by the encoder, such as information from or derived from one or more reference image frames. In this way an encoder for inter point cloud frames, such as encoder <b>250</b>, may generate more compact compressed point cloud information by not repeating information included in a reference image frame, and instead communicating differences between the reference frames and a current state of the point cloud.</p><p id="p-0100" num="0099">In some embodiments, an encoder, such as encoder <b>250</b>, may be combined with or share modules with an intra point cloud frame encoder, such as encoder <b>200</b>. In some embodiments, a point cloud re-sampling module, such as point cloud re-sampling module <b>252</b>, may resample points in an input point cloud image frame in order to determine a one-to-one mapping between points in patches of the current image frame and points in patches of a reference image frame for the point cloud. In some embodiments, a 3D motion compensation &#x26; delta vector prediction module, such as a 3D motion compensation &#x26; delta vector prediction module <b>254</b>, may apply a temporal prediction to the geometry/texture/attributes of the resampled points of the patches. The prediction residuals may be stored into images, which may be padded and compressed by using video/image codecs. In regard to spatial changes for points of the patches between the reference frame and a current frame, a 3D motion compensation &#x26; delta vector prediction module <b>254</b>, may determine respective vectors for each of the points indicating how the points moved from the reference frame to the current frame. A 3D motion compensation &#x26; delta vector prediction module <b>254</b>, may then encode the motion vectors using different image parameters. For example, changes in the X direction for a point may be represented by an amount of red included at the point in a patch image that includes the point. In a similar manner, changes in the Y direction for a point may be represented by an amount of blue included at the point in a patch image that includes the point. Also, in a similar manner, changes in the Z direction for a point may be represented by an amount of green included at the point in a patch image that includes the point. In some embodiments, other characteristics of an image included in a patch image may be adjusted to indicate motion of points included in the patch between a reference frame for the patch and a current frame for the patch.</p><heading id="h-0012" level="1">Example Inter 3D Frame Decoder</heading><p id="p-0101" num="0100"><figref idref="DRAWINGS">FIG. <b>2</b>D</figref> illustrates components of a decoder for decoding inter point cloud frames, according to some embodiments. In some embodiments, a decoder, such as decoder <b>280</b>, includes a video decompression module <b>270</b>, an inverse 3D motion compensation and inverse delta prediction module <b>272</b>, a point cloud generation module <b>274</b>, and a smoothing filter <b>276</b>. In some embodiments, a decoder, such as decoder <b>280</b> may be combined with a decoder, such as decoder <b>230</b>, or may share some components with the decoder, such as a video decompression module and/or smoothing filter. In decoder <b>280</b>, the video/image streams are first decoded, then an inverse motion compensation and delta prediction procedure may be applied. The obtained images are then used in order to reconstruct a point cloud, which may be smoothed as described previously to generate a reconstructed point cloud <b>282</b>.</p><heading id="h-0013" level="2">Segmentation Process</heading><p id="p-0102" num="0101"><figref idref="DRAWINGS">FIG. <b>3</b>A</figref> illustrates an example segmentation process for determining patches for a point cloud, according to some embodiments. The segmentation process as described in <figref idref="DRAWINGS">FIG. <b>3</b>A</figref> may be performed by a decomposition into patches module, such as decomposition into patches module <b>206</b>. A segmentation process may decompose a point cloud into a minimum number of patches (e.g., a contiguous subset of the surface described by the point cloud), while making sure that the respective patches may be represented by a depth field with respect to a patch plane. This may be done without a significant loss of shape information.</p><p id="p-0103" num="0102">In some embodiments, a segmentation process comprises:<ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0103">Letting point cloud PC be the input point cloud to be partitioned into patches and {P(0), P(1) . . . , P(N&#x2212;1)} be the positions of points of point cloud PC.</li>        <li id="ul0002-0002" num="0104">In some embodiments, a fixed set D={D(0), D(1), . . . , D(K&#x2212;1)} of K 3D orientations is pre-defined. For instance, D may be chosen as follows D={(1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0), (&#x2212;1.0, 0.0, 0.0), (0.0, &#x2212;1.0, 0.0), (0.0, 0.0, &#x2212;1.0)}</li>        <li id="ul0002-0003" num="0105">In some embodiments, the normal vector to the surface at every point P(i) is estimated. Any suitable algorithm may be used to determine the normal vector to the surface. For instance, a technique could include fetching the set H of the &#x201c;N&#x201d; nearest points of P(i), and fitting a plane &#x3a0;(i) to H(i) by using principal component analysis techniques. The normal to P(i) may be estimated by taking the normal &#x2207;(i) to &#x3a0;(i). Note that &#x201c;N&#x201d; may be a user-defined parameter or may be found by applying an optimization procedure. &#x201c;N&#x201d; may also be fixed or adaptive. The normal values may then be oriented consistently by using a minimum-spanning tree approach.</li>        <li id="ul0002-0004" num="0106">Normal-based Segmentation: An initial segmentation S0 of the points of point cloud PC may be obtained by associating respective points with the direction D(k) which maximizes the score <img id="CUSTOM-CHARACTER-00001" he="3.22mm" wi="0.68mm" file="US20230005188A1-20230105-P00001.TIF" alt="custom-character" img-content="character" img-format="tif"/>&#x2207;(i)|D(k)<img id="CUSTOM-CHARACTER-00002" he="3.22mm" wi="0.68mm" file="US20230005188A1-20230105-P00002.TIF" alt="custom-character" img-content="character" img-format="tif"/>, where <img id="CUSTOM-CHARACTER-00003" he="3.22mm" wi="0.68mm" file="US20230005188A1-20230105-P00001.TIF" alt="custom-character" img-content="character" img-format="tif"/>.|.<img id="CUSTOM-CHARACTER-00004" he="3.22mm" wi="0.68mm" file="US20230005188A1-20230105-P00002.TIF" alt="custom-character" img-content="character" img-format="tif"/> is the canonical dot product of R3. Pseudo code is provided below.</li>    </ul>    </li></ul></p><p id="p-0104" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="49pt" align="left"/><colspec colname="2" colwidth="133pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2003;</entry><entry>for (i = 0; i &#x3c; pointCount; ++i) {</entry></row><row><entry/><entry/><entry>&#x2003;clusterIndex = 0;</entry></row><row><entry/><entry/><entry>&#x2003;bestScore = <img id="CUSTOM-CHARACTER-00005" he="2.46mm" wi="1.10mm" file="US20230005188A1-20230105-P00003.TIF" alt="custom-character" img-content="character" img-format="tif"/> V()|D(0)<img id="CUSTOM-CHARACTER-00006" he="2.46mm" wi="1.10mm" file="US20230005188A1-20230105-P00004.TIF" alt="custom-character" img-content="character" img-format="tif"/> ;</entry></row><row><entry/><entry/><entry>&#x2003;for(j = 1; j &#x3c; K; ++j) {</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;score = <img id="CUSTOM-CHARACTER-00007" he="2.46mm" wi="1.10mm" file="US20230005188A1-20230105-P00003.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2207;(i) | D(j));</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;if (score &#x3e; bestScore) {</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;&#x2003;bestScore = score;</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;&#x2003;clusterIndex = j;</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;}</entry></row><row><entry/><entry/><entry>&#x2003;}</entry></row><row><entry/><entry/><entry>&#x2003;partition[i] = clusterIndex;</entry></row><row><entry/><entry/><entry>}</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><ul id="ul0003" list-style="none">    <li id="ul0003-0001" num="0000">    <ul id="ul0004" list-style="none">        <li id="ul0004-0001" num="0107">Iterative segmentation refinement: Note that segmentation S0 associates respective points with the plane &#x3a0;(i) that best preserves the geometry of its neighborhood (e.g. the neighborhood of the segment). In some circumstances, segmentation S0 may generate too many small connected components with irregular boundaries, which may result in poor compression performance In order to avoid such issues, the following iterative segmentation refinement procedure may be applied:        <ul id="ul0005" list-style="none">            <li id="ul0005-0001" num="0108">1. An adjacency graph A may be built by associating a vertex &#x2207;(i) to respective points P(i) of point cloud PC and by adding R edges {E(i,j(0)), . . . , E(i,j(R&#x2212;1)} connecting vertex V(i) to its nearest neighbors {V(j(0)), V(j(1)), . . . , V(j(R&#x2212;1))}. More precisely, {V(j(0)), V(j(1)), . . . , V(j(R&#x2212;1))} may be the vertices associated with the points {P(j(0)), P(j(1)), . . . , P(j(R&#x2212;1))}, which may be the nearest neighbors of P(i). Note that R may be a user-defined parameter or may be found by applying an optimization procedure. It may also be fixed or adaptive.</li>            <li id="ul0005-0002" num="0109">2. At each iteration, the points of point cloud PC may be traversed and every vertex may be associated with the direction D (k) that maximizes</li>        </ul>        </li>    </ul>    </li></ul></p><p id="p-0105" num="0000"><maths id="MATH-US-00001" num="00001"><math overflow="scroll"> <mrow>  <mrow>   <mo>(</mo>   <mrow>    <mrow>     <mo>&#x2329;</mo>     <mrow>      <mrow>       <mo>&#x2207;</mo>       <mrow>        <mo>(</mo>        <mi>i</mi>        <mo>)</mo>       </mrow>      </mrow>      <mo>&#x2062;</mo>      <mrow>       <semantics definitionURL="">        <mo>&#x2758;</mo>        <annotation encoding="Mathematica">"\[LeftBracketingBar]"</annotation>       </semantics>       <mrow>        <mi>D</mi>        <mo>&#x2061;</mo>        <mo>(</mo>        <mi>k</mi>        <mo>)</mo>       </mrow>      </mrow>     </mrow>     <mo>&#x232a;</mo>    </mrow>    <mo>+</mo>    <mrow>     <mfrac>      <mi>&#x3bb;</mi>      <mi>R</mi>     </mfrac>     <mo>&#x2062;</mo>     <mrow>      <semantics definitionURL="">       <mo>&#x2758;</mo>       <annotation encoding="Mathematica">"\[LeftBracketingBar]"</annotation>      </semantics>      <mrow>       <mi>&#x3b6;</mi>       <mo>&#x2061;</mo>       <mo>(</mo>       <mi>i</mi>       <mo>)</mo>      </mrow>      <semantics definitionURL="">       <mo>&#x2758;</mo>       <annotation encoding="Mathematica">"\[RightBracketingBar]"</annotation>      </semantics>     </mrow>    </mrow>   </mrow>   <mo>)</mo>  </mrow>  <mo>,</mo> </mrow></math></maths><ul id="ul0006" list-style="none">    <li id="ul0006-0001" num="0000">    <ul id="ul0007" list-style="none">        <li id="ul0007-0001" num="0000">        <ul id="ul0008" list-style="none">            <li id="ul0008-0001" num="0000">&#x2003;where |&#x3b6;(i)| is the number of the R-nearest neighbors of &#x2207;(i) belonging to the same cluster and &#x3bb; is a parameter controlling the regularity of the produced patches. Note that the parameters &#x3bb; and R may be defined by the user or may be determined by applying an optimization procedure. They may also be fixed or adaptive. In some embodiments, a &#x201c;user&#x201d; as referred to herein may be an engineer who configured a point cloud compression technique as described herein to one or more applications.</li>            <li id="ul0008-0002" num="0110">3. An example of pseudo code is provided below</li>        </ul>        </li>    </ul>    </li></ul></p><p id="p-0106" num="0000"><tables id="TABLE-US-00002" num="00002"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="42pt" align="left"/><colspec colname="2" colwidth="175pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;</entry><entry>for(1 = 0; 1 &#x3c; iterationCount; ++1) {</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;for(i = 0; i &#x3c; pointCount; ++i) {</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;clusterIndex = partition[i];</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;bestScore = 0.0;</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;for(k = 0; k &#x3c; K; ++k) {</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;score = <img id="CUSTOM-CHARACTER-00008" he="2.46mm" wi="1.10mm" file="US20230005188A1-20230105-P00005.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;&#x2207;(I)|D(k)&#x2009;<img id="CUSTOM-CHARACTER-00009" he="2.46mm" wi="1.10mm" file="US20230005188A1-20230105-P00006.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;;</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;for(j &#x2208; {j(0), j(1), . . . , j(R &#x2212; 1 )}) {</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if (k == partition [j]) {</entry></row><row><entry> </entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;<maths id="MATH-US-00002" num="00002"><math overflow="scroll"> <mrow>  <mrow>   <mi>score</mi>   <mtext>   </mtext>   <mo>+=</mo>   <mtext>   </mtext>   <mfrac>    <mi>&#x3bb;</mi>    <mi>R</mi>   </mfrac>  </mrow>  <mo>;</mo> </mrow></math></maths></entry></row><row><entry> </entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;}</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;if (score &#x3e; bestScore) {</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;bestScore = score;</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;clusterIndex = k;</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;}</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;partition[i] = clusterIndex;</entry></row><row><entry/><entry>&#x2003;&#x2003;}</entry></row><row><entry/><entry>&#x2003;}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry namest="1" nameend="2" align="left" id="FOO-00001">*In some embodiments, the pseudo code shown above may further include an early termination step. For example, if a score that is a particular value is reached, or if a difference between a score that is reached and a best score only changes by a certain amount or less, the search could be terminated early. Also, the search could be terminated if after a certain number of iterations (l = m), the clusterindex does not change.</entry></row></tbody></tgroup></table></tables><ul id="ul0009" list-style="none">    <li id="ul0009-0001" num="0000">    <ul id="ul0010" list-style="none">        <li id="ul0010-0001" num="0111">Patch segmentation: In some embodiments, the patch segmentation procedure further segments the clusters detected in the previous steps into patches, which may be represented with a depth field with respect to a projection plane. The approach proceeds as follows, according to some embodiments:        <ul id="ul0011" list-style="none">            <li id="ul0011-0001" num="0112">1. First, a cluster-based adjacency graph with a number of neighbors R&#x2032; is built, while considering as neighbors only the points that belong to the same cluster. Note that R&#x2032; may be different from the number of neighbors R used in the previous steps.</li>            <li id="ul0011-0002" num="0113">2. Next, the different connected components of the cluster-based adjacency graph are extracted. Only connected components with a number of points higher than a parameter &#x3b1; are considered. Let CC={CC(0), CC(1), . . . , CC(M&#x2212;1)} be the set of the extracted connected components.</li>            <li id="ul0011-0003" num="0114">3. Respective connected component CC(m) inherits the orientation D(m) of the cluster it belongs to. The points of CC(m) are then projected on a projection plane having as normal the orientation D(m), while updating a depth map, which records for every pixel the depth of the nearest point to the projection plane.</li>            <li id="ul0011-0004" num="0115">4. An approximated version of CC(m), denoted C&#x2032;(m), is then built by associating respective updated pixels of the depth map with a 3D point having the same depth. Let PC&#x2032; be the point cloud obtained by the union of reconstructed connected components {CC&#x2032;(0), CC&#x2032;(1), . . . , CC&#x2032;(M&#x2212;1)}</li>            <li id="ul0011-0005" num="0116">5. Note that the projection reconstruction process may be lossy and some points may be missing. In order, to detect such points, every point P(i) of point cloud PC may be checked to make sure it is within a distance lower than a parameter &#x3b4; from a point of PC&#x2032;. If this is not the case, then P(i) may be marked as a missed point and added to a set of missed points denoted MP.</li>            <li id="ul0011-0006" num="0117">6. The steps 2-5 are then applied to the missed points MP. The process is repeated until MP is empty or CC is empty. Note that the parameters &#x3b4; and &#x3b1; may be defined by the user or may be determined by applying an optimization procedure. They may also be fixed or adaptive.</li>            <li id="ul0011-0007" num="0118">7. A filtering procedure may be applied to the detected patches in order to make them better suited for compression. Example filter procedures may include:            <ul id="ul0012" list-style="none">                <li id="ul0012-0001" num="0119">a. A smoothing filter based on the geometry/texture/attributes of the points of the patches (e.g., median filtering), which takes into account both spatial and temporal aspects.</li>                <li id="ul0012-0002" num="0120">b. Discarding small and isolated patches.</li>                <li id="ul0012-0003" num="0121">c. User-guided filtering.</li>                <li id="ul0012-0004" num="0122">d. Other suitable smoothing filter techniques.</li>            </ul>            </li>        </ul>        </li>    </ul>    </li></ul></p><heading id="h-0014" level="2">Depth/Geometry Patch Images</heading><p id="p-0107" num="0123">In some embodiments, an encoder, such as any of the encoders described herein may follow a depth/geometry image generation process to generate a depth/geometry image for a patch of a point cloud, wherein the relative placement of a point in the depth/geometry image indicates its location in a projection plane upon which a segment of a point cloud is being projected. Additionally, an attribute of the point in the depth/geometry image may indicate a depth value of the point in a direction perpendicular to the projection plane.</p><p id="p-0108" num="0124">For example, if a coordinate system for a depth/geometry image is referenced to the projection plane, horizontal and vertical locations of a point in the depth/geometry image may indicate horizontal and vertical positions of the point of the point cloud being projected onto the projection plane in the projection plane. Additionally, a depth of the point in a direction normal to the projection plane may be indicated by an attribute value of the point in the depth/geometry image, such as a color value of a pixel located at the horizontal and vertical position of the point projected onto the projection plane, wherein horizontal and vertical positions of the point in the depth/geometry image correspond to the horizontal and vertical positions of the point in the projection plane. Said another way, a depth of the point in a normal direction, normal to the projection plane, may indicate a depth of the point relative to the projection plane, and a tangential position of the point in the depth/geometry image may correspond to a horizontal-position of the point on a surface of the projection plane, wherein a bi-tangential position of the point in the depth/geometry image may correspond to a vertical-position of the point on a surface of the projection plane.</p><p id="p-0109" num="0125">In some embodiments, when a depth/geometry image is generated, a minimum depth value for each patch may be evaluated. When pixel values (e.g. color values) are determined for the points (e.g. pixels) included in the depth/geometry image, the minimum depth value may be subtracted from the depth values of the points (wherein the depths are depths in a direction normal to the projection plane). This may reduce a range of pixel values included in a packed image frame that is packed with multiple depth/geometry images. Also, reducing the range of pixel values may improve compression efficiency. Also, in some embodiments, a maximum depth value for each patch may be evaluated.</p><p id="p-0110" num="0126">In some embodiments, geometry/depth images may be packed into a 2D image frame as described above. Also, in some embodiments, minimum and/or maximum depth values for respective patches may be signaled with auxiliary patch information such as the size of the patches, projection relationship from 3D space to 2D space, location in 2D space, etc. This auxiliary information, including minimum and/or maximum depth values for patches may be encoded using a combination of fixed length and/or variable length coding, e.g. UVLC or binary arithmetic encoding.</p><p id="p-0111" num="0127">Note that minimum depth values are used as an alternative to encoding absolute depth values for points of a patch. For example, if a minimum depth point in a patch has a nominal depth value of &#x201c;100&#x201d; and other points in the patch have nominal depth values that range from 101-120, the points may be encoded with depth values ranging from 1-20 and a minimum depth value for the patch may be assigned as 100. Thus, a decoder may add the encoded depth values that range from 1-20 to the minimum depth value of 100 to determine the actual depth values for the points. In a similar manner, when encoding the patch, the encoder may subtract the minimum depth values of the points of the patch before encoding the corresponding depth values for the points, wherein the encoded depth values are equal to the absolute depth values minus the minimum depth value for the patch. This approach may reduce the dynamic range of the geometry signals and thus enable encoding of geometry signals with a bitdepth constrained codec.</p><p id="p-0112" num="0128">In some embodiments, a depth value for a point of a patch may be defined as</p><p id="p-0113" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>I</i><sub>i</sub>(<i>u,v</i>)=<i>d. </i><?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0114" num="0129">In the above equation the depth value (which may be an intensity of a pixel color in a geometry image) is represented by Ii, where the subscript i ranges from 1 to the number of points included in the patch. In the above equation, u is the tangential value of the point and v is the bi-tangential value. Also, in the above equation, d is the distance of the point in the normal direction from the projection plane. Thus the minim depth value is the smallest d value for the points of the patch. For example the minimum depth value is given by:</p><p id="p-0115" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>minDepth=min(<i>Ii</i>)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0116" num="0000">where Ii is the set of pixel values in the patch.</p><p id="p-0117" num="0130">Thus for the patch, the encoded depth values I&#x2032;(u,v) are the depth values d minus the minDepth. For example:</p><p id="p-0118" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>I</i>(<i>u,v</i>)=<i>d</i>&#x2212;MinDepth<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0119" num="0131">In some embodiments, minimum depth values may be determined independently for each patch. However, this approach may result in varying minimum depths for depth/geometry images resulting from similarly situated projection planes and may result in varying minimum depths being used for different depth/geometry images that are all packed into the same image frame.</p><p id="p-0120" num="0132">In some embodiments, to further improve compression efficiency, minimum depth values and/or maximum depth values may be quantized. This may limit fluctuations between minimum depth values (or maximum depth values) used for depth/geometry images resulting from similar situated projection planes and for minimum depths (or maximum depths) used for different depth/geometry images that are all packed into the same image frame. For example, the minimum depth may be quantized into minimum depth intervals N. Similar depth intervals may also be used for maximum values. For the minimum depth values, the minimum depth intervals may be defined as:</p><p id="p-0121" num="0000"><maths id="MATH-US-00003" num="00003"><math overflow="scroll"> <mrow>  <mi>quantizedMinDepth</mi>  <mo>=</mo>  <mrow>   <mi>m</mi>   <mo>&#xd7;</mo>   <mi>N</mi>  </mrow> </mrow></math></maths><maths id="MATH-US-00003-2" num="00003.2"><math overflow="scroll"> <mrow>  <mrow>   <mi>where</mi>   <mo>:</mo>   <mi>m</mi>  </mrow>  <mo>=</mo>  <mrow>   <mi>floor</mi>   <mo>&#x2062;</mo>   <mtext>   </mtext>   <mrow>    <mo>(</mo>    <mfrac>     <mrow>      <mi>min</mi>      <mo>&#x2061;</mo>      <mo>(</mo>      <mrow>       <mi>I</mi>       <mo>&#x2062;</mo>       <mi>i</mi>      </mrow>      <mo>)</mo>     </mrow>     <mi>N</mi>    </mfrac>    <mo>)</mo>   </mrow>  </mrow> </mrow></math></maths></p><heading id="h-0015" level="2">Uniform Quantization</heading><p id="p-0122" num="0133">For example, for a particular minimum depth value and assuming a first bit level representation (e.g. F bit representation) of the original minimum depth values (in the range of 0 to 2{circumflex over (&#x2003;)}F&#x2212;1) and the possibility of up to G bits for the quantized representation of the particular minimum depth value, the minimum depth value x may be quantized into a quantized representation of the minimum depth value x (e.g. Q_x) using the following equation:</p><p id="p-0123" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>Q</i>_<i>x</i>=max(0,floor((<i>x*</i>2{circumflex over (&#x2003;)}<i>G</i>+(2{circumflex over (&#x2003;)}<i>G</i>)&#x2212;2)/(2{circumflex over (&#x2003;)}<i>F&#x2212;</i>1))&#x2212;1)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0124" num="0134">For example, <figref idref="DRAWINGS">FIG. <b>3</b>J</figref> shows a graph of minimum depth intervals N when quantizing minimum depth values from a F bit representation to a G bit representation (where F=8 and G=4, as examples). In the Figure, the numbers along the X-axis are non-quantized minimum depth representations in a F bit representation and the numbers along the Y-axis are the quantized minimum depth representation in a G bit representation. For example, the graph shown in <figref idref="DRAWINGS">FIG. <b>3</b>J</figref> may be a graphical representation of the equation for Q_x above, wherein the equation for Q_x represents a transfer function that transforms a non-quantized minimum depth value into a quantized minimum depth value. As discussed in more detail below, in some embodiments, maximum depth values may also be quantized, and the transfer function represented by the equation for Q_x could also be used to determine quantized maximum depth values. For maximum depth values, reconstructed maximum depth values (for example values reconstructed at a decoder using the quantized maximum depth values generated as described above) may be computed as:</p><p id="p-0125" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>Recon_<i>x</i>=floor((<i>Q</i>_<i>x+</i>1)*(2{circumflex over (&#x2003;)}<i>F&#x2212;</i>1)/2{circumflex over (&#x2003;)}<i>G</i>)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0126" num="0135">Also, for minimum depth values, reconstructed minimum depth values (for example values reconstructed at a decoder using the quantized minimum depth values generated as described above) may be computed as:</p><p id="p-0127" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>Recon_<i>x</i>=floor(<i>Q</i>_<i>x</i>*(2{circumflex over (&#x2003;)}<i>F&#x2212;</i>1)/2{circumflex over (&#x2003;)}<i>G</i>)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0128" num="0136">Note the difference between the equations for determining the reconstructed minimum depth values and the reconstructed maximum depth values. They differ because it is desirable to capture the zero value as a lower bound for the minimum depth minimum depth limit, while it is desirable to capture the value of 2{circumflex over (&#x2003;)}F&#x2212;1 for the maximum depth limit. Also, note that the signaled quantized value using the above equation to determine Q_x would not result in a quantized value equal to zero (even though zero may be determined during reconstruction), but would instead map to the value of 2&#x2003;G&#x2212;1.</p><heading id="h-0016" level="2">Zero Biased Quantization</heading><p id="p-0129" num="0137">In some embodiments, it may be desirable to signal the value of 0 for the maximum depth. This may be the case if all depth values in a patch are equal to zero. In such a circumstance, the following transfer function may be used to determine quantized minimum or maximum depth values. The formula assigns 0 only to values of x=0 and uses uniform quantization for other cases. The formula is:</p><p id="p-0130" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>Q</i>_<i>x</i>=max(0,floor((<i>x</i>*(2{circumflex over (&#x2003;)}<i>G&#x2212;</i>1)+(2{circumflex over (&#x2003;)}<i>F</i>)&#x2212;2)/(2{circumflex over (&#x2003;)}<i>F&#x2212;</i>1)))<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0131" num="0138">In the above formula, there will be one quantized value assigned to zero and the remaining 2{circumflex over (&#x2003;)}G&#x2212;1 quantized values are assigned uniformly to all other values greater than zero. For example, <figref idref="DRAWINGS">FIG. <b>3</b>K</figref> shows a graph of minimum depth intervals N when quantizing minimum depth values from a F bit representation to a G bit representation using the above formula (where F=8 and G=4, as examples). In the Figure, the numbers along the X-axis are non-quantized minimum depth representations in a F bit representation and the numbers along the Y-axis are the quantized minimum depth representation in a G bit representation. For example, the graph shown in <figref idref="DRAWINGS">FIG. <b>3</b>K</figref> may be a graphical representation of the zero biased equation for Q_x above, wherein the zero biased equation for Q_x represents a transfer function that transforms a non-quantized minimum depth value into a quantized minimum depth value. As discussed in more detail below, in some embodiments, maximum depth values may also be quantized, and the transfer function represented by the zero biased equation for Q_x could also be used to determine quantized maximum depth values. For minimum or maximum depth values, reconstructed depth values (for example values reconstructed at a decoder using the quantized maximum depth values generated as described above) may be computed as:</p><p id="p-0132" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>Recon_<i>x</i>=floor((<i>Q</i>_<i>x</i>*(2{circumflex over (&#x2003;)}<i>F&#x2212;</i>1)/(2{circumflex over (&#x2003;)}<i>G&#x2212;</i>1))<?in-line-formulae description="In-line Formulae" end="tail"?></p><heading id="h-0017" level="2">Non-Uniform Quantization</heading><p id="p-0133" num="0139">In some embodiments, a logarithmic quantization could be used. For example:</p><p id="p-0134" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>Q</i>_<i>x</i>=min(2{circumflex over (&#x2003;)}<i>G&#x2212;</i>1,round(log 2(round(<i>x</i>/(2{circumflex over (&#x2003;)}<i>F&#x2212;</i>1)*255)+1))*2{circumflex over (&#x2003;)}(<i>G&#x2212;</i>3))<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0135" num="0140">Use of the above equation also results in an interval or bin for the zero case (0). However, the above equation uses non-uniform spacing for all other intervals or bins. The use of the above equation may be beneficial to take advantage of dynamic range characteristics of depth signals. For example, depth signals may not be uniformly concentrated, but may instead be closer to a particular value, such as the zero value. In some embodiments, other non-uniform quantization processes may be used that exploit characteristics of the depth signals.</p><heading id="h-0018" level="2">Implicit or Explicit Signaling of Quantization/Dequantization Transfer Values</heading><p id="p-0136" num="0141">In some embodiments, an implicit signaling of quantization/dequantization values may be used. For example, fixed values known by a decoder and encoder may be used (or may be mapped to) based on signal parameters. For example, a mapping may be predicted at the encoder and decoder and known by both the encoder and decoder. In some embodiments, explicit signaling of quantization/dequantization values may be used. For example, quantization/dequantization values may signaled at a high level syntax structure of the bit stream. For example at SPS (sequence parameter set), PPS (picture parameter set), or at the header of the patch information. In such cases, the explicitly signaled quantization/dequantization values may be used for all patches that belong to a structure for which the values were signaled. In some embodiments, additionally, lower level signaling may be used to override the higher level signaling for particular patches. In some embodiments, the presence of lower level signaling may be indicated using flags.</p><p id="p-0137" num="0142">Also, in some embodiments, the quantized minimum depth (or maximum depth) for a patch may further be calculated with an offset. For example, an offset may move the depth values of the patch closer to a center range of depths. For example, in the example of a point cloud of a person, a patch may cover an extended hand of the person. If the person were to wave her hand, points at an outer depth range may exceed the range if the hand were to wave such that it was at a greater depth. Thus, in addition to a minimum depth value, an offset may be used to move the depth values of the hand closer into a supported depth value range. Because the offset is included in the minimum depth, the offset may be subtracted from the absolute depth at the encoder and added to the modified depths at the decoder to result in the absolute depth. For example:</p><p id="p-0138" num="0000"><maths id="MATH-US-00004" num="00004"><math overflow="scroll"> <mrow>  <mrow>   <mi>quantizedMinDept</mi>   <mo>&#x2062;</mo>   <mi>h</mi>  </mrow>  <mo>=</mo>  <mrow>   <mfrac>    <mrow>     <mrow>      <mi>valu</mi>      <mo>&#x2062;</mo>      <mi>e</mi>     </mrow>     <mo>+</mo>     <mi>offset</mi>    </mrow>    <mi>N</mi>   </mfrac>   <mo>&#xd7;</mo>   <mi>N</mi>  </mrow> </mrow></math></maths></p><p id="p-0139" num="0143">In the above equation, the offset can be fixed or adaptive. In the adaptive case it could be computed based on the spatial or temporal relationship of the current patch with other patches.</p><p id="p-0140" num="0144">In some embodiments, a maximum geometry value (e.g. a maximum depth as discussed above) for an encoded depth may limit the encoded depth value I&#x2032;. For example, when the maximum depth is maxDepth=maxGeometryValue, where MaxGeometryValue=2{circumflex over (&#x2003;)}bitdepth&#x2212;1, and where bitdepth is the maximum bitdepth supported by the codec. In some embodiments, the max depth may be set to be smaller than the maximum bitdepth or geometry value. Thus in some embodiments, the pixel values can be given by:</p><p id="p-0141" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>I</i>(<i>u,v</i>)=<i>d</i>&#x2212;quantMinDepth if(<i>d</i>&#x2212;quantMinDepth&#x2264;max Geometry Value,<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0142" num="0000">Otherwise=the point is discarded, e.g. the pixel is set to equal 0</p><p id="p-0143" num="0145">In some embodiments, a maximum bitsize required to signal the minimum depths in a frame is signaled and then the minimum depth of each patch is signaled by the bitsize.</p><p id="p-0144" num="0146">In some embodiments, when the quantized minimum depth is used, the bitsize is less than when actual minimum depth is signaled. Specifically, if the quantization level (N) is 2 k, the required bits to signal the minDepth value is M&#x2212;k when the bitdepth of geometry data is M bit. If it is detected that for a particular frame the required bits do not exceed L bits, with L&#x3c;M, the number of bits needed for coding the minimum depth signal could also be encoded. Alternatively, the minDepth information could also be entropy encoded, e.g. using Exp-Golomb codes or Arithmetically encoded. In that case, encoding could start from zero, but could also be centered around a middle value, in which case that middle value would also have to be encoded in the stream. Such values could be signaled at the sequence level, frame level, or even at a per group of patches level.</p><p id="p-0145" num="0147">In some embodiments, the quantization level (N) can be signaled per Group of Frames, per sequence or per frame. In other embodiment, it can be signaled per groups of patches.</p><p id="p-0146" num="0148">In some embodiments, the quantization level can be signaled absolutely or can be predicted from previous patches. Previous patches may include patches in the same frame that have already been decoded, but could also include patches in previously decoded frames, assuming that some correspondence between patches in time has been defined.</p><p id="p-0147" num="0149">In some embodiments, no maximum depth information may be signaled for each patch. This may bound the geometry on the low end but leaves the geometry unbounded and unprotected on the high values of the geometry. For example, a geometry signal that may have been originally in the range of [0, 20], after the subtraction of the minimumDepth, after processing and encoding could be altered and go in a different range of [a,b]. Although it is guaranteed that a&#x3e;=0, there is no guarantee that b&#x3c;=20. That could potentially create considerable artifacts in the depth representation after decoding. Thus in some embodiments, a maximum depth may be signaled to avoid such issues. For example, the maximum depth that is present in each patch may be signaled as metadata that is included in the auxiliary/patch information signal, as is done with the minimum depth per patch information.</p><p id="p-0148" num="0150">This information could be coded as an absolute value, but since the value of the minimum depth is already known, an alternative method would be to encode the delta value between minimum and maximum depth, e.g. deltaMinMaxDepth. This value could then be used to &#x201c;clip&#x201d; the depth information for each patch during reconstruction of the point cloud signal.</p><p id="p-0149" num="0151">In the case that quantization is used for the minDepth, there are multiple options of how to encode the maximum Depth value. Again, this could be signaled in absolute terms, in which case maximum depth may be quantized as well (for example as discussed above). However in this case, the upper bound may be selected to avoid &#x201c;overclipping&#x201d; of the depth data. Quantization could use the same quantizer as that used for the minimum, but given the different dynamic range of minimum and maximum, a different quantizer, could be used. The quantizers could also be related, e.g. Nmax=Nmin+quant_offset, where quant_offset could be fixed (e.g. equal to 1), or signaled at a certain level (e.g. sequence, frame, or group of patches). If quantized, the quantized maximum depth would need to be dequantized in order to clip the reconstructed geometry signal.</p><p id="p-0150" num="0152">This information could also be delta encoded given the minimum depth. There are a variety of options, such as taking the maximum depth, first quantizing it using the same quantization step size as that used for the minimum depth, and then encoding the difference, or, dequantizing the minimum depth, subtracting this value from the maximum depth and either encoding this value directly or quantizing this value with the same or some other quantizer. If another quantizer is used, again such quantizer could be signaled or could also be related, e.g. Nmax=Nmin+quant_offset, where quant_offset could be fixed (e.g. equal to 1), or signaled at a certain level (e.g. sequence, frame, or group of patches). Encoding of this information could be performed using fix length encoding or some entropy coding method, e.g. Exp-Golomb, arithmetic encoding etc. If quantized, the quantized maximum delta depth would need to be dequantized in order to determine the maximum depth that would be used when clipping the reconstructed geometry signal.</p><p id="p-0151" num="0153">The method used for the signaling of max depth could be fixed for the entire sequence, or could be switchable given some flag or parameter across two or more different methods, as discussed herein, at the sequence, frame, or group of patches.</p><p id="p-0152" num="0154">The maximum depth and/or its quantization level can be also predicted from previously decoded patches. Previously decoded patches may include patches in the same frame that have already been decoded, but could also include patches in previously decoded frames, assuming that some correspondence between patches in time has been defined.</p><p id="p-0153" num="0155">In some embodiments, when the maximum depth is equal to zero, all the values in the patch have one same value equal to the minimum depth. In this case, the patch does not need to be included into the geometry image. Instead, the occupancy information may be sufficient at both the encoder and decoder to permit the full reconstruction of the patch. In this case, and for this patch, the values in the geometry image can be ignored and any information that is better in terms of video compression may be inserted in place of the values in the geometry image. In some embodiments, the maximum depth of a patch may be decided to be zero at the encoder side as a part of the optimization process.</p><p id="p-0154" num="0156">In some embodiments, a minimum depth, or a maximum depth, could be coded directly without quantization. In some embodiments, a minimum depth and delta maximum could be encoded, wherein the delta maximum is equal to the maximum depth minus the minimum depth (but in this case the delta maximum is encoded instead of encoding the actual maximum depth).</p><heading id="h-0019" level="2">Layers</heading><p id="p-0155" num="0157">The image generation process described above consists of projecting the points belonging to each patch onto its associated projection plane to generate a patch image. This process could be generalized to handle the situation where multiple points are projected onto the same pixel as follows:<ul id="ul0013" list-style="none">    <li id="ul0013-0001" num="0000">    <ul id="ul0014" list-style="none">        <li id="ul0014-0001" num="0158">Let H(u,v) be the set of points of the current patch that get projected to the same pixel (u,v). Note that H(u,v) may be empty, may have one point or multiple points.</li>        <li id="ul0014-0002" num="0159">If H(u,v) is empty then the pixel is marked as unoccupied.</li>        <li id="ul0014-0003" num="0160">If the H(u,v) has a single element, then the pixel is filled with the associated geometry/texture/attribute value.</li>        <li id="ul0014-0004" num="0161">If H(u,v), has multiple elements, then different strategies are possible:        <ul id="ul0015" list-style="none">            <li id="ul0015-0001" num="0162">Keep only the nearest point P0(u,v) for the pixel (u,v)</li>            <li id="ul0015-0002" num="0163">Take the average or a linear combination of a group of points that are within a distance d from P0(u,v), where d is a user-defined parameter needed only on the encoder side.</li>            <li id="ul0015-0003" num="0164">Store two images: one for P0(u,v) and one to store the furthest point P1(u,v) of H(u,v) that is within a distance d from P0(u,v)</li>            <li id="ul0015-0004" num="0165">Store N patch images containing a subset of H(u,v)</li>        </ul>        </li>    </ul>    </li></ul></p><p id="p-0156" num="0166">The generated patch images for point clouds with points at the same patch location, but different depths may be referred to as layers herein. In some embodiments, scaling/up-sampling/down-sampling could be applied to the produced patch images/layers in order to control the number of points in the reconstructed point cloud.</p><p id="p-0157" num="0167">Guided up-sampling strategies may be performed on the layers that were down-sampled given the full resolution image from another &#x201c;primary&#x201d; layer that was not down-sampled.</p><p id="p-0158" num="0168">Down-sampling could leverage the closed loop techniques as described below in regard to closed-loop color conversion, while exploiting a guided up-sampling strategy. For example, a generated layer may be encoded independently, which allows for parallel decoding and error resilience. Also encoding strategies, such as those specified by the scalable-HEVC standard, may be leveraged in order to support advanced functionalities such as spatial, SNR (signal to noise ratio), and color gamut scalability.</p><p id="p-0159" num="0169">In some embodiments, a delta prediction between layers could be adaptively applied based on a rate-distortion optimization. This choice may be explicitly signaled in the bit stream.</p><p id="p-0160" num="0170">In some embodiments, the generated layers may be encoded with different precisions. The precision of each layer may be adaptively controlled by using a shift+scale or a more general linear or non-linear transformation.</p><p id="p-0161" num="0171">In some embodiments, an encoder may make decisions on a scaling strategy and parameters, which are explicitly encoded in the bit stream. The decoder may read the information from the bit stream and apply the right scaling process with the parameters signaled by the encoder.</p><p id="p-0162" num="0172">In some embodiments, a video encoding motion estimation process may be guided by providing a motion vector map to the video encoder indicating for each block of the image frame, a 2D search center or motion vector candidates for the refinement search. Such information, may be trivial to compute since the mapping between the 3D frames and the 2D image frames is available to the point cloud encoder and a coarse mapping between the 2D image frames could be computed by using a nearest neighbor search in 3D.</p><p id="p-0163" num="0173">The video motion estimation/mode decision/intra-prediction could be accelerated/improved by providing a search center map, which may provide guidance on where to search and which modes to choose from for each N&#xd7;N pixel block.</p><p id="p-0164" num="0174">Hidden/non-displayed pictures could be used in codecs such as AV1 and HEVC. In particular, synthesized patches could be created and encoded (but not displayed) in order to improve prediction efficiency. This could be achieved by re-using a subset of the padded pixels to store synthesized patches.</p><p id="p-0165" num="0175">The patch re-sampling (e.g., packing and patch segmentation) process described above exploits solely the geometry information. A more comprehensive approach may take into account the distortions in terms of geometry, texture, and other attributes and may improve the quality of the re-sampled point clouds.</p><p id="p-0166" num="0176">Instead of first deriving the geometry image and optimizing the texture image given said geometry, a joint optimization of geometry and texture could be performed. For example, the geometry patches could be selected in a manner that results in minimum distortion for both geometry and texture. This could be done by immediately associating each possible geometry patch with its corresponding texture patch and computing their corresponding distortion information. Rate-distortion optimization could also be considered if the target compression ratio is known.</p><p id="p-0167" num="0177">In some embodiments, a point cloud resampling process described above may additionally consider texture and attributes information, instead of relying only on geometry.</p><p id="p-0168" num="0178">Also, a projection-based transformation that maps 3D points to 2D pixels could be generalized to support arbitrary 3D to 2D mapping as follows:<ul id="ul0016" list-style="none">    <li id="ul0016-0001" num="0000">    <ul id="ul0017" list-style="none">        <li id="ul0017-0001" num="0179">Store the 3D to 2D transform parameters or the pixel coordinates associated with each point</li>        <li id="ul0017-0002" num="0180">Store X, Y, Z coordinates in the geometry images instead of or in addition to the depth information</li>    </ul>    </li></ul></p><heading id="h-0020" level="2">Packing</heading><p id="p-0169" num="0181">In some embodiments, depth maps associated with patches, also referred to herein as &#x201c;depth patch images&#x201d; or &#x201c;geometry patch images,&#x201d; such as those described above, may be packed into a 2D image frame. For example, a packing module, such as packing module <b>208</b>, may pack depth patch images generated by a spatial image generation module, such as spatial image generation module <b>210</b>. The depth maps, or depth patch images, may be packed such that (A) no non-overlapping block of T&#xd7;T pixels contains depth information from two different patches and such that (B) a size of the generated image frame is minimized.</p><p id="p-0170" num="0182">In some embodiments, packing comprises the following steps:<ul id="ul0018" list-style="none">    <li id="ul0018-0001" num="0000">    <ul id="ul0019" list-style="none">        <li id="ul0019-0001" num="0183">a. The patches are sorted by height and then by width. The patches are then inserted in image frame (I) one after the other in that order. At each step, the pixels of image frame (I) are traversed in raster order, while checking if the current patch could be inserted under the two conditions (A) and (B) described above. If it is not possible then the height of (I) is doubled.</li>        <li id="ul0019-0002" num="0184">b. This process is iterated until all the patches are inserted.</li>    </ul>    </li></ul></p><p id="p-0171" num="0185">In some embodiments, the packing process described above may be applied to pack a subset of the patches inside multiples tiles of an image frame or multiple image frames. This may allow patches with similar/close orientations based on visibility according to the rendering camera position to be stored in the same image frame/tile, to enable view-dependent streaming and/or decoding. This may also allow parallel encoding/decoding.</p><p id="p-0172" num="0186">In some embodiments, the packing process can be considered a bin-packing problem and a first decreasing strategy as described above may be applied to solve the bin-packing problem. In other embodiments, other methods such as the modified first fit decreasing (MFFD) strategy may be applied in the packing process.</p><p id="p-0173" num="0187">In some embodiments, if temporal prediction is used, such as described for inter compression encoder <b>250</b>, such an optimization may be performed with temporal prediction/encoding in addition to spatial prediction/encoding. Such consideration may be made for the entire video sequence or per group of pictures (GOP). In the latter case additional constraints may be specified. For example, a constraint may be that the resolution of the image frames should not exceed a threshold amount. In some embodiments, additional temporal constraints may be imposed, even if temporal prediction is not used, for example such as that a patch corresponding to a particular object view is not moved more than x number of pixels from previous instantiations.</p><p id="p-0174" num="0188"><figref idref="DRAWINGS">FIG. <b>3</b>B</figref> illustrates an example image frame comprising packed patch images and padded portions, according to some embodiments. Image frame <b>300</b> includes patch images <b>302</b> packed into image frame <b>300</b> and also includes padding <b>304</b> in space of image frame <b>300</b> not occupied by patch images. In some embodiments, padding, such as padding <b>304</b>, may be determined so as to minimize incongruences between a patch image and the padding. For example, in some embodiments, padding may construct new pixel blocks that are replicas of, or are to some degree similar to, pixel blocks that are on the edges of patch images. Because an image and/or video encoder may encode based on differences between adjacent pixels, such an approach may reduce the number of bytes required to encode an image frame comprising of patch images and padding, in some embodiments.</p><p id="p-0175" num="0189">In some embodiments, the patch information may be stored in the same order as the order used during the packing, which makes it possible to handle overlapping 2D bounding boxes of patches. Thus a decoder receiving the patch information can extract patch images from the image frame in the same order in which the patch images were packed into the image frame. Also, because the order is known by the decoder, the decoder can resolve patch image bounding boxes that overlap.</p><p id="p-0176" num="0190"><figref idref="DRAWINGS">FIG. <b>3</b>C</figref> illustrates an example image frame <b>312</b> with overlapping patches, according to some embodiments. <figref idref="DRAWINGS">FIG. <b>3</b>C</figref> shows an example with two patches (patch image <b>1</b> and patch image <b>2</b>) having overlapping 2D bounding boxes <b>314</b> and <b>316</b> that overlap at area <b>318</b>. In order to determine to which patch the T&#xd7;T blocks in the area <b>318</b> belong, the order of the patches may be considered. For example, the T&#xd7;T block <b>314</b> may belong to the last decoded patch. This may be because in the case of an overlapping patch, a later placed patch is placed such that it overlaps with a previously placed patch. By knowing the placement order it can be resolved that areas of overlapping bounding boxes go with the latest placed patch. In some embodiments, the patch information is predicted and encoded (e.g., with an entropy/arithmetic encoder). Also, in some embodiments, U0, V0, DU0 and DV0 are encoded as multiples of T, where T is the block size used during the padding phase.</p><p id="p-0177" num="0191"><figref idref="DRAWINGS">FIG. <b>3</b>C</figref> also illustrates blocks of an image frame <b>312</b>, wherein the blocks may be further divided into sub-blocks. For example block A1, B1, C1, A2, etc. may be divided into multiple sub-blocks, and, in some embodiments, the sub-blocks may be further divided into smaller blocks. In some embodiments, a video compression module of an encoder, such as video compression module <b>218</b> or video compression module <b>264</b>, may determine whether a block comprises active pixels, non-active pixels, or a mix of active and non-active pixels. The video compression module may budget fewer resources to compress blocks comprising non-active pixels than an amount of resources that are budgeted for encoding blocks comprising active pixels. In some embodiments, active pixels may be pixels that include data for a patch image and non-active pixels may be pixels that include padding. In some embodiments, a video compression module may sub-divide blocks comprising both active and non-active pixels, and budget resources based on whether sub-blocks of the blocks comprise active or non-active pixels. For example, blocks A1, B1, C1, A2 may comprise non-active pixels. As another example block E3 may comprise active pixels, and block B6, as an example, may include a mix of active and non-active pixels.</p><p id="p-0178" num="0192">In some embodiments, a patch image may be determined based on projections, such as projecting a point cloud onto a cube, cylinder, sphere, etc. In some embodiments, a patch image may comprise a projection that occupies a full image frame without padding. For example, in a cubic projection each of the six cubic faces may be a patch image that occupies a full image frame.</p><p id="p-0179" num="0193">For example, <figref idref="DRAWINGS">FIG. <b>3</b>D</figref> illustrates a point cloud being projected onto multiple projections, according to some embodiments.</p><p id="p-0180" num="0194">In some embodiments, a representation of a point cloud is encoded using multiple projections. For example, instead of determining patches for a segment of the point cloud projected on a plane perpendicular to a normal to the segment, the point cloud may be projected onto multiple arbitrary planes or surfaces. For example, a point cloud may be projected onto the sides of a cube, cylinder, sphere, etc. Also multiple projections intersecting a point cloud may be used. In some embodiments, the projections may be encoded using conventional video compression methods, such as via a video compression module <b>218</b> or video compression module <b>264</b>. In particular, the point cloud representation may be first projected onto a shape, such as a cube, and the different projections/faces projected onto that shape (i.e. front (<b>320</b>), back (<b>322</b>), top (<b>324</b>), bottom (<b>326</b>), left (<b>328</b>), right (<b>330</b>)) may all be packed onto a single image frame or multiple image frames. This information, as well as depth information may be encoded separately or with coding tools such as the ones provided in the 3D extension of the HEVC (3D-HEVC) standard. The information may provide a representation of the point cloud since the projection images can provide the (x,y) geometry coordinates of all projected points of the point cloud. Additionally, depth information that provides the z coordinates may be encoded. In some embodiments, the depth information may be determined by comparing different ones of the projections, slicing through the point cloud at different depths. When projecting a point cloud onto a cube, the projections might not cover all point cloud points, e.g. due to occlusions. Therefore additional information may be encoded to provide for these missing points and updates may be provided for the missing points.</p><p id="p-0181" num="0195">In some embodiments, adjustments to a cubic projection can be performed that further improve upon such projections. For example, adjustments may be applied at the encoder only (non-normative) or applied to both the encoder and the decoder (normative).</p><p id="p-0182" num="0196">More specifically, in some embodiments alternative projections may be used. For example, instead of using a cubic projection, a cylindrical or spherical type of a projection method may be used. Such methods may reduce, if not eliminate, redundancies that may exist in the cubic projection and reduce the number or the effect of &#x201c;seams&#x201d; that may exist in cubic projections. Such seams may create artifacts at object boundaries, for example. Eliminating or reducing the number or effect of such seams may result in improved compression/subjective quality as compared to cubic projection methods. For a spherical projection case, a variety of sub-projections may be used, such as the equirectangular, equiangular, and authagraph projection among others. These projections may permit the projection of a sphere onto a 2D plane. In some embodiments, the effects of seams may be de-emphasized by overlapping projections, wherein multiple projections are made of a point cloud, and the projections overlap with one another at the edges, such that there is overlapping information at the seams. A blending effect could be employed at the overlapping seams to reduce the effects of the seams, thus making them less visible.</p><p id="p-0183" num="0197">In addition to, or instead of, considering a different projection method (such as cylindrical or spherical projections), in some embodiments multiple parallel projections may be used. The multiple parallel projections may provide additional information and may reduce a number of occluded points. The projections may be known at the decoder or signaled to the decoder. Such projections may be defined on planes or surfaces that are at different distances from a point cloud object. Also, in some embodiments the projections may be of different shapes, and may also overlap or cross through the point cloud object itself. These projections may permit capturing some characteristics of a point cloud object that may have been occluded through a single projection method or a patch segmentation method as described above.</p><p id="p-0184" num="0198">For example, <figref idref="DRAWINGS">FIG. <b>3</b>E</figref> illustrates a point cloud being projected onto multiple parallel projections, according to some embodiments. Point cloud <b>350</b> which includes points representing a coffee mug is projected onto parallel horizontal projections <b>352</b> that comprise planes orthogonal to the Z axis. Point cloud <b>350</b> is also projected onto vertical projections <b>354</b> that comprise planes orthogonal to the X axis, and is projected onto vertical projections <b>356</b> that comprise planes orthogonal to the Y axis. In some embodiments, instead of planes, multiple projections may comprise projections having other shapes, such as multiple cylinders or spheres.</p><heading id="h-0021" level="2">Generating Images Having Depth</heading><p id="p-0185" num="0199">In some embodiments, only a subset of the pixels of an image frame will be occupied and may correspond to a subset of 3D points of a point cloud. Mapping of patch images may be used to generate geometry, texture, and attribute images, by storing for each occupied pixel the depth/texture/attribute value of its associated point.</p><p id="p-0186" num="0200">In some embodiments, spatial information may be stored with various variations, for example spatial information may:<ul id="ul0020" list-style="none">    <li id="ul0020-0001" num="0000">    <ul id="ul0021" list-style="none">        <li id="ul0021-0001" num="0201">a. Store depth as a monochrome image.</li>        <li id="ul0021-0002" num="0202">b. Store depth as Y and keep U and V empty (where YUV is a color space, also RGB color space may be used).</li>        <li id="ul0021-0003" num="0203">c. Store depth information for different patches in different color planes Y, U and V, in order to avoid inter-patch contamination during compression and/or improve compression efficiency (e.g., have correlated patches in the same color plane). Also, hardware codec capabilities may be utilized, which may spend the same encoding\decoding time independently of the content of the frame.</li>        <li id="ul0021-0004" num="0204">d. Store depth patch images on multiple images or tiles that could be encoded and decoded in parallel. One advantage is to store depth patch images with similar/close orientations or based on visibility according to the rendering camera position in the same image/tile, to enable view-dependent streaming and/or decoding.</li>        <li id="ul0021-0005" num="0205">e. Store depth as Y and store a redundant version of depth in U and V.</li>        <li id="ul0021-0006" num="0206">f. Store X, Y, Z coordinates in Y, U, and V</li>        <li id="ul0021-0007" num="0207">g. Different bit depth (e.g., 8, 10 or 12-bit) and sampling (e.g., 420, 422, 444 . . . ) may be used. Note that different bit depth may be used for the different color planes.</li>    </ul>    </li></ul></p><heading id="h-0022" level="2">Padding</heading><p id="p-0187" num="0208">In some embodiments, padding may be performed to fill the non-occupied pixels with values such that the resulting image is suited for video/image compression. For example, image frame padding module <b>216</b> or image padding module <b>262</b> may perform padding as described below.</p><p id="p-0188" num="0209">In some embodiments, padding is applied on pixel blocks, while favoring the intra-prediction modes used by existing video codecs. More precisely, for each block of size B&#xd7;B to be padded, the intra prediction modes available at the video encoder side are assessed and the one that produces the lowest prediction errors on the occupied pixels is retained. This may take advantage of the fact that video/image codecs commonly operate on pixel blocks with pre-defined sizes (e.g., 64&#xd7;64, 32&#xd7;32, 16&#xd7;16 . . . ). In some embodiments, other padding techniques may include linear extrapolation, in-painting techniques, or other suitable techniques.</p><p id="p-0189" num="0210">In some embodiments, auxiliary metadata, such as an occupancy map may be used to determine attribute values for the padded portion of the image frame, such as color values, assigned to unoccupied pixels. For example, <figref idref="DRAWINGS">FIGS. <b>3</b>F, <b>3</b>G, and <b>3</b>H</figref> illustrate an example occupancy map and corresponding image frames comprising patches packed into the image frame and padding between the patches, wherein smoothing of the padding is not performed in <figref idref="DRAWINGS">FIG. <b>3</b>G</figref> and smoothing of the padding is performed in <figref idref="DRAWINGS">FIG. <b>3</b>H</figref>. As can be seen in <figref idref="DRAWINGS">FIG. <b>3</b>G</figref> the padding comprises a solid color/attribute, such as black, and the patches have varying values according to the attributes of the point cloud. Also, as can be seen there are hard boundaries between the patch images and padding, wherein adjacent points at the boundaries have considerably different values. Also, as can be seen in <figref idref="DRAWINGS">FIG. <b>3</b>H</figref>, the padding values are selected such that boundaries are smooth. A smother image may require fewer bits to encode than an image with hard boundaries. Also, because the location of active and non-active points is known based on the information in the occupancy map, there is not a need for a hard boundary in the packed and padded image frame to be able to distinguish pad pixels from patch pixels. As used herein, a pixel that corresponds to a patch image may be referred to as a &#x201c;full&#x201d; pixel and a pixel that corresponds to a pad portion may be referred to as an &#x201c;empty&#x201d; pixel or &#x201c;pad&#x201d; pixel.</p><p id="p-0190" num="0211">In some embodiments, an approach to determining &#x201c;smoothed&#x201d; values for empty pixels may include determining a value for the empty pixel based on values of neighboring pixels. In some embodiments, an objective function is defined that can be used to minimize the cost of the pad pixel values. For example:<ul id="ul0022" list-style="none">    <li id="ul0022-0001" num="0000">    <ul id="ul0023" list-style="none">        <li id="ul0023-0001" num="0212">Let C(i,j) be the color/position/attribute associated with the pixel (i,j) and O(i,j) be its occupancy (e.g., O(i,j) equals 1 if the pixel is full, and 0 otherwise)</li>        <li id="ul0023-0002" num="0213">Let E={(i<sub>1</sub>,j<sub>1</sub>), (i<sub>2</sub>,j<sub>2</sub>), . . . , (i<sub>k</sub>,j<sub>k</sub>), (i<sub>K</sub>,j<sub>K</sub>)} be the set of empty pixels, F the set of full pixels and S=(F&#x222a;E) the set of all pixels.</li>        <li id="ul0023-0003" num="0214">Let N(i,j) be the set of neighboring pixels of the pixel (i,j) as described in <figref idref="DRAWINGS">FIG. <b>3</b>I</figref>. Note that <figref idref="DRAWINGS">FIG. <b>3</b>I</figref> illustrates four example neighborhood arrangements that may be used to determine a value for pixel (i,j). For example a four connected pixel neighborhood arrangement may be used. Also an 8-connected neighborhood, diamond connected neighborhood, or extended neighborhood arrangement may be used as illustrated in <figref idref="DRAWINGS">FIG. <b>3</b>I</figref>. In some embodiments, other neighborhood arrangements may be used.</li>    </ul>    </li></ul></p><p id="p-0191" num="0215">In some embodiments, a padding minimization problem which tries to determine values of empty pixels, E, is formulated, wherein a padding obtained by solving the minimization problem for each pixel of the padding results in a smoothed padding. More precisely, the colors for pixels P(i,j), C(i<sub>1</sub>,i<sub>1</sub>), C(i<sub>2</sub>,i<sub>2</sub>), . . . , C(i<sub>k</sub>,i<sub>k</sub>), . . . C(i<sub>K</sub>,i<sub>K</sub>), are determined such that the following cost function &#x398; is minimized:</p><p id="p-0192" num="0000"><maths id="MATH-US-00005" num="00005"><math overflow="scroll"> <mrow>  <mrow>   <mi>&#x398;</mi>   <mo>&#x2061;</mo>   <mo>(</mo>   <mrow>    <mrow>     <mi>C</mi>     <mo>&#x2061;</mo>     <mo>(</mo>     <mrow>      <msub>       <mi>i</mi>       <mn>1</mn>      </msub>      <mo>,</mo>      <msub>       <mi>j</mi>       <mn>1</mn>      </msub>     </mrow>     <mo>)</mo>    </mrow>    <mo>,</mo>    <mrow>     <mi>C</mi>     <mo>&#x2061;</mo>     <mo>(</mo>     <mrow>      <msub>       <mi>i</mi>       <mn>2</mn>      </msub>      <mo>,</mo>      <msub>       <mi>j</mi>       <mn>2</mn>      </msub>     </mrow>     <mo>)</mo>    </mrow>    <mo>,</mo>    <mo>&#x2026;</mo>    <mtext>   </mtext>    <mo>,</mo>    <mrow>     <mi>C</mi>     <mo>&#x2061;</mo>     <mo>(</mo>     <mrow>      <msub>       <mi>i</mi>       <mi>k</mi>      </msub>      <mo>,</mo>      <msub>       <mi>j</mi>       <mi>k</mi>      </msub>     </mrow>     <mo>)</mo>    </mrow>    <mo>,</mo>    <mo>&#x2026;</mo>    <mtext>   </mtext>    <mo>,</mo>    <mrow>     <mi>C</mi>     <mo>&#x2061;</mo>     <mo>(</mo>     <mrow>      <msub>       <mi>i</mi>       <mi>K</mi>      </msub>      <mo>,</mo>      <msub>       <mi>j</mi>       <mi>K</mi>      </msub>     </mrow>     <mo>)</mo>    </mrow>   </mrow>   <mo>)</mo>  </mrow>  <mo>=</mo>  <mrow>   <munder>    <mo>&#x2211;</mo>    <mrow>     <mrow>      <mo>(</mo>      <mrow>       <mi>i</mi>       <mo>,</mo>       <mi>j</mi>      </mrow>      <mo>)</mo>     </mrow>     <mo>&#x2208;</mo>     <mi>S</mi>    </mrow>   </munder>   <msup>    <mrow>     <mo>&#xf605;</mo>     <mrow>      <mrow>       <mrow>        <semantics definitionURL="">         <mo>&#x2758;</mo>         <annotation encoding="Mathematica">"\[LeftBracketingBar]"</annotation>        </semantics>        <mrow>         <mi>N</mi>         <mo>&#x2061;</mo>         <mo>(</mo>         <mrow>          <mi>i</mi>          <mo>,</mo>          <mi>j</mi>         </mrow>         <mo>)</mo>        </mrow>        <semantics definitionURL="">         <mo>&#x2758;</mo>         <annotation encoding="Mathematica">"\[RightBracketingBar]"</annotation>        </semantics>       </mrow>       <mo>&#x2062;</mo>       <mrow>        <mi>C</mi>        <mo>&#x2061;</mo>        <mo>(</mo>        <mrow>         <mi>i</mi>         <mo>,</mo>         <mi>j</mi>        </mrow>        <mo>)</mo>       </mrow>      </mrow>      <mo>-</mo>      <mrow>       <munder>        <mo>&#x2211;</mo>        <mrow>         <mrow>          <mo>(</mo>          <mrow>           <mi>p</mi>           <mo>,</mo>           <mi>q</mi>          </mrow>          <mo>)</mo>         </mrow>         <mo>&#x2208;</mo>         <mrow>          <mi>N</mi>          <mo>&#x2061;</mo>          <mo>(</mo>          <mrow>           <mi>i</mi>           <mo>,</mo>           <mi>j</mi>          </mrow>          <mo>)</mo>         </mrow>        </mrow>       </munder>       <mrow>        <mi>C</mi>        <mo>&#x2061;</mo>        <mo>(</mo>        <mrow>         <mi>p</mi>         <mo>,</mo>         <mi>q</mi>        </mrow>        <mo>)</mo>       </mrow>      </mrow>     </mrow>     <mo>&#xf606;</mo>    </mrow>    <mn>2</mn>   </msup>  </mrow> </mrow></math></maths></p><p id="p-0193" num="0000">&#x2014;where |N(i,j)| is the number of available neighbors of the pixel P(i,j). For interior pixels, |N(i,j)| equals 4 (in a 4-connected neighborhood arrangement, and may be 8, etc. for other neighborhood arrangements). For pixels on the boundary of the image |N(i,j)| is lower than 4.</p><p id="p-0194" num="0216">The solution of the previous minimization problem verifies the following equation:</p><p id="p-0195" num="0000"><maths id="MATH-US-00006" num="00006"><math overflow="scroll"> <mrow>  <mtext>	</mtext>  <mrow>   <mfrac>    <mrow>     <mi>d</mi>     <mo>&#x2062;</mo>     <mi>&#x398;</mi>    </mrow>    <mi>dx</mi>   </mfrac>   <mo>=</mo>   <mn>0</mn>  </mrow> </mrow></math></maths><maths id="MATH-US-00006-2" num="00006.2"><math overflow="scroll"> <mrow>  <mrow>   <mrow>    <mrow>     <mrow>      <semantics definitionURL="">       <mo>&#x2758;</mo>       <annotation encoding="Mathematica">"\[LeftBracketingBar]"</annotation>      </semantics>      <mrow>       <mi>N</mi>       <mo>&#x2061;</mo>       <mo>(</mo>       <mrow>        <msub>         <mi>i</mi>         <mi>k</mi>        </msub>        <mo>,</mo>        <msub>         <mi>i</mi>         <mi>k</mi>        </msub>       </mrow>       <mo>)</mo>      </mrow>      <semantics definitionURL="">       <mo>&#x2758;</mo>       <annotation encoding="Mathematica">"\[RightBracketingBar]"</annotation>      </semantics>     </mrow>     <mo>&#x2062;</mo>     <mrow>      <mi>C</mi>      <mo>&#x2061;</mo>      <mo>(</mo>      <mrow>       <msub>        <mi>i</mi>        <mi>k</mi>       </msub>       <mo>,</mo>       <msub>        <mi>j</mi>        <mi>k</mi>       </msub>      </mrow>      <mo>)</mo>     </mrow>    </mrow>    <mo>-</mo>    <mrow>     <munder>      <mo>&#x2211;</mo>      <mrow>       <mrow>        <mo>(</mo>        <mrow>         <msub>          <mi>i</mi>          <mrow>           <mi>k</mi>           <mo>&#x2062;</mo>           <mn>1</mn>          </mrow>         </msub>         <mo>,</mo>         <msub>          <mi>j</mi>          <mrow>           <mi>k</mi>           <mo>&#x2062;</mo>           <mn>1</mn>          </mrow>         </msub>        </mrow>        <mo>)</mo>       </mrow>       <mo>&#x2208;</mo>       <mrow>        <mi>N</mi>        <mo>&#x2061;</mo>        <mo>(</mo>        <mrow>         <msub>          <mi>i</mi>          <mi>k</mi>         </msub>         <mo>,</mo>         <msub>          <mi>j</mi>          <mi>k</mi>         </msub>        </mrow>        <mo>)</mo>       </mrow>      </mrow>     </munder>     <mrow>      <mi>C</mi>      <mo>&#x2061;</mo>      <mo>(</mo>      <mrow>       <msub>        <mi>i</mi>        <mrow>         <mi>k</mi>         <mo>&#x2062;</mo>         <mn>1</mn>        </mrow>       </msub>       <mo>&#x2062;</mo>       <msub>        <mi>j</mi>        <mrow>         <mi>k</mi>         <mo>&#x2062;</mo>         <mn>1</mn>        </mrow>       </msub>      </mrow>      <mo>)</mo>     </mrow>    </mrow>   </mrow>   <mo>=</mo>   <mn>0</mn>  </mrow>  <mo>,</mo>  <mrow>   <mrow>    <mi>forall</mi>    <mo>&#x2061;</mo>    <mo>(</mo>    <mrow>     <msub>      <mi>i</mi>      <mi>k</mi>     </msub>     <mo>,</mo>     <msub>      <mi>j</mi>      <mi>k</mi>     </msub>    </mrow>    <mo>)</mo>   </mrow>   <mo>&#x2208;</mo>   <mi>E</mi>  </mrow> </mrow></math></maths><maths id="MATH-US-00006-3" num="00006.3"><math overflow="scroll"> <mrow>  <mrow>   <mrow>    <mrow>     <semantics definitionURL="">      <mo>&#x2758;</mo>      <annotation encoding="Mathematica">"\[LeftBracketingBar]"</annotation>     </semantics>     <mrow>      <mi>N</mi>      <mo>&#x2061;</mo>      <mo>(</mo>      <mrow>       <msub>        <mi>i</mi>        <mi>k</mi>       </msub>       <mo>,</mo>       <msub>        <mi>j</mi>        <mi>k</mi>       </msub>      </mrow>      <mo>)</mo>     </mrow>     <semantics definitionURL="">      <mo>&#x2758;</mo>      <annotation encoding="Mathematica">"\[RightBracketingBar]"</annotation>     </semantics>    </mrow>    <mo>&#x2062;</mo>    <mrow>     <mi>C</mi>     <mo>&#x2061;</mo>     <mo>(</mo>     <mrow>      <msub>       <mi>i</mi>       <mi>k</mi>      </msub>      <mo>,</mo>      <msub>       <mi>j</mi>       <mi>k</mi>      </msub>     </mrow>     <mo>)</mo>    </mrow>   </mrow>   <mo>-</mo>   <mrow>    <munder>     <mo>&#x2211;</mo>     <mrow>      <mrow>       <mo>(</mo>       <mrow>        <msub>         <mi>i</mi>         <mrow>          <mi>k</mi>          <mo>&#x2062;</mo>          <mn>1</mn>         </mrow>        </msub>        <mo>,</mo>        <msub>         <mi>j</mi>         <mrow>          <mi>k</mi>          <mo>&#x2062;</mo>          <mn>1</mn>         </mrow>        </msub>       </mrow>       <mo>)</mo>      </mrow>      <mo>&#x2208;</mo>      <mrow>       <mrow>        <mi>N</mi>        <mo>&#x2061;</mo>        <mo>(</mo>        <mrow>         <msub>          <mi>i</mi>          <mi>k</mi>         </msub>         <mo>,</mo>         <msub>          <mi>j</mi>          <mi>k</mi>         </msub>        </mrow>        <mo>)</mo>       </mrow>       <mo>&#x22c2;</mo>       <mi>E</mi>      </mrow>     </mrow>    </munder>    <mrow>     <mi>C</mi>     <mo>&#x2061;</mo>     <mo>(</mo>     <mrow>      <msub>       <mi>p</mi>       <mi>n</mi>      </msub>      <mo>,</mo>      <msub>       <mi>q</mi>       <mi>n</mi>      </msub>     </mrow>     <mo>)</mo>    </mrow>   </mrow>  </mrow>  <mo>=</mo>  <mrow>   <munder>    <mo>&#x2211;</mo>    <mrow>     <mrow>      <mo>(</mo>      <mrow>       <msub>        <mi>i</mi>        <mrow>         <mi>k</mi>         <mo>&#x2062;</mo>         <mn>1</mn>        </mrow>       </msub>       <mo>,</mo>       <msub>        <mi>j</mi>        <mrow>         <mi>k</mi>         <mo>&#x2062;</mo>         <mn>1</mn>        </mrow>       </msub>      </mrow>      <mo>)</mo>     </mrow>     <mo>&#x2208;</mo>     <mrow>      <mrow>       <mi>N</mi>       <mo>&#x2061;</mo>       <mo>(</mo>       <mrow>        <msub>         <mi>i</mi>         <mi>k</mi>        </msub>        <mo>,</mo>        <msub>         <mi>j</mi>         <mi>k</mi>        </msub>       </mrow>       <mo>)</mo>      </mrow>      <mo>&#x22c2;</mo>      <mi>F</mi>     </mrow>    </mrow>   </munder>   <mrow>    <mi>C</mi>    <mo>&#x2061;</mo>    <mo>(</mo>    <mrow>     <msub>      <mi>i</mi>      <mrow>       <mi>k</mi>       <mo>&#x2062;</mo>       <mn>1</mn>      </mrow>     </msub>     <mo>,</mo>     <msub>      <mi>j</mi>      <mrow>       <mi>k</mi>       <mo>&#x2062;</mo>       <mn>1</mn>      </mrow>     </msub>    </mrow>    <mo>)</mo>   </mrow>  </mrow> </mrow></math></maths><maths id="MATH-US-00006-4" num="00006.4"><math overflow="scroll"> <mrow>  <mtext>	</mtext>  <mrow>   <mrow>    <mrow>     <mrow>      <semantics definitionURL="">       <mo>&#x2758;</mo>       <annotation encoding="Mathematica">"\[LeftBracketingBar]"</annotation>      </semantics>      <mrow>       <mi>N</mi>       <mo>&#x2061;</mo>       <mo>(</mo>       <mrow>        <msub>         <mi>i</mi>         <mi>k</mi>        </msub>        <mo>,</mo>        <msub>         <mi>i</mi>         <mi>k</mi>        </msub>       </mrow>       <mo>)</mo>      </mrow>      <semantics definitionURL="">       <mo>&#x2758;</mo>       <annotation encoding="Mathematica">"\[RightBracketingBar]"</annotation>      </semantics>     </mrow>     <mo>&#x2062;</mo>     <mrow>      <mi>C</mi>      <mo>&#x2061;</mo>      <mo>(</mo>      <mrow>       <msub>        <mi>i</mi>        <mi>k</mi>       </msub>       <mo>,</mo>       <msub>        <mi>j</mi>        <mi>k</mi>       </msub>      </mrow>      <mo>)</mo>     </mrow>    </mrow>    <mo>-</mo>    <mrow>     <munder>      <mo>&#x2211;</mo>      <mrow>       <mrow>        <mo>(</mo>        <mrow>         <msub>          <mi>i</mi>          <mrow>           <mi>k</mi>           <mo>&#x2062;</mo>           <mn>1</mn>          </mrow>         </msub>         <mo>,</mo>         <msub>          <mi>j</mi>          <mrow>           <mi>k</mi>           <mo>&#x2062;</mo>           <mn>1</mn>          </mrow>         </msub>        </mrow>        <mo>)</mo>       </mrow>       <mo>&#x2208;</mo>       <mrow>        <mrow>         <mi>N</mi>         <mo>&#x2061;</mo>         <mo>(</mo>         <mrow>          <msub>           <mi>i</mi>           <mi>k</mi>          </msub>          <mo>,</mo>          <msub>           <mi>i</mi>           <mi>k</mi>          </msub>         </mrow>         <mo>)</mo>        </mrow>        <mo>&#x22c2;</mo>        <mi>E</mi>       </mrow>      </mrow>     </munder>     <mrow>      <mi>C</mi>      <mo>&#x2061;</mo>      <mo>(</mo>      <mrow>       <mi>p</mi>       <mo>,</mo>       <mi>q</mi>      </mrow>      <mo>)</mo>     </mrow>    </mrow>   </mrow>   <mo>=</mo>   <mrow>    <mi>b</mi>    <mo>&#x2061;</mo>    <mo>(</mo>    <mrow>     <msub>      <mi>i</mi>      <mi>k</mi>     </msub>     <mo>,</mo>     <msub>      <mi>j</mi>      <mi>k</mi>     </msub>    </mrow>    <mo>)</mo>   </mrow>  </mrow> </mrow></math></maths></p><p id="p-0196" num="0000">&#x2014;where b(i<sub>k</sub>,i<sub>k</sub>)=&#x3a3;<sub>(i</sub><sub><sub2>k1</sub2></sub><sub>,j</sub><sub><sub2>k1</sub2></sub><sub>)&#x2208;N(i</sub><sub><sub2>k</sub2></sub><sub>,i</sub><sub><sub2>k</sub2></sub><sub>)&#x2229;F</sub>C(i<sub>k1</sub>,j<sub>k1</sub>)</p><p id="p-0197" num="0217">The previous system of linear equations may be formulated in a matrix-form as follows:</p><p id="p-0198" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>Ax=b </i><?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0199" num="0000">&#x2014;where A is a sparse square matrix of dimension K&#xd7;K defined as follows:</p><p id="p-0200" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>A</i>(<i>k,k</i>)=|<i>N</i>(<i>i</i><sub>k</sub><i>,j</i><sub>k</sub>)|<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0201" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>For (<i>i</i><sub>k1</sub><i>,j</i><sub>k1</sub>)&#x2208;<i>N</i>(<i>i</i><sub>k</sub><i>,j</i><sub>k</sub>)&#x2229;<i>E,A</i>(<i>k,k</i>1)=&#x2212;<i>C</i>(<i>i</i><sub>k1</sub><i>,j</i><sub>k1</sub>)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0202" num="0000">b is a vector of dimension K defined as:</p><p id="p-0203" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>b</i>(<i>k</i>)=<i>b</i>(<i>i</i><sub>k</sub><i>,j</i><sub>k</sub>)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0204" num="0218">In some embodiments, the previous linear system can be solved by using an iterative technique, such as a conjugate gradient technique. For example, an iterative approach may start with a guess XO. XO could be a fixed vector, could be determined by another padding technique such as any of the padding techniques described above, or using another padding technique. The guess XO is refined according to the following algorithm:</p><p id="p-0205" num="0000"><tables id="TABLE-US-00003" num="00003"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="49pt" align="left"/><colspec colname="2" colwidth="168pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;</entry><entry>r<sub>0 </sub>:= b &#x2212; Ax<sub>0</sub></entry></row><row><entry/><entry>p<sub>0 </sub>:= r<sub>0</sub></entry></row><row><entry/><entry>k := 0</entry></row><row><entry/><entry>repeat</entry></row><row><entry> </entry></row><row><entry/><entry>&#x2003;<maths id="MATH-US-00007" num="00007"><math overflow="scroll"> <mrow>  <msub>   <mi>&#x3b1;</mi>   <mi>k</mi>  </msub>  <mo>:=</mo>  <mfrac>   <mrow>    <msubsup>     <mi>r</mi>     <mi>k</mi>     <mi>T</mi>    </msubsup>    <mo>&#x2062;</mo>    <msub>     <mi>r</mi>     <mi>k</mi>    </msub>   </mrow>   <mrow>    <msubsup>     <mi>p</mi>     <mi>k</mi>     <mi>T</mi>    </msubsup>    <mo>&#x2062;</mo>    <msub>     <mi>Ap</mi>     <mi>k</mi>    </msub>   </mrow>  </mfrac> </mrow></math></maths></entry></row><row><entry> </entry></row><row><entry/><entry>&#x2003;x<sub>k+1</sub> := x<sub>k </sub>+ &#x3b1;<sub>k</sub>p<sub>k</sub></entry></row><row><entry/><entry>&#x2003;r<sub>k+1</sub> := r<sub>k &#x2212;</sub> &#x3b1;<sub>k</sub>Ap<sub>k</sub></entry></row><row><entry/><entry>&#x2003;if r<sub>k+1</sub> is sufficiently small, then exit loop</entry></row><row><entry> </entry></row><row><entry/><entry>&#x2003;<maths id="MATH-US-00008" num="00008"><math overflow="scroll"> <mrow>  <msub>   <mi>&#x3b2;</mi>   <mi>k</mi>  </msub>  <mo>:=</mo>  <mfrac>   <mrow>    <msubsup>     <mi>r</mi>     <mrow>      <mi>k</mi>      <mo>+</mo>      <mn>1</mn>     </mrow>     <mi>T</mi>    </msubsup>    <mo>&#x2062;</mo>    <msub>     <mi>r</mi>     <mrow>      <mi>k</mi>      <mo>+</mo>      <mn>1</mn>     </mrow>    </msub>   </mrow>   <mrow>    <msubsup>     <mi>p</mi>     <mi>k</mi>     <mi>T</mi>    </msubsup>    <mo>&#x2062;</mo>    <msub>     <mi>r</mi>     <mi>k</mi>    </msub>   </mrow>  </mfrac> </mrow></math></maths></entry></row><row><entry> </entry></row><row><entry/><entry>&#x2003;p<sub>k+1</sub> := r<sub>k+1</sub> + &#x3b2;<sub>k</sub>p<sub>k</sub></entry></row><row><entry/><entry>&#x2003;k := k +1</entry></row><row><entry/><entry>end repeat</entry></row><row><entry/><entry>The result is x<sub>k+1</sub></entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0206" num="0219">In some embodiments, the maximum number of iterations to perform or the minimum error are parameters that a user (e.g. engineer implementing the point cloud encoder/decoder) may set. In some embodiments, the previous algorithm may be optimized by utilizing a hierarchical approach to determining pixel values for empty pixels (e.g. pad pixels). For example, instead of applying the algorithm to the full resolution of pixels of the pad, the padding is initially performed at a lower resolution. After N iterations or when &#x201c;good&#x201d; (e.g., has an error lower that a user-defined threshold) solution is reached, the padded regions are up-sampled and further refined at a higher resolution using the same technique. This process is repeated until the target resolution is achieved.</p><p id="p-0207" num="0220">In some embodiments, in order to enable parallelization and to reduce computational complexity, the padding technique could be applied independently to a set of overlapping or no-overlapping tiles. For overlapping tiles, the overlapped regions could be used as a constraint, while solving the padding problem only for the other empty pixels of the tile. In some embodiments, in order to enable pipelining, a previous iteration from neighboring tiles could be used as a constraint instead of the current iteration. In some embodiments, the tiles may be traversed in various orders, such as a raster scan, inward or outward spiral, checkerboard, random order, or other order. In some embodiments, tiles and hierarchal approaches to determining pixel values for empty pixels (e.g. pad pixels) may be combined. For example, a global solution could be determined with the hierarchical approach and refined on a tile by tile basis. As referred to herein global solution may a solution that minimizes costs taking into account all of the pixels of a given image frame (both padded and full). For padded pixels close to boundaries of packed patch images some of the neighboring pixels in a neighborhood of the padded pixel may include both full and empty (or padded) pixels. As referred to herein a local solution may a solution that minimizes costs for a portion of an image frame, such as a block, tile, etc.</p><p id="p-0208" num="0221">In some embodiments, padding values could be determined in the original texture/position/attribute domain (e.g., RGB domain for texture) or in a transformed domain. For example, using a YUV <b>420</b> version of the image may reduce the computational complexity by half. As another example, a more uniform space such as Yu&#x2032;v&#x2032; or IPT or ICtCp may be used. In some embodiments, different convergence thresholds could be defined for the different channels. In some embodiments, in solving the linear system, certain computations can be shared between different color components. For instance, the conjugate gradient algorithm can operate in Y domain, and the resulted &#x3b1; and &#x3b2; can be applied to U and V channels. Since the calculation of &#x3b1; and &#x3b2; represent the most expensive computational steps, the overall cost of implementation can be reduced. The linear system solver can also be carried out in stages. For example the solver can be applied first in Y. After that has converged, U and V can be initialized with Y and continue the conjugate gradient routine in U/V domain With better initialization, the second stage solver could converge faster therefore resulting in an overall reduction of complexity.</p><p id="p-0209" num="0222">In some embodiments, temporal considerations may be taken into account. For example, average co-located empty samples in adjacent frames, average co-located empty samples, while considering the prediction structure used by the video codec, etc. In some embodiments, the definition of neighbors may be updated by considering not only the neighbors in the current picture, but also the co-located pixels and their neighborhood in adjacent or reference frames. In some embodiments, empty pixels that are within a certain proximity (e.g., for instance within a distance of d samples) from non-empty pixels (or full pixels) may also consider motion estimated pixels as their temporal neighbors.</p><p id="p-0210" num="0223">In some embodiments, other cost functions may be used such as L0 and L1 norm cost functions. An objective for minimizing the cost of padding using a cost function could be defined as minimizing a number of bits used to encode the areas to be padded. Also, an objective for minimizing the cost of padding using a cost function could be defined as a cost accumulated on a block by block basis, for example when using a block based predictive coding scheme, such as H.264 and/or H.265. On each block a predictor signal is formed first, a cost term is subsequently evaluated on the residue signal. SSD, SAD or SATD may be used to compute the cost term. The residue signal can be modeled as a linear combination of pixel values therefore existing solutions for such linear systems may be leveraged. Note the above algorithms can be applied for both Intra prediction and Inter prediction. Note this can be done by estimating the coding mode for each block. If a block uses Intra prediction, the predictor will depend on neighboring pixels in the same picture. For Inter prediction, the predictor will depend on previous pictures in coding order.</p><p id="p-0211" num="0224">As mentioned above, various neighborhood configurations may be used by a cost function to determine a cost for a given pixel value being smoothed. For example, <figref idref="DRAWINGS">FIG. <b>41</b></figref> illustrates a 4-connected neighborhood, an 8-connected neighborhood, a diamond neighborhood, and an extended neighborhood. In each of the neighborhood configurations illustrated, the pixel (i,j) may be the given pixel being evaluated for smoothing. The (i&#x2212;1) pixels may be pixels adjacent pixels above the pixel being evaluated and the (i+1) pixels may be pixels below the given pixel being evaluated. Also, the (j+1) and (j&#x2212;1) pixels may be adjacent pixels on either side of the pixel being evaluated. The (i&#x2212;1,j&#x2212;1) and (i+1, j+1) pixels may be diagonal pixels to the pixel being evaluated. Also the (i+2), (i&#x2212;2), (j+2), and/or (j&#x2212;2) may be secondarily adjacent pixels that are adjacent to adjacent pixels. Also as shown in the extended neighborhood, in some embodiments secondarily adjacent diagonal pixels may be included in a neighborhood of a pixel being evaluated.</p><heading id="h-0023" level="2">Video Compression</heading><p id="p-0212" num="0225">In some embodiments, a video compression module, such as video compression module <b>218</b> or video compression module <b>264</b>, may perform video compression as described below.</p><p id="p-0213" num="0226">In some embodiments, a video encoder may leverage an occupancy map, which describes for each pixel of an image whether it stores information belonging to the point cloud or padded pixels. In some embodiments, such information may permit enabling various features adaptively, such as de-blocking, adaptive loop filtering (ALF), or shape adaptive offset (SAO) filtering. Also, such information may allow a rate control module to adapt and assign different, e.g. lower, quantization parameters (QPs), and in an essence a different amount of bits, to the blocks containing the occupancy map edges. Coding parameters, such as lagrangian multipliers, quantization thresholding, quantization matrices, etc. may also be adjusted according to the characteristics of the point cloud projected blocks. In some embodiments, such information may also enable rate distortion optimization (RDO) and rate control/allocation to leverage the occupancy map to consider distortions based on non-padded pixels. In a more general form, weighting of distortion may be based on the &#x201c;importance&#x201d; of each pixel to the point cloud geometry. Importance may be based on a variety of aspects, e.g. on proximity to other point cloud samples, directionality/orientation/position of the samples, etc. Facing forward samples, for example, may receive a higher weighting in the distortion computation than backward facing samples. Distortion may be computed using metrics such as Mean Square or Absolute Error, but different distortion metrics may also be considered, such as SSIM, VQM, VDP, Hausdorff distance, and others.</p><heading id="h-0024" level="2">Occupancy Map Compression</heading><p id="p-0214" num="0227">In some embodiments, an occupancy map compression module, such as occupancy map compression module <b>220</b>, may compress an occupancy map as described below.</p><heading id="h-0025" level="1">Example Occupancy Map Compression Techniques</heading><p id="p-0215" num="0228">In some embodiments, an occupancy map may be encoded in a hierarchical mode. Such a process may comprise:<ul id="ul0024" list-style="none">    <li id="ul0024-0001" num="0000">    <ul id="ul0025" list-style="none">        <li id="ul0025-0001" num="0229">1. A binary information for each B1&#xd7;B2 pixel block (e.g., a rectangle that covers the entire image frame, or smaller blocks of different sizes such as 64&#xd7;64, 64&#xd7;32, 32&#xd7;32 block, etc.) being encoded indicating whether the block is empty (e.g., has only padded pixels) or non-empty (e.g., has non-padded pixels).</li>        <li id="ul0025-0002" num="0230">2. If the block is non-empty, then a second binary information may be encoded to indicate whether the block is full (e.g., all the pixels are non-padded) or not.</li>        <li id="ul0025-0003" num="0231">3. The non-empty and non-full blocks may then be refined by considering their (B1/2)&#xd7;(B2/2) sub-blocks.</li>        <li id="ul0025-0004" num="0232">4. The steps 1-3 may be repeated until the size of the block reaches a certain block size B3&#xd7;B4 (e.g., of size 4&#xd7;4). At this level only the empty/non-empty information may be encoded.</li>        <li id="ul0025-0005" num="0233">5. An entropy-based codec may be used to encode the binary information in steps 1 and 2. For instance, context adaptive binary arithmetic encoders may be used.</li>        <li id="ul0025-0006" num="0234">6. The reconstructed geometry image may be leveraged to better encode the occupancy map. More precisely, the residual prediction errors may be used to predict whether a block is empty or not or full or not. Such an information may be incorporated by using a different context based on the predicted case or simply by encoding the binary value XORed with the predicted value.</li>    </ul>    </li></ul></p><p id="p-0216" num="0235">In some embodiments, mesh-based codecs may be an alternative to the approach described above.</p><heading id="h-0026" level="1">Additional Example Occupancy Map Compression Technique</heading><p id="p-0217" num="0236">In some embodiments, auxiliary information and the patch encoding order may be leveraged in order to efficiently compress a mapping information indicating for each T&#xd7;T block of an image frame (e.g., 16&#xd7;16 block) to which patch it belongs to. This mapping may be explicitly encoded in the bit stream as follows:<ul id="ul0026" list-style="none">    <li id="ul0026-0001" num="0000">    <ul id="ul0027" list-style="none">        <li id="ul0027-0001" num="0237">A list of candidate patches is created for each T&#xd7;T block of an image frame by considering all the patches that overlap with that block.</li>        <li id="ul0027-0002" num="0238">The list of candidates is sorted in the reverse order of the patches. Meaning the candidate patches are ordered from smallest patch to largest patch.</li>        <li id="ul0027-0003" num="0239">For each block, the index of the patches in this list is encoded by using an arithmetic or other form of an entropy encoder (e.g. UVLC or Huffman based).</li>        <li id="ul0027-0004" num="0240">Note that empty blocks are assigned a special index, such as zero.</li>        <li id="ul0027-0005" num="0241">The mapping information described above makes it possible to detect empty T&#xd7;T blocks of an image frame (e.g., blocks that contain only padded pixels). The occupancy information is encoded only for the non-empty T&#xd7;T blocks (e.g., the blocks that contain at least one non-padded pixel).</li>        <li id="ul0027-0006" num="0242">The occupancy map is encoded with a precision of a B0&#xd7;B0 blocks. In order to achieve lossless encoding B0 is chosen to be 1. In some embodiments B0=2 or B0=4, which may result in visually acceptable results, while significantly reducing the number of bits required to encode the occupancy map.</li>        <li id="ul0027-0007" num="0243">Binary values are associated with B0&#xd7;B0 sub-blocks belonging to the same T&#xd7;T block. Different strategies are possible. For instance, one could associate a value of 1 if the sub-block contains at least some non-padded pixels and 0 otherwise. If a sub-block has a value of 1 it is said to be full, otherwise it is an empty sub-block.</li>        <li id="ul0027-0008" num="0244">If all the sub-blocks of a T&#xd7;T block are full (e.g., have value 1). The block is said to be full. Otherwise, the block is said to be non-full.</li>        <li id="ul0027-0009" num="0245">A binary information is encoded for each T&#xd7;T block to indicate whether it is full or not. Various encoding strategies could be used. For instance, a context adaptive binary arithmetic encoder could be used.</li>        <li id="ul0027-0010" num="0246">If the block is non-full, an extra information is encoded indicating the location of the full/empty sub-blocks. More precisely, the process may proceed as follows:        <ul id="ul0028" list-style="none">            <li id="ul0028-0001" num="0247">Different traversal orders are defined for the sub-blocks. <figref idref="DRAWINGS">FIG. <b>12</b>B</figref>, shows some examples. The traversal orders are predetermined and known to both the encoder and decoder.</li>            <li id="ul0028-0002" num="0248">The encoder chooses one of the traversal orders and explicitly signals its index in the bit stream.</li>            <li id="ul0028-0003" num="0249">The binary values associated with the sub-blocks are encoded by using a run-length encoding strategy.</li>            <li id="ul0028-0004" num="0250">The binary value of the initial sub-block is encoded. Various encoding strategies could be used. For instance, fixed length coding or a context adaptive binary arithmetic encoder could be used.</li>            <li id="ul0028-0005" num="0251">Continuous runs of 0s and 1s are detected, while following the traversal order selected by the encoder.</li>            <li id="ul0028-0006" num="0252">The number of detected runs is encoded. Various encoding strategies could be used. For instance, fixed length coding or a context adaptive binary arithmetic encoder, or a universal variable length encoder (UVLC) could be used.</li>            <li id="ul0028-0007" num="0253">The length of each run, except of the last one, is then encoded. Various encoding strategies could be used. For instance, fixed length coding, a context adaptive binary arithmetic encoder, or a universal variable length encoder could be used.</li>        </ul>        </li>    </ul>    </li></ul></p><p id="p-0218" num="0254">Note that the symbol probabilities used during the arithmetic encoding could be initialized by using values explicitly signaled in the bit stream by the encoder in order to improve compression efficiency. Such information could be signaled at frame, slice, row(s) of blocks, or block level, or using a non-fixed interval. In that case, a system may have the ability to signal the initialization interval, or the interval adaptation could be predefined between encoder and decoder. For example, the interval could start with one block, and then increment by one block afterwards (e.g. using an adaptation positions of {1, 2, 3 . . . N&#x2212;1 . . . } blocks.</p><p id="p-0219" num="0255">The choice of the traversal order may have a direct impact on the compression efficiency. Different strategies are possible. For instance, the encoder could choose the traversal order, which would result in the lowest number of bits or the lowest number of runs. In some embodiments, hierarchical sub-blocks with variable sizes may be used.</p><p id="p-0220" num="0256">In some embodiments, temporal prediction may be used for encoding/compressing occupancy maps as follows:<ul id="ul0029" list-style="none">    <li id="ul0029-0001" num="0000">    <ul id="ul0030" list-style="none">        <li id="ul0030-0001" num="0257">a. The occupancy map of the current frame may be predicted from the occupancy map of a reference frame (e.g. through a difference process assuming zero motion). The prediction could be done at the frame level, but could also be done at a sub-block level, e.g. signal 1 bit whether a block will be predicted temporally, or the original map for a block will be used instead.</li>        <li id="ul0030-0002" num="0258">b. Prediction could be enhanced by using motion compensation and by associating a motion vector with each T&#xd7;T block.</li>        <li id="ul0030-0003" num="0259">c. The values of the current block may be XOR-ed with the values of the block referenced by the motion vector or the co-located block. If no prediction is used, the current block may be coded as is.</li>        <li id="ul0030-0004" num="0260">d. Motion vectors could be integer, integer multiples, or can have sub-pixel precision.</li>        <li id="ul0030-0005" num="0261">e. The encoding strategy described above may be applied to the results.</li>        <li id="ul0030-0006" num="0262">f. The motion vectors of the current block may be predicted based on the motion vectors of the previously encoded blocks. For example, a list of candidate predicted motion vectors may be computed based on the motion vectors of spatially and/or temporally neighboring blocks that have already been encoded. The index of the best candidate to be used as a predictor and the difference can be explicitly encoded in the bit stream. The process may be similar to the process used in codecs such as AVC and HEVC among others. A reduction in temporal candidates may be performed similar to what is done in HEVC to reduce memory requirements. The residual motion vector can then be encoded using a technique such as context adaptive arithmetic encoding or UVLC.</li>        <li id="ul0030-0007" num="0263">g. A skip mode may also be supported to indicate that the predicted block matches exactly the reference block. In that case, no residual motion vector is needed.</li>        <li id="ul0030-0008" num="0264">h. Different block sizes could be used instead of sticking with T&#xd7;T blocks.</li>        <li id="ul0030-0009" num="0265">i. The choice of the block size and the motion vectors could be achieved by minimizing the number of bits required to encode the occupancy map.</li>        <li id="ul0030-0010" num="0266">j. The process could also consider multiple references.</li>    </ul>    </li></ul></p><p id="p-0221" num="0267">In some embodiments, additional techniques for encoding/compression of an occupancy map may include:<ul id="ul0031" list-style="none">    <li id="ul0031-0001" num="0000">    <ul id="ul0032" list-style="none">        <li id="ul0032-0001" num="0268">Using clues included in the video picture to help encode the occupancy map, such as:        <ul id="ul0033" list-style="none">            <li id="ul0033-0001" num="0269">Use high quantization parameters QPs (e.g., 51) or use skip mode for blocks composed of padded pixels only.</li>            <li id="ul0033-0002" num="0270">The arithmetic encoding contexts could be adaptively adjusted based on information extracted from the video bit streams associated with the texture/geometry/motion frames.</li>        </ul>        </li>        <li id="ul0032-0002" num="0271">Group the binary values associated with pixels into 8-bit or 10-bit words and encode them with dictionary-based approaches such as the DEFLATE algorithm.        <ul id="ul0034" list-style="none">            <li id="ul0034-0001" num="0272">Pixels could be grouped 4&#xd7;2/5&#xd7;2 blocks or by leveraging a zig zag scan.</li>            <li id="ul0034-0002" num="0273">Only the pixels belonging to non-empty T&#xd7;T blocks may be encoded.</li>            <li id="ul0034-0003" num="0274">The mapping information indicating for each T&#xd7;T block to which patch it belongs may encoded.</li>        </ul>        </li>    </ul>    </li></ul></p><heading id="h-0027" level="1">Additional Example Occupancy Map Compression Techniques</heading><p id="p-0222" num="0275">In some embodiments, a binary occupancy map is generated based on whether or not bocks of the occupancy map are occupied or un-occupied. This may be performed in a similar manner as described above. Also, the patch information (e.g. bounding box position, size, etc.) is encoded using an arithmetic encoder, in a similar manner as described above. However, instead of relying on the occupancy map to discard empty blocks that intersect with at least one patch bounding box, the empty boxes are explicitly signaled with a special value for the local index. In this approach, the block to patch information is decoded when needed.</p><p id="p-0223" num="0276">In some embodiments, instead of using an arithmetic encoder as described above to encode block to patch information that links boxes of the occupancy map with particular patches, the block to patch information (which contains the local indexes) may be encoded using a video-based encoder. The encoded block-to patch information may then be decoded using a corresponding video-decoder.</p><p id="p-0224" num="0277">In some embodiments, instead of generating a binary occupancy map based on whether or not bocks of the occupancy map are occupied or un-occupied, a non-binary occupancy map is generated. The non-binary occupancy map is configured such that each pixel not only indicates whether the pixel is occupied or non-occupied, but also includes an attribute value, such as a color value that is associated with a local index value of a patch with which the pixel is associated. If the pixel is non-occupied, the pixel may have a color value of zero. Also, the patch information (e.g. bounding box position, size, etc.) is encoded using an arithmetic encoder, in a similar manner as described above. The non-binary occupancy map may be encoded using a video-based encoder. A decoder can retrieve the block to patch information by decoding the non-binary occupancy map and matching each pixel value with the local index lists.</p><p id="p-0225" num="0278">In some embodiments, instead of using a local index, a full list of patches may be used as an index. In such embodiments, there may be no need to compute a list of candidate patches for each block. The decoder can retrieve the block-to-patch information by decoding the non-binary occupancy map directly reading the index value for the patch associated with the pixel from the value of the pixel. In such embodiments, the local index may be omitted because there are enough unique values (e.g. non-binary) values available to be associated with a block, such that each candidate patch may be assigned a unique value.</p><p id="p-0226" num="0279">In some embodiments, during the generation of the occupancy map, the bounding boxes for the patches may be adjusted or initially packed in an image frame such that the bounding boxes do not overlap. This removes ambiguity as to whether a particular bounding box belongs to a particular patch or another patch. The patch information (with non-overlapping bounding boxes) is encoding using an arithmetic encoder. Because there is not ambiguity as to which patch goes with which bounding box, the block to patch information (such as in the local index or complete index, as described above), may be omitted.</p><p id="p-0227" num="0280">In some embodiments, a process that uses a full list of patches (instead of a local index) may result in a high number of patches, which may exceed the max possible number of values (e.g. color values) that may be represented in the non-binary occupancy map. In some embodiments, to address such issues, an occupancy map may be decomposed into segments, with a limited number of patches per segments. Thus for each segment, the patch index is bound. For example, fewer patches may be listed as possibilities for a segment of an occupancy map, such that for each segment the list of possible patches is less than the max possible number of values (e.g. color values). In some such embodiments, bounding boxes for different patches may be allowed to overlap within a segment, but not across segments. During decoding, each segment may have its own global index list of possible patches for that segment.</p><p id="p-0228" num="0281">In some embodiments, a binary occupancy map is generated such that when the patches are packed in the image frame, a bounding box of the patch, aligned to an occupancy resolution does not intersect any previously packed patches of size=_occupancy resolution*size occupancy resolution (e.g. a 16&#xd7;16 block). The patch information (e.g. bounding box position and size) for each patch is encoded using an arithmetic encoder. The order in which the patch information for each patch is encoded may create a hierarchy of patches, such that for any overlapping bounding boxes, the corresponding patch that goes with the bound box can be resolved based on the hierarchy of patch information. The decoder may reconstruct block to patch information using the arithmetically encoded patch information (without the block to patch information being explicitly encoded). For example, a patch list may be parsed in a same order at a decoder as an order in which the patch list was generated at encoding time, wherein the order indicates an order in which the patches were packed in the image frame. This is possible because the packing guarantees that the bounding box for a given patch does not cover any previously processed patch. In such embodiments, patches may be packed (and signaled) in an order such as from small to large, or vice versa. During the packing, each block may include pixels of just one patch, but some bounding boxes for multiple patches may overlap, wherein blocks of the overlapping patches include no pixels for either patch, or pixels for just one of the patches, but not pixels for more than one patch.</p><heading id="h-0028" level="2">Auxiliary Patch-Information Compression</heading><p id="p-0229" num="0282">In some embodiments, for each patch, the following information may be encoded. For example, by auxiliary patch-info compression module <b>222</b>.<ul id="ul0035" list-style="none">    <li id="ul0035-0001" num="0000">    <ul id="ul0036" list-style="none">        <li id="ul0036-0001" num="0283">Its location (U0, V0) in the packed image frame and the extent of its 2D bounding box (DU0, DV0).</li>        <li id="ul0036-0002" num="0284">Minimum/maximum/average/median depth value.</li>        <li id="ul0036-0003" num="0285">Index of the projection direction.</li>    </ul>    </li></ul></p><heading id="h-0029" level="2">Video-Based Occupancy Map Compression</heading><p id="p-0230" num="0286">As described above, in some embodiments, the occupancy map is a binary information that indicates for each pixel in the image frame whether the pixel should be interpreted as an actual point in the point cloud or not, e.g. the pixel is a padded pixel or not. Also, as described above, the auxiliary patch-information indicates for each T&#xd7;T block of an image frame to which patch it belongs. Whereas it was described above to encode an index of patches for a block of an image frame and to keep encoding information for sub-blocks of the image frame until the sub-blocks were either fully empty or fully occupied, an alternative approach is to use a video encoder to encode an additional image frame for the occupancy map. In such embodiments, the additional occupancy map image frame, indicates occupied and unoccupied pixels based on image properties such as different colors (e.g. occupied pixels may be white and non-occupied pixels may be black). In this way it is not necessary to completely subdivide the blocks of the image frame until only occupied or un-occupied sub-blocks are determined. Instead, it is only necessary to identify bounding box sizes and locations in the image frame for the respective patches. The video encoded occupancy map will mirror the image frame and the different pixel values in the occupancy map video image frame will indicate which pixels in a given bounding box of the patch video image frame are patch image pixels or are padded pixels. Thus there is not a need to create a bit stream of sub-divided blocks of the image frame and there is not a need to indicate for each sub-block whether the sub-block is full or empty. Instead the video encoded occupancy map can be used to determine which pixels included in a patch bounding box are padded pixels or patch image pixels. In some embodiments, an occupancy map may be first encoded and then used to generate an index of patches that are associated with blocks of an image frame. In some embodiments, a compression process follows the following procedure that leverages existing video codecs to compress an occupancy map.</p><p id="p-0231" num="0287">The occupancy map could be encoded with a precision of B0&#xd7;B1 blocks. In order to achieve lossless encoding B0 and B1 may be chosen to be equal to 1. In practice B0=B1=2 or B0=B1=4 may result in visually acceptable results, while significantly reducing the number of bits required to encode the occupancy map.</p><p id="p-0232" num="0288">In some embodiments, a single binary is associated with each B0&#xd7;B1 sub-block. Different strategies are possible. For instance, one could associate a value of 1 with the rule that the sub-block contains at least one non-padded pixel and the value of 0 if not. In order to reduce computational complexity, the binary values of multiple B0&#xd7;B1 blocks could be grouped together in a single pixel value.</p><p id="p-0233" num="0289">A binary video frame may be generated by storing the value of each B0&#xd7;B1 block in a pixel. The obtained video frame could be compressed by using a lossless video codec. For example the HEVC video codec could be utilized and its main, screen context coding (scc) main or other profiles could be used.</p><p id="p-0234" num="0290">In some embodiments, the occupancy map could be packed in a 4:4:4 or 4:2:0 chroma format, where the chroma information could contain fixed values, e.g. the values 0 or 128 for an 8 bit codec. The occupancy map could also be coded using a codec supporting a monochrome representation. The occupancy map could be replicated in all color components and encoded using a 4:4:4 representation. Other rearrangements of the occupancy map could be used so as to fit the data in a 4:4:4, 4:2:2, or 4:2:0 representation, while preserving the lossless nature of the signal and at the same time preserving the lossless characteristics of the occupancy map. For example, the occupancy map could be segmented to even horizontal and odd horizontal position sub-maps, and those sub-maps could be embedded into a 4:4:4 signal, the odd position samples in the Y plane and the even position samples in the U plane, and then encoded. This could provide savings in complexity since a reduced resolution (by half) image would be encoded. Other such arrangements could be used.</p><p id="p-0235" num="0291">The occupancy map is used to detect non-empty T&#xd7;T blocks and only for those blocks a patch index is encoded by proceeding as follows:<ul id="ul0037" list-style="none">    <li id="ul0037-0001" num="0000">    <ul id="ul0038" list-style="none">        <li id="ul0038-0001" num="0292">1) A list of candidate patches is created for each T&#xd7;T block by considering all the patches that contain that block.</li>        <li id="ul0038-0002" num="0293">2) The list of candidates is sorted in the reverse order of the patches. Meaning the index is sorted from smallest patch to largest patch, e.g. the patches with bounding boxes covering the smallest area are ordered ahead of patches with bounding boxes covering larger areas of the patch image frame.</li>        <li id="ul0038-0003" num="0294">3) For each block, the index of the patch in this list is encoded by using an entropy encoder, e.g. an arithmetic encoder or other suitable encoder.</li>    </ul>    </li></ul></p><heading id="h-0030" level="2">Patch Alignment and Size Determination in a 2D Bounding Box of an Occupancy Map</heading><p id="p-0236" num="0295">In some embodiments, methods may be applied to remove redundant output points created by the occupancy map quantization/downsampling/upsampling process. By removing these points, the reconstruction process can result in better reconstruction. Furthermore, fewer points may need to be processed during post-processing, e.g. when performing smoothing as described below, thus reducing reconstruction complexity as well as during attribute image generation during encoding. Additionally, quality of the &#x201c;removed&#x201d; points in the geometry and attribute layers may be less important, therefore the characteristics of such points may be exploited during compression, such as devoting fewer resources to redundant points that will be removed.</p><p id="p-0237" num="0296">In some embodiments, when a patch is created, the patch size information (e.g. sizeU0, sizeV0) is defined as multiples of the occupancy packing block. In other words, when patch size is N&#xd7;M and the occupancy packing block resolution is 16, sizeU0 and sizeV0 will be (16*(N/16+1), 16*(M/16+1)). For example, Table 1 shows an example algorithm for determining the width and width of a 2D bounding box for a patch.</p><p id="p-0238" num="0000"><tables id="TABLE-US-00004" num="00004"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="315pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 1</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Width and Height of Patch Derivation</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="315pt" align="left"/><tbody valign="top"><row><entry>If p is equal to 0, then:</entry></row><row><entry>&#x2003;Patch2dSizeU[ frmIdx ][ p ] = pdu_2d_delta_size_u[ frmIdx ][ p ] *</entry></row><row><entry>ops_occupancy_packing_block_size (8-8)</entry></row><row><entry>&#x2003;Patch2dSizeV[ frmIdx ][ p ] = pdu_2d_delta_size_v[ frmIdx ][ p ] *</entry></row><row><entry>ops_occupancy_packing_block_size (8-9)</entry></row><row><entry>Otherwise, if (p &#x3e; 0), then:</entry></row><row><entry>&#x2003;Patch2dSizeU[ frmIdx ][ p ] = Patch2dSizeU[ frmIdx ][ p &#x2212; 1 ] + pdu_2d_delta_size_u[ frmIdx ][ p ]</entry></row><row><entry>* ops_occupancy_packing_block_size (8-10)</entry></row><row><entry>&#x2003;Patch2dSizeV[ frmIdx ][ p ] = Patch2dSizeV[ frmIdx ][ p &#x2212; 1 ] + pdu_2d_delta_size_v[ frmIdx ][ p ]</entry></row><row><entry>* ops_occupancy_packing_block_size (8-11)</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0239" num="0297">In some embodiments, in a patch bounding box, there could be &#x201c;empty&#x201d; lines and/or columns maximum equal to (occupancy packing block resolution &#x2212;1).</p><p id="p-0240" num="0298">In some embodiments, an occupancy map could be quantized/downsampled by oPrecision which can be derived from the decoded occupancy map video resolution and the nominal resolution of the decoded video frames and then dequantized/upsampled when it is used. Therefore, (oPrecision&#xd7;oPrecision) pixels will share one same value (1. Occupied 0. Empty). When the (oPrecision&#xd7;oPrecision) pixels were not fully filled with 1 before the quantization process, the dequantization process will mark previously empty pixels with redundant points, and it would add on the distortion and complexity of the point cloud.</p><p id="p-0241" num="0299">A method which simply discards samples that would have otherwise created additional points may result in holes or crack during reconstruction of the point cloud. A method which moves occupied samples to reduce redundant pixels may, for irregular shapes, result in redundant pixels.</p><p id="p-0242" num="0300">In some embodiments, to improve upon such methods and to remove redundant output points, the width, height, and placement of a patch in an occupancy map may be adjusted.</p><heading id="h-0031" level="2">Point Cloud Resampling</heading><p id="p-0243" num="0301">In some embodiments, a point cloud resampling module, such as point cloud resampling module <b>252</b>, may resample a point cloud as described below.</p><p id="p-0244" num="0302">In some embodiments, dynamic point clouds may have a different number of points from one frame to another. Efficient temporal prediction may require mapping the points of the current frame, denoted CF, to the points of a reference frame, denoted RF. Signaling such a mapping in a bit stream may require a high number of bits and thus may be inefficient. Instead, re-sampling of a current frame CF may be performed so that the current frame CF has the same number of points as reference frame RF. More precisely, the points of reference frame RF may be displaced such that its shape matches the shape of current frame CF. As a second step, the color and attributes of current frame CF may be transferred to the deformed version of reference frame RF. The obtained frame CF&#x2032; may be considered as the re-sampled version of the current frame. The decision to compress the approximation CF&#x2032; of CF may be made by comparing the rate distortion costs of both options (e.g., encoding CF&#x2032; as inter-frame vs. encoding CF as intra-frame). In some embodiments, pre-adjusting RF may be performed in an effort to make it a better reference for future CF images. Resampling may comprise the following:<ul id="ul0039" list-style="none">    <li id="ul0039-0001" num="0000">    <ul id="ul0040" list-style="none">        <li id="ul0040-0001" num="0303">a. First, normals of the points associated with current frame CF and reference frame RF may be estimated and oriented consistently. For every point P belonging to current frame CF (resp. Q belonging to RF), let &#x3b1;(P) (resp., &#x3b1;(Q)) be its position and &#x2207;(P) (resp.,&#x2207;(Q)) its normal. A 6D vector, denoted &#x3c5;(P) (resp., &#x3c5;(Q)) is then associated with every point by combining its position and a weighted version of its normal in the same vector.</li>    </ul>    </li></ul></p><p id="p-0245" num="0000"><maths id="MATH-US-00009" num="00009"><math overflow="scroll"> <mrow>  <mrow>   <mrow>    <mi>v</mi>    <mo>&#x2061;</mo>    <mo>(</mo>    <mi>P</mi>    <mo>)</mo>   </mrow>   <mo>=</mo>   <mrow>    <mrow>     <mrow>      <mo>[</mo>      <mtable>       <mtr>        <mtd>         <mrow>          <mi>&#x3b1;</mi>          <mo>&#x2061;</mo>          <mo>(</mo>          <mi>P</mi>          <mo>)</mo>         </mrow>        </mtd>       </mtr>       <mtr>        <mtd>         <mrow>          <mi>&#x3b5;</mi>          <mo>&#x2062;</mo>          <mrow>           <mo>&#x2207;</mo>           <mrow>            <mo>(</mo>            <mi>P</mi>            <mo>)</mo>           </mrow>          </mrow>         </mrow>        </mtd>       </mtr>      </mtable>      <mo>]</mo>     </mrow>     <mo>&#x2062;</mo>     <mtext>   </mtext>     <mrow>      <mi>v</mi>      <mo>&#x2061;</mo>      <mo>(</mo>      <mi>Q</mi>      <mo>)</mo>     </mrow>    </mrow>    <mo>=</mo>    <mrow>     <mo>[</mo>     <mtable>      <mtr>       <mtd>        <mrow>         <mi>&#x3b1;</mi>         <mo>&#x2061;</mo>         <mo>(</mo>         <mi>Q</mi>         <mo>)</mo>        </mrow>       </mtd>      </mtr>      <mtr>       <mtd>        <mrow>         <mi>&#x3b5;</mi>         <mo>&#x2062;</mo>         <mrow>          <mo>&#x2207;</mo>          <mrow>           <mo>(</mo>           <mi>Q</mi>           <mo>)</mo>          </mrow>         </mrow>        </mrow>       </mtd>      </mtr>     </mtable>     <mo>]</mo>    </mrow>   </mrow>  </mrow>  <mo>,</mo> </mrow></math></maths><ul id="ul0041" list-style="none">    <li id="ul0041-0001" num="0000">    <ul id="ul0042" list-style="none">        <li id="ul0042-0001" num="0000">&#x2003;where &#x3b5; is a parameter controlling the importance of normal for positions. &#x3b5; could be defined by the user or could be determined by applying an optimization procedure. They could also be fixed of adaptive.</li>        <li id="ul0042-0002" num="0304">b. Two mappings from reference frame RF to current frame CF and from current frame CF to reference frame RF are computed as follows:        <ul id="ul0043" list-style="none">            <li id="ul0043-0001" num="0305">i. Every point Q of reference frame RF is mapped to the point P(Q) of current frame CF that has the minimum distance to Q in the 6D space defined in the previous step.</li>            <li id="ul0043-0002" num="0306">ii. Every point P of current frame CF is mapped to the point Q(P) of reference frame RF that has the minimum distance to P in the 6D space defined in the previous step. Let &#x3c1;(Q) be the set of points of current frame CF that are mapped to the same point Q.</li>        </ul>        </li>        <li id="ul0042-0003" num="0307">c. At each iteration        <ul id="ul0044" list-style="none">            <li id="ul0044-0001" num="0308">i. The positions of the points of reference frame RF are updated as follows:</li>        </ul>        </li>    </ul>    </li></ul></p><p id="p-0246" num="0000"><maths id="MATH-US-00010" num="00010"><math overflow="scroll"> <mrow>  <mrow>   <mrow>    <msup>     <mi>&#x3b1;</mi>     <mo>&#x2032;</mo>    </msup>    <mo>(</mo>    <mi>Q</mi>    <mo>)</mo>   </mrow>   <mo>=</mo>   <mrow>    <mrow>     <mi>w</mi>     <mo>.</mo>     <mrow>      <mi>&#x3b1;</mi>      <mo>&#x2061;</mo>      <mo>(</mo>      <mrow>       <mi>P</mi>       <mo>&#x2061;</mo>       <mo>(</mo>       <mi>Q</mi>       <mo>)</mo>      </mrow>      <mo>)</mo>     </mrow>    </mrow>    <mo>+</mo>    <mrow>     <mfrac>      <mrow>       <mo>(</mo>       <mrow>        <mn>1</mn>        <mo>-</mo>        <mi>W</mi>       </mrow>       <mo>)</mo>      </mrow>      <mrow>       <semantics definitionURL="">        <mo>&#x2758;</mo>        <annotation encoding="Mathematica">"\[LeftBracketingBar]"</annotation>       </semantics>       <mrow>        <mi>&#x3c1;</mi>        <mo>&#x2061;</mo>        <mo>(</mo>        <mi>Q</mi>        <mo>)</mo>       </mrow>       <semantics definitionURL="">        <mo>&#x2758;</mo>        <annotation encoding="Mathematica">"\[RightBracketingBar]"</annotation>       </semantics>      </mrow>     </mfrac>     <mo>&#x2062;</mo>     <mrow>      <msub>       <mo>&#x2211;</mo>       <mrow>        <mi>P</mi>        <mo>&#x2208;</mo>        <mrow>         <mi>&#x3c1;</mi>         <mo>&#x2061;</mo>         <mo>(</mo>         <mi>Q</mi>         <mo>)</mo>        </mrow>       </mrow>      </msub>      <mrow>       <mi>&#x3b1;</mi>       <mo>&#x2061;</mo>       <mo>(</mo>       <mi>P</mi>       <mo>)</mo>      </mrow>     </mrow>    </mrow>   </mrow>  </mrow>  <mo>,</mo> </mrow></math></maths><ul id="ul0045" list-style="none">    <li id="ul0045-0001" num="0000">    <ul id="ul0046" list-style="none">        <li id="ul0046-0001" num="0000">        <ul id="ul0047" list-style="none">            <li id="ul0047-0001" num="0000">&#x2003;where |&#x3c1;(Q)| is the number of elements of &#x3c1;(Q). The parameter w could be defined by the user or could be determined by applying an optimization procedure. It could also be fixed or adaptive.</li>            <li id="ul0047-0002" num="0309">ii. The previous updated step results usually in an irregular repartition of the points. In order to overcome such limitations, a Laplacian-based smoothing procedure is applied. The idea is to update the positions of the points such that they stay as close as possible to {a&#x2032;(Q)}, while favoring a repartition as close as possible to the original point repartition in reference frame RF. More precisely, the following sparse linear system may be solved:</li>        </ul>        </li>    </ul>    </li></ul></p><p id="p-0247" num="0000"><maths id="MATH-US-00011" num="00011"><math overflow="scroll"> <mrow>  <mrow>   <mrow>    <mo>{</mo>    <mrow>     <msup>      <mi>&#x3b1;</mi>      <mo>*</mo>     </msup>     <mo>(</mo>     <mi>Q</mi>     <mo>)</mo>    </mrow>    <mo>}</mo>   </mrow>   <mo>=</mo>   <mrow>    <msub>     <mi>argmin</mi>     <mrow>      <mo>{</mo>      <mrow>       <msup>        <mi>&#x3b1;</mi>        <mo>&#x2032;</mo>       </msup>       <mo>(</mo>       <mi>Q</mi>       <mo>)</mo>      </mrow>      <mo>}</mo>     </mrow>    </msub>    <mo>&#x2062;</mo>    <mrow>     <mo>{</mo>     <mrow>      <mrow>       <msub>        <mo>&#x2211;</mo>        <mrow>         <mi>Q</mi>         <mo>&#x2208;</mo>         <mrow>          <mi>R</mi>          <mo>&#x2062;</mo>          <mi>F</mi>         </mrow>        </mrow>       </msub>       <msup>        <mrow>         <mo>&#xf605;</mo>         <mrow>          <mrow>           <msup>            <mi>&#x3b1;</mi>            <mo>&#x2033;</mo>           </msup>           <mo>(</mo>           <mi>Q</mi>           <mo>)</mo>          </mrow>          <mo>-</mo>          <mrow>           <msup>            <mi>&#x3b1;</mi>            <mo>&#x2032;</mo>           </msup>           <mo>(</mo>           <mi>Q</mi>           <mo>)</mo>          </mrow>         </mrow>         <mo>&#xf606;</mo>        </mrow>        <mn>2</mn>       </msup>      </mrow>      <mo>+</mo>      <mrow>       <mi>&#x3b3;</mi>       <mo>&#x2062;</mo>       <mrow>        <msub>         <mo>&#x2211;</mo>         <mrow>          <mi>Q</mi>          <mo>&#x2208;</mo>          <mrow>           <mi>R</mi>           <mo>&#x2062;</mo>           <mi>F</mi>          </mrow>         </mrow>        </msub>        <mrow>         <mo>&#xf605;</mo>         <mrow>          <mrow>           <msup>            <mi>&#x3b1;</mi>            <mo>&#x2033;</mo>           </msup>           <mo>(</mo>           <mi>Q</mi>           <mo>)</mo>          </mrow>          <mo>-</mo>          <msup>           <mrow>            <mrow>             <mrow>              <mfrac>               <mn>1</mn>               <mi>R</mi>              </mfrac>              <mo>&#x2062;</mo>              <mrow>               <msub>                <mo>&#x2211;</mo>                <mrow>                 <msup>                  <mi>Q</mi>                  <mo>&#x2032;</mo>                 </msup>                 <mo>&#x2062;</mo>                 <mi>&#x3f5;</mi>                 <mo>&#x2062;</mo>                 <mrow>                  <mi>N</mi>                  <mo>&#x2061;</mo>                  <mo>(</mo>                  <mi>Q</mi>                  <mo>)</mo>                 </mrow>                </mrow>               </msub>               <mrow>                <msup>                 <mi>&#x3b1;</mi>                 <mo>&#x2033;</mo>                </msup>                <mo>(</mo>                <msup>                 <mi>Q</mi>                 <mo>&#x2032;</mo>                </msup>                <mo>)</mo>               </mrow>              </mrow>             </mrow>             <mo>-</mo>             <mrow>              <mi>&#x3b1;</mi>              <mo>&#x2061;</mo>              <mo>(</mo>              <mi>Q</mi>              <mo>)</mo>             </mrow>             <mo>-</mo>             <mrow>              <mfrac>               <mn>1</mn>               <mi>R</mi>              </mfrac>              <mo>&#x2062;</mo>              <mrow>               <msub>                <mo>&#x2211;</mo>                <mrow>                 <msup>                  <mi>Q</mi>                  <mo>&#x2032;</mo>                 </msup>                 <mo>&#x2062;</mo>                 <mi>&#x3f5;</mi>                 <mo>&#x2062;</mo>                 <mrow>                  <mi>N</mi>                  <mo>&#x2061;</mo>                  <mo>(</mo>                  <mi>Q</mi>                  <mo>)</mo>                 </mrow>                </mrow>               </msub>               <mrow>                <mi>&#x3b1;</mi>                <mo>&#x2061;</mo>                <mo>(</mo>                <msup>                 <mi>Q</mi>                 <mo>&#x2032;</mo>                </msup>                <mo>)</mo>               </mrow>              </mrow>             </mrow>            </mrow>            <mo>&#xf606;</mo>           </mrow>           <mn>2</mn>          </msup>         </mrow>        </mrow>       </mrow>      </mrow>     </mrow>     <mo>}</mo>    </mrow>   </mrow>  </mrow>  <mo>,</mo> </mrow></math></maths><ul id="ul0048" list-style="none">    <li id="ul0048-0001" num="0000">    <ul id="ul0049" list-style="none">        <li id="ul0049-0001" num="0000">        <ul id="ul0050" list-style="none">            <li id="ul0050-0001" num="0000">&#x2003;where N(Q) is the set of the R nearest neighbors of Q in reference frame RF.</li>            <li id="ul0050-0002" num="0310">iii. The mappings between the updated RF&#x2032; point cloud and current frame CF are then updated as follows            <ul id="ul0051" list-style="none">                <li id="ul0051-0001" num="0311">1. Every point Q of RF&#x2032; is mapped to the point P(Q) of current frame CF that has the minimum distance to Q in the 3D space of positions.</li>                <li id="ul0051-0002" num="0312">2. Every point P of current frame CF is mapped to the point Q(P) of reference frame RF that has the minimum distance to P in the 3D space of positions. Let &#x3c1;(Q) be the set of points of current frame CF that are mapped to the same point Q.</li>            </ul>            </li>        </ul>        </li>        <li id="ul0049-0002" num="0313">d. This process is iterated until a pre-defined number of iterations is reached or there is no further change.</li>        <li id="ul0049-0003" num="0314">e. At this stage, the color and attribute information is transferred from current frame CF to RF&#x2032; by exploiting the following formula</li>    </ul>    </li></ul></p><p id="p-0248" num="0000"><maths id="MATH-US-00012" num="00012"><math overflow="scroll"> <mrow>  <mrow>   <mrow>    <mi>A</mi>    <mo>&#x2061;</mo>    <mo>(</mo>    <mi>Q</mi>    <mo>)</mo>   </mrow>   <mo>=</mo>   <mrow>    <mrow>     <mrow>      <mi>w</mi>      <mo>&#x2061;</mo>      <mo>(</mo>      <mi>A</mi>      <mo>)</mo>     </mrow>     <mo>.</mo>     <mrow>      <mi>A</mi>      <mo>&#x2061;</mo>      <mo>(</mo>      <mrow>       <mi>P</mi>       <mo>&#x2061;</mo>       <mo>(</mo>       <mi>Q</mi>       <mo>)</mo>      </mrow>      <mo>)</mo>     </mrow>    </mrow>    <mo>+</mo>    <mrow>     <mfrac>      <mrow>       <mo>(</mo>       <mrow>        <mn>1</mn>        <mo>-</mo>        <mrow>         <mi>w</mi>         <mo>&#x2061;</mo>         <mo>(</mo>         <mi>A</mi>         <mo>)</mo>        </mrow>       </mrow>       <mo>)</mo>      </mrow>      <mrow>       <semantics definitionURL="">        <mo>&#x2758;</mo>        <annotation encoding="Mathematica">"\[LeftBracketingBar]"</annotation>       </semantics>       <mrow>        <mi>&#x3c1;</mi>        <mo>&#x2061;</mo>        <mo>(</mo>        <mi>Q</mi>        <mo>)</mo>       </mrow>       <semantics definitionURL="">        <mo>&#x2758;</mo>        <annotation encoding="Mathematica">"\[RightBracketingBar]"</annotation>       </semantics>      </mrow>     </mfrac>     <mo>&#x2062;</mo>     <mrow>      <msub>       <mo>&#x2211;</mo>       <mrow>        <mi>P</mi>        <mo>&#x2208;</mo>        <mrow>         <mi>&#x3c1;</mi>         <mo>&#x2061;</mo>         <mo>(</mo>         <mi>Q</mi>         <mo>)</mo>        </mrow>       </mrow>      </msub>      <mrow>       <mi>A</mi>       <mo>&#x2061;</mo>       <mo>(</mo>       <mi>P</mi>       <mo>)</mo>      </mrow>     </mrow>    </mrow>   </mrow>  </mrow>  <mo>,</mo> </mrow></math></maths><ul id="ul0052" list-style="none">    <li id="ul0052-0001" num="0000">    <ul id="ul0053" list-style="none">        <li id="ul0053-0001" num="0000">&#x2003;where A stands for the texture or attribute to be transferred, |&#x3c1;(Q)| is the number of elements of &#x3c1;(Q). The parameter w(A) could be defined by the user or could be determined by applying an optimization procedure. It could also be fixed of adaptive.</li>    </ul>    </li></ul></p><heading id="h-0032" level="2">3D Motion Compensation</heading><p id="p-0249" num="0315">In some embodiments, the positions, attributes and texture information may be temporally predicted by taking the difference between the value at current resampled frame minus a corresponding value, e.g. motion compensated value, from the reference frame. These values may be fed to the image generation stage to be stored as images. For example, such techniques may be performed by 3D motion compensation and delta vector prediction module <b>254</b>.</p><heading id="h-0033" level="2">Smoothing Filter</heading><p id="p-0250" num="0316">In some embodiments, a smoothing filter of a decoder, such as smoothing filter <b>244</b> or smoothing filter <b>276</b> of decoder <b>230</b> or decoder <b>280</b>, may perform smoothing as described below.</p><p id="p-0251" num="0317">In some embodiments, a reconstructed point cloud may exhibit discontinuities at the patch boundaries, especially at very low bitrates. In order to alleviate such a problem, a smoothing filter may be applied to the reconstructed point cloud. Applying the smoothing filter may comprise:<ul id="ul0054" list-style="none">    <li id="ul0054-0001" num="0000">    <ul id="ul0055" list-style="none">        <li id="ul0055-0001" num="0318">a. By exploiting the occupancy map, both the encoder and the decoder may be able to detect boundary points, which are defined as being points belonging to B0&#xd7;B0 blocks encoded during the last iteration of the hierarchical occupancy map compression procedure described in previous sections above.</li>        <li id="ul0055-0002" num="0319">b. The boundary points may have their positions/attribute/texture updated. More precisely, respective boundary points may be assigned a smoothed position based on its R nearest neighbors in the point cloud. The smoothed position may be the centroid/median of the nearest neighbors. Another option may comprise fitting a plane or any smooth surface the nearest neighbor and assigning as a smoothed position the projection of the point on that surface. The number of parameters and/or the smoothing strategy may be chosen by a user or determined by applying an optimization strategy. They may be fixed for all the points or chosen adaptively. These parameters may be signaled in the bit stream.</li>        <li id="ul0055-0003" num="0320">c. In order to reduce the computational complexity of the smoothing stage, a subsampled version of the reconstructed point cloud may be considered when looking for the nearest neighbors. Such subsampled version could be efficiently derived by considering a subsampled version of the geometry image and the occupancy map.</li>    </ul>    </li></ul></p><heading id="h-0034" level="2">Closed-Loop Color Conversion</heading><p id="p-0252" num="0321">In some embodiments, an encoder and/or decoder for a point cloud may further include a color conversion module to convert color attributes of a point cloud from a first color space to a second color space. In some embodiments, color attribute information for a point cloud may be more efficiently compressed when converted to a second color space. For example, <figref idref="DRAWINGS">FIGS. <b>4</b>A and <b>4</b>B</figref> illustrates encoders <b>400</b> and <b>450</b> which are similar encoders as illustrated in <figref idref="DRAWINGS">FIGS. <b>2</b>A and <b>2</b>C</figref>, but that further include color conversion modules <b>402</b> and <b>404</b>, respectively. While not illustrated, decoders such as the decoders illustrated in <figref idref="DRAWINGS">FIGS. <b>2</b>B and <b>2</b>D</figref>, may further include color conversion modules to convert color attributes of a decompressed point cloud back into an original color space, in some embodiments.</p><p id="p-0253" num="0322"><figref idref="DRAWINGS">FIG. <b>4</b>C</figref> illustrates components of a closed-loop color conversion module, according to some embodiments. The closed-loop color conversion module <b>410</b> illustrated in <figref idref="DRAWINGS">FIG. <b>4</b>C</figref> may be a similar closed-loop color conversion module as closed-loop color conversion modules <b>402</b> and <b>404</b> illustrated in <figref idref="DRAWINGS">FIGS. <b>4</b>A and <b>4</b>B</figref>.</p><p id="p-0254" num="0323">In some embodiments, a closed-loop color conversion module, such as closed-loop color conversion module <b>410</b>, receives a compressed point cloud from a video encoder, such as video compression module <b>218</b> illustrated in <figref idref="DRAWINGS">FIG. <b>4</b>A</figref> or video compression module <b>264</b> illustrated in <figref idref="DRAWINGS">FIG. <b>4</b>B</figref>. Additionally, a closed-loop color conversion module, such as closed-loop color conversion module <b>410</b>, may receive attribute information about an original non-compressed point cloud, such as color values of points of the point cloud prior to being down-sampled, up-sampled, color converted, etc. Thus, a closed-loop color conversion module may receive a compressed version of a point cloud such as a decoder would receive and also a reference version of the point cloud before any distortion has been introduced into the point cloud due to sampling, compression, or color conversion.</p><p id="p-0255" num="0324">In some embodiments, a closed-loop color conversion module, such as closed-loop color conversion module <b>410</b>, may include a video decompression module, such as video decompression module <b>270</b>, and a geometry reconstruction module, such as geometry reconstruction module <b>412</b>. A video decompression module may decompress one or more video encoded image frames to result in decompressed image frames each comprising one or more patch images packed into the image frame. A geometry reconstruction module, such as geometry reconstruction module <b>412</b>, may then generate a reconstructed point cloud geometry. A re-coloring module, such as re-coloring module <b>414</b>, may then determine colors for points in the point cloud based on the determined reconstructed geometry. For example, in some embodiments, a nearest neighbor approach or other approach may be used to determine estimated color values for points of the point cloud based on sub-sampled color information, wherein a color value is not explicitly encoded for each point of the point cloud. Because there may be losses during the patching process, compression process, decompression process, and geometry reconstruction process, the geometry of the points in the reconstructed point cloud may not be identical to the geometry in the original point cloud. Due to this discrepancy, color compression techniques that rely on geometrical relationships between points to encode color values may result in colors that are slightly different when decoded and decompressed than the original colors. For example, if a color is to be determined based on color values of the nearest neighboring points, a change in geometry may cause a different nearest neighbor to be selected to determine the color value for the point at the decoder than was selected to encode a residual value at the encoder. Thus distortion may be added to the decoded decompressed point cloud.</p><p id="p-0256" num="0325">If a color space conversion module does not account for this distortion that takes place when converting a point cloud into patches packed in an image frame and that takes place when encoding the image frames, the color space conversion module may select less than optimum color conversion parameters, such as luma and chroma values. For example, optimum color conversion parameters that cause a packed image frame in a first color space to closely match the packed image frame converted into a second color space may be different than optimum color conversion parameters when upstream and downstream distortions are accounted for.</p><p id="p-0257" num="0326">In order to account for such distortions, a texture/attribute image color space conversion and re-sampling module, such as module <b>416</b>, may take into account a difference between the &#x201c;re-created&#x201d; color values from re-coloring module <b>416</b> and the original color values from the original non-compressed reference point cloud when determining color conversion parameters for converting an image frame from a first color space, such as R&#x2032;G&#x2032;B&#x2032; 4:4:4 to YCbCr 4:2:0, for example. Thus, the color-converted and re-sampled texture/attribute images provided to video encoder <b>218</b> and <b>264</b>, as shown in <figref idref="DRAWINGS">FIG. <b>4</b>C</figref> may take into account distortion introduced at any stage of compression and decompression of a point cloud, and may utilize optimum color conversion parameters taking into account such distortion.</p><p id="p-0258" num="0327">Such methods may result in considerably reduced distortion when reconstructing the point cloud representation, while maintaining the high compressibility characteristics of the 4:2:0 signal.</p><p id="p-0259" num="0328">In some embodiments, conversion from 4:4:4 R&#x2032;G&#x2032;B&#x2032; to a 4:2:0 YCbCr representation is performed using a 3&#xd7;3 matrix conversion of the form:</p><p id="p-0260" num="0000"><maths id="MATH-US-00013" num="00013"><math overflow="scroll"> <mrow>  <mrow>   <mo>[</mo>   <mtable>    <mtr>     <mtd>      <msup>       <mi>Y</mi>       <mo>&#x2032;</mo>      </msup>     </mtd>    </mtr>    <mtr>     <mtd>      <mrow>       <mi>C</mi>       <mo>&#x2062;</mo>       <mi>b</mi>      </mrow>     </mtd>    </mtr>    <mtr>     <mtd>      <mrow>       <mi>C</mi>       <mo>&#x2062;</mo>       <mi>r</mi>      </mrow>     </mtd>    </mtr>   </mtable>   <mo>]</mo>  </mrow>  <mo>=</mo>  <mrow>   <mrow>    <mo>[</mo>    <mtable>     <mtr>      <mtd>       <msub>        <mi>a</mi>        <mrow>         <mi>Y</mi>         <mo>&#x2062;</mo>         <mi>R</mi>        </mrow>       </msub>      </mtd>      <mtd>       <msub>        <mi>a</mi>        <mrow>         <mi>Y</mi>         <mo>&#x2062;</mo>         <mi>G</mi>        </mrow>       </msub>      </mtd>      <mtd>       <msub>        <mi>a</mi>        <mrow>         <mi>Y</mi>         <mo>&#x2062;</mo>         <mi>B</mi>        </mrow>       </msub>      </mtd>     </mtr>     <mtr>      <mtd>       <msub>        <mi>a</mi>        <mi>CbR</mi>       </msub>      </mtd>      <mtd>       <msub>        <mi>a</mi>        <mi>CbG</mi>       </msub>      </mtd>      <mtd>       <msub>        <mi>a</mi>        <mi>CbB</mi>       </msub>      </mtd>     </mtr>     <mtr>      <mtd>       <msub>        <mi>a</mi>        <mi>CrR</mi>       </msub>      </mtd>      <mtd>       <msub>        <mi>a</mi>        <mi>CrG</mi>       </msub>      </mtd>      <mtd>       <msub>        <mi>a</mi>        <mi>CrB</mi>       </msub>      </mtd>     </mtr>    </mtable>    <mo>]</mo>   </mrow>   <mo>[</mo>   <mtable>    <mtr>     <mtd>      <msup>       <mi>R</mi>       <mo>&#x2032;</mo>      </msup>     </mtd>    </mtr>    <mtr>     <mtd>      <msup>       <mi>G</mi>       <mo>&#x2032;</mo>      </msup>     </mtd>    </mtr>    <mtr>     <mtd>      <msup>       <mi>B</mi>       <mo>&#x2032;</mo>      </msup>     </mtd>    </mtr>   </mtable>   <mo>]</mo>  </mrow> </mrow></math></maths></p><p id="p-0261" num="0329">In the above matrix, Y&#x2032; is the luma component and Cb and Cr are the chroma components. The values of R&#x2032;, G&#x2032;, and B&#x2032; correspond to the red, green, and blue components respectively, after the application of a transfer function that is used to exploit the psycho-visual characteristics of the signal. The coefficients a<sub>YR </sub>through a<sub>CrB </sub>are selected according to the relationship of the red, green, and blue components to the CIE 1931 XYZ color space. Furthermore, the Cb and Cr components are also related to Y&#x2032; in the following manner</p><p id="p-0262" num="0000"><maths id="MATH-US-00014" num="00014"><math overflow="scroll"> <mrow>  <mi>Cb</mi>  <mo>=</mo>  <mrow>   <mrow>    <mfrac>     <mrow>      <msup>       <mi>B</mi>       <mo>&#x2032;</mo>      </msup>      <mo>-</mo>      <msup>       <mi>Y</mi>       <mo>&#x2032;</mo>      </msup>     </mrow>     <mrow>      <mi>alph</mi>      <mo>&#x2062;</mo>      <mi>a</mi>     </mrow>    </mfrac>    <mo>&#x2062;</mo>    <mtext>   </mtext>    <mi>with</mi>    <mo>&#x2062;</mo>    <mtext>   </mtext>    <mi>alpha</mi>   </mrow>   <mo>=</mo>   <mrow>    <mn>2</mn>    <mo>*</mo>    <mrow>     <mo>(</mo>     <mrow>      <mn>1</mn>      <mo>-</mo>      <msub>       <mi>a</mi>       <mrow>        <mi>Y</mi>        <mo>&#x2062;</mo>        <mi>B</mi>       </mrow>      </msub>     </mrow>     <mo>)</mo>    </mrow>   </mrow>  </mrow> </mrow></math></maths><maths id="MATH-US-00014-2" num="00014.2"><math overflow="scroll"> <mrow>  <mi>Cr</mi>  <mo>=</mo>  <mrow>   <mrow>    <mfrac>     <mrow>      <msup>       <mi>R</mi>       <mo>&#x2032;</mo>      </msup>      <mo>-</mo>      <msup>       <mi>Y</mi>       <mo>&#x2032;</mo>      </msup>     </mrow>     <mi>beta</mi>    </mfrac>    <mo>&#x2062;</mo>    <mtext>   </mtext>    <mi>with</mi>    <mo>&#x2062;</mo>    <mtext>   </mtext>    <mi>beta</mi>   </mrow>   <mo>=</mo>   <mrow>    <mn>2</mn>    <mo>*</mo>    <mrow>     <mo>(</mo>     <mrow>      <mn>1</mn>      <mo>-</mo>      <msub>       <mi>a</mi>       <mrow>        <mi>Y</mi>        <mo>&#x2062;</mo>        <mi>R</mi>       </mrow>      </msub>     </mrow>     <mo>)</mo>    </mrow>   </mrow>  </mrow> </mrow></math></maths></p><p id="p-0263" num="0000">with also the following relationships:</p><p id="p-0264" num="0000"><maths id="MATH-US-00015" num="00015"><math overflow="scroll"> <mrow>  <msub>   <mi>a</mi>   <mi>CbR</mi>  </msub>  <mo>=</mo>  <mrow>   <mo>-</mo>   <mfrac>    <msub>     <mi>a</mi>     <mrow>      <mi>Y</mi>      <mo>&#x2062;</mo>      <mi>R</mi>     </mrow>    </msub>    <mrow>     <mn>2</mn>     <mo>*</mo>     <mrow>      <mo>(</mo>      <mrow>       <mn>1</mn>       <mo>-</mo>       <msub>        <mi>a</mi>        <mrow>         <mi>Y</mi>         <mo>&#x2062;</mo>         <mi>B</mi>        </mrow>       </msub>      </mrow>      <mo>)</mo>     </mrow>    </mrow>   </mfrac>  </mrow> </mrow></math></maths><maths id="MATH-US-00015-2" num="00015.2"><math overflow="scroll"> <mrow>  <msub>   <mi>a</mi>   <mi>CbR</mi>  </msub>  <mo>=</mo>  <mrow>   <mo>-</mo>   <mfrac>    <msub>     <mi>a</mi>     <mrow>      <mi>Y</mi>      <mo>&#x2062;</mo>      <mi>G</mi>     </mrow>    </msub>    <mrow>     <mn>2</mn>     <mo>*</mo>     <mrow>      <mo>(</mo>      <mrow>       <mn>1</mn>       <mo>-</mo>       <msub>        <mi>a</mi>        <mrow>         <mi>Y</mi>         <mo>&#x2062;</mo>         <mi>B</mi>        </mrow>       </msub>      </mrow>      <mo>)</mo>     </mrow>    </mrow>   </mfrac>  </mrow> </mrow></math></maths><maths id="MATH-US-00015-3" num="00015.3"><math overflow="scroll"> <mrow>  <msub>   <mi>a</mi>   <mi>CbB</mi>  </msub>  <mo>=</mo>  <mrow>   <mn>0</mn>   <mo>.</mo>   <mn>5</mn>  </mrow> </mrow></math></maths><maths id="MATH-US-00015-4" num="00015.4"><math overflow="scroll"> <mrow>  <msub>   <mi>a</mi>   <mi>CrR</mi>  </msub>  <mo>=</mo>  <mrow>   <mn>0</mn>   <mo>.</mo>   <mn>5</mn>  </mrow> </mrow></math></maths><maths id="MATH-US-00015-5" num="00015.5"><math overflow="scroll"> <mrow>  <msub>   <mi>a</mi>   <mi>CrR</mi>  </msub>  <mo>=</mo>  <mrow>   <mo>-</mo>   <mfrac>    <msub>     <mi>a</mi>     <mrow>      <mi>Y</mi>      <mo>&#x2062;</mo>      <mi>G</mi>     </mrow>    </msub>    <mrow>     <mn>2</mn>     <mo>*</mo>     <mrow>      <mo>(</mo>      <mrow>       <mn>1</mn>       <mo>-</mo>       <msub>        <mi>a</mi>        <mrow>         <mi>Y</mi>         <mo>&#x2062;</mo>         <mi>R</mi>        </mrow>       </msub>      </mrow>      <mo>)</mo>     </mrow>    </mrow>   </mfrac>  </mrow> </mrow></math></maths><maths id="MATH-US-00015-6" num="00015.6"><math overflow="scroll"> <mrow>  <msub>   <mi>a</mi>   <mi>CrB</mi>  </msub>  <mo>=</mo>  <mrow>   <mo>-</mo>   <mfrac>    <msub>     <mi>a</mi>     <mrow>      <mi>Y</mi>      <mo>&#x2062;</mo>      <mi>B</mi>     </mrow>    </msub>    <mrow>     <mn>2</mn>     <mo>*</mo>     <mrow>      <mo>(</mo>      <mrow>       <mn>1</mn>       <mo>-</mo>       <msub>        <mi>a</mi>        <mrow>         <mi>Y</mi>         <mo>&#x2062;</mo>         <mi>R</mi>        </mrow>       </msub>      </mrow>      <mo>)</mo>     </mrow>    </mrow>   </mfrac>  </mrow> </mrow></math></maths></p><p id="p-0265" num="0330">The process described above is followed by a 2&#xd7; down-sampling horizontally and vertically of the chroma components, resulting in chroma components that are 4 times smaller, in terms of overall number of samples, 2&#xd7; smaller horizontally and 2&#xd7; smaller vertically, compared to those of luma. Such a process can help not only with compression but also with bandwidth and processing complexity of the YCbCr 4:2:0 signals.</p><p id="p-0266" num="0331">In using such an approach quantization for the color components, as well as the down sampling and up sampling processes for the chroma components, may introduce distortion that could impact the quality of the reconstructed signals especially in the R&#x2032;G&#x2032;B&#x2032; but also in the XYZ (CIE 1931 domains). However, a closed loop conversion process, where the chroma and luma values are generated while taking into account such distortions, may considerably improve quality.</p><p id="p-0267" num="0332">In a luma adjustment process, for example, the chroma components may be converted using the above formulations, additionally a down sampling and up sampling may be performed given certain reference filtering mechanisms. Afterwards, using the reconstructed chroma samples, an appropriate luma value may be computed that would result in minimal distortion for the luminance Y component in the CIE 1931 XYZ space. Such luma value may be derived through a search process instead of a direct computation method as provided above. Refinements and simplifications of this method may include interpolative techniques to derive the luma value.</p><p id="p-0268" num="0333">Projected point cloud images can also benefit from similar strategies for 4:2:0 conversion. For example, closed loop color conversion, including luma adjustment methods may be utilized in this context. That is, instead of converting point cloud data by directly using the 3&#xd7;3 matrix above and averaging all neighboring chroma values to generate the 4:2:0 chroma representation for the projected image, one may first project point cloud data/patches using the R&#x2032;G&#x2032;B&#x2032; representation on a 4:4:4 grid. For this new image one may then convert to the YCbCr 4:2:0 representation while using a closed loop optimization such as the luma adjustment method. Assuming that the transfer characteristics function is known, e.g. BT.709, ST 2084 (PQ), or some other transfer function as well as the color primaries of the signal, e.g. BT.709 or BT.2020, an estimate of the luminance component Y may be computed before the final conversion. Then the Cb and Cr components may be computed, down sampled and up sampled using more sophisticated filters. This may then be followed with the computation of the Y&#x2032; value that would result in a luminance value Yrecon that would be as close as possible to Y. If distortion in the RGB domain is of higher distortion, a Y&#x2032; value that minimizes the distortion for R&#x2032;, G&#x2032;, and B&#x2032; jointly, could be considered instead.</p><p id="p-0269" num="0334">For point cloud data, since geometry may also be altered due to lossy compression, texture distortion may also be impacted. In particular, overall texture distortion may be computed by first determining for each point in the original and reconstructed point clouds their closest point in the reconstructed and original point clouds respectively. Then the RGB distortion may be computed for those matched points and accumulated across the entire point cloud image. This means that if the geometry was altered due to lossy compression, the texture distortion would also be impacted. Given that the texture may have been distorted, it may be desirable to consider geometry during closed loop conversion of chroma.</p><p id="p-0270" num="0335">In some embodiments, the geometry is modified so that the relative sampling density in a given region of the point cloud is adjusted to be similar to other regions of the point cloud. Here the relative sampling density is defined as density of original points relative to the uniform 2D sampling grid.</p><p id="p-0271" num="0336">Because the relative sampling density can vary within a given patch, this information can be used to guide the patch decomposition process as described above in regard to occupancy maps and auxiliary information, where patch approximation is used to determine local geometry. Furthermore, this information can be used to guide encoding parameters to achieve more uniform quality after compression. If a local region has higher relative sampling density, the encoder may code that region better through a variety of means. The variety of means may include: variable block size decision, Quantization Parameters (QPs), quantization rounding, de-blocking, shape adaptive offset (SAO) filtering, etc.</p><p id="p-0272" num="0337">In some embodiments, the geometry information is first compressed according to a target bitrate or quality, and then it is reconstructed before generating the texture projected image. Then, given the reconstructed geometry, the closest point in the reconstructed point cloud is determined that corresponds to each point in the original point cloud. The process may be repeated for all points in the reconstructed point cloud by determining their matched points in the original point cloud. It is possible that some points in the reconstructed point cloud may match multiple points in the original point cloud, which would have implications in the distortion computation. This information may be used in the closed loop/luma adjustment method so as to ensure a minimized texture distortion for the entire point cloud. That is, the distortion impact to the entire point cloud of a sample Pr at position (x,y,z) in the reconstructed point cloud can be computed (assuming the use of MSE on YCbCr data for the computation):</p><p id="p-0273" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>D</i>(<i>Pr</i>)=<i>D</i>original(<i>Pr</i>)+<i>D</i>reconstructed(<i>Pr</i>)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0274" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>D</i>(<i>Pr</i>)=Sum_matching(((<i>Y</i>_<i>pr&#x2212;Y</i>_<i>or</i>(<i>i</i>)){circumflex over (&#x2003;)}2+(<i>Cb</i>_<i>pr&#x2212;Cb</i>_<i>or</i>(<i>i</i>)){circumflex over (&#x2003;)}2+(<i>Cr</i>_<i>pr&#x2212;Cr</i>_<i>or</i>(<i>i</i>)){circumflex over (&#x2003;)}2)+sqrt((<i>Y</i>_<i>pr&#x2212;Y</i>_<i>or</i>){circumflex over (&#x2003;)}2+(<i>Cb</i>_<i>pr&#x2212;Cb</i>_<i>or</i>){circumflex over (&#x2003;)}2+(<i>Cr</i>_<i>pr&#x2212;Cr</i>_<i>or</i>){circumflex over (&#x2003;)}2)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0275" num="0338">In the above equation, Y_pr, Cb_pr, and Cr_pr are the luma and chroma information of point Pr, Y_or(i), Cb_or(i), and Cr_or(i) correspond to the luma and chroma information of all the points that were found to match the geometry location of point Pr from the original image, and Y_or, Cb_or, and Cr_or is the point that matches the location of point Pr in the original as seen from the reconstructed image.</p><p id="p-0276" num="0339">If the distortion computation in the context of closed loop conversion/luma adjustment utilizes D(Pr), then better performance may be achieved since it not only optimizes projected distortion, but also point cloud distortion. Such distortion may not only consider luma and chroma values, but may instead or additionally consider other color domain components such as R, G, or B, luminance Y, CIE 1931 x and y, CIE 1976 u&#x2032; and v&#x2032;, YCoCg, and the ICtCp color space amongst others.</p><p id="p-0277" num="0340">If geometry is recompressed a different optimal distortion point may be possible. In that case, it might be appropriate to redo the conversion process once again.</p><p id="p-0278" num="0341">In some embodiments, texture distortion, as measured as described below, can be minimized as follows:<ul id="ul0056" list-style="none">    <li id="ul0056-0001" num="0000">    <ul id="ul0057" list-style="none">        <li id="ul0057-0001" num="0342">Let (Q(j))<sub>i&#x2208;{1, . . . , N}</sub> and (P<sub>rec</sub>(i))<sub>i&#x2208;{1, . . . , N</sub><sub><sub2>rec</sub2></sub><sub>}</sub> be the original and the reconstructed geometries, respectively.</li>        <li id="ul0057-0002" num="0343">Let N and N<sub>rec </sub>be the number of points in the original and the reconstructed point clouds, respectively.</li>        <li id="ul0057-0003" num="0344">For each point P<sub>rec</sub>(i) in the reconstructed point cloud, let Q*(i) be its nearest neighbor in the original point cloud and R(Q*(i)), G(Q*(i)), and B(Q*(i)) the RGB values associated with Q*(i).</li>        <li id="ul0057-0004" num="0345">For each point P<sub>rec</sub>(i) in the reconstructed point cloud, let <img id="CUSTOM-CHARACTER-00010" he="3.22mm" wi="2.12mm" file="US20230005188A1-20230105-P00007.TIF" alt="custom-character" img-content="character" img-format="tif"/><sup>+</sup>(i)=(Q<sup>+</sup>(i,h))<sub>h&#x2208;{1, . . . , H(i)}</sub> be the set of point in the original point cloud that share P<sub>rec</sub>(i) as their nearest neighbor in the reconstructed point cloud. Note that <img id="CUSTOM-CHARACTER-00011" he="3.22mm" wi="2.12mm" file="US20230005188A1-20230105-P00007.TIF" alt="custom-character" img-content="character" img-format="tif"/><sup>+</sup>(i) could be empty or could have one or multiple elements.</li>    </ul>    </li></ul></p><p id="p-0279" num="0346">If <img id="CUSTOM-CHARACTER-00012" he="3.22mm" wi="2.12mm" file="US20230005188A1-20230105-P00007.TIF" alt="custom-character" img-content="character" img-format="tif"/><sup>+</sup>(i) is empty, then the RGB values R(<img id="CUSTOM-CHARACTER-00013" he="3.22mm" wi="2.12mm" file="US20230005188A1-20230105-P00007.TIF" alt="custom-character" img-content="character" img-format="tif"/>*(i)), G(<img id="CUSTOM-CHARACTER-00014" he="3.22mm" wi="2.12mm" file="US20230005188A1-20230105-P00007.TIF" alt="custom-character" img-content="character" img-format="tif"/>*(i)), and B(<img id="CUSTOM-CHARACTER-00015" he="3.22mm" wi="2.12mm" file="US20230005188A1-20230105-P00007.TIF" alt="custom-character" img-content="character" img-format="tif"/>*(i)) are associated with the point P<sub>rec</sub>(i).<ul id="ul0058" list-style="none">    <li id="ul0058-0001" num="0000">    <ul id="ul0059" list-style="none">        <li id="ul0059-0001" num="0347">If <img id="CUSTOM-CHARACTER-00016" he="3.22mm" wi="2.12mm" file="US20230005188A1-20230105-P00007.TIF" alt="custom-character" img-content="character" img-format="tif"/><sup>+</sup>(i) is not empty, then proceed as follows:        <ul id="ul0060" list-style="none">            <li id="ul0060-0001" num="0348">Virtual RGB values, denoted R(<img id="CUSTOM-CHARACTER-00017" he="3.22mm" wi="2.12mm" file="US20230005188A1-20230105-P00007.TIF" alt="custom-character" img-content="character" img-format="tif"/><sup>+</sup>(i), G(<img id="CUSTOM-CHARACTER-00018" he="3.22mm" wi="2.12mm" file="US20230005188A1-20230105-P00007.TIF" alt="custom-character" img-content="character" img-format="tif"/><sup>+</sup>(i), and B(<img id="CUSTOM-CHARACTER-00019" he="3.22mm" wi="2.12mm" file="US20230005188A1-20230105-P00007.TIF" alt="custom-character" img-content="character" img-format="tif"/><sup>+</sup>(i)), are computed as follows:</li>        </ul>        </li>    </ul>    </li></ul></p><p id="p-0280" num="0000"><maths id="MATH-US-00016" num="00016"><math overflow="scroll"> <mrow>  <mrow>   <mi>&#x25aa;</mi>   <mo>&#x2062;</mo>   <mtext>   </mtext>   <mrow>    <mi>R</mi>    <mo>&#x2061;</mo>    <mo>(</mo>    <mrow>     <msup>      <mi>&#x211a;</mi>      <mo>+</mo>     </msup>     <mo>(</mo>     <mi>i</mi>     <mo>)</mo>    </mrow>    <mo>)</mo>   </mrow>  </mrow>  <mo>=</mo>  <mrow>   <mfrac>    <mn>1</mn>    <mrow>     <mi>H</mi>     <mo>&#x2061;</mo>     <mo>(</mo>     <mi>i</mi>     <mo>)</mo>    </mrow>   </mfrac>   <mo>&#x2062;</mo>   <mrow>    <msubsup>     <mo>&#x2211;</mo>     <mrow>      <mi>h</mi>      <mo>=</mo>      <mn>1</mn>     </mrow>     <mrow>      <mi>H</mi>      <mo>&#x2061;</mo>      <mo>(</mo>      <mi>i</mi>      <mo>)</mo>     </mrow>    </msubsup>    <mrow>     <mi>R</mi>     <mo>&#x2061;</mo>     <mo>(</mo>     <mrow>      <msup>       <mi>Q</mi>       <mo>+</mo>      </msup>      <mo>(</mo>      <mrow>       <mi>i</mi>       <mo>,</mo>       <mi>h</mi>      </mrow>      <mo>)</mo>     </mrow>     <mo>)</mo>    </mrow>   </mrow>  </mrow> </mrow></math></maths><maths id="MATH-US-00016-2" num="00016.2"><math overflow="scroll"> <mrow>  <mrow>   <mi>&#x25aa;</mi>   <mo>&#x2062;</mo>   <mtext>   </mtext>   <mrow>    <mi>G</mi>    <mo>&#x2061;</mo>    <mo>(</mo>    <mrow>     <msup>      <mi>&#x211a;</mi>      <mo>+</mo>     </msup>     <mo>(</mo>     <mi>i</mi>     <mo>)</mo>    </mrow>    <mo>)</mo>   </mrow>  </mrow>  <mo>=</mo>  <mrow>   <mfrac>    <mn>1</mn>    <mrow>     <mi>H</mi>     <mo>&#x2061;</mo>     <mo>(</mo>     <mi>i</mi>     <mo>)</mo>    </mrow>   </mfrac>   <mo>&#x2062;</mo>   <mrow>    <msubsup>     <mo>&#x2211;</mo>     <mrow>      <mi>h</mi>      <mo>=</mo>      <mn>1</mn>     </mrow>     <mrow>      <mi>H</mi>      <mo>&#x2061;</mo>      <mo>(</mo>      <mi>i</mi>      <mo>)</mo>     </mrow>    </msubsup>    <mrow>     <mi>G</mi>     <mo>&#x2061;</mo>     <mo>(</mo>     <mrow>      <msup>       <mi>Q</mi>       <mo>+</mo>      </msup>      <mo>(</mo>      <mrow>       <mi>i</mi>       <mo>,</mo>       <mi>h</mi>      </mrow>      <mo>)</mo>     </mrow>     <mo>)</mo>    </mrow>   </mrow>  </mrow> </mrow></math></maths><maths id="MATH-US-00016-3" num="00016.3"><math overflow="scroll"> <mrow>  <mrow>   <mi>&#x25aa;</mi>   <mo>&#x2062;</mo>   <mtext>   </mtext>   <mrow>    <mi>B</mi>    <mo>&#x2061;</mo>    <mo>(</mo>    <mrow>     <msup>      <mi>&#x211a;</mi>      <mo>+</mo>     </msup>     <mo>(</mo>     <mi>i</mi>     <mo>)</mo>    </mrow>    <mo>)</mo>   </mrow>  </mrow>  <mo>=</mo>  <mrow>   <mfrac>    <mn>1</mn>    <mrow>     <mi>H</mi>     <mo>&#x2061;</mo>     <mo>(</mo>     <mi>i</mi>     <mo>)</mo>    </mrow>   </mfrac>   <mo>&#x2062;</mo>   <mrow>    <msubsup>     <mo>&#x2211;</mo>     <mrow>      <mi>h</mi>      <mo>=</mo>      <mn>1</mn>     </mrow>     <mrow>      <mi>H</mi>      <mo>&#x2061;</mo>      <mo>(</mo>      <mi>i</mi>      <mo>)</mo>     </mrow>    </msubsup>    <mrow>     <mi>B</mi>     <mo>&#x2061;</mo>     <mo>(</mo>     <mrow>      <msup>       <mi>Q</mi>       <mo>+</mo>      </msup>      <mo>(</mo>      <mrow>       <mi>i</mi>       <mo>,</mo>       <mi>h</mi>      </mrow>      <mo>)</mo>     </mrow>     <mo>)</mo>    </mrow>   </mrow>  </mrow> </mrow></math></maths><ul id="ul0061" list-style="none">    <li id="ul0061-0001" num="0000">    <ul id="ul0062" list-style="none">        <li id="ul0062-0001" num="0000">        <ul id="ul0063" list-style="none">            <li id="ul0063-0001" num="0349">Note that R(<img id="CUSTOM-CHARACTER-00020" he="3.22mm" wi="2.12mm" file="US20230005188A1-20230105-P00007.TIF" alt="custom-character" img-content="character" img-format="tif"/><sup>+</sup>(i)), G(<img id="CUSTOM-CHARACTER-00021" he="3.22mm" wi="2.12mm" file="US20230005188A1-20230105-P00007.TIF" alt="custom-character" img-content="character" img-format="tif"/><sup>+</sup>(i)), and B(<img id="CUSTOM-CHARACTER-00022" he="3.22mm" wi="2.12mm" file="US20230005188A1-20230105-P00007.TIF" alt="custom-character" img-content="character" img-format="tif"/><sup>+</sup>(i)) correspond to the average RGB values of the points of <img id="CUSTOM-CHARACTER-00023" he="3.22mm" wi="2.12mm" file="US20230005188A1-20230105-P00007.TIF" alt="custom-character" img-content="character" img-format="tif"/><sup>+</sup>(i).</li>            <li id="ul0063-0002" num="0350">The final RGB values R(P<sub>rec</sub>(i)), G(P<sub>rec</sub>(i)), and B(P<sub>rec</sub>(i)) are obtained by applying the following linear interpolation:            <ul id="ul0064" list-style="none">                <li id="ul0064-0001" num="0351">R(P<sub>rec</sub>(i))=wR(<img id="CUSTOM-CHARACTER-00024" he="3.22mm" wi="2.12mm" file="US20230005188A1-20230105-P00007.TIF" alt="custom-character" img-content="character" img-format="tif"/><sup>+</sup>(i))+(1&#x2212;w)R(Q*(i))</li>                <li id="ul0064-0002" num="0352">G(P<sub>rec</sub>(i))=wR(<img id="CUSTOM-CHARACTER-00025" he="3.22mm" wi="2.12mm" file="US20230005188A1-20230105-P00007.TIF" alt="custom-character" img-content="character" img-format="tif"/><sup>+</sup>(i))+(1&#x2212;w)G(Q*(i))</li>                <li id="ul0064-0003" num="0353">B(P<sub>rec</sub>(i))=wR(<img id="CUSTOM-CHARACTER-00026" he="3.22mm" wi="2.12mm" file="US20230005188A1-20230105-P00007.TIF" alt="custom-character" img-content="character" img-format="tif"/><sup>+</sup>(i))+(1&#x2212;w)B(Q*(i))</li>            </ul>            </li>            <li id="ul0063-0003" num="0354">The interpolation parameter w is chosen such that the following cost function C(i) is minimized</li>        </ul>        </li>    </ul>    </li></ul></p><p id="p-0281" num="0000"><maths id="MATH-US-00017" num="00017"><math overflow="scroll"> <mrow>  <mrow>   <mi>C</mi>   <mo>&#x2061;</mo>   <mo>(</mo>   <mi>i</mi>   <mo>)</mo>  </mrow>  <mo>=</mo>  <mrow>   <mi>max</mi>   <mo>&#x2062;</mo>   <mrow>    <mo>{</mo>    <mrow>     <mrow>      <mfrac>       <mn>1</mn>       <mi>N</mi>      </mfrac>      <mo>&#x2062;</mo>      <mrow>       <munderover>        <mo>&#x2211;</mo>        <mrow>         <mi>h</mi>         <mo>=</mo>         <mn>1</mn>        </mrow>        <mrow>         <mi>H</mi>         <mo>&#x2061;</mo>         <mo>(</mo>         <mi>i</mi>         <mo>)</mo>        </mrow>       </munderover>       <mrow>        <mo>{</mo>        <mrow>         <msup>          <mrow>           <mo>(</mo>           <mrow>            <mrow>             <mi>R</mi>             <mo>&#x2061;</mo>             <mo>(</mo>             <mrow>              <msub>               <mi>P</mi>               <mi>rec</mi>              </msub>              <mo>(</mo>              <mi>i</mi>              <mo>)</mo>             </mrow>             <mo>)</mo>            </mrow>            <mo>-</mo>            <mrow>             <mi>R</mi>             <mo>&#x2061;</mo>             <mo>(</mo>             <mrow>              <msup>               <mi>&#x211a;</mi>               <mo>+</mo>              </msup>              <mo>(</mo>              <mrow>               <mi>i</mi>               <mo>,</mo>               <mi>h</mi>              </mrow>              <mo>)</mo>             </mrow>             <mo>)</mo>            </mrow>           </mrow>           <mo>)</mo>          </mrow>          <mn>2</mn>         </msup>         <mo>+</mo>         <msup>          <mrow>           <mo>(</mo>           <mrow>            <mrow>             <mi>G</mi>             <mo>&#x2061;</mo>             <mo>(</mo>             <mrow>              <msub>               <mi>P</mi>               <mi>rec</mi>              </msub>              <mo>(</mo>              <mi>i</mi>              <mo>)</mo>             </mrow>             <mo>)</mo>            </mrow>            <mo>-</mo>            <mrow>             <mi>G</mi>             <mo>&#x2061;</mo>             <mo>(</mo>             <mrow>              <msup>               <mi>&#x211a;</mi>               <mo>+</mo>              </msup>              <mo>(</mo>              <mrow>               <mi>i</mi>               <mo>,</mo>               <mi>h</mi>              </mrow>              <mo>)</mo>             </mrow>             <mo>)</mo>            </mrow>           </mrow>           <mo>)</mo>          </mrow>          <mn>2</mn>         </msup>         <mo>+</mo>         <msup>          <mrow>           <mo>(</mo>           <mrow>            <mrow>             <mi>B</mi>             <mo>&#x2061;</mo>             <mo>(</mo>             <mrow>              <msub>               <mi>P</mi>               <mi>rec</mi>              </msub>              <mo>(</mo>              <mi>i</mi>              <mo>)</mo>             </mrow>             <mo>)</mo>            </mrow>            <mo>-</mo>            <mrow>             <mi>B</mi>             <mo>&#x2061;</mo>             <mo>(</mo>             <mrow>              <msup>               <mi>&#x211a;</mi>               <mo>+</mo>              </msup>              <mo>(</mo>              <mrow>               <mi>i</mi>               <mo>,</mo>               <mi>h</mi>              </mrow>              <mo>)</mo>             </mrow>             <mo>)</mo>            </mrow>           </mrow>           <mo>)</mo>          </mrow>          <mn>2</mn>         </msup>        </mrow>        <mo>}</mo>       </mrow>      </mrow>     </mrow>     <mo>,</mo>     <mrow>      <mfrac>       <mn>1</mn>       <msub>        <mi>N</mi>        <mrow>         <mi>r</mi>         <mo>&#x2062;</mo>         <mi>e</mi>         <mo>&#x2062;</mo>         <mi>c</mi>        </mrow>       </msub>      </mfrac>      <mo>&#x2062;</mo>      <mrow>       <mo>{</mo>       <mrow>        <msup>         <mrow>          <mo>(</mo>          <mrow>           <mrow>            <mi>R</mi>            <mo>&#x2061;</mo>            <mo>(</mo>            <mrow>             <msub>              <mi>P</mi>              <mi>rec</mi>             </msub>             <mo>(</mo>             <mi>i</mi>             <mo>)</mo>            </mrow>            <mo>)</mo>           </mrow>           <mo>-</mo>           <mrow>            <mi>R</mi>            <mo>&#x2061;</mo>            <mo>(</mo>            <mrow>             <msup>              <mi>Q</mi>              <mo>*</mo>             </msup>             <mo>(</mo>             <mi>i</mi>             <mo>)</mo>            </mrow>            <mo>)</mo>           </mrow>          </mrow>          <mo>)</mo>         </mrow>         <mn>2</mn>        </msup>        <mo>+</mo>        <msup>         <mrow>          <mo>(</mo>          <mrow>           <mrow>            <mi>G</mi>            <mo>&#x2061;</mo>            <mo>(</mo>            <mrow>             <msub>              <mi>P</mi>              <mrow>               <mi>r</mi>               <mo>&#x2062;</mo>               <mi>e</mi>               <mo>&#x2062;</mo>               <mi>c</mi>              </mrow>             </msub>             <mo>(</mo>             <mi>i</mi>             <mo>)</mo>            </mrow>            <mo>)</mo>           </mrow>           <mo>-</mo>           <mrow>            <mi>G</mi>            <mo>&#x2061;</mo>            <mo>(</mo>            <mrow>             <msup>              <mi>Q</mi>              <mo>*</mo>             </msup>             <mo>(</mo>             <mi>i</mi>             <mo>)</mo>            </mrow>            <mo>)</mo>           </mrow>          </mrow>          <mo>)</mo>         </mrow>         <mn>2</mn>        </msup>        <mo>+</mo>        <msup>         <mrow>          <mo>(</mo>          <mrow>           <mrow>            <mi>B</mi>            <mo>&#x2061;</mo>            <mo>(</mo>            <mrow>             <msub>              <mi>P</mi>              <mi>rec</mi>             </msub>             <mo>(</mo>             <mi>i</mi>             <mo>)</mo>            </mrow>            <mo>)</mo>           </mrow>           <mo>-</mo>           <mrow>            <mi>B</mi>            <mo>&#x2061;</mo>            <mo>(</mo>            <mrow>             <msup>              <mi>Q</mi>              <mo>*</mo>             </msup>             <mo>(</mo>             <mi>i</mi>             <mo>)</mo>            </mrow>            <mo>)</mo>           </mrow>          </mrow>          <mo>)</mo>         </mrow>         <mn>2</mn>        </msup>       </mrow>       <mo>}</mo>      </mrow>     </mrow>    </mrow>    <mo>}</mo>   </mrow>  </mrow> </mrow></math></maths><ul id="ul0065" list-style="none">    <li id="ul0065-0001" num="0000">    <ul id="ul0066" list-style="none">        <li id="ul0066-0001" num="0000">        <ul id="ul0067" list-style="none">            <li id="ul0067-0001" num="0355">Note that by minimizing the cost C(i), the distortion measure as described below is minimized</li>            <li id="ul0067-0002" num="0356">Different search strategies may be used to find the parameter w            <ul id="ul0068" list-style="none">                <li id="ul0068-0001" num="0357">Use the closed form solution described below.</li>                <li id="ul0068-0002" num="0358">No search: use w=0.5.</li>                <li id="ul0068-0003" num="0359">Full search: choose a discrete set of values (w<sub>i</sub>)<sub>i=1 . . . W </sub>in the interval [0,1] and evaluate C(i) for these values in order to find the w*, which minimizes C(i).</li>                <li id="ul0068-0004" num="0360">Gradient descent search: start with w=0.5. Evaluate E1(i), E2(i) and C(i). Store C(i) and w as the lowest cost and its associated interpolation parameter w. If E1(i)&#x3e;E2(i), update w based on the gradient of E1(i), else use the gradient of E2(i). Re-evaluate E1(i), E2(i), and C(i) at the new value of w. Compare the new cost C(i) to the lowest cost found so far. If new cost is higher than the lowest cost stop, else update the lowest cost and the associated value of w, and continue the gradient descent, where R(P<sub>rec</sub>(i), G (P<sub>rec</sub>(i)), and B(P<sub>rec</sub>(i)) are the three unknowns to be determined.</li>            </ul>            </li>        </ul>        </li>    </ul>    </li></ul></p><p id="p-0282" num="0361">In some embodiments, the above process could be performed with other color spaces and not necessarily the RGB color space. For example, the CIE 1931 XYZ or xyY, CIE 1976 Yu&#x2032;v&#x2032;, YCbCr, IPT, ICtCp, La*b*, or some other color model could be used instead. Furthermore, different weighting of the distortion of each component could be considered. Weighting based on illumination could also be considered, e.g. weighting distortion in dark areas more than distortion in bright areas. Other types of distortion, that include neighborhood information, could also be considered. That is, visibility of errors in a more sparse area is likely to be higher than in a more dense region, depending on the intensity of the current and neighboring samples. Such information could be considered in how the optimization is performed.</p><p id="p-0283" num="0362">Down sampling and up sampling of chroma information may also consider geometry information, if available. That is, instead of down sampling and up sampling chroma information without consideration to geometry, the shape and characteristics of the point cloud around the neighborhood of the projected sample may be considered, and appropriately consider or exclude neighboring samples during these processes. In particular, neighboring samples for down sampling or interpolating may be considered that have a normal that is as similar as possible to the normal of the current sample. Weighting during filtering according to the normal difference as well as distance to the point may also be considered. This may help improve the performance of the down sampling and up sampling processes.</p><p id="p-0284" num="0363">It should be noted that for some systems, up sampling of the Cb/Cr information may have to go through existing architectures, e.g. an existing color format converter, and it might not be possible to perform such guided up sampling. In those cases, only considerations for down sampling may be possible.</p><p id="p-0285" num="0364">In some embodiments, it may be possible to indicate in the bit stream syntax the preferred method for up sampling the chroma information. A decoder (included in an encoder), in such a case, may try a variety of up sampling filters or methods, find the best performing one and indicate that in the bit stream syntax. On the decoder side, the decoder may know which up sampling method would perform best for reconstructing the full resolution YCbCr and consequently RGB data. Such method could be mandatory, but could also be optional in some architectures.</p><p id="p-0286" num="0365">Clipping as well as other considerations for color conversion, may also apply to point cloud data and may be considered to further improve the performance of the point cloud compression system. Such methods may also apply to other color representations and not necessarily YCbCr data, such as the YCoCg and ICtCp representation. For such representations different optimization may be required due to the nature of the color transform.</p><heading id="h-0035" level="1">Example Objective Evaluation Method</heading><p id="p-0287" num="0366">A point cloud consists of a set of points represented by (x,y,z) and various attributes of which color components (y,u,v) are of importance. First, define the point v. It has as a mandatory position in a 3D space (x,y,z) and an optional color attribute c that has components r,g,b or y,u,v and optional other attributes possibly representing normal or texture mappings.</p><p id="p-0288" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>point <i>v</i>=(((<i>x,y,z</i>),[<i>c</i>],[<i>a</i><sub>0</sub><i>. . . a</i><sub>A</sub>]):<i>x,y,z&#x2208;R</i>,[<i>c</i>&#x2208;(<i>r,g,b</i>)|<i>r,g,b&#x2208;N</i>],[<i>a</i><sub>i</sub>&#x2208;[0,1]])&#x2003;&#x2003;(def.1)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0289" num="0367">The point cloud is then a set of K points without a strict ordering:</p><p id="p-0290" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>Original Point Cloud <i>V</i><sub>or</sub>={(<i>v</i><sub>i</sub>): <i>i=</i>0 . . . <i>K&#x2212;</i>1}&#x2003;&#x2003; (def. 2)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0291" num="0368">The point cloud comprises a set of (x,y,z) coordinates and attributes that can be attached to the points. The original point cloud Vor (<b>420</b>) will act as the reference for determining the quality of a second degraded point cloud Vdeg (<b>424</b>). Vdeg consists of N points, where N does not necessarily=K. Vdeg is a version of the point cloud with a lower quality possibly resulting from lossy encoding and decoding of Vor (e.g. operation <b>422</b>). This can result in a different point count N.</p><p id="p-0292" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>Degraded Point Cloud <i>V</i><sub>deg</sub>={(<i>v</i><sub>i</sub>):<i>i=</i>0 . . . <i>N&#x2212;</i>1}&#x2003;&#x2003;(def. 3)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0293" num="0369">The quality metric Q_(point cloud) is computed from Vor and Vdeg and used for assessment as shown in <figref idref="DRAWINGS">FIG. <b>4</b>D</figref> for full reference quality metric <b>426</b>.</p><p id="p-0294" num="0370">Table 3, below, outlines the metrics used for the assessment of the quality of a point cloud, in some embodiments. The geometric distortion metrics are similar as ones used for meshes based on haussdorf (Linf) and root mean square (L2), instead of distance to surface. This approach takes the distance to the closest/most nearby point in the point cloud (see definitions 4, 5, 6, and 7) into account. Peak signal to noise ratio (PSNR) is defined as the peak signal of the geometry over the symmetric Root Mean Square (RMS/rms) distortion (def 8.). For colors, a similar metric is defined; the color of the original cloud is compared to the most nearby color in the degraded cloud and peak signal to noise ratio (PSNR) is computed per YUV/YCbCr component in the YUV color space (def. 10). An advantage of this metric is that it corresponds to peak signal to noise ratio (PSNR) in Video Coding. The quality metric is supported in the 3DG PCC software.</p><p id="p-0295" num="0000"><tables id="TABLE-US-00005" num="00005"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="294pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 3</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Assessment criteria for assessment of the point cloud quality of Vdeg, Q<sub>point</sub>_cloud</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="77pt" align="left"/><colspec colname="2" colwidth="161pt" align="left"/><colspec colname="3" colwidth="56pt" align="left"/><tbody valign="top"><row><entry>d_symmetric_rms</entry><entry>Symmetric rms distance between the point clouds</entry><entry>(def. 7.)</entry></row><row><entry>d_symmetric_haussdorf</entry><entry>Symmetric haussdorf distance between the clouds</entry><entry>(def. 7.)</entry></row><row><entry>psnr_geom</entry><entry>Peak signal to noise ratio geometry (vertex positions) </entry><entry>(def. 8.)</entry></row><row><entry>psnr_y</entry><entry>Peak signal to noise ratio geometry (colors Y)</entry><entry>(def. 10)</entry></row><row><entry>psnr_u</entry><entry>Peak signal to noise ratio geometry (colors U)</entry><entry>(as def. 10 rep.</entry></row><row><entry/><entry/><entry>y for u)</entry></row><row><entry>psnr_v</entry><entry>Peak signal to noise ratio geometry (colors V)</entry><entry>(as def. 10 rep.</entry></row><row><entry/><entry/><entry>y for v)</entry></row><row><entry> </entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="238pt" align="left"/><colspec colname="2" colwidth="56pt" align="left"/><tbody valign="top"><row><entry><maths id="MATH-US-00018" num="00018"><math overflow="scroll"> <mrow>  <mrow>   <msub>    <mi>d</mi>    <mrow>     <mi>r</mi>     <mo>&#x2062;</mo>     <mi>m</mi>     <mo>&#x2062;</mo>     <mi>s</mi>    </mrow>   </msub>   <mo>(</mo>   <mrow>    <msub>     <mi>V</mi>     <mi>or</mi>    </msub>    <mo>,</mo>    <msub>     <mi>V</mi>     <mi>deg</mi>    </msub>   </mrow>   <mo>)</mo>  </mrow>  <mo>=</mo>  <msqrt>   <mrow>    <mfrac>     <mn>1</mn>     <mi>K</mi>    </mfrac>    <mo>&#x2062;</mo>    <mrow>     <munder>      <mo>&#x2211;</mo>      <mrow>       <mi>vo</mi>       <mo>&#x2208;</mo>       <mi>Vor</mi>      </mrow>     </munder>     <msup>      <mrow>       <mo>[</mo>       <mrow>        <mo>[</mo>        <mrow>         <mi>vo</mi>         <mo>-</mo>         <mrow>          <msub>           <mi>vd</mi>           <mo>_</mo>          </msub>          <mo>&#x2062;</mo>          <mi>n</mi>          <mo>&#x2062;</mo>          <mi>e</mi>          <mo>&#x2062;</mo>          <mi>a</mi>          <mo>&#x2062;</mo>          <mi>r</mi>          <mo>&#x2062;</mo>          <mi>e</mi>          <mo>&#x2062;</mo>          <mi>s</mi>          <mo>&#x2062;</mo>          <msub>           <mi>t</mi>           <mo>-</mo>          </msub>          <mo>&#x2062;</mo>          <mi>neighbour</mi>         </mrow>        </mrow>        <mo>]</mo>       </mrow>       <mo>]</mo>      </mrow>      <mn>2</mn>     </msup>    </mrow>   </mrow>  </msqrt> </mrow></math></maths></entry><entry>(def.4)</entry></row><row><entry> </entry></row><row><entry>d<sub>symmetric</sub>_rms(V<sub>or</sub>, V<sub>deg</sub>) = max(d<sub>rms</sub>(V<sub>or</sub>,V<sub>deg</sub>), d<sub>rms</sub>(V<sub>deg</sub>,V<sub>or</sub>))</entry><entry>(def.5)</entry></row><row><entry>d<sub>haussdorf</sub>(V<sub>or</sub>, V<sub>deg</sub>) = max<sub>vo &#x2208;Vor</sub>, ( ||v<sub>0 </sub>&#x2212;</entry><entry>(def.6)</entry></row><row><entry>v<sub>d</sub>_nearest_neighbour||<sub>2</sub>, v<sub>d </sub>is the point in Vdeg closest to v<sub>o </sub>(L2)) </entry><entry/></row><row><entry>d<sub>symmetric</sub>_haussdorf(V<sub>or</sub>, V<sub>deg</sub>) = max(d<sub>haussdorf</sub>(V<sub>or</sub>,V<sub>deg</sub>), d<sub>haussdorf</sub>(V<sub>deg</sub>,V<sub>or</sub>)</entry><entry>(def.7)</entry></row><row><entry>BBwidth = max((xmax &#x2212; xmin), (ymax &#x2212; ymin), (zmax &#x2212; zmin) </entry><entry>(def. 8)</entry></row><row><entry>psnr<sub>geom </sub>= 10log<sub>10</sub>(|BBwidth||<sub>2</sub><sup>2</sup>/(d<sub>symmetric rms</sub>(V))<sup>2 </sup>)) </entry><entry>(def. 9)</entry></row><row><entry> </entry></row><row><entry><maths id="MATH-US-00019" num="00019"><math overflow="scroll"> <mrow>  <mrow>   <msub>    <mi>d</mi>    <mi>y</mi>   </msub>   <mo>(</mo>   <mrow>    <msub>     <mi>V</mi>     <mrow>      <mi>o</mi>      <mo>&#x2062;</mo>      <mi>r</mi>     </mrow>    </msub>    <mo>,</mo>    <mtext>&#x205f;</mtext>    <msub>     <mi>V</mi>     <mi>deg</mi>    </msub>   </mrow>   <mo>)</mo>  </mrow>  <mo>=</mo>  <msqrt>   <mrow>    <mfrac>     <mn>1</mn>     <mi>K</mi>    </mfrac>    <mo>&#x2062;</mo>    <mrow>     <munder>      <mo>&#x2211;</mo>      <mrow>       <mi>vo</mi>       <mo>&#x2208;</mo>       <mi>Vor</mi>      </mrow>     </munder>     <msup>      <mrow>       <mo>[</mo>       <mrow>        <mo>[</mo>        <mrow>         <mrow>          <mi>y</mi>          <mo>&#x2061;</mo>          <mo>(</mo>          <mi>vo</mi>          <mo>)</mo>         </mrow>         <mo>-</mo>         <mrow>          <mi>y</mi>          <mo>(</mo>          <msub>           <mi>v</mi>           <msub>            <mi>dnearest</mi>            <mi>neighbour</mi>           </msub>          </msub>         </mrow>        </mrow>        <mo>]</mo>       </mrow>       <mo>]</mo>      </mrow>      <mn>2</mn>     </msup>    </mrow>   </mrow>  </msqrt> </mrow></math></maths></entry><entry>(def.10)</entry></row><row><entry> </entry></row><row><entry>psnr<sub>y </sub>= 10log<sub>10</sub>(|255 ||<sup>2</sup>/(d<sub>y</sub>(V<sub>or</sub>, V<sub>deg</sub>)<sup>2</sup>) </entry><entry>(def. 11)</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0296" num="0371">In some embodiments, additional metrics that define the performance of a codec are outlined below in Table 4.</p><p id="p-0297" num="0000"><tables id="TABLE-US-00006" num="00006"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 4</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Additional Performance Metrics</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="91pt" align="left"/><colspec colname="2" colwidth="168pt" align="left"/><tbody valign="top"><row><entry>Compressed size</entry><entry>Complete compressed mesh size</entry></row><row><entry>In point count</entry><entry>K, the number of vertices in Vor</entry></row><row><entry>Out point count</entry><entry>N, number of vertices in Vdeg</entry></row><row><entry>Bytes_geometry_layer</entry><entry>Number of bytes for encoding the vertex positions</entry></row><row><entry>Bytes_color_layer (opt)</entry><entry>Number of bytes for encoding the colour attributes</entry></row><row><entry>Bytes_att_layer (opt)</entry><entry>Number of bytes for encoding the other attributes</entry></row><row><entry>Encoder time (opt)</entry><entry>Encoder time in ms on commodity hardware (optional)</entry></row><row><entry>Decoder time (opt)</entry><entry>Decoder time in ms on commodity hardware (optional)</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0036" level="1">Example Closed Form Solution</heading><p id="p-0298" num="0372">For each point P<sub>rec</sub>(i) in the reconstructed point cloud, let Q*(i) be its nearest neighbor in the original point cloud. For each point P<sub>rec</sub>(i) in the reconstructed point cloud, let (Q<sup>+</sup>(i,h))<sub>h&#x2208;{1, . . . , H(i)}</sub> be the set of point in the original point cloud that share P<sub>rec</sub>(i) as their nearest neighbor in the reconstructed point cloud. Let <img id="CUSTOM-CHARACTER-00027" he="3.22mm" wi="2.12mm" file="US20230005188A1-20230105-P00007.TIF" alt="custom-character" img-content="character" img-format="tif"/><sup>+</sup>(i) be the centroid of (Q<sup>+</sup>(i,h))<sub>h&#x2208;{1, . . . , H(i)}</sub>.</p><p id="p-0299" num="0000">If H=0, then C(P<sub>rec</sub>(i))=C(Q*(i))</p><p id="p-0300" num="0373">Denote as R-G-B vector C(P) associated with a given point P. In order to compute the color for a given P<sub>rec</sub>(i), we have the following formulation:</p><p id="p-0301" num="0000"><maths id="MATH-US-00020" num="00020"><math overflow="scroll"> <mrow>  <munder>   <mi>argmin</mi>   <mrow>    <mi>C</mi>    <mo>&#x2061;</mo>    <mo>(</mo>    <mrow>     <msub>      <mi>P</mi>      <mi>rec</mi>     </msub>     <mo>(</mo>     <mi>i</mi>     <mo>)</mo>    </mrow>    <mo>)</mo>   </mrow>  </munder>  <mo>&#x2062;</mo>  <mi>max</mi>  <mo>&#x2062;</mo>  <mrow>   <mo>{</mo>   <mrow>    <mrow>     <mfrac>      <mn>1</mn>      <msub>       <mi>N</mi>       <mrow>        <mi>r</mi>        <mo>&#x2062;</mo>        <mi>e</mi>        <mo>&#x2062;</mo>        <mi>c</mi>       </mrow>      </msub>     </mfrac>     <mo>&#x2062;</mo>     <msup>      <mrow>       <mo>&#xf605;</mo>       <mrow>        <mrow>         <mi>C</mi>         <mo>&#x2061;</mo>         <mo>(</mo>         <mrow>          <msub>           <mi>P</mi>           <mi>rec</mi>          </msub>          <mo>(</mo>          <mi>i</mi>          <mo>)</mo>         </mrow>         <mo>)</mo>        </mrow>        <mo>-</mo>        <mrow>         <mi>C</mi>         <mo>&#x2061;</mo>         <mo>(</mo>         <mrow>          <msup>           <mi>Q</mi>           <mo>*</mo>          </msup>          <mo>(</mo>          <mi>i</mi>          <mo>)</mo>         </mrow>         <mo>)</mo>        </mrow>       </mrow>       <mo>&#xf606;</mo>      </mrow>      <mn>2</mn>     </msup>    </mrow>    <mo>,</mo>    <mrow>     <mfrac>      <mn>1</mn>      <mi>N</mi>     </mfrac>     <mo>&#x2062;</mo>     <mrow>      <munderover>       <mo>&#x2211;</mo>       <mrow>        <mi>h</mi>        <mo>=</mo>        <mn>1</mn>       </mrow>       <mi>H</mi>      </munderover>      <msup>       <mrow>        <mo>&#xf605;</mo>        <mrow>         <mrow>          <mi>C</mi>          <mo>&#x2061;</mo>          <mo>(</mo>          <mrow>           <msub>            <mi>P</mi>            <mi>rec</mi>           </msub>           <mo>(</mo>           <mi>i</mi>           <mo>)</mo>          </mrow>          <mo>)</mo>         </mrow>         <mo>-</mo>         <mrow>          <mi>C</mi>          <mo>&#x2061;</mo>          <mo>(</mo>          <mrow>           <msup>            <mi>Q</mi>            <mo>+</mo>           </msup>           <mo>(</mo>           <mrow>            <mi>i</mi>            <mo>,</mo>            <mi>h</mi>           </mrow>           <mo>)</mo>          </mrow>          <mo>)</mo>         </mrow>        </mrow>        <mo>&#xf606;</mo>       </mrow>       <mn>2</mn>      </msup>     </mrow>    </mrow>   </mrow>   <mo>}</mo>  </mrow> </mrow></math></maths><maths id="MATH-US-00020-2" num="00020.2"><math overflow="scroll"> <mrow>  <mrow>   <mi>Where</mi>   <mo>&#x2062;</mo>   <mtext>   </mtext>   <mi>max</mi>   <mo>&#x2062;</mo>   <mrow>    <mo>{</mo>    <mrow>     <mrow>      <mfrac>       <mn>1</mn>       <msub>        <mi>N</mi>        <mrow>         <mi>r</mi>         <mo>&#x2062;</mo>         <mi>e</mi>         <mo>&#x2062;</mo>         <mi>c</mi>        </mrow>       </msub>      </mfrac>      <mo>&#x2062;</mo>      <msup>       <mrow>        <mo>&#xf605;</mo>        <mrow>         <mrow>          <mi>C</mi>          <mo>&#x2061;</mo>          <mo>(</mo>          <mrow>           <msub>            <mi>P</mi>            <mi>rec</mi>           </msub>           <mo>(</mo>           <mi>i</mi>           <mo>)</mo>          </mrow>          <mo>)</mo>         </mrow>         <mo>-</mo>         <mrow>          <mi>C</mi>          <mo>&#x2061;</mo>          <mo>(</mo>          <mrow>           <msup>            <mi>Q</mi>            <mo>*</mo>           </msup>           <mo>(</mo>           <mi>i</mi>           <mo>)</mo>          </mrow>          <mo>)</mo>         </mrow>        </mrow>        <mo>&#xf606;</mo>       </mrow>       <mn>2</mn>      </msup>     </mrow>     <mo>,</mo>     <mrow>      <munderover>       <mo>&#x2211;</mo>       <mrow>        <mi>h</mi>        <mo>=</mo>        <mn>1</mn>       </mrow>       <mi>H</mi>      </munderover>      <msup>       <mrow>        <mo>&#xf605;</mo>        <mrow>         <mrow>          <mi>C</mi>          <mo>&#x2061;</mo>          <mo>(</mo>          <mrow>           <msub>            <mi>P</mi>            <mi>rec</mi>           </msub>           <mo>(</mo>           <mi>i</mi>           <mo>)</mo>          </mrow>          <mo>)</mo>         </mrow>         <mo>-</mo>         <mrow>          <mi>C</mi>          <mo>&#x2061;</mo>          <mo>(</mo>          <mrow>           <msup>            <mi>&#x211a;</mi>            <mo>+</mo>           </msup>           <mo>(</mo>           <mi>i</mi>           <mo>)</mo>          </mrow>          <mo>)</mo>         </mrow>         <mo>+</mo>         <mrow>          <mi>C</mi>          <mo>&#x2061;</mo>          <mo>(</mo>          <mrow>           <msup>            <mi>&#x211a;</mi>            <mo>+</mo>           </msup>           <mo>(</mo>           <mi>i</mi>           <mo>)</mo>          </mrow>          <mo>)</mo>         </mrow>         <mo>-</mo>         <mrow>          <mi>C</mi>          <mo>&#x2061;</mo>          <mo>(</mo>          <mrow>           <msup>            <mi>Q</mi>            <mo>+</mo>           </msup>           <mo>(</mo>           <mrow>            <mi>i</mi>            <mo>,</mo>            <mi>h</mi>           </mrow>           <mo>)</mo>          </mrow>          <mo>)</mo>         </mrow>        </mrow>        <mo>&#xf606;</mo>       </mrow>       <mn>2</mn>      </msup>     </mrow>    </mrow>    <mo>}</mo>   </mrow>  </mrow>  <mo>=</mo>  <mrow>   <mrow>    <mi>max</mi>    <mo>&#x2062;</mo>    <mrow>     <mo>{</mo>     <mrow>      <mrow>       <mfrac>        <mn>1</mn>        <msub>         <mi>N</mi>         <mrow>          <mi>r</mi>          <mo>&#x2062;</mo>          <mi>e</mi>          <mo>&#x2062;</mo>          <mi>c</mi>         </mrow>        </msub>       </mfrac>       <mo>&#x2062;</mo>       <msup>        <mrow>         <mo>&#xf605;</mo>         <mrow>          <mrow>           <mi>C</mi>           <mo>&#x2061;</mo>           <mo>(</mo>           <mrow>            <msub>             <mi>P</mi>             <mrow>              <mi>r</mi>              <mo>&#x2062;</mo>              <mi>e</mi>              <mo>&#x2062;</mo>              <mi>c</mi>             </mrow>            </msub>            <mo>(</mo>            <mi>i</mi>            <mo>)</mo>           </mrow>           <mo>)</mo>          </mrow>          <mo>-</mo>          <mrow>           <mi>C</mi>           <mo>&#x2061;</mo>           <mo>(</mo>           <mrow>            <msup>             <mi>Q</mi>             <mo>*</mo>            </msup>            <mo>(</mo>            <mi>i</mi>            <mo>)</mo>           </mrow>           <mo>)</mo>          </mrow>         </mrow>         <mo>&#xf606;</mo>        </mrow>        <mn>2</mn>       </msup>      </mrow>      <mo>,</mo>      <mrow>       <mrow>        <mfrac>         <mi>H</mi>         <mi>N</mi>        </mfrac>        <mo>&#x2062;</mo>        <msup>         <mrow>          <mo>&#xf605;</mo>          <mrow>           <mrow>            <mi>C</mi>            <mo>&#x2061;</mo>            <mo>(</mo>            <mrow>             <msub>              <mi>P</mi>              <mi>rec</mi>             </msub>             <mo>(</mo>             <mi>i</mi>             <mo>)</mo>            </mrow>            <mo>)</mo>           </mrow>           <mo>-</mo>           <mrow>            <mi>C</mi>            <mo>&#x2061;</mo>            <mo>(</mo>            <mrow>             <msup>              <mi>&#x211a;</mi>              <mo>+</mo>             </msup>             <mo>(</mo>             <mi>i</mi>             <mo>)</mo>            </mrow>            <mo>)</mo>           </mrow>          </mrow>          <mo>&#xf606;</mo>         </mrow>         <mn>2</mn>        </msup>       </mrow>       <mo>+</mo>       <mrow>        <mfrac>         <mn>1</mn>         <mi>N</mi>        </mfrac>        <mo>&#x2062;</mo>        <mrow>         <munderover>          <mo>&#x2211;</mo>          <mrow>           <mi>h</mi>           <mo>=</mo>           <mn>1</mn>          </mrow>          <mi>H</mi>         </munderover>         <msup>          <mrow>           <mo>&#xf605;</mo>           <mrow>            <mrow>             <mi>C</mi>             <mo>&#x2061;</mo>             <mo>(</mo>             <mrow>              <msup>               <mi>&#x211a;</mi>               <mo>+</mo>              </msup>              <mo>(</mo>              <mi>i</mi>              <mo>)</mo>             </mrow>             <mo>)</mo>            </mrow>            <mo>-</mo>            <mrow>             <mi>C</mi>             <mo>&#x2061;</mo>             <mo>(</mo>             <mrow>              <msup>               <mi>Q</mi>               <mo>+</mo>              </msup>              <mo>(</mo>              <mrow>               <mi>i</mi>               <mo>,</mo>               <mtext>&#x205f;</mtext>               <mi>h</mi>              </mrow>              <mo>)</mo>             </mrow>             <mo>)</mo>            </mrow>           </mrow>           <mo>&#xf606;</mo>          </mrow>          <mn>2</mn>         </msup>        </mrow>       </mrow>       <mo>+</mo>       <mrow>        <mfrac>         <mn>2</mn>         <mi>N</mi>        </mfrac>        <mo>&#x2062;</mo>        <mrow>         <munderover>          <mo>&#x2211;</mo>          <mrow>           <mi>h</mi>           <mo>=</mo>           <mn>1</mn>          </mrow>          <mi>H</mi>         </munderover>         <mrow>          <mo>&#x2329;</mo>          <mrow>           <mrow>            <mrow>             <mi>C</mi>             <mo>&#x2061;</mo>             <mo>(</mo>             <mrow>              <msub>               <mi>P</mi>               <mrow>                <mi>r</mi>                <mo>&#x2062;</mo>                <mi>e</mi>                <mo>&#x2062;</mo>                <mi>c</mi>               </mrow>              </msub>              <mo>(</mo>              <mi>i</mi>              <mo>)</mo>             </mrow>             <mo>)</mo>            </mrow>            <mo>-</mo>            <mrow>             <mi>C</mi>             <mo>&#x2061;</mo>             <mo>(</mo>             <mrow>              <msup>               <mi>&#x211a;</mi>               <mo>+</mo>              </msup>              <mo>(</mo>              <mi>i</mi>              <mo>)</mo>             </mrow>             <mo>)</mo>            </mrow>           </mrow>           <mo>,</mo>           <mrow>            <mrow>             <mi>C</mi>             <mo>&#x2061;</mo>             <mo>(</mo>             <mrow>              <msup>               <mi>&#x211a;</mi>               <mo>+</mo>              </msup>              <mo>(</mo>              <mi>i</mi>              <mo>)</mo>             </mrow>             <mo>)</mo>            </mrow>            <mo>-</mo>            <mrow>             <mi>C</mi>             <mo>&#x2061;</mo>             <mo>(</mo>             <mrow>              <msup>               <mi>Q</mi>               <mo>+</mo>              </msup>              <mo>(</mo>              <mrow>               <mi>i</mi>               <mo>,</mo>               <mi>h</mi>              </mrow>              <mo>)</mo>             </mrow>             <mo>)</mo>            </mrow>           </mrow>          </mrow>          <mo>&#x232a;</mo>         </mrow>        </mrow>       </mrow>      </mrow>     </mrow>     <mo>}</mo>    </mrow>   </mrow>   <mo>=</mo>   <mrow>    <mi>max</mi>    <mo>&#x2062;</mo>    <mrow>     <mo>{</mo>     <mrow>      <mrow>       <mfrac>        <mn>1</mn>        <msub>         <mi>N</mi>         <mrow>          <mi>r</mi>          <mo>&#x2062;</mo>          <mi>e</mi>          <mo>&#x2062;</mo>          <mi>c</mi>         </mrow>        </msub>       </mfrac>       <mo>&#x2062;</mo>       <msup>        <mrow>         <mo>&#xf605;</mo>         <mrow>          <mrow>           <mi>C</mi>           <mo>&#x2061;</mo>           <mo>(</mo>           <mrow>            <msub>             <mi>P</mi>             <mrow>              <mi>r</mi>              <mo>&#x2062;</mo>              <mi>e</mi>              <mo>&#x2062;</mo>              <mi>c</mi>             </mrow>            </msub>            <mo>(</mo>            <mi>i</mi>            <mo>)</mo>           </mrow>           <mo>)</mo>          </mrow>          <mo>-</mo>          <mrow>           <mi>C</mi>           <mo>&#x2061;</mo>           <mo>(</mo>           <mrow>            <msup>             <mi>Q</mi>             <mo>*</mo>            </msup>            <mo>(</mo>            <mi>i</mi>            <mo>)</mo>           </mrow>           <mo>)</mo>          </mrow>         </mrow>         <mo>&#xf606;</mo>        </mrow>        <mn>2</mn>       </msup>      </mrow>      <mo>,</mo>      <mrow>       <mrow>        <mfrac>         <mi>H</mi>         <mi>N</mi>        </mfrac>        <mo>&#x2062;</mo>        <msup>         <mrow>          <mo>&#xf605;</mo>          <mrow>           <mrow>            <mi>C</mi>            <mo>&#x2061;</mo>            <mo>(</mo>            <mrow>             <msub>              <mi>P</mi>              <mi>rec</mi>             </msub>             <mo>(</mo>             <mi>i</mi>             <mo>)</mo>            </mrow>            <mo>)</mo>           </mrow>           <mo>-</mo>           <mrow>            <mi>C</mi>            <mo>&#x2061;</mo>            <mo>(</mo>            <mrow>             <msup>              <mi>&#x211a;</mi>              <mo>+</mo>             </msup>             <mo>(</mo>             <mi>i</mi>             <mo>)</mo>            </mrow>            <mo>)</mo>           </mrow>          </mrow>          <mo>&#xf606;</mo>         </mrow>         <mn>2</mn>        </msup>       </mrow>       <mo>+</mo>       <mrow>        <mfrac>         <mn>1</mn>         <mi>N</mi>        </mfrac>        <mo>&#x2062;</mo>        <mrow>         <munderover>          <mo>&#x2211;</mo>          <mrow>           <mi>h</mi>           <mo>=</mo>           <mn>1</mn>          </mrow>          <mi>H</mi>         </munderover>         <msup>          <mrow>           <mo>&#xf605;</mo>           <mrow>            <mrow>             <mi>C</mi>             <mo>&#x2061;</mo>             <mo>(</mo>             <mrow>              <msup>               <mi>&#x211a;</mi>               <mo>+</mo>              </msup>              <mo>(</mo>              <mi>i</mi>              <mo>)</mo>             </mrow>             <mo>)</mo>            </mrow>            <mo>-</mo>            <mrow>             <mi>C</mi>             <mo>&#x2061;</mo>             <mo>(</mo>             <mrow>              <msup>               <mi>Q</mi>               <mo>+</mo>              </msup>              <mo>(</mo>              <mrow>               <mi>i</mi>               <mo>,</mo>               <mi>h</mi>              </mrow>              <mo>)</mo>             </mrow>             <mo>)</mo>            </mrow>           </mrow>           <mo>&#xf606;</mo>          </mrow>          <mn>2</mn>         </msup>        </mrow>       </mrow>      </mrow>     </mrow>     <mo>}</mo>    </mrow>   </mrow>  </mrow> </mrow></math></maths><maths id="MATH-US-00020-3" num="00020.3"><math overflow="scroll"> <mrow>  <mrow>   <mrow>    <mi>Now</mi>    <mo>&#x2062;</mo>    <mtext>   </mtext>    <mi>denote</mi>    <mo>&#x2062;</mo>    <mtext>   </mtext>    <msup>     <mi>D</mi>     <mn>2</mn>    </msup>   </mrow>   <mo>=</mo>   <mrow>    <msubsup>     <mo>&#x2211;</mo>     <mrow>      <mi>h</mi>      <mo>=</mo>      <mn>1</mn>     </mrow>     <mi>H</mi>    </msubsup>    <msup>     <mrow>      <mo>&#xf605;</mo>      <mrow>       <mrow>        <mi>C</mi>        <mo>&#x2061;</mo>        <mo>(</mo>        <mrow>         <msup>          <mi>&#x211a;</mi>          <mo>+</mo>         </msup>         <mo>(</mo>         <mi>i</mi>         <mo>)</mo>        </mrow>        <mo>)</mo>       </mrow>       <mo>-</mo>       <mrow>        <mi>C</mi>        <mo>&#x2061;</mo>        <mo>(</mo>        <mrow>         <msup>          <mi>Q</mi>          <mo>+</mo>         </msup>         <mo>(</mo>         <mrow>          <mi>i</mi>          <mo>,</mo>          <mi>h</mi>         </mrow>         <mo>)</mo>        </mrow>        <mo>)</mo>       </mrow>      </mrow>      <mo>&#xf606;</mo>     </mrow>     <mn>2</mn>    </msup>   </mrow>  </mrow>  <mo>,</mo>  <mrow>   <mi>so</mi>   <mo>&#x2062;</mo>   <mtext>   </mtext>   <mi>that</mi>   <mo>&#x2062;</mo>   <mtext>   </mtext>   <munder>    <mi>argmin</mi>    <mrow>     <mi>C</mi>     <mo>&#x2061;</mo>     <mo>(</mo>     <mrow>      <msub>       <mi>P</mi>       <mi>rec</mi>      </msub>      <mo>(</mo>      <mi>i</mi>      <mo>)</mo>     </mrow>     <mo>)</mo>    </mrow>   </munder>   <mo>&#x2062;</mo>   <mi>max</mi>   <mo>&#x2062;</mo>   <mrow>    <mrow>     <mo>{</mo>     <mrow>      <mrow>       <mfrac>        <mn>1</mn>        <msub>         <mi>N</mi>         <mrow>          <mi>r</mi>          <mo>&#x2062;</mo>          <mi>e</mi>          <mo>&#x2062;</mo>          <mi>c</mi>         </mrow>        </msub>       </mfrac>       <mo>&#x2062;</mo>       <msup>        <mrow>         <mo>&#xf605;</mo>         <mrow>          <mrow>           <mi>C</mi>           <mo>&#x2061;</mo>           <mo>(</mo>           <mrow>            <msub>             <mi>P</mi>             <mi>rec</mi>            </msub>            <mo>(</mo>            <mi>i</mi>            <mo>)</mo>           </mrow>           <mo>)</mo>          </mrow>          <mo>-</mo>          <mrow>           <mi>C</mi>           <mo>&#x2061;</mo>           <mo>(</mo>           <mrow>            <msup>             <mi>Q</mi>             <mo>*</mo>            </msup>            <mo>(</mo>            <mi>i</mi>            <mo>)</mo>           </mrow>           <mo>)</mo>          </mrow>         </mrow>         <mo>&#xf606;</mo>        </mrow>        <mn>2</mn>       </msup>      </mrow>      <mo>,</mo>      <mrow>       <mrow>        <mfrac>         <mi>H</mi>         <mi>N</mi>        </mfrac>        <mo>&#x2062;</mo>        <msup>         <mrow>          <mo>&#xf605;</mo>          <mrow>           <mrow>            <mi>C</mi>            <mo>&#x2061;</mo>            <mo>(</mo>            <mrow>             <msub>              <mi>P</mi>              <mrow>               <mi>r</mi>               <mo>&#x2062;</mo>               <mi>e</mi>               <mo>&#x2062;</mo>               <mi>c</mi>              </mrow>             </msub>             <mo>(</mo>             <mi>i</mi>             <mo>)</mo>            </mrow>            <mo>)</mo>           </mrow>           <mo>-</mo>           <mrow>            <mi>C</mi>            <mo>&#x2061;</mo>            <mo>(</mo>            <mrow>             <msup>              <mi>&#x211a;</mi>              <mo>+</mo>             </msup>             <mo>(</mo>             <mi>i</mi>             <mo>)</mo>            </mrow>            <mo>)</mo>           </mrow>          </mrow>          <mo>&#xf606;</mo>         </mrow>         <mn>2</mn>        </msup>       </mrow>       <mo>+</mo>       <mfrac>        <msup>         <mi>D</mi>         <mn>2</mn>        </msup>        <mi>N</mi>       </mfrac>      </mrow>     </mrow>     <mo>}</mo>    </mrow>    <mo>.</mo>   </mrow>  </mrow> </mrow></math></maths></p><p id="p-0302" num="0374">Note: if H=1 then D<sup>2</sup>=0</p><p id="p-0303" num="0375">Let C<sup>0</sup>(P<sub>rec</sub>(i)) be a solution of the previous minimization problem. It can be shown that C<sup>0</sup>(P<sub>rec </sub>(i)) could be expressed as:</p><p id="p-0304" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>C</i><sup>0</sup>(<i>P</i><sub>rec</sub>(<i>i</i>))=<i>wC</i>(<i>Q</i>*(<i>i</i>))+(1&#x2212;<i>w</i>)<i>C</i>(<img id="CUSTOM-CHARACTER-00028" he="3.22mm" wi="2.12mm" file="US20230005188A1-20230105-P00008.TIF" alt="custom-character" img-content="character" img-format="tif"/><sup>+</sup>(<i>i</i>))<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0305" num="0376">Furthermore, C<sup>0</sup>(P<sub>rec </sub>(i)) verifies:</p><p id="p-0306" num="0000"><maths id="MATH-US-00021" num="00021"><math overflow="scroll"> <mrow>  <mrow>   <mfrac>    <mn>1</mn>    <msub>     <mi>N</mi>     <mrow>      <mi>r</mi>      <mo>&#x2062;</mo>      <mi>e</mi>      <mo>&#x2062;</mo>      <mi>c</mi>     </mrow>    </msub>   </mfrac>   <mo>&#x2062;</mo>   <msup>    <mrow>     <mo>&#xf605;</mo>     <mrow>      <mrow>       <mi>wC</mi>       <mo>&#x2061;</mo>       <mo>(</mo>       <mrow>        <msup>         <mi>Q</mi>         <mo>*</mo>        </msup>        <mo>(</mo>        <mi>i</mi>        <mo>)</mo>       </mrow>       <mo>)</mo>      </mrow>      <mo>+</mo>      <mrow>       <mrow>        <mo>(</mo>        <mrow>         <mn>1</mn>         <mo>-</mo>         <mi>w</mi>        </mrow>        <mo>)</mo>       </mrow>       <mo>&#x2062;</mo>       <mrow>        <mi>C</mi>        <mo>&#x2061;</mo>        <mo>(</mo>        <mrow>         <msup>          <mi>&#x211a;</mi>          <mo>+</mo>         </msup>         <mo>(</mo>         <mi>i</mi>         <mo>)</mo>        </mrow>        <mo>)</mo>       </mrow>      </mrow>      <mo>-</mo>      <mrow>       <mi>C</mi>       <mo>&#x2061;</mo>       <mo>(</mo>       <mrow>        <msup>         <mi>Q</mi>         <mo>*</mo>        </msup>        <mo>(</mo>        <mi>i</mi>        <mo>)</mo>       </mrow>       <mo>)</mo>      </mrow>     </mrow>     <mo>&#xf606;</mo>    </mrow>    <mn>2</mn>   </msup>  </mrow>  <mo>=</mo>  <mrow>   <mrow>    <mfrac>     <mi>H</mi>     <mi>N</mi>    </mfrac>    <mo>&#x2062;</mo>    <msup>     <mrow>      <mo>&#xf605;</mo>      <mrow>       <mrow>        <mi>wC</mi>        <mo>&#x2061;</mo>        <mo>(</mo>        <mrow>         <msup>          <mi>Q</mi>          <mo>*</mo>         </msup>         <mo>(</mo>         <mi>i</mi>         <mo>)</mo>        </mrow>        <mo>)</mo>       </mrow>       <mo>+</mo>       <mrow>        <mrow>         <mo>(</mo>         <mrow>          <mn>1</mn>          <mo>-</mo>          <mi>w</mi>         </mrow>         <mo>)</mo>        </mrow>        <mo>&#x2062;</mo>        <mrow>         <mi>C</mi>         <mo>&#x2061;</mo>         <mo>(</mo>         <mrow>          <msup>           <mi>&#x211a;</mi>           <mo>+</mo>          </msup>          <mo>(</mo>          <mi>i</mi>          <mo>)</mo>         </mrow>         <mo>)</mo>        </mrow>       </mrow>       <mo>-</mo>       <mrow>        <mi>C</mi>        <mo>&#x2061;</mo>        <mo>(</mo>        <mrow>         <msup>          <mi>&#x211a;</mi>          <mo>+</mo>         </msup>         <mo>(</mo>         <mi>i</mi>         <mo>)</mo>        </mrow>        <mo>)</mo>       </mrow>      </mrow>      <mo>&#xf606;</mo>     </mrow>     <mn>2</mn>    </msup>   </mrow>   <mo>+</mo>   <mfrac>    <msup>     <mi>D</mi>     <mn>2</mn>    </msup>    <mi>N</mi>   </mfrac>  </mrow> </mrow></math></maths><maths id="MATH-US-00021-2" num="00021.2"><math overflow="scroll"> <mrow>  <mrow>   <msup>    <mrow>     <mo>(</mo>     <mrow>      <mn>1</mn>      <mo>-</mo>      <mi>w</mi>     </mrow>     <mo>)</mo>    </mrow>    <mn>2</mn>   </msup>   <mo>&#x2062;</mo>   <msup>    <mrow>     <mo>&#xf605;</mo>     <mrow>      <mrow>       <mi>C</mi>       <mo>&#x2061;</mo>       <mo>(</mo>       <mrow>        <msup>         <mi>&#x211a;</mi>         <mo>+</mo>        </msup>        <mo>(</mo>        <mi>i</mi>        <mo>)</mo>       </mrow>       <mo>)</mo>      </mrow>      <mo>-</mo>      <mrow>       <mi>C</mi>       <mo>&#x2061;</mo>       <mo>(</mo>       <mrow>        <msup>         <mi>Q</mi>         <mo>*</mo>        </msup>        <mo>(</mo>        <mi>i</mi>        <mo>)</mo>       </mrow>       <mo>)</mo>      </mrow>     </mrow>     <mo>&#xf606;</mo>    </mrow>    <mn>2</mn>   </msup>  </mrow>  <mo>=</mo>  <mrow>   <mrow>    <msup>     <mi>w</mi>     <mn>2</mn>    </msup>    <mo>&#x2062;</mo>    <mfrac>     <mrow>      <mi>H</mi>      <mo>&#x2062;</mo>      <msub>       <mi>N</mi>       <mrow>        <mi>r</mi>        <mo>&#x2062;</mo>        <mi>e</mi>        <mo>&#x2062;</mo>        <mi>c</mi>       </mrow>      </msub>     </mrow>     <mi>N</mi>    </mfrac>    <mo>&#x2062;</mo>    <msup>     <mrow>      <mo>&#xf605;</mo>      <mrow>       <mrow>        <mi>C</mi>        <mo>&#x2061;</mo>        <mo>(</mo>        <mrow>         <msup>          <mi>Q</mi>          <mo>*</mo>         </msup>         <mo>(</mo>         <mi>i</mi>         <mo>)</mo>        </mrow>        <mo>)</mo>       </mrow>       <mo>-</mo>       <mrow>        <mi>C</mi>        <mo>(</mo>        <mrow>         <msup>          <mi>&#x211a;</mi>          <mo>+</mo>         </msup>         <mo>(</mo>         <mi>i</mi>         <mo>)</mo>        </mrow>       </mrow>      </mrow>      <mo>&#xf606;</mo>     </mrow>     <mn>2</mn>    </msup>   </mrow>   <mo>+</mo>   <mfrac>    <mrow>     <msup>      <mi>D</mi>      <mn>2</mn>     </msup>     <mo>&#x2062;</mo>     <msub>      <mi>N</mi>      <mrow>       <mi>r</mi>       <mo>&#x2062;</mo>       <mi>e</mi>       <mo>&#x2062;</mo>       <mi>c</mi>      </mrow>     </msub>    </mrow>    <mi>N</mi>   </mfrac>  </mrow> </mrow></math></maths><maths id="MATH-US-00021-3" num="00021.3"><math overflow="scroll"> <mrow>  <mtext>	</mtext>  <mrow>   <mrow>    <mi>Let</mi>    <mo>&#x2062;</mo>    <mtext>   </mtext>    <msup>     <mi>&#x3b4;</mi>     <mn>2</mn>    </msup>   </mrow>   <mo>=</mo>   <mrow>    <mrow>     <msup>      <mrow>       <mo>&#xf605;</mo>       <mrow>        <mrow>         <mi>C</mi>         <mo>&#x2061;</mo>         <mo>(</mo>         <mrow>          <msup>           <mi>Q</mi>           <mo>*</mo>          </msup>          <mo>(</mo>          <mi>i</mi>          <mo>)</mo>         </mrow>         <mo>)</mo>        </mrow>        <mo>-</mo>        <mrow>         <mi>C</mi>         <mo>(</mo>         <mrow>          <msup>           <mi>&#x211a;</mi>           <mo>+</mo>          </msup>          <mo>(</mo>          <mi>i</mi>          <mo>)</mo>         </mrow>        </mrow>       </mrow>       <mo>&#xf606;</mo>      </mrow>      <mn>2</mn>     </msup>     <mo>&#x2062;</mo>     <mtext>   </mtext>     <mi>and</mi>     <mo>&#x2062;</mo>     <mtext>   </mtext>     <mi>r</mi>    </mrow>    <mo>=</mo>    <mfrac>     <msub>      <mi>N</mi>      <mi>rec</mi>     </msub>     <mi>N</mi>    </mfrac>   </mrow>  </mrow> </mrow></math></maths></p><p id="p-0307" num="0000"><tables id="TABLE-US-00007" num="00007"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>If &#x3b4;<sup>2 </sup>= 0, then C(P<sub>rec</sub>(i)) = C(Q*(i)) = C(&#x2009;<img id="CUSTOM-CHARACTER-00029" he="2.79mm" wi="2.12mm" file="US20230005188A1-20230105-P00009.TIF" alt="custom-character" img-content="character" img-format="tif"/> <sup>+</sup>(i)</entry></row><row><entry>(1 &#x2212; w)<sup>2 </sup>&#x3b4;<sup>2 </sup>= w<sup>2</sup>rH&#x3b4;<sup>2 </sup>+ rD<sup>2</sup></entry></row><row><entry>&#x3b4;<sup>2 </sup>+ w2&#x3b4;<sup>2 </sup>&#x2212; 2w&#x3b4;<sup>2 </sup>= w<sup>2</sup>rH&#x3b4;<sup>2 </sup>+ rD<sup>2</sup></entry></row><row><entry>&#x3b4;<sup>2</sup>(1 &#x2212; rH)w<sup>2 </sup>&#x2212; 2&#x3b4;<sup>2</sup>w + (&#x3b4;<sup>2 </sup>&#x2212; rD<sup>2</sup>) = 0</entry></row><row><entry>(rH &#x2212; 1)w<sup>2 </sup>+ 2w + (&#x3b1;r &#x2212; 1) = 0</entry></row><row><entry> </entry></row><row><entry><maths id="MATH-US-00022" num="00022"><math overflow="scroll"> <mrow>  <mi>With</mi>  <mo>&#x2062;</mo>  <mtext>   </mtext>  <mrow>   <mi>&#x3b1;</mi>   <mo>=</mo>   <mfrac>    <msup>     <mi>D</mi>     <mn>2</mn>    </msup>    <msup>     <mi>&#x3b4;</mi>     <mn>2</mn>    </msup>   </mfrac>  </mrow> </mrow></math></maths></entry></row><row><entry> </entry></row><row><entry><maths id="MATH-US-00023" num="00023"><math overflow="scroll"> <mrow>  <mrow>   <mi>if</mi>   <mtext>   </mtext>   <mrow>    <mi>H</mi>    <mtext>=1</mtext>   </mrow>  </mrow>  <mo>,</mo>  <mrow>   <mrow>    <mi>then</mi>    <mo>&#x2062;</mo>    <mtext>   </mtext>    <mi>w</mi>   </mrow>   <mo>=</mo>   <mfrac>    <mn>1</mn>    <mn>2</mn>   </mfrac>  </mrow> </mrow></math></maths></entry></row><row><entry> </entry></row><row><entry>if H &#x3e; l</entry></row><row><entry>&#x394; = 4 &#x2212; 4(rH &#x2212; 1)(&#x3b1;r &#x2212; 1)</entry></row><row><entry>&#x394; = 4 &#x2212; 4 (rH &#x2212; 1)&#x3b1;r + 4 H &#x2212; 4</entry></row><row><entry>&#x394; = 4(H &#x2212; (rH &#x2212; 1)&#x3b1;r)</entry></row><row><entry>If &#x394; = 0</entry></row><row><entry> </entry></row><row><entry><maths id="MATH-US-00024" num="00024"><math overflow="scroll"> <mrow>  <mi>w</mi>  <mo>=</mo>  <mfrac>   <mrow>    <mo>-</mo>    <mn>1</mn>   </mrow>   <mrow>    <mo>(</mo>    <mrow>     <mrow>      <mi>r</mi>      <mo>&#x2062;</mo>      <mi>H</mi>     </mrow>     <mo>-</mo>     <mn>1</mn>    </mrow>    <mo>)</mo>   </mrow>  </mfrac> </mrow></math></maths></entry></row><row><entry> </entry></row><row><entry>If &#x394; &#x3e; 0</entry></row><row><entry> </entry></row><row><entry><maths id="MATH-US-00025" num="00025"><math overflow="scroll"> <mrow>  <mrow>   <mi>w</mi>   <mo>&#x2062;</mo>   <mn>1</mn>  </mrow>  <mo>=</mo>  <mfrac>   <mrow>    <mrow>     <mo>-</mo>     <mn>1</mn>    </mrow>    <mo>-</mo>    <msqrt>     <mrow>      <mo>(</mo>      <mrow>       <mi>H</mi>       <mo>-</mo>       <mrow>        <mrow>         <mo>(</mo>         <mrow>          <mrow>           <mi>H</mi>           <mo>&#x2062;</mo>           <mi>r</mi>          </mrow>          <mo>-</mo>          <mn>1</mn>         </mrow>         <mo>)</mo>        </mrow>        <mo>&#x2062;</mo>        <mi>&#x3b1;</mi>        <mo>&#x2062;</mo>        <mi>r</mi>       </mrow>      </mrow>      <mo>)</mo>     </mrow>    </msqrt>   </mrow>   <mrow>    <mo>(</mo>    <mrow>     <mrow>      <mi>r</mi>      <mo>&#x2062;</mo>      <mi>H</mi>     </mrow>     <mo>-</mo>     <mn>1</mn>    </mrow>    <mo>)</mo>   </mrow>  </mfrac> </mrow></math></maths></entry></row><row><entry> </entry></row><row><entry><maths id="MATH-US-00026" num="00026"><math overflow="scroll"> <mrow>  <mrow>   <mi>w</mi>   <mo>&#x2062;</mo>   <mn>2</mn>  </mrow>  <mo>=</mo>  <mfrac>   <mrow>    <mrow>     <mo>-</mo>     <mn>1</mn>    </mrow>    <mo>+</mo>    <msqrt>     <mrow>      <mo>(</mo>      <mrow>       <mi>H</mi>       <mo>-</mo>       <mrow>        <mrow>         <mo>(</mo>         <mrow>          <mrow>           <mi>H</mi>           <mo>&#x2062;</mo>           <mi>r</mi>          </mrow>          <mo>-</mo>          <mn>1</mn>         </mrow>         <mo>)</mo>        </mrow>        <mo>&#x2062;</mo>        <mi>&#x3b1;</mi>        <mo>&#x2062;</mo>        <mi>r</mi>       </mrow>      </mrow>      <mo>)</mo>     </mrow>    </msqrt>   </mrow>   <mrow>    <mo>(</mo>    <mrow>     <mrow>      <mi>r</mi>      <mo>&#x2062;</mo>      <mi>H</mi>     </mrow>     <mo>-</mo>     <mn>1</mn>    </mrow>    <mo>)</mo>   </mrow>  </mfrac> </mrow></math></maths></entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0308" num="0377">Where the cost C(i) is computed for both w1 and w2 and the value that leads to the minimum cost is retained as the final solution.</p><heading id="h-0037" level="2">Compression/Decompression Using Multiple Resolutions</heading><p id="p-0309" num="0378"><figref idref="DRAWINGS">FIG. <b>5</b>A</figref> illustrates components of an encoder that includes geometry, texture, and/or attribute downscaling, according to some embodiments. Any of the encoders described herein may further include a spatial down-scaler component <b>502</b>, a texture down-scaler component <b>504</b>, and/or an attribute down-scaler component <b>506</b> as shown for encoder <b>500</b> in <figref idref="DRAWINGS">FIG. <b>5</b>A</figref>. For example, encoder <b>200</b> illustrated in <figref idref="DRAWINGS">FIG. <b>2</b>A</figref> may further include downscaling components as described in <figref idref="DRAWINGS">FIG. <b>5</b>A</figref>. In some embodiments, encoder <b>250</b> may further include downscaling components as described in <figref idref="DRAWINGS">FIG. <b>5</b>A</figref>.</p><p id="p-0310" num="0379">In some embodiments, an encoder that includes downscaling components, such as geometry down-scaler <b>502</b>, texture down-scaler <b>504</b>, and/or attribute down-scaler <b>506</b>, may further include a geometry up-scaler, such as spatial up-scaler <b>508</b>, and a smoothing filter, such as smoothing filter <b>510</b>. In some embodiments, a reconstructed geometry image is generated from compressed patch images, compressed by video compression module <b>218</b>. In some embodiments an encoder may further include a geometry reconstruction module (not shown) to generate the reconstructed geometry image. The reconstructed geometry image may be used to encode and/or improve encoding of an occupancy map that indicates patch locations for patches included in one or more frame images. Additionally, the reconstructed geometry image may be provided to a geometry up-scaler, such as spatial up-scaler <b>508</b>. A geometry up-scaler may scale the reconstructed geometry image up to an original resolution or a higher resolution approximating the original resolution of the geometry image, wherein the original resolution is a resolution prior to downscaling being performed at spatial down-scaler <b>502</b>. In some embodiments, the up-scaled reconstructed geometry image may be provided to a smoothing filter that generates a smoothed image of the reconstructed and up-scaled geometry image. The smoothing filter, such as smoothing filter <b>510</b>, may approximate smoothing that would be applied via a smoothing filter of a decoder. This information may then be provided to the spatial image generation module <b>210</b>, texture image generation module <b>212</b>, and/or the attribute image generation module <b>214</b>. These modules may adjust generation of spatial images, texture images, and/or other attribute images based on the reconstructed geometry images. For example, if a patch shape (e.g. geometry) is slightly distorted during the downscaling, encoding, decoding, and upscaling process, these changes may be taken into account when generating spatial images, texture images, and/or other attribute images to correct for the changes in patch shape (e.g. distortion). As an example, points of the point cloud represented in the reconstructed geometry image may be slightly moved as compared to the locations of the points in the original geometry image. In such circumstances, a texture image generation module, as an example, may take into account these distortions and adjust texture values assigned to the points of a corresponding texture image patch accordingly.</p><p id="p-0311" num="0380"><figref idref="DRAWINGS">FIG. <b>5</b>B</figref> illustrates components of a decoder <b>520</b> that includes geometry, texture, and/or other attribute upscaling, according to some embodiments. For example, decoder <b>520</b> includes texture up-scaler <b>512</b>, attribute up-scaler <b>514</b>, and spatial up-scaler <b>516</b>. Any of the decoders described herein may further include a texture up-scaler component <b>512</b>, an attribute up-scaler component <b>514</b>, and/or a spatial image up-scaler component <b>516</b> as shown for decoder <b>520</b> in <figref idref="DRAWINGS">FIG. <b>5</b>B</figref>.</p><p id="p-0312" num="0381"><figref idref="DRAWINGS">FIG. <b>5</b>C</figref> illustrates rescaling from the perspective of an encoder, according to some embodiments. In some embodiments, a point cloud may be scaled in both the point cloud domain (e.g. 3D domain prior to patch projection) and in a video level domain (e.g. by scaling 2D image frames comprising patch information). For example <figref idref="DRAWINGS">FIG. <b>5</b>C</figref> illustrates a point cloud <b>522</b> of a person. An encoder, such as encoder <b>500</b>, performs 3D scaling of the point cloud <b>522</b> in the point cloud domain to generate a downscaled point cloud <b>524</b>. Patches generated based on downscaled point cloud <b>524</b> are packed into image frame <b>526</b>. Additionally, downscaling is performed on the image frame <b>526</b> at the video level to reduce a resolution of the image frame. The additional downscaling results in a downscaled image frame <b>528</b> that is then encoded into a bit stream <b>530</b>.</p><p id="p-0313" num="0382"><figref idref="DRAWINGS">FIG. <b>5</b>D</figref> illustrates rescaling from the perspective of a decoder, according to some embodiments. In some embodiments, a decoder, such as decoder <b>520</b>, may receive a bit stream, such as bit stream <b>530</b>. The decoder may decode the video encoded bit stream to generate one or more video image frames, such as image frame <b>532</b>. The decoder may further upscale the image frame <b>532</b> to generate an up-scaled image frame <b>534</b>. The decoder may then use a patch reconstruction method, as described above, to generate a reconstructed point cloud <b>536</b> from the patch information included in the up-scaled image frame <b>534</b>. The decoder may also perform up-scaling in the 3D point cloud domain to scale up the reconstructed point cloud <b>536</b> to a similar size as the original point cloud. This process may result in an up-scaled reconstructed point cloud <b>538</b>.</p><p id="p-0314" num="0383"><figref idref="DRAWINGS">FIG. <b>5</b>E</figref> illustrates an example open loop rescaling, according to some embodiments. In an open loop rescaling of an image frame, a geometry plane, and a texture or other attribute plane may be independently scaled, where geometry distortion is not taken into account when scaling the texture or other attribute information. For example, geometry image frame <b>540</b> may indicate depths of points of a point cloud relative to a projection plane and texture or attribute image frame <b>544</b> may represent respective attributes of the points of the point cloud projected on to the projection plane. As shown in <figref idref="DRAWINGS">FIG. <b>5</b>E</figref>, in an open loop rescaling process, the geometry information and the attribute information may be independently scaled to generate down-scaled geometry image frame <b>542</b> and down-scaled texture or attribute image frame <b>546</b>, respectively. Also, as shown in <figref idref="DRAWINGS">FIG. <b>5</b>E</figref>, the downscaled geometry image frame <b>542</b> may be video encoded/compressed to generate a geometry bit stream and the downscaled attribute image frame <b>546</b> may be video encoded/compressed to generate a texture or attribute bit stream, such as a texture/attribute bit stream. For example, spatial down-scaler <b>502</b> may downscale the geometry image frame <b>540</b> and the texture down-scaler <b>504</b> may independently downscale the texture image frame <b>544</b>. In some embodiments, attribute down-scaler <b>506</b> may downscale an attribute image frame independently of spatial down-scaler <b>502</b> and texture down-scaler <b>504</b>. Because different down-scalers are used to downscale different types of image frames (e.g. spatial information, texture, other attributes, etc.), different downscaling parameters may be applied to the different types of image frames to downscale geometry different than texture or attributes.</p><p id="p-0315" num="0384"><figref idref="DRAWINGS">FIG. <b>5</b>F</figref> illustrates an example closed loop rescaling, according to some embodiments. In some embodiments, a closed loop rescaling process may be used by an encoder such as encoder <b>500</b> to determine distortion or other changes to geometry that may occur as part of a downscaling, encoding, decoding, and/or upscaling process. In some embodiments, such distortion may be accounted for when downscaling other attributes, such as texture. An encoder, such as encoder <b>500</b>, receives a point cloud <b>548</b>. The encoder generates a geometry image frame for the point cloud <b>548</b>, for example an image frame comprising patches representing relative depths of the points, such as an original geometry image frame <b>550</b>. A point cloud compression geometry mapper, which may include a decomposition into patches module <b>506</b>, a packing module <b>208</b>, and a spatial image generation module <b>210</b>, etc., generates the original geometry image frame <b>550</b>. A geometry down-scaler, such as spatial down-scaler <b>502</b> downscales the geometry image frame to generate downscaled geometry image frame <b>552</b>. Note that &#x201c;geometry plane&#x201d; may be used to refer to geometry patch information, which may be included in an image frame only consisting of geometry patches as shown in <figref idref="DRAWINGS">FIG. <b>5</b>F</figref>.</p><p id="p-0316" num="0385">The downscaled geometry image frame <b>552</b> is compressed, for example by video compression module <b>218</b>, and is converted into a geometry bit stream. In a closed loop process as shown in <figref idref="DRAWINGS">FIG. <b>5</b>F</figref>, the geometry bit stream is decompressed at the encoder to generate a reconstructed geometry plane <b>554</b>. The reconstructed geometry plane is then up-scaled, at the encoder, to generate an up-scaled reconstructed geometry plane <b>556</b>.</p><p id="p-0317" num="0386">The texture points of the original geometry image frame <b>550</b> are then mapped to the points of the reconstructed up-scaled geometry plane <b>556</b>. Differences in locations of the points in the original geometry image frame and the re-constructed up-scaled geometry image frame are determined. Also, the points included in the geometry image frame <b>550</b> are adjusted to take into account distortion that may be introduced during the down-scaling, video compression, video-de-compression, and up-scaling processes. Additionally, this distortion may be taken into account by a point cloud compression (PCC) attribute/texture mapper to adjust texture values for points that are distorted during the down-scaling, video-compression, video-de-compression, and up-scaling process. Additionally, attribute values may also be adjusted to take into account geometry distortion. In this way, the texture and attribute points are mapped to the same points in the same locations as the decoder will encounter when reconstructing and up-scaling the geometry plane. Then, the encoder can take into account the distortion of the geometry plane that may occur due to downscaling, encoding, decoding, and upscaling.</p><p id="p-0318" num="0387">The texture points mapped to the points of the reconstructed up-scaled geometry plane <b>556</b> may be used to generate an adjusted attribute/texture image frame <b>558</b>. The adjusted attribute/texture image frame <b>558</b> may then be down-scaled to generate a down-scaled adjusted attribute/texture image frame <b>560</b>. The down-scaled adjusted attribute/texture image frame <b>560</b> may then be video encoded and transmitted as an attribute/texture bit stream.</p><p id="p-0319" num="0388"><figref idref="DRAWINGS">FIG. <b>5</b>G</figref> illustrates an example closed loop rescaling with multiple attribute layers, according to some embodiments. In some embodiments, a similar process as described for <figref idref="DRAWINGS">FIG. <b>5</b>F</figref> may be followed. However, multiple degrees of down-sampling may be performed for one or more attribute image frames being down-scaled. For example texture/attribute image plane <b>558</b> may not be downscaled at all (e.g. compression rate target 0), or may be downscaled according to a plurality of compression rate targets (e.g. compression rate targets 1-4) to generate down-scaled versions of the adjusted attribute/texture image frame <b>562</b>. In such embodiments, a compression rate target may be dynamically adjusted, for example based on network conditions, processing capacity, etc.</p><p id="p-0320" num="0389"><figref idref="DRAWINGS">FIG. <b>5</b>H</figref> illustrates an example of video level spatio-temporal scaling, according to some embodiments. In some embodiments, a similar process as described in <figref idref="DRAWINGS">FIGS. <b>5</b>C and <b>5</b>D</figref> may be performed using video level spatio-temporal downscaling and upscaling. For example, a frame rate (e.g. a number of frames generated per unit time) may be adjusted up or down in order to improve compression efficiency. In such embodiments spatial temporal adjustments may be made instead of resolution scaling and/or in addition to resolution scaling. For example, point clouds <b>564</b> at sequential movements in time may be down-scaled in resolution and/or frame rate in the 3D domain to generate down-scaled point clouds <b>566</b>. The point clouds <b>566</b> may be projected onto a patch plane and image frames <b>568</b> may be generated. Note image frames <b>568</b> may be geometry image frames or attribute image frames, or both. Additionally, video level spatio-temporal down-scaling may be applied to reduce a resolution of the image frames <b>568</b> and/or reduce a frame-rate of the image frames <b>568</b> to generate down-scaled image frames <b>570</b>. Note FIG. Note <figref idref="DRAWINGS">FIG. <b>5</b>H</figref> illustrates both frame-rate down-scaling (e.g. spatial temporal down-scaling) and resolution down-scaling. However, in some embodiments, spatio-temporal down-scaling may be performed without performing resolution down-scaling. The spatio-temporal and/or resolution down-scaled image frames <b>570</b> may then be video-encoded to generate bit stream <b>572</b>.</p><p id="p-0321" num="0390"><figref idref="DRAWINGS">FIG. <b>5</b>H</figref> also illustrates an encoder receiving bit-stream <b>572</b>. A video-decoding component of the decoder may video-decode the bit stream <b>572</b> to generate down-scaled image frames <b>574</b>. The decoder may also perform video level-spatio temporal upscaling to interpolate between the down-scaled image frames to generate up-scaled image frame <b>576</b>. For example, down-scaled image frames, as an example includes two image frames per unit of time, whereas up-scaled image frames <b>576</b> includes a third image frame that has been generated in the 2D video domain by interpolating, and/or using other video-spatial intra frame compression techniques, such as motion vectors, etc. to generate the third image frame. The up-scaled image frames <b>576</b> may then be used to generate reconstructed point clouds <b>578</b>. Note that three reconstructed point clouds have been generated based on up-scaled image frames <b>576</b>. Optionally, the decoder may further upscale the reconstructed point clouds <b>578</b> either temporally or size-wise, or both, to generate up-scaled point clouds <b>580</b>.</p><p id="p-0322" num="0391"><figref idref="DRAWINGS">FIG. <b>5</b>I</figref> illustrates an example closed loop rescaling with spatiotemporal scaling, according to some embodiments. For example, point clouds <b>582</b> may be used to generate original geometry image frames <b>584</b>. The original geometry frames may further be down-scaled temporally and/or size-wise to generate down-scaled geometry image frames <b>586</b>, which may have a different frame rate, such as fg frames per second, as compared to fo frames per second for original geometry image frames <b>584</b>, where fg is less than fo. The down-scaled geometry image frames <b>586</b> may also have a smaller size than the original geometry image frames <b>584</b>, such as height and width &#x201c;g&#x201d; as compared to height and width &#x201c;o&#x201d; of original geometry image frames <b>584</b>. The downs-scaled geometry image frames may further be video-encoded/compressed to generate geometry bit stream <b>596</b>. In a closed loop compression procedure, the geometry bit-stream <b>596</b> may further be video-decompressed/decoded at the encoder to generate reconstructed down-scaled geometry images <b>588</b>, which may have a similar frame rate and size as down-scaled geometry images <b>586</b>. The encoder may further apply a similar spatio-temporal and/or size-based up-scaling algorithm as would be executed at a decoder to generate up-scaled reconstructed image frames <b>590</b>, which may have a similar frame rate and size as original geometry image frames <b>584</b>. In some embodiments, the encoder may further adjust the original geometry image frames and repeat the process to reduce distortion. In some embodiments, geometry bit-stream <b>596</b> communicated out of the encoder may be based on adjusted geometry image frames <b>584</b>.</p><p id="p-0323" num="0392">In some embodiments, a point cloud compression (PCC) texture/attribute mapper may further adjust attribute/texture values of attribute/texture image frames based on distortion introduced due to the down-scaling, video-encoding, video-decoding, and up-scaling of the geometry image frames. For example, adjusted attribute/texture image frames <b>592</b> may be generated. The adjusted attribute/texture image frames <b>592</b> may further be down-scaled at generate down-scaled adjusted attribute/texture image frames <b>594</b>, which may in turn be video-encoded to generate texture/attribute bit stream <b>598</b>. While not illustrated for spatio-temporal down-scaling, a similar process as described in <figref idref="DRAWINGS">FIG. <b>5</b>G</figref> may be performed, wherein a level of spatio-temporal down-scaling to be applied is determined based on an available bit rate to communicate the compressed point cloud.</p><p id="p-0324" num="0393">As discussed above, methods of compressing point cloud video data may use conventional video codecs as well as auxiliary information that can help describe and reconstruct the point cloud information. The encoder and decoder diagrams of how that process is performed is shown in at least <figref idref="DRAWINGS">FIGS. <b>5</b>A and <b>5</b>B</figref>, respectively. Also, <figref idref="DRAWINGS">FIGS. <b>6</b>A-<b>6</b>I</figref> further illustrate how relationships between geometry image frames and attribute/texture image frames may be used to improve compression efficiency and reconstruction accuracy. Similar techniques may be combined with up-scaling and down-scaling techniques as described herein in <figref idref="DRAWINGS">FIGS. <b>5</b>A-<b>5</b>L</figref>.</p><p id="p-0325" num="0394">As discussed above, the process of generating the image frames segments the point cloud into multiple 2D projected images/videos, each representing different types of information. This process is performed by segmenting the point cloud first into multiple patches that permit efficient projection of the entire 3D space data onto 2D planes. Each patch is associated with information such as geometry (also referred to herein as &#x201c;spatial information&#x201d;), texture, and other attributes if they are available. Such information is then copied at the co-located locations of the image frames on separate image sequences with each now containing only the geometry information, the texture information, and any other remaining attributes respectively. Auxiliary information that contains the patch information as well as an occupancy map that dictates which areas in these projected image sequences correspond to actual point cloud data and which are unoccupied, e.g. may contain no data or dummy data, are also provided. Compression is then applied on such information using different strategies. Auxiliary information, for example, is entropy coded, while occupancy maps may be down-converted and encoded using either conventional codecs or other methods such as run length compression. The separate projected image sequences on the other hand are compressed using conventional codecs. This results in a collection of multiple sub streams, e.g. a geometry sub stream, texture and attribute sub streams, as well as occupancy and auxiliary information sub streams.</p><p id="p-0326" num="0395">As described above, all sub streams except the occupancy map are expected to be of the same resolution. Each point in the geometry sub stream essentially corresponds to a point in the final 3D reconstructed point cloud. In some embodiments, it is permitted for the signal to be encoded at a different resolution than the original representation. Also, in some embodiments, offsetting as well as rotating the point cloud is also possible. Seeing things from the encoder perspective, this is done by signaling in the stream header additional metadata that would identify the scaling, offset, and rotation that should be applied onto the original point cloud data prior to projecting it onto the target video planes. From the decoder perspective, these parameters are used after the reconstruction of a first 3D point cloud representation and utilized to generate the final 3D point cloud representation. In such a scheme, both geometry and attribute/texture video data are signaled at the same resolution as specified in the point cloud header. Per patch metadata including scaling factors and rotation parameters are also supported in such a scheme, with scaling though now applied on each projected patch independently.</p><p id="p-0327" num="0396">However, in some embodiments, this scheme may be further extended by providing additional resolution scaling flexibility in the encoded streams In particular, not only may the scaling be applied in 3D space or per patch, but in some embodiments scheme scaling may be applied on the entire projected point cloud video data. This may permit use of &#x201c;conventional&#x201d; 2D rescaling schemes and architectures, which are readily available in many architectures. Furthermore, unlike a scheme where geometry and attribute sub streams are encoded at the same resolution, this alternative scheme permits signaling of these sub streams at different resolutions. In some embodiments, this scheme could also be combined with the 3D scaling scheme described above, e.g. the specified 2D image frame scaling can follow in encoding order and precede in decoding order the 3D scaling process as described above. This can provide further flexibility in coding performance.</p><p id="p-0328" num="0397">In particular, with the scheme described above the scaling factors, if any, that were applied to the point cloud signal in 3D space to change its resolution are known. Essentially the point cloud scene/object that is being represented would change from resolution W<sub>3D</sub>&#xd7;H<sub>3D</sub>&#xd7;D<sub>3D </sub>to (s<sub>x</sub>&#xd7;W<sub>3D</sub>)&#xd7;(s<sub>y</sub>&#xd7;H<sub>3D</sub>)&#xd7;(s<sub>z</sub>&#xd7;D<sub>3D</sub>). Then this rescaled object would be projected using the patch approach specified above into a variety of sub videos, e.g. occupancy, geometry and attribute sub videos, each of a nominal resolution of W<sub>N</sub>&#xd7;H<sub>N</sub>. The nominal resolution may be currently specified in the group of frames header syntax of the MPEG PCC TMC2 draft (v1.2), using the syntax elements frame_width and frame_height. The scaling factors may be added into this syntax.</p><p id="p-0329" num="0000"><tables id="TABLE-US-00008" num="00008"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Group of frames header syntax</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="154pt" align="left"/><colspec colname="1" colwidth="63pt" align="left"/><tbody valign="top"><row><entry/><entry>Descriptor</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="21pt" align="left"/><colspec colname="1" colwidth="133pt" align="left"/><colspec colname="2" colwidth="63pt" align="left"/><tbody valign="top"><row><entry/><entry>group_of_frames_header( ) {</entry><entry/></row><row><entry/><entry>&#x2003;group_of_frames_size</entry><entry>u(8)</entry></row><row><entry/><entry>&#x2003;frame_width</entry><entry>u(16)</entry></row><row><entry/><entry>&#x2003;frame_height</entry><entry>u(16)</entry></row><row><entry/><entry>&#x2003;occupancy_resolution</entry><entry>u(8)</entry></row><row><entry/><entry>&#x2003;radius_to_smoothing</entry><entry>u(8)</entry></row><row><entry/><entry>&#x2003;neighbor_count_smoothing</entry><entry>u(8)</entry></row><row><entry/><entry>&#x2003;radius_to_boundary_detection</entry><entry>u(8)</entry></row><row><entry/><entry>&#x2003;threshold_smoothing</entry><entry>u(8)</entry></row><row><entry/><entry>}</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0330" num="0398">With the proposed method one may also now rescale the geometry and attribute signal i further at a resolution of W<sub>G</sub>&#xd7;H<sub>G </sub>and W<sub>A(i)</sub>&#xd7;H<sub>A(i) </sub>respectively. There is no need of signaling the resolution of these videos in the point cloud compression PCC headers since that information already exists in the video bit streams themselves. Conventional algorithms can be used to rescale the videos from the nominal resolution of W<sub>N</sub>&#xd7;H<sub>N </sub>to W<sub>G</sub>&#xd7;H<sub>G </sub>or W<sub>A(i)</sub>&#xd7;H<sub>A(i) </sub>and vice versa. These can be seen from the encoder perspective in <figref idref="DRAWINGS">FIG. <b>5</b>C</figref> and from the decoder perspective in <figref idref="DRAWINGS">FIG. <b>5</b>D</figref>.</p><p id="p-0331" num="0399"><figref idref="DRAWINGS">FIG. <b>5</b>E</figref> shows an open loop architecture for converting the geometry and attribute signals. In this architecture the geometry and attribute signals are created and converted independently. In some embodiments, the only dependency is that the geometry signal prior to downscaling and compression is used for generating the texture plane signal. However, in <figref idref="DRAWINGS">FIG. <b>5</b>F</figref>, a closed loop architecture is considered. In this architecture, the geometry signal is scaled and coded first, then it is reconstructed and up converted to its original resolution. This new geometry signal is then used to generate the texture/attribute plane. Using this method, the texture (or attributes) generated more accurately correspond to the reconstructed geometry compared to the open loop architecture in the previous figure (<figref idref="DRAWINGS">FIG. <b>5</b>E</figref>). It should be noted that the upscaling process of the geometry, if needed, should be matched across decoders to achieve the desired closed-loop performance. If the up-scalers do not match, there could be some difference in performance. The resolutions of the geometry and attribute signals also do not need to match in any of these systems. Conventional up-scalers, such as a separable filter based up-scaler, e.g. bicubic, lanczos, windowed cosine or sine, etc., or more complicated up-scalers, including bilateral up-scalers, edge adaptive, motion compensated, etc. could be used. Downscaling also could use similar methods, e.g. separable filters, edge preserving down-scalers, etc.</p><p id="p-0332" num="0400">Such an approach could also be utilized by adaptive streaming solutions as well. In particular in adaptive streaming systems multiple streams may be generated at different resolutions and frame rates to better support the variability of a network. In this system apart from adjusting frame rates for the different layers, different resolutions can also be used between the texture and geometry to also augment such functionality. An example is shown in <figref idref="DRAWINGS">FIG. <b>5</b>G</figref> where for a particular geometry signal multiple different bit streams are generated for the texture/attribute signal, each potentially having different frame rates and/or resolutions as well. An encoder may select to use the particular texture layer and then also select the appropriate corresponding sub-bit stream for the attribute/texture plane given the overall bandwidth characteristics of their network.</p><p id="p-0333" num="0401">In a different aspect, downscaling and upscaling of the geometry plane and attribute/texture plane can be performed by considering the characteristics of the point cloud system and how the images are constructed. In particular, in the systems described above, images are constructed using patches. These patches are available at both the encoder and decoder. A conventional system likely will not be able to consider the patches, however a more advanced system could utilize the patches to improve these two processes. In particular, better performance could be achieved by processing/filtering when upscaling or downscaling only the samples within a patch. Samples outside the patch are likely padded samples that may have no direct relationship with the samples inside the patch and if filtered/processed together could contaminate the signal. By isolating such samples this contamination can be avoided and performance can be improved. Even if not able to extract the full patch location information in a system, it could still be possible to consider other related information such as the occupancy map information. Occupancy maps, even though less accurate if they were down sampled, can still provide some improvement in performance. On the other hand, the interpolation process for the attribute signals may be augmented by also considering the characteristics, e.g. edges, in the geometry signal. In particular, edges may be extracted in the geometry signal, and they may be related to edges in the attribute signals and a guided interpolation based on that information may be performed. This is possible since edges in the two layers are highly related, especially at the boundaries of every patch. For example <figref idref="DRAWINGS">FIG. <b>6</b>I</figref> further discusses an example guided interpolation technique.</p><p id="p-0334" num="0402">In some embodiments, spatio-temporal rescaling may be applied as shown in <figref idref="DRAWINGS">FIGS. <b>5</b>H and <b>5</b>I</figref>. In some embodiments, on the encoder, frame dropping may be performed, while the decision to drop a frame may be based on how similar are the &#x201c;neighboring&#x201d; frames or the frame dropping could be done at a fixed rate (time stamps would still exist in the stream to inform the use of temporal relationships). In some embodiments &#x201c;blending&#x201d;/averaging of frames may be performed. That is, all frames may be scaled using different phase that is controlled &#x201c;temporally&#x201d;. For example, odd frames may be scaled vertically using phase 0, while even frames would be scaled vertically using phase 1. Those scaled images are called fields, which are then interleaved together to create interlace frames. This process could be used for projected point cloud data. Note that interleaving does not need to be restricted in vertical fashion, but could be done horizontally instead or as well.</p><p id="p-0335" num="0403">For the temporal up conversion, frame repeats could be used, or more intelligent methods could be used that include motion adaptive and motion compensated strategies for the interpolation. Machine learning methods could also be used to assist with the interpolation.</p><p id="p-0336" num="0404">In some embodiments, the temporal resolution may be only reduced in one of the planes (e.g. geometry or attribute/texture) while for the other all frames are retained (along with the occupancy and patch information). In such a case the &#x201c;shape&#x201d; and location of all patches in the reduced temporal resolution plane are known, but the exact value of its characteristics (depth for geometry, color for attribute/texture) is not known. However, that value may be computed by trying to locate each patch in their temporal adjacent neighbors. That can be done by searching using the shape information of the patch and/or the available values of the patch characteristics of the full resolution plane. That basically would involve a search (e.g. a motion estimation based search). When a patch is located, the information from the characteristics to interpolate from its temporal neighbors can be copied/blended and used as a predictor.</p><p id="p-0337" num="0405"><figref idref="DRAWINGS">FIG. <b>5</b>J</figref> illustrates a process of encoding/compressing image frames of a point cloud using down-scaling, according to some embodiments.</p><p id="p-0338" num="0406">At <b>501</b>, an encoder determines for a point cloud a plurality of patches projected on 2D planes. For example, any of the patch projection procedures described herein may be used.</p><p id="p-0339" num="0407">At <b>503</b>, the encoder generates attribute (or texture) patch images and geometry patch images for the patches. For example, any of the patch image generation techniques described herein may be used.</p><p id="p-0340" num="0408">At <b>505</b>, the encoder packs the generated attribute/texture patch images and the generated geometry patch images into one or more image frames. Note that the packing of the patch images and the generating of the patch images may occur concurrently. Any of the patch image packing techniques described herein may be used.</p><p id="p-0341" num="0409">At <b>507</b>, the encoder down-scales at least one of the image frames video down-scaling process. For example, the down-scaling process may include resolution reduction and/or frame rate reduction. Also, the down-scaling process may be open-loop or closed loop. Also the down-scaling process may be adjusted based on available bit rate, or not. Any of the down-scaling techniques described in regard to <figref idref="DRAWINGS">FIGS. <b>5</b>A-<b>5</b>L</figref> may be used.</p><p id="p-0342" num="0410">At <b>509</b>, the encoder video encodes one or more bit streams based on the down-scaled image frames. Any video encoding technique as described herein may be used.</p><p id="p-0343" num="0411"><figref idref="DRAWINGS">FIG. <b>5</b>K</figref> illustrates a process of determining to down-scaling image frames using open-loop or closed-loop down-scaling, according to some embodiments.</p><p id="p-0344" num="0412">At <b>511</b>, the encoder receives a point cloud to compress. At <b>513</b>, the encoder determines whether to apply down-scaling, and if so, whether to utilize an open-loop down-scaling process, as described herein, or a closed-loop down-scaling process, as described herein. For example, the encoder may determine whether to utilize an open-loop or closed-loop down-scaling process based on a complexity of the point cloud and an availability of processing capacity to perform the down-scaling. For example, a complicated point cloud with a larger number of patches may be down-scaled using an open-loop down-scaling process when processing capacity is limited, but may be down-scaled using a closed-loop down-scaling process when more processing capacity is available. For example, if the combination of complexity and available processing capacity are such that one or more thresholds are exceeded, the down-scaling may be performed at <b>515</b> via an open-loop process. Conversely, if the combination of complexity and available processing capacity are such that the one or more thresholds are not exceeded, the down-scaling may be performed at <b>517</b> via a closed-loop process.</p><p id="p-0345" num="0413"><figref idref="DRAWINGS">FIG. <b>5</b>L</figref> illustrates a process of decoding/decompressing image frames of a point cloud using up-scaling, according to some embodiments.</p><p id="p-0346" num="0414">At <b>521</b>, a decoder receives a bit stream comprising video encoded image frames of a point cloud. At least one of the video encoded image frames was video encoded from a down-scaled image frame, such as the down-scaled image frames discussed herein. The at least one down-scaled image(s) frame may have been down-scaled in size or frame-rate, or both.</p><p id="p-0347" num="0415">At <b>523</b>, the decoder video de-codes the bit stream to generate one or more image frames comprising the at least one down-scaled image frame(s).</p><p id="p-0348" num="0416">At <b>525</b>, the decoder determines which of the image frames have been down-scaled. For example any of the techniques described above may be used to identify down-scaled image frames.</p><p id="p-0349" num="0417">At <b>527</b>, the decoder up-scales the at least one down-scaled image frame(s). The down-scaled image frame(s) may be up-scaled in size, frame-rate, or both. In some embodiments, any of the up-scaling techniques described herein may be used.</p><p id="p-0350" num="0418">At <b>529</b>, the decoder generates a reconstructed version of the compressed point cloud based on the video decoded and/or up-scaled image frames. Any of the reconstruction procedures described herein may be used.</p><heading id="h-0038" level="2">Pre Video Compression Pre-Processing and Post Video Decompression Filtering/Post-Processing</heading><p id="p-0351" num="0419">As discussed above, video point cloud data may be compressed using conventional video codecs. As discussed above, the process segments a point cloud frame into multiple 2D projected images/videos, each representing different types of information. This process is performed by segmenting the point cloud into multiple patches that permit one to efficiently project the 3D space data of the point cloud onto 2D planes. Each patch is associated with information such as geometry, texture, and/or other attributes. Such information is then copied at co-located locations on separate image frame sequences with each image frame containing the geometry information, the texture information, or any other remaining attributes, respectively as patch images packed into the image frame. Auxiliary information that contains the patch information as well as an occupancy map that dictates which areas in these projected image frame sequences correspond to actual point cloud data and which are unoccupied, e.g. may contain no or dummy data, are also provided. Compression is applied on such information using different strategies. Auxiliary information, for example, can be entropy coded, while occupancy maps may be down converted and encoded using either conventional video codecs or other methods such as run length compression. The separate projected image sequences on the other hand are compressed using conventional video codecs. This results in a collection of multiple sub streams, e.g. a geometry sub stream, texture and attribute sub streams, as well as occupancy and auxiliary information sub streams. All these streams are multiplexed together to generate the final point cloud bit stream as shown in <figref idref="DRAWINGS">FIGS. <b>2</b>A</figref>. In some embodiments, these streams may be provided to an image frame pre-processing/filtering element of an encoder to make intelligent pre-processing decisions and/or to intelligently adjust parameters used for video encoding based on information included in these streams.</p><p id="p-0352" num="0420"><figref idref="DRAWINGS">FIG. <b>6</b>A</figref> illustrates components of an encoder that further includes pre-video compression texture processing and/or filtering and pre-video decompression geometry processing/filtering, according to some embodiments. Encoder <b>600</b> includes image frame pre-processing/filtering element <b>602</b>. In some embodiments, any of the encoders described herein, such as encoder <b>200</b>, <b>250</b>, <b>400</b>, <b>450</b>, or encoder <b>500</b> may further include a texture processing/filtering element, such as texture processing/filter element <b>602</b>. In some embodiments, any of the decoders described herein, such as decoder <b>230</b> or decoder <b>280</b>, may further include a geometry processing/filtering element, such as geometry/filtering element <b>604</b>. In some embodiments, pre-processing of a packed image frame from image frame padding element <b>216</b> may be pre-processed via image frame pre-processing/filtering element <b>602</b> prior to being video encoded by video compression <b>218</b>. In some embodiments, image frame pre-processing/filtering element <b>602</b> may receive occupancy map information, spatial information, for example from spatial image generation element <b>210</b>, texture information, for example from texture image generation element <b>212</b>, and attribute information, for example from attribute image generation element <b>214</b>.</p><p id="p-0353" num="0421">In some embodiments, an image frame pre-processing/filter element, such as image frame pre-processing/filter element <b>602</b>, may determine relationship information indicating relationships between respective attribute patch images and/or depth patch images. Additionally, the relationship information may include relationships between the respective patches and an image frame, for example which portions of the image frame are occupied or unoccupied and where edges of the patches in the image frame are located.</p><p id="p-0354" num="0422">In some embodiments, an encoder, such as encoder <b>600</b>, may utilize a received or determined occupancy map to determine the relationship information. In some embodiments, an image frame pre-processing/filtering element, such as image frame pre-processing/filtering element <b>602</b>, may cause one or more encoding parameters of a video encoding component, such as video compression <b>218</b>, to be adjusted based on the determined relationship information. For example, the image frame pre-processing/filtering element may cause the video encoding component to allocate more encoding resources to encoding portions of the image frame that are occupied with patches and may cause the video encoding component to allocate fewer encoding resources to encoding portions of the image frame that are unoccupied. Also, in some embodiments, the relationship information may indicate a plurality of patches (e.g. attribute patch images and/or depth patch images) that correspond to a same set of points projected onto a same patch plane. In some embodiments, an image frame pre-processing/filtering element may cause a video encoding component to utilize complementary encoding parameters when encoding patches corresponding to a same set of points in the point cloud.</p><p id="p-0355" num="0423">In some embodiments, an image pre-processing/filtering element, such as image pre-processing/filtering element <b>602</b>, may determine a pooled distortion for a set of points. For example, the image frame pre-processing/filtering element may determine an amount of distortion introduced due to video compression of a depth patch image, an amount of distortion introduced due to video compression of an attribute patch image (such as colors), and an impact of overall or pooled distortion on the reconstructed point cloud based on the interactions of the distortions introduced for the separate patches. For example, depth distortion may cause additional color distortion in a reconstructed point cloud. In some embodiments, the image frame pre-processing/filtering element may adjust one or more video encoding parameters of a video encoding component, such as video compression <b>218</b>, in order to reduce the overall pooled distortion for the set of points.</p><p id="p-0356" num="0424">In some embodiments, an image pre-processing/filtering element, such as image pre-processing/filtering element <b>602</b>, may determine edges of patches based on the relationship information. The image pre-processing/filtering element may further adjust one or more pre-processing processes such as color down-sampling of the one or more images, for example as described above in regard to closed-loop color conversion, based on the boundaries of the patches according to their determined edges.</p><p id="p-0357" num="0425"><figref idref="DRAWINGS">FIG. <b>6</b>B</figref> illustrates components of a decoder that further includes post video decompression texture processing and/or filtering and post video decompression geometry processing/filtering, according to some embodiments. Decoder <b>610</b> includes texture processing/filtering element <b>612</b> and geometry processing/filter element <b>614</b>. In some embodiments, any of the decoders described herein, such as decoder <b>230</b>, <b>280</b>, or <b>550</b> may further include a texture processing/filtering element, such as texture processing/filter element <b>612</b>. In some embodiments, any of the decoders described herein, such as decoder <b>230</b>, <b>280</b>, or <b>550</b>, may further include a geometry processing/filtering element, such as geometry/filtering element <b>614</b>.</p><p id="p-0358" num="0426">In some embodiments, relationship information for patch images in an image frame may be included in or derived from a bit stream for a compressed point cloud. For example, <figref idref="DRAWINGS">FIG. <b>6</b>C</figref> illustrates a bit stream structure for a compressed point cloud, according to some embodiments. In some embodiments, the auxiliary information may include relationship information for patch images. Also, in some embodiments an occupancy map may include relationship information for patches of an image frame. For example, an occupancy map may indicate which portions of an image frame are occupied or unoccupied. Also, the auxiliary information may indicate which blocks of an image frame correspond to which patches. This information may be used to determine portions of an image frame that correspond to a same patch. Also depth information included in the geometry information (e.g. depth patch images) may be used to identify portions of image frames for points having a common depth in the point cloud. Additionally, attribute/texture information included in the texture video stream may be used to identify patches in the image frames with similar textures or attribute values. In some embodiments, an attribute texture processing/filtering element, such as attribute processing/filtering element <b>612</b>, and a geometry processing/filtering element, such as geometry/filtering element <b>614</b>, may utilize these data streams to determine or receive relationship information for patches included in one or more video encoded image frames, such as are included in the group of frames for the geometry video stream, and such as are included in the group of frames for the texture/attribute video stream. The attribute processing/filtering element and/or geometry processing/filtering element may further utilize these determined or received relationships to intelligently post-process geometry image frames in the geometry video stream or to post-process texture/attribute image frames in the texture video stream. Also, in some embodiments, geometry patches (e.g. depth patches) and texture or attribute patches may be packed into a same image frame. Thus, in some embodiments, a texture/attribute video stream and a geometry video stream may be combined into a common video stream comprising image frames with both geometry patches and attribute/texture patches.</p><p id="p-0359" num="0427">One of the characteristics of this point cloud coding scheme is that the different projected image sequences can be not only compressed using &#x201c;conventional&#x201d; codecs but also processed with conventional processing algorithms reserved for 2D image/video data. That is, one could apply de-noising, scaling, enhancement, and/or other algorithms commonly used for processing 2D image data onto these image sequences. Such processing could have advantages, especially in terms of complexity and reuse of existing hardware implementations, versus performing such processing in the 3D domain.</p><p id="p-0360" num="0428">One example of such processing is the conversion of the data from an RGB 4:4:4 representation to a 4:2:0 YCbCr representation and vice versa. In that scenario, for down conversion, the RGB data would be, for example, first converted to a YCbCr 4:4:4 representation, and then the chroma planes could be filtered and downscaled to &#xbc; of their original resolution (half resolution horizontally and vertically). For the inverse process, the chroma planes would be upscaled to their original resolution, e.g. back to YCbCr 4:4:4, and then the signal would be converted back to RGB 4:4:4. A variety of down conversion and up conversion methods could be used, including the use of edge adaptive downscaling and upscaling, as well as techniques such as the luma adjustment method.</p><p id="p-0361" num="0429">Although some conventional processing methods may operate &#x201c;as is&#x201d; on the point cloud projected image sequences, they do not fully consider the characteristics of such images and in particular the relationship that exists between different layers or the information about patches and occupancy. Consideration of such information could improve performance. For example, such methods may be improved by taking into account such characteristics and information, therefore improving performance and the final quality of the reconstructed 3D point cloud from the projected images.</p><p id="p-0362" num="0430">In particular, conventional methods will most likely process the projected image sequences assuming that all samples inside these sequences are highly correlated and that adjoining samples likely correspond to the same or at least neighboring objects. Unfortunately, this may not be the case in such imagery. In fact, such image frames comprise samples that correspond to projected patches, as well as filler areas used to separate and distinguish these patches. Such filler areas may be left unfilled, e.g. with a default color value, or may have been filled using padding methods as described herein. Processing of individual samples, e.g. when using long filters for filtering, may result in contamination of information between different patches as well as the filler areas, which can impair quality.</p><p id="p-0363" num="0431">Knowledge of the precise patch location and the filler areas can instead benefit performance substantially. In some embodiments, a processing engine (such as texture processing/filtering element <b>612</b> and/or geometry processing/filtering element <b>614</b>) performs filtering/processing operations on such image data on a patch by patch basis. That is, a particular sample s is processed/filtered by accounting for samples that correspond to the same patch as s. Samples that may have been included in the processing using a conventional method, e.g. because of the consideration of a long filter, but which do not correspond to the same patch are excluded from the processing of s. This could be done, for example, by reducing the length of the processing filter until such samples are fully excluded, or by performing on the fly extrapolation of the data at the boundaries between patches, when processing, and using the extrapolated data in place of the available data outside a patch.</p><p id="p-0364" num="0432">The same or similar principles could be applied when processing filler data, which can be seen as a patch on its own.</p><p id="p-0365" num="0433">A particular system may consider the exact location and shape information for each individual patch, e.g. it may require that the patch information be fully decoded and therefore is fully available during processing. This can provide the most accurate processing and can avoid contamination across patches. In some embodiments, an approximation of the patch location and shape can be determined by looking only at the occupancy map information, which may have been coded using a conventional 2D video coding system. In this case, since occupancy information may have been subsampled, e.g. by 4 times horizontally and vertically (16 times overall), some of the samples at the boundaries of the patch may have been duplicated. This may have some implications in performance, however, processing complexity can be considerably lower since there is no need to decode the full patch information.</p><p id="p-0366" num="0434">Point cloud data are associated with geometry information as well as other attributes, e.g. texture, color, reflectance information, etc. Improved performance may be achieved by considering the relationships and characteristics across different attributes. In particular, similarity or dissimilarity of the geometry sample values in the projected plane may be accounted for when processing the corresponding samples in an attribute plane. In particular, neighboring projected samples that correspond to the same or similar depth in the geometry plane are expected to be highly correlated. However, neighboring samples that have very dissimilar depth information are less likely to be correlated. Therefore, when processing such samples, depth information could also be considered to determine how these samples should be considered.</p><p id="p-0367" num="0435">In some embodiments, samples that are too far from a sample x in terms of depth distance, e.g. exceed a distance threshold T, may be excluded when processing sample x. Other samples may be weighted or prioritized in processing again based on their distance. Corresponding information from other attributes and how similar or dissimilar these attributes are could also be considered when processing the sample. Information, such as edges extracted from the geometry plane or from other attribute planes could also be considered when processing. In the particular example of chroma down sampling (e.g. 4:4:4 to 4:2:0), as discussed earlier, edge directed downsampling using the geometry as well as luma attribute information could be performed in the first case, while similarly for up sampling (e.g. 4:2:0 to 4:4:4) an edge directed upsampling process using geometry and luma attribute information could be performed. Such processing could again be patch/occupancy map based as described earlier, however such processing could also be performed on its own without such consideration. In another example, directed interpolation could be performed of the attribute planes from a resolution H_o&#xd7;W_o to a new resolution H_n&#xd7;W_n, again using information from the geometry information and/or other attribute planes that may be available. For example, <figref idref="DRAWINGS">FIG. <b>6</b>I</figref> illustrates an example application where an attribute plane is upscaled using its corresponding geometry information and the geometry extracted edges, according to some embodiments.</p><p id="p-0368" num="0436">In some embodiments, other applications that utilize the proposed filter/processing techniques described above may include de-noising, de-banding, de-ringing, de-blocking, sharpening, edge enhancement, object extraction/segmentation, display mapping (e.g. for HDR applications), recoloring/tone mapping, among others. Such methods could also be utilized for quality evaluation, e.g. by pooling together and considering data (e.g. summing distortion values) in corresponding patches that also correspond to similar geometry information and other attributes when evaluating a particular distortion measurement. Processing may be purely spatial, e.g. only projected images that correspond to the same time stamp may be considered for such processing, however temporal/spatio-temporal processing may also be permitted, e.g. using motion compensated or motion adaptive processing strategies.</p><p id="p-0369" num="0437"><figref idref="DRAWINGS">FIG. <b>6</b>D</figref> illustrates a process for generating video encoded image frames for patches of a point cloud taking into account relationship information between the patches packed into the image frames, according to some embodiments.</p><p id="p-0370" num="0438">At <b>620</b>, an encoder generates attribute (or texture) image patches for sets of points projected onto patch planes. At <b>622</b>, the encoder generates depth (e.g. geometry) patch images for sets of points projected onto the patch planes. At <b>624</b>, the encoder packs the generated patch images into one or more image frames. In some embodiments, various ones of the patch generation and image frame packing techniques described herein may be used to generate the attribute patch images, the depth patch images, and to pack the generated patch images into one or more image frames.</p><p id="p-0371" num="0439">At <b>626</b>, the encoder generates one or more occupancy maps for the one or more packed image frames. In some embodiments, various ones of the techniques described herein to generate an occupancy map may be used.</p><p id="p-0372" num="0440">At <b>628</b>, the encoder optionally performs one or more pre-processing processes on the packed image frames taking into account the relationships between the attribute patch images and the depth patch images packed into the one or more image frames.</p><p id="p-0373" num="0441">At <b>630</b>, the encoder (or a separate video encoding component) video encodes the one or more image frames, wherein one or more parameters of the video encoding is adjusted based on the determined relationships between the patch images. For example, one or more parameters may be adjusted based on a pooled distortion for patches corresponding to the same set of points. Also, a color conversion process may be adjusted based on patch boundaries, as a few examples. In some embodiments, various other video encoding parameters may be intelligently adjusted based on knowledge not typically available to a video encoder regarding which portions of an image frame relate to patches, and which do not. For example, as explained above, default encoding algorithms for a video encoder may assume that pixels proximate to one another are highly correlated. However, in the case of packed image frames, points on either side of a patch image boundary may vary and not be correlated as would be expected in other video images. As explained above, in some embodiments, a video encoder may disregard padded portions of the image frame when selecting video encoding parameters. Also, other adjustments may be made in view of knowledge of the relationships between the patch images packed into the image frames.</p><p id="p-0374" num="0442"><figref idref="DRAWINGS">FIG. <b>6</b>E</figref> illustrates a process for generating video encoded image frames taking into account pooled distortion for a set of patches corresponding to a same set of points, according to some embodiments.</p><p id="p-0375" num="0443">At <b>632</b>, an encoder identifies attribute patch images and depth patch images corresponding to a same set of points projected on a same patch plane. For example, this information may be included in auxiliary information that is to be included in a compressed point cloud stream.</p><p id="p-0376" num="0444">At <b>634</b>, the encoder determines a pooled amount of distortion affecting the set of points based on distortion introduced via video encoding the attribute patch images and the depth patch images for the set of points. For example, the encoder may video encode and video decode one or more image frames to determine distortion introduced for the respective patches. Also, in some embodiments, a video encoding component may have known distortion levels associated with various settings and the encoder may be able to determine levels of distortion that will be introduced based on the selection of such settings. In some embodiments, distortion in one patch image may compound distortion in another patch image when reconstructing a representation of the point cloud. For example, depth distortion combined with attribute or texture distortion may compound upon each other, where points are both moved in a reconstructed point cloud and also have changed colors. In some embodiments, these effects may be greater than the sum of the individual distortions. For example, depth distortion may further highlight color distortion and vice-versa.</p><p id="p-0377" num="0445">At <b>636</b>, the encoder adjusts one or more video encoding parameters and/or one or more pre-processing parameters to reduce the overall amount of pooled distortion for the set of points.</p><p id="p-0378" num="0446"><figref idref="DRAWINGS">FIG. <b>6</b>F</figref> illustrates a process for generating video encoded image frames taking into account patch edges, according to some embodiments.</p><p id="p-0379" num="0447">At <b>638</b>, an encoder determines edges for attribute patch images or depth patch images packed into one or more image frames. For example, such information may be included in an occupancy map for the image frame, and/or in auxiliary information for the image frame.</p><p id="p-0380" num="0448">At <b>640</b>, the encoder provides the relationship information to a video encoding component that will video encode the image frame.</p><p id="p-0381" num="0449">At <b>642</b>, the video encoding component adjusts one or more video encoding parameters and/or an image pre-processing/filtering element adjusts one or more parameters based on the determined edges. For example, a pre-processing filter may be adjusted to avoid cross patch contamination or contamination between patch portions and pad portions of the image frame.</p><p id="p-0382" num="0450"><figref idref="DRAWINGS">FIG. <b>6</b>G</figref> illustrates a process for reconstructing a point cloud based on video encoded image frames comprising patches of the point cloud, wherein relationship information between the patches packed into the image frames is taken into account, according to some embodiments.</p><p id="p-0383" num="0451">At <b>650</b>, a decoder receives one or more image frames comprising attribute patch images and depth patch images packed into one or more image frames. For example, the one or more image frames may have been packed with patch images as described herein.</p><p id="p-0384" num="0452">At <b>652</b>, the decoder receives an occupancy map and/or auxiliary information for the one or more image frames. For example, the one or more image frames, occupancy map, and/or auxiliary information may be included in a group of frames and/or point cloud data stream as shown in <figref idref="DRAWINGS">FIG. <b>6</b>C</figref>.</p><p id="p-0385" num="0453">At <b>654</b>, the decoder receives (e.g. via the occupancy map or auxiliary information) or determines (e.g. based on the occupancy map and/or auxiliary information) one or more relationships for the attribute patch images and/or depth patch images packed in the one or more image frames. In some embodiments, the one or more determined relationships may indicate portions of the image frame that are occupied and unoccupied. In some embodiments, the one or more determined relationships may indicate a depth patch image and one or more attribute or texture patch images that correspond to a same set of points projected on a same patch plane as the depth patch image. In some embodiments, the one or more determined relationships may indicate regions of a set of one or more attribute patch images and one or more depth patch images which correspond to a same depth of the point cloud. In some embodiments, the one or more determined relationships may indicate regions of a set of one or more attribute patch images which share similar attribute values. In some embodiments, the one or more determined relationships may indicate regions of a set of one or more attribute patch images and one or more depth patch images which correspond to patches comprising points of the point cloud with depth gradients that deviate from one another by less than a threshold amount. In some embodiments, other relationships may be determined based on the occupancy map and/or auxiliary information.</p><p id="p-0386" num="0454">At <b>656</b>, the decoder video decodes the one or more packed image frames. In some embodiments, the decoder adjusts decoding parameters based on the determined relationships.</p><p id="p-0387" num="0455">At <b>658</b>, the decoder performs one or more post-processing processes on the video decoded image frames before using the depth patch images and attribute or texture patch images to reconstruct a reconstructed representation of the point cloud. As explained above, it may be more efficient to perform post-processing on a 2-D representation via a video post-processing process than to perform post-processing in a 3-D space comprising points of a point cloud reconstructed from the patch images included in the 2-D image frames. The decoder may adjust one or more parameters of the post-processing based on the determined relationships. For example, a long filter may be adjusted to avoid cross-contamination across patch images, between patches and padding, or between patch images. In some embodiments, various post-processing processes may be adjusted, such as: denoising, debanding, deringing, deblocking, sharpening, object extraction or segmentation, display mapping, wherein a range of the one or more image frames is mapped to a range to be used to display a reconstructed representation of the point cloud, a color space conversion of the one or more image frames, a filtering process of the one or more image frames, color or tone adjustment processes applied to the one or more image frames, etc.</p><p id="p-0388" num="0456">At <b>660</b>, the decoder generates a reconstructed representation of the compressed point cloud based on attribute information and depth information extracted from the patch images in the one or more image frames that have undergone the post-processing processes at <b>658</b>.</p><p id="p-0389" num="0457"><figref idref="DRAWINGS">FIG. <b>6</b>H</figref> illustrates a process of upscaling a patch image included in an image frame taking into account edges of the patch image determined based on received or determined relationship information for the patches, according to some embodiments.</p><p id="p-0390" num="0458">At <b>670</b>, a decoder determines edges of an attribute patch image or a depth patch image in an image frame based on the determined relationships (e.g. determined from an occupancy map and/or auxiliary information). For example, <figref idref="DRAWINGS">FIG. <b>6</b>I</figref> illustrates an edge extraction process being applied to a geometry plane <b>680</b> to determine edges <b>682</b> of patch images in the geometry image frame.</p><p id="p-0391" num="0459">At <b>670</b>, an attribute patch image or depth patch image is up-scaled. For example, any of the up-scaling and down-scaling processes described herein may take advantage of determined relationships as described for an encoder or decoder in regards to <figref idref="DRAWINGS">FIGS. <b>6</b>A-<b>6</b>I</figref>. For example, <figref idref="DRAWINGS">FIG. <b>6</b>I</figref> also illustrates an attribute patch image <b>684</b> being up-scaled.</p><p id="p-0392" num="0460">At <b>674</b>, edges of the up-scaled attribute or depth patch image are updated based on an interpolation between points of the extracted edges determined at <b>670</b>. For example, <figref idref="DRAWINGS">FIG. <b>6</b>I</figref> illustrates a directed interpolation step included in the processing of attribute plane <b>684</b> to result in up-scaled attribute plane <b>686</b>.</p><heading id="h-0039" level="2">Bit Stream Structure for Compressed Point Cloud Data</heading><p id="p-0393" num="0461">As discussed above and in more detail in regard to <figref idref="DRAWINGS">FIGS. <b>13</b> and <b>14</b></figref>, there is considerable interest in augmented and virtual reality applications and in the use and compression of 3 dimensional data to support them. One such form of data includes point cloud representations, where objects are specified as a series of points that are described in terms of 3D geometry and a set of attributes per point that may include information such as color, reflectance, time, or other types of information. Compression of such information is highly desirable given the amount of space and bandwidth such data would require if not compressed.</p><p id="p-0394" num="0462">One method that has been proposed for compressing point cloud data is described above in regard to packing patches into video frames and may be further extended to achieve near lossless or lossless performance by further encoding points that are &#x201c;missed&#x201d; or not included in the patches.</p><p id="p-0395" num="0463">The encoder and decoder diagrams as shown in <figref idref="DRAWINGS">FIGS. <b>5</b>A and <b>5</b>B</figref> show how that process is performed. In some embodiments, the point cloud data is first segmented into multiple 2D projected images/videos, each representing different types of information. Segmentation is performed by dividing the point cloud into multiple patches that permit one to efficiently project the entire 3D space data onto 2D planes. Each patch is associated with information such as geometry, texture, and other attributes if they are available. Such information is then copied at the co-located locations on separate image sequences with each now containing only the geometry information, the texture information, and any other remaining attributes respectively. Auxiliary information that contains the patch information as well as an occupancy map that dictates which areas in these projected image sequences correspond to actual point cloud data and which are unoccupied, e.g. may contain no or dummy data (e.g. padded data), are also provided. Compression is then applied on such information using different strategies. Auxiliary information, for example, can be entropy coded, while occupancy maps may be down-converted and encoded using either conventional image/video codecs or other methods such as run length compression. The separate projected image sequences may be compressed using conventional codecs. This results in a collection of multiple sub streams, e.g. a geometry sub stream, texture and attribute sub streams, as well as occupancy and auxiliary information sub streams. All these streams are multiplexed together to generate the final point cloud bit stream as shown in the bit stream structure illustrated in <figref idref="DRAWINGS">FIG. <b>6</b>C</figref>.</p><p id="p-0396" num="0464">In some embodiments, the structure specified in <figref idref="DRAWINGS">FIG. <b>6</b>C</figref> may be quite rigid and inflexible, and may not account for certain applications, especially low delay applications, that would require all information corresponding to a single point cloud frame in time to be efficiently signaled and decoded within a constrained time frame. The bit stream architecture illustrated in <figref idref="DRAWINGS">FIG. <b>6</b>C</figref> may also impose considerable penalties in terms of memory and delay. In some embodiments, a point cloud video sequence is segmented into multiple groups of point cloud frames (GOFs). Group of Frames or GOFs may consist of multiple layers of information, with each one representing different types of data, such as geometry and texture information among others. In some embodiments, a point cloud compression PCC decoder is required to first decode and store the entire geometry video stream for each GOF, as well as any associated information with it, followed by the related texture video stream before starting to reconstruct each frame within a GOF (one may argue that point cloud reconstruction can follow the decoding order of the texture video stream). However, the memory requirements may be reduced by scanning the bit stream and finding the appropriate location of each sub-bit stream (e.g. geometry, occupancy/auxiliary info, texture) and decoding them in parallel. However, this assumes that such streams are restricted in using the same coding order and structures.</p><p id="p-0397" num="0465">When all the data is sequentially signaled without any markers to indicate the positions of different sub streams, there may be a significant disadvantage of time delay. For example, one frame cannot be reconstructed until all the group of frame GOF information is decoded. Also, the bit stream cannot be decoded in parallel unless every data has information of its own size. To resolve this issue, in some embodiments the concept of a coding unit, which may be referred to herein as a PCCNAL (Point Cloud Compression Network Abstraction Layer) unit for convenience, that contains information on one or more types of data and its related header information may be used. Encapsulated data can be placed in any location within a bit stream and can be decoded and reconstructed in parallel.</p><p id="p-0398" num="0466">In some embodiments, signaling methods of the parameters may not be defined or limited. The names of the parameters may not be limited as long as the parameters serve the same purpose. The actual value or code words of each parameter may not be limited as long as each function of the parameter is identified by the numbers.</p><p id="p-0399" num="0467">For example, a bit stream structure for compressed Point Cloud Data that is more flexible and that permits the delivery of point cloud data for low delay applications may be used. The bit stream structure may also enable other features such as unequal error protection, reordering, and reduced memory footprint, among others. Furthermore, the parameters and/or component units which are used to identify the different methods and definitions used over the entire slice, frame, GOP, or sequence of the Point Cloud Data may also be considered in some embodiments. An example of a component unit that is defined and used within a point cloud compression PCC bit stream is the Point Cloud Compression Network Abstraction Layer (PCCNAL) unit. In particular, a PCCNAL unit may be defined as a set of data that contains one or more types of information and that can be placed anywhere in the bit stream. However, placement may be limited within a particular period.</p><p id="p-0400" num="0468">Some other properties of the PCCNAL unit include:<ul id="ul0069" list-style="none">    <li id="ul0069-0001" num="0000">    <ul id="ul0070" list-style="none">        <li id="ul0070-0001" num="0469">PCCNAL header: sequence of bits that indicates the start of the unit and/or the type of the unit. Such a header may contain a &#x201c;start code&#x201d; indicator that is a unique sequence that should not be present anywhere else within the PCCNAL, and can help in identifying such a unit. Start code emulation prevention methods could be used to avoid the presence of equivalent signatures within the stream.</li>        <li id="ul0070-0002" num="0470">PCCNAL index: index to identify different PCCNAL units</li>        <li id="ul0070-0003" num="0471">PCCNAL size: size of the PCCNAL unit</li>        <li id="ul0070-0004" num="0472">PCCNAL trailing bits: Such information is optional, and similar to the start code, this is a unique signature that can help in identifying the end of a PCCNAL unit</li>        <li id="ul0070-0005" num="0473">PCCNAL GoF index: Corresponding GoF index to the PCCNAL units</li>        <li id="ul0070-0006" num="0474">PCCNAL POC: An indexing parameter for such a unit. This index can be used to classify and/or identify each NAL unit and permit grouping of different NAL units based on its value. For example, a geometry and an attribute frame that correspond to the same Point Cloud frame can be given the same index, which helps identify their relationship later during decoding and reconstruction of the point cloud representation. This information may limit placement of PCCNAL units within the bit stream.</li>    </ul>    </li></ul></p><p id="p-0401" num="0475">Each coded block or set of coded blocks can be identified as a PCCNAL unit. Such blocks can include sequence parameter sets, picture parameter sets, geometry video data, occupancy data, texture video data, geometry frame, occupancy frame and texture frame amongst others. For example, Geometry video stream in <figref idref="DRAWINGS">FIG. <b>7</b>A</figref> can correspond to geometry video data PCCNAL(PCCNAL-GEO), auxiliary info &#x26; occupancy maps can correspond to PCCNAL-OCC and Texture video stream can correspond to PCCNAL-ATT. In an alternative embodiment, all of the geometry video data, occupancy data and texture video data can comprise one PCCNAL unit.</p><p id="p-0402" num="0476">Examples of PCCNAL unit are as following:<ul id="ul0071" list-style="none">    <li id="ul0071-0001" num="0000">    <ul id="ul0072" list-style="none">        <li id="ul0072-0001" num="0477">PCCNAL-SPS: set of parameters used and can be applied over the entire sequence</li>        <li id="ul0072-0002" num="0478">PCCNAL-PPS: set of parameters used and can be applied over the entire frame/picture</li>        <li id="ul0072-0003" num="0479">PCCNAL-GOF: set of parameters used and can be applied over the entire GOF</li>        <li id="ul0072-0004" num="0480">PCCNAL-OCC: set of occupancy map information</li>        <li id="ul0072-0005" num="0481">PCCNAL-GEO: set of geometry data information</li>        <li id="ul0072-0006" num="0482">PCCNAL-ATT: set of texture data information</li>        <li id="ul0072-0007" num="0483">PCCNAL-FRM: information on single frame</li>        <li id="ul0072-0008" num="0484">PCCNAL-GEOFRM: geometry information on single frame</li>        <li id="ul0072-0009" num="0485">PCCNAL-ATTFRM: texture information on single frame</li>        <li id="ul0072-0010" num="0486">PCCNAL-OCCFRM: occupancy map information on single frame</li>    </ul>    </li></ul></p><p id="p-0403" num="0487">The above information could also be defined for sub-frames, e.g. slices, group of coding tree units (CTUs) or macroblocks, tiles, or groups of slices or tiles. They can also be specified for a group of frames that does not necessarily need to be equal to the number of frames in a GOF. Such group of frames may be smaller or even larger than a GOF. In the case that this is smaller, it is expected that all frames inside this group would be a subset of a GOF. If larger, it is expected that the number would include several complete GOFs, which might not necessarily be of equal length. <figref idref="DRAWINGS">FIG. <b>7</b>B</figref> is an example illustration of the conceptual structure of PCC encoded bit stream with PCCNAL units</p><p id="p-0404" num="0488">In some embodiments, the PCCNAL units can be signaled sequentially without any marker.</p><p id="p-0405" num="0489">In some embodiments, PCCNAL units can have a PCCNAL header, which may include a start code and/or contain PCCNAL trailing bits. The PCCNAL header is located at the beginning of a PCCNAL unit and the PCCNAL trailing bits are located the end of a PCCNAL unit. By having a PCCNAL header and/or a PCCNAL trailing bits, the decoder can jump to the point where the proper data is located without decode from the beginning to the data.</p><p id="p-0406" num="0490">For example, in the PCCNAL header a start code can be included, which can help in detecting a PCCNAL unit. A start code is a unique sequence of bits that should not be used for representing any other data within such a unit. When such start code is detected, it may be known that the following bits would correspond to particular information relating to such a unit, including its identification information as well as any related payload that would correspond to such an identifier. For example, an identifier equal to 000000, assuming 6 bits for the identifier, can indicate the PCCNAL is GoF Header Unit, while an identifier equal to 000001 can indicate that the payload includes Geometry Data information. Other identifiers could correspond to occupancy information, attributes, and so on and such could be defined by the application or user (e.g. engineer configuring the encoder/decoder). It should be pointed out that although start codes are present at the beginning of a particular unit, it might be possible to also define a &#x201c;start code&#x201d; that follows a fixed number of bits or syntax elements, which may be referred to herein as a &#x201c;preamble&#x201d; sequence. For example, the preamble sequence may include the unit identifier as well as the POCNAL POC parameter. If the parameters in the preamble sequence use variable arithmetic encoding, encoding them in right to left order in the bit stream (e.g. the least significant bit of the encoded parameter is written first in the stream and the most significant one is written last). This is not necessary, but could still be used for fixed length parameters.</p><p id="p-0407" num="0491">In some embodiments, a PCCNAL header can contain the size of its own PCCNAL size instead of PCCNAL header bits.</p><p id="p-0408" num="0492">In some embodiments, a PCCNAL header can have both PCCNAL size and PCCNAL header bits.</p><p id="p-0409" num="0493">In some embodiments, a PCCNAL can have trailing bits to indicate the end of the PCCNAL unit.</p><p id="p-0410" num="0494">In some embodiments, a PCCNAL can have its corresponding GoF index.</p><p id="p-0411" num="0495">In some embodiments, a PCCNAL can have its corresponding POC index.</p><p id="p-0412" num="0496">In some embodiments, a PCCNAL can have its corresponding a type identifier.</p><p id="p-0413" num="0497">In some embodiments, with the PCCNAL header, PCCNAL units in a bit stream can be located without any fixed order. For example, in some embodiments PCCNAL units can be placed in any order within a bit stream, within the limitations of the PCCNAL POC. Reordering could still be performed during decoding or reconstruction using the value of PCCNAL POC. PCCNAL POC could be a periodic number however, and such reordering should account for such a characteristic. In some embodiments, PCCNAL units can be grouped by their GoF index. In some embodiments, PCCNAL units can be grouped by their POC as depicted in <figref idref="DRAWINGS">FIG. <b>7</b>B</figref>. In some embodiments, PCCNAL units can be grouped by their types as depicted in <figref idref="DRAWINGS">FIG. <b>7</b>C</figref>.</p><p id="p-0414" num="0498">In some embodiments, PCCNAL units can be signaled in different bit streams. Even when they are signaled separately they can be reconstructed properly by PCCNAL header information such as GoF index and/or POC.</p><p id="p-0415" num="0499">For example, when an encoded PCC bit stream is received at the decoder, the decoder may start parsing PCCNAL unit headers. Using information in the headers, a decoder can jump through the bit stream to collect synced occupancy-geometry-texture data. If a header has the size of the PCCNAL unit, it may jump to the end by the size. If a header only contains a start code, it may read through the bit stream until it encounters a new header or a trailing bits sequence. The decoder can also analyze the PCCNAL POC information for each PCCNAL, determine which units contain the same information and then group and reorder them. Such process can permit the compressed point cloud data to be properly decoded and then reconstructed, e.g. by determining which frame in the geometry and attribute video signals correspond to the same point cloud frame and could be used for its reconstruction. This is a similar mechanism as used in scalable video codecs where the decoder scans through the bit stream and determines correspondence of base and enhancement layers based on their POCs.</p><p id="p-0416" num="0500">In an encoded PCC bit stream, there can be several parameters per slice, per frame/picture, per GOP, or per sequence of Point Cloud Data, which signal information that permits proper decoding and rendering of the point cloud data. The parameters can be present in the bit stream more than one once and at different locations. For example, a parameter can be signaled at both the sequence level and at the slice level. In this case, the parameter at the lower level can overwrite the one at the higher level within the level's scope. In another embodiment, the parameter at the lower level can provide additional information that can clarify the characteristics of the parameter at the higher level. Set of these parameters can comprise a PCCNAL unit. Some example of such parameters include the following:<ul id="ul0073" list-style="none">    <li id="ul0073-0001" num="0000">    <ul id="ul0074" list-style="none">        <li id="ul0074-0001" num="0501">PCC frame width, PCC frame height: the &#x201c;nominal&#x201d; width and the height of the frame that the PCC data is mapped. The size can be the same as the size of the output of the video codec. The size can be different from the size of the output of the video codec. In this case the outputs can be resized by a method indicated in the parameter sets or predefined by the user/codec.</li>        <li id="ul0074-0002" num="0502">Resizing type: type of resizing method from decoded video size to PCC frame size</li>        <li id="ul0074-0003" num="0503">Group of Frames size: the number of frames in one group of frames can be signaled.</li>        <li id="ul0074-0004" num="0504">Chroma format: Chroma format of the geometry data video and texture data video can be signaled. If necessary, Chroma format of occupancy map can be signaled as well. The format can be signaled once for both video layers or can be signaled separately for each video layer. Such information could also be inferred from the video bit stream and does not necessarily need to be present in the PCCNAL unit again.</li>        <li id="ul0074-0005" num="0505">Input, output bit depth: This syntax defines the bit depth of input PCC data and output PCC data are signaled.</li>        <li id="ul0074-0006" num="0506">Internal bit depth: This syntax element defines the bit depth of the data for internal computation in the PCC. During the internal computation, the input data is adjusted to be within the range of internal bit depth. Such information could also be inferred from the video bit stream and does not necessarily need to be present in the PCCNAL unit again.</li>        <li id="ul0074-0007" num="0507">Type of the video codec: This syntax element defines the video codec, e.g. AVC, HEVC, AV1 or some other codec, as well as the corresponding profile and level information, that is used for encoding the Geometry and Attribute projected video data. Such a syntax element can be signaled once for both the Geometry and Attribute video signals, or can be signaled independently for each video signal. Such information could also be omitted and be inferred by the characteristics of and information within the video stream.</li>        <li id="ul0074-0008" num="0508">Layers for each stream        <ul id="ul0075" list-style="none">            <li id="ul0075-0001" num="0509">Presence of layers: a flag that indicates that there are more than 1 layers for the geometry data/attribute data/occupancy map in the bit stream</li>            <li id="ul0075-0002" num="0510">Number of layers: in the case that the layers are more than 1, the number of layers is also signaled. This syntax element defines the number of layers that the Geometry and Attributes data video have. Each layer contains information about the points mapped to a same pixel in a patch but each one corresponds to a different depths.</li>            <li id="ul0075-0003" num="0511">Minimum number of layers: This is an optional syntax element that defines the minimum number of layers present in the bit streams</li>            <li id="ul0075-0004" num="0512">Each video layer can use a different type of a video codec. The type of the video codec used for a particular layers can be signaled.</li>        </ul>        </li>        <li id="ul0074-0009" num="0513">Occupancy map        <ul id="ul0076" list-style="none">            <li id="ul0076-0001" num="0514">Presence of an occupancy map: a flag that indicates the presence of occupancy map in the bit stream</li>            <li id="ul0076-0002" num="0515">Coding type of the occupancy map: in case that occupancy map is present, the type of the coding method used for the occupancy map is also signaled. For example, the occupancy map can be coded with a video codec or another method defined in the specification.</li>        </ul>        </li>    </ul>    </li></ul></p><heading id="h-0040" level="1">Example Methods of Compressing and Decompressing Point Clouds</heading><p id="p-0417" num="0516"><figref idref="DRAWINGS">FIG. <b>8</b>A</figref> illustrates a process for compressing attribute and spatial information of a point cloud, according to some embodiments.</p><p id="p-0418" num="0517">At <b>802</b>, a point cloud is received by an encoder. The point cloud may be captured, for example by one or more sensors, or may be generated, for example in software.</p><p id="p-0419" num="0518">At <b>804</b>, compressed point cloud information is determined, using any of the techniques described herein or using one more combinations of the techniques described herein.</p><p id="p-0420" num="0519">At <b>806</b>, a compressed point cloud is encoded using the compressed point cloud information determined at <b>804</b>. The point cloud may be compressed using any of the techniques described herein.</p><p id="p-0421" num="0520"><figref idref="DRAWINGS">FIG. <b>8</b>B</figref> illustrates a process for decompressing attribute and spatial information of a point cloud, according to some embodiments.</p><p id="p-0422" num="0521">At <b>803</b> an encoded point cloud is received. The point cloud may have been encoded using any of the encoding techniques described herein, such as patch images packed into an image frame that is then encoded by a video encoder. In some embodiments, the encoded point cloud may comprise point cloud projections, such as projections onto a cube, cylinder, sphere, etc. that are then encoded via a video encoder.</p><p id="p-0423" num="0522">At <b>805</b>, spatial and attribute information for the encoded point cloud is determined. For example, a video decoder may be used to decode video encoded packed images or projects. Spatial information may then be determined based on the packed images or projections and combined to determine spatial information for points of the point cloud. For example, depth information for points of a patch may be matched with X and Y information for the points of the patch to determine spatial information for the points of the patch in 3D space. In a similar manner other attributes, included in patch images such as color attributes, texture attributes, etc. may be matched with corresponding points to determine attribute values for the points. Also, in the case of multiple projections, the same point may be identified in more than one of the projections to determine spatial information for the point in 3D space.</p><p id="p-0424" num="0523">At <b>807</b>, a decompressed point cloud may be provided to a recipient device or module.</p><p id="p-0425" num="0524"><figref idref="DRAWINGS">FIG. <b>8</b>C</figref> illustrates patch images being generated and packed into an image frame to compress attribute and spatial information of a point cloud, according to some embodiments.</p><p id="p-0426" num="0525">At <b>810</b>, patches are determined for portions of point cloud. For example patches may be determined as described above. At <b>825</b> patch information for the patches may be generated and at <b>826</b>, may be encoded to be sent to a decoder. In some embodiments, encoded patch information may be separately encoded from one or more image frames comprising packed patch images.</p><p id="p-0427" num="0526">At <b>811</b>, a first patch (or next patch is selected). At <b>812</b> a color (e.g. attribute) patch image is generated for the points of the point cloud included in the patch. At <b>814</b>, one or more additional attribute images, such as a texture attribute image, are generated for the points of the point cloud included in the patch.</p><p id="p-0428" num="0527">At <b>813</b>, spatial information images are generated for the points of the point cloud included in the patch. In some embodiments, to generate the spatial information images, the points of the point cloud are projected, at <b>815</b>, onto a patch plane perpendicular to a normal vector normal to a surface of the point cloud at the patch location. At <b>817</b> a first spatial image is generated for the patch based on the points being projected on the patch plane at <b>815</b>. In addition, depth information for the points of the patch relative to the patch plane is determined at <b>816</b>, and at <b>818</b> a depth patch image is generated based on the depth information determined at <b>816</b>.</p><p id="p-0429" num="0528">At <b>819</b>, it is determined whether there are additional patches for which patch images are to be generated. If so, the process reverts to <b>811</b> for the next patch. If not, at <b>820</b> the patch images for the patches are packed into one or more image frames. In some embodiments, patch images for respective patches may be packed before patch images are determined for other patches. At <b>821</b>, an occupancy map is generated based on where the patch images were placed when being packed into the one or more image frames. At <b>824</b>, the occupancy map is encoded. As discussed above, in some embodiments, the occupancy map may be encoded using an arithmetic encoder, entropy encoder etc. Also, in some embodiments, the occupancy map may be encoded using a video encoder, wherein the occupancy map is organized as an additional image frame that corresponds with a patch image frame and that represents portions of the patch image frame that are occupied with patch images (e.g. occupied pixels) and portions of the patch image frame that are padded (e.g. non-occupied pixels). Video encoding of an occupancy map is discussed in more detail below in <figref idref="DRAWINGS">FIGS. <b>12</b>A-<b>12</b>C</figref>.</p><p id="p-0430" num="0529">At <b>822</b>, spaces in the one or more image frames that are not occupied by patch images are padded. In some embodiments, an occupancy map for a patch image frame may be generated before or after the patch image frame is padded at <b>822</b>.</p><p id="p-0431" num="0530">At <b>823</b>, the one or more image frames are video encoded, such as in accordance with a high efficiency video coding (HEVC) standard. In some embodiments, in which an occupancy map is represented by an occupancy map video image frame, the occupancy map video image frame may be video encoded at <b>823</b>.</p><p id="p-0432" num="0531"><figref idref="DRAWINGS">FIG. <b>9</b></figref> illustrates patch images being generated and packed into an image frame to compress attribute and spatial information of a moving or changing point cloud, according to some embodiments.</p><p id="p-0433" num="0532">At <b>930</b>, point cloud information for a previously encoded point cloud is received wherein the point cloud information represents a subsequent version of the previously encoded point cloud. For example, the subsequent version may be a representation of the point cloud at a subsequent moment in time, wherein the point cloud is moving or changing as time progresses.</p><p id="p-0434" num="0533">At <b>931</b>, it is determined if any new patches need to be determined for the point cloud. For example, an object not currently in the previously encoded point cloud may have been added to the point cloud. For example, the point cloud may be a point cloud of a road and a ball may have entered into the road. If there is a need to add a new patch, the occupancy map is updated at <b>933</b> to include the new patch and encoded at <b>934</b>. Also, at <b>932</b> patch images are generated for the new patch in similar manner as described in <b>812</b>-<b>814</b>. The generated patch images are included in packing at <b>943</b>.</p><p id="p-0435" num="0534">At <b>935</b>, a first or next patch of the patches generated for the reference (previous) point cloud is selected. At <b>936</b>, the points of the patch are re-sampled as described herein. At <b>937</b> motion vectors for the points included in the selected patch between the reference point cloud and the current point cloud are determined. At <b>940</b> the motion vectors are used to generate a relative motion patch image. For example, in some embodiments, generating a relative motion patch image may comprise, encoding, at <b>941</b>, vector motion in different directions using different image characteristics, as described herein. At <b>938</b> an updated color patch image is generated. In some embodiments, the updated color patch image may encode residual values indicating differences in colors of the points of the point cloud included in the patch between the reference point cloud and the current point cloud. In a similar manner, at <b>939</b>, other attribute update patch images may be generated.</p><p id="p-0436" num="0535">At <b>942</b>, it is determined whether there are additional patches to be evaluated. If so, the process reverts to <b>935</b> for the next patch. If not, at <b>943</b> the patch images for the patches are packed into one or more image frames. In some embodiments, patch images for respective patches may be packed before patch images are determined for other patches.</p><p id="p-0437" num="0536">At <b>944</b>, spaces in the one or more image frames that are not occupied by patch images are padded.</p><p id="p-0438" num="0537">At <b>945</b>, the one or more image frames are video encoded, such as in accordance with a high efficiency video coding (HEVC) standard.</p><p id="p-0439" num="0538"><figref idref="DRAWINGS">FIG. <b>10</b></figref> illustrates a decoder receiving image frames comprising patch images, patch information, and an occupancy map, and generating a decompressed representation of a point cloud, according to some embodiments.</p><p id="p-0440" num="0539">At <b>1050</b>, an occupancy map is received by a decoder, at <b>1051</b> patch information is received by the decoder. In some embodiments the occupancy map and the patch information may be encoded and the decoder may decode the occupancy map and the patch information (not shown). At <b>1052</b>, the decoder receives one or more encoded video image frames. At <b>1052</b> the decoder identifies patch images in the one or more encoded video image frames and at <b>1054</b> the decoder decodes the encoded video image frames. In some embodiments, the decoder may utilize the occupancy map and the patch information to identify active and non-active portions of the one or more encoded video images and may adjust one or more decoded parameters used to decode the encoded video images based on whether portions, e.g. blocks, sub-blocks, pixels, etc. comprise active or non-active information.</p><p id="p-0441" num="0540">At <b>1055</b>, the decoder determines spatial information and/or attribute information for the points of the respective patches and at <b>1056</b> generates a decompressed representation of the point cloud encoded in the one or more encoded video images.</p><p id="p-0442" num="0541">In some embodiments, active and non-active portions of an image frame may be indicated by a &#x201c;mask.&#x201d; For example, a mask may indicate a portion of an image that is a padding portion or may indicate non-active points of a point cloud, such as points that are hidden from view in one or more viewing angles.</p><p id="p-0443" num="0542">In some embodiments, a &#x201c;mask&#x201d; may be encoded along with patch images or projections. In some embodiments, a &#x201c;mask&#x201d; may show &#x201c;active/available&#x201d; points and &#x201c;non-active/non-available&#x201d; points in space. In some embodiments, a mask may be independent from a texture and a depth patch image. In some embodiments, a mask may be combined with other information, such as a texture or depth patch image. For example, by indicating that certain values in a signal range correspond to active points, e.g. values above 16 and below 235 in an 8 bit image, and that other values correspond to non-active points, e.g. values below 16 or values above 235 in an 8 bit image. In some embodiments, additional considerations may be taken to avoid or reduce contamination between active and non-active regions. For example, it may be necessary to make use of lossless or visually lossless coding at the boundaries between active and non-active regions.</p><p id="p-0444" num="0543">In some embodiments, a mask may be utilized in a variety of ways for improving coding efficiency. For example, a mask may be used with projection methods such as cylindrical, spherical or multiple projection as wells as decomposition into patches. In addition, a mask may be used with a cubic projection method.</p><p id="p-0445" num="0544"><figref idref="DRAWINGS">FIG. <b>11</b>A</figref> illustrates an encoder, adjusting encoding based on one or more masks for a point cloud, according to some embodiments.</p><p id="p-0446" num="0545">At <b>1162</b>, an encoder receives a point cloud. At <b>1164</b>, the encoder generate multiple projections or patch images as described herein, for the received point cloud. At <b>1166</b>, the encoder determines or more masks. The masks may be hidden points, padded portions of an image frame, points not viewable from a particular view-point, etc. At <b>1168</b>, the encoder adjusts one or more encoding parameters based on the masks. For example the encoder may adjust a budget allocated to masked portions. Additional adjustments that an encoder may perform are described. At <b>1168</b>, the encoder encodes a compressed point cloud, for example via one or more video encoded image frames.</p><p id="p-0447" num="0546"><figref idref="DRAWINGS">FIG. <b>11</b>B</figref> illustrates a decoder, adjusting decoding based on one or more masks for a point cloud, according to some embodiments.</p><p id="p-0448" num="0547">At <b>1170</b>, a decoder receives an encoded point cloud. At <b>1172</b>, the decoder determines one or more masks for portions of the encoded point cloud. For example, the encoder may determine portions of image frames representing the compressed point cloud correspond to padding. Or, for a particular view of the point cloud being rendered by the decoder, the decoder may determine that one or more points of the compressed point cloud are not viewable from the particular point of view. In some embodiments, mask information may indicate which points are hidden when the point cloud is viewed from particular points of view. At <b>1174</b>, the decoder adjusts one or more decoding parameters based on the masks. Adjustments that may be made by a decoder based on active/non-active regions or points (e.g. masks) are described in more detail below. At <b>1176</b> the decoder decodes the compressed point cloud.</p><p id="p-0449" num="0548">In some embodiments, a mask may be used when performing motion estimation and mode decision. Commonly distortion is computed for an entire block. However, some blocks may have blocks that contain a combination of texture data as well as empty/nonvisible areas. For these areas only the textured data are of interest and any distortion in the non-visible areas may be ignored. Therefore, since commonly when performing such processes as motion estimation and mode decision, a distortion computation, such as Sum of Absolute Differences (SAD) or Sum of Square Errors (SSE), is performed, a mask may be used to alter the computation to exclude distortion for the non-visible areas. For example, for the SAD case, distortion may be computed by computing the sum of absolute differences of only samples in a block that correspond to a visible area in a current image. All other samples may be ignored during the computation. In some embodiments, distortion may be normalized at the pixel level thus avoiding having to consider blocks with different number of pixels.</p><p id="p-0450" num="0549">In some embodiments, instead of only considering non-visible samples, samples that are adjacent to non-visible samples, or samples identified to correspond to different projections (but are placed when encoding within the same coding block) may be assigned different weights. For example samples in particular blocks could be considered more important for subjective quality, and a lower distortion tolerance may be assigned. In such case, the weighting for those samples may be increased, thus biasing decisions where the distortion for those samples is lower. Knowledge also that different samples in the same block of a particular size M&#xd7;N during motion estimation or mode decision correspond to different objects, may also help with the determination of the block partitioning mode, e.g. the encoder could make an early decision (based potentially on a preliminary search) on whether different partitioning could/should be used.</p><p id="p-0451" num="0550">In some embodiments, masks may be used for rate control and rate allocation. For example, it may be desirable that blocks that correspond to areas that contain both visible and non-visible samples be encoded at a different, and some times higher, quality than blocks that contain only visible samples. This is done so as to avoid leakage between visible and not visible samples and ensure the best quality at the point-clouds &#x201c;boundaries&#x201d;. Different quality may also be assigned based on depth information, which may also be available on the encoder. Flatter areas may tolerate much more distortion than areas with considerable variance in depth. Control of quality may be performed by adjusting quantization parameters/factors, but also by adjusting other parameters such as the lagrangian multiplier during mode decision, using different quantization matrices if available, enabling and/or adjusting quantization thresholding and the size and/or shapes of zonal quantization.</p><p id="p-0452" num="0551">Quantization may also be adjusted according to the projection method used. If, for example an equirectangular projection method was used to project the object onto a sphere and then onto a 2D plane, it might be desirable to increase quantization on the top and bottom boundaries, and slowly decrease it when moving towards the center/equator. This may help compensate for some of the differences in resolution allocation when using a particular projection method. Different adjustments may also be made to the different color components, again based on similar assumptions, and in consideration again of the mask information.</p><p id="p-0453" num="0552">Quantization may also be performed while considering whether a sample is a visible or a non-visible sample. For example, if a strategy involves the use of dynamic programming/trellis quantization methods for determining the value of a quantized coefficient. In such embodiments, an impact in distortion of a quantized coefficient, as well as its impact on bitrate at multiple reconstruction points may commonly be computed. This may be done for all coefficients while considering their bitrate interactions. Finally a decision may be made for all coefficients jointly by selecting the quantized values that would together result in the best rate distortion performance In some embodiments, the visible and non-visible areas may be considered when computing such metrics.</p><p id="p-0454" num="0553">Similar to the motion estimation and mode decision processes, sample adaptive offset (SAO) techniques also commonly compute the resulting distortion for each possible mode or SAO value that may be used. Again, the decision may exclude non-visible samples, or prioritize, with different weights samples that are close to non-visible samples or samples that correspond to areas with considerably varying depth.</p><p id="p-0455" num="0554">In some embodiments, masks may be used in any other coding process that may involve a distortion computation.</p><p id="p-0456" num="0555">In some embodiments, masks may be used in preprocessing/prefiltering. For example, samples may be prefiltered based on their proximity to non-visible samples so as to reduce the possibility of artifacts and/or remove noise that may make encoding more difficult. Any form of prefiltering, including spatio-temporal filters, may be used.</p><p id="p-0457" num="0556">In some embodiments, prefiltering may be applied to both texture as well as depth information.</p><p id="p-0458" num="0557">Decisions in quantization parameters could also be made at the picture level (temporally) given the amount of visible/non-visible samples and depth variance on different pictures. Such decisions could be quite useful, for example, in a multi-pass coding system where analyze the entire sequence is first analyzed to determine the complexity and relationship of each frame with other frames. The coding parameters may then be decided that will be used for that frame in relationship to all other frames and given an expected quality or bitrate target Similar decisions may also be made, not only for quantization parameters, but also for the picture coding types (i.e. I, P, or B), structures (e.g. hierarchical or not coding of N frames that follows a particular coding order of frames), references to use, weighting parameters, etc.</p><heading id="h-0041" level="2">Encoding and Decoding (Normative Concepts)</heading><p id="p-0459" num="0558">Since a mask is likely to be available losslessly or visually losslessly at the decoder, as well as the depth information, this information may also be used at the decoder (and of course at the encoder) to further improve quality.</p><p id="p-0460" num="0559">For example, deblocking and sample adaptive offset (SAO), as well as adaptive loop filtering (ALF) and deringing (in codecs that support such mechanisms), with exclusion of non-visible samples, samples that correspond to different projections, or samples with very different depth characteristics may use masking information. Instead, it may be desirable to only consider for such filtering methods samples that correspond to the same projection and are not so far from each other (depth wise). This may reduce blockiness and/or other artifacts that these methods try to mitigate. Other future types of in-loop post filtering may also be performed in a similar manner.</p><p id="p-0461" num="0560">As another example, out of loop post filtering with visible/non-visible/different area segmentation may utilize masking information.</p><p id="p-0462" num="0561">Implicit adjustment of QP quality parameters based on a certain percentage of visible/non-visible samples within a block may be performed. This may reduce signaling of coding parameters if such switching occurs frequently in a bit stream.</p><p id="p-0463" num="0562">Adjustment of the transform type based on the percentage of visible/non-visible samples may be performed, including the consideration of shape adaptive discrete cosine transforms (DCT transforms).</p><p id="p-0464" num="0563">Adjustment of overlapped block motion compensation techniques may utilize masking information, if existing in a codec, to mask away non-visible samples. A similar consideration may be performed for block motion compensation and/or intra prediction (including an intra block copy method). Samples that are considered visible may be considered when constructing a prediction signal, including also when interpolating to perform subpixel motion compensation or when performing bi-prediction. Masks from the current picture may be considered, but if desired, both the masks from the current picture as well as the masks corresponding to the reference pictures could be considered. Such considerations may be made adaptive at the encoder, through some form of signaling, i.e. at the sequence, picture, tile, slice, or even CTU/block level.</p><p id="p-0465" num="0564">In some embodiments, clipping of the final value based on the mask or depth information may be performed.</p><p id="p-0466" num="0565">In some embodiments, other prediction methods that may exist inside a codec (e.g. in AV1 or the Versatile Video Coding (VVC) standard currently being developed by the JVET team in MPEG) may be similarly adjusted or constrained based on the existence (and amount) of visible and non-visible points, and points corresponding to different projections.</p><p id="p-0467" num="0566">In some embodiments, different control/adjustments may be applied to different color components as well as to the depth information.</p><heading id="h-0042" level="2">Methods of Occupancy Map Compression</heading><heading id="h-0043" level="2">Arithmetic Compression</heading><p id="p-0468" num="0567"><figref idref="DRAWINGS">FIG. <b>12</b>A</figref> illustrates more detail regarding compression of an occupancy map, according to some embodiments. The steps shown in <figref idref="DRAWINGS">FIG. <b>12</b>A</figref> may be performed as part of steps <b>821</b> or <b>933</b> as described above. In some embodiments, any of the occupancy map compression techniques described herein may be performed at <b>821</b> or <b>933</b>.</p><p id="p-0469" num="0568">At <b>1280</b> a list of candidate patches is determined for each block or modified block of an occupancy map.</p><p id="p-0470" num="0569">At <b>1281</b>, the lists of candidate patches for each block are ordered in a reverse order as an order in which the patches were packed into the image frame. For example, the patches may be packed into an image, with larger patches packed before smaller patches. In contrast, the candidate list for each block of an occupancy map may include smaller patches before larger patches. At <b>1282</b>, an arithmetic encoder may be used to encode the patch candidate list for each block. In some embodiments, an entropy encoder may be used. Also, in some embodiments, empty blocks may be assigned a special value, such as zero, whereas patch candidates may be assigned numbers corresponding to a patch number, such as 1, 2, 3, etc.</p><p id="p-0471" num="0570">At <b>1283</b>, for each block sub-blocks are determined according to a determined precision value. The determined precision value may be encoded with the occupancy map such that a decoder may determine the determined precision value used at the encoder.</p><p id="p-0472" num="0571">At <b>1284</b>, for each block, a binary value (e.g. 0 or 1) is determined for each sub-block of the block. Full sub-blocks are assigned a different binary value than non-full sub-blocks. If all sub-blocks of a block are full, the block may be assigned a binary &#x201c;full&#x201d; value.</p><p id="p-0473" num="0572">At <b>1285</b>, for each non-full sub-block, a traversal order is determined. For example, any of the example traversal orders shown in <figref idref="DRAWINGS">FIG. <b>12</b>B</figref> (or other traversal orders) may be determined. A run-length encoding strategy as described above in regard to occupancy map compression may be used to encode the binary values for the sub-blocks using the determined traversal order.</p><p id="p-0474" num="0573"><figref idref="DRAWINGS">FIG. <b>12</b>B</figref> illustrates example blocks and traversal patterns for compressing an occupancy map, according to some embodiments. The traversal patterns may be used as described above in regard to occupancy map compression and in <figref idref="DRAWINGS">FIG. <b>12</b>A</figref>. For example, <figref idref="DRAWINGS">FIG. <b>12</b>B</figref> illustrates block <b>1286</b> of an occupancy map that includes multiple sub-blocks <b>1287</b>.</p><heading id="h-0044" level="2">Video-Based Compression</heading><p id="p-0475" num="0574"><figref idref="DRAWINGS">FIG. <b>12</b>C</figref> illustrates more detail regarding compression of an occupancy map, according to some embodiments. The steps shown in <figref idref="DRAWINGS">FIG. <b>12</b>C</figref> may be performed as part of steps <b>821</b> or <b>933</b> as described above. In some embodiments, any of the occupancy map compression techniques described herein may be performed at <b>821</b> or <b>933</b>.</p><p id="p-0476" num="0575">At <b>1290</b>, for each patch image frame, such as image frames comprising depth information patches or attribute value patches, a corresponding occupancy map image frame is generated. The occupancy map image frame may have a same frame size as the patch image frame and when placed over the patch image frame the pixels of the occupancy map image frame may match up with corresponding pixels in the patch image frame. Because of this, a binary value may be assigned to each of the pixels of the occupancy map image frames to indicate whether the same corresponding pixel in the patch image frame is an occupied pixel or a padded pixel. In some embodiments, an occupancy map image frame may be smaller than its corresponding patch image frame. In such embodiments, different values may be assigned to the occupancy map image frame pixel to indicate whether its corresponding pixels in the patch image frame are occupied or padded. For example, a single occupancy map image frame pixel may correspond to multiple patch image frame pixels, wherein a first value indicates a first combination of occupied and unoccupied pixels in the patch image frame and another value indicates a different combination. As an example, say a single occupancy map pixel corresponds to two patch image map pixels. In such an embodiments, a first value in the occupancy map for the occupancy map pixel may indicate that both the patch image pixels are un-occupied, a second value may indicate that both are occupied, a third value may indicate that an upper one of the two pixels is occupied and the other is un-occupied and a fourth value may indicate that a lower one of the two pixels is occupied and the other is un-occupied. For example, each block of the occupancy map may be a multiple larger than a block of the patch image frame (e.g. the occupancy map may have a lower resolution than the patch image frame). Different color values (e.g. the 1<sup>st</sup>, 2<sup>nd</sup>, 3<sup>rd</sup>, 4<sup>th </sup>value, etc.) may represent sub-divisions of the occupancy map that correspond with multiple pixels of the patch image frame.</p><p id="p-0477" num="0576">At <b>1292</b> a list of candidate patches is determined for each block of the patch image frames.</p><p id="p-0478" num="0577">At <b>1294</b>, the lists of candidate patches for each block are ordered in a reverse order as an order in which the patches were packed into the image frame. For example, the patches may be packed into an image, with larger patches packed before smaller patches. In contrast, the candidate list for each block of the patch image frame may include smaller patches before larger patches.</p><p id="p-0479" num="0578">At <b>1296</b>, the occupancy map image frames are video encoded.</p><p id="p-0480" num="0579">At <b>1298</b>, an arithmetic encoder may be used to encode auxiliary information, such as the patch candidate list for each block. In some embodiments, an entropy encoder may be used.</p><heading id="h-0045" level="1">Example Applications Using Point Cloud Encoders and Decoders</heading><p id="p-0481" num="0580"><figref idref="DRAWINGS">FIG. <b>13</b></figref> illustrates compressed point clouds being used in a 3-D telepresence application, according to some embodiments.</p><p id="p-0482" num="0581">In some embodiments, a sensor, such as sensor <b>102</b>, an encoder, such as encoder <b>104</b> or any of the other encoders described herein, and a decoder, such as decoder <b>116</b> or any of the decoders described herein, may be used to communicate point clouds in a 3-D telepresence application. For example, a sensor, such as sensor <b>102</b>, at <b>1302</b> may capture a 3D image and at <b>1304</b>, the sensor or a processor associated with the sensor may perform a 3D reconstruction based on sensed data to generate a point cloud.</p><p id="p-0483" num="0582">At <b>1306</b>, an encoder such as encoder <b>104</b> may compress the point cloud and at <b>1308</b> the encoder or a post processor may packetize and transmit the compressed point cloud, via a network <b>1310</b>. At <b>1312</b>, the packets may be received at a destination location that includes a decoder, such as decoder <b>116</b>. The decoder may decompress the point cloud at <b>1314</b> and the decompressed point cloud may be rendered at <b>1316</b>. In some embodiments a 3-D telepresence application may transmit point cloud data in real time such that a display at <b>1316</b> represents images being observed at <b>1302</b>. For example, a camera in a canyon may allow a remote user to experience walking through a virtual canyon at <b>1316</b>.</p><p id="p-0484" num="0583"><figref idref="DRAWINGS">FIG. <b>14</b></figref> illustrates compressed point clouds being used in a virtual reality (VR) or augmented reality (AR) application, according to some embodiments.</p><p id="p-0485" num="0584">In some embodiments, point clouds may be generated in software (for example as opposed to being captured by a sensor). For example, at <b>1402</b> virtual reality or augmented reality content is produced. The virtual reality or augmented reality content may include point cloud data and non-point cloud data. For example, a non-point cloud character may traverse a landscape represented by point clouds, as one example. At <b>1404</b>, the point cloud data may be compressed and at <b>1406</b> the compressed point cloud data and non-point cloud data may be packetized and transmitted via a network <b>1408</b>. For example, the virtual reality or augmented reality content produced at <b>1402</b> may be produced at a remote server and communicated to a VR or AR content consumer via network <b>1408</b>. At <b>1410</b>, the packets may be received and synchronized at the VR or AR consumer's device. A decoder operating at the VR or AR consumer's device may decompress the compressed point cloud at <b>1412</b> and the point cloud and non-point cloud data may be rendered in real time, for example in a head mounted display of the VR or AR consumer's device. In some embodiments, point cloud data may be generated, compressed, decompressed, and rendered responsive to the VR or AR consumer manipulating the head mounted display to look in different directions.</p><p id="p-0486" num="0585">In some embodiments, point cloud compression as described herein may be used in various other applications, such as geographic information systems, sports replay broadcasting, museum displays, autonomous navigation, etc.</p><heading id="h-0046" level="1">Example Computer System</heading><p id="p-0487" num="0586"><figref idref="DRAWINGS">FIG. <b>15</b></figref> illustrates an example computer system <b>1500</b> that may implement an encoder or decoder or any other ones of the components described herein, (e.g., any of the components described above with reference to <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>14</b></figref>), in accordance with some embodiments. The computer system <b>1500</b> may be configured to execute any or all of the embodiments described above. In different embodiments, computer system <b>1500</b> may be any of various types of devices, including, but not limited to, a personal computer system, desktop computer, laptop, notebook, tablet, slate, pad, or netbook computer, mainframe computer system, handheld computer, workstation, network computer, a camera, a set top box, a mobile device, a consumer device, video game console, handheld video game device, application server, storage device, a television, a video recording device, a peripheral device such as a switch, modem, router, or in general any type of computing or electronic device.</p><p id="p-0488" num="0587">Various embodiments of a point cloud encoder or decoder, as described herein may be executed in one or more computer systems <b>1500</b>, which may interact with various other devices. Note that any component, action, or functionality described above with respect to <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>14</b></figref> may be implemented on one or more computers configured as computer system <b>1500</b> of <figref idref="DRAWINGS">FIG. <b>15</b></figref>, according to various embodiments. In the illustrated embodiment, computer system <b>1500</b> includes one or more processors <b>1510</b> coupled to a system memory <b>1520</b> via an input/output (I/O) interface <b>1530</b>. Computer system <b>1500</b> further includes a network interface <b>1540</b> coupled to I/O interface <b>1530</b>, and one or more input/output devices <b>1550</b>, such as cursor control device <b>1560</b>, keyboard <b>1570</b>, and display(s) <b>1580</b>. In some cases, it is contemplated that embodiments may be implemented using a single instance of computer system <b>1500</b>, while in other embodiments multiple such systems, or multiple nodes making up computer system <b>1500</b>, may be configured to host different portions or instances of embodiments. For example, in one embodiment some elements may be implemented via one or more nodes of computer system <b>1500</b> that are distinct from those nodes implementing other elements.</p><p id="p-0489" num="0588">In various embodiments, computer system <b>1500</b> may be a uniprocessor system including one processor <b>1510</b>, or a multiprocessor system including several processors <b>1510</b> (e.g., two, four, eight, or another suitable number). Processors <b>1510</b> may be any suitable processor capable of executing instructions. For example, in various embodiments processors <b>1510</b> may be general-purpose or embedded processors implementing any of a variety of instruction set architectures (ISAs), such as the x86, PowerPC, SPARC, or MIPS ISAs, or any other suitable ISA. In multiprocessor systems, each of processors <b>1510</b> may commonly, but not necessarily, implement the same ISA.</p><p id="p-0490" num="0589">System memory <b>1520</b> may be configured to store point cloud compression or point cloud decompression program instructions <b>1522</b> and/or sensor data accessible by processor <b>1510</b>. In various embodiments, system memory <b>1520</b> may be implemented using any suitable memory technology, such as static random access memory (SRAM), synchronous dynamic RAM (SDRAM), nonvolatile/Flash-type memory, or any other type of memory. In the illustrated embodiment, program instructions <b>1522</b> may be configured to implement an image sensor control application incorporating any of the functionality described above. In some embodiments, program instructions and/or data may be received, sent or stored upon different types of computer-accessible media or on similar media separate from system memory <b>1520</b> or computer system <b>1500</b>. While computer system <b>1500</b> is described as implementing the functionality of functional blocks of previous Figures, any of the functionality described herein may be implemented via such a computer system.</p><p id="p-0491" num="0590">In one embodiment, I/O interface <b>1530</b> may be configured to coordinate I/O traffic between processor <b>1510</b>, system memory <b>1520</b>, and any peripheral devices in the device, including network interface <b>1540</b> or other peripheral interfaces, such as input/output devices <b>1550</b>. In some embodiments, I/O interface <b>1530</b> may perform any necessary protocol, timing or other data transformations to convert data signals from one component (e.g., system memory <b>1520</b>) into a format suitable for use by another component (e.g., processor <b>1510</b>). In some embodiments, I/O interface <b>1530</b> may include support for devices attached through various types of peripheral buses, such as a variant of the Peripheral Component Interconnect (PCI) bus standard or the Universal Serial Bus (USB) standard, for example. In some embodiments, the function of I/O interface <b>1530</b> may be split into two or more separate components, such as a north bridge and a south bridge, for example. Also, in some embodiments some or all of the functionality of I/O interface <b>1530</b>, such as an interface to system memory <b>1520</b>, may be incorporated directly into processor <b>1510</b>.</p><p id="p-0492" num="0591">Network interface <b>1540</b> may be configured to allow data to be exchanged between computer system <b>1500</b> and other devices attached to a network <b>1585</b> (e.g., carrier or agent devices) or between nodes of computer system <b>1500</b>. Network <b>1585</b> may in various embodiments include one or more networks including but not limited to Local Area Networks (LANs) (e.g., an Ethernet or corporate network), Wide Area Networks (WANs) (e.g., the Internet), wireless data networks, some other electronic data network, or some combination thereof. In various embodiments, network interface <b>1540</b> may support communication via wired or wireless general data networks, such as any suitable type of Ethernet network, for example; via telecommunications/telephony networks such as analog voice networks or digital fiber communications networks; via storage area networks such as Fibre Channel SANs, or via any other suitable type of network and/or protocol.</p><p id="p-0493" num="0592">Input/output devices <b>1550</b> may, in some embodiments, include one or more display terminals, keyboards, keypads, touchpads, scanning devices, voice or optical recognition devices, or any other devices suitable for entering or accessing data by one or more computer systems <b>1500</b>. Multiple input/output devices <b>1550</b> may be present in computer system <b>1500</b> or may be distributed on various nodes of computer system <b>1500</b>. In some embodiments, similar input/output devices may be separate from computer system <b>1500</b> and may interact with one or more nodes of computer system <b>1500</b> through a wired or wireless connection, such as over network interface <b>1540</b>.</p><p id="p-0494" num="0593">As shown in <figref idref="DRAWINGS">FIG. <b>15</b></figref>, memory <b>1520</b> may include program instructions <b>1522</b>, which may be processor-executable to implement any element or action described above. In one embodiment, the program instructions may implement the methods described above. In other embodiments, different elements and data may be included. Note that data may include any data or information described above.</p><p id="p-0495" num="0594">Those skilled in the art will appreciate that computer system <b>1500</b> is merely illustrative and is not intended to limit the scope of embodiments. In particular, the computer system and devices may include any combination of hardware or software that can perform the indicated functions, including computers, network devices, Internet appliances, PDAs, wireless phones, pagers, etc. Computer system <b>1500</b> may also be connected to other devices that are not illustrated, or instead may operate as a stand-alone system. In addition, the functionality provided by the illustrated components may in some embodiments be combined in fewer components or distributed in additional components. Similarly, in some embodiments, the functionality of some of the illustrated components may not be provided and/or other additional functionality may be available.</p><p id="p-0496" num="0595">Those skilled in the art will also appreciate that, while various items are illustrated as being stored in memory or on storage while being used, these items or portions of them may be transferred between memory and other storage devices for purposes of memory management and data integrity. Alternatively, in other embodiments some or all of the software components may execute in memory on another device and communicate with the illustrated computer system via inter-computer communication. Some or all of the system components or data structures may also be stored (e.g., as instructions or structured data) on a computer-accessible medium or a portable article to be read by an appropriate drive, various examples of which are described above. In some embodiments, instructions stored on a computer-accessible medium separate from computer system <b>1500</b> may be transmitted to computer system <b>1500</b> via transmission media or signals such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as a network and/or a wireless link Various embodiments may further include receiving, sending or storing instructions and/or data implemented in accordance with the foregoing description upon a computer-accessible medium. Generally speaking, a computer-accessible medium may include a non-transitory, computer-readable storage medium or memory medium such as magnetic or optical media, e.g., disk or DVD/CD-ROM, volatile or non-volatile media such as RAM (e.g. SDRAM, DDR, RDRAM, SRAM, etc.), ROM, etc. In some embodiments, a computer-accessible medium may include transmission media or signals such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as network and/or a wireless link.</p><p id="p-0497" num="0596">The methods described herein may be implemented in software, hardware, or a combination thereof, in different embodiments. In addition, the order of the blocks of the methods may be changed, and various elements may be added, reordered, combined, omitted, modified, etc. Various modifications and changes may be made as would be obvious to a person skilled in the art having the benefit of this disclosure. The various embodiments described herein are meant to be illustrative and not limiting. Many variations, modifications, additions, and improvements are possible. Accordingly, plural instances may be provided for components described herein as a single instance. Boundaries between various components, operations and data stores are somewhat arbitrary, and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of claims that follow. Finally, structures and functionality presented as discrete components in the example configurations may be implemented as a combined structure or component. These and other variations, modifications, additions, and improvements may fall within the scope of embodiments as defined in the claims that follow</p><?detailed-description description="Detailed Description" end="tail"?></description><us-math idrefs="MATH-US-00001" nb-file="US20230005188A1-20230105-M00001.NB"><img id="EMI-M00001" he="5.67mm" wi="76.20mm" file="US20230005188A1-20230105-M00001.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00002" nb-file="US20230005188A1-20230105-M00002.NB"><img id="EMI-M00002" he="5.25mm" wi="13.38mm" file="US20230005188A1-20230105-M00002.TIF" alt="embedded image " img-content="table" img-format="tif"/></us-math><us-math idrefs="MATH-US-00003 MATH-US-00003-2" nb-file="US20230005188A1-20230105-M00003.NB"><img id="EMI-M00003" he="9.91mm" wi="76.20mm" file="US20230005188A1-20230105-M00003.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00004" nb-file="US20230005188A1-20230105-M00004.NB"><img id="EMI-M00004" he="5.67mm" wi="76.20mm" file="US20230005188A1-20230105-M00004.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00005" nb-file="US20230005188A1-20230105-M00005.NB"><img id="EMI-M00005" he="13.04mm" wi="76.20mm" file="US20230005188A1-20230105-M00005.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00006 MATH-US-00006-2 MATH-US-00006-3 MATH-US-00006-4" nb-file="US20230005188A1-20230105-M00006.NB"><img id="EMI-M00006" he="38.78mm" wi="76.20mm" file="US20230005188A1-20230105-M00006.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00007" nb-file="US20230005188A1-20230105-M00007.NB"><img id="EMI-M00007" he="7.03mm" wi="13.72mm" file="US20230005188A1-20230105-M00007.TIF" alt="embedded image " img-content="table" img-format="tif"/></us-math><us-math idrefs="MATH-US-00008" nb-file="US20230005188A1-20230105-M00008.NB"><img id="EMI-M00008" he="7.03mm" wi="14.82mm" file="US20230005188A1-20230105-M00008.TIF" alt="embedded image " img-content="table" img-format="tif"/></us-math><us-math idrefs="MATH-US-00009" nb-file="US20230005188A1-20230105-M00009.NB"><img id="EMI-M00009" he="5.67mm" wi="76.20mm" file="US20230005188A1-20230105-M00009.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00010" nb-file="US20230005188A1-20230105-M00010.NB"><img id="EMI-M00010" he="6.01mm" wi="76.20mm" file="US20230005188A1-20230105-M00010.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00011" nb-file="US20230005188A1-20230105-M00011.NB"><img id="EMI-M00011" he="12.70mm" wi="76.20mm" file="US20230005188A1-20230105-M00011.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00012" nb-file="US20230005188A1-20230105-M00012.NB"><img id="EMI-M00012" he="6.01mm" wi="76.20mm" file="US20230005188A1-20230105-M00012.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00013" nb-file="US20230005188A1-20230105-M00013.NB"><img id="EMI-M00013" he="9.14mm" wi="76.20mm" file="US20230005188A1-20230105-M00013.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00014 MATH-US-00014-2" nb-file="US20230005188A1-20230105-M00014.NB"><img id="EMI-M00014" he="13.04mm" wi="76.20mm" file="US20230005188A1-20230105-M00014.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00015 MATH-US-00015-2 MATH-US-00015-3 MATH-US-00015-4 MATH-US-00015-5 MATH-US-00015-6" nb-file="US20230005188A1-20230105-M00015.NB"><img id="EMI-M00015" he="33.19mm" wi="76.20mm" file="US20230005188A1-20230105-M00015.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00016 MATH-US-00016-2 MATH-US-00016-3" nb-file="US20230005188A1-20230105-M00016.NB"><img id="EMI-M00016" he="20.07mm" wi="76.20mm" file="US20230005188A1-20230105-M00016.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00017" nb-file="US20230005188A1-20230105-M00017.NB"><img id="EMI-M00017" he="28.53mm" wi="76.20mm" file="US20230005188A1-20230105-M00017.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00018" nb-file="US20230005188A1-20230105-M00018.NB"><img id="EMI-M00018" he="8.13mm" wi="60.28mm" file="US20230005188A1-20230105-M00018.TIF" alt="embedded image " img-content="table" img-format="tif"/></us-math><us-math idrefs="MATH-US-00019" nb-file="US20230005188A1-20230105-M00019.NB"><img id="EMI-M00019" he="8.13mm" wi="57.15mm" file="US20230005188A1-20230105-M00019.TIF" alt="embedded image " img-content="table" img-format="tif"/></us-math><us-math idrefs="MATH-US-00020 MATH-US-00020-2 MATH-US-00020-3" nb-file="US20230005188A1-20230105-M00020.NB"><img id="EMI-M00020" he="97.37mm" wi="76.20mm" file="US20230005188A1-20230105-M00020.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00021 MATH-US-00021-2 MATH-US-00021-3" nb-file="US20230005188A1-20230105-M00021.NB"><img id="EMI-M00021" he="27.18mm" wi="76.20mm" file="US20230005188A1-20230105-M00021.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00022" nb-file="US20230005188A1-20230105-M00022.NB"><img id="EMI-M00022" he="6.35mm" wi="14.14mm" file="US20230005188A1-20230105-M00022.TIF" alt="embedded image " img-content="table" img-format="tif"/></us-math><us-math idrefs="MATH-US-00023" nb-file="US20230005188A1-20230105-M00023.NB"><img id="EMI-M00023" he="5.25mm" wi="20.49mm" file="US20230005188A1-20230105-M00023.TIF" alt="embedded image " img-content="table" img-format="tif"/></us-math><us-math idrefs="MATH-US-00024" nb-file="US20230005188A1-20230105-M00024.NB"><img id="EMI-M00024" he="6.01mm" wi="13.72mm" file="US20230005188A1-20230105-M00024.TIF" alt="embedded image " img-content="table" img-format="tif"/></us-math><us-math idrefs="MATH-US-00025" nb-file="US20230005188A1-20230105-M00025.NB"><img id="EMI-M00025" he="6.69mm" wi="31.75mm" file="US20230005188A1-20230105-M00025.TIF" alt="embedded image " img-content="table" img-format="tif"/></us-math><us-math idrefs="MATH-US-00026" nb-file="US20230005188A1-20230105-M00026.NB"><img id="EMI-M00026" he="6.69mm" wi="31.75mm" file="US20230005188A1-20230105-M00026.TIF" alt="embedded image " img-content="table" img-format="tif"/></us-math><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A non-transitory computer-readable medium storing program instructions that, when executed by one or more processors, cause the one or more processors to:<claim-text>generate, for a point cloud, one or more projected geometry patch images and attribute patch images;</claim-text><claim-text>pack the generated one or more projected geometry patch images and attribute patch images into one or more image frames, wherein depth values of the geometry patch images are relative to a separately signaled quantized minimum depth for each respective patch corresponding to one of the one or more projected geometry images;</claim-text><claim-text>encode the one or more image frames.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The non-transitory computer-readable medium of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the program instructions, when executed on the one or more processors, cause the one or more processors to:<claim-text>determine a minimum depth for respective ones of the geometry patch images, wherein respective points included in the respective geometry patch images each have an associated depth value, and wherein the minimum depth for a given geometry patch image is a minimum depth value of a point in the given geometry patch image that has a minimum depth as compared to depth values of other points included in the given geometry patch image.</claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The non-transitory computer-readable medium of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the program instructions, when executed on the one or more processors, cause the one or more processors to:<claim-text>quantize the determined minimum depths such that minimum depths having depth values in a value interval are assigned a common quantized minimum depth corresponding to the value interval.</claim-text></claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The non-transitory computer-readable medium of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the program instructions, cause the one or more processors to:<claim-text>signal the quantized determined minimum depths using a bitdepth that is less than a bitdepth used for signaling the depth values of the points of the geometry patch images and attribute values of the attribute patch images.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The non-transitory computer-readable medium of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the program instructions, when executed on the one or more processors, cause the one or more processors to:<claim-text>adaptively determine a bitdepth for signaling the quantized determined minimum depths; and</claim-text><claim-text>signal the determined bitdepth to be used for the quantized determined minimum depths.</claim-text></claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The non-transitory computer-readable medium of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the program instructions cause the one or more processors to:<claim-text>arithmetically encode the quantized determined minimum depths.</claim-text></claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The non-transitory computer-readable medium of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the program instructions, when executed on the one or more processors, cause the one or more processors to:<claim-text>determine for at least one of the determined quantized minimum depths, an offset to be added to, or subtracted from, the determined quantized minimum depth, wherein the offset is determined such that the value interval for the at least one quantized determined minimum depth is more closely centered on a range of depth values of points included in a given patch to which the at least one determined quantized minimum depth corresponds.</claim-text></claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The non-transitory computer readable medium of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the offset is a fixed-offset applied to the geometry patch images of the one or more image frames.</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The non-transitory computer-readable medium of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the offset is adaptively determined for respective ones of the geometry patch images and signaled in a bitstream with the encoded information.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The non-transitory computer-readable medium of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the program instructions cause the one or more processors to:<claim-text>determine a maximum depth for respective ones of the geometry patch images, wherein respective points included in the respective geometry patch images each have an associated depth value, and wherein the maximum depth for a given respective geometry patch image is a maximum depth value of a point in the given respective geometry patch image that has a maximum depth as compared to depth values of other points included in the respective given geometry patch image.</claim-text></claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The non-transitory computer-readable medium of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the program instructions cause the one or more processors to:<claim-text>signal the determined maximum depth values as delta values relative to the corresponding quantized determined minimum depth values for same patches, wherein a given delta value added to a corresponding quantized determined minimum depth value results in a corresponding quantized determined maximum depth value.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. A non-transitory computer-readable medium storing program instructions that, when executed by one or more processors, cause the one or more processors to:<claim-text>receive a bitstream comprising data for geometry images frames and attribute image frames of a point cloud, wherein the geometry image frames comprise depth information for patches of the point cloud projected onto patch planes and the attribute images frames comprise attribute information for the patches of the point cloud projected onto the patch planes, and wherein the bitstream comprises respective quantized minimum depths for the patches;</claim-text><claim-text>reconstruct geometry patches and attribute patches for the point cloud using the geometry image frames and the attribute image frames included in the bitstream, wherein reconstructing the geometry patches comprises:<claim-text>adding a respective quantized minimum depth for respective ones of a plurality of geometry patches to depth values included in the geometry image frames for the respective ones of the geometry patches; and</claim-text></claim-text><claim-text>reconstruct the point cloud using the reconstructed geometry patches and the reconstructed attribute patches.</claim-text></claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The non-transitory computer-readable medium of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the bitstream further comprises respective maximum depths for the geometry patches, and wherein the program instructions cause the one or more processors to:<claim-text>clip one or more depth values of one or more of the geometry patches exceeding a corresponding maximum depth for the one or more geometry patches.</claim-text></claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The non-transitory computer-readable medium of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the respective maximum depths are signaled as absolute values.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The non-transitory computer-readable medium of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the respective maximum depths are signaled as delta values in relation to the quantized minimum depths, wherein the program instructions cause the one or more processors to:<claim-text>add the respective delta values of the maximum depths for respective geometry patches to corresponding quantized minimum depths of the respective geometry patches to reconstruct, at a decoder, the respective maximum depths.</claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. A device, comprising:<claim-text>a memory storing program instructions; and</claim-text><claim-text>one or more processors, wherein the program instructions, when executed by the one or more processors, cause the one or more processors to:<claim-text>generate, for a point cloud, one or more projected geometry patch images and attribute patch images;</claim-text><claim-text>pack the generated one or more projected geometry patch images and attribute patch images into one or more image frames, wherein depth values of the geometry patch images are signaled relative to one or more signaled quantized minimum depths; and</claim-text><claim-text>encode the one or more image frames.</claim-text></claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The device of <claim-ref idref="CLM-00016">claim 16</claim-ref>, further comprising:<claim-text>one or more sensors configured to capture a plurality of points that make up the point cloud, wherein respective ones of the points comprise spatial information for the point and attribute information for the point.</claim-text></claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The device of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the program instructions, when executed on the one or more processors, cause the one or more processors to:<claim-text>determine a minimum depth for respective ones of the geometry patch images, wherein respective points included in the respective geometry patch images each have an associated depth value, and wherein the minimum depth for a given geometry patch image is a minimum depth value of a point in the given geometry patch image that has a minimum depth as compared to depth values of other points included in the given geometry patch image.</claim-text></claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The device of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein the program instructions, when executed on the one or more processors, cause the one or more processors to:<claim-text>quantize the determined minimum depths such that minimum depths having depth values in a value interval are assigned a common quantized minimum depth corresponding to the value interval.</claim-text></claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The device of <claim-ref idref="CLM-00019">claim 19</claim-ref>, wherein the program instructions cause the one or more processors to:<claim-text>determine a maximum depth for respective ones of the geometry patch images, wherein respective points included in the respective geometry patch images each have an associated depth value, and wherein the maximum depth for a given respective geometry patch image is a maximum depth value of a point in the given respective geometry patch image that has a maximum depth as compared to depth values of other points included in the respective given geometry patch image; and</claim-text><claim-text>signal the determined maximum depths for the respective ones of the geometry patch images.</claim-text></claim-text></claim></claims></us-patent-application>