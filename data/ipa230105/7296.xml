<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230007297A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230007297</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17900142</doc-number><date>20220831</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>577</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>105</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>172</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>176</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>187</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>52</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>577</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>105</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>172</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>176</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>187</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>52</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>70</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">SYSTEMS AND METHODS FOR PERFORMING MOTION VECTOR PREDICTION USING A DERIVED SET OF MOTION VECTORS</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>17052497</doc-number><date>20201102</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11470346</doc-number></document-id></parent-grant-document><parent-pct-document><document-id><country>WO</country><doc-number>PCT/JP2019/018294</doc-number><date>20190507</date></document-id></parent-pct-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17900142</doc-number></document-id></child-doc></relation></continuation><us-provisional-application><document-id><country>US</country><doc-number>62738888</doc-number><date>20180928</date></document-id></us-provisional-application><us-provisional-application><document-id><country>US</country><doc-number>62693406</doc-number><date>20180702</date></document-id></us-provisional-application><us-provisional-application><document-id><country>US</country><doc-number>62685207</doc-number><date>20180614</date></document-id></us-provisional-application><us-provisional-application><document-id><country>US</country><doc-number>62669332</doc-number><date>20180509</date></document-id></us-provisional-application></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>SHARP KABUSHIKI KAISHA</orgname><address><city>Sakai City</city><country>JP</country></address></addressbook><residence><country>JP</country></residence></us-applicant><us-applicant sequence="01" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>FG Innovation Company Limited</orgname><address><city>Tuen Mun</city><country>HK</country></address></addressbook><residence><country>HK</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>CHOI</last-name><first-name>BYEONGDOO</first-name><address><city>Vancouver</city><state>WA</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>BOSSEN</last-name><first-name>FRANK</first-name><address><city>Vancouver</city><state>WA</state><country>US</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>SEGALL</last-name><first-name>CHRISTOPHER ANDREW</first-name><address><city>Vancouver</city><state>WA</state><country>US</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">This disclosure relates to video coding and more particularly to techniques for performing motion vector prediction. According to an aspect of an invention, a motion vector and a corresponding reference picture identifier for the motion vector are received; a reference picture corresponding to a second motion vector is determined based on the reference picture corresponding to the received motion vector and a current picture; a scaling value is determined based on the determined reference picture, the reference picture corresponding to the received motion vector, and the current picture; and the second motion vector is generated from the received motion vector by scaling with the scaling value.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="83.74mm" wi="158.75mm" file="US20230007297A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="240.37mm" wi="154.43mm" orientation="landscape" file="US20230007297A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="191.52mm" wi="151.89mm" orientation="landscape" file="US20230007297A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="234.53mm" wi="131.57mm" file="US20230007297A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="242.15mm" wi="147.40mm" file="US20230007297A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="215.98mm" wi="98.13mm" file="US20230007297A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="230.21mm" wi="142.49mm" orientation="landscape" file="US20230007297A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="245.45mm" wi="152.48mm" orientation="landscape" file="US20230007297A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="207.86mm" wi="158.07mm" orientation="landscape" file="US20230007297A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="241.38mm" wi="163.58mm" file="US20230007297A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="119.63mm" wi="154.69mm" orientation="landscape" file="US20230007297A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="229.19mm" wi="160.10mm" file="US20230007297A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="243.33mm" wi="160.02mm" file="US20230007297A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="229.02mm" wi="160.10mm" file="US20230007297A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00014" num="00014"><img id="EMI-D00014" he="237.83mm" wi="158.07mm" orientation="landscape" file="US20230007297A1-20230105-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00015" num="00015"><img id="EMI-D00015" he="222.17mm" wi="162.14mm" orientation="landscape" file="US20230007297A1-20230105-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00016" num="00016"><img id="EMI-D00016" he="248.50mm" wi="153.16mm" orientation="landscape" file="US20230007297A1-20230105-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00017" num="00017"><img id="EMI-D00017" he="245.03mm" wi="156.21mm" orientation="landscape" file="US20230007297A1-20230105-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">CROSS REFERENCE</heading><p id="p-0002" num="0001">This application is a continuation of U.S. patent application Ser. No. 17/052,497, filed Nov. 2, 2020, which claims priority under 35 U.S.C. &#xa7; 119 on provisional Application No. 62/669,332 on May 9, 2018, No. 62/685,207 on Jun. 14. 2018 No. 62/693,406 on Jul. 2, 2018, No. 62/738,888 on Sep. 28, 2018, the entire contents of which are hereby incorporated by reference.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">TECHNICAL FIELD</heading><p id="p-0003" num="0002">This disclosure relates to video coding and more particularly to techniques for performing motion vector prediction.</p><heading id="h-0003" level="1">BACKGROUND ART</heading><p id="p-0004" num="0003">Digital video capabilities can be incorporated into a wide range of devices, including digital televisions, laptop or desktop computers, tablet computers, digital recording devices, digital media players, video gaming devices, cellular telephones, including so-called smartphones, medical imaging devices, and the like. Digital video may be coded according to a video coding standard. Video coding standards may incorporate video compression techniques. Examples of video coding standards include ISO/IEC MPEG-4 Visual and ITU-T H.264 (also known as ISO/IEC MPEG-4 AVC) and High-Efficiency Video Coding (HEVC). HEVC is described in High Efficiency Video Coding (HEVC), Rec. ITU-T H.265, December 2016, which is incorporated by reference, and referred to herein as ITU-T H.2.65. Extensions and improvements for ITU-T H.265 are currently being considered for the development of next generation video coding standards. For example, the ITU-T Video Coding Experts Group (VCEG) and ISO/IEC (Moving Picture Experts Group (MPEG) (collectively referred to as the Joint Video Exploration Team (JVET)) have commenced standardization of video coding technology with a compression capability that significantly exceeds that of the current HEVC standard. The Joint Exploration Model 7 (JEM 7), Algorithm Description of Joint Exploration Test Model 7 (JEM 7), ISO/IEC JTC1/SC29/WG11 Document: JVET-G1001, July 2017, Torino, IT, which is incorporated by reference herein, describes coding features under coordinated test model study by the JVET as potentially enhancing video coding technology beyond the capabilities of ITU-T H.265. It should be noted that the coding features of JEM 7 are implemented in JEM reference software. As used herein, the term JEM may collectively refer to algorithms included in JEM 7 and implementations of JEM reference software. Further, in response to a &#x201c;Joint Call for Proposals on Video Compression with Capabilities beyond HEVC,&#x201d; jointly issued by VCEG and MPEG, multiple descriptions of video coding were proposed by various groups at the 10<sup>th </sup>Meeting of ISO/IEC JTC1/SC29/WG11 16-20 April 2018, San Diego, Calif.</p><p id="p-0005" num="0004">Video compression techniques enable data requirements for storing and transmitting video data to be reduced. Video compression techniques may reduce data requirements by exploiting the inherent redundancies in a video sequence. Video compression techniques may sub-divide a video sequence into successively smaller portions (i.e., groups of frames within a video sequence, a frame within a group of frames, slices within a frame, coding tree units (e.g., macroblocks) within a slice, coding blocks within a coding tree unit, etc.). Intra prediction coding techniques (e.g., intra-picture (spatial)) and inter prediction techniques (i.e., inter-picture (temporal)) may be used to generate difference values between a unit of video data to be coded and a reference unit of video data. The difference values may be referred to as residual data. Residual data may be coded as quantized transform coefficients. Syntax elements may relate residual data and a reference coding unit (e.g., intra-prediction mode indices, motion vectors, and block vectors). Residual data and syntax elements may be entropy coded. Entropy encoded residual data and syntax elements may be included in a compliant bitstream.</p><heading id="h-0004" level="1">SUMMARY OF INVENTION</heading><p id="p-0006" num="0005">In one example, a method of performing motion vector prediction for coding video data, the method comprises receiving a motion vector and a corresponding reference picture identifier for the motion vector, determining a reference picture corresponding to a second motion vector based on the reference picture corresponding to the received motion vector and a current picture, determining a scaling value based on the determined reference picture, the reference picture corresponding to the received motion vector, and the current picture, and generating the second motion vector by scaling the received motion vector according to the determined scaling value.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0005" level="1">BRIEF DESCRIPTION OF DRAWINGS</heading><p id="p-0007" num="0006"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a conceptual diagram illustrating an example of a group of pictures coded according to a quad tree binary tree partitioning in accordance with one or more techniques of this disclosure.</p><p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a conceptual diagram illustrating possible coding structures for a block of video data in accordance with one or more techniques of this disclosure.</p><p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. <b>3</b>A</figref> is a conceptual diagram illustrating examples of coding a block of video data in accordance with one or more techniques of this disclosure.</p><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. <b>3</b>B</figref> is a conceptual diagram illustrating examples of coding a block of video data in accordance with one or more techniques of this disclosure.</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a conceptual diagram illustrating the position of neighboring video blocks for inclusion in a set of candidate for motion vector predictors in accordance with one or more techniques of this disclosure.</p><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a conceptual diagram illustrating the position neighboring video blocks for inclusion in a set of candidate motion vector predictors in accordance with one or more techniques of this disclosure.</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a conceptual diagram illustrating the use of template matching for deriving motion information for a current video block in accordance with one or more techniques of this disclosure.</p><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a conceptual diagram illustrating the use of bilateral matching for deriving motion information for a current video block in accordance with one or more techniques of this disclosure.</p><p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a block diagram illustrating an example of a system that may be configured to encode and decode video data according to one or more techniques of this disclosure.</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a block diagram illustrating an example of a video encoder that may be configured to encode video data according to one or more techniques of this disclosure.</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a conceptual diagram illustrating the position neighboring video blocks for inclusion in a set of candidate motion vector predictors in accordance with one or more techniques of this disclosure.</p><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>11</b>A</figref> is a block diagram illustrating an example of a coding structure that may be used to indicate a coding mode for a video block according to one or more techniques of this disclosure.</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>11</b>B</figref> is a block diagram illustrating an example of a coding structure that may be used to indicate a coding mode for a video block according to one or more techniques of this disclosure.</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>12</b></figref> is a block diagram illustrating an example of a coding structure that may be used to indicate a coding mode for a video block according to one or more techniques of this disclosure.</p><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. <b>13</b></figref> is a block diagram illustrating an example of a video decoder that may be configured to decode video data according to one or more techniques of this disclosure.</p><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. <b>14</b></figref> is a conceptual diagram illustrating the position neighboring video blocks for inclusion in a set of candidate motion vector predictors in accordance with one or more techniques of this disclosure.</p><p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. <b>15</b>A</figref> is a conceptual diagram illustrating a search range according to one or more techniques of this disclosure.</p><p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. <b>15</b>B</figref> is a conceptual diagram illustrating a search range according to one or more techniques of this disclosure.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0006" level="1">DESCRIPTION OF EMBODIMENTS</heading><p id="p-0025" num="0024">In general, this disclosure describes various techniques for coding video data. In particular, this disclosure describes techniques for motion vector prediction. It should be noted that although techniques of this disclosure are described with respect to, e.g., ITU-T H.264, ITU-T H.265, and JEM, the techniques of this disclosure are generally applicable to video coding. For example, the coding techniques described herein may be incorporated into video coding systems, (including video coding systems based on future video coding standards) including block structures, intra prediction techniques, inter prediction techniques, transform techniques, filtering techniques, and/or entropy coding techniques other than those included in ITU-T H.265 and JEM. Thus, reference to ITU-T H.264, ITU-T H.265, and/or JEM is for descriptive purposes and should not be construed to limit the scope of the techniques described herein. Further, it should be noted that incorporation by reference of documents herein is for descriptive purposes and should not be construed to limit or create ambiguity with respect to terms used herein. For example, in the case where an incorporated reference provides a different definition of a term than another incorporated reference and/or as the term is used herein, the term should be interpreted in a manner that broadly includes each respective definition and/or in a manner that includes each of the particular definitions in the alternative.</p><p id="p-0026" num="0025">In one example, a device for reconstructing video data comprises one or more processors configured to receive a motion vector and a corresponding reference picture identifier for the motion vector, determine a reference picture corresponding to a second motion vector based on the reference picture corresponding to the received motion vector and a current picture, determine a scaling value based on the determined reference picture, the reference picture corresponding to the received motion vector, and the current picture, and generate the second motion vector by scaling the received motion vector according to the determined scaling value.</p><p id="p-0027" num="0026">In one example, a non-transitory computer-readable storage medium comprises instructions stored thereon that, when executed, cause one or more processors of a device to receive a motion vector and a corresponding reference picture identifier for the motion vector, determine a reference picture corresponding to a second motion vector based on the reference picture corresponding to the received motion vector and a current picture, determine a scaling value based on the determined reference picture, the reference picture corresponding to the received motion vector, and the current picture, and generate the second motion vector by scaling the received motion vector according to the determined scaling value.</p><p id="p-0028" num="0027">In one example, an apparatus comprises means for receiving a motion vector and a corresponding reference picture identifier for the motion vector, means for determining a reference picture corresponding to a second motion vector based on the reference picture corresponding to the received motion vector and a current picture, means for determining a scaling value based on the determined reference picture, the reference picture corresponding to the received motion vector, and the current picture, and means for generating the second motion vector by scaling the received motion vector according to the determined scaling value.</p><p id="p-0029" num="0028">The details of one or more examples are set forth in the accompanying drawings and the description below. Other features, objects, and advantages will be apparent from the description and drawings, and from the claims.</p><p id="p-0030" num="0029">Video content typically includes video sequences comprised of a series of frames (or pictures). A series of frames may also be referred to as a group of pictures (GOP). Each video frame or picture may include a plurality of slices or tiles, where a slice or tile includes a plurality of video blocks. As used herein, the term video block may generally refer to an area of a picture or may more specifically refer to the largest array of sample values that may be predictively coded, sub-divisions thereof, and/or corresponding structures. Further, the term current video block may refer to an area of a picture being encoded or decoded. A video block may be defined as an array of sample values that may be predictively coded. It should be noted that in some cases pixels values may be described as including sample values for respective components of video data, which may also be referred to as color components, (e.g., luma (Y) and chroma (Cb and Cr) components or red, green, and blue components). It should be noted that in some cases, the terms pixel value and sample value are used interchangeably. Further, in some cases a pixel or sample may be referred to as a pel. A video sampling format, which may also be referred to as a chroma format, may define the number of chroma samples included in a video block with respect to the number of luma samples included in a video block. For example, for the 4:2:0 sampling format, the sampling rate for the luma component is twice that of the chroma components for both the horizontal and vertical directions. As a result, for a video block formatted according to the 4:2:0 format, the width and height of an array of samples for the luma component are twice that of each array of samples for the chroma components. For a video block formatted according to the 4:2:2 format, the width of an array of samples for the luma component is twice that of the width of an array of samples for each chroma component, but the height of the array of samples for the luma component is equal to the height of an array of samples for each chroma component. Further, for a video block formatted according to the 4:4:4 format, an array of samples for the luma component has the same width and height as an array of samples for each chroma component.</p><p id="p-0031" num="0030">Video blocks may be ordered within a picture according to a scan pattern (e.g., a raster scan). A video encoder may perform predictive encoding on video blocks and sub-divisions thereof. Video blocks and sub-divisions thereof may be referred to as nodes. ITU-T H.264 specifies a macroblock including 16&#xd7;16 luma samples. That is, in ITU-T H.264, a picture is segmented into macroblocks. ITU-T H.265 specifies an analogous Coding Tree Unit (CTU) structure (also referred to as an largest coding unit (LCU)). In ITU-T H265, pictures are segmented into CTUs. In ITU-T H.265, for a picture, a CTU size may be set as including 16&#xd7;16, 32&#xd7;32, or 64&#xd7;64 luma samples. In ITU-T H.265, a CTU is composed of respective Coding Tree Blocks (CTB) for each component of video data (e.g., luma (Y) and chroma (Cb and Cr). Further, in ITU-T H.265, a CTU may be partitioned according to a quadtree (QT) partitioning structure, which results in the CTBs of the CTU being partitioned into Coding Blocks (CB). That is, in ITU-T H.265, a CTU may be partitioned into quadtree leaf nodes. According to ITU-T H.265, one luma CB together with two corresponding chroma CBs and associated syntax elements are referred to as a coding unit (CU). In ITU-T H.265, a minimum allowed size of a CB may be signaled. In ITU-T H.265, the smallest minimum allowed size of a luma CB is 8&#xd7;8 luma samples. In ITU-T H.265, the decision to code a picture area using intra prediction or inter prediction is made at the CU level.</p><p id="p-0032" num="0031">In ITU-T H.265, a CU is associated with a prediction unit (PU) structure having its root at the CU. In ITU-T H.265, PU structures allow luma and chroma CBs to be split for purposes of generating corresponding reference samples. That is, in ITU-T H.265, luma and chroma CBs may be split into respect luma and chroma prediction blocks (PBs), where a PB includes a block of sample values for which the same prediction is applied. In ITU-T H.265, a CB may be partitioned into 1, 2, or 4 PBs. ITU-T H.265 supports PB sizes from 64&#xd7;64 samples down to 4&#xd7;4 samples. In ITU-T H.265, square PBs are supported for intra prediction, where a CB may form the PB or the CB may be split into four square PBs (i.e., intra prediction PB types include M&#xd7;M or M/2&#xd7;M/2, where M is the height and width of the square CB). In ITU-T H.265, in addition to the square PBs, rectangular PBs are supported for inter prediction, where a CB may by halved vertically or horizontally to form PBs (i.e., inter prediction PB types include M&#xd7;M, M/2&#xd7;M/2, M/2&#xd7;M, or M&#xd7;M/2). Further, it should be noted that in ITU-T H.265, for inter prediction, four asymmetric PB partitions are supported, where the CB is partitioned into two PBs at one quarter of the height (at the top or the bottom) or width (at the left or the right) of the CB (i.e., asymmetric partitions include M/4&#xd7;M left, M/4&#xd7;M right, M&#xd7;M/4 top, and M&#xd7;M/4 bottom). Intra prediction data (e.g., intra prediction mode syntax elements) or inter prediction data (e.g., motion data syntax elements) corresponding to a PB is used to produce reference and/or predicted sample values for the PB.</p><p id="p-0033" num="0032">JEM specifies a CTU having a maximum size of 256&#xd7;256 luma samples. JEM specifies a quadtree plus binary tree (QTBT) block structure. In JEM, the QTBT structure enables quadtree leaf nodes to be further partitioned by a binary tree (BT) structure. That is, in JEM, the binary tree structure enables quadtree leaf nodes to be recursively divided vertically or horizontally. <figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates an example of a CTU (e.g., a CTU having a size of 256&#xd7;256 luma samples) being partitioned into quadtree leaf nodes and quadtree leaf nodes being further partitioned according to a binary tree. That is, in <figref idref="DRAWINGS">FIG. <b>1</b></figref> dashed lines indicate additional binary tree partitions in a quadtree. Thus, the binary tree structure in JEM enables square and rectangular leaf nodes, where each leaf node includes a CB. As illustrated in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, a picture included in a GOP may include slices, where each slice includes a sequence of CTUs and each CTU may be partitioned according to a QTBT structure. <figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates an example of QTBT partitioning for one CTU included in a slice.</p><p id="p-0034" num="0033">In JEM, a QTBT is signaled by signaling QT split flag and ST split mode syntax elements. Further, in JEM, luma and chroma components may have separate QTBT partitions. That is, in JEM luma and chroma components may be partitioned independently by signaling respective QTBTs. Currently, in JEM independent QTBT structures are enabled for slices using intra prediction techniques. In JEM, CBs are used for prediction without any further partitioning. That is, in JEM, a CB may be a block of sample values on which the same prediction is applied. Thus, a JEM QTBT leaf node may be analogous a PB in ITU-T H.265.</p><p id="p-0035" num="0034">As described above, intra prediction data or inter prediction data is used to produce reference sample values for a block of sample values. The difference between sample values included in a current PB, or another type of picture area structure, and associated reference samples (e.g., those generated using a prediction) may be referred to as residual data. Residual data may include respective arrays of difference values corresponding to each component of video data. Residual data may be in the pixel domain. A transform, such as, a discrete cosine transform (DCT), a discrete sine transform (DST), an integer transform, a wavelet transform, or a conceptually similar transform, may be applied to an array of difference values to generate transform coefficients, It should be noted that in ITU-T H.265, a CU is associated with a transform unit (TU) structure having its root at the CU level. That is, in ITU-T H.265, an array of difference values may be sub-divided for purposes of generating transform coefficients (e.g., four 8&#xd7;8 transforms may be applied to a, 16&#xd7;16 array of residual values). For each component of video data, such sub-divisions of difference values may be referred to as Transform Blocks (TBs). It should be noted that in ITU-T H.265, TBs are not necessarily aligned with PBs. <figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates examples of alternative PB and TB combinations that may be used for coding a particular CB. Further, it should be noted that in ITU-T H.265, TBs may have the following sizes 4&#xd7;4, 8&#xd7;8, 16&#xd7;16, and 32&#xd7;32. In JEM, residual values corresponding to a CB are used to generate transform coefficients without further partitioning. That is, in JEM a QTBT leaf node may be analogous to both a PB and a TB in ITU-T H.265. It should be noted that in JEM, a core transform and a subsequent secondary transforms may be applied (in the video encoder) to generate transform coefficients. For a video decoder, the order of transforms is reversed. Further, in JEM, whether a secondary transform is applied to generate transform coefficients may be dependent on a prediction mode.</p><p id="p-0036" num="0035">A quantization process may be performed on transform coefficients. Quantization essentially scales transform coefficients in order to vary the amount of data required to represent a group of transform coefficients. Quantization may include division of transform coefficients by a quantization scaling factor and any associated rounding functions (e.g., rounding to the nearest integer). Quantized transform coefficients may be referred to as coefficient level values. Inverse quantization (or &#x201c;dequantization&#x201d;) may include multiplication of coefficient level values by the quantization scaling factor. It should be noted that as used herein the term quantization process in some instances may refer to division by a scaling factor to generate level values and multiplication by a scaling factor to recover transform coefficients in some instances. That is, a quantization process may refer to quantization in some cases and inverse quantization in some cases.</p><p id="p-0037" num="0036"><figref idref="DRAWINGS">FIGS. <b>3</b>A-<b>3</b>B</figref> are conceptual diagrams illustrating examples of coding a block of video data. As illustrated in <figref idref="DRAWINGS">FIG. <b>3</b>A</figref>, a current block of video data (e.g., a CB corresponding to a video component) is encoded by generating a residual by subtracting a set of prediction values from the current block of video data, performing a transformation on the residual, and quantizing the transform coefficients to generate level values. As illustrated in <figref idref="DRAWINGS">FIG. <b>3</b>B</figref>, the current block of video data is decoded by performing inverse quantization on level values, performing an inverse transform, and adding a set of prediction values to the resulting residual. It should be noted that in the examples in <figref idref="DRAWINGS">FIGS. <b>3</b>A-<b>3</b>B</figref>, the sample values of the reconstructed block differs from the sample values of the current video block that is encoded. In this manner, coding may said to be lossy. However, the difference in sample values may be considered acceptable or imperceptible to a viewer of the reconstructed video. Further, as illustrated in <figref idref="DRAWINGS">FIGS. <b>3</b>A-<b>3</b>B</figref>, scaling is performed using an array of scaling factors.</p><p id="p-0038" num="0037">As illustrated in <figref idref="DRAWINGS">FIG. <b>3</b>A</figref>, quantized transform coefficients are coded into a bitstream. Quantized transform coefficients and syntax elements (e.g., syntax elements indicating a coding structure for a video block) may be entropy coded according to an entropy coding technique. Examples of entropy coding techniques include content adaptive variable length coding (CAVLC), context adaptive binary arithmetic coding (CABAC), probability interval partitioning entropy coding (PIPE), and the like. Entropy encoded quantized transform coefficients and corresponding entropy encoded syntax elements may form a compliant bitstream that can be used to reproduce video data at a video decoder. An entropy coding process may include performing a binarization on syntax elements. Binarization refers to the process of converting a value of a syntax value into a series of one or more bits. These bits may be referred to as &#x201c;bins.&#x201d; Binarization is a lossless process and may include one or a combination of the following coding techniques: fixed length coding, unary coding, truncated unary coding, truncated Rice coding, Golomb coding, k-th order exponential Golomb coding, and Golomb-Rice coding. For example, binarization may include representing the integer value of 5 for a syntax element as 00000101 using an 8-bit fixed length binarization technique or representing the integer value of 5 as 11110 using a unary coding binarization technique. As used herein each of the terms fixed length coding, unary coding, truncated unary coding, truncated Rice coding, Golomb coding, k-th order exponential Golomb coding, and Golomb-Rice coding may refer to general implementations of these techniques and/or more specific implementations of these coding techniques. For example, a Golomb-Rice coding implementation may be specifically defined according to a video coding standard, for example, ITU-T H.265. An entropy coding process further includes coding bin values using lossless data compression algorithms. In the example of a CABAC, for a particular bin, a context model may be selected from a set of available context models associated with the bin. In some examples, a context model may be selected based on a previous bin and/or values of previous syntax elements. A context model may identify the probability of a bin having a particular value. For instance, a context model may indicate a 0.7 probability of coding a 0-valued bin. After selecting an available context model, a CABAC entropy encoder may arithmetically code a bin based on the identified context model. The context model may be updated based on the value of a coded bin. The context model may be updated based on an associated variable stored with the context, e.g., adaptation window size, number of bins coded using the context. It should be noted, that according to ITU-T H.265, a CABAC entropy encoder may be implemented, such that some syntax elements may be entropy encoded using arithmetic encoding without the usage of an explicitly assigned context model, such coding may be referred to as bypass coding.</p><p id="p-0039" num="0038">As described above, infra prediction data or inter prediction data may associate an area of a picture (e.g., a PB or a CB) with corresponding reference samples. For intra prediction coding, an intra prediction mode may specify the location of reference samples within a picture. In ITU-T H.265, defined possible intra prediction modes include a planar (i.e., surface fitting) prediction mode (predMode: 0), a DC (i.e., flat overall averaging) prediction mode (predMode: 1), and 33 angular prediction modes (predMode: 2-34). In JEM, defined possible intra-prediction modes include a planar prediction mode (predMode: 0), a DC prediction mode (predMode: 1), and 65 angular prediction modes (predMode: 2-66). It should be noted that planar and DC prediction modes may be referred to as non-directional prediction modes and that angular prediction modes may be referred to as directional prediction modes. It should be noted that the techniques described herein may be generally applicable regardless of the number of defined possible prediction modes.</p><p id="p-0040" num="0039">For inter prediction coding, a previously decoded picture, i.e., a reference picture is determined and a motion vector (MV) identifies samples in the reference picture. For example, a current video block may be predicted using reference sample values located in one or more previously coded picture(s) and a motion vector is used to indicate the location of the reference block relative to the current video block. A motion vector may describe, for example, a horizontal displacement component of the motion vector (i.e., MVx), a vertical displacement component of the motion vector (i.e., MVy), and a resolution for the motion vector (e.g., one-quarter pixel precision, one-half pixel precision, one-pixel precision, two-pixel precision, four-pixel precision). In ITU-T H.265, a motion vector is represented at &#xbc;-pixel precision. Previously decoded pictures, which may include pictures output before or after a current picture, may be organized into one or more to reference pictures lists and identified using a reference picture index value. Further, in inter prediction coding, uni-prediction refers to generating a prediction using sample values from a single reference picture and bi-prediction refers to generating a prediction using respective sample values from two reference pictures. That is, in uni-prediction, a single reference picture and corresponding motion vector are used to generate a prediction for a current video block and in bi-prediction, a first reference picture and corresponding first motion vector and a second reference picture and corresponding second motion vector are used to generate a prediction for a current video block. In bi-prediction, respective sample values are combined (e.g., added, rounded, and clipped, or averaged according to weights) to generate a prediction. In ITU-T H.265, pictures and slices are classified based on which types of prediction modes may be utilized for encoding video blocks thereof. That is, for slices having a B type (i.e., a B slice), bi-prediction, uni-prediction, and infra prediction modes may be utilized, for slices having a P type (i.e., a P slice), uni-prediction, and intra prediction modes may be utilized, and for slices having an I type (i.e., an I slice), only intra prediction modes may be utilized. As described above, reference pictures are identified through reference indices. In ITU-T H.265, for a P slice, there is a single reference picture list, RefPicList0 and for a B slice, there is a second independent reference picture list, RefPicList1, in addition to RefPicList0. It should be noted that for uni-prediction in a B slice, one of RefPicList0 or RefPicList1 may be used to generate a prediction. Further, it should be noted that in ITU-T H.265, during the decoding process, at the onset of decoding a picture, reference picture list(s) are generated from previously decoded picture stored in a decoded picture buffer (DPB).</p><p id="p-0041" num="0040">Further, a coding standard, such as, for example ITU-T H.265, may support motion vector prediction. Motion vector prediction enables the value of a motion vector to be derived based on another motion vector. Examples of motion vector prediction include advanced motion vector prediction (AMVP), temporal motion vector prediction (TMVP), so-called &#x201c;merge&#x201d; mode, and &#x201c;skip&#x201d; and &#x201c;direct&#x201d; motion inference. Further, JEM supports advanced temporal motion vector prediction (ATMVP) and Spatial-temporal motion vector prediction (STMVP). ITU-T H.265 supports two modes for motion vector prediction: a merge mode and so-called Advanced Motion Vector Prediction (AMVP). In ITU-T H.265, for both the merge mode and the AMVP for a current PB, a set of candidate blocks is derived. Both a video encoder and video decoder perform the same process to derive a set of candidates. Thus, for a current video block, the same set of candidates is generated during encoding and decoding. A candidate block includes a video block having associated motion information from which motion information used to generate a prediction for a current video block can be derived. For the merge mode in ITU-T H.265, all motion information (i.e., motion vector displacement values, reference picture indices, and reference picture lists) associated with a selected candidate is inherited as the motion information for the current PB. That is, at a video encoder, a candidate block is selected from the derived set of candidates and an index value included in the bitstream indicates the selected candidate and thus, indicates the motion information for the current PB. For AMVP in ITU-T H.265, the motion vector information for the selected candidate is used as a motion vector predictor (MVP) for the motion vector of the current PB. That is, at a video encoder, a candidate block is selected from the derived set of candidates and an index value indicating the selected candidate and a delta value (i.e., a motion vector delta (MVD)) indicating the difference between the motion vector predictor and the motion vector for the current PB are included in the bitstream. Further, for AMVP in ITU-T H.265, syntax elements identifying a reference picture are included in the bitstream.</p><p id="p-0042" num="0041">In ITU-T H.265, a set of candidate blocks may be derived from spatial neighboring blocks, and temporal blocks. Further, generated (or default) motion information may be used for motion vector prediction. In ITU-T H.265, whether motion information used for motion vector prediction of a current PB includes motion information associated with spatial neighboring blocks, motion information associated with temporal blocks, or generated motion information is dependent on the number of candidates to be included in a set, whether temporal motion vector prediction is enabled, the availability of blocks, and/or whether motion information associated with blocks is redundant.</p><p id="p-0043" num="0042">For the merge mode in ITU-T H.265, a maximum number of candidates that may be included in a set of candidate blocks may be set and signaled by a video encoder and may be up to five. Further, a video encoder may disable the use of temporal motion vector candidates (e.g., in order to reduce the amount memory resources needed to store motion information at a video decoder) and signal whether the use of temporal motion vector candidates is enabled or disabled for a picture. <figref idref="DRAWINGS">FIG. <b>4</b></figref> illustrates the position of spatial neighboring blocks and the temporal block that may be included in a set of candidate blocks for the merge mode in ITU-T H.265. The derivation of the set of candidates for merge mode in ITU-T H.265 includes determining the availability of A<b>1</b>, B<b>1</b>, B<b>0</b>, A<b>0</b>, and B<b>2</b>. It should be noted that a block is considered unavailable, if it is intra-predicted (i.e., does not have corresponding motion information) or is not included in the current slice (or tile). After determining the availability of A<b>1</b>, B<b>1</b>, B<b>0</b>, A<b>0</b>, and B<b>2</b>, a set of comparisons (illustrated as dashed arrows in <figref idref="DRAWINGS">FIG. <b>4</b></figref>) is performed to remove redundant entries from the set of candidates. For example, B<b>2</b> is compared to B<b>1</b> and if B<b>1</b> has associated motion information that is equal to that of B<b>2</b>, it is removed from the set of candidates. The removal of entries from a set of candidates may be referred to as a pruning process. It should be noted that in <figref idref="DRAWINGS">FIG. <b>4</b></figref>, in order to reduce complexity, a complete comparison of candidates is not performed (e.g., A<b>0</b> is not compared to B<b>0</b>) and as such, it is possible that redundant entries are included in the set of candidates.</p><p id="p-0044" num="0043">Referring again to <figref idref="DRAWINGS">FIG. <b>4</b></figref>, the dashed block labeled Temp refers to the temporal candidate that may be included in the set of candidates. In ITU-T H.265 for merge mode, for the temporal candidate, a spatially collocated PU included in a reference picture is defined and the temporal candidate includes a block having a position just outside to the bottom right of the collocated PU, if available, or the block at the center position of the collocated PU. As described above, a maximum number of candidates that may be included in a set of candidate blocks is set. If the maximum number of candidates is set to N, N-1 spatial candidates and the temporal candidate are included in the set, in cases where the number of available spatial candidates (after pruning) and temporal candidate is greater than or equal to N. In cases where the number of available spatial candidates (after pruning) and temporal candidate is less than N, generated motion information is included in the set in order to fill the set.</p><p id="p-0045" num="0044">For AMVP in ITU-T H.265, referring to <figref idref="DRAWINGS">FIG. <b>5</b></figref>, the derivation of the set of candidates includes adding one of A<b>0</b> or A<b>1</b> a left candidate) and one of B<b>0</b>, B<b>1</b> or B<b>2</b> (an above candidate) to the set based on their availability. That is, the first available left candidate and the first available above candidate are added to the set. When the left candidate and the above candidate have redundant motion vector components, one redundant candidate is removed from the set. If the number of candidates included in the set is less than two, and temporal motion vector prediction is enabled, the temporal candidate (Temp) is included in the set. In cases where the number of available spatial candidates (after pruning) and temporal candidate included in the set is less than two, a zero value motion vector is included in the set in order to fill the set.</p><p id="p-0046" num="0045">JEM describes a special merge mode, a so-called pattern matched motion vector derivation (PMMVD) mode, based on Frame-Rate Up Conversion (FRUC) techniques. In the PMMVD mode, both a video encoder and video decoder perform the same process to derive motion information of a video block. In some cases, in JEM a QTBT leaf node may be referred to as a CU. In JEM, a CU-level merge flag indicates whether motion vector information for the CU is derived using a merge mode. Further, in order to indicate that the PMMVD mode is to be used to derive motion information, when the merge flag is TRUE for a CU, a so-called FRUC flag is additionally signaled for the CU. When the FRUC flag is FALSE, a merge index is signaled and the regular merge mode is used to indicate motion information for the CU. When the FRUC flag is TRUE, a FRUC mode flag is additionally signaled to indicate whether one of a defined template matching technique or a defined bilateral (or bi-lateral) matching technique is to be used to derive motion information for sub-blocks within the CU. In JEM, each of the defined template matching technique and the defined bilateral matching technique derive an initial CU-level motion vector. After the initial CU-level motion vector is determined, the current CU is divided into sub-blocks and a motion vector is derived for each sub-block using the initial CU-level motion vector.</p><p id="p-0047" num="0046"><figref idref="DRAWINGS">FIG. <b>6</b></figref> illustrates the use of template matching for deriving a CU-level motion vector. In template matching, a template is defined, where a template indicates the positions of samples to be included in a set of samples. For a current video block, according to the template, a set of sample values in the current picture corresponding to the current video block are determined. For example, for an N&#xd7;M current video block, a template may specify that for each of the N columns, the X samples neighboring the top row of the current video block and for each of the M rows, the Y samples neighboring the left column of the current video block are to be included in the set of samples. That is, for example, referring to <figref idref="DRAWINGS">FIG. <b>6</b></figref>, for the current CU, a template may be an inverse L-shape including neighboring above and left samples.</p><p id="p-0048" num="0047">Template matching is used to derive motion information for a current video block by determining the best match between the sample values in the current picture corresponding to the template and the current video block and a set of sample values positioned within a reference picture corresponding to the template. In JEM, for template matching the absolute sum difference (SAD) of corresponding samples is used to determine the degree to which two sets match, where lower values of the SAD indicate a better match. To search for sets of sample values positioned within a reference picture that may provide a good match, origin points and search patterns are used. Template matching techniques may use one or more sets of motion vector candidates to determine origin points. For example, the each of the motion vectors in the set of motion vector candidates {A<b>1</b>, B<b>1</b>, B<b>0</b>, A<b>0</b>, and B<b>2</b>} described above with respect to merge mode in ITU-T H.265 may be used as an origin point in a reference picture. For example, referring to <figref idref="DRAWINGS">FIG. <b>6</b></figref>, for the current CU, the candidate motion vector B<b>2</b> (illustrated as MV<sub>B2</sub>) is used as an origin point in reference picture. A region corresponding to an origin point is searched for the set of samples that provides the best match. That is, a search may be performed according to a search pattern initiated with respect to an origin point. For example, if an origin point is (x<sub>0</sub>, y<sub>0</sub>) a search pattern may include evaluating sets of samples having the shape of the template located at the following positions: (x<sub>0</sub>&#x2212;4, y<sub>0</sub>); (x<sub>0</sub>+4, y<sub>0</sub>); (x<sub>0</sub>, y<sub>0</sub>&#x2212;4) and (x<sub>0</sub>, y<sub>0</sub>+4). In the example illustrated in <figref idref="DRAWINGS">FIG. <b>6</b></figref>, MV<sub>B2 </sub>forms the center of a search region and the set of samples at a position within the search region having the best match is indicated. As further illustrated in <figref idref="DRAWINGS">FIG. <b>6</b></figref>, a potential CU-level motion vector (i.e., MV<sub>CU</sub>) is determined from the relative position of the set of samples having the best match and the position of the current CU. The process illustrated in <figref idref="DRAWINGS">FIG. <b>6</b></figref>, may be performed using each motion vector in the input set of candidate motion vectors as an origin point and the CU-level motion vector for the current CU may be selected from the potential CU-level motion vectors according to which potential CU-level motion vector provides the best match. As described above, in JEM, after the initial CU-level motion vector is determined, the current CU is divided into sub-blocks and a motion vector is derived for each sub-block by performing a sub-block level iteration of template matching. The sub-block iteration of template matching uses the initial CU-level motion vector as input and may be referred to as a motion vector refinement process.</p><p id="p-0049" num="0048">It should be noted that in JEM, in cases where a candidate neighboring video block is predicted using bi-prediction, template matching is applied independently to the first reference picture and the second reference picture. Thereafter, it is determined whether one of a uni-prediction (one motion vector referencing one of the first reference picture or the second reference picture) or bi-prediction (one motion vector referencing the first reference picture and one motion vector referencing the second reference picture) will be used to generate a prediction for the current video block.</p><p id="p-0050" num="0049"><figref idref="DRAWINGS">FIG. <b>7</b></figref> illustrates the use of bilateral matching for deriving a CU-level motion vector. Bilateral matching is used to derive motion information for a current video block by finding the closest match between two corresponding blocks in two different reference pictures located along a motion trajectory. A motion trajectory may include a motion vector, MV<b>0</b>, pointing to a reference block in a reference picture at a temporal distance, TD<b>0</b>, from a current picture, and a motion vector, MV<b>1</b>, pointing to a reference block in a reference picture at a temporal distance, TD<b>1</b> from a current picture. For example, the reference picture at TD<b>0</b> may be the temporal preceding picture to the current picture (which may be referred to as the backward picture) and the reference picture TD<b>1</b> may be the temporal subsequent picture to the current picture (which may be referred to as the forward picture). It should be noted that in ITU-T H.265 and JEM, each picture is assigned a picture order count (POC) value indicated a temporal position of the picture and temporal distances may be determined as the difference between POC values. Further, it should be noted that in JEM, under the assumption of continuous motion trajectory, the motion vectors MV<b>0</b> and MV<b>1</b> pointing to the two reference blocks shall be proportional to the temporal distances, i.e., TD<b>0</b> and TD<b>1</b>, between the current picture and the two reference pictures.</p><p id="p-0051" num="0050">Similar to template matching, bilateral matching may use one or more sets of motion vector candidates at inputs and each motion vector candidate may be used as an origin point in a reference frame. For example, referring to <figref idref="DRAWINGS">FIG. <b>7</b></figref>, for a current CU, the candidate motion vector B<b>2</b> (i.e., MV<sub>B2</sub>) is used as an origin point in the backward reference picture. Similar to template matching, a search may be performed according to a search pattern initiated with respect to an origin point to identify blocks of sample values in a reference picture. Further, in a manner similar to determining a potential CU-level motion vector in template matching described above, a potential CU-level backward prediction motion vector (i.e., MV<b>0</b><sub>CU </sub>in <figref idref="DRAWINGS">FIG. <b>7</b></figref>) may be determined from the relative position of a block of sample values (i.e., Block0 in <figref idref="DRAWINGS">FIG. <b>7</b></figref>) and the position of the current CU. For each potential CU-level backward motion vector, a corresponding forward motion vector is generated. Typically, the corresponding forward motion vector is generated as a motion vector having the same absolute value and reverse direction of the backward motion vector and is further scaled proportionally based on the temporal distances of TD<b>0</b> and TD<b>1</b>. The corresponding forward motion vector indicates a corresponding block of sample values (i.e., Block<sub>1 </sub>in <figref idref="DRAWINGS">FIG. <b>7</b></figref>). In JEM, the SAD of corresponding samples in Block0 and Block<sub>1 </sub>is used to determine the degree to which the two blocks match for determining the CU-level motion vectors MV<b>0</b> and MV<b>1</b>. In JEM, for each origin point, potential motion vectors MV<b>0</b> and MV<b>1</b> are determined based on the best match between a block in the TD<b>0</b> reference picture (e.g., Block0 in <figref idref="DRAWINGS">FIG. <b>7</b></figref>) and a block in the TD<b>1</b> reference picture (e.g., Block<sub>1 </sub>in <figref idref="DRAWINGS">FIG. <b>7</b></figref>) within a search region. The initial CU-level motion vectors MV<b>0</b> and MV<b>1</b> are selected from the potential motion vectors MV<b>0</b> and MV<b>1</b> according to the best match of corresponding blocks. As described above, in JEM, after the initial CU-level motion vector is determined, the current CU is divided into sub-blocks and a motion vector is derived for each sub-block by performing a sub-block level iteration of bilateral matching. That is, for each sub-block, MV<b>0</b><sub>CU </sub>is used as an origin point in the backward reference picture and a corresponding search region (i.e., search pattern) is used to determine the motion vectors MV<b>0</b> and MV<b>1</b> for each sub-block.</p><p id="p-0052" num="0051">As described above, multiple descriptions of video coding were proposed by various groups at the 10<sup>th </sup>Meeting of ISO/IEC JTC1/SC29/WG11, 16-20 Apr. 2018, San Diego, Calif. &#x201c;Description of SDR video coding technology proposal by MediaTek,&#x201d; ISO/IEC JTC1/SC29/WG11 Document: 1VET-J0018, 10<sup>th </sup>Meeting 16-20 Apr. 2018, San Diego, Calif. (hereinafter &#x201c;J0018&#x201d;) describes a motion vector prediction merge mode where motion vector candidates may include four temporal candidates having the following temporal collocated positions with respect to a current video block: a right bottom position candidate, a center position candidate, a left bottom position candidate, and a right top position candidate.</p><p id="p-0053" num="0052">&#x201c;Description of SDR, HDR and 360&#xb0; video coding technology proposal by Qualcomm and Technicolor&#x2014;low and high complexity versions,&#x201d; ISO/IEC JTC1/SC29/WG11 Document: JVET-J0021, 10<sup>th </sup>Meeting 16-20 Apr. 2018, San Diego, Calif. (hereinafter &#x201c;J0021&#x201d;) describes a motion vector prediction merge mode where motion vector candidates may include adjacent and non-adjacent spatial candidates. J0021 further describes where adjacent spatial candidates are ordered in the merge candidate list according to bi-prediction candidates being ordered before uni-prediction candidates. As described above, in ITU-T H.265, a maximum number of merge candidates is defined and merge candidates are indexed within a merge candidate list. Merge candidates placed at the top of the order list are more likely to be included in a list regardless of the maximum number of merge candidates and have a lower index value, which typically can be signaled using fewer bits (e.g., if a unary binarization is used for an index value).</p><p id="p-0054" num="0053">&#x201c;Description of SDR, HDR and 360&#xb0; video coding technology proposal considering mobile application scenario by Samsung, Huawei, GoPro, and HiSilicon,&#x201d; ISO/IEC JTC1/SC29/WG11 Document: JVET-J0024, 10<sup>th </sup>Meeting 16-20 Apr. 2018, San Diego, Calif. (hereinafter &#x201c;J0024&#x201d;) describes a motion vector prediction technique utilizing Adaptive Motion Vector Resolution (AMVR). As described above, in ITU-T H.265, a motion vector is represented with &#xbc;-pixel (or pel) precision. In AMVP, in ITU-T H.265, because the motion vector of the video current block and the motion vector predictor are represented with &#xbc;-pel precision, the motion vector difference is also represented with &#xbc;-pel precision. Further, in ITU-T H.265, for bi-prediction, the x-component (MVDx) and the y-component (MVDx) for each prediction direction are signaled independently. The AMVR technique proposed in J0024, supports multiple motion vector resolutions and signaling one or both of MVDx and MVDy. In particular, the AMVR technique proposed in J0024 supports the following motion vector resolutions: &#xbc;-pixel, &#xbd;-pixel, 1-pixel, 2-pixel and 4-pixel). In the AMVR technique described in J0024, a MVR Index is signaled at the CU level with MVD information to indicate the motion vector resolution, R, and a motion vector predictor, as provided in Table 1.</p><p id="p-0055" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="35pt" align="center"/><colspec colname="2" colwidth="168pt" align="center"/><thead><row><entry/><entry namest="offset" nameend="2" rowsep="1">TABLE 1</entry></row></thead><tbody valign="top"><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry/><entry>MVR Index</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="7"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="35pt" align="center"/><colspec colname="2" colwidth="42pt" align="center"/><colspec colname="3" colwidth="21pt" align="center"/><colspec colname="4" colwidth="49pt" align="center"/><colspec colname="5" colwidth="21pt" align="center"/><colspec colname="6" colwidth="35pt" align="center"/><tbody valign="top"><row><entry/><entry/><entry>0</entry><entry>1</entry><entry>2</entry><entry>3</entry><entry>4</entry></row><row><entry/><entry namest="offset" nameend="6" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="7"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="35pt" align="left"/><colspec colname="2" colwidth="42pt" align="center"/><colspec colname="3" colwidth="21pt" align="center"/><colspec colname="4" colwidth="49pt" align="center"/><colspec colname="5" colwidth="21pt" align="center"/><colspec colname="6" colwidth="35pt" align="center"/><tbody valign="top"><row><entry/><entry>Resolution </entry><entry>&#xbc;</entry><entry>&#xbd;</entry><entry>1</entry><entry>2</entry><entry>4</entry></row><row><entry/><entry>(R) in pel</entry><entry/><entry/><entry/><entry/><entry/></row><row><entry/><entry>N<sup>th </sup>MVP</entry><entry>1<sup>st </sup></entry><entry>2<sup>nd </sup></entry><entry>3<sup>rd </sup></entry><entry>4<sup>th </sup></entry><entry>5<sup>th</sup></entry></row><row><entry/><entry/><entry>MVP</entry><entry>MVP</entry><entry>MVP</entry><entry>MVP</entry><entry>MVP</entry></row><row><entry/><entry namest="offset" nameend="6" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0056" num="0054">J0024 provides the following equations for adjusting MV (MVx, MVy), MVP (MVPx, MVPy) and MVD (MVDx, MVDy) by the resolution R:</p><p id="p-0057" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>(MV<sub>x</sub>, MV<sub>y</sub>)=(Round(MV<sub>x</sub>/(R*4))*4), Round(MV<sub>y</sub>/(R*4))*(R*4))<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0058" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>(MVP<sub>x</sub>, MVP<sub>y</sub>)=(Round(MVP<sub>x</sub>/(R*4))*(R*4), Round(MVP<sub>y</sub>/(R*4))*(R*4))<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0059" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>(MVD<sub>x</sub>, MVD<sub>y</sub>)=(MV<sub>x</sub>&#x2212;MVP<sub>x</sub>)/(R*4), (MV<sub>y</sub>&#x2212;MVP<sub>y</sub>)/R*4))<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0060" num="0055">Further, J0024 provides where in the case of bi-prediction, there are three possible signal modes for signaling MVDx, MVDy for each prediction direction. That is, J0024 provides where an AMVR Bi-Index value indicates whether the MVDx, and MVDy for each reference list (list 0 or list 1) are signaled or not, as provided in Table 2. It should be noted that when a MVDx, MVDy are not signaled, they are inferred to he equal to (0,0).</p><p id="p-0061" num="0000"><tables id="TABLE-US-00002" num="00002"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="70pt" align="center"/><colspec colname="2" colwidth="49pt" align="center"/><colspec colname="3" colwidth="98pt" align="center"/><thead><row><entry namest="1" nameend="3" rowsep="1">TABLE 2</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row><row><entry>AMVR </entry><entry>(MVD<sub>x</sub>, MVD<sub>y</sub>) </entry><entry>(MVD<sub>x</sub>, MVD<sub>y</sub>) </entry></row><row><entry>Bi-Index</entry><entry>of list 0</entry><entry>of list 1</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>0</entry><entry>Signaled</entry><entry>Signaled</entry></row><row><entry>1</entry><entry>Not signaled</entry><entry>Signaled</entry></row><row><entry>2</entry><entry>Signaled</entry><entry>Not signaled</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0062" num="0056">As described above, in ITU-T H.265, for bi-prediction, the x-component (MVDx) and the y-component (MVDx) for each prediction direction are signaled independently. &#x201c;Symmetrical mode for bi-prediction,&#x201d; ISO/IEC JTC1/SC29/WG11 Document: JVET-J0063, 10<sup>th </sup>Meeting 16-20 Apr. 2018, San Diego, Calif. (hereinafter &#x201c;J0063&#x201d;) describes where only motion information (an MVP Index, MVD, and a reference picture index) for list 0, and an MVP Index for list 1 are explicitly signaled. The reference index and MVD for the list 1 are derived based on the assumption of linear motion. In particular, in J0063, in the case of bi-prediction, a symmetrical mode flag indicating whether symmetrical mode is used or not is explicitly signaled. When the flag is true, only an MVP Index for list 1 is signaled, and the reference index and MVD for list 1 are derived from motion information of list 0. In J0063, the reference index for list 1, ref_idx_11, is determined by searching for a reference picture in list 1, which is mirrored with the reference picture for list 0. If such a picture is not present in list 1, the nearest temporal reference picture to current picture opposite in temporal direction to the list 0 reference picture is used. After the reference picture in list 1 is determined, MVD for list 1, MVD<b>1</b> is derived by scaling MVD for list 0, MVD<b>0</b>. In J0063, the scaling factor is calculated according following formula:</p><heading id="h-0007" level="2">Where,</heading><p id="p-0063" num="0057"><maths id="MATH-US-00001" num="00001"><math overflow="scroll"> <mrow>  <mrow>   <mi>MVD</mi>   <mo>&#x2062;</mo>   <mn>1</mn>  </mrow>  <mo>=</mo>  <mrow>   <mfrac>    <mrow>     <msub>      <mi>POC</mi>      <mi>CUR</mi>     </msub>     <mo>-</mo>     <msub>      <mi>POC</mi>      <mrow>       <mi>list</mi>       <mo>&#x2062;</mo>       <mn>1</mn>      </mrow>     </msub>    </mrow>    <mrow>     <msub>      <mi>POC</mi>      <mi>CUR</mi>     </msub>     <mo>-</mo>     <msub>      <mi>POC</mi>      <mrow>       <mi>list</mi>       <mo>&#x2062;</mo>       <mn>0</mn>      </mrow>     </msub>    </mrow>   </mfrac>   <mo>&#xd7;</mo>   <mi>MVD</mi>   <mo>&#x2062;</mo>   <mn>0</mn>  </mrow> </mrow></math></maths><ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0058">POC<sub>CUR </sub>is the POC value of the current picture,</li>        <li id="ul0002-0002" num="0059">POC<sub>list0 </sub>is the POC value of the list 0 reference picture, and</li>        <li id="ul0002-0003" num="0060">POC<sub>list1 </sub>is the POC value of the list 1 reference picture.</li>    </ul>    </li></ul></p><p id="p-0064" num="0061">As described above, a motion vector is typically expressed as a horizontal displacement component (i.e., MVx) and a vertical displacement component (i.e., MVy). J0024 provides a mechanism for expressing a motion vector according to a starting point, a motion magnitude, and a motion direction. In particular, J0024 provides where candidate motion vector may form a starting point and is signaled according to an index value as provided in Table 3. A distance index indicates a pre-defined distance from a starting point information and is signaled according to an index value as provided in Table 4, and a direction index represents one of the four directions of a MVD from the starting point and is signaled according to an index value as provided in Table 5.</p><p id="p-0065" num="0000"><tables id="TABLE-US-00003" num="00003"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="161pt" align="center"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 3</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Base candidate IDX</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="28pt" align="center"/><colspec colname="3" colwidth="56pt" align="center"/><colspec colname="4" colwidth="28pt" align="center"/><colspec colname="5" colwidth="49pt" align="center"/><tbody valign="top"><row><entry/><entry>0</entry><entry>1</entry><entry>2</entry><entry>3</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row><row><entry>N<sup>th </sup>MVP</entry><entry>1<sup>st </sup>MVP</entry><entry>2<sup>nd </sup>MVP</entry><entry>3<sup>rd </sup>MVP</entry><entry>4<sup>th </sup>MVP</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0066" num="0000"><tables id="TABLE-US-00004" num="00004"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="9"><colspec colname="1" colwidth="42pt" align="center"/><colspec colname="2" colwidth="28pt" align="center"/><colspec colname="3" colwidth="28pt" align="center"/><colspec colname="4" colwidth="28pt" align="center"/><colspec colname="5" colwidth="28pt" align="center"/><colspec colname="6" colwidth="28pt" align="center"/><colspec colname="7" colwidth="28pt" align="center"/><colspec colname="8" colwidth="28pt" align="center"/><colspec colname="9" colwidth="28pt" align="center"/><thead><row><entry namest="1" nameend="9" rowsep="1">TABLE 4</entry></row><row><entry namest="1" nameend="9" align="center" rowsep="1"/></row><row><entry>Distance IDX</entry><entry>0</entry><entry>1</entry><entry>2</entry><entry>3</entry><entry>4</entry><entry>5</entry><entry>6</entry><entry>7</entry></row><row><entry namest="1" nameend="9" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>Pixel distance</entry><entry>1/4-pel</entry><entry>1/2-pel</entry><entry>1-pel</entry><entry>2-pel</entry><entry>4-pel</entry><entry>8-pel</entry><entry>16-pel</entry><entry>32-pel</entry></row><row><entry namest="1" nameend="9" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0067" num="0000"><tables id="TABLE-US-00005" num="00005"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="56pt" align="center"/><colspec colname="2" colwidth="161pt" align="center"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 5</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Direction IDX</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="56pt" align="center"/><colspec colname="2" colwidth="21pt" align="center"/><colspec colname="3" colwidth="63pt" align="center"/><colspec colname="4" colwidth="21pt" align="center"/><colspec colname="5" colwidth="56pt" align="center"/><tbody valign="top"><row><entry/><entry>00</entry><entry>01</entry><entry>10</entry><entry>11</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="21pt" align="center"/><colspec colname="3" colwidth="63pt" align="center"/><colspec colname="4" colwidth="21pt" align="center"/><colspec colname="5" colwidth="56pt" align="center"/><tbody valign="top"><row><entry>x-axis</entry><entry>+</entry><entry>&#x2212;</entry><entry>N/A</entry><entry>N/A</entry></row><row><entry>y-axis</entry><entry>N/A</entry><entry>N/A</entry><entry>+</entry><entry>&#x2212;</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0068" num="0062">According to the techniques described herein additional motion vector prediction techniques are provided. The motion vector prediction techniques provided herein may utilize techniques for deriving a paired set bi-prediction motion vectors described herein, techniques for adaptive motion vector resolution described herein, techniques for motion vector difference signaling described herein, and/or techniques for deriving non-adjacent spatial candidates described herein.</p><p id="p-0069" num="0063"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a block diagram illustrating an example of a system that may be configured to code (i.e., encode and/or decode) video data according to one or more techniques of this disclosure. System <b>100</b> represents an example of a system that may perform video coding using motion vector prediction techniques described according to one or more examples of this disclosure. As illustrated in <figref idref="DRAWINGS">FIG. <b>8</b></figref>, system <b>100</b> includes source device <b>102</b>, communications medium <b>110</b>, and destination device <b>120</b>. In the example illustrated in <figref idref="DRAWINGS">FIG. <b>8</b></figref>, source device <b>102</b> may include any device configured to encode video data and transmit encoded video data to communications medium <b>110</b>. Destination device <b>120</b> may include any device configured to receive encoded video data via communications medium <b>110</b> and to decode encoded video data. Source device <b>102</b> and/or destination device <b>120</b> may include computing devices equipped for wired and/or wireless communications and may include set top boxes, digital video recorders, televisions, desktop, laptop, or tablet computers, gaming consoles, mobile devices, including, for example, &#x201c;smart&#x201d; phones, cellular telephones, personal gaming devices, and medical imagining devices.</p><p id="p-0070" num="0064">Communications medium <b>110</b> may include any combination of wireless and wired communication media, and/or storage devices. Communications medium <b>110</b> may include coaxial cables, fiber optic cables, twisted pair cables, wireless transmitters and receivers, routers, switches, repeaters, base stations, or any other equipment that may be useful to facilitate communications between various devices and sites. Communications medium <b>110</b> may include one or more networks. For example, communications medium <b>110</b> may include a network configured to enable access to the World Wide Web, for example, the Internet. A network may operate according to a combination of one or more telecommunication protocols. Telecommunications protocols may include proprietary aspects and/or may include standardized telecommunication protocols. Examples of standardized telecommunications protocols include Digital Video Broadcasting (DVB) standards, Advanced Television Systems Committee (ATSC) standards, integrated Services Digital Broadcasting (ISDB) standards, Data Over Cable Service Interface Specification (DOCSIS) standards, Global System Mobile Communications (GSM) standards, code division multiple access (CDMA) standards, 3rd Generation Partnership Project (3GPP) standards, European Telecommunications Standards Institute (ETSI) standards, Internet Protocol (IP) standards, Wireless Application Protocol (WAP) standards, and Institute of Electrical and Electronics Engineers (IEEE) standards.</p><p id="p-0071" num="0065">Storage devices may include any type of device or storage medium capable of storing data. A storage medium may include a tangible or non-transitory computer-readable media. A computer readable medium may include optical discs, flash memory, magnetic memory, or any other suitable digital storage media In some examples, a memory device or portions thereof may be described as non-volatile memory and in other examples portions of memory devices may be described as volatile memory. Examples of volatile memories may include random access memories (RAM), dynamic random access memories (DRAM), and static random access memories (SRAM). Examples of non-volatile memories may include magnetic hard discs, optical discs, floppy discs, flash memories, or forms of electrically programmable memories (EPROM) or electrically erasable and programmable (EEPROM) memories. Storage device(s) may include memory cards (e.g., a Secure. Digital (SD) memory card), internal/external hard disk drives, and/or internal/external solid state drives. Data may be stored on a storage device according to a defined file format.</p><p id="p-0072" num="0066">Referring again to <figref idref="DRAWINGS">FIG. <b>8</b></figref>, source device <b>102</b> includes video source <b>104</b>, video encoder <b>106</b>, and interface <b>108</b>. Video source <b>104</b> may include any device configured to capture and/or store video data For example, video source <b>104</b> may include a video camera and a storage device operably coupled thereto. Video encoder <b>106</b> may include any device configured to receive video data and generate a compliant bitstream representing the video data. A compliant bitstream may refer to a bitstream that a video decoder can receive and reproduce video data therefrom. Aspects of a compliant bitstream may be defined according to a video coding standard. When generating a compliant bitstream video encoder <b>106</b> may compress video data. Compression may be lossy (discernible or indiscernible) or lossless. Interface <b>108</b> may include any device configured to receive a compliant video bitstream and transmit and/or store the compliant video bitstream to a communications medium. Interface <b>108</b> may include a network interface card, such as an Ethernet card, and may include an optical transceiver, a radio frequency transceiver, or any other type of device that can send and/or receive information. Further, interface <b>108</b> may include a computer system interface that may enable a compliant video bitstream to be stored on a storage device. For example, interface <b>108</b> may include a chipset supporting Peripheral Component Interconnect (PCI) and Peripheral Component. Interconnect Express (PCTe) bus protocols, proprietary bus protocols, Universal Serial Bus (USB) protocols, I2C, or any other logical and physical structure that may be used to interconnect peer devices.</p><p id="p-0073" num="0067">Referring again to <figref idref="DRAWINGS">FIG. <b>8</b></figref>, destination device <b>120</b> includes interface <b>122</b>, video decoder <b>124</b>, and display <b>126</b>. Interface <b>122</b> may include any device configured to receive a compliant video bitstream from a communications medium. Interface <b>108</b> may include a network interface card, such as an Ethernet card, and may include an optical transceiver, a radio frequency transceiver, or any other type of device that can receive and/or send information. Further, interface <b>122</b> may include a computer system interface enabling a compliant video bitstream to be retrieved from a storage device. For example, interface <b>122</b> may include a chipset supporting PCI and PCIe bus protocols, proprietary bus protocols, USB protocols, I2C, or any other logical and physical structure that may be used to interconnect peer devices. Video decoder <b>124</b> may include any device configured to receive a compliant bitstream and/or acceptable variations thereof and reproduce video data therefrom. Display <b>126</b> may include any device configured to display video data. Display <b>126</b> may comprise one of a variety of display devices such as a liquid crystal display (LCD), a plasma display, an organic light emitting diode (OLED) display, or another type of display. Display <b>126</b> may include a High Definition display or an Ultra High Definition display. It should be noted that although in the example illustrated in <figref idref="DRAWINGS">FIG. <b>8</b></figref>, video decoder <b>124</b> is described as outputting data to display <b>126</b>, video decoder <b>124</b> may be configured to output video data to various types of devices and/or sub-components thereof. For example, video decoder <b>124</b> may be configured to output video data to any communication medium, as described herein.</p><p id="p-0074" num="0068"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a block diagram illustrating an example of video encoder <b>200</b> that may implement the techniques for encoding video data described herein. It should be noted that although example video encoder <b>200</b> is illustrated as having distinct functional blocks, such an illustration is for descriptive purposes and does not limit video encoder <b>200</b> and/or sub-components thereof to a particular hardware or software architecture. Functions of video encoder <b>200</b> may be realized using any combination of hardware, firmware, and/or software implementations. In one example, video encoder <b>200</b> may be configured to encode video data according to the techniques described herein. Video encoder <b>200</b> may perform intra prediction coding and inter prediction coding of picture areas, and, as such, may be referred to as a hybrid video encoder. In the example illustrated in <figref idref="DRAWINGS">FIG. <b>9</b></figref>, video encoder <b>200</b> receives source video blocks. In some examples, source video blocks may include areas of picture that has been divided according to a coding structure. For example, source video data may include macroblocks, CTUs, CBs, sub-divisions thereof, and/or another equivalent coding unit. In some examples, video encoder <b>200</b> may be configured to perform additional subdivisions of source video blocks. It should be noted that some techniques described herein may be generally applicable to video coding, regardless of how source video data is partitioned prior to and/or during encoding. In the example illustrated in <figref idref="DRAWINGS">FIG. <b>9</b></figref>, video encoder <b>200</b> includes summer <b>202</b>, transform coefficient generator <b>204</b>, coefficient quantization unit <b>206</b>, inverse quantization/transform processing unit <b>208</b>, summer <b>210</b>, intra prediction processing unit <b>212</b>, inter prediction processing unit <b>214</b>, filter unit <b>216</b>, and entropy encoding unit <b>218</b>.</p><p id="p-0075" num="0069">As illustrated in <figref idref="DRAWINGS">FIG. <b>9</b></figref>, video encoder <b>200</b> receives source video blocks and outputs a bitstream. Video encoder <b>200</b> may generate residual data by subtracting a predictive video block from a source video block. Summer <b>202</b> represents a component configured to perform this subtraction operation. In one example, the subtraction of video blocks occurs in the pixel domain. Transform coefficient generator <b>204</b> applies a transform, such as a discrete cosine transform (DCT), a discrete sine transform (DST), or a conceptually similar transform, to the residual block or sub-divisions thereof (e.g., four 8&#xd7;8 transforms may be applied to a 16&#xd7;16 array of residudl values) to produce a set of residual transform coefficients. Transform coefficient generator <b>204</b> may be configured to perform any and all combinations of the transforms included in the family of discrete trigonometric transforms. Transform coefficient generator <b>204</b> may output. transform coefficients to coefficient quantization unit <b>206</b>. Coefficient quantization unit <b>206</b> may be configured to perform quantization of the transform coefficients. As described above, the degree of quantization may be modified by adjusting a quantization parameter. Coefficient quantization unit <b>206</b> may be further configured to determine quantization parameters (QP) and output QP data (e.g., data used to determine a quantization group size and/or delta QP values) that may be used by a video decoder to reconstruct a quantization parameter to perform inverse quantization during video decoding. It should be noted that in other examples, one or more additional or alternative parameters may be used to determine a level of quantization (e.g., scaling factors). The techniques described herein may be generally applicable to determining a level of quantization for transform coefficients corresponding to a component of video data based on a level of quantization for transform coefficients corresponding another component of video data.</p><p id="p-0076" num="0070">As illustrated in <figref idref="DRAWINGS">FIG. <b>9</b></figref>, quantized transform coefficients are output to inverse quantization/transform processing unit <b>208</b>. Inverse quantization/transform processing unit <b>208</b> may be configured to apply an inverse quantization and an inverse transformation to generate reconstructed residual data. As illustrated in <figref idref="DRAWINGS">FIG. <b>9</b></figref>, at summer <b>210</b>, reconstructed residual data may be added to a predictive video block. In this manner, an encoded video block may be reconstructed and the resulting reconstructed video block may be used to evaluate the encoding quality for a given prediction, transformation, and/or quantization. Video encoder <b>200</b> may be configured to perform multiple coding passes (e.g., perform encoding while varying one or more of a prediction, transformation parameters, and quantization parameters). The rate-distortion of a bitstream or other system parameters may be optimized based on evaluation of reconstructed video blocks. Further, reconstructed video blocks may be stored and used as reference for predicting subsequent blocks.</p><p id="p-0077" num="0071">As described above, a video block may be coded using an intra prediction mode. Intra prediction processing unit <b>212</b> may be configured to select an intra prediction mode for a current video block. Intra prediction processing unit <b>212</b> may be configured to evaluate a frame and/or an area thereof and determine an intra prediction mode to use to encode a current block. As illustrated in <figref idref="DRAWINGS">FIG. <b>9</b></figref>, intra prediction processing unit <b>212</b> outputs intra prediction data (e.g., syntax elements) to entropy encoding unit <b>218</b> and transform coefficient generator <b>204</b>. As described above, possible intra prediction modes may include planar prediction modes, DC prediction modes, and angular prediction modes. Inter prediction processing unit <b>214</b> may be configured to perform inter prediction coding for a current video block. Inter prediction processing unit <b>214</b> may be configured to receive source video blocks and calculate motion information for PUs of a video block. A motion vector may indicate the displacement of a PU (or similar coding structure) of a video block within a current video frame relative to a predictive block within a reference frame. Inter prediction coding may use one or more reference pictures. For example, inter prediction processing unit <b>214</b> may locate a predictive video block within a frame buffer (not shown in <figref idref="DRAWINGS">FIG. <b>9</b></figref>). It should be noted that inter prediction processing unit <b>214</b> may further be configured to apply one or more interpolation filters to a reconstructed residual block to calculate sub-integer pixel values for use in motion estimation. Further, motion prediction may be uni-predictive (use one motion vector) or bi-predictive (use two motion vectors). Inter prediction processing unit <b>214</b> may be configured to select a predictive block by calculating a pixel difference determined by, for example, sum of absolute difference (SAD), sum of square difference (SSD), or other difference metrics. Inter prediction processing unit <b>214</b> may output motion prediction data for a calculated motion vector to entropy encoding unit <b>218</b>.</p><p id="p-0078" num="0072">As described above, motion information may be determined and specified according to motion vector prediction techniques. Inter prediction processing unit <b>214</b> may be configured to perform motion vector prediction techniques, including for example, those described above. Further, inter prediction processing unit <b>214</b> may be configured to perform motion vector prediction according to techniques described below. In particular, inter prediction processing unit <b>214</b> may be configured to derive a paired set of bi-prediction motion vectors. A derived paired set of bi-prediction motion vectors may be included in a set of motion vector prediction candidates.</p><p id="p-0079" num="0073">In one example, according to the techniques herein, inter prediction processing unit <b>214</b> may be configured to derive a motion vector MV<b>1</b>, from a motion vector MV<b>0</b>, and thus derive a paired set of motion vectors, MV<b>0</b> and MV<b>1</b>. It should be noted that in one example, MV<b>0</b> may be selected from a uni-prediction motion vector candidate or as one motion vector from a bi-prediction motion vector candidate. A selected motion vector MV<b>0</b> (MV<b>0</b>x, MV<b>0</b>y) includes a corresponding reference picture, ref0. ref0 may be included in a reference picture list and be associated with a POC value, POC<b>0</b>. POC<b>0</b> may be used to derive a POC value, POC<b>1</b>, for the reference picture, ref1, corresponding to MV<b>1</b> as follows:</p><p id="p-0080" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>POC<b>1</b>=2*POC<sub>Cur</sub>&#x2212;POC<b>0</b><?in-line-formulae description="In-line Formulae" end="tail"?><ul id="ul0003" list-style="none">    <li id="ul0003-0001" num="0000">    <ul id="ul0004" list-style="none">        <li id="ul0004-0001" num="0074">Where,</li>        <li id="ul0004-0002" num="0075">POC<sub>Cur </sub>is the POC value of the current picture.</li>    </ul>    </li></ul></p><p id="p-0081" num="0076">It should be noted that there may be cases where ref1 is required to be selected from a reference picture list (e.g., reference list 1) and a reference picture having POC<b>1</b>, as derived above, is not included in the reference picture list. In such cases, ref1 may be selected as the reference picture included in the reference picture list which has a POC value that is closest to POCCur. Further, if two pictures have POC values that are equally close to POCCur, the picture with a POC value most distant from POC<b>0</b> may be selected.</p><p id="p-0082" num="0077">After POC<b>1</b> is determined, MV<b>1</b> may be set to (a<sub>1</sub>*MV<b>0</b>x, a<sub>1</sub>*MV<b>0</b>y) where a<sub>1 </sub>is determined as follows:</p><p id="p-0083" num="0000"><maths id="MATH-US-00002" num="00002"><math overflow="scroll"> <mrow>  <mrow>   <mrow>    <mi>a</mi>    <mo>&#x2062;</mo>    <mn>1</mn>   </mrow>   <mo>=</mo>   <mfrac>    <mrow>     <msub>      <mi>POC</mi>      <mi>CUR</mi>     </msub>     <mo>-</mo>     <mrow>      <mi>POC</mi>      <mo>&#x2062;</mo>      <mn>1</mn>     </mrow>    </mrow>    <mrow>     <msub>      <mi>POC</mi>      <mi>CUR</mi>     </msub>     <mo>-</mo>     <mrow>      <mi>POC</mi>      <mo>&#x2062;</mo>      <mn>0</mn>     </mrow>    </mrow>   </mfrac>  </mrow>  <mo>;</mo> </mrow></math></maths></p><p id="p-0084" num="0078">It should be noted that in some cases, a<sub>1 </sub>may be set to 1 or &#x2212;1, e.g., according to a flag (e.g., a flag included in a parameter set or a slice header). For example, a flag may indicate a<sub>1</sub>=&#x2212;1, when POCcur&#x2212;POC<b>1</b> and POCcur&#x2212;POC<b>0</b> have a different sign value and a<sub>1</sub>=1, when POCcur&#x2212;POC<b>1</b> and POCcur&#x2212;POC<b>0</b> have the same sign value.</p><p id="p-0085" num="0079">In one example, MV<b>0</b> may be used as an origin point and a motion vector, MV<b>0</b>&#x2032;=(MV<b>0</b>x+offset_x, MV<b>0</b>y+offset_y), may be derived according to a template or bilateral matching technique, for example, those described above. In one example, once MV<b>0</b>&#x2032; is derived, according to the technique above, a motion vector MV<b>1</b>&#x2032; would be equal to (a<sub>1</sub>*(MV<b>0</b>x+offset_x), a<sub>1</sub>*(MV<b>0</b>y+offset_y)). In one example, offset_x and offset_y may be signaled to a video decoder. Further, in one example, offset_x and offset_y may be derived by a video decoder using MV<b>0</b> as an origin point and performing the template or bilateral matching technique performed by a video encoder.</p><p id="p-0086" num="0080">In one example, according to the techniques herein, inter prediction processing unit <b>214</b> may be configured to derive a paired set of motion vectors, MV<b>0</b>&#x2032; and MV<b>1</b>&#x2032; from a paired set of motion vectors, MV<b>0</b> and MV<b>1</b>. In one example, MV<b>0</b> (MV<b>0</b>x, MV<b>0</b>y) having corresponding reference picture ref0 and MV<b>1</b> (MV<b>1</b>x, MV<b>1</b>y) having corresponding reference picture ref1 may be inherited from a bi-prediction motion vector candidate. In one example, MV<b>0</b>&#x2032; and MV<b>1</b>&#x2032; may be derived as follows:</p><p id="p-0087" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>MV<b>0</b>&#x2032;=(MV<b>0</b><sub>x</sub>+offset_x, MV<b>0</b><sub>y</sub>+offset_y);<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0088" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>MV<b>1</b>&#x2032;=(MV<b>1</b><sub>x</sub>+a<sub>1</sub>*offset_x, MV<b>1</b><sub>y</sub>+a<sub>1</sub>*offset_y);<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0089" num="0000"><maths id="MATH-US-00003" num="00003"><math overflow="scroll"> <mrow>  <mrow>   <mrow>    <mi>a</mi>    <mo>&#x2062;</mo>    <mn>1</mn>   </mrow>   <mo>=</mo>   <mfrac>    <mrow>     <msub>      <mi>POC</mi>      <mi>CUR</mi>     </msub>     <mo>-</mo>     <mrow>      <mi>POC</mi>      <mo>&#x2062;</mo>      <mn>1</mn>     </mrow>    </mrow>    <mrow>     <msub>      <mi>POC</mi>      <mi>CUR</mi>     </msub>     <mo>-</mo>     <mrow>      <mi>POC</mi>      <mo>&#x2062;</mo>      <mn>0</mn>     </mrow>    </mrow>   </mfrac>  </mrow>  <mo>;</mo> </mrow></math></maths><ul id="ul0005" list-style="none">    <li id="ul0005-0001" num="0000">    <ul id="ul0006" list-style="none">        <li id="ul0006-0001" num="0081">Where,</li>        <li id="ul0006-0002" num="0082">POC<b>1</b> is the POC of ref1; and</li>        <li id="ul0006-0003" num="0083">offset_x and offset_y are determined by applying, for example, a template or bilateral matching technique using MV<b>0</b> as an origin point.</li>    </ul>    </li></ul></p><p id="p-0090" num="0084">It should be noted that in one example, for a bi-prediction candidate, whether a video decoder derives a paired set of motion vectors by selecting one of the motion vectors from a bi-prediction motion vector candidate (i.e., derives MV<b>0</b>&#x2032; and MV<b>1</b>&#x2032; from the selected motion vector MV<b>0</b> (MV<b>0</b>x, MV<b>0</b>y)) or derives a paired set of motion vectors from both motion vectors of the bi-prediction motion vector candidate, according to the techniques above, may be determined based on explicit signaling. For example, an index value identifying a bi-prediction motion vector candidate may be signaled and an associated flag may indicate whether one of the motion vectors from the bi-prediction motion vector candidate or both motion vectors of the bi-prediction motion vector candidate are used to determine MV<b>0</b>&#x2032; and MV<b>1</b>&#x2032;. Further, in the case where one of the motion vectors from the bi-prediction motion vector candidate is used, which of the motion vectors is used may be indicated (a flag indicating MV<b>0</b> or MV<b>1</b>) or inferred (e.g., use MV<b>0</b>). Further, in one example, for a bi-prediction motion vector candidate (MV<b>0</b> and MV<b>1</b>) and MV<b>0</b>&#x2032; equal to (MV<b>0</b>x+offset_x, MV<b>0</b>y+offset_y), a video decoder may determine whether MV<b>1</b>&#x2032; used for motion vector prediction is (a<sub>1</sub>*(MV<b>0</b>x+offset_x), a<sub>1</sub>*(MV<b>0</b>y+offset_y)) or (MV<b>1</b>x+a<sub>1</sub>*offset_x, MV<b>1</b>y+a<sub>1</sub>*offset_y) by performing template or bilateral matching for each derivation of MV<b>1</b>&#x2032;. In one example, a video decoder may determine whether MV<b>1</b>&#x2032; used for motion vector prediction is (a<sub>1</sub>*(MV<b>0</b>x+offset_x), a<sub>1</sub>*(MV<b>0</b>y+offset_y)) or (MV<b>1</b>x+a<sub>1</sub>*offset_x, MV<b>1</b>y+a<sub>1</sub>*offset_y) based on whether a picture having POC<b>1</b>=2*POCCur&#x2212;POC<b>0</b> is available in a reference list, in such a case MV<b>1</b>&#x2032; may be determined according to (MV<b>1</b>x+a<sub>1</sub>*offset_x, MV<b>1</b>y+a<sub>1</sub>*offset_y). Further, in one example, the difference between MV<b>0</b> and MV<b>1</b> may be determined and one of the techniques for determining MV<b>1</b>&#x2032; may be selected based on whether the absolute difference is greater than a threshold value. In one example, the sign values (or directions) of MV<b>0</b> and MV<b>1</b> may be compared and if MV<b>0</b> and MV<b>1</b> have the same sign, MV<b>1</b>&#x2032; may be determined according to (a<sub>1</sub>*(MV<b>0</b>x+offset_x), a<sub>1</sub>*(MV<b>0</b>y+offset_y)).</p><p id="p-0091" num="0085">In one example, according to the techniques herein, inter prediction processing unit <b>214</b> may be configured to adjust the resolution of a MVP and/or a MVD value locally. For example, inter prediction processing unit <b>214</b> may determine the MVP and/or a MVD value for a CU according to a derivation process and explicitly signal the resolution of MVP and/or a corresponding MVD value. It should be noted that in one example, each of the resolutions of the MVP and MVD may be signaled independently and in some examples, one of the resolutions of the MVP and MVD may be signaled and the resolution of the MVP (or MVD) may be adjusted based on the resolution of the MVD (or MVP). In one example, inter prediction processing unit <b>214</b> may be configured to explicit signal the resolution of a MVP and/or a corresponding MVD value index value at a CTU/CU level that indicates the MV resolution. For example, the following indices with corresponding resolutions may be represented by corresponding syntax elements values:</p><p id="p-0092" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>MVP_resolution_idx: &#xbc;, &#xbd;, 1, 2, 4, 8<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0093" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>MVD_resolution_idx: &#xbc;, &#xbd;, 1, 2, 4<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0094" num="0086">In one example, if the current CU is coded using a Skip/Merge mode, MVP_resolution_idx is signaled and MVD_resolution_idx is not signaled. In one example, if the current CU is coded using a AMVP mode, both MVP_resolution_idx and MVD_resolution_idx may be present in a bitstream.</p><p id="p-0095" num="0087">As described above, inter prediction processing unit <b>214</b> may be configured to perform motion vector prediction using a derived paired set of bi-prediction motion vectors. In one example, inter prediction processing unit <b>214</b> may be configured to perform motion vector prediction using a so-called bi-merge mode. In one example, according to a bi-merge mode, inter prediction processing unit <b>214</b> may derive a set of candidates for merge mode according to the techniques described above with respect to <figref idref="DRAWINGS">FIG. <b>4</b></figref> or another technique for deriving a set of merge mode candidates. Inter prediction processing unit <b>214</b> may reorder the set of candidates such that all bi-prediction candidates are ordered higher on the candidate list. For each, uni-prediction candidate, a paired set of motion vectors may be derived, for example, according to the technique described above. In one example, each uni-prediction candidate may be replaced in the candidate list with its derived paired set of motion vectors. In one example, the derived paired set of motion vectors may be added to the list. In one example, the derived paired set of motion vectors may be added to the list and may be ordered higher in the list than the uni-prediction candidates. Inter prediction processing unit <b>214</b> may be configured to select a candidate and signal the selected candidate according to an index value. It should be noted, that as described above, bi-prediction is not enabled for P slices. In one example, for a P slice, the list of candidates including the bi-prediction candidates may be derived and one of the predictions for each bi-prediction candidates may be removed (e.g., all list 1 candidates). In one example, in bi-merge mode, offset values and MVD values are not signaled. However, in one example, a video decoder, may perform a motion vector refinement for selected candidate, e.g., according to a template matching or bilateral matching.</p><p id="p-0096" num="0088">As described above, for AMVP in ITU-T H.265, a candidate block is selected from the derived set of candidates and an index value indicating the selected candidate and a delta value indicating the difference between the motion vector predictor and the motion vector for the current PB are included in the bitstream. In one example, inter prediction processing unit <b>214</b> may be configured to perform motion vector prediction using a so-called Bi-AMVP mode. According to a Bi-AMVP modes, only bi-prediction is allowed for generating a prediction for a current block. That is, in a Bi-AMVP mode, for a current video block, a first motion vector and a second motion vector are used to generate a prediction. That is, a first motion vector for a current block may be equal to mvp0+mvd0 and a second motion vector for a current block may be equal to mvp1+mvd1, where mvpX is a motion vector predictor and mvdX is a delta value. According to the techniques herein there may be several ways mvp0, mvd0, mvp1, and mvd1 and the corresponding reference pictures are derived/signaled. That is, there may be several types of Bi-AMVP modes.</p><p id="p-0097" num="0089">It should be noted that for AMVP in ITU-T H.265, when bi-prediction is used, for each prediction direction, a reference picture is indicated by signaling a reference picture index associated with a constructed reference picture list (e.g., ref_idx_10 and ref_idx_11). Further, for AMVP in ITU-T H.265 for B slices, a syntax element (i.e., inter_pred_idc) indicates whether one of a uni-prediction using list0, a uni-prediction using list1, or a bi-prediction is used to generate a prediction for a current block. As described in further detail below, for some types of Bi-AMVP modes for B slices, syntax elements indicating a uni-prediction using list0 or list1 a bi-prediction (e.g., inter_pred_idc in ITU-T H.265) do not need to be and are not signaled. Further, values of inter_pred_idc may have different interpretations depending on the Bi-AMVP mode. A particular Bi-AMVP mode may be derived by a video decoder by parsing explicit signaling in the bitstream (e.g., syntax element(s) present in a parameter set, slice header, and/or at the CTU or CU level) and/or implicitly derived by coding parameters and/or properties of video data (e.g., CU size, temporal id, partitioning depth, etc.).</p><p id="p-0098" num="0090">In one example, according to a Bi-AMVP mode, inter prediction processing unit <b>214</b> may derive an initial set of candidates, for example, according to the techniques described above with respect to <figref idref="DRAWINGS">FIG. <b>5</b></figref> or another technique for deriving a set of motion vector predictor candidates. For each uni-prediction candidate in the initial set of candidates, inter prediction processing unit <b>214</b> converts the uni-prediction candidate to a derived paired set of motion vectors, for example, according to the techniques described above. For each, bi-prediction candidate in the initial set of candidates, inter prediction processing unit <b>214</b> converts each of MV<b>0</b> nand MV<b>1</b> to a derived paired set of motion vectors, for example, according to the techniques described above. Thus, the initial candidate list 0 and list 1 are expanded, where the final candidate list 0 and list 1 include a derived pair for each uni-prediction candidate in initial candidate list 0, a first derived pair for the bi-prediction motion vector and a second derived pair for second bi-prediction motion vector. Table 6 illustrates where a final candidate list 0 and a final candidate list 1 are generated based on a uni-prediction motion vector predictor and a bi-prediction motion vector predictor in an initial candidate list. That is, as illustrated in Table 6, for the uni-prediction motion vector predictor MV<sub>0, </sub>MV<sub>0</sub><b>0</b> is added to final candidate list 0 and derived MV<sub>0</sub><b>1</b>* is added to final candidate list 1 and for the bi-prediction motion vector predictor MV<sub>1</sub>, MV<sub>1</sub><b>0</b> and derived MV<sub>1</sub><b>0</b>* are added to final candidate list 0 and derived MV<sub>1</sub><b>1</b>* and MV<sub>1</sub><b>1</b> are added to final candidate list 1.</p><p id="p-0099" num="0000"><tables id="TABLE-US-00006" num="00006"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="42pt" align="left"/><colspec colname="2" colwidth="35pt" align="left"/><colspec colname="3" colwidth="35pt" align="left"/><colspec colname="4" colwidth="35pt" align="left"/><colspec colname="5" colwidth="35pt" align="left"/><colspec colname="6" colwidth="35pt" align="left"/><thead><row><entry namest="1" nameend="6" rowsep="1">TABLE 6</entry></row><row><entry namest="1" nameend="6" align="center" rowsep="1"/></row><row><entry/><entry>Motion </entry><entry/><entry/><entry/><entry/></row><row><entry>Motion </entry><entry>Vector</entry><entry>Initial</entry><entry>Initial</entry><entry>Final</entry><entry>Final</entry></row><row><entry>Vector</entry><entry>Predictor </entry><entry>Candidate </entry><entry>Candidate </entry><entry>Candidate</entry><entry>Candidate</entry></row><row><entry>Predictor</entry><entry>Type</entry><entry>List 0</entry><entry>List 1</entry><entry>List 0</entry><entry>List 1</entry></row><row><entry namest="1" nameend="6" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>MV<sub>0 </sub>(MV<sub>0</sub>0)</entry><entry>Uni</entry><entry>MV<sub>0</sub>0</entry><entry>N/A</entry><entry>MV<sub>0</sub>0</entry><entry>MV<sub>0</sub>1*</entry></row><row><entry>MV<sub>1 </sub>(MV<sub>1</sub>0,</entry><entry>Bi</entry><entry>MV<sub>1</sub>0</entry><entry>MV<sub>1</sub>1</entry><entry>MV<sub>1</sub>0</entry><entry>MV<sub>1</sub>1*</entry></row><row><entry>MV<sub>1</sub>1)</entry><entry/><entry>N/A</entry><entry>N/A</entry><entry>MV<sub>1</sub>0*</entry><entry>MV<sub>1</sub>1</entry></row><row><entry namest="1" nameend="6" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0100" num="0091">Thus, with respect to the example illustrated in Table 6, for a current video block, a first motion vector may be determined by one of MV<sub>0</sub><b>0</b>, MV<sub>1</sub><b>0</b>, or MV<sub>1</sub><b>0</b>* being a first motion vector predictor (e.g., mvp0 is set to one of MV<sub>0</sub><b>0</b>, MV<sub>1</sub><b>0</b>, or MV<sub>1</sub><b>0</b>*) and a corresponding delta value (e.g., mvd0) and a second motion vector may be determined by one of MV<sub>0</sub><b>1</b>*, MV<sub>1</sub><b>1</b>*, or MV<sub>1</sub><b>1</b> being a second motion vector predictor (e.g., mvp1 is set to one of MV<sub>0</sub><b>1</b>*, MV<sub>1</sub><b>1</b>*, or MV<sub>1</sub><b>1</b>) and a corresponding delta value (e.g., mvd1).</p><p id="p-0101" num="0092">In one example of Bi-AMVP mode, one of the selected derived pair may be used to generate a prediction and an index corresponding to a selected derived pair is signaled and one or more MVD values are signaled. In one example, a single MVD value is signaled, for example, an MVD value for MV<b>0</b> may be signaled. In one example, the MVD for MV<b>1</b> may be derived based on the MVD value signaled for MV<b>0</b>. For example, in one example, if MVD<sub>0</sub>(MV<b>0</b>x MV<b>0</b>y) is signaled, MVD<sub>1 </sub>may be derived as follows:</p><p id="p-0102" num="0000"><maths id="MATH-US-00004" num="00004"><math overflow="scroll"> <mrow>  <mrow>   <mrow>    <mi>M</mi>    <mo>&#x2062;</mo>    <mi>V</mi>    <mo>&#x2062;</mo>    <msub>     <mi>D</mi>     <mn>1</mn>    </msub>   </mrow>   <mo>=</mo>   <mrow>    <mo>(</mo>    <mrow>     <mrow>      <msub>       <mi>a</mi>       <mn>1</mn>      </msub>      <mo>*</mo>      <mi>MV</mi>      <mo>&#x2062;</mo>      <msub>       <mn>0</mn>       <mi>x</mi>      </msub>     </mrow>     <mo>,</mo>     <mrow>      <msub>       <mi>a</mi>       <mn>1</mn>      </msub>      <mo>*</mo>      <mi>MV</mi>      <mo>&#x2062;</mo>      <msub>       <mn>0</mn>       <mi>y</mi>      </msub>     </mrow>    </mrow>    <mo>)</mo>   </mrow>  </mrow>  <mo>;</mo> </mrow></math></maths><maths id="MATH-US-00004-2" num="00004.2"><math overflow="scroll"> <mrow>  <mrow>   <mrow>    <mi>a</mi>    <mo>&#x2062;</mo>    <mn>1</mn>   </mrow>   <mo>=</mo>   <mfrac>    <mrow>     <msub>      <mi>POC</mi>      <mi>CUR</mi>     </msub>     <mo>-</mo>     <mrow>      <mi>POC</mi>      <mo>&#x2062;</mo>      <mn>1</mn>     </mrow>    </mrow>    <mrow>     <msub>      <mi>POC</mi>      <mi>CUR</mi>     </msub>     <mo>-</mo>     <mrow>      <mi>POC</mi>      <mo>&#x2062;</mo>      <mn>0</mn>     </mrow>    </mrow>   </mfrac>  </mrow>  <mo>;</mo> </mrow></math></maths></p><heading id="h-0008" level="2">Where,</heading><p id="p-0103" num="0000"><ul id="ul0007" list-style="none">    <li id="ul0007-0001" num="0000">    <ul id="ul0008" list-style="none">        <li id="ul0008-0001" num="0093">POC<b>0</b> is the POC of the picture associated with MV<b>0</b>; and</li>        <li id="ul0008-0002" num="0094">POC<b>1</b> is the POC of the picture associated with MV<b>1</b>.</li>    </ul>    </li></ul></p><p id="p-0104" num="0095">It should be noted that signaling one MVD value and further deriving MVD, according to the techniques above can reduce the bit-rate of coded video, and may work well for deriving a prediction for linear motions in video.</p><p id="p-0105" num="0096">In one example, there may be up to (or at least) six modes (i.e., types) of Bi-AMVP. As described above, a mode may be determined by explicit signaling and/or implicitly. In one example, an index value and/or flag(s) may be signaled (e.g., slice header) to indicate a particular Bi-AMVP mode. Table 7A illustrates an example of six modes of Bi-AMVP. In the example illustrated in Table 7A, the six modes of Bi-AMVP are illustrated based on the prediction unit syntax in ITU-T H.265. That is, inter_pred_idc may indicate one of a uni-prediction using list0, a uni-prediction using list1, or a bi-prediction, ref_idx_1X is a reference picture index indicating a reference picture associated with a constructed reference picture list, mvp_idx_X is a motion vector predictor index (e.g., indicating an entry in a Final Candidate List X), and mvdX is a delta value, which may be determined based on delta coding signaling (e.g., using mvd_coding( ) in ITU-T H.265). It should be noted that the techniques described herein are generally applicable to various AMVP signaling techniques. It should be noted that with respect to Table 7A, list0 may include a forward prediction list and list1 may include a backward prediction list.</p><p id="p-0106" num="0000"><tables id="TABLE-US-00007" num="00007"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="8"><colspec colname="1" colwidth="21pt" align="center"/><colspec colname="2" colwidth="49pt" align="left"/><colspec colname="3" colwidth="35pt" align="center"/><colspec colname="4" colwidth="35pt" align="center"/><colspec colname="5" colwidth="35pt" align="center"/><colspec colname="6" colwidth="35pt" align="center"/><colspec colname="7" colwidth="35pt" align="center"/><colspec colname="8" colwidth="35pt" align="center"/><thead><row><entry namest="1" nameend="8" rowsep="1">TABLE 7A</entry></row><row><entry namest="1" nameend="8" align="center" rowsep="1"/></row><row><entry>Mode</entry><entry>inter_pred_idc</entry><entry>mvp_idx_0</entry><entry>mvd0</entry><entry>ref_idx_l0</entry><entry>mvp_idx_1</entry><entry>mvd1</entry><entry>ref_idx_l1</entry></row><row><entry namest="1" nameend="8" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>0</entry><entry>Inferred to</entry><entry>Inferred </entry><entry>Signaled</entry><entry>Inferred </entry><entry>Inferred </entry><entry>Equal to</entry><entry>Inferred </entry></row><row><entry/><entry>Bi-mode (==2).</entry><entry>to 0.</entry><entry/><entry>to 0.</entry><entry>to 0.</entry><entry>b<sub>1</sub>*mvd0</entry><entry>to 0.</entry></row><row><entry>1</entry><entry>Inferred to</entry><entry>Signaled</entry><entry>Signaled</entry><entry>Inferred </entry><entry>Signaled</entry><entry>Equal to</entry><entry>Inferred </entry></row><row><entry/><entry>Bi-mode (==2).</entry><entry/><entry/><entry>to 0.</entry><entry/><entry>b<sub>1</sub>*mvd0</entry><entry>to 0.</entry></row><row><entry>2</entry><entry>Signaled (==0)</entry><entry>Signaled</entry><entry>Signaled</entry><entry>Inferred </entry><entry>mvp1 =</entry><entry>Equal to</entry><entry>Inferred </entry></row><row><entry/><entry/><entry/><entry/><entry>to 0.</entry><entry>b<sub>1</sub>*mvp0</entry><entry>b<sub>1</sub>*mvd0</entry><entry>to 0.</entry></row><row><entry/><entry>Signaled (==1)</entry><entry>mvp0 =</entry><entry>Equal to</entry><entry>Inferred </entry><entry>Signaled</entry><entry>Signaled</entry><entry>Inferred </entry></row><row><entry/><entry/><entry>b<sub>2</sub>*mvp1</entry><entry>b<sub>2</sub>*mvd1</entry><entry>to 0.</entry><entry/><entry/><entry>to 0.</entry></row><row><entry/><entry>Signaled (==2)</entry><entry>Signaled</entry><entry>Signaled</entry><entry>Inferred </entry><entry>Signaled</entry><entry>Equal to</entry><entry>Inferred </entry></row><row><entry/><entry/><entry/><entry/><entry>to 0.</entry><entry/><entry>b<sub>1</sub>*mvd0</entry><entry>to 0.</entry></row><row><entry>3</entry><entry>Signaled (==0)</entry><entry>Signaled</entry><entry>Signaled</entry><entry>Signaled</entry><entry>mvp1 =</entry><entry>Equal to</entry><entry>Signaled</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>b<sub>1</sub>*mvp0</entry><entry>b<sub>1</sub>*mvd0</entry><entry/></row><row><entry/><entry>Signaled (==1)</entry><entry>mvp0 =</entry><entry>Equal to</entry><entry>Signaled</entry><entry>Signaled</entry><entry>Signaled</entry><entry>Signaled</entry></row><row><entry/><entry/><entry>b<sub>2</sub>*mvp1</entry><entry>b<sub>2</sub>*mvd1</entry><entry/><entry/><entry/><entry/></row><row><entry/><entry>Signaled (==2)</entry><entry>Signaled</entry><entry>Signaled</entry><entry>Signaled</entry><entry>Signaled</entry><entry>Equal to</entry><entry>Signaled</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry/><entry>b<sub>1</sub>*mvd0</entry><entry/></row><row><entry>4</entry><entry>Signaled (==0)</entry><entry>Signaled</entry><entry>Signaled</entry><entry>Signaled</entry><entry>mvp1 =</entry><entry>Signaled</entry><entry>Signaled</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>b<sub>1</sub>*mvp0</entry><entry/><entry/></row><row><entry/><entry>Signaled (==1)</entry><entry>mvp0 =</entry><entry>Signaled</entry><entry>Signaled</entry><entry>Signaled</entry><entry>Signaled</entry><entry>Signaled</entry></row><row><entry/><entry/><entry>b<sub>2</sub>*mvp1</entry><entry/><entry/><entry/><entry/><entry/></row><row><entry/><entry>Signaled (==2)</entry><entry>Signaled</entry><entry>Signaled</entry><entry>Signaled</entry><entry>Signaled</entry><entry>Signaled</entry><entry>Signaled</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="21pt" align="center"/><colspec colname="2" colwidth="49pt" align="left"/><colspec colname="3" colwidth="210pt" align="center"/><tbody valign="top"><row><entry/><entry>Signaled </entry><entry>Semantics as provided in ITU-T H.265</entry></row><row><entry/><entry>(==0, 1 OR 2)</entry><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="7"><colspec colname="1" colwidth="21pt" align="center"/><colspec colname="2" colwidth="49pt" align="left"/><colspec colname="3" colwidth="35pt" align="center"/><colspec colname="4" colwidth="35pt" align="center"/><colspec colname="5" colwidth="35pt" align="center"/><colspec colname="6" colwidth="70pt" align="center"/><colspec colname="7" colwidth="35pt" align="center"/><tbody valign="top"><row><entry/><entry>Signaled (==3)</entry><entry>Signaled</entry><entry>Signaled</entry><entry>Signaled</entry><entry>MV1 =</entry><entry>Signaled</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>b<sub>1</sub>*(mvp0 + mvd0)</entry><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="7"><colspec colname="1" colwidth="21pt" align="center"/><colspec colname="2" colwidth="49pt" align="left"/><colspec colname="3" colwidth="70pt" align="center"/><colspec colname="4" colwidth="35pt" align="center"/><colspec colname="5" colwidth="35pt" align="center"/><colspec colname="6" colwidth="35pt" align="center"/><colspec colname="7" colwidth="35pt" align="center"/><tbody valign="top"><row><entry/><entry>Signaled (==4)</entry><entry>MV0 =</entry><entry>Signaled</entry><entry>Signaled</entry><entry>Signaled</entry><entry>Signaled</entry></row><row><entry/><entry/><entry>b<sub>2</sub>*(mvp1 + mvd1)</entry></row><row><entry namest="1" nameend="7" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0107" num="0097">It should be noted that with respect to Table 7A, b1 and b2 may be determined as follows:</p><p id="p-0108" num="0000"><maths id="MATH-US-00005" num="00005"><math overflow="scroll"> <mrow>  <mrow>   <mrow>    <mi>b</mi>    <mo>&#x2062;</mo>    <mn>1</mn>   </mrow>   <mo>=</mo>   <mfrac>    <mrow>     <msub>      <mi>POC</mi>      <mn>1</mn>     </msub>     <mo>-</mo>     <msub>      <mrow>       <mi>POC</mi>       <mtext> </mtext>      </mrow>      <mi>CUR</mi>     </msub>    </mrow>    <mrow>     <msub>      <mi>POC</mi>      <mn>2</mn>     </msub>     <mo>-</mo>     <msub>      <mrow>       <mi>POC</mi>       <mtext> </mtext>      </mrow>      <mi>CUR</mi>     </msub>    </mrow>   </mfrac>  </mrow>  <mo>;</mo> </mrow></math></maths><maths id="MATH-US-00005-2" num="00005.2"><math overflow="scroll"> <mrow>  <mrow>   <mrow>    <mi>b</mi>    <mo>&#x2062;</mo>    <mn>2</mn>   </mrow>   <mo>=</mo>   <mfrac>    <mrow>     <msub>      <mi>POC</mi>      <mn>2</mn>     </msub>     <mo>-</mo>     <msub>      <mrow>       <mi>POC</mi>       <mtext> </mtext>      </mrow>      <mi>CUR</mi>     </msub>    </mrow>    <mrow>     <msub>      <mi>POC</mi>      <mn>1</mn>     </msub>     <mo>-</mo>     <msub>      <mrow>       <mi>POC</mi>       <mtext> </mtext>      </mrow>      <mi>CUR</mi>     </msub>    </mrow>   </mfrac>  </mrow>  <mo>;</mo> </mrow></math></maths><ul id="ul0009" list-style="none">    <li id="ul0009-0001" num="0000">    <ul id="ul0010" list-style="none">        <li id="ul0010-0001" num="0098">Where,</li>        <li id="ul0010-0002" num="0099">POC<sub>cur </sub>is the POC of the current picture;</li>        <li id="ul0010-0003" num="0100">POC<b>0</b> is the POC of the reference picture given by ref_idx_10; and</li>        <li id="ul0010-0004" num="0101">POC<b>1</b> is the POC of the reference picture given by ref_idx_11.</li>    </ul>    </li></ul></p><p id="p-0109" num="0102">Table 7B illustrates an example of two additional and/or alternative modes of Bi-AMVP to those illustrated in Table 7A.</p><p id="p-0110" num="0000"><tables id="TABLE-US-00008" num="00008"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="8"><colspec colname="1" colwidth="21pt" align="center"/><colspec colname="2" colwidth="49pt" align="left"/><colspec colname="3" colwidth="35pt" align="center"/><colspec colname="4" colwidth="28pt" align="center"/><colspec colname="5" colwidth="35pt" align="center"/><colspec colname="6" colwidth="35pt" align="center"/><colspec colname="7" colwidth="35pt" align="center"/><colspec colname="8" colwidth="35pt" align="center"/><thead><row><entry namest="1" nameend="8" rowsep="1">TABLE 7B</entry></row><row><entry namest="1" nameend="8" align="center" rowsep="1"/></row><row><entry>Mode</entry><entry>inter_pred_idc</entry><entry>mvp_idx_0</entry><entry>mvd0</entry><entry>ref_idx_l0</entry><entry>mvp_idx_1</entry><entry>mvd1</entry><entry>ref_idx_l1</entry></row><row><entry namest="1" nameend="8" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>6</entry><entry>Inferred to</entry><entry>Signaled</entry><entry>Signaled</entry><entry>Inferred </entry><entry>Equal to</entry><entry>Equal to</entry><entry>Inferred </entry></row><row><entry/><entry>Bi-mode (==2).</entry><entry/><entry/><entry>to 0.</entry><entry>mvp_idx_0</entry><entry>b<sub>1</sub>*mvd0</entry><entry>to 0.</entry></row><row><entry>7</entry><entry>Inferred to</entry><entry>Signaled</entry><entry>Signaled</entry><entry>Signaled</entry><entry>Signaled</entry><entry>Equal to</entry><entry>Signaled</entry></row><row><entry/><entry>Bi-mode(==2).</entry><entry/><entry/><entry/><entry/><entry>b<sub>1</sub>*mvd0</entry></row><row><entry namest="1" nameend="8" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0111" num="0103">With respect to Table 7A and 7B, in one example, mvd1 can be adaptively derived from mvd0, depending on whether mvd0 is signaled. In one example, mvd1 may be derived as follows:</p><p id="p-0112" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>signHor=(((mvp0.hor&#x3c;0) &#x26;&#x26; (mvp1.hor&#x3c;0))&#x2225;((mvp0.hor&#x3e;0) &#x26;&#x26; (mvp1.hor&#x3e;0)))?1:&#x2212;1<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0113" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>mvd1.hor=signHor*mvd0.hor<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0114" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>signVer=(((mvp0.ver&#x3c;0) &#x26;&#x26; (mvp1.ver&#x3c;0))&#x2225;((mvp0.ver&#x3e;0) &#x26;&#x26; (mvp1.ver&#x3e;0)))?1:&#x2212;1<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0115" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>mvd1.ver=signVer*mvd0.ver<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0116" num="0104">wherein,</p><p id="p-0117" num="0105">signHor is a sign of the horizontal motion component;</p><p id="p-0118" num="0106">mvp0.hor is the horizontal component of mvp0;</p><p id="p-0119" num="0107">mvd0.hor is the horizontal component of mvd0;</p><p id="p-0120" num="0108">mvp1.hor is the horizontal component of mvp1;</p><p id="p-0121" num="0109">mvd1.hor is the horizontal component of mvp1;</p><p id="p-0122" num="0110">signVer is a sign of the vertical motion component;</p><p id="p-0123" num="0111">mvp0.ver is the vertical component of mvp0;</p><p id="p-0124" num="0112">mvd0.ver is the vertical component of mvd0;</p><p id="p-0125" num="0113">mvp1.ver is the vertical component of mvp1;</p><p id="p-0126" num="0114">mvd1.ver is the vertical component of mvp1;<ul id="ul0011" list-style="none">    <li id="ul0011-0001" num="0000">    <ul id="ul0012" list-style="none">        <li id="ul0012-0001" num="0115">In one example, mvd1 may be derived as follows:</li>    </ul>    </li></ul></p><p id="p-0127" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>signHor=(((mvp0.hor&#x3c;0) &#x26;&#x26; (mvp1.hor&#x3c;0))&#x2225;((mvp0.hor&#x3e;0) &#x26;&#x26; (mvp1.hor&#x3e;0)))? 1 :&#x2212;1<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0128" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>mvd1.hor=signHor*mvd0.hor<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0129" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>signVer=(((mvp0.ver&#x3c;0) &#x26;&#x26; (mvp1.ver&#x3c;0))&#x2225;((mvp0.ver&#x3e;0) &#x26;&#x26; (mvp1.ver&#x3e;0)))?1:&#x2212;1<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0130" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>mvd1.ver=signVer*mvd0.ver<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0131" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>if(mvp1.hor==0) mvd1.hor=0<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0132" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>if(mvp1.ver==0) mvd1.ver=0<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0133" num="0116">In one example, a MV<b>0</b> and/or MV<b>1</b> in a Bi-AMVP mode may be determined according to a search process. For example, in one example, for each potential candidate mvp, a corresponding delta value may be determined according to a search process. That is, a search process may be performed for each mvp candidate to determine a motion vector and thus, a mvd value. In one example, a search range for determining a mvd may be determined as an intersecting region between a forward search range and a backward search range. For example, referring to <figref idref="DRAWINGS">FIG. <b>15</b>A</figref>, a forward motion vector predictor, mvp0 having components (mvx0, mvy0), may form the center of an initial search range having dimensions top0, bottom0, left0, and right0, and a backward motion vector predictor, mvp1 having components (mvx1, mvy1), may form the center of an initial search range having dimensions top1, bottom1, left1, and right1. A restricted search range for determining MV<b>0</b> (i.e., mvp0+mvd0) may have dimensions top0&#x2032;, bottom0&#x2032;, left0&#x2032;, and right0&#x2032; and a restricted search range for MV<b>1</b> (i.e., mvp1+mvd1) may have dimensions top1&#x2032;, bottom1&#x2032;, left1&#x2032;, and right1&#x2032;. Referring to <figref idref="DRAWINGS">FIG. <b>15</b>B</figref>, <figref idref="DRAWINGS">FIG. <b>15</b>B</figref> illustrates an example where top0&#x2032;, bottom0&#x2032;, left0&#x2032;, and right0&#x2032; and top1&#x2032;, bottom1&#x2032;, left1&#x2032;, and right1&#x2032; are determined as the overlapping regions of the initial search ranges. In one example, top0&#x2032;, bottom0&#x2032;, left0&#x2032;, and right0&#x2032; may be determined by excluding the region of top0&#x2032;, bottom0&#x2032;, left0&#x2032;, and right0&#x2032; not encapsulated by the region defined by top1&#x2032;, bottom1&#x2032;, left1&#x2032;, and right1&#x2032;. In one example, top1&#x2032;, bottom1&#x2032;, left1&#x2032;, and right1&#x2032; may be determined by excluding the region of top1&#x2032;, bottom1&#x2032;, left1&#x2032;, and right1&#x2032; not encapsulated by the region defined by top0&#x2032;, bottom0&#x2032;, left0&#x2032;, and right0&#x2032;. In one example, top1&#x2032;, bottom1&#x2032;, left1&#x2032;, and right1&#x2032; may be determined by centering top0&#x2032;, bottom0&#x2032;, left0&#x2032;, and right0&#x2032; at mvp<sub>1</sub>.</p><p id="p-0134" num="0117">In one example, with respect to MV<b>0</b> and MV<b>1</b> and the respective initial search ranges the following initial values may be defined:</p><p id="p-0135" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>topDist0=mvy0&#x2212;top0;<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0136" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>bottomDist0=bottom0&#x2212;mvy0;<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0137" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>leftDist0=mvx0&#x2212;left0;<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0138" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>rightDist0=right0&#x2212;mvx0;<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0139" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>topDist1=mvy1&#x2212;top1;<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0140" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>bottomDist1=bottom1&#x2212;mvy1;<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0141" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>leftDist1=mvx1&#x2212;left1; and<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0142" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>rightDist1=right1&#x2212;mvx1.<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0143" num="0118">In one example, a variable a may be calculated as:</p><p id="p-0144" num="0000"><maths id="MATH-US-00006" num="00006"><math overflow="scroll"> <mrow>  <mi>a</mi>  <mo>=</mo>  <mfrac>   <mrow>    <msub>     <mi>POC</mi>     <mn>1</mn>    </msub>    <mo>-</mo>    <msub>     <mi>POC</mi>     <mi>CUR</mi>    </msub>   </mrow>   <mrow>    <msub>     <mi>POC</mi>     <mn>0</mn>    </msub>    <mo>-</mo>    <msub>     <mi>POC</mi>     <mi>CUR</mi>    </msub>   </mrow>  </mfrac> </mrow></math></maths></p><heading id="h-0009" level="2">Where,</heading><p id="p-0145" num="0000"><ul id="ul0013" list-style="none">    <li id="ul0013-0001" num="0000">    <ul id="ul0014" list-style="none">        <li id="ul0014-0001" num="0119">POC<sub>CUR </sub>is the POC value of the current picture,</li>        <li id="ul0014-0002" num="0120">POC<sub>0 </sub>is the POC value of reference picture 0, and</li>        <li id="ul0014-0003" num="0121">POC<sub>1 </sub>is the POC value of reference picture 1,</li>    </ul>    </li></ul></p><p id="p-0146" num="0122">In one example, when a is greater than 0, topDist0; bottomDist0; leftDist0; rightDist0; topDist1; bottomDist1; leftDist1; and rightDist1 may be updated as follows:</p><p id="p-0147" num="0000"><tables id="TABLE-US-00009" num="00009"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="28pt" align="left"/><colspec colname="1" colwidth="49pt" align="left"/><colspec colname="2" colwidth="140pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2003;</entry><entry>if (topDist1 &#x3e; topDist0*a)</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;topDist1 = topDist*</entry></row><row><entry/><entry/><entry>else</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;topDist0 = topDist1/a</entry></row><row><entry/><entry/><entry>if (bottomDist1 &#x3e; bottomDist0*a)</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;bottom Dist1 = bottomDist0*a</entry></row><row><entry/><entry/><entry>else</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;bottomDist0 = bottomDist1/a</entry></row><row><entry/><entry/><entry>if (leftDist1 &#x3e; leftDist0*a)</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;leftDist1 = leftDist0*a</entry></row><row><entry/><entry/><entry>else</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;leftDist0 = leftDist1/a</entry></row><row><entry/><entry/><entry>if (rightDist1 &#x3e; rightDist0*a)</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;rightDist1 = rightDist0*a</entry></row><row><entry/><entry/><entry>else</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;rightDist0 = rightDist1/a</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0148" num="0123">and when a is less than 0, topDist0; bottomDist0; leftDist0; rightDist0; topDist1; bottomDist1; leftDist1; and rightDist1 may be updated as follows:</p><p id="p-0149" num="0000"><tables id="TABLE-US-00010" num="00010"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="42pt" align="left"/><colspec colname="1" colwidth="49pt" align="left"/><colspec colname="2" colwidth="126pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2003;</entry><entry>if (topDist1 &#x3e; bottomDist0*a)</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;topDist1 = bottomDist0*</entry></row><row><entry/><entry/><entry>else</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;bottomDist0 = topDist1/a</entry></row><row><entry/><entry/><entry>if (bottomDist1 &#x3e; topDist0*a)</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;bottom Dist1 = topDist0*a</entry></row><row><entry/><entry/><entry>else</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;topDist0 = bottomDist1/a</entry></row><row><entry/><entry/><entry>if (leftDist1 &#x3e; rightDist0*a)</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;leftDist1 = rightDist0*a</entry></row><row><entry/><entry/><entry>else</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;rightDist0 = leftDist1/a</entry></row><row><entry/><entry/><entry>if (rightDist1 &#x3e; leftDist0*a)</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;rightDist1 = leftDist0*a</entry></row><row><entry/><entry/><entry>else</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;left Dist0 = rightDist1/a</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0150" num="0124">Thus, the restricted search range for MV<b>0</b> and MV<b>1</b> may be determined according to the following:</p><p id="p-0151" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>top0&#x2032;=mvy0&#x2212;topDist0;<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0152" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>mvy0&#x2032;=bottom0&#x2212;bottomDist0;<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0153" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>left0&#x2032;=mvx0&#x2212;leftDist0; and<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0154" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>mvx0&#x2032;=rights0&#x2212;rightDist0.<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0155" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>top1&#x2032;=mvy1&#x2212;topDist1;<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0156" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>mvy1&#x2032;=bottom1&#x2212;bottomDist1;<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0157" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>left1&#x2032;=leftDist1; and<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0158" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>mvx1&#x2032;=right1&#x2212;rightDist1.<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0159" num="0125">As described above, in Bi-AMVP, a forward motion vector may be mvp0+mvd0 and a backward motion vector may be mvp1+mvd1. In one example, a motion vector resolution refinement may be performed for the forward motion vector and/or the backward motion vector. In one example, variables shift_for_mv_predictor and shift_for_mv_offset may be implicitly determined from coding/video properties and/or explicitly signaled (e.g., in a parameter set, a slice header, or a CU header) and the refined motion vectors may be calculated as follows:</p><p id="p-0160" num="0126">If shift_for_mv_predictor&#x3e;0</p><p id="p-0161" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>MV<b>0</b>&#x2032;=((mvp0+(1&#x3c;&#x3c;(shift_for_mv_predictor&#x2212;1)))&#x3e;&#x3e;shift_for_mv_predictor)+((mvd0+(1&#x3c;&#x3c;(shift _for_my_offset)))&#x3e;&#x3e;shift_for_mv_offset)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0162" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>MV<b>1</b>&#x2032;=((mvp1+(1&#x3c;&#x3c;(shift_for_my_predictor&#x2212;1)))&#x3e;&#x3e;shift_for_my_predictor)+((mvp1+(1&#x3c;&#x3c;(shift_for_mv_offset)))&#x3e;&#x3e;shift_for_mv_offset)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0163" num="0127">Referring again to Table 7, as illustrated in Table 7, in some cases both mvp1 and mvd1 are derived from mvp0 and mvd0 (or vice-versa). Such cases may be referred to as a complete inheritance (CI) Bi-AMVP mode. Further, in as illustrated in Table 7, in some cases, mvd1 is derived from mvd0 and mvp1 is signaled independent of mvp0. Such cases may be referred to as a partial inheritance (PI) Bi-AMVP mode. Further, in as illustrated in Table 7, in some cases, mvd1 and mvp1 are signaled independent of mvd0 and mvp0. Such cases may be referred to as an independent Bi-AMVP mode.</p><p id="p-0164" num="0128">In some examples, when a CI Bi-AMVP mode or a PI Bi-AMVP mode is used (or other inter prediction modes), possible mvd values may be compressed and an mvd value may be reconstructed from a compressed mvd value. In one example, a compressed mvd value may be reconstructed according to the following process:<ul id="ul0015" list-style="none">    <li id="ul0015-0001" num="0000">    <ul id="ul0016" list-style="none">        <li id="ul0016-0001" num="0129">uiUncompressed.MVAbs=ReconstructMV(uiCompressedMVAbs);</li>        <li id="ul0016-0002" num="0130">Input: uiCompressedMVAbs, where uiCompressedMVAbs is an absolute mvd value (e.g., x or y component);</li>        <li id="ul0016-0003" num="0131">Output: uiUnCompressedMVAbs, where uiUnCompressedMVAbs is a reconstrued absolute mvd value;</li>    </ul>    </li></ul></p><p id="p-0165" num="0000"><tables id="TABLE-US-00011" num="00011"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>if (uiUncompressedMVAbs &#x3c; 3)</entry></row><row><entry>&#x2003;&#x2003;uiUnCompressedMVAbs = uCompressedMVAbs;</entry></row><row><entry>else if (uiCompressedMVAbs % 2)</entry></row><row><entry>&#x2003;&#x2003;uiUnCompressedMVAbs = 4 &#x3c;&#x3c; ((uiCompressedMVAbs &#x2212; 3) &#x3e;&#x3e; 1);</entry></row><row><entry>else</entry></row><row><entry>&#x2003;{</entry></row><row><entry>&#x2003;&#x2003;uiUnCompressedMVAbs = 4 &#x3c;&#x3c; (uiCompressedMVAbs &#x2212; 3) &#x3e;&#x3e; 1);</entry></row><row><entry>&#x2003;&#x2003;uiUnCompressedMVAbs += uiCompressedMVAbs &#x3e;&#x3e; 1;</entry></row><row><entry>&#x2003;}</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0166" num="0132">It should be noted that</p><p id="p-0167" num="0000"><tables id="TABLE-US-00012" num="00012"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>{</entry></row><row><entry>uiUnCompressedMVAbs = 4 &#x3c;&#x3c; ((uiCompressedMVAbs &#x2212; 3) &#x3e;&#x3e; 1);</entry></row><row><entry>uiUnCompressedMVAbs += uiCompressedMVAbs &#x3e;&#x3e; 1;</entry></row><row><entry>}</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0168" num="0133">may be equivalently expressed as:</p><p id="p-0169" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>uiUnCompressedMVAbs=6&#x3c;&#x3c;((uiCompressedMVAbs&#x2212;3)&#x3e;&#x3e;1);<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0170" num="0134">OR</p><p id="p-0171" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>uiCompressedMVAbs=3&#x3c;&#x3c;((uiCoinpressedMVAbs&#x2212;1)&#x3e;&#x3e;1);<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0172" num="0135">In one example, an mvd value may be compressed according to the following process:</p><p id="p-0173" num="0000"><tables id="TABLE-US-00013" num="00013"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>uiCompressedMVAbs = CompressMV(uiUncompressedMVAbs);</entry></row><row><entry>Input : uiUncompressedMVAbs;</entry></row><row><entry>Output : uiCompressedMVAbs;</entry></row><row><entry>if (uiUncompressedMVAbs &#x3c; 3)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;uiCompressedMVAbs = uiUncompressedMVAbs</entry></row><row><entry>else</entry></row><row><entry>{</entry></row><row><entry>&#x2003;a = log2(uiUncompressedMVAbs)</entry></row><row><entry>&#x2003;if ((1 &#x3c;&#x3c; a) == uiUncompressedMVAbs)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;uiCompressedMVAbs = 2*a &#xb7; 1;</entry></row><row><entry>&#x2003;else if (a &#x3e; 1 &#x26;&#x26; (3 &#x3c;&#x3c; (a<sup>&#x2212;</sup> 1)) == uiUncompressedMVAbs)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;uiCompressedMVAbs = 2*a;</entry></row><row><entry>&#x2003;else</entry></row><row><entry>&#x2003;&#x2003;return &#x2212;1; // invalid</entry></row><row><entry>}</entry></row><row><entry>return uiCompressedMVAbs</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0174" num="0136">where,</p><p id="p-0175" num="0137">log2(x) is a function that returns an integer value that is the largest value y for which 1&#x3c;&#x3c;y&#x3c;=x;</p><p id="p-0176" num="0138">In one example, a compression process can be enabled by repeating reconstruction process, for example as follows:</p><p id="p-0177" num="0000"><tables id="TABLE-US-00014" num="00014"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>uiCompressedMVAbs = CompressMV(uiUncompressedMVAbs);</entry></row><row><entry>Input : uiUncompressedMVAbs</entry></row><row><entry>Output : uiCompressedMVAbs</entry></row><row><entry>for (Index = 0; Index &#x3c; MaxCompressedMVDValue; Index ++)</entry></row><row><entry>{</entry></row><row><entry>&#x2003;if (uiUncompressedMVAbs == ReconstructMV(Index)</entry></row><row><entry>&#x2003;&#x2003;uiCompressedMVAbs = Index</entry></row><row><entry>}</entry></row><row><entry>return uiCompressedMVAbs</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0178" num="0139">In one example, an MVD compression and reconstruction process is performed at a video encoder. Then, only a set of representative (quantized) MVD values are searched. The video encoder may signal the compressed MVD values. A video decoder receiving the compressed MVD values may decode the compressed MVD values and reconstruct them to derive the uncompressed MVD values.</p><p id="p-0179" num="0140">In one example, inter prediction processing unit <b>214</b> may be configured to perform motion vector prediction using a so-called E-Merge mode. According to an E-Merge mode, a list of merge candidate may be derived and an index value may indicate a selected merge candidate. According to an E-Merge mode, inter prediction processing unit <b>214</b> may derive a set of spatial candidates from adjacent and non-adjacent CUs. That is, all available MVs inside the current CTU may be considered as spatial candidates. <figref idref="DRAWINGS">FIG. <b>10</b></figref> illustrates an example of a set of spatial candidates from adjacent CUs (i.e., CU<sub>A0</sub>, CU<sub>A1</sub>, CU<sub>B2</sub>, CU<sub>B1</sub>, and CU<sub>B0</sub>)) and non-adjacent CUs (i.e., CU<sub>NA0</sub>, CU<sub>NA01</sub>, CU<sub>NA02</sub>, CU<sub>NA3, </sub>CU<sub>NA4</sub>, and CU<sub>NA5</sub>) of a current CU (CU<sub>Curr</sub>) within a current CTU. Further, according to an E-Merge mode, inter prediction processing unit <b>214</b> may derive a set of temporal candidates. For example, a set of temporal candidates may include four temporal candidates having the following temporal collocated positions with respect to a current video block: a right bottom position candidate, a center position candidate, a left bottom position candidate, and a right top position candidate. Table 8 illustrates a set of spatial candidates from adjacent CUs, a set of spatial candidates from non-adjacent CUs, and temporal candidates for the example current CU illustrated in <figref idref="DRAWINGS">FIG. <b>10</b></figref>.</p><p id="p-0180" num="0000"><tables id="TABLE-US-00015" num="00015"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="offset" colwidth="28pt" align="left"/><colspec colname="1" colwidth="84pt" align="left"/><colspec colname="2" colwidth="63pt" align="left"/><colspec colname="3" colwidth="42pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="3" rowsep="1">TABLE 8</entry></row><row><entry/><entry namest="offset" nameend="3" align="center" rowsep="1"/></row><row><entry/><entry>Candidate Type</entry><entry>Candidate</entry><entry>Type</entry></row><row><entry/><entry namest="offset" nameend="3" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>Spatial Adjacent</entry><entry>CU<sub>A1</sub></entry><entry>Uni</entry></row><row><entry/><entry/><entry>CU<sub>B1</sub></entry><entry>Bi</entry></row><row><entry/><entry/><entry>CU<sub>A0</sub></entry><entry>Bi</entry></row><row><entry/><entry/><entry>CU<sub>B0</sub></entry><entry>Uni</entry></row><row><entry/><entry/><entry>CU<sub>B0</sub></entry><entry>Uni</entry></row><row><entry/><entry>Spatial Non-Adjacent</entry><entry>CU<sub>NA0</sub></entry><entry>Bi</entry></row><row><entry/><entry/><entry>CU<sub>NA1</sub></entry><entry>Bi</entry></row><row><entry/><entry/><entry>CU<sub>NA2</sub></entry><entry>Uni</entry></row><row><entry/><entry/><entry>CU<sub>NA3</sub></entry><entry>Uni</entry></row><row><entry/><entry/><entry>CU<sub>NA4</sub></entry><entry>Uni</entry></row><row><entry/><entry/><entry>CU<sub>NA5</sub></entry><entry>Uni</entry></row><row><entry/><entry>Temporal</entry><entry>Temp<sub>RB</sub></entry><entry>Uni</entry></row><row><entry/><entry/><entry>Temp<sub>LB</sub></entry><entry>Bi</entry></row><row><entry/><entry/><entry>Temp<sub>RT</sub></entry><entry>Bi</entry></row><row><entry/><entry/><entry>Temp<sub>Center</sub></entry><entry>Uni</entry></row><row><entry/><entry namest="offset" nameend="3" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0181" num="0141">For each uni-prediction candidate, inter prediction processing unit <b>214</b> may derive a paired set of motion vectors, MV<b>0</b> and MV<b>1</b>, according to the technique described above. Further, for each uni-prediction candidate, inter prediction processing unit <b>214</b> may derive a paired set of motion vectors, MV<b>0</b>&#x2032; and MV<b>1</b>&#x2032; having offset values which are derived according to a template or bi-lateral matching, which may be performing by both a video encoder and video decoder, e.g., according to the techniques described above. Further, in one example, offset values may be signaled with an index value indicating a selected candidate. In one example, higher level signaling (e.g., a flag in a parameter set) may indicate whether the offset values are signaled. Table 9 illustrates derived paired sets of motion vectors for uni-prediction motion vector candidates. For each bi-prediction candidate, inter prediction processing unit <b>214</b> may derive a paired set of motion vectors, MV<b>0</b> and MV<b>1</b>, for each of MV<b>0</b> and MV<b>1</b> included in the bi-prediction for example, according to the technique described above. Further, for each bi-prediction candidate, inter prediction processing unit <b>214</b> may derive a paired set of motion vectors, MV<b>0</b>&#x2032; and MV<b>1</b>&#x2032; having offset values which are derived according to template or bi-lateral matching, according to the techniques described above. Table 9 illustrates derived paired sets of motion vectors for bi-prediction motion vector candidates.</p><p id="p-0182" num="0000"><tables id="TABLE-US-00016" num="00016"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="133pt" align="left"/><colspec colname="3" colwidth="28pt" align="left"/><thead><row><entry namest="1" nameend="3" rowsep="1">TABLE 9</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row><row><entry>Candidate Type</entry><entry>Candidate</entry><entry>Type</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>Spatial Adjacent</entry><entry>CU<sub>A1</sub></entry><entry>Uni</entry></row><row><entry/><entry>MV0 = (MV0<sub>x</sub>, MV0<sub>y</sub>)</entry><entry/></row><row><entry/><entry>CU<sub>A1 </sub>Derived<sub>1</sub></entry><entry>Bi</entry></row><row><entry/><entry>MV0 = (MV0<sub>x</sub>, MV0<sub>y</sub>),</entry><entry/></row><row><entry/><entry>MV1 = (a<sub>1</sub>*MV0<sub>x</sub>, a<sub>1</sub>*MV0<sub>y</sub>)</entry><entry/></row><row><entry/><entry>CU<sub>A1 </sub>Derived<sub>offset</sub></entry><entry>Bi</entry></row><row><entry/><entry>MV0&#x2032; = (MV0<sub>x </sub>+ offset_x, MV0<sub>y </sub>+ offset_y),</entry><entry/></row><row><entry/><entry>MV1&#x2032; = (a<sub>1</sub>*( MV0<sub>x </sub>+ offset_x), a<sub>1</sub>*( MV0<sub>y </sub>+ </entry><entry/></row><row><entry/><entry>offset_y))</entry><entry/></row><row><entry/><entry>. . .</entry><entry/></row><row><entry>Spatial Non-</entry><entry>CU<sub>NA0</sub></entry><entry>Bi</entry></row><row><entry>Adjacent</entry><entry>MV0 = (MV0<sub>x</sub>, MV0<sub>y</sub>)</entry><entry/></row><row><entry/><entry>MV1 = (MV1<sub>x</sub>, MV1<sub>y</sub>)</entry><entry/></row><row><entry/><entry>CU<sub>NA0 </sub>Derived<sub>MV0</sub></entry><entry>Bi</entry></row><row><entry/><entry>MV0 = (MV0<sub>x</sub>, MV0<sub>y</sub>),</entry><entry/></row><row><entry/><entry>MV1 = (a<sub>1</sub>*MV0<sub>x</sub>, a<sub>1</sub>*MV0<sub>y</sub>)</entry><entry/></row><row><entry/><entry>CU<sub>NA0 </sub>Derived<sub>MV1</sub></entry><entry>Bi</entry></row><row><entry/><entry>MV0 = (MV1<sub>x</sub>, MV1<sub>y</sub>),</entry><entry/></row><row><entry/><entry>MV1 = (a<sub>1</sub>*MV1<sub>x</sub>, a<sub>1</sub>*MV1<sub>y</sub>)</entry><entry/></row><row><entry/><entry>CU<sub>NA0 </sub>Derived<sub>offset</sub></entry><entry>Bi</entry></row><row><entry/><entry>MV0&#x2032; = (MV0<sub>x </sub>+ offset_x, MV0<sub>y </sub>+ offset_y),</entry><entry/></row><row><entry/><entry>MV1&#x2032; = (MV1<sub>x </sub>+ a<sub>1</sub>*offset_x, MV1<sub>y </sub>+ </entry><entry/></row><row><entry/><entry>a<sub>1</sub>*offset_y)</entry><entry/></row><row><entry/><entry>. . .</entry><entry/></row><row><entry>Temporal</entry><entry>Temp<sub>RS</sub></entry><entry>Uni</entry></row><row><entry/><entry>MV0 = (MV0<sub>x</sub>, MV0<sub>y</sub>)</entry><entry/></row><row><entry/><entry>Temp<sub>RS </sub>Derived<sub>1</sub></entry><entry>Bi</entry></row><row><entry/><entry>MV0 = (MV0<sub>x</sub>, MV0<sub>y</sub>),</entry><entry/></row><row><entry/><entry>MV1 = (a<sub>1</sub>*MV0<sub>x</sub>, a<sub>1</sub>*MV0<sub>y</sub>)</entry><entry/></row><row><entry/><entry>Temp<sub>RS </sub>Derived<sub>offset</sub></entry><entry>Bi</entry></row><row><entry/><entry>MV0&#x2032; = (MV0<sub>x </sub>+ offset_x, MV0<sub>y </sub>+ offset_y),</entry><entry/></row><row><entry/><entry>MV1&#x2032; = (a<sub>1</sub>*( MV0<sub>x </sub>+ offset_x), a<sub>1</sub>*( MV0<sub>y </sub>+ </entry><entry/></row><row><entry/><entry>offset_y))</entry><entry/></row><row><entry/><entry>. . .</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0183" num="0142">According to an E-Merge mode, inter prediction processing unit <b>214</b> may perform a global thinning and ordering process to the list of candidates including all of the derived candidates. Each candidate to be potentially added to the list may be compared to candidates already included in the list and if the MV difference between the new candidate and any previous candidate in the current list is less than a predefined threshold (e.g., a threshold determined by a video decoder and signaled to a video decoder, or a threshold defined according to a standard), the new candidate is not added to the current candidate list. In one example, the threshold value may be adaptively changed depending on the MV resolution (e.g., a MV resolution signaled at CTU/CU-level). In one example, after all candidates are added to the list, the final candidates can be resampled considering their unicity and diversity (if necessary). For example, the covered regions can be defined by all current candidates in the list and the final MV candidates may be resampled in the covered regions by uniform sampling up to a predefined (or specified) number of E-merge candidates. The final candidates in the list may be reordered. In one example, the final candidates may be reordered according to the following rules: candidates derived from spatially neighboring CUs may have the relative highest priorities, candidates having small absolute values may have the next relative highest priorities, bi-directional MVs may have higher priorities than uni-directional MVs, and candidates, which are more frequently selected in the previous CUs, may have relatively higher priorities than candidate which are less frequently selected.</p><p id="p-0184" num="0143">As illustrated in Table 9, candidates may have different types. In one example, all motion vector candidates in a candidate list may be categorized into one of the following categories:<ul id="ul0017" list-style="none">    <li id="ul0017-0001" num="0000">    <ul id="ul0018" list-style="none">        <li id="ul0018-0001" num="0144">Category 0: MV candidates inherited from spatially adjacent CUs (e.g., CU<sub>A1</sub>);</li>        <li id="ul0018-0002" num="0145">Category 1: MV candidates inherited from spatially non-adjacent CUs (e.g., CU <sub>NA0</sub>);</li>        <li id="ul0018-0003" num="0146">Category 2: MV candidates inherited from temporally collocated CUs (e.g., Temp<sub>RB</sub>);</li>        <li id="ul0018-0004" num="0147">Category 3: MV candidates derived from spatially adjacent CUs without derived offsets (e.g., CU<sub>A1 </sub>Derived<sub>1</sub>);</li>        <li id="ul0018-0005" num="0148">Category 4: MV candidates derived from spatially non-adjacent CUs without derived offsets (e.g., CU<sub>NA0 </sub>Derived<sub>1</sub>);</li>        <li id="ul0018-0006" num="0149">Category 5: MV candidates derived from temporally collocated CUs without derived offsets (e.g., Temp<sub>RB </sub>Derived<sub>1</sub>);</li>        <li id="ul0018-0007" num="0150">Category 6: MV candidates derived from spatially adjacent CUs with derived offsets (e.g., CU<sub>A1 </sub>Derived<sub>offset</sub>);</li>        <li id="ul0018-0008" num="0151">Category 7: MV candidates derived from spatially non-adjacent CUs with derived offsets (e.g., CU<sub>NA0 </sub>Derived<sub>offset</sub>;</li>        <li id="ul0018-0009" num="0152">Category 8: MV candidates derived from temporally collocated CUs with derived offsets Temp<sub>RB </sub>Derived<sub>offset</sub>)</li>    </ul>    </li></ul></p><p id="p-0185" num="0153">In one example, for each category, an independent thinning and ordering process can be performed. Further, in one example, each category can be ordered in a final list, for example, as follows: Category 0; Category 3; Category 2; Category 1; Category 5; Category 6; Category 4 Category 8; Category 7.</p><p id="p-0186" num="0154">In one example, for diversity of candidates, a few representative candidates may be chosen among various candidate categories. For example, the first available of a candidate in a category may be selected. In one example, the selected candidate from a category may be used as an origin point and new candidates may be derived by adding offsets to origin points. In some examples, new candidates may be signaled using an index corresponding to a selected candidate and a signaled offset value. In one example, signaling an index corresponding to a selected candidate and offset value may be according to a starting point, a motion magnitude, and a motion direction expression in a manner similar to that described above with respect to J10024. Further, offset values can be adjusted by an AMVR index or neighboring contexts.</p><p id="p-0187" num="0155">In one example, a final list of candidates may be inherited for a CU. For example, in one example, within a CTU, once a merge candidate list is constructed for a CU, the list can be inherited for a subsequently coded CU in the CTU. Further, in some examples, the inherited list can be updated by adding new candidates. In some cases, instead of accessing relatively spatially far CUs from a current CU for construction of a list, for a current. CU, propagating a well-constructed list may be more efficient. Further, it should be noted that in some cases, E-Merge mode, may not be allowed for particular CUs with a CTU. For example, referring to <figref idref="DRAWINGS">FIG. <b>10</b></figref>, for the CU labelled CUNA5, E-Merge mode may be inefficient as a generated list may have relatively few candidates, as spatial CUs within the CTU may not be available (e.g., due to a Z-scan coding order). Further, in some cases, a flag may be signaled to indicate whether a CU is allowed to access spatial CUs outside a current CTU for purposes of creating an initial candidate list and thus, whether E-Merge mode is allowed for CUs. For example, a high level flag (e.g., slice header or parameter set flag) may indicate whether a top-left CU in a CTU is allowed to access spatial CUs outside a current CTU for purposes of creating an initial candidate list.</p><p id="p-0188" num="0156">As described above, according to an E-Merge mode for a current CU, an initial list of motion vector candidates is derived and a thinning process and ordering process may be applied to the initial list of candidates to derive a final list of motion vector candidates. For a subsequent CU, the final list of motion vector candidates from the previous CU may be inherited as a list of motion vector candidates and the inherited list can be updated for the subsequent CU by adding new candidates. In one example, an E-Merge mode may derive a CTU-level list of motion vector candidates in one example, the CTU-level list of motion vector candidates may be derived by deriving an initial list of motion vector candidates for the top-left CU (or another first coded CU in a CTU) in the CTU and applying a thinning process and an ordering process to the initial list of motion vector candidates to generate a CTU-level list of motion vector candidates. In one example, each CU in the CTU (e.g., each CU coded after the top-left CU according to a raster scan order) may inherit the CTU-level list and update the CTU-level list to generate a respective final CU-level list of motion vector candidates. It should be noted that, as described above, steps for deriving an initial list and performing thinning/ordering to generate a final list may be performed interchangeably. That is, for example, derivation and thinning/ordering may be performed on a category-by-category basis.</p><p id="p-0189" num="0157">Referring to <figref idref="DRAWINGS">FIG. <b>14</b></figref>, in one example, the derivation of an initial list of motion vector candidates for a current CU (e.g., the top-left CU in the CTU) may include adding potential motion vector candidates from the following three categories: motion vector candidates inherited from spatially adjacent CUs to the current CU, which are illustrated as MV_LB, MV_L, MV_LT, MV_T, and MV_RT in the example of <figref idref="DRAWINGS">FIG. <b>14</b></figref>; motion vector candidates inherited from spatially non-adjacent CUs to the current CU, which are illustrated as MV_<b>0</b> to MV_<b>6</b> in the example of <figref idref="DRAWINGS">FIG. <b>14</b></figref>; and temporal motion vector candidates. In the example illustrated in <figref idref="DRAWINGS">FIG. <b>14</b></figref> temporal motion vector candidates include a motion vector associated with a CU in a reference picture which is collocated with the current CU, a motion vector associated with the CU that is displaced from the current CU according to the motion vector MV_T, and a motion vector associated with the CU that is displaced from the current CU according to the motion vector MV_L. It should be noted that although <figref idref="DRAWINGS">FIG. <b>14</b></figref> illustrates a single reference picture, in other examples, temporal motion vector candidates may be derived from one or more reference pictures (e.g., reference picture 0 and reference picture 1).</p><p id="p-0190" num="0158">In one example, deriving a final list for a current CU, (and thus, the CTU-level list of motion vector candidates) may include adding motion vector candidates inherited from spatially adjacent CUs to the current CU to the final list (MV_LB, MV_L, MV_LT, MV_T, and MV_RT) with redundant entries removed, adding a representative number of non-redundant motion vector candidates from spatially non-adjacent CUs (e.g., adding two of MV_<b>0</b> to MV_<b>6</b>) to the final list, and adding a representative number of non-redundant motion vector candidates from temporal motion vector candidates (e.g., adding one of MV_L<b>0</b>, MV_R<b>0</b>, or MV_C<b>0</b>) to the final list. It should be noted that redundancy may be based on two motion vectors being equal or having component values within a specified threshold of one another. For example, if respective x-components and/or y-components of motion vectors are within a threshold, the motion vectors may be considered to be redundant.</p><p id="p-0191" num="0159">In one example, adding a representative number of non-redundant motion vector candidates from spatially non-adjacent CUs to the final list may include defining regions. For example, referring to <figref idref="DRAWINGS">FIG. <b>14</b></figref>, defined regions may include a top region including the non-adjacent CUs MV_<b>1</b>, MV_<b>2</b>, and MV_<b>3</b>; a left region including the non-adjacent CUs MV_<b>4</b>, MV_<b>5</b>, and MV_<b>6</b>; and a diagonal region including the non-adjacent CU MV_<b>0</b>. In one example, for each region, one or more representative motion vectors may be derived. A representative motion vector may be derived, for example, by one or more of: selecting a motion vector in a region based on availability (e.g., select the first available of MV_<b>1</b>, MV_<b>2</b>, or MV_<b>3</b>) and/or performing a function on two or more motion vectors in a region (e.g., MV_<b>1</b> and MV_<b>2</b> may be averaged and MV_<b>2</b> and MV_<b>3</b> may be averaged to generate two representative motion vectors). Non-redundant derived representative motion vectors may be added to the final list. For example, for a top region, if a set of representative motion vectors includes the first available of MV_<b>1</b>, MV_<b>2</b>, or MV_<b>3</b> and one of the average of MV_<b>1</b> and MV_<b>2</b> or the average of MV_<b>2</b> and MV_<b>3</b>, when MV_<b>1</b> is added to the final list, if the average of MV_<b>1</b> and MV_<b>2</b> is redundant to MV_<b>1</b>, the average of MV_<b>2</b> and MV_<b>3</b> may be added to the final list. For the left region, in the case where MV_<b>1</b> and the average of MV_<b>2</b> and MV_<b>3</b> were previously added to the list, the first available of MV_<b>4</b>, MV_<b>5</b>, or MV_<b>6</b>, which is non-redundant to MV_<b>1</b> or the average of MV_<b>2</b> and MV_<b>3</b> may be added to the final list and one of the average of MV_<b>4</b> and MV_<b>5</b> or the average of MV_<b>5</b> and MV_<b>6</b> may be added to the final list, if it is non-redundant to any motion vector previously added to the list. It should be noted that such a process may be repeated for any number of regions until the final candidate list includes a predefined number of candidates from spatially non-adjacent CUs. Further, it should be noted the order in which regions are evaluated may be predefined. For example, regions may be evaluated according to the following order: top, left, and diagonal.</p><p id="p-0192" num="0160">In one example, adding a representative number of non-redundant motion vector candidates from temporal motion vector candidates to the final list may be similar to adding a representative number of non-redundant motion vector candidates from spatially non-adjacent CUs to the final list. That is, for each reference frame, one or more representative motion vectors (e.g., the first available of MV_L<b>0</b>, MV_R<b>0</b>, or MV_C<b>0</b> and one of the average of MV_C<b>0</b> and MV_R<b>0</b> or the average of MV_C<b>0</b> and MV_L<b>0</b>) may be derived and non-redundant representative motion vectors may be added to the final list until the final list includes a predefined number of candidates from temporal motion vector candidates. In one example, for ordering, motion vector candidates for each candidate may be grouped and the order of each candidate in a group may be predefined according to the order candidates are added to each group. In one example, a selected candidate motion vector may be identified by signaling a group (e.g., one of spatially adjacent, spatially non-adjacent, or temporal) and an index value corresponding to an order within the group. In one example, signaling a group may include signaling a flag indicating whether the selected candidate motion vector is in the spatially adjacent group, and if the selected candidate motion is not in the spatially adjacent group, signaling a flag indicating whether the selected candidate motion is in one of the spatially non-adjacent or temporal group. In one example, the indexing order of each candidate in a group may signaled (e.g., in a parameter set, slice header, or CTU level syntax). It should be noted that in the typical case, it is desirable to order candidates based on the likelihood of selection.</p><p id="p-0193" num="0161">As described above, at each CU coded after the generation of the CTU-level, the CTU-level list may be inherited and updated to generate a respective final CU-level list of motion vector candidates. In one example, at a CU coded after the generation of the CTU-level list an initial list of CU level candidates may be generated. For example, an initial CU-level list may be generated by adding motion vector candidates inherited from spatially adjacent CUs, adding a representative number of non-redundant motion vector candidates from spatially non-adjacent CUs, and adding a representative number of non-redundant motion vector candidates from temporal MV candidates in an manner similar to that described above. A flag may indicate whether the initial list of CU-level candidates is updated based on the CTU-level list (i.e., whether the CTU-level list is inherited). In one example, when the CTU-level list is inherited, non-redundant candidate motion vectors in the CTU-level list are added to initial list of CU level candidates to generate an final list of CU level candidates. In one example, when the CTU-level list is not inherited, the initial list of CU level candidates become the final list of CU level candidates. It should be noted that when the CTU-level list is inherited, in the typical case, the CU will be associated with a unique list of motion vector candidates (i.e., each CU within a CTU may be associated with a unique list). In one example, the CTU-level list may be updated based on each derived CU-level list. For example, if a CU selects a particular motion vector as a motion vector predictor, the selected motion vector may be added to the CTU-level list.</p><p id="p-0194" num="0162">In one example, motion vector candidates may be used to derive new motion vector candidates. For example, at a CU, a number of representative candidates may be selected (e.g., one representative candidate from each group of a CTU-level list) and for each representative candidate, one or more new motion vector candidates may be derived by determining an offset value. The one or more new candidates may added to a list of CU level candidates. For example, in one example, each representative candidate motion vector may be used as a motion vector origin and offset values may be determined according to the techniques described herein, (e.g., template or bi-lateral matching). Further, in some examples, offset values may be adjusted using an AMVR index or neighboring contexts as described above. As described above, for a motion vector, a symmetric paired motion vector may be derived by scaling the motion vector according to a POC distance. In one example, derived symmetric motion pairs may be added to the final CU-level motion candidate list.</p><p id="p-0195" num="0163">As described above, a CTU-level list of motion vector candidates may be derived and used to construct CU level motion vector candidate lists. In one example, one or more CTU-level lists of motion vector candidates may be stored in a buffer. As described above, CTU-level lists may be updated at the CU-level. Thus, in some examples, one or more CTU-level lists stored in a buffer may be updated based on CU-level list determinations. Further, in one example, one or more CTU-level lists stored in a buffer may be used for generating and/or updating a CTU-level list for a current CTU. Thus, one or more CTU-level lists stored in a buffer may be propagated according to the scanning order of CTUs. In one example, at the first CTU in each slice, the buffer storing one or more CTU-level lists may be refreshed. In one example, a CTU group level list of motion vector candidates may be derived and used to construct CTU-level lists of motion vector candidates. For example, a CTU group level list may be constructed for a plurality spatial adjacent CTUs and/or CTUs included in a structure/region included CTUs (e.g., CTUs included in a tile). One or more CTU group level lists may be stored in a buffer. As such, CTU group level lists in a buffer may be used to generate CTU-level lists.</p><p id="p-0196" num="0164">In one example, for each CU, one of a Bi-Merge mode, an E-Merge mode, or a Bi-AMVP mode may be indicated. In one example, for each CU one of a Bi-Merge mode, an E-Merge mode, or a Bi-AMVP mode may be indicated according to semantics and syntax elements based on the coding structure illustrated in <figref idref="DRAWINGS">FIG. <b>11</b>A</figref>. As described above, in some cases, Bi-AMVP may include a CI Bi-AMVP mode and a PI Bi-AMVP mode. In one example, for each CU, one of a Bi-Merge mode, an E-Merge mode, a CI Bi-AMVP mode, or a PI Bi-AMVP mode may be indicated. In one example, for each CU one of a Bi-Merge mode, an E-Merge mode, a CI Bi-AMVP mode, or a PI Bi-AMVP mode may be indicated according to semantics and syntax elements based on the coding structure illustrated in <figref idref="DRAWINGS">FIG. <b>11</b>B</figref>. It should be noted that in some examples a PI mode or a CI Bi-AMVP may be used with other combinations of inter prediction modes other than those illustrated in <figref idref="DRAWINGS">FIG. <b>11</b>B</figref>. Further, in some cases, one of a CI Bi-AMVP mode and/or or a PI Bi-AMVP may be disallowed based on coding parameters and/or video properties. In such cases, a flag indicating one of a CI Bi-AMVP mode or a PI Bi-AMVP is not signaled. In one example, if the following condition is satisfied (POC<sub>CUR</sub>&#x3e;POC<sub>0</sub>&#x26;&#x26; POC<sub>CUR</sub>&#x3e;POC<sub>1</sub>), only a PI Bi-AMVP mode is allowed, otherwise both a CI Bi-AMVP mode or a PI Bi-AMVP mode is allowed.</p><p id="p-0197" num="0165">Further, in one example, for each CU, one of an E-Merge mode or a Bi-AMVP mode may be indicated. In one example, for each CU one of an E-Merge mode or a Bi-AMVP mode may be indicated according to semantics and syntax elements based on the coding structure illustrated in <figref idref="DRAWINGS">FIG. <b>12</b></figref>. It should be noted that in some examples, one or more one of a Bi-Merge mode, an E-Merge mode, or a Bi-AMVP mode may be disallowed for a CU. For example, CTU level flags may indicate with each of Bi-Merge mode, an E-Merge mode, or a Bi-AMVP mode are allowed for CUs. Further, each of Bi-Merge mode, an E-Merge mode, or a Bi-AMVP mode may be allowed or disallowed based on the order/position of a CU within a CTU. In such cases, the example coding structures in <figref idref="DRAWINGS">FIG. <b>11</b></figref> and <figref idref="DRAWINGS">FIG. <b>12</b></figref> may be simplified according, e.g., flags corresponding to disallowed modes are not signaled.</p><p id="p-0198" num="0166">Referring again to <figref idref="DRAWINGS">FIG. <b>9</b></figref>, as illustrated in <figref idref="DRAWINGS">FIG. <b>9</b></figref>, inter prediction processing unit <b>214</b> may receive reconstructed video block via filter unit <b>216</b>, which may be part of an in-loop filtering process. Filter unit <b>216</b> may be configured to perform deblocking and/or Sample Adaptive Offset (SAO) filtering. Deblocking refers to the process of smoothing the boundaries of reconstructed video blocks (e.g., make boundaries less perceptible to a viewer). SAO filtering is a non-linear amplitude mapping that may be used to improve reconstruction by adding an offset to reconstructed video data. Entropy encoding unit <b>218</b> receives quantized transform coefficients and predictive syntax data (i.e., intra prediction data, motion prediction data, QP data, etc.). Entropy encoding unit <b>218</b> may be configured to perform entropy encoding according to one or more of the techniques described herein. Entropy encoding unit <b>218</b> may be configured to output a compliant bitstream, i.e., a bitstream that a video decoder can receive and reproduce video data therefrom. In this manner video encoder <b>200</b> represents an example of a device configured to receive a motion vector and a corresponding reference picture identifier for the motion vector, determine a reference picture corresponding to a second motion vector based on the reference picture corresponding to the received motion vector and a current picture, determine a scaling value based on the determined reference picture, the reference picture corresponding to the received motion vector, and the current picture, and generate the second motion vector by scaling the received motion vector according to the determined scaling value.</p><p id="p-0199" num="0167"><figref idref="DRAWINGS">FIG. <b>13</b></figref> is a block diagram illustrating an example of a video decoder that may be configured to decode video data according to one or more techniques of this disclosure. In one example, video decoder <b>300</b> may be configured to reconstruct video data based on one or more of the techniques described above. That is, video decoder <b>300</b> may operate in a reciprocal manner to video encoder <b>200</b> described above. Video decoder <b>300</b> may be configured to perform intra prediction decoding and inter prediction decoding and, as such, may be referred to as a hybrid decoder. In the example illustrated in <figref idref="DRAWINGS">FIG. <b>13</b></figref> video decoder <b>300</b> includes an entropy decoding unit <b>302</b>, inverse quantization unit <b>304</b>, inverse transformation processing unit <b>306</b>, intra prediction processing unit <b>308</b>, inter prediction processing unit <b>310</b>, summer <b>312</b>, filter unit <b>314</b>, and reference buffer <b>316</b>. Video decoder <b>300</b> may be configured to decode video data in a manner consistent with a video encoding system, which may implement one or more aspects of a video coding standard. It should be noted that although example video decoder <b>300</b> is illustrated as having distinct functional blocks, such an illustration is for descriptive purposes and does not limit video decoder <b>300</b> and/or sub-components thereof to a particular hardware or software architecture. Functions of video decoder <b>300</b> may be realized using any combination of hardware, firmware, and/or software implementations.</p><p id="p-0200" num="0168">As illustrated in <figref idref="DRAWINGS">FIG. <b>13</b></figref>, entropy decoding unit <b>302</b> receives an entropy encoded bitstream. Entropy decoding unit <b>302</b> may be configured to decode quantized syntax elements and quantized coefficients from the bitstream according to a process reciprocal to an entropy encoding process. Entropy decoding unit <b>302</b> may be configured to perform entropy decoding according any of the entropy coding techniques described above. Entropy decoding unit <b>302</b> may parse an encoded bitstream in a manner consistent with a video coding standard. Video decoder <b>300</b> may be configured to parse an encoded bitstream where the encoded bitstream is generated based on the techniques described above. Inverse quantization unit <b>304</b> receives quantized transform coefficients (i.e., level values) and quantization parameter data from entropy decoding unit <b>302</b>. Quantization parameter data may include any and all combinations of delta QP values and/or quantization group size values and the like described above. Video decoder <b>300</b> and/or inverse quantization unit <b>304</b> may be configured to determine QP values used for inverse quantization based on values signaled by a video encoder and/or through video properties and/or coding parameters. That is, inverse quantization unit <b>304</b> may operate in a reciprocal manner to coefficient quantization unit <b>206</b> described above. Inverse quantization unit <b>304</b> may be configured to apply an inverse quantization. Inverse transform processing unit <b>306</b> may be configured to perform an inverse transformation to generate reconstructed residual data. The techniques respectively performed by inverse quantization unit <b>304</b> and inverse transform processing unit <b>306</b> may be similar to techniques performed by inverse quantization/transform processing unit <b>208</b> described above. Inverse transform processing unit <b>306</b> may be configured to apply an inverse DCT, an inverse DST, an inverse integer transform, Non-Separable Secondary Transform (NSST), or a conceptually similar inverse transform processes to the transform coefficients in order to produce residual blocks in the pixel domain. Further, as described above, whether a particular transform (or type of particular transform) is performed may be dependent on an intra prediction mode. As illustrated in <figref idref="DRAWINGS">FIG. <b>13</b></figref>, reconstructed residual data may be provided to summer <b>312</b>. Summer <b>312</b> may add reconstructed residual data to a predictive video block and generate reconstructed video data.</p><p id="p-0201" num="0169">As describe above, a predictive video block may be determined according to a predictive video technique (i.e., intra prediction and inter frame prediction). Intra prediction processing unit <b>308</b> may be configured to receive intra prediction syntax elements and retrieve a predictive video block from reference buffer <b>316</b>. Reference buffer <b>316</b> may include a memory device configured to store one or more frames of video data. Intra prediction syntax elements may identify an intra prediction mode, such as the intra prediction modes described above. In one example, intra prediction processing unit <b>308</b> may reconstruct a video block using according to one or more of the intra prediction coding techniques described herein. Inter prediction processing unit <b>310</b> may receive inter prediction syntax elements and generate motion vectors to identify a prediction block in one or more reference frames stored in reference buffer <b>316</b>. Inter prediction processing unit <b>310</b> may produce motion compensated blocks, possibly performing interpolation based on interpolation filters. Identifiers for interpolation filters to be used for motion estimation with sub-pixel precision may be included in the syntax elements. Inter prediction processing unit <b>310</b> may use interpolation filters to calculate interpolated values for sub-integer pixels of a reference block.</p><p id="p-0202" num="0170">As described above, video decoder <b>300</b> may parse an encoded bitstream where the encoded bitstream is generated based on the techniques described above and as described above, video encoder <b>200</b> may generate a bitstream according to the motion vector prediction techniques described above. Thus, video decoder <b>300</b> may be configured to perform motion vector prediction according to techniques described above. In this manner video decoder <b>300</b> represents an example of a device configured to receive a motion vector and a corresponding reference picture identifier for the motion vector, determine a reference picture corresponding to a second motion vector based on the reference picture corresponding to the received motion vector and a current picture, determine a scaling value based on the determined reference picture, the reference picture corresponding to the received motion vector, and the current picture, and generate the second motion vector by scaling the received motion vector according to the determined scaling value.</p><p id="p-0203" num="0171">Referring again to <figref idref="DRAWINGS">FIG. <b>13</b></figref>, filter unit <b>314</b> may be configured to perform filtering on reconstructed video data. For example, filter unit <b>314</b> may be configured to perform deblocking and/or SAO filtering, as described above with respect to filter unit <b>216</b>. Further, it should be noted that in some examples, filter unit <b>314</b> may be configured to perform proprietary discretionary filter (e.g., visual enhancements). As illustrated in <figref idref="DRAWINGS">FIG. <b>13</b></figref> a reconstructed video block may be output by video decoder <b>300</b>.</p><p id="p-0204" num="0172">In one or more examples, the functions described may be implemented in hardware, software, firmware, or any combination thereof. If implemented in software, the functions may be stored on or transmitted over as one or more instructions or code on a computer-readable medium and executed by a hardware-based processing unit. Computer-readable media may include computer-readable storage media, which corresponds to a tangible medium such as data storage media, or communication media including any medium that facilitates transfer of a computer program from one place to another, e.g., according to a communication protocol. In this manner, computer-readable media generally may correspond to (1) tangible computer-readable storage media which is non-transitory or (2) a communication medium such as a signal or carrier wave. Data storage media may be any available media that can be accessed by one or more computers or one or more processors to retrieve instructions, code and/or data structures for implementation of the techniques described in this disclosure. A computer program product may include a computer-readable medium.</p><p id="p-0205" num="0173">By way of example, and not limitation, such computer-readable storage media can comprise RAM, ROM, EEPROM, CD-ROM or other optical disk storage, magnetic disk storage, or other magnetic storage devices, flash memory, or any other medium that can be used to store desired program code in the form of instructions or data structures and that can be accessed by a computer. Also, any connection is properly termed a computer-readable medium. For example, if instructions are transmitted from a website, server, or other remote source using a coaxial cable, fiber optic cable, twisted pair, digital subscriber line (DSL), or wireless technologies such as infrared, radio, and microwave, then the coaxial cable, fiber optic cable, twisted pair, DSL, or wireless technologies such as infrared, radio, and microwave are included in the definition of medium. It should be understood, however, that computer-readable storage media and data storage media do not include connections, carrier waves, signals, or other transitory media, but are instead directed to non-transitory, tangible storage media. Disk and disc, as used herein, includes compact disc (CD), laser disc, optical disc, digital versatile disc (DVD), floppy disk and Blu-ray disc where disks usually reproduce data magnetically, while discs reproduce data optically with lasers. Combinations of the above should also be included within the scope of computer-readable media.</p><p id="p-0206" num="0174">Instructions may be executed by one or more processors, such as one or more digital signal processors (DSPs), general purpose microprocessors, application specific integrated circuits (ASICs), field programmable logic arrays (FPGAs), or other equivalent integrated or discrete logic circuitry. Accordingly, the term &#x201c;processor,&#x201d; as used herein may refer to any of the foregoing structure or any other structure suitable for implementation of the techniques described herein. In addition, in some aspects, the functionality described herein may be provided within dedicated hardware and/or software modules configured for encoding and decoding, or incorporated in a combined codec. Also, the techniques could be fully implemented in one or more circuits or logic elements.</p><p id="p-0207" num="0175">The techniques of this disclosure may be implemented in a wide variety of devices or apparatuses, including a wireless handset, an integrated circuit (IC) or a set of ICs (e.g., a chip set). Various components, modules, or units are described in this disclosure to emphasize functional aspects of devices configured to perform the disclosed techniques, but do not necessarily require realization by different hardware units. Rather, as described above, various units may be combined in a codec hardware unit or provided by a collection of interoperative hardware units, including one or more processors as described above, in conjunction with suitable software and/or firmware.</p><p id="p-0208" num="0176">Moreover, each functional block or various features of the base station device and the terminal device used in each of the aforementioned embodiments may be implemented or executed by a circuitry, which is typically an integrated circuit or a plurality of integrated circuits. The circuitry designed to execute the functions described in the present specification may comprise a general-purpose processor, a digital signal processor (DSP), an application specific or general application integrated circuit (ASIC), a field programmable gate array (FPGA), or other programmable logic devices, discrete gates or transistor logic, or a discrete hardware component, or a combination thereof. The general-purpose processor may be a microprocessor, or alternatively, the processor may be a conventional processor, a controller, a microcontroller or a state machine. The general-purpose processor or each circuit described above may be configured by a digital circuit or may be configured by an analogue circuit. Further, when a technology of making into an integrated circuit superseding integrated circuits at the present time appears due to advancement of a semiconductor technology, the integrated circuit by this technology is also able to be used.</p><p id="p-0209" num="0177">Various examples have been described. These and other examples are within the scope of the following claims.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-math idrefs="MATH-US-00001" nb-file="US20230007297A1-20230105-M00001.NB"><img id="EMI-M00001" he="6.01mm" wi="76.20mm" file="US20230007297A1-20230105-M00001.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00002" nb-file="US20230007297A1-20230105-M00002.NB"><img id="EMI-M00002" he="6.01mm" wi="76.20mm" file="US20230007297A1-20230105-M00002.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00003" nb-file="US20230007297A1-20230105-M00003.NB"><img id="EMI-M00003" he="6.01mm" wi="76.20mm" file="US20230007297A1-20230105-M00003.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00004 MATH-US-00004-2" nb-file="US20230007297A1-20230105-M00004.NB"><img id="EMI-M00004" he="10.24mm" wi="76.20mm" file="US20230007297A1-20230105-M00004.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00005 MATH-US-00005-2" nb-file="US20230007297A1-20230105-M00005.NB"><img id="EMI-M00005" he="13.04mm" wi="76.20mm" file="US20230007297A1-20230105-M00005.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00006" nb-file="US20230007297A1-20230105-M00006.NB"><img id="EMI-M00006" he="6.01mm" wi="76.20mm" file="US20230007297A1-20230105-M00006.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A method of performing motion vector prediction for video data, the method comprising:<claim-text>performing bi-prediction according to a first mode of bi-prediction, wherein the first mode allows only bi-prediction;</claim-text><claim-text>for the first mode of bi-prediction, performing inter prediction by:<claim-text>inferring an index value for a first reference picture list;</claim-text><claim-text>generating a first motion vector based on a first signaled index value indicating a first motion vector predictor and a signaled value indicating a first motion vector difference value;</claim-text><claim-text>inferring an index value for a second reference picture list; and</claim-text><claim-text>generating a second motion vector based on a second signaled index value indicating a second motion vector predictor and a second motion vector difference value, wherein the second motion vector difference value is a scaled version of the first motion vector difference value, and</claim-text></claim-text><claim-text>wherein a resolution of the first motion vector difference value and the second motion vector difference value are adjusted according to a signaled motion vector difference resolution index value.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the signaled motion vector difference resolution index value indicates one of &#xbc;, 1, and 4 luma sample resolution.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. A device of performing motion vector prediction for video data, the device comprising one or more processors configured to perform steps of:<claim-text>performing bi-prediction according to a first mode of bi-prediction, wherein the first mode allows only bi-prediction;</claim-text><claim-text>for the first mode of bi-prediction, performing inter prediction by:<claim-text>inferring an index value for a first reference picture list;</claim-text><claim-text>generating a first motion vector based on a first signaled index value indicating a first motion vector predictor and a signaled value indicating a first motion vector difference value;</claim-text><claim-text>inferring an index value for a second reference picture list; and</claim-text><claim-text>generating a second motion vector based on a second signaled index value indicating a second motion vector predictor and a second motion vector difference value, wherein the second motion vector difference value is a scaled version of the first motion vector difference value, and</claim-text></claim-text><claim-text>wherein a resolution of the first motion vector difference value and the second motion vector difference value are adjusted according to a signaled motion vector difference resolution index value.</claim-text></claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The device of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the signaled motion vector difference resolution index value indicates one of &#xbc;, 1, and 4 luma sample resolution.</claim-text></claim></claims></us-patent-application>