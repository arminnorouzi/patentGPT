<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230007249A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230007249</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17902790</doc-number><date>20220902</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><priority-claims><priority-claim sequence="01" kind="national"><country>KR</country><doc-number>10-2019-0149657</doc-number><date>20191120</date></priority-claim><priority-claim sequence="02" kind="national"><country>KR</country><doc-number>10-2020-0044442</doc-number><date>20200413</date></priority-claim></priority-claims><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20140101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>119</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20140101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>46</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20140101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>174</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20140101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>176</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>119</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>46</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>174</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>176</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e79">METHOD FOR ENCODING/DECODING IMAGE SIGNAL, AND DEVICE FOR THE SAME</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>17283542</doc-number><date>20210407</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11470314</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17902790</doc-number></document-id></child-doc></relation></continuation><continuation><relation><parent-doc><document-id><country>US</country><doc-number>PCT/KR2020/016282</doc-number><date>20201118</date></document-id><parent-status>PENDING</parent-status></parent-doc><child-doc><document-id><country>US</country><doc-number>17283542</doc-number></document-id></child-doc></relation></continuation></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only"><addressbook><orgname>XRIS CORPORATION</orgname><address><city>Seongnam-si</city><country>KR</country></address></addressbook><residence><country>KR</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>LEE</last-name><first-name>Bae Keun</first-name><address><city>Seongnam-si</city><country>KR</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A video signal decoding method according to the present disclosure includes partitioning a current picture into a plurality of tiles, decoding partitioning information representing a slice type, wherein the partitioning information represents whether a rectangular slice is applied, decoding width information and height information for a first slice, decoding tile index difference value information for the first slice and determining an index of a top-left tile of a second slice based on the difference value information.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="47.24mm" wi="153.33mm" file="US20230007249A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="166.45mm" wi="156.46mm" file="US20230007249A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="149.27mm" wi="154.26mm" file="US20230007249A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="163.58mm" wi="76.88mm" file="US20230007249A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="215.22mm" wi="147.07mm" file="US20230007249A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="206.93mm" wi="150.96mm" file="US20230007249A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="220.22mm" wi="143.76mm" file="US20230007249A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="207.94mm" wi="154.43mm" file="US20230007249A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="189.99mm" wi="153.25mm" file="US20230007249A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="154.43mm" wi="153.92mm" file="US20230007249A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="195.33mm" wi="157.31mm" file="US20230007249A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="221.91mm" wi="156.21mm" file="US20230007249A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="201.76mm" wi="108.54mm" file="US20230007249A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="190.33mm" wi="154.26mm" file="US20230007249A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00014" num="00014"><img id="EMI-D00014" he="160.19mm" wi="152.48mm" file="US20230007249A1-20230105-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00015" num="00015"><img id="EMI-D00015" he="200.91mm" wi="113.28mm" file="US20230007249A1-20230105-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00016" num="00016"><img id="EMI-D00016" he="210.14mm" wi="153.08mm" file="US20230007249A1-20230105-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00017" num="00017"><img id="EMI-D00017" he="169.33mm" wi="148.84mm" file="US20230007249A1-20230105-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00018" num="00018"><img id="EMI-D00018" he="199.98mm" wi="134.45mm" file="US20230007249A1-20230105-D00018.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00019" num="00019"><img id="EMI-D00019" he="196.34mm" wi="134.28mm" file="US20230007249A1-20230105-D00019.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00020" num="00020"><img id="EMI-D00020" he="166.45mm" wi="151.21mm" file="US20230007249A1-20230105-D00020.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading><p id="p-0002" num="0001">This application is a continuation application of application Ser. No. 17/283,542, filed Apr. 7, 2021, which is a continuation of PCT International Application No. PCT/KR2020/016282, filed on Nov. 18, 2020, which claims foreign priority to Korean Patent Application No. 10-2019-0149657, filed on Nov. 20, 2019, Korean Patent Application No.: 10-2020-0044442, filed on Apr. 13, 2020, which is hereby incorporated by reference in its entirety.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">FIELD OF THE DISCLOSURE</heading><p id="p-0003" num="0002">The present disclosure relates to a video signal encoding/decoding method and a device therefor.</p><heading id="h-0003" level="1">DESCRIPTION OF THE RELATED ART</heading><p id="p-0004" num="0003">As display panels become larger, video service of higher quality is required. The biggest problem with high-definition video service is that an amount of data is greatly increased. In order to solve the above problem, research for improving the video compression rate is being actively conducted. As a representative example, the Joint Collaborative Team on Video Coding (JCT-VC) was formed in 2009 by the Motion Picture Experts Group (MPEG) and the Video Coding Experts Group (VCEG) under the International Telecommunication Union-Telecommunication (ITU-T). The JCT-VC proposed High Efficiency Video Coding (HEVC), a video compression standard that has about twice compression performance of H.264/AVC, and that was approved as standard on Jan. 25, 2013. However, with rapid development of high-definition video services, the performance of HEVC is gradually showing its limitations.</p><heading id="h-0004" level="1">DISCLOSURE</heading><heading id="h-0005" level="1">Technical purpose</heading><p id="p-0005" num="0004">A purpose of the present disclosure is to provide a method for partitioning a picture into a plurality of tiles or a plurality of slices in encoding/decoding a video signal, and a device for performing the method.</p><p id="p-0006" num="0005">A purpose of the present disclosure is to provide a method for partitioning a slice based on a tile index in partitioning a picture into a plurality of tiles, and a device for performing the method.</p><p id="p-0007" num="0006">A purpose of the present disclosure is to provide a method for partitioning a slice based on difference information with a previous slice in partitioning a picture into a plurality of slices, and a device for performing the method.</p><p id="p-0008" num="0007">Technical purposes obtainable from the present disclosure are non-limited to the above-mentioned technical purposes, and other unmentioned technical purposes may be clearly understood from the following description by those having ordinary skill in the technical field to which the present disclosure pertains.</p><heading id="h-0006" level="1">Technical Solution</heading><p id="p-0009" num="0008">A video signal decoding method according to the present disclosure includes partitioning a current picture into a plurality of tiles, decoding partitioning information representing a slice type, wherein the partitioning information represents whether a rectangular slice is applied, decoding width information and height information for a first slice, decoding tile index difference value information for the first slice and determining an index of a top-left tile of a second slice based on the difference value information. In this case, whether width information for the second slice is decoded may be determined based on a position of a top-left tile of the second slice.</p><p id="p-0010" num="0009">A video signal encoding method according to the present disclosure includes partitioning a current picture into a plurality of tiles, determining whether a rectangular slice is applied, determining a size of a first slice and a second slice, encoding width information and size information for the first slice and encoding tile index difference value information for the first slice. In this case, whether width information for the second slice will be encoded may be determined based on a position of a top-left tile of the second slice.</p><p id="p-0011" num="0010">In a video signal decoding method according to the present disclosure, when the top-left tile of the second slice is included in the rightmost tile column in the current picture, decoding of width information for the second slice may be omitted and a value thereof may be inferred to 0.</p><p id="p-0012" num="0011">In a video signal decoding method according to the present disclosure, whether the top-left tile of the second slice belongs to the rightmost tile column may be determined based on a modular operation between an index of the top-left tile and the number of tile columns in a picture.</p><p id="p-0013" num="0012">In a video signal decoding method according to the present disclosure, whether height information for the second slice is decoded may be determined based on a position of a top-left tile of the second slice.</p><p id="p-0014" num="0013">In a video signal decoding method according to the present disclosure, when the top-left tile of the second slice is included in the lowest tile row in the current picture, decoding of height information for the second slice may be omitted and a value thereof may be inferred to 0.</p><p id="p-0015" num="0014">In a video signal decoding method according to the present disclosure, whether the top-left tile of the second slice belongs to the lowest tile row may be determined based on a division operation between an index of the top-left tile and the number of tile columns in a picture.</p><p id="p-0016" num="0015">In a video signal decoding method according to the present disclosure, the tile index difference value information may represent a difference value between an index of a top-left tile of the first slice and an index of a top-left tile of the second slice.</p><p id="p-0017" num="0016">In a video signal decoding method according to the present disclosure, the tile index difference value may be obtained when a value of a tile index difference value present flag representing that the tile index difference value is encoded is true and whether the tile index difference value present flag is to be decoded or not may be determined based on the number of slices in the current picture.</p><p id="p-0018" num="0017">It is to be understood that the foregoing summarized features are exemplary aspects of the following detailed description of the present disclosure without limiting the scope of the present disclosure.</p><heading id="h-0007" level="1">Technical Effect</heading><p id="p-0019" num="0018">According to the present disclosure, encoding/decoding efficiency may be improved by partitioning a picture into a plurality of tiles or slices.</p><p id="p-0020" num="0019">According to the present disclosure, encoding/decoding efficiency may be improved by partitioning a slice based on a tile index.</p><p id="p-0021" num="0020">According to the present disclosure, encoding/decoding efficiency may be improved by partitioning a slice based on difference information with a previous slice.</p><p id="p-0022" num="0021">Effects obtainable from the present disclosure may be non-limited by the above-mentioned effect, and other unmentioned effects may be clearly understood from the following description by those having ordinary skill in the technical field to which the present disclosure pertains.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0008" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a view showing a block diagram of a video encoding device (encoder) according to an embodiment of the present disclosure;</p><p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a view showing a block diagram of a video decoding device (decoder) according to an embodiment of the present disclosure;</p><p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a view showing a basic coding tree unit according to an embodiment of the present disclosure;</p><p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a view showing various partitioning types of a coding block.</p><p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a view of an example showing an aspect of partitioning a CTU.</p><p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a flow diagram of an inter prediction method according to an embodiment of the present disclosure.</p><p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a diagram illustrating the nonlinear motion of an object.</p><p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a flow diagram of an inter-prediction method based on an affine motion according to an embodiment of the present disclosure.</p><p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a diagram illustrating affine seed vectors for each affine motion model.</p><p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a diagram illustrating affine vectors of sub-blocks in a 4-parameter motion model.</p><p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. <b>11</b></figref> is a diagram of illustrating candidate blocks used to derive a merge candidate.</p><p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. <b>12</b></figref> is a diagram to explain the update aspect of a motion information table.</p><p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. <b>13</b></figref> is a diagram to explain the update aspect of a motion information table.</p><p id="p-0036" num="0035"><figref idref="DRAWINGS">FIG. <b>14</b></figref> is a diagram showing the update aspect of a motion information table.</p><p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. <b>15</b></figref> is a diagram showing an example in which the index of a saved motion information candidate is renewed.</p><p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. <b>16</b></figref> is a diagram showing an example in which a redundancy check is performed only for a part of merge candidates.</p><p id="p-0039" num="0038"><figref idref="DRAWINGS">FIG. <b>17</b></figref> is a diagram showing an example in which a redundancy check with a specific merge candidate is omitted.</p><p id="p-0040" num="0039"><figref idref="DRAWINGS">FIG. <b>18</b></figref> is a diagram showing an example in which a candidate block included in the same merge processing region as a current block is set to be unavailable as a merge candidate.</p><p id="p-0041" num="0040"><figref idref="DRAWINGS">FIG. <b>19</b></figref> is a diagram showing an example deriving a merge candidate for a current block when a current block is included in a merge processing region.</p><p id="p-0042" num="0041"><figref idref="DRAWINGS">FIG. <b>20</b></figref> is a diagram showing a temporary motion information table.</p><p id="p-0043" num="0042"><figref idref="DRAWINGS">FIG. <b>21</b></figref> is a diagram showing an example in which a motion information table and a temporary motion information table are unified.</p><p id="p-0044" num="0043"><figref idref="DRAWINGS">FIG. <b>22</b></figref> is a flow diagram of an intra-prediction method according to an embodiment of the present disclosure.</p><p id="p-0045" num="0044"><figref idref="DRAWINGS">FIG. <b>23</b></figref> is a diagram showing intra-prediction modes.</p><p id="p-0046" num="0045"><figref idref="DRAWINGS">FIGS. <b>24</b></figref> and <figref idref="DRAWINGS">FIG. <b>25</b></figref> are a diagram showing the example of a one-dimensional array in which reference samples are arranged in a row.</p><p id="p-0047" num="0046"><figref idref="DRAWINGS">FIG. <b>26</b></figref> is a diagram illustrating an angle formed by directional intra-prediction modes with a straight line parallel to an x-axis.</p><p id="p-0048" num="0047"><figref idref="DRAWINGS">FIG. <b>27</b></figref> is a diagram showing an aspect in which a prediction sample is obtained in case that a current block has a non-square shape.</p><p id="p-0049" num="0048"><figref idref="DRAWINGS">FIG. <b>28</b></figref> is a diagram showing wide angle intra-prediction modes.</p><p id="p-0050" num="0049"><figref idref="DRAWINGS">FIG. <b>29</b></figref> is a diagram showing an example in which whether transform skip is performed is determined per sub-block.</p><p id="p-0051" num="0050"><figref idref="DRAWINGS">FIG. <b>30</b></figref> is a diagram showing an example in which sub-blocks use the same transform type.</p><p id="p-0052" num="0051"><figref idref="DRAWINGS">FIG. <b>31</b></figref> is a flow diagram showing a process of determining a blocking strength.</p><p id="p-0053" num="0052"><figref idref="DRAWINGS">FIG. <b>32</b></figref> shows predefined filter candidates.</p><p id="p-0054" num="0053"><figref idref="DRAWINGS">FIG. <b>33</b></figref> is a diagram showing a picture partitioning method according to an embodiment of the present disclosure.</p><p id="p-0055" num="0054"><figref idref="DRAWINGS">FIG. <b>34</b></figref> shows an example in which a picture is partitioned into a plurality of tiles.</p><p id="p-0056" num="0055"><figref idref="DRAWINGS">FIGS. <b>35</b> and <b>36</b></figref> are diagrams showing an example in which a slice is defined based on a raster order.</p><p id="p-0057" num="0056"><figref idref="DRAWINGS">FIG. <b>37</b></figref> is a diagram showing an example in which only a slice in a rectangular shape is allowed.</p><p id="p-0058" num="0057"><figref idref="DRAWINGS">FIG. <b>38</b></figref> is a diagram showing an example on a case in which a picture is configured with 2 slices.</p><p id="p-0059" num="0058"><figref idref="DRAWINGS">FIG. <b>39</b></figref> is a diagram illustrating a case in which the number of tile columns or tile rows in a picture is 1.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0009" level="1">DETAILED DESCRIPTION OF THE DISCLOSURE</heading><p id="p-0060" num="0059">Hereinafter, embodiments of the present disclosure will be described in detail with reference to the accompanying drawings.</p><p id="p-0061" num="0060">Image encoding and decoding is performed on a basis of a block. In an example, for a coding block, a transform block, or a prediction block, encoding/decoding processes such as transform, quantization, prediction, in-loop filtering, reconstruction, etc. may be performed.</p><p id="p-0062" num="0061">Hereinafter, an encoding/decoding target block is referred to as a &#x201c;current block&#x201d;. In an example, a current block may represent a coding block, a transform block, or a prediction block according to a current process of encoding/decoding.</p><p id="p-0063" num="0062">In addition, the term &#x201c;unit&#x201d; used in the present specification represents a basis unit for performing a specific encoding/decoding process, and a &#x201c;block&#x201d; may be understood to represent a sample array having a predetermined size. Unless otherwise stated, &#x201c;block&#x201d; and &#x201c;unit&#x201d; may be used interchangeably. In an example, in examples described later, a coding block and a coding unit may be understood to have the same meaning as each other.</p><p id="p-0064" num="0063"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is view showing a block diagram of an image encoding apparatus (encoder) according to an embodiment of the present disclosure.</p><p id="p-0065" num="0064">Referring to <figref idref="DRAWINGS">FIG. <b>1</b></figref>, an image encoding apparatus <b>100</b> may include a picture partitioning unit <b>110</b>, prediction units <b>120</b> and <b>125</b>, a transform unit <b>130</b>, a quantization unit <b>135</b>, a rearrangement unit <b>160</b>, an entropy encoding unit <b>165</b>, a dequantization unit <b>140</b>, an inverse-transform unit <b>145</b>, a filter unit <b>150</b>, and a memory <b>155</b>.</p><p id="p-0066" num="0065">Components described in <figref idref="DRAWINGS">FIG. <b>1</b></figref> are independently illustrated in order to show different characteristic functions in an image encoding apparatus, and the figure does not mean that each component is constituted by separated hardware or one software unit. That is, each component is just enumerated for convenience of explanation, at least two components of respective components may constitute one component or one component may be partitioned into a plurality of components which may perform their functions. Even an embodiment of integrating respective components and embodiment of dividing a component are also included in the scope of the present disclosure unless they are departing from the spirit of the present disclosure.</p><p id="p-0067" num="0066">Further, some components are not requisite components that perform essential functions of the present disclosure but are optional components for just improving performance. The present disclosure may be implemented with the requisite component for implementing the spirit of the present disclosure other than the component used to just improve the performance and a structure including only the requisite component other than the optional component used to just improve the performance is also included in the scope of the present disclosure.</p><p id="p-0068" num="0067">The picture partitioning unit <b>110</b> may partition an input picture into at least one processing unit. In this connection, the processing unit may be a prediction unit (PU), a transform unit (TU), or a coding unit (CU). In the picture partitioning unit <b>110</b>, a single picture may be partitioned into combinations of a plurality of coding units, prediction units, and transform units, and the picture may be encoded by selecting a combination of the coding units, the prediction units, and the transform units according to a predetermined condition (for example, cost function).</p><p id="p-0069" num="0068">For example, a single picture may be partitioned into a plurality of coding units. In order to partition a picture into coding units, a recursive tree structure such as a quad-tree structure may be used, and a coding unit that is originated from a root such as a single image or largest coding unit may be partitioned into other coding units and may have child nodes as many as the partitioned coding units. A coding unit that is no longer partitioned according to certain restrictions becomes a leaf node. Namely, when it is assumed that only square partitioning is available for a single coding unit, a single coding unit may be partitioned into at most four other coding units.</p><p id="p-0070" num="0069">Hereinafter, in the embodiment of the present disclosure, a coding unit may be used as a unit for encoding or may be used as a unit for decoding.</p><p id="p-0071" num="0070">A prediction unit may be obtained by partitioning a single coding unit into at least one square or rectangle having the same size, or a single coding unit may be partitioned into prediction units in such a manner that one prediction unit may be different from another prediction unit in a shape and/or size.</p><p id="p-0072" num="0071">In generation of a prediction unit based on a coding block to which intra-prediction is being performed, when the coding unit is not the smallest coding unit, intra-prediction may be performed without performing partitioning into a plurality of N&#xd7;N prediction units.</p><p id="p-0073" num="0072">The prediction units <b>120</b> and <b>125</b> may include an inter-prediction unit <b>120</b> performing inter-prediction and an intra prediction unit <b>125</b> performing intra-prediction. Whether to perform inter-prediction or intra-prediction on a prediction unit may be determined, and detailed information (for example, an intra-prediction mode, a motion vector, a reference picture, etc.) according to each prediction method may be determined. In this connection, a processing unit on which prediction is performed may differ with a processing unit for which a prediction method, and detail thereof are determined. For example, a prediction method, a prediction mode, etc. may be determined on the basis of a prediction unit, and prediction may be performed on the basis of a transform unit. A residual value (residual block) between the generated prediction block and an original block may be input to the transform unit <b>130</b>. In addition, prediction mode information used for prediction, motion vector information, etc. may be encoded using a residual value by the entropy encoding unit <b>165</b> and may be transmitted to the decoder. When a specific encoding mode is used, an original block is encoded as it is and transmitted to a decoding unit without generating a prediction block through the prediction unit <b>120</b> or <b>125</b>.</p><p id="p-0074" num="0073">The inter-prediction unit <b>120</b> may predict a prediction unit on the basis of information on at least one of a previous picture and a subsequent picture of a current picture, or in some cases, may predict a prediction unit on the basis of information on some encoded regions in the current picture. The inter-prediction unit <b>120</b> may include a reference picture interpolation unit, a motion prediction unit, and a motion compensation unit.</p><p id="p-0075" num="0074">The reference picture interpolation unit may receive reference picture information from the memory <b>155</b>, and generate pixel information of a pixel at an integer or less from the reference picture. In case of a luma pixel, an 8-tap DCT-based interpolation filter having different coefficients may be used so as to generate pixel information on a pixel at an integer or less for a &#xbc; pixel unit. In case of a chroma signal, a 4-tap DCT-based interpolation filter having different filter coefficients may be used so as to generate pixel information on a pixel at an integer or less for a &#x215b; pixel unit.</p><p id="p-0076" num="0075">The motion prediction unit may perform motion prediction based on a reference picture interpolated by the reference picture interpolation unit. As methods for calculating a motion vector, various methods, such as a full search-based block matching algorithm (FBMA), a three step search (TSS) algorithm, a new three-step search (NTS) algorithm, etc. may be used. A motion vector may have a motion vector value in a unit of &#xbd; or &#xbc; pixel on the basis of the interpolated pixel. The motion prediction unit may predict a current prediction unit by varying a motion prediction method. As motion prediction methods, various methods, such as a skip method, a merge method, an advanced motion vector prediction (AMVP) method, an intra block copy method, etc. may be used.</p><p id="p-0077" num="0076">The intra-prediction unit <b>125</b> may generate a prediction unit on the basis of information on a reference pixel around a current block, which is pixel information in a current picture. When a neighboring block of a current prediction unit is a block for which inter-prediction is performed, and thus a reference pixel is a pixel for which inter-prediction is performed, a reference pixel included in the block for which inter-prediction is performed may be replaced by information on a reference pixel of a neighboring block for which intra-prediction is performed. In other words, when a reference pixel is unavailable, at least one reference pixel of available reference pixels may be used in place of unavailable reference pixel information.</p><p id="p-0078" num="0077">A prediction mode in intra-prediction may include a directional prediction mode using reference pixel information according to a prediction direction and a non-directional mode not using directional information when performing prediction. A mode for predicting luma information may be different from a mode for predicting chroma information. In order to predict the chroma information, information on an intra-prediction mode used for predicting the luma information or information on a predicted luma signal may be used.</p><p id="p-0079" num="0078">In performing intra-prediction, when a prediction unit is identical in a size with a transform unit, intra-prediction may be performed on the prediction unit on the basis of pixels positioned at the left, the top-left, and the top of the prediction unit. However, in performing intra-prediction, when a prediction unit is different in a size with a transform unit, intra-prediction may be performed by using a reference pixel based on the transform unit. In addition, intra-prediction using N&#xd7;N partitioning may be only used for the smallest coding unit.</p><p id="p-0080" num="0079">In an intra-prediction method, a prediction block may be generated after applying an adaptive intra smoothing (AIS) filter to a reference pixel according to a prediction mode. A type of AIS filter applied to a reference pixel may vary. In order to perform an intra-prediction method, an intra prediction mode for a current prediction unit may be predicted from an intra-prediction mode of a prediction unit present around the current prediction unit. In predicting a prediction mode for a current prediction unit by using mode information predicted from a neighboring prediction unit, when an intra prediction mode for the current prediction unit is identical to an intra prediction mode of the neighboring prediction unit, information indicating that the current prediction unit and the neighboring prediction unit have the same prediction mode may be transmitted by using predetermined flag information. When a prediction mode for the current prediction unit is different from prediction modes of the neighboring prediction units, entropy encoding may be performed to encode information on a prediction mode for a current block.</p><p id="p-0081" num="0080">In addition, a residual block may be generated which includes information on a residual value that is a difference value between a prediction unit for which prediction is performed on by the prediction unit <b>120</b> or <b>125</b>, and an original block of the prediction unit. The generated residual block may be input to the transform unit <b>130</b>.</p><p id="p-0082" num="0081">The transform unit <b>130</b> may perform transform on a residual block, which includes information on a residual value between an original block and a prediction unit generated by the prediction unit <b>120</b> or <b>125</b>, by using a transform method such as discrete cosine transform (DCT) or discrete sine transform (DST). In this connection, a DCT transform core includes at least one of DCT2 or DCT8 and a DST transform core includes DST7. Whether to apply DCT, or DST so as to perform transform on a residual block may be determined on the basis of information on an intra-prediction mode of a prediction unit which is used to generate the residual block. It is possible to skip a transform for a residual block. A flag indicating whether or not to skip a transform for a residual block may be encoded. A transform skip may be allowed for a residual block whose a size is smaller than or equal to a threshold value, a residual block of a luma component, or a residual block of a chroma component under 4:4:4 format.</p><p id="p-0083" num="0082">The quantization unit <b>135</b> may perform quantization on values transformed into a frequency domain by the transform unit <b>130</b>. A quantization coefficient may vary according to a block or importance of an image. Values calculated in the quantization unit <b>135</b> may be provided to the dequantization unit <b>140</b> and the rearrangement unit <b>160</b>.</p><p id="p-0084" num="0083">The rearrangement unit <b>160</b> may perform rearrangement on coefficient values with respect to quantized residual values.</p><p id="p-0085" num="0084">The rearrangement unit <b>160</b> may change coefficients in the form of a two-dimensional block into coefficients in the form of a one-dimensional vector through a coefficient scanning method. For example, the rearrangement unit <b>160</b> may scan from a DC coefficient to a coefficient in a high frequency domain by using a zigzag scanning method so as to change the coefficients into the form of a one-dimensional vector. According to a size and an intra prediction mode of a transform unit, rather than zigzag scanning, vertical directional scanning where coefficients in the form of a two-dimensional block are scanned in a column direction, or horizontal directional scanning where coefficients in the form of two-dimensional block are scanned in a row direction may be used. In other words, which scanning method among zigzag scanning, vertical directional scanning, and horizontal directional scanning is used may be determined according to a size and an intra prediction mode of a transform unit.</p><p id="p-0086" num="0085">The entropy encoding unit <b>165</b> may perform entropy encoding on the basis of values calculated by the rearrangement unit <b>160</b>. Entropy encoding may use various encoding methods, for example, exponential Golomb coding, context-adaptive variable length coding (CAVLC), or context-adaptive binary arithmetic coding (CABAL).</p><p id="p-0087" num="0086">The entropy encoding unit <b>165</b> may encode various types of information, such as information on a residual value coefficient and information on a block type of a coding unit, information on a prediction mode, information on a partitioning unit, information on a prediction unit, information on a partitioning unit, information on a prediction unit and information on a transmission unit, information on a motion vector, information on a reference frame, information on a block interpolation, filtering information, etc. obtained from the rearrangement unit <b>160</b> and the prediction units <b>120</b> and <b>125</b>.</p><p id="p-0088" num="0087">The entropy encoding unit <b>165</b> may entropy encode coefficients of a coding unit input from the rearrangement unit <b>160</b>.</p><p id="p-0089" num="0088">The dequantization unit <b>140</b> may perform dequantization on values quantized in the quantization unit <b>135</b>, and the inverse-transform unit <b>145</b> may perform inverse-transform on values transformed in the transform unit <b>130</b>. A residual value generated by the dequantization unit <b>140</b> and the inverse-transform unit <b>145</b> may be added with a prediction unit predicted by a motion estimation unit, a motion compensation unit, or the intra-prediction unit which are included in the prediction units <b>120</b> and <b>125</b> so as to generate a reconstructed block.</p><p id="p-0090" num="0089">The filter unit <b>150</b> may include at least one of a deblocking filter, an offset correction unit, and an adaptive loop filter (ALF).</p><p id="p-0091" num="0090">The deblocking filter may remove block distortion that occurs due to boundaries between blocks in a reconstructed picture. In order to determine whether or not to perform deblocking, whether or not to apply a deblocking filter to a current block may be determined on the basis of pixels included in several rows and columns included in a block. When a deblocking filter is applied to a block, a strong filter or a weak filter is applied according to required deblocking filtering strength. In addition, in applying a deblocking filter, when performing horizontal directional filtering and vertical directional filtering, horizontal directional filtering and vertical directional filtering may be configured to be processed in parallel.</p><p id="p-0092" num="0091">The offset correction unit may correct an original image by an offset in a unit of a pixel with respect to an image for which deblocking is performed. In order to perform offset correction on a specific picture, a method of applying a offset to a region which is determined after partitioning pixels of the image into the predetermined number of regions, or a method of applying an offset according to edge information of each pixel may be used.</p><p id="p-0093" num="0092">Adaptive loop filtering (ALF) may be performed on the basis of a value obtained by comparing a filtered reconstructed image with an original image. Pixels included in an image may be partitioned into predetermined groups, a filter to be applied to each of the groups may be determined, and filtering may be individually performed on each group. Information on whether or not to apply ALF and may be transmitted for each coding unit (CU) for a luma signal, and a shape and a filter coefficient of an ALF filter to be applied may vary on the basis of each block. Alternatively, an ALF filter having the same shape (fixed shape) may be applied regardless of a feature of a block to which the filter will be applied.</p><p id="p-0094" num="0093">In the memory <b>155</b>, a reconstructed block or picture calculated through the filter unit <b>150</b> may be stored. The stored reconstructed block or picture may be provided to the prediction unit <b>120</b> or <b>125</b> when performing inter-prediction.</p><p id="p-0095" num="0094"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is view showing a block diagram of an image decoding apparatus (decoder) according to an embodiment of the present disclosure.</p><p id="p-0096" num="0095">Referring to <figref idref="DRAWINGS">FIG. <b>2</b></figref>, an image decoding apparatus <b>200</b> may include: an entropy decoding unit <b>210</b>, a rearrangement unit <b>215</b>, a dequantization unit <b>220</b>, an inverse-transform unit <b>225</b>, prediction units <b>230</b> and <b>235</b>, a filter unit <b>240</b>, and a memory <b>245</b>.</p><p id="p-0097" num="0096">When an image bitstream is input from the encoder, the input bitstream may be decoded according to an inverse process of the image encoding apparatus.</p><p id="p-0098" num="0097">The entropy decoding unit <b>210</b> may perform entropy decoding according to the inverse process of the entropy encoding by the entropy encoding unit of the image encoder. For example, in association with the methods performed by the image encoder apparatus, various methods, such as exponential Golomb coding, context-adaptive variable length coding (CAVLC), or context-adaptive binary arithmetic coding (CABAC) may be applied.</p><p id="p-0099" num="0098">The entropy decoding unit <b>210</b> may decode information on intra-prediction and inter-prediction performed by the encoder.</p><p id="p-0100" num="0099">The rearrangement unit <b>215</b> may perform rearrangement on the bitstream entropy decoded by the entropy decoding unit <b>210</b> on the basis of the rearrangement method used in the encoder. Coefficients represented in the form of a one-dimensional vector may be reconstructed and rearranged into coefficients in the form of a two-dimensional block. The rearrangement unit <b>215</b> may perform rearrangement through a method of receiving information related to coefficient scanning performed in the encoder and of inversely scanning on the basis of the scanning order performed in the encoder.</p><p id="p-0101" num="0100">The dequantization unit <b>220</b> may perform dequantization on the basis of a quantization parameter received from the encoder and coefficient values of the rearranged block.</p><p id="p-0102" num="0101">The inverse-transform unit <b>225</b> may perform, an inverse transform, that is inverse DCT or inverse DST, against to a transform, that is DCT or DST, performed on the quantization result by the transform unit in the image encoder. In this connection, a DCT transform core may include at least one of DCT2 or DCT8, and a DST transform core may include DST7. Alternatively, when the transform is skipped in the image encoder, the inverse-transform also not be performed in the inverse-transform unit <b>225</b>. Inverse transform may be performed on the basis of a transmission unit determined by the image encoder. The inverse transform unit <b>225</b> of the image decoder may selectively perform a transform method (for example, DCT, or DST) according to multiple pieces of information, such as a prediction method, a size of a current block, a prediction direction, etc.</p><p id="p-0103" num="0102">The prediction unit <b>230</b> or <b>235</b> may generate a prediction block on the basis of information related to a prediction block received from the entropy decoding unit <b>210</b> and information on a previously decoded block or picture received from the memory <b>245</b>.</p><p id="p-0104" num="0103">As described above, as the operation of the image encoder, in performing intra-prediction, when a prediction unit is identical in size with a transform unit, intra-prediction may be performed on the prediction unit on the basis of pixels positioned at the left, the top-left, and the top of the prediction unit. However, in performing intra-prediction, when a prediction unit is different in size with a transform unit, intra-prediction may be performed by using a reference pixel based on the transform unit. In addition, intra-prediction using N&#xd7;N partitioning may be only used for the smallest coding unit.</p><p id="p-0105" num="0104">The prediction units <b>230</b> and <b>235</b> may include a PU determination module, an inter-prediction unit, and an intra-prediction unit. The PU determination unit may receive various types of information, such as information on a prediction unit, information on a prediction mode of an intra-prediction method, information on a motion prediction of an inter-prediction method, etc. which are input from the entropy decoding unit <b>210</b>, divide a prediction unit in a current coding unit, and determine whether inter-prediction or intra-prediction is performed on the prediction unit. By using information required in inter-prediction of a current prediction unit received from the image encoder, the inter-prediction unit <b>230</b> may perform inter-prediction on the current prediction unit on the basis of information on at least one of a previous picture and a subsequent picture of a current picture including the current prediction unit. Alternatively, inter-prediction may be performed on the basis of information on some pre-reconstructed regions in a current picture including the current prediction unit.</p><p id="p-0106" num="0105">In order to perform inter-prediction, which method among a skip mode, a merge mode, an AMVP mode, or an intra block copy mode is used as a motion prediction method for a prediction unit included in a coding unit may be determined on the basis of the coding unit.</p><p id="p-0107" num="0106">The intra prediction unit <b>235</b> may generate a prediction block on the basis of information on a pixel within a current picture. When a prediction unit is a prediction unit for which intra-prediction has been performed, intra-prediction may be performed on the basis of information on an intra-prediction mode of a prediction unit received from the image encoder. The intra prediction unit <b>235</b> may include an adaptive intra smoothing (AIS) filter, a reference pixel interpolation module, or a DC filter. The AIS filter may perform filtering on a reference pixel of a current block, and whether to apply the filter may be determined according to a prediction mode for a current prediction unit. A prediction mode of the prediction unit and information on an AIS filter which are received from the image encoder may be used when performing AIS filtering on a reference pixel of a current block. When a prediction mode for the current block is a mode to which AIS filtering is not applied, the AIS filter may not be applied.</p><p id="p-0108" num="0107">When a prediction mode of a prediction unit is a prediction mode for which intra-prediction is performed on the basis of a pixel value obtained by interpolating reference pixels, the reference pixel interpolation unit may interpolate the reference pixels so as to generate a reference pixel having a unit of an integer or less. When a prediction mode for a current prediction unit is a prediction mode where a prediction block is generated without interpolating reference pixels, the reference pixels may not be interpolated. The DC filter may generate a prediction block through filtering when a prediction mode for a current block is a DC mode.</p><p id="p-0109" num="0108">A reconstructed block or picture may be provided to the filter unit <b>240</b>. The filter unit <b>240</b> may include a deblocking filter, an offset correction module, and an ALF.</p><p id="p-0110" num="0109">Information on whether or not a deblocking filter has been applied to a corresponding block or picture and information on whether a strong filter or a weak filter is applied when the deblocking filter is applied may be received from the image encoder. The deblocking filter of the image decoder may receive information on a deblocking filter from the image encoder, and the image decoder may perform deblocking filtering on a corresponding block.</p><p id="p-0111" num="0110">The offset correction unit may perform offset correction on a reconstructed image on the basis of a type of offset correction, information on an offset value, etc. applied to an image when performing encoding.</p><p id="p-0112" num="0111">The ALF may be applied to a coding unit on the basis of information on whether or not to apply ALF, information on an ALF coefficient, etc. received from the encoder. The above ALF information may be provided by being included in a particular parameter set.</p><p id="p-0113" num="0112">In the memory <b>245</b>, a reconstructed picture or block may be stored so as to be used as a reference picture or reference block, and the reconstructed picture may be provided to an output unit.</p><p id="p-0114" num="0113"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a view showing a basic coding tree unit according to an embodiment of the present disclosure.</p><p id="p-0115" num="0114">The largest coding block may be defined as a coding tree block. A single picture may be partitioned into a plurality of coding tree units (CTU). A CTU may be a coding unit of the largest size, and may be referred to as the largest coding unit (LCU). <figref idref="DRAWINGS">FIG. <b>3</b></figref> is a view showing an example where a single picture is partitioned into a plurality of CTUs.</p><p id="p-0116" num="0115">A size of a CTU may be defined in a picture level or sequence level. For the same, information representing a size of a CTU may be signaled through a picture parameter set or sequence parameter set.</p><p id="p-0117" num="0116">In an example, a size of a CTU for the entire picture within a sequence may be set to 128&#xd7;128. Alternatively, any one of 128&#xd7;128 or 256&#xd7;256 may be determined as a size of a CTU in a picture level. In an example, a CTU may be set to have a size of 128&#xd7;128 in a first picture, and a size of 256&#xd7;256 in a second picture.</p><p id="p-0118" num="0117">Coding blocks may be generated by partitioning a CTU. A coding block represents a basic unit for performing encoding/decoding. In an example, prediction or transform may be performed for each coding block, or a prediction encoding mode may be determined for each coding block. In this connection, the prediction encoding mode represents a method of generating a prediction image. In an example, a prediction encoding mode may include intra-prediction, inter-prediction, current picture referencing (CPR), intra block copy (IBC) or combined prediction. For a coding block, a prediction block of the coding block may be generated by using a prediction encoding mode of at least one of intra-prediction, inter-prediction, current picture referencing, or combined prediction.</p><p id="p-0119" num="0118">Information representing a prediction encoding mode for a current block may be signaled in a bitstream. In an example, the information may be a 1-bit flag representing whether a prediction encoding mode is an intra mode or an inter mode. When a prediction encoding mode for a current block is determined as an inter mode, current picture referencing or combined prediction may be available.</p><p id="p-0120" num="0119">Current picture referencing is setting a current picture as a reference picture and obtaining a prediction block of a current block from a region that has been already encoded/decoded within a current picture. In this connection, the current picture means a picture including the current block. Information representing whether or not current picture referencing is applied to a current block may be signaled in a bitstream. In an example, the information may be a 1-bit flag. When the flag is TRUE, a prediction encoding mode for a current block may be determined as current picture referencing, and when the flag is FALSE, a prediction encoding mode for a current block may be determined as inter-prediction.</p><p id="p-0121" num="0120">Alternatively, a prediction encoding mode for a current block may be determined on the basis of a reference picture index. In an example, when a reference picture index indicates a current picture, a prediction encoding mode for a current block may be determined as current picture referencing. When a reference picture index indicates a picture other than a current picture, a prediction encoding mode for a current block may be determined as inter-prediction. In other words, current picture referencing is a prediction method using information on a region that has been already encoded/decoded within a current picture, and inter-prediction is a prediction method using information on another picture that has been already encoded/decoded.</p><p id="p-0122" num="0121">Combined prediction represents a combined encoding mode combining at least two of intra-prediction, inter-prediction, and current picture referencing. In an example, when combined prediction is applied, a first prediction block may be generated on the basis of any one of intra-prediction, inter-prediction or current picture referencing, and a second prediction block may be generated on the basis of another. When a first prediction block and a second prediction block are generated, a final prediction block may be generated by calculating an average or weighted sum of the first prediction block and the second prediction block. Information representing whether or not to apply combined prediction to a current block may be signaled in a bitstream. The information may be a 1-bit flag.</p><p id="p-0123" num="0122"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a view showing various partitioning types a coding block.</p><p id="p-0124" num="0123">A coding block may be partitioned into a plurality of coding blocks on the basis of quad-tree partitioning, binary-tree partitioning or ternary tree partitioning. The partitioned coding block may be partitioned again into a plurality of coding blocks on the basis of quad-tree partitioning, binary-tree partitioning or ternary tree partitioning.</p><p id="p-0125" num="0124">Quad-tree partitioning represents a method of partitioning a current block into four blocks. As a result of quad-tree partitioning, a current block may be partitioned into four square partitions (refer to &#x201c;SPLIT_QT&#x201d; of <figref idref="DRAWINGS">FIG. <b>4</b>(<i>a</i>)</figref>).</p><p id="p-0126" num="0125">Binary-tree partitioning represents a method of partitioning a current block into two blocks. Partitioning a current block into two blocks along a vertical direction (that is, using a vertical line across the current block) may be referred to vertical directional binary-tree partitioning, and partitioning a current block into two blocks along a horizontal direction (that is, using a horizontal line across the current block) may be referred to as horizontal directional binary-tree partitioning. As a result of binary-tree partitioning, a current block may be partitioned into two non-square partitions. &#x201c;SPLIT_BT_VER&#x201d; of <figref idref="DRAWINGS">FIG. <b>4</b>(<i>b</i>)</figref> is a view showing a result of vertical directional binary-tree partitioning, and &#x201c;SPLIT_BT_HOR&#x201d; of <figref idref="DRAWINGS">FIG. <b>4</b>(<i>c</i>)</figref> is a view showing a result of horizontal directional binary-tree partitioning.</p><p id="p-0127" num="0126">Ternary-tree partitioning represents a method of partitioning a current block into three blocks. Partitioning a current block into three blocks along a vertical direction (that is, using two vertical lines across the current block) may be referred to vertical directional ternary-tree partitioning, and partitioning a current block into three blocks along a horizontal direction (that is, using two horizontal lines across the current block) may be referred to as horizontal directional ternary-tree partitioning. As a result of ternary-tree partitioning, a current block may be partitioned into three non-square partitions. In this connection, a width/height of a partition positioned at the center of a current block may be twice than a width/height of other partitions. &#x201c;SPLIT_TT_VER&#x201d; of <figref idref="DRAWINGS">FIG. <b>4</b>(<i>d</i>)</figref> is a view showing a result of vertical directional ternary-tree partitioning, and &#x201c;SPLIT_TT_HOR&#x201d; of <figref idref="DRAWINGS">FIG. <b>4</b>(<i>e</i>)</figref> is a view showing a result of horizontal directional ternary-tree partitioning.</p><p id="p-0128" num="0127">The number of partitioning times of a CTU may be defined as a partitioning depth. The maximum partitioning depth of a CTU may be determined in a sequence or picture level. Accordingly, the maximum partitioning depth of a CTU may vary on the basis of a sequence or picture.</p><p id="p-0129" num="0128">Alternatively, the maximum partitioning depth may be independently determined for each partitioning method. In an example, the maximum partitioning depth where quad-tree partitioning is allowed may differ from the maximum partitioning depth where binary-tree partitioning and/or ternary-tree partitioning is allowed.</p><p id="p-0130" num="0129">The encoder may signal information representing at least one of a partitioning type and a partitioning depth of a current block in a bitstream. The decoder may determine a partitioning type and a partitioning depth of a CTU on the basis of the information obtained by parsing a bitstream.</p><p id="p-0131" num="0130"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a view of an example showing an aspect of partitioning a CTU.</p><p id="p-0132" num="0131">Partitioning a coding block by using quad-tree partitioning, binary-tree partitioning and/or ternary-tree partitioning may be referred to as multi-tree partitioning.</p><p id="p-0133" num="0132">Coding blocks generated by partitioning a coding block by applying multi-tree partitioning may be referred to child coding blocks. When a partitioning depth of a coding block is k, a partitioning depth of child coding blocks is set to k+1.</p><p id="p-0134" num="0133">To the contrary, for coding blocks having a partitioning depth of k+1, a coding block having a partitioning depth of k may be referred to as a parent coding block.</p><p id="p-0135" num="0134">A partitioning type of a current coding block may be determined on the basis of at least one of a partitioning type of a parent coding block and a partitioning type of a neighboring coding block. In this connection, the neighboring coding block may be a block adjacent to a current coding block, and include at least one of an top neighboring block, a left neighboring block, or a neighboring block adjacent to the top-left corner of the current coding block. In this connection, the partitioning type may include whether or not to apply quad-tree partitioning, whether or not to apply binary-tree partitioning, a direction of binary-tree partitioning, whether or not to apply ternary-tree partitioning, or a direction of ternary-tree partitioning.</p><p id="p-0136" num="0135">In order to determine a partitioning type of a coding block, information representing whether or not a coding block is partitioned may be signaled in a bitstream. The information is a 1-bit flag of &#x201c;split_cu_flag&#x201d;, and when the flag is TRUE, it may represent that a coding block is partitioned by a multi tree partitioning method.</p><p id="p-0137" num="0136">When split_cu_flag is TRUE, information representing whether or not a coding block is partitioned by quad-tree partitioning may be signaled in a bitstream. The information is a 1-bit flag of split_qt_flag, and when the flag is TRUE, a coding block may be partitioned into four blocks.</p><p id="p-0138" num="0137">In an example, in an example shown in <figref idref="DRAWINGS">FIG. <b>5</b></figref>, a CTU is partitioned by quad-tree partitioning, and thus four coding blocks having a partitioning depth of 1 are generated. In addition, it is shown that quad-tree partitioning is applied again to the first coding block and the fourth coding block among four coding blocks generated by quad-tree partitioning. As a result, four coding blocks having a partitioning depth of 2 may be generated.</p><p id="p-0139" num="0138">In addition, by applying again quad-tree partitioning to a coding block having a partitioning depth of 2, a coding block having a partitioning depth of 3 may be generated.</p><p id="p-0140" num="0139">When quad-tree partitioning is not applied to a coding block, whether to perform binary-tree partitioning or ternary-tree partitioning for the coding block may be determined according to at least one of a size of the coding block, whether or not the coding block is positioned at a picture boundary, the maximum partitioning depth, or a partitioning type of a neighboring block. When it is determined to perform binary-tree partitioning or ternary-tree partitioning for the coding block, information representing a partitioning direction may be signaled in a bitstream. The information may be a 1-bit flag of mtt_split_cu_vertical_flag. Whether a partitioning direction is a vertical direction or a horizontal direction may be determined on the basis of the flag. Additionally, information representing which one of binary-tree partitioning or ternary-tree partitioning is applied to the coding block may be signaled in a bitstream. The information may be a 1-bit flag of mtt_split_cu_binary_flag. Whether binary-tree partitioning is applied to the coding block or ternary-tree partitioning is applied to the coding block may be determined on the basis of the flag.</p><p id="p-0141" num="0140">In an example, in an example shown in <figref idref="DRAWINGS">FIG. <b>5</b></figref>, vertical directional binary-tree partitioning is applied to a coding block having a partitioning depth of 1, vertical directional ternary-tree partitioning is applied to a left coding block among coding blocks generated by the partitioning, and vertical directional binary-tree partitioning is applied to a right coding block.</p><p id="p-0142" num="0141">Inter-prediction is a prediction encoding mode predicting a current block by using information on a previous picture. In an example, a block (hereinafter, collocated block) at the same position with a current block within a previous picture may be set as a prediction block of the current block. Hereinafter, a prediction block generated on the basis of a collocated block of the current block may be referred to as a collocated prediction block.</p><p id="p-0143" num="0142">To the contrary, when an object present in a previous picture has moved to another position in a current picture, a current block may be effectively predicted by using motions of the object. For example, when a motion direction and a size of the object is determined by comparing a previous picture with a current picture, a prediction block (or prediction image) of the current block may be generated according to motion information of the objects. Hereinafter, a prediction block generated by using motion information may be referred to as a motion prediction block.</p><p id="p-0144" num="0143">A residual block may be generated by subtracting a prediction block from a current block. In this connection, in case where an object moves, energy of a residual block may be reduced by using a motion prediction block rather than using a collocated prediction block, and thus compression performance of the residual block may be improved.</p><p id="p-0145" num="0144">As above, generating a prediction block by using motion information may be referred to as motion estimation prediction. In the most inter-prediction, a prediction block may be generated on the basis of motion compensation prediction.</p><p id="p-0146" num="0145">Motion information may include at least one of a motion vector, a reference picture index, a prediction direction, and a bidirectional weighting factor index. A motion vector represents a motion direction of an object and a magnitude. A reference picture index specifies a reference picture of a current block among reference pictures included in a reference picture list. A prediction direction indicates any one of uni-directional L0 prediction, uni-directional L1 prediction, or bi-directional prediction (L0 prediction and L1 prediction). At least one of L0 directional motion information and L1 directional motion information may be used according to a prediction direction of a current block. A bidirectional weighting factor index specifies a weighting factor applied to an L0 prediction block and a weighting factor applied to an L1 prediction block.</p><p id="p-0147" num="0146"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a flow diagram of an inter-prediction method according to the embodiment of the present disclosure.</p><p id="p-0148" num="0147">In reference to <figref idref="DRAWINGS">FIG. <b>6</b></figref>, an inter-prediction method includes determining an inter-prediction mode for a current block (S<b>601</b>), obtaining motion information of the current block according to the determined inter-prediction mode (S<b>602</b>), and performing motion compensation prediction for a current block on the basis of the obtained motion information (S<b>603</b>).</p><p id="p-0149" num="0148">In this connection, the inter-prediction mode may represent various methods for determining motion information of a current block, and include an inter-prediction mode using translation motion information, an inter-prediction mode using affine motion information. In an example, an inter-prediction mode using translation motion information may include a merge mode and a motion vector prediction mode, and an inter-prediction mode using affine motion information may include an affine merge mode and an affine motion vector prediction mode. Motion information on a current block may be determined on the basis of a neighboring block neighboring the current block or information obtained by parsing a bitstream. Motion information of a current block may be derived from motion information of another block. In this connection, another block may be a block encoded/decoded by inter prediction previous to the current block. Setting motion information of a current block to be the same as motion information of another block may be defined as a merge mode. Also, setting a motion vector of another block as a prediction value of a motion vector of the current block may be defined as a motion vector prediction mode.</p><p id="p-0150" num="0149">Hereinafter, an inter-prediction method using affine motion information is described in detail.</p><p id="p-0151" num="0150"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a diagram illustrating a non-linear motion of an object.</p><p id="p-0152" num="0151">In a video, a non-linear motion of an object may occur. In an example, as in an example shown in <figref idref="DRAWINGS">FIG. <b>7</b></figref>, a non-linear motion of an object may occur such as camera zoom-in, zoom-out, rotation or affine transform, etc. For the nonlinear motion of the object, a translation motion vector may not effectively express the motion of the object. Accordingly, for a region in which the non-linear motion of the object is occur, encoding efficiency may be improved by using affine motion, instead of translation motion.</p><p id="p-0153" num="0152"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a flow diagram of an inter-prediction method based on an affine motion according to an embodiment of the present disclosure.</p><p id="p-0154" num="0153">Whether an inter-prediction method based on an affine motion is applied to a current block may be determined based on information parsed from a bitstream. Concretely, based on at least one of a flag indicating whether an affine merge mode is applied to a current block or a flag indicating whether an affine motion vector prediction mode is applied to a current block, whether an inter-prediction method based on an affine motion is applied to a current block will be determined.</p><p id="p-0155" num="0154">When an inter-prediction method based on an affine motion is applied to a current block, an affine motion model for the current block may be determined S<b>801</b>. An affine motion model may be determined as at least one of a 6-parameter affine motion model or a 4-parameter affine motion model. The 6-parameter affine motion model expresses an affine motion by using 6 parameters and the 4-parameter affine motion model expresses an affine motion by using 4 parameters.</p><p id="p-0156" num="0155">Equation 1 expresses an affine motion by using 6 parameters. An affine motion represents translation motion for a predetermined region determined by affine seed vectors.</p><p id="p-0157" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>v</i><sub>x</sub><i>=ax&#x2212;by+e </i><?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0158" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>v</i><sub>y</sub><i>=cx+dy+j </i>&#x2003;&#x2003;[Equation 1]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0159" num="0156">In case of expressing an affine motion by using 6 parameters, complicated motion may be expressed, but encoding efficiency may be reduced as more bits are needed to encode each parameter. Accordingly, an affine motion may be expressed by using 4 parameters. Equation 2 expresses an affine motion by using 4 parameters.</p><p id="p-0160" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>v</i><sub>x</sub><i>=ax&#x2212;by+e </i><?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0161" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>v</i><sub>y</sub><i>=bx+ay+j </i>&#x2003;&#x2003;[Equation 2]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0162" num="0157">Information for determining an affine motion model of a current block may be encoded and signaled in a bitstream. In an example, the information may be a 1-bit flag, &#x2018;affine_type_flag&#x2019;. If the value of the flag is 0, it may represent that a 4-parameter affine motion model is applied and if the value of the flag is 1, it may represent that a 6-parameter affine motion model is applied. The flag may be encoded in a unit of a slice, a tile, or a block (e.g. a coding block or a coding tree unit). When a flag is signaled at a slice level, an affine motion model determined at the slice level may be applied to all blocks belonging to the slice.</p><p id="p-0163" num="0158">Alternatively, based on an affine inter-prediction mode of a current block, an affine motion model of the current block may be determined. In an example, when an affine merge mode is applied, an affine motion model of a current block may be determined as a 4-parameter motion model. On the other hand, when an affine motion vector prediction mode is applied, information for determining an affine motion model of a current block may be encoded and signaled in a bitstream. In an example, when an affine motion vector prediction mode is applied to a current block, an affine motion model of the current block may be determined based on a 1-bit flag, &#x2018;affine_type_flag&#x2019;.</p><p id="p-0164" num="0159">Next, affine seed vectors of a current block may be derived S<b>802</b>. When a 4-parameter affine motion model is selected, motion vectors at two control points for a current block may be derived. On the other hand, when a 6-parameter affine motion model is selected, motion vectors at three control points for a current block may be derived. A motion vector at a control point may be referred to as an affine seed vector. A control point may include at least one of a left-top corner, a right-top corner or a left-bottom corner of a current block.</p><p id="p-0165" num="0160"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a diagram illustrating affine seed vectors for each affine motion model.</p><p id="p-0166" num="0161">In a 4-parameter affine motion model, affine seed vectors for two among a left-top corner, a right-top corner or a left-bottom corner may be derived. In an example, as in an example shown in <figref idref="DRAWINGS">FIG. <b>9</b>(<i>a</i>)</figref>, when a 4-parameter affine motion model is selected, an affine vector may be derived by using an affine seed vector sv<b>0</b> for a left-top corner of a current block (e.g. a left-top sample (x<b>1</b>, y<b>1</b>)) and an affine seed vector sv<b>1</b> for a right-top corner of the current block (e.g. a right-top sample (x<b>1</b>, y<b>1</b>)). It is possible to use an affine seed vector for a left-bottom corner instead of the affine seed vector for the left-top corner or use an affine seed vector for a left-bottom corner instead of the affine seed vector for the right-top corner.</p><p id="p-0167" num="0162">In a 6-parameter affine motion model, affine seed vectors for a left-top corner, a right-top corner and a left-bottom corner may be derived. In an example, as in an example shown in the <figref idref="DRAWINGS">FIG. <b>9</b>(<i>b</i>)</figref>, when a 6-parameter affine motion model is selected, an affine vector may be derived by using an affine seed vector sv<b>0</b> for a left-top corner of a current block (e.g. a left-top sample (x<b>1</b>, y<b>1</b>)), an affine seed vector sv<b>1</b> for a right-top corner of the current block (e.g. a right-top sample (x<b>1</b>, y<b>1</b>)) and an affine seed vector sv<b>2</b> for a left-top corner of the current block (e.g. a left-top sample (x<b>2</b>, y<b>2</b>)).</p><p id="p-0168" num="0163">In an embodiment described later, under a 4-parameter affine motion model, affine seed vectors at a left-top control point and a right-top control point are referred to as a first affine seed vector and a second affine seed vector, respectively. In embodiments described later which use the first affine seed vector and the second affine seed vector, at least one of the first affine seed vector and the second affine seed vector may be replaced with an affine seed vector at a left-bottom control point (a third affine seed vector) or an affine seed vector at a right-bottom control point (a fourth affine seed vector).</p><p id="p-0169" num="0164">In addition, under a 6-parameter affine motion model, affine seed vectors at a left-top control point, a right-top control point and a left-bottom control point are referred to as a first affine seed vector, a second affine seed vector and a third affine seed vector, respectively. In embodiments described later which use the first affine seed vector, the second affine seed vector and the third affine seed vector, at least one of the first affine seed vector, the second affine seed vector and the third affine seed vector may be replaced with an affine seed vector at a right-bottom control point (a fourth affine seed vector).</p><p id="p-0170" num="0165">An affine vector may be derived per sub-block by using affine seed vectors S<b>803</b>. In this connection, the affine vector represents a translation motion vector derived based on the affine seed vectors. An affine vector of a sub-block can be referred to as an affine sub-block motion vector or a sub-block motion vector.</p><p id="p-0171" num="0166"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a diagram illustrating affine vectors of sub-blocks under a 4-parameter motion model.</p><p id="p-0172" num="0167">An affine vector of a sub-block may be derived based on a position of a control point, a position of the sub-block and an affine seed vector. In an example, Equation 3 represents an example of deriving an affine sub-block motion vector.</p><p id="p-0173" num="0000"><maths id="MATH-US-00001" num="00001"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mrow>      <msub>       <mi>v</mi>       <mi>x</mi>      </msub>      <mo>=</mo>      <mrow>       <mrow>        <mfrac>         <mrow>          <mo>(</mo>          <mrow>           <msub>            <mi>sv</mi>            <mrow>             <mn>1</mn>             <mo>&#x2062;</mo>             <mi>x</mi>            </mrow>           </msub>           <mo>-</mo>           <msub>            <mi>sv</mi>            <mrow>             <mn>0</mn>             <mo>&#x2062;</mo>             <mi>x</mi>            </mrow>           </msub>          </mrow>          <mo>)</mo>         </mrow>         <mrow>          <mo>(</mo>          <mrow>           <msub>            <mi>x</mi>            <mn>1</mn>           </msub>           <mo>-</mo>           <msub>            <mi>x</mi>            <mn>0</mn>           </msub>          </mrow>          <mo>)</mo>         </mrow>        </mfrac>        <mo>&#x2062;</mo>        <mrow>         <mo>(</mo>         <mrow>          <mi>x</mi>          <mo>-</mo>          <msub>           <mi>x</mi>           <mn>0</mn>          </msub>         </mrow>         <mo>)</mo>        </mrow>       </mrow>       <mo>-</mo>       <mrow>        <mfrac>         <mrow>          <mo>(</mo>          <mrow>           <msub>            <mi>sv</mi>            <mrow>             <mn>1</mn>             <mo>&#x2062;</mo>             <mi>y</mi>            </mrow>           </msub>           <mo>-</mo>           <msub>            <mi>sv</mi>            <mrow>             <mn>0</mn>             <mo>&#x2062;</mo>             <mi>y</mi>            </mrow>           </msub>          </mrow>          <mo>)</mo>         </mrow>         <mrow>          <mo>(</mo>          <mrow>           <msub>            <mi>x</mi>            <mn>1</mn>           </msub>           <mo>-</mo>           <msub>            <mi>x</mi>            <mn>0</mn>           </msub>          </mrow>          <mo>)</mo>         </mrow>        </mfrac>        <mo>&#x2062;</mo>        <mrow>         <mo>(</mo>         <mrow>          <mi>y</mi>          <mo>-</mo>          <msub>           <mi>y</mi>           <mn>0</mn>          </msub>         </mrow>         <mo>)</mo>        </mrow>       </mrow>       <mo>+</mo>       <msub>        <mi>sv</mi>        <mrow>         <mn>0</mn>         <mo>&#x2062;</mo>         <mi>x</mi>        </mrow>       </msub>      </mrow>     </mrow>     <mo>&#x2062;</mo>     <mspace linebreak="newline"/>     <mrow>      <msub>       <mi>v</mi>       <mi>y</mi>      </msub>      <mo>=</mo>      <mrow>       <mrow>        <mfrac>         <mrow>          <mo>(</mo>          <mrow>           <msub>            <mi>sv</mi>            <mrow>             <mn>1</mn>             <mo>&#x2062;</mo>             <mi>y</mi>            </mrow>           </msub>           <mo>-</mo>           <msub>            <mi>sv</mi>            <mrow>             <mn>0</mn>             <mo>&#x2062;</mo>             <mi>y</mi>            </mrow>           </msub>          </mrow>          <mo>)</mo>         </mrow>         <mrow>          <mo>(</mo>          <mrow>           <msub>            <mi>x</mi>            <mn>1</mn>           </msub>           <mo>-</mo>           <msub>            <mi>x</mi>            <mn>0</mn>           </msub>          </mrow>          <mo>)</mo>         </mrow>        </mfrac>        <mo>&#x2062;</mo>        <mrow>         <mo>(</mo>         <mrow>          <mi>x</mi>          <mo>-</mo>          <msub>           <mi>x</mi>           <mn>0</mn>          </msub>         </mrow>         <mo>)</mo>        </mrow>       </mrow>       <mo>-</mo>       <mrow>        <mfrac>         <mrow>          <mo>(</mo>          <mrow>           <msub>            <mi>sv</mi>            <mrow>             <mn>1</mn>             <mo>&#x2062;</mo>             <mi>x</mi>            </mrow>           </msub>           <mo>-</mo>           <msub>            <mi>sv</mi>            <mrow>             <mn>0</mn>             <mo>&#x2062;</mo>             <mi>x</mi>            </mrow>           </msub>          </mrow>          <mo>)</mo>         </mrow>         <mrow>          <mo>(</mo>          <mrow>           <msub>            <mi>x</mi>            <mn>1</mn>           </msub>           <mo>-</mo>           <msub>            <mi>x</mi>            <mn>0</mn>           </msub>          </mrow>          <mo>)</mo>         </mrow>        </mfrac>        <mo>&#x2062;</mo>        <mrow>         <mo>(</mo>         <mrow>          <mi>y</mi>          <mo>-</mo>          <msub>           <mi>y</mi>           <mn>0</mn>          </msub>         </mrow>         <mo>)</mo>        </mrow>       </mrow>       <mo>+</mo>       <msub>        <mi>sv</mi>        <mrow>         <mn>0</mn>         <mo>&#x2062;</mo>         <mi>y</mi>        </mrow>       </msub>      </mrow>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>[</mo>     <mrow>      <mi>Equation</mi>      <mo>&#x2062;</mo>      <mtext>   </mtext>      <mn>3</mn>     </mrow>     <mo>]</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0174" num="0168">In the Equation 3, (x, y) represents a position of a sub-block. In this connection, the position of the sub-block represents a position of a base sample included in the sub-block. The base sample may be a sample positioned at a left-top corner of the sub-block or a sample that at least one of an x-axis or y-axis coordinate is at a central position. (x<b>0</b>, y<b>0</b>) represents a position of a first control point and (sv<b>0</b><i>x, </i>sv<b>0</b><i>y</i>) represents a first affine seed vector. In addition, (x<b>1</b>, y<b>1</b>) represents a position of a second control point and (sv<b>1</b><i>x, </i>sv<b>1</b><i>y</i>) represents a second affine seed vector.</p><p id="p-0175" num="0169">When the first control point and the second control point correspond to a left-top corner and a right-top corner of a current block, respectively, x<b>1</b>-x<b>0</b> may be set as a value identical to a width of the current block.</p><p id="p-0176" num="0170">After that, motion compensation prediction for each sub-block may be performed by using an affine vector of each sub-block S<b>804</b>. As a result of performing motion compensation prediction, a prediction block for each sub-block may be generated. The prediction blocks of sub-blocks may be set as a prediction block of a current block.</p><p id="p-0177" num="0171">An affine seed vector of a current block may be derived based on an affine seed vector of a neighboring block neighboring the current block. When an inter-prediction mode of a current block is an affine merge mode, an affine seed vector of a merge candidate included in a merge candidate list may be determined as an affine seed vector of the current block. In addition, when the inter-prediction mode of the current block is the affine merge mode, motion information including at least one of the reference picture index, a specific directional prediction flag or a bidirectional weight of the current block may be also set the same as the merge candidate.</p><p id="p-0178" num="0172">Next, an inter-prediction method using translation motion information will be described in detail.</p><p id="p-0179" num="0173">Motion information of a current block may be derived from motion information of another block. In this connection, another block may be a block encoded/decoded by inter prediction previous to the current block. Setting motion information of a current block to be the same as motion information of another block may be defined as a merge mode. Also, setting a motion vector of another block as a prediction value of a motion vector of the current block may be defined as a motion vector prediction mode.</p><p id="p-0180" num="0174"><figref idref="DRAWINGS">FIG. <b>11</b></figref> is a flow diagram of a process deriving the motion information of a current block under a merge mode.</p><p id="p-0181" num="0175">The merge candidate of a current block may be derived S<b>1101</b>. The merge candidate of a current block may be derived from a block encoded/decoded by inter-prediction prior to a current block.</p><p id="p-0182" num="0176"><figref idref="DRAWINGS">FIG. <b>12</b></figref> is a diagram illustrating candidate blocks used to derive a merge candidate.</p><p id="p-0183" num="0177">The candidate blocks may include at least one of neighboring blocks including a sample adjacent to a current block or non-neighboring blocks including a sample non-adjacent to a current block. Hereinafter, samples determining candidate blocks are defined as base samples. In addition, a base sample adjacent to a current block is referred to as a neighboring base sample and a base sample non-adjacent to a current block is referred to as a non-neighboring base sample.</p><p id="p-0184" num="0178">A neighboring base sample may be included in a neighboring column of a leftmost column of a current block or a neighboring row of an uppermost row of a current block. In an example, when the coordinate of a left-top sample of a current block is (0,0), at least one of a block including a base sample at a position of (&#x2212;1, H&#x2212;1), (W&#x2212;1, &#x2212;1), (W, &#x2212;1), (&#x2212;1, H) or (&#x2212;1, 1) may be used as a candidate block. In reference to a diagram, the neighboring blocks of index 0 to 4 may be used as candidate blocks.</p><p id="p-0185" num="0179">A non-neighboring base sample represents a sample that at least one of an x-axis distance or a y-axis distance with a base sample adjacent to a current block has a predefined value. In an example, at least one of a block including a base sample that an x-axis distance with a left base sample is a predefined value, a block including a non-neighboring sample that a y-axis distance with a top base sample is a predefined value or a block including a non-neighboring sample that a x-axis distance and a y-axis distance with a left-top base sample are a predefined value may be used as a candidate block. A predefined value may be a natural number such as 4, 8, 12, 16, etc. In reference to a diagram, at least one of blocks in an index 5 to 26 may be used as a candidate block.</p><p id="p-0186" num="0180">A sample not positioned on the same vertical line, horizontal line or diagonal line as a neighboring base sample may be set as a non-neighboring base sample.</p><p id="p-0187" num="0181">The motion information of a merge candidate may be set the same as the motion information of a candidate block. In an example, at least one of a motion vector, a reference picture index, a prediction direction or a bidirectional weight index of a candidate block may be set as the motion information of a merge candidate.</p><p id="p-0188" num="0182">A merge candidate list including a merge candidate may be generated S<b>1102</b>.</p><p id="p-0189" num="0183">The index of merge candidates in a merge candidate list may be assigned according to the predetermined order. In an example, an index may be assigned in the order of a merge candidate derived from a left neighboring block, a merge candidate derived from a top neighboring block, a merge candidate derived from a right-top neighboring block, a merge candidate derived from a left-bottom neighboring block, a merge candidate derived from a left-top neighboring block and a merge candidate derived from a temporal neighboring block.</p><p id="p-0190" num="0184">When a plurality of merge candidates are included in a merge candidate, at least one of a plurality of merge candidates may be selected S<b>1103</b>. Concretely, information for specifying any one of a plurality of merge candidates may be signaled in a bitstream. In an example, information, merge_idx, representing an index of any one of merge candidates included in a merge candidate list may be signaled in a bitstream.</p><p id="p-0191" num="0185">When the number of merge candidates included in a merge candidate list is less than the threshold, a motion information candidate included in a motion information table may be added to a merge candidate list as a merge candidate. In this connection, the threshold may be the maximum number of merge candidates which may be included in a merge candidate list or a value in which an offset is subtracted from the maximum number of merge candidates. An offset may be a natural number such as 1 or 2, etc.</p><p id="p-0192" num="0186">A motion information table includes a motion information candidate derived from a block encoded/decoded based on inter-prediction in a current picture. In an example, the motion information of a motion information candidate included in a motion information table may be set the same as the motion information of a block encoded/decoded based on inter-prediction. In this connection, motion information may include at least one of a motion vector, a reference picture index, a prediction direction or a bidirectional weight index.</p><p id="p-0193" num="0187">A motion information candidate included in a motion information table also can be referred to as a inter region merge candidate or a prediction region merge candidate.</p><p id="p-0194" num="0188">The maximum number of a motion information candidate which may be included in a motion information table may be predefined in an encoder and a decoder. In an example, the maximum number of a motion information candidate which may be included in a motion information table may be 1, 2, 3, 4, 5, 6, 7, 8 or more (e.g. 16).</p><p id="p-0195" num="0189">Alternatively, information representing the maximum number of a motion information candidate which may be included in a motion information table may be signaled in a bitstream. The information may be signaled in a sequence, a picture or a slice level. The information may represent the maximum number of a motion information candidate which may be included in a motion information table. Alternatively, the information may represent difference between the maximum number of a motion information candidate which may be included in a motion information table and the maximum number of a merge candidate which may be included in a merge candidate list.</p><p id="p-0196" num="0190">Alternatively, the maximum number of a motion information candidate which may be included in a motion information table may be determined according to a picture size, a slice size or a coding tree unit size.</p><p id="p-0197" num="0191">A motion information table may be initialized in a unit of a picture, a slice, a tile, a brick, a coding tree unit or a coding tree unit line (a row or a column). In an example, when a slice is initialized, a motion information table is also initialized thus a motion information table may not include any motion information candidate.</p><p id="p-0198" num="0192">Alternatively, information representing whether a motion information table will be initialized may be signaled in a bitstream. The information may be signaled in a slice, a tile, a brick or a block level. Until the information indicates the initialization of a motion information table, a pre-configured motion information table may be used.</p><p id="p-0199" num="0193">Alternatively, information on an initial motion information candidate may be signaled in a picture parameter set or a slice header. Although a slice is initialized, a motion information table may include an initial motion information candidate. Accordingly, an initial motion information candidate may be used for a block which is the first encoding/decoding target in a slice.</p><p id="p-0200" num="0194">Alternatively, a motion information candidate included in the motion information table of a previous coding tree unit may be set as an initial motion information candidate. In an example, a motion information candidate with the smallest index or with the largest index among motion information candidates included in the motion information table of a previous coding tree unit may be set as an initial motion information candidate.</p><p id="p-0201" num="0195">Blocks are encoded/decoded in the order of encoding/decoding, and blocks encoded/decoded based on inter-prediction may be sequentially set as a motion information candidate in the order of encoding/decoding.</p><p id="p-0202" num="0196"><figref idref="DRAWINGS">FIG. <b>13</b></figref> is a diagram to explain the update aspect of a motion information table.</p><p id="p-0203" num="0197">For a current block, when inter-prediction is performed S<b>1301</b>, a motion information candidate may be derived based on a current block S<b>1302</b>. The motion information of a motion information candidate may be set the same as that of a current block.</p><p id="p-0204" num="0198">When a motion information table is empty S<b>1303</b>, a motion information candidate derived based on a current block may be added to a motion information table S<b>1304</b>.</p><p id="p-0205" num="0199">When a motion information table already includes a motion information candidate S<b>1303</b>, a redundancy check for the motion information of a current block (or, a motion information candidate derived based on it) may be performed S<b>1305</b>. A redundancy check is to determine whether the motion information of a pre-stored motion information candidate in a motion information table is the same as the motion information of a current block. A redundancy check may be performed for all pre-stored motion information candidates in a motion information table. Alternatively, a redundancy check may be performed for motion information candidates with an index over or below the threshold among pre-stored motion information candidates in a motion information table. Alternatively, a redundancy check may be performed for the predefined number of motion information candidates. In an example, 2 motion information candidates with smallest indexes or with largest indexes may be determined as targets for a redundancy check.</p><p id="p-0206" num="0200">When a motion information candidate with the same motion information as a current block is not included, a motion information candidate derived based on a current block may be added to a motion information table S<b>1308</b>. Whether motion information candidates are identical may be determined based on whether the motion information (e.g. a motion vector/a reference picture index, etc.) of motion information candidates is identical.</p><p id="p-0207" num="0201">In this connection, when the maximum number of motion information candidates are already stored in a motion information table S<b>1306</b>, the oldest motion information candidate may be deleted S<b>1307</b> and a motion information candidate derived based on a current block may be added to a motion information table S<b>1308</b>. In this connection, the oldest motion information candidate may be a motion information candidate with the largest or the smallest index.</p><p id="p-0208" num="0202">Motion information candidates may be identified by respective index. When a motion information candidate derived from a current block is added to a motion information table, the smallest index (e.g. 0) may be assigned to the motion information candidate and indexes of pre-stored motion information candidates may be increased by 1. In this connection, When the maximum number of motion information candidates are already stored in a motion information table, a motion information candidate with the largest index is removed.</p><p id="p-0209" num="0203">Alternatively, when a motion information candidate derived from a current block is added to a motion information table, the largest index may be assigned to the motion information candidate. In an example, when the number of pre-stored motion information candidates in a motion information table is less than the maximum value, an index with the same value as the number of pre-stored motion information candidates may be assigned to the motion information candidate. Alternatively, when the number of pre-stored motion information candidates in a motion information table is equal to the maximum value, an index subtracting 1 from the maximum value may be assigned to the motion information candidate. Alternatively, a motion information candidate with the smallest index is removed and the indexes of residual pre-stored motion information candidates are decreased by 1.</p><p id="p-0210" num="0204"><figref idref="DRAWINGS">FIG. <b>14</b></figref> is a diagram showing the update aspect of a motion information table.</p><p id="p-0211" num="0205">It is assumed that as a motion information candidate derived from a current block is added to a motion information table, the largest index is assigned to the motion information candidate. In addition, it is assumed that the maximum number of a motion information candidate is already stored in a motion information table.</p><p id="p-0212" num="0206">When a motion information candidate HmvpCand[n+1] derived from a current block is added to a motion information table HmvpCandList, a motion information candidate HmvpCand[0] with the smallest index among pre-stored motion information candidates may be deleted and indexes of residual motion information candidates may be decreased by 1. In addition, the index of a motion information candidate HmvpCand[n+1] derived from a current block may be set to the maximum value (for an example shown in <figref idref="DRAWINGS">FIG. <b>14</b></figref>, n) .</p><p id="p-0213" num="0207">When a motion information candidate identical to a motion information candidate derived based on a current block is prestored S<b>1305</b>, a motion information candidate derived based on a current block may not be added to a motion information table S<b>1309</b>.</p><p id="p-0214" num="0208">Alternatively, while a motion information candidate derived based on a current block is added to a motion information table, a pre-stored motion information candidate identical to the motion information candidate may be removed. In this case, it causes the same effect as when the index of a pre-stored motion information candidate is newly updated.</p><p id="p-0215" num="0209"><figref idref="DRAWINGS">FIG. <b>15</b></figref> is a diagram showing an example in which the index of a pre-stored motion information candidate is updated.</p><p id="p-0216" num="0210">When the index of a pre-stored motion information candidate identical to a motion information candidate mvCand derived from a current block is hIdx, the pre-stored motion information candidate may be removed and the index of motion information candidates with an index larger than hIdx may be decreased by 1. In an example, an example shown in <figref idref="DRAWINGS">FIG. <b>15</b></figref> showed that HmvpCand[2] identical to mvCand is deleted in a motion information table HvmpCandList and an index from HmvpCand[3] to HmvpCand[n] is decreased by 1.</p><p id="p-0217" num="0211">And, a motion information candidate mvCand derived based on a current block may be added to the end of a motion information table.</p><p id="p-0218" num="0212">Alternatively, an index assigned to a pre-stored motion information candidate identical to a motion information candidate derived based on a current block may be updated. For example, the index of a pre-stored motion information candidate may be changed to the minimum value or the maximum value.</p><p id="p-0219" num="0213">The motion information of blocks included in a predetermined region may be set not to be added to a motion information table. In an example, a motion information candidate derived based on the motion information of a block included in a merge processing region may not be added to a motion information table. Since the encoding/decoding order for blocks included in a merge processing region is not defined, it is improper to use motion information of any one of them for the inter-prediction of another of them. Accordingly, motion information candidates derived based on blocks included in a merge processing region may not be added to a motion information table.</p><p id="p-0220" num="0214">Alternatively, the motion information of a block smaller than a preset size may be set not to be added to a motion information table. In an example, a motion information candidate derived based on the motion information of a coding block whose width or height is smaller than 4 or 8 or the motion information of a 4&#xd7;4 sized coding block may not be added to a motion information table.</p><p id="p-0221" num="0215">Based on the inter-prediction mode of a current block, it may be determined whether a current block will be used as a motion information candidate. In an example, a block encoded/decoded based on an affine motion model may be set to be unavailable as a motion information candidate. Accordingly, although a current block is encoded/decoded by inter-prediction, a motion information table may not be updated based on a current block when the inter-prediction mode of a current block is an affine prediction mode.</p><p id="p-0222" num="0216">A motion information candidate may be set to include additional information except for motion information. In an example, at least one of the size, shape or partition information of a block may be additionally stored in a motion information candidate. When the merge candidate list of a current block is configured, only motion information candidate whose size, shape or partition information is identical or similar to a current block among motion information candidates may be used or a motion information candidate whose size, shape or partition information is identical or similar to a current block may be added to a merge candidate list in advance.</p><p id="p-0223" num="0217">When the number of a merge candidate included in the merge candidate list of a current block is less than the threshold, a motion information candidate included in a motion information table may be added to a merge candidate list as a merge candidate. The additional process is performed in the order reflecting sorted order of indexes of motion information candidates in ascending or descending order. In an example, a motion information candidate with the largest index may be first added to the merge candidate list of a current block.</p><p id="p-0224" num="0218">When a motion information candidate included in a motion information table is added to a merge candidate list, a redundancy check between a motion information candidate and pre-stored merge candidates in the merge candidate list may be performed. As a result of a redundancy check, a motion information candidate with the same motion information as a pre-stored merge candidate may not be added to the merge candidate list.</p><p id="p-0225" num="0219">A redundancy check may be performed only for a part of motion information candidates included in a motion information table. In an example, a redundancy check may be performed only for a motion information candidate with an index over or below the threshold. Alternatively, a redundancy check may be performed only for N motion information candidates with the largest index or the smallest index.</p><p id="p-0226" num="0220">Alternatively, a redundancy check may be performed only for a part of pre-stored merge candidates in a merge candidate list. In an example, a redundancy check may be performed only for a merge candidate whose index is over or below the threshold or a merge candidate derived from a block at a specific position. In this connection, a specific position may include at least one of the left neighboring block, the top neighboring block, the right-top neighboring block or the left-bottom neighboring block of a current block.</p><p id="p-0227" num="0221"><figref idref="DRAWINGS">FIG. <b>16</b></figref> is a diagram showing an example in which a redundancy check is performed only for a part of merge candidates.</p><p id="p-0228" num="0222">When a motion information candidate HmvpCand[j] is added to a merge candidate list, a redundancy check with 2 merge candidates with the largest index, mergeCandList[NumMerge&#x2212;2] and mergeCandList[NumMerge&#x2212;1], may be performed for a motion information candidate. In this connection, NumMerge may show the number of an available spatial merge candidate and a temporal merge candidate.</p><p id="p-0229" num="0223">Unlike a shown example, when a motion information candidate HmvpCand[j] is added to a merge candidate list, a redundancy check with 2 merge candidates with the smallest index may be performed for a motion information candidate. For example, it may be checked whether mergeCandList[0] and mergeCandList[1] are identical to HmvpCand[j].</p><p id="p-0230" num="0224">Alternatively, a redundancy check may be performed only for a merge candidate derived from a specific position. In an example, a redundancy check may be performed for at least one of a merge candidate derived from a neighboring block positioned at the left of a current block or at the top of a current block. When there is no merge candidate derived from a specific position in a merge candidate list, a motion information candidate may be added to a merge candidate list without a redundancy check.</p><p id="p-0231" num="0225">When a motion information candidate HmvpCand[j] is added to a merge candidate list, a redundancy check with 2 merge candidates with the largest index, mergeCandList[NumMerge&#x2212;2] and mergeCandList[NumMerge&#x2212;1], may be performed for a motion information candidate. In this connection, NumMerge may show the number of an available spatial merge candidate and a temporal merge candidate.</p><p id="p-0232" num="0226">A redundancy check with a merge candidate may be performed only for a part of motion information candidates. In an example, a redundancy check may be performed only for N motion information candidates with a large or a small index among motion information candidates included in a motion information table. In an example, a redundancy check may be performed only for motion information candidates with an index that the number and difference of motion information candidates included in a motion information table are below the threshold. When the threshold is 2, a redundancy check may be performed only for 3 motion information candidates with the largest index value among motion information candidates included in a motion information table. A redundancy check may be omitted for motion information candidates except for the above 3 motion information candidates. When a redundancy check is omitted, a motion information candidate may be added to a merge candidate list regardless of whether the same motion information as a merge candidate is exist or not.</p><p id="p-0233" num="0227">Conversely, a redundancy check is set to be performed only for motion information candidates with an index that the number and difference of motion information candidates included in a motion information table are over the threshold.</p><p id="p-0234" num="0228">The number of a motion information candidate that a redundancy check is performed may be redefined in an encoder and a decoder. In an example, the threshold may be an integer such as 0, 1 or 2.</p><p id="p-0235" num="0229">Alternatively, the threshold may be determined based on at least one of the number of a merge candidate included in a merge candidate list or the number of motion information candidates included in a motion information table.</p><p id="p-0236" num="0230">When a merge candidate identical to the first motion information candidate is found, a redundancy check with the merge candidate identical to the first motion information candidate may be omitted in a redundancy check for the second motion information candidate.</p><p id="p-0237" num="0231"><figref idref="DRAWINGS">FIG. <b>17</b></figref> is a diagram showing an example in which a redundancy check with a specific merge candidate is omitted.</p><p id="p-0238" num="0232">When a motion information candidate HmvpCand[i] whose index is i is added to a merge candidate list, a redundancy check between the motion information candidate and pre-stored merge candidates in a merge candidate list is performed. In this connection, when a merge candidate mergeCandlist[j] identical to a motion information candidate HmvpCand[i] is found, a redundancy check between a motion information candidate HmvpCand[i&#x2212;1] whose index is i&#x2212;1 and merge candidates may be performed without adding the motion information candidate HmvpCand[i] to a merge candidate list. In this connection, a redundancy check between the motion information candidate HmvpCand[i&#x2212;1] and the merge candidate mergeCandList[j] may be omitted.</p><p id="p-0239" num="0233">In an example, in an example shown in <figref idref="DRAWINGS">FIG. <b>17</b></figref>, it was determined that HmvpCand[i] and mergeCandList[2] are identical. Accordingly, a redundancy check for HmvpCand[i&#x2212;1] may be performed without adding HmvpCand[i] to a merge candidate list. In this connection, a redundancy check between HmvpCand[i&#x2212;1] and mergeCandList[2] may be omitted.</p><p id="p-0240" num="0234">When the number of a merge candidate included in the merge candidate list of a current block is less than the threshold, at least one of a pairwise merge candidate or a zero merge candidate may be additionally included except for a motion information candidate. A pairwise merge candidate means a merge candidate having a value obtained from averaging the motion vectors of more than 2 merge candidates as a motion vector and a zero merge candidate means a merge candidate whose motion vector is 0.</p><p id="p-0241" num="0235">For the merge candidate list of a current block, a merge candidate may be added in the following order.</p><p id="p-0242" num="0236">Spatial merge candidate&#x2014;Temporal merge candidate&#x2014;Motion information candidate&#x2014;(Affine motion information candidate)&#x2014;Pairwise merge candidate&#x2014;Zero merge candidate</p><p id="p-0243" num="0237">A spatial merge candidate means a merge candidate derived from at least one of a neighboring block or a non-neighboring block and a temporal merge candidate means a merge candidate derived from a previous reference picture. An affine motion information candidate represents a motion information candidate derived from a block encoded/decoded by an affine motion model.</p><p id="p-0244" num="0238">A motion information table may also be used in a motion vector prediction mode. In an example, when the number of a motion vector prediction candidate included in the motion vector prediction candidate list of a current block is less than the threshold, a motion information candidate included in a motion information table may be set as a motion vector prediction candidate for a current block. Concretely, the motion vector of a motion information candidate may be set as a motion vector prediction candidate.</p><p id="p-0245" num="0239">If any one of motion vector prediction candidates included in the motion vector prediction candidate list of a current block is selected, a selected candidate may be set as a motion vector predictor of a current block. Then, after the motion vector residual value of a current block is decoded, the motion vector of a current block may be obtained by adding up the motion vector predictor and the motion vector residual value.</p><p id="p-0246" num="0240">The motion vector prediction candidate list of a current block may be configured in the following order.</p><p id="p-0247" num="0241">Spatial motion vector prediction candidate&#x2014;Temporal motion vector prediction candidate&#x2014;Motion information candidate&#x2014;(Affine motion information candidate)&#x2014;Zero motion vector prediction candidate</p><p id="p-0248" num="0242">A spatial motion vector prediction candidate means a motion vector prediction candidate derived from at least one of a neighboring block or a non-neighboring block and a temporal motion vector prediction candidate means a motion vector prediction candidate derived from a previous reference picture. An affine motion information candidate represents a motion information candidate derived from a block encoded/decoded by an affine motion model. A zero motion vector prediction candidate represents a candidate that the value of a motion vector is 0.</p><p id="p-0249" num="0243">A merge processing region larger than a coding block may be defined. Coding blocks included in a merge processing region may be processed in parallel without being sequentially encoded/decoded. In this connection, not being sequentially encoded/decoded means the order of encoding/decoding is not defined. Accordingly, the encoding/decoding process of blocks included in a merge processing region may be independently processed. Alternatively, blocks included in a merge processing region may share merge candidates. In this connection, the merge candidates may be derived based on a merge processing region.</p><p id="p-0250" num="0244">According to the above-mentioned feature, a merge processing region may be referred to as a parallel processing region, a shared merge region (SMR) or a merge estimation region (MER).</p><p id="p-0251" num="0245">A merge candidate of a current block may be derived based on a coding block. But, when a current block is included in a merge processing region larger than the current block, a candidate block included in the same merge processing region as the current block may be set to be unavailable as a merge candidate.</p><p id="p-0252" num="0246"><figref idref="DRAWINGS">FIG. <b>18</b></figref> is a diagram showing an example in which a candidate block included in the same merge processing region as a current block is set to be unavailable as a merge candidate.</p><p id="p-0253" num="0247">In an example shown in <figref idref="DRAWINGS">FIG. <b>18</b>(<i>a</i>)</figref>, in the decoding/decoding of CU<b>5</b>, blocks including base samples adjacent to CU<b>5</b> may be set as candidate blocks. In this connection, candidate blocks X<b>3</b> and X<b>4</b> included in the same merge processing region as CU<b>5</b> may be set to be unavailable as a merge candidate of CU<b>5</b>. But, candidate blocks X<b>0</b>, X<b>1</b> and X<b>2</b> not included in the same merge processing region as CU<b>5</b> may be set to be available as a merge candidate.</p><p id="p-0254" num="0248">In an example shown in <figref idref="DRAWINGS">FIG. <b>18</b>(<i>b</i>)</figref>, in the decoding/decoding of CU<b>8</b>, blocks including base samples adjacent to CU<b>8</b> may be set as candidate blocks. In this connection, candidate blocks X<b>6</b>, X<b>7</b> and X<b>8</b> included in the same merge processing region as CU<b>8</b> may be set to be unavailable as a merge candidate. But, candidate blocks X<b>5</b> and X<b>9</b> not included in the same merge processing region as CU<b>8</b> may be set to be available as a merge candidate.</p><p id="p-0255" num="0249">Alternatively, when a current block is included in a merge processing region, a neighboring block adjacent to a current block and to a merge processing region may be set as a candidate block.</p><p id="p-0256" num="0250"><figref idref="DRAWINGS">FIG. <b>19</b></figref> is a diagram showing an example which derives a merge candidate for a current block when a current block is included in a merge processing region.</p><p id="p-0257" num="0251">As in an example shown in <figref idref="DRAWINGS">FIG. <b>19</b>(<i>a</i>)</figref>, neighboring blocks adjacent to a current block may be set as candidate blocks for deriving the merge candidate of the current block. In this connection, a candidate block included in the same merge processing region as the current block may be set to be unavailable as a merge candidate. In an example, in deriving a merge candidate for a coding block CU<b>3</b>, a top neighboring block y<b>3</b> and a right-top neighboring block y<b>4</b> included in the same merge processing region as the coding block CU<b>3</b> may be set to be unavailable as a merge candidate of the coding block CU<b>3</b>.</p><p id="p-0258" num="0252">By scanning neighboring blocks adjacent to a current block in the predefined order, a merge candidate may be derived. In an example, the predefined order may be the order of y<b>1</b>, y<b>3</b>, y<b>4</b>, y<b>0</b> and y<b>2</b>.</p><p id="p-0259" num="0253">When the number of merge candidates which may be derived from neighboring blocks adjacent to a current block is less than a value that an offset is subtracted from the maximum number of merge candidates or the maximum number, a merge candidate for the current block may be derived by using neighboring blocks adjacent to a merge processing region like an example shown in <figref idref="DRAWINGS">FIG. <b>19</b>(<i>b</i>)</figref>. In an example, neighboring blocks adjacent to a merge processing region including a coding block CU<b>3</b> may be set as candidate blocks for the coding block CU<b>3</b>. In this connection, neighboring blocks adjacent to a merge processing region may include at least one of a left neighboring block x<b>1</b>, a top neighboring block x<b>3</b>, a left-bottom neighboring block x<b>0</b>, a right-top neighboring block x<b>4</b> or a left-top neighboring block x<b>2</b>.</p><p id="p-0260" num="0254">By scanning neighboring blocks adjacent to a merge processing region in the predefined order, a merge candidate may be derived. In an example, the predefined order may be the order of x<b>1</b>, x<b>3</b>, x<b>4</b>, x<b>0</b> and x<b>2</b>.</p><p id="p-0261" num="0255">In summary, a merge candidate on the coding block CU<b>3</b> including in a merge processing region may be derived by scanning candidate blocks in the following scanning order.</p><p id="p-0262" num="0256">(y<b>1</b>, y<b>3</b>, y<b>4</b>, y<b>0</b>, y<b>2</b>, x<b>1</b>, x<b>3</b>, x<b>4</b>, x<b>0</b>, x<b>2</b>)</p><p id="p-0263" num="0257">But, the scanning order of the above-illustrated candidate blocks only shows the example of the present disclosure and candidate blocks may be scanned in the order different from the above example. Alternatively, the scanning order may be adaptively determined based on at least one of a size or a shape of a current block or a merge processing region.</p><p id="p-0264" num="0258">A merge processing region may be square or non-square. Information for determining a merge processing region may be signaled in a bitstream. The information may include at least one of information representing the shape of a merge processing region or information representing the size of a merge processing region. When a merge processing region is non-square, at least one of information representing the size of a merge processing region, information representing the width or height of a merge processing region or information representing a ratio between the width and height of a merge processing region may be signaled in a bitstream.</p><p id="p-0265" num="0259">The size of a merge processing region may be determined based on at least one of information signaled in a bitstream, picture resolution, the size of a slice or the size of a tile.</p><p id="p-0266" num="0260">If motion compensation prediction is performed for a block included in a merge processing region, a motion information candidate derived based on the motion information of a block in which motion compensation prediction is performed may be added to a motion information table.</p><p id="p-0267" num="0261">But, if a motion information candidate derived from a block included in a merge processing region is added to a motion information table, a case may occur where a motion information candidate derived from the block is used in the encoding/decoding of other block in the merge processing region whose encoding/decoding is actually slower than the block. In other words, although dependence between blocks should be excluded in the encoding/decoding of blocks included in a merge processing region, a case may occur where motion prediction compensation is performed by using the motion information of other block included in the merge processing region. To solve such a problem, although the encoding/decoding of a block included in a merge processing region is completed, the motion information of the block whose encoding/decoding is completed may not be added to a motion information table.</p><p id="p-0268" num="0262">Alternatively, the motion information table may be updated using only a block at a predefined position within a merge processing region. The examples of the predefined position may include at least one of a block positioned on the top left of the merge processing region, a block positioned on the top right of the merge processing region, a block positioned on the bottom left of the merge processing region, a block positioned on the bottom right of the merge processing region, a block positioned in the center of the merge processing region, a block adjacent to the right boundary of the merge processing region, and a block adjacent to the bottom boundary of the merge processing region. As an example, the motion information table may be updated only with motion information of a block adjacent to the bottom right corner of the merge processing region and the motion information table may not be updated with motion information of other blocks.</p><p id="p-0269" num="0263">Alternatively, after decoding of all blocks included in the merge processing region is completed, a motion information candidate derived from the blocks may be added to the motion information table. That is, while the blocks included in the merge processing region are encoded/decoded, the motion information table may not be updated.</p><p id="p-0270" num="0264">In an example, if motion compensation prediction is performed for blocks included in a merge processing region, a motion information candidate derived from the blocks may be added to a motion information table in the predefined order. In this connection, the predefined order may be determined in the scanning order of coding blocks in a merge processing region or a coding tree unit. The scanning order may be at least one of raster scanning, horizontal scanning, vertical scanning or zigzag scanning. Alternatively, the predefined order may be determined based on the motion information of each block or the number of blocks with the same motion information.</p><p id="p-0271" num="0265">Alternatively, a motion information candidate including a unidirectional motion information may be added to a motion information table before a motion information candidate including a bidirectional motion information. On the contrary, a motion information candidate including a bidirectional motion information may be added to a motion information table before a motion information candidate including a unidirectional motion information.</p><p id="p-0272" num="0266">Alternatively, a motion information candidate may be added to a motion information table in the order of high frequency of use or low frequency of use in a merge processing region or a coding tree unit.</p><p id="p-0273" num="0267">When a current block is included in a merge processing region and the number of merge candidates included in a merge candidate list of the current block is less than the maximum number, a motion information candidate included in a motion information table may be added to the merge candidate list. In this connection, a motion information candidate derived from a block included in the same merge processing region as a current block may be set not to be added to the merge candidate list of the current block.</p><p id="p-0274" num="0268">Alternatively, when a current block is included in a merge processing region, it may be set not to use a motion information candidate included in a motion information table. In other words, although the number of merge candidates included in a merge candidate list of the current block is less than the maximum number, a motion information candidate included in a motion information table may not be added to the merge candidate list.</p><p id="p-0275" num="0269">In another example, a motion information table on a merge processing region or a coding tree unit may be configured. This motion information table plays a role of temporarily storing the motion information of blocks included in a merge processing region. To distinguish between a general motion information table and a motion information table for a merge processing region or a coding tree unit, the motion information table for the merge processing region or the coding tree unit is referred to as a temporary motion information table. And, a motion information candidate stored in the temporary motion information table is referred to as a temporary motion information candidate.</p><p id="p-0276" num="0270"><figref idref="DRAWINGS">FIG. <b>20</b></figref> is a diagram showing a temporary motion information table.</p><p id="p-0277" num="0271">A temporary motion information table for a coding tree unit or a merge processing region may be configured. When motion compensation prediction is performed for a current block included in a coding tree unit or a merge processing region, the motion information of the block may not be added to a motion information table HmvpCandList. Instead, a temporary motion information candidate derived from the block may be added to a temporary motion information table HmvpMERCandList. In other words, a temporary motion information candidate added to a temporary motion information table may not be added to a motion information table. Accordingly, a motion information table may not include a motion information candidate derived based on motion information of blocks included in a coding tree unit or a merge processing region including a current block.</p><p id="p-0278" num="0272">Alternatively, only motion information of some of the blocks included in the merge processing region may be added to the temporary motion information table. As an example, only blocks at predefined positions within the merge processing region may be used for updating the motion information table. The predefined positions may include at least one of a block positioned on the top left of the merge processing region, a block positioned on the top right of the merge processing region, a block positioned on the bottom left of the merge processing region, a block positioned on the bottom right of the merge processing region, a block positioned in the center of the merge processing region, a block adjacent to the right boundary of the merge processing region, and a block adjacent to the bottom boundary of the merge processing region. As an example, only motion information of a block adjacent to the bottom right corner of the merge processing region may be added to the temporary motion information table and motion information of other blocks may not be added to the temporary motion information table.</p><p id="p-0279" num="0273">The maximum number of temporary motion information candidates that the temporary motion information table is able to include may be set equal to the maximum number of motion information candidates that the motion information table is able to include. Alternatively, the maximum number of temporary motion information candidates that the temporary motion information table is able to include may be determined according to the size of the coding tree unit or the merge processing region. Alternatively, the maximum number of temporary motion information candidates that the temporary motion information table is able to include may be set smaller than the maximum number of motion information candidates that the motion information table is able to include.</p><p id="p-0280" num="0274">A current block included in a coding tree unit or a merge processing region may be set not to use a temporary motion information table on the corresponding coding tree unit or merge processing region. In other words, when the number of merge candidates included in the merge candidate list of the current block is less than the threshold, a motion information candidate included in a motion information table may be added to the merge candidate list and a temporary motion information candidate included in a temporary motion information table may not be added to the merge candidate list. Accordingly, the motion information of other block including in the same coding tree unit or the same merge processing region as the current block may not be used for the motion compensation prediction of the current block.</p><p id="p-0281" num="0275">If the encoding/decoding of all blocks included in a coding tree unit or a merge processing region is completed, a motion information table and a temporary motion information table may be unified.</p><p id="p-0282" num="0276"><figref idref="DRAWINGS">FIG. <b>21</b></figref> is a diagram showing an example in which a motion information table and a temporary motion information table are unified.</p><p id="p-0283" num="0277">If the encoding/decoding of all blocks included in a coding tree unit or a merge processing region is completed, a temporary motion information candidate included in a temporary motion information table may be updated in a motion information table as in an example shown in <figref idref="DRAWINGS">FIG. <b>21</b></figref>.</p><p id="p-0284" num="0278">In this connection, temporary motion information candidates included in a temporary motion information table may be added to a motion information table in the order inserted in the temporary motion information table. (In other words, in the ascending order or the descending order of the index value)</p><p id="p-0285" num="0279">In another example, temporary motion information candidates included in a temporary motion information table may be added to a motion information table in the predefined order. In this connection, the predefined order may be determined in the scanning order of coding blocks in a merge processing region or a coding tree unit. The scanning order may be at least one of raster scanning, horizontal scanning, vertical scanning or zigzag scanning. Alternatively, the predefined order may be determined based on the motion information of each block or the number of blocks with the same motion information.</p><p id="p-0286" num="0280">Alternatively, a temporary motion information candidate including a unidirectional motion information may be added to a motion information table before a temporary motion information candidate including a bidirectional motion information. On the contrary, a temporary motion information candidate including a bidirectional motion information may be added to a motion information table before a temporary motion information candidate including a unidirectional motion information.</p><p id="p-0287" num="0281">Alternatively, a temporary motion information candidate may be added to a motion information table in the order of high frequency of use or low frequency of use in a merge processing region or a coding tree unit.</p><p id="p-0288" num="0282">In case that a temporary motion information candidate included in a temporary motion information table is added to a motion information table, a redundancy check for a temporary motion information candidate may be performed. In an example, when the same motion information candidate as a temporary motion information candidate included in a temporary motion information table is prestored in a motion information table, the temporary motion information candidate may not be added to the motion information table. In this connection, a redundancy check may be performed for a part of motion information candidates included in a motion information table. In an example, a redundancy check may be performed for motion information candidates with an index over or below the threshold. In an example, when a temporary motion information candidate is equal to a motion information candidate with an index over the predefined value, the temporary motion information candidate may not be added to a motion information table.</p><p id="p-0289" num="0283">It may limit the use of a motion information candidate derived from a block included in the same coding tree unit or the same merge processing region as a current block as the merge candidate of the current block. For it, the address information of a block may be additionally stored for a motion information candidate. The address information of a block may include at least one of the position of the block, the address of the block, the index of the block, the position of a merge processing region in which the block is included, the address of a merge processing region in which the block is included, the index of a merge processing region in which the block is included, the position of a coding tree region in which the block is included, the address of a coding tree region in which the block is included or the index of a coding tree region in which the block is included.</p><p id="p-0290" num="0284">Intra-prediction predicts a current block by using a reconstructed sample that has been already encoded/decoded and which is around the current block. In this connection, a reconstructed sample before applying an in-loop filter may be used for intra-prediction of the current block.</p><p id="p-0291" num="0285">An intra-prediction method includes intra-prediction based on a matrix and intra-prediction according to a direction with a neighboring reconstruction sample. Information indicating an intra-prediction method of a current block may be signaled in a bitstream. The information may be a 1-bit flag. Alternatively, an intra-prediction of a current block may be determined on the basis of at least one of a position of the current block, a size of the current block, a shape of the current block, or an intra-prediction method of a neighboring block. In an example, when a current block is present crossing a picture boundary, it may be set such that an intra-prediction method based on a matrix is not applied to the current block.</p><p id="p-0292" num="0286">An intra-prediction method based on a matrix is a method of obtaining a prediction block of a current block on the basis of a matrix product of a matrix stored in the encoder and the decoder, and reconstruction samples around the current block. Information for specifying any one of a plurality of prestored matrices may be signaled in a bitstream. The decoder may determine a matrix for performing intra-prediction on a current block on the basis of the above information and a size of the current block.</p><p id="p-0293" num="0287">General intra-prediction is a method of obtaining a prediction block of a current block on the basis of a non-directional intra-prediction mode or directional intra-prediction mode. Hereinafter, with reference to figures, a process of intra-prediction based on general intra-prediction will be described in detail.</p><p id="p-0294" num="0288"><figref idref="DRAWINGS">FIG. <b>22</b></figref> is a flow diagram of an intra-prediction method according to an embodiment of the present disclosure.</p><p id="p-0295" num="0289">A reference sample line of a current block may be determined S<b>2201</b>. The reference sample line means a group of reference samples included in a k-th line apart from a top and/or a left of the current block. A reference sample may be derived from a reconstructed sample encoded/decoded around the current block.</p><p id="p-0296" num="0290">Index information identifying a reference sample line for a current block among a plurality of reference sample lines may be signaled in a bitstream. In an example, index information, intra_luma_ref_idx, for specifying the reference sample line of the current block may be signaled in the bitstream. The index information may be signaled per coding block.</p><p id="p-0297" num="0291">A plurality of reference sample lines may include at least one of a first line, a second line or a third line at a top and/or left of a current block. A reference sample line composed of a row adjacent to the top of the current block and a column adjacent to the left of the current block among a plurality of reference sample lines may be referred to as an adjacent reference sample line, and other reference sample lines may be referred to as a non-adjacent reference sample line.</p><p id="p-0298" num="0292">Table 1 shows an index assigned to each candidate reference sample line.</p><p id="p-0299" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="63pt" align="center"/><colspec colname="2" colwidth="154pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 1</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>Index</entry><entry/></row><row><entry>(intra_luma_</entry><entry/></row><row><entry>ref_idx)</entry><entry>Reference sample line</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>0</entry><entry>Adjacent reference sample line</entry></row><row><entry>1</entry><entry>First non-adjacent reference sample line</entry></row><row><entry>2</entry><entry>Second non-adjacent reference sample line</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0300" num="0293">Based on at least one of a position, a size, a shape of a current block or a prediction encoding mode of a neighboring block, a reference sample line of the current block may be determined. In one example, when the current block adjoins a boundary of a picture, a tile, a slice or a coding tree unit, an adjacent reference sample line may be determined as the reference sample line of the current block.</p><p id="p-0301" num="0294">A reference sample line may include top reference samples positioned at a top of the current block and left reference samples positioned at a left of the current block. The top reference samples and left reference samples may be derived from reconstructed samples around the current block. The reconstructed samples may be in a state before an in-loop filter is applied.e</p><p id="p-0302" num="0295">Next, an intra-prediction mode of a current block may be determined S<b>2202</b>. For the intra-prediction mode of the current block, at least one of a non-directional intra-prediction mode or a directional intra-prediction mode may be determined as the intra-prediction mode of the current block. Non-directional intra-prediction modes includes a planar and a DC and directional intra-prediction modes includes 33 or 65 modes from a left-bottom diagonal direction to a right-top diagonal direction.</p><p id="p-0303" num="0296"><figref idref="DRAWINGS">FIG. <b>23</b></figref> is a diagram showing intra-prediction modes.</p><p id="p-0304" num="0297"><figref idref="DRAWINGS">FIG. <b>23</b>(<i>a</i>)</figref> shows 35 intra-prediction modes and <figref idref="DRAWINGS">FIG. <b>23</b>(<i>b</i>)</figref> shows 67 intra-prediction modes.</p><p id="p-0305" num="0298">The larger or smaller number of intra-prediction modes than shown in <figref idref="DRAWINGS">FIG. <b>23</b></figref> may be defined.</p><p id="p-0306" num="0299">Based on an intra-prediction mode of a neighboring block adjacent to a current block, an MPM(Most Probable Mode) may be set. In this connection, a neighboring block may include a left neighboring block adjacent to a left of the current block and a top neighboring block adjacent to a top of the current block.</p><p id="p-0307" num="0300">The number of MPMs included in an MPM list may be preset in an encoder and a decoder. In an example, the number of MPMs may be 3, 4, 5 or 6. Alternatively, information representing the number of MPMs may be signaled in a bitstream. Alternatively, based on at least one of a prediction encoding mode of a neighboring block, a size, a shape or a reference sample line index of a current block, the number of MPMs may be determined. In an example, while N MPMs may be used when an adjacent reference sample line is determined as the reference sample line of the current block, M MPMs may be used when a non-adjacent reference sample line is determined as the reference sample line of the current block. As M is a natural number smaller than N, in an example, N may be 6 and M may be 5, 4 or 3. Accordingly, while the intra-prediction mode of the current block may be determined as any one of 6 candidate intra-prediction modes when the index of the reference sample line of the current block is 0 and an MPM flag is true, the intra-prediction mode of the current block may be determined as any one of 5 candidate intra-prediction modes when the index of the reference sample line of the current block is larger than 0 and an MPM flag is true.</p><p id="p-0308" num="0301">Alternatively, the fixed number (e.g. 6 or 5) of MPM candidates may be used regardless of the index of the reference sample line of the current block.</p><p id="p-0309" num="0302">An MPM list including a plurality of MPMs may be generated and information indicating whether the same MPM as an intra-prediction mode of a current block is included in the MPM list may be signaled in a bitstream. As the information is a 1-bit flag, it may be referred to as an MPM flag. When the MPM flag represents the same MPM as the current block is included in the MPM list, index information identifying one of MPMs may be signaled in a bitstream. In an example, index information, mpm_idx, specifying any one of plural MPMs may be signaled in a bitstream. An MPM specified by the index information may be set as the intra-prediction mode of the current block. When the MPM flag represents the same MPM as the current block is not included in the MPM list, remaining mode information indicating any one of remaining intra-prediction modes except for MPMs may be signaled in a bitstream. Remaining mode information represents an index value corresponding to the intra-prediction mode of the current block when an index is reassigned to remaining intra-prediction modes except for MPMs. A decoder may may determine the intra-prediction mode of the current block by arranging MPMs in the ascending order and comparing remaining mode information with MPMs. In an example, when remaining mode information is equal to or smaller than MPM, the intra-prediction mode of the current block may be derived by adding 1 to remaining mode information.</p><p id="p-0310" num="0303">In deriving an intra-prediction mode of a current block, comparing a part of MPMs with remaining mode information may be omitted. In an example, MPMs in a non-directional intra-prediction mode among MPMs may be excluded from a comparison target. When non-directional intra-prediction modes are set as MPMs, remaining mode information clearly indicates a directional intra-prediction mode, so the intra-prediction mode of the current block may be derived by comparing remaining MPMs except for non-directional intra-prediction modes with remaining mode information. Instead of excluding non-directional intra-prediction modes from a comparison target, a result value may be compared with remaining MPMs after adding the number of non-directional intra-prediction modes to remaining mode information.</p><p id="p-0311" num="0304">Instead of setting a default mode as an MPM, information indicating whether an intra-prediction mode of a current block is the default mode may be signaled in a bitstream. The information is a 1-bit flag and the flag may be referred to as a default mode flag. The default mode flag may be signaled only when an MPM flag represents that the same MPM as the current block is included in an MPM list. As described above, the default mode may include at least one of a planar, DC, a vertical direction mode or a horizontal direction mode. In an example, when the planar is set as the default mode, the default mode flag may indicate whether the intra-prediction mode of the current block is the planar. When the default mode flag indicates that the intra-prediction mode of the current block is not the default mode, one of MPMs indicated by index information may be set as the intra-prediction mode of the current block.</p><p id="p-0312" num="0305">When a default mode flag is used, it may be set that an intra-prediction mode same with a default mode is not set as an MPM. In an example, when the default mode flag indicates that whether the intra-prediction mode of the current block is a planar, the intra-prediction mode of the current block may be derived by using 5 MPMs excluding an MPM corresponding to the planar.</p><p id="p-0313" num="0306">When a plurality of intra-prediction modes are set as default modes, index information indicating any one of default modes may be further signaled. The intra-prediction mode of the current block may be set as a default mode indicated by the index information.</p><p id="p-0314" num="0307">When an index of a reference sample line of a current block is not 0, it may be set not to use a default mode. In an example, when a non-adjacent reference sample line is determined as the reference sample line of the current block, it may be set not to use a non-directional intra-prediction mode such as a DC mode or a planar mode. Accordingly, when an index of a reference sample line is not 0, a default mode flag may not be signaled and a value of the default mode flag may be inferred to a predefined value (i.e. false).</p><p id="p-0315" num="0308">When an intra-prediction mode of a current block is determined, prediction samples for the current block may be obtained based on a determined intra-prediction mode S<b>2203</b>.</p><p id="p-0316" num="0309">When the DC mode is selected, prediction samples for the current block may be generated based on an average value of the reference samples. In detail, values of all of samples within the prediction block may be generated based on an average value of the reference samples. An average value may be derived using at least one of top reference samples adjacent to the top of the current block, and left reference samples adjacent to the left of the current block.</p><p id="p-0317" num="0310">The number or a range of the reference samples used when deriving an average value may vary based on the shape of the current block. In an example, when a current block is a non-square block where a width is greater than a height, an average value may be calculated by using top reference samples. To the contrary, when a current block is a non-square block where a width is smaller than a height, an average value may be calculated by using left reference samples. In other words, when a width and a height of the current block are different, reference samples adjacent to the greater length may be used so as to calculate an average value. Alternatively, whether to calculate an average value by using top reference samples or by using left reference samples may be determined on the basis of a ratio between a width and a height of the current block.</p><p id="p-0318" num="0311">When a planar mode is selected, a prediction sample may be obtained by using a horizontal directional prediction sample and a vertical directional prediction sample. In this connection, the horizontal directional prediction sample may be obtained on the basis of a left reference sample and a right reference sample which are positioned at the same horizontal line with the prediction sample, and the vertical directional prediction sample may be obtained on the basis of an top reference sample and a bottom reference sample which are positioned at the same vertical line with the prediction sample. In this connection, the right reference sample may be generated by copying a reference sample adjacent to the top-right corner of the current block, and the bottom reference sample may be generated by copying a reference sample adjacent to the lower-left corner of the current block. The horizontal directional prediction sample may be obtained on the basis of a weighted sum of the left reference sample and the right reference sample, and the vertical directional prediction sample may be obtained on the basis of a weighted sum of the top reference sample and the bottom reference sample. In this connection, a weighting factor assigned to each reference sample may be determined according to a position of the prediction sample. The prediction sample may be obtained on the basis of an average or a weighted sum of the horizontal directional prediction sample and the vertical directional prediction sample. When a weighted sum is used, a weighting factor assigned to the horizontal directional prediction sample and the vertical directional prediction sample may be determined on the basis of a position of the prediction sample.</p><p id="p-0319" num="0312">When a directional prediction mode is selected, a parameter representing a prediction direction (or prediction angle) of the selected directional prediction mode may be determined. Table 2 below represents an intra directional parameter of intraPredAng for each intra-prediction mode.</p><p id="p-0320" num="0000"><tables id="TABLE-US-00002" num="00002"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="8"><colspec colname="1" colwidth="49pt" align="center"/><colspec colname="2" colwidth="21pt" align="char"/><colspec colname="3" colwidth="28pt" align="char"/><colspec colname="4" colwidth="21pt" align="char"/><colspec colname="5" colwidth="28pt" align="char"/><colspec colname="6" colwidth="21pt" align="char"/><colspec colname="7" colwidth="28pt" align="char"/><colspec colname="8" colwidth="21pt" align="char"/><thead><row><entry namest="1" nameend="8" rowsep="1">TABLE 2</entry></row><row><entry namest="1" nameend="8" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>PredModeIntra</entry><entry>1</entry><entry>2</entry><entry>3</entry><entry>4</entry><entry>5</entry><entry>6</entry><entry>7</entry></row><row><entry>IntraPredAng</entry><entry>&#x2014;</entry><entry>32</entry><entry>26</entry><entry>21</entry><entry>17</entry><entry>13</entry><entry>9</entry></row><row><entry>PredModeIntra</entry><entry>8</entry><entry>9</entry><entry>10</entry><entry>11</entry><entry>12</entry><entry>13</entry><entry>14</entry></row><row><entry>IntraPredAng</entry><entry>5</entry><entry>2</entry><entry>0</entry><entry>&#x2212;2</entry><entry>&#x2212;5</entry><entry>&#x2212;9</entry><entry>&#x2212;13</entry></row><row><entry>PredModeIntra</entry><entry>15</entry><entry>16</entry><entry>17</entry><entry>18</entry><entry>19</entry><entry>20</entry><entry>21</entry></row><row><entry>IntraPredAng</entry><entry>&#x2212;17</entry><entry>&#x2212;21</entry><entry>&#x2212;26</entry><entry>&#x2212;32</entry><entry>&#x2212;26</entry><entry>&#x2212;21</entry><entry>&#x2212;17</entry></row><row><entry>PredModeIntra</entry><entry>22</entry><entry>23</entry><entry>24</entry><entry>25</entry><entry>26</entry><entry>27</entry><entry>28</entry></row><row><entry>IntraPredAng</entry><entry>&#x2212;13</entry><entry>&#x2212;9</entry><entry>&#x2212;5</entry><entry>&#x2212;2</entry><entry>0</entry><entry>2</entry><entry>5</entry></row><row><entry>PredModeIntra</entry><entry>29</entry><entry>30</entry><entry>31</entry><entry>32</entry><entry>33</entry><entry>34</entry><entry/></row><row><entry>IntraPredAng</entry><entry>9</entry><entry>13</entry><entry>17</entry><entry>21</entry><entry>26</entry><entry>32</entry></row><row><entry namest="1" nameend="8" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0321" num="0313">Table 2 represents an intra directional parameter of each intra-prediction mode where an index thereof is one of 2 to 34 when 35 intra-prediction modes are defined. When directional intra-prediction modes are defined more than 33, an intra directional parameter of each intra-prediction mode may be set by subdividing Table 2.</p><p id="p-0322" num="0314">Top reference samples and left reference samples for the current block are arranged in a line, and then a prediction sample may be obtained on the basis of a value of an intra directional parameter. In this connection, when a value of the intra directional parameter is a negative value, left reference samples and top reference samples may be arranged in a line.</p><p id="p-0323" num="0315"><figref idref="DRAWINGS">FIGS. <b>24</b> and <b>25</b></figref> are views respectively showing examples of one-dimensional arrangement where reference samples are arranged in a line.</p><p id="p-0324" num="0316"><figref idref="DRAWINGS">FIG. <b>24</b></figref> is a view showing vertical directional one-dimensional arrangement where reference samples are arranged in a vertical direction, and <figref idref="DRAWINGS">FIG. <b>25</b></figref> is a view showing horizontal directional one-dimensional arrangement where reference samples are arranged in a horizontal direction. Examples of <figref idref="DRAWINGS">FIGS. <b>24</b> and <b>25</b></figref> will be described in assumption that 35 intra-prediction modes are defined.</p><p id="p-0325" num="0317">When an intra-prediction mode index is any one of 11 to 18, horizontal directional one-dimensional arrangement may be applied where top reference samples are rotated in counterclockwise, and when an intra-prediction mode index is any one of 19 to 25, vertical directional one-dimensional arrangement may be applied where left reference samples are rotated in clockwise. When arranging reference samples in a line, an intra-prediction mode angle may be considered.</p><p id="p-0326" num="0318">A reference sample determining parameter may be determined on the basis of an intra directional parameter. The reference sample determining parameter may include a reference sample index for specifying a sample, and a weighting factor parameter for determining a weighting factor applied to the reference sample.</p><p id="p-0327" num="0319">A reference sample index, iIdx, and a weighting factor parameter, ifact, may be respectively obtained through Equations 4 and 5 below.</p><p id="p-0328" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>i</i>Idx=(<i>y+</i>1)*<i>P</i><sub>ang</sub>/32 &#x2003;&#x2003;[Equation 4]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0329" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>i</i><sub>fact</sub>=[(<i>y+</i>1)*<i>P</i><sub>ang</sub>]&#x26;31 &#x2003;&#x2003;[Equation 5]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0330" num="0320">In Equations 4 and 5, P<sub>ang </sub>represents an intra directional parameter. A reference sample specified by a reference sample index of iIdx corresponds to an integer pel.</p><p id="p-0331" num="0321">In order to derive a prediction sample, at least one reference sample may be specified. In detail, according to a slope of a prediction mode, a position of a reference sample used for deriving a prediction sample may be specified. In an example, a reference sample used for deriving a prediction sample may be specified by using a reference sample index of iIdx.</p><p id="p-0332" num="0322">In this connection, when a slope of an intra-prediction mode is not represented by one reference sample, a prediction sample may be generated by performing interpolation on a plurality of reference samples. In an example, when a slope of an intra-prediction mode is a value between a slope between a prediction sample and a first reference sample, and a slope between the prediction sample and a second reference sample, the prediction sample may be obtained by performing interpolation on the first reference sample and the second reference sample. In other words, when an angular line according to an intra-prediction angle does not pass a reference sample positioned at an integer pel, a prediction sample may be obtained by performing interpolation on reference samples positioned adjacent to the left and the right, or the top and the bottom of the position where the angular line passes.</p><p id="p-0333" num="0323">Equation 6 below represents an example of obtaining a prediction sample on the basis of reference samples.</p><p id="p-0334" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>P</i>(<i>x,y</i>)=((32<i>&#x2212;i</i><sub>fact</sub>)/<sup>32</sup>)*Ref_1D(<i>x+i</i>Idx+1)+(<i>i</i><sub>fact</sub>/32)*Ref_1D(<i>x+i</i>Idx2) &#x2003;&#x2003;[Equation 6]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0335" num="0324">In Equation 6, P represents a prediction sample, and Ref_1D represents any one of reference samples that are arranged in a line. In this connection, a position of the reference sample may be determined by a position (x, y) of the prediction sample and a reference sample index of iIdx.</p><p id="p-0336" num="0325">When a slope of an intra-prediction mode is possibly represented by one reference sample, a weighting factor parameter of i<sub>fact </sub>is set to 0. Accordingly, Equation 6 may be simplified as Equation 7 below.</p><p id="p-0337" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>P</i>(<i>x,y</i>)=Ref_1D(<i>x+i</i>Idx+1) &#x2003;&#x2003;[Equation 7]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0338" num="0326">Intra-prediction for a current block may be performed on the basis of a plurality of intra-prediction modes. In an example, an intra-prediction mode may be derived for each prediction sample, and a prediction sample may be derived on the basis of an intra-prediction mode assigned to each prediction sample.</p><p id="p-0339" num="0327">Alternatively, an intra-prediction mode may be derived for each region, intra-prediction for each region may be performed on the basis of an intra-prediction mode assigned to each region. In this connection, the region may include at least one sample. At least one of a size and a shape of the region may be adaptively determined on the basis of at least one of a size of the current block, a shape of the current block, and an intra-prediction mode for the current block. Alternatively, at least one of a size and a shape of the region may be predefined in the encoder and the decoder independent to a size or shape of the current block.</p><p id="p-0340" num="0328"><figref idref="DRAWINGS">FIG. <b>26</b></figref> is a view showing a degree formed between directional intra-prediction modes and a straight line parallel to an x axis.</p><p id="p-0341" num="0329">As an example shown in <figref idref="DRAWINGS">FIG. <b>26</b></figref>, directional prediction modes may be present between the lower-left diagonal direction and the top-right diagonal direction. Describing a degree formed between the x axis and a directional prediction mode, directional prediction modes may be present from 45 degrees (bottom-left diagonal direction) to &#x2212;135 degrees (top-right diagonal direction).</p><p id="p-0342" num="0330">When a current block is a non-square, a case may be present where a prediction sample is derived by using, among reference samples positioned at the angular line according to an intra-prediction angle, a reference sample that is positioned farther than a reference sample close to a prediction sample according to an intra-prediction mode for the current block.</p><p id="p-0343" num="0331"><figref idref="DRAWINGS">FIG. <b>27</b></figref> is a view shown an aspect of obtaining a prediction sample when a current block is a non-square.</p><p id="p-0344" num="0332">In an example, as an example shown in <figref idref="DRAWINGS">FIG. <b>27</b>(<i>a</i>)</figref>, it is assumed that a current block is a non-square where a width is greater than a height, and an intra-prediction mode for the current block is a directional intra-prediction mode having an angle from 0 degree to 45 degrees. In the above case, when deriving a prediction sample A around a right column of the current block, among reference samples positioned at the angular mode according to the above degree, rather than using a top reference sample T close to the prediction sample, a case may be present where a left reference sample L far away from the prediction sample is used.</p><p id="p-0345" num="0333">In another example, as an example shown in <figref idref="DRAWINGS">FIG. <b>27</b>(<i>b</i>)</figref>, it is assumed that a current block is a non-square where a height is greater than a width, and an intra-prediction mode for the current block is a directional intra-prediction mode from &#x2212;90 degrees to &#x2212;135 degrees. In the above case, when deriving a prediction sample A around a bottom row of the current block, among reference samples positioned at the angular mode according to the above degree, rather than using a left reference sample L close to the prediction sample, a case may be present where a top reference sample T far away from the prediction sample is used.</p><p id="p-0346" num="0334">To solve the above problem, when a current block is a non-square, an intra-prediction mode for the current block may be substituted with an intra-prediction mode in opposite direction. Accordingly, for a non-square block, directional prediction modes having angles greater or smaller than those of directional prediction modes shown in <figref idref="DRAWINGS">FIG. <b>23</b></figref> may be used. The above directional intra-prediction mode may be defined as a wide angle intra-prediction mode. A wide angle intra-prediction mode represents a directional intra-prediction mode that does not belong to a range of 45 degrees to &#x2212;135 degrees.</p><p id="p-0347" num="0335"><figref idref="DRAWINGS">FIG. <b>28</b></figref> is a view showing wide angle intra-prediction modes.</p><p id="p-0348" num="0336">In an example show in <figref idref="DRAWINGS">FIG. <b>28</b></figref>, intra-prediction modes having indices from &#x2212;1 to &#x2212;14 and intra-prediction modes having indices from 67 to 80 represent wide angle intra-prediction modes.</p><p id="p-0349" num="0337">In <figref idref="DRAWINGS">FIG. <b>28</b></figref>, 14 wide angle intra-prediction modes (from &#x2212;1 to &#x2212;14) which are greater in angle than 45 degrees and 4 wide angle intra-prediction modes (from 67 to 80) which are smaller in angle than &#x2212;135 degrees are shown. However, more or fewer number of wide angle intra-prediction modes may be defined.</p><p id="p-0350" num="0338">When a wide angle intra-prediction mode is used, a length of top reference samples may be set to 2W+1, and a length of left reference samples may be set to 2H+1.</p><p id="p-0351" num="0339">By using a wide angle intra-prediction mode, a sample A shown in <figref idref="DRAWINGS">FIG. <b>28</b>(<i>a</i>)</figref> may be predicted by using a reference sample T, and a sample A shown in <figref idref="DRAWINGS">FIG. <b>28</b>(<i>b</i>)</figref> may be predicted by a reference sample L.</p><p id="p-0352" num="0340">In addition to legacy intra-prediction modes and N wide angle intra-prediction modes, a total of 67+N intra-prediction modes may be used. In an example, Table 3 represents an intra directional parameter for intra-prediction modes when 20 wide angle intra-prediction modes are defined.</p><p id="p-0353" num="0000"><tables id="TABLE-US-00003" num="00003"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="10"><colspec colname="1" colwidth="49pt" align="center"/><colspec colname="2" colwidth="28pt" align="char"/><colspec colname="3" colwidth="28pt" align="char"/><colspec colname="4" colwidth="28pt" align="char"/><colspec colname="5" colwidth="28pt" align="char"/><colspec colname="6" colwidth="28pt" align="char"/><colspec colname="7" colwidth="28pt" align="char"/><colspec colname="8" colwidth="28pt" align="char"/><colspec colname="9" colwidth="28pt" align="char"/><colspec colname="10" colwidth="28pt" align="char"/><thead><row><entry namest="1" nameend="10" rowsep="1">TABLE 3</entry></row><row><entry namest="1" nameend="10" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>PredModeIntra</entry><entry>&#x2212;10</entry><entry>&#x2212;9</entry><entry>&#x2212;8</entry><entry>&#x2212;7</entry><entry>&#x2212;6</entry><entry>&#x2212;5</entry><entry>&#x2212;4</entry><entry>&#x2212;3</entry><entry>&#x2212;2</entry></row><row><entry>intra PredAngle</entry><entry>114</entry><entry>93</entry><entry>79</entry><entry>68</entry><entry>60</entry><entry>54</entry><entry>49</entry><entry>45</entry><entry>39</entry></row><row><entry>PredModeIntra</entry><entry>&#x2212;1</entry><entry>2</entry><entry>3</entry><entry>4</entry><entry>5</entry><entry>6</entry><entry>7</entry><entry>8</entry><entry>9</entry></row><row><entry>intraPredAngle</entry><entry>35</entry><entry>32</entry><entry>29</entry><entry>26</entry><entry>23</entry><entry>21</entry><entry>19</entry><entry>17</entry><entry>15</entry></row><row><entry>PredModeIntra</entry><entry>10</entry><entry>11</entry><entry>12</entry><entry>13</entry><entry>14</entry><entry>15</entry><entry>16</entry><entry>17</entry><entry>18</entry></row><row><entry>intraPredAngle</entry><entry>13</entry><entry>11</entry><entry>9</entry><entry>7</entry><entry>5</entry><entry>3</entry><entry>2</entry><entry>1</entry><entry>0</entry></row><row><entry>PredModeIntra</entry><entry>19</entry><entry>20</entry><entry>21</entry><entry>22</entry><entry>23</entry><entry>24</entry><entry>25</entry><entry>26</entry><entry>27</entry></row><row><entry>intraPredAngle</entry><entry>&#x2212;1</entry><entry>&#x2212;2</entry><entry>&#x2212;3</entry><entry>&#x2212;5</entry><entry>&#x2212;7</entry><entry>&#x2212;9</entry><entry>&#x2212;11</entry><entry>&#x2212;13</entry><entry>&#x2212;15</entry></row><row><entry>PredModeIntra</entry><entry>28</entry><entry>29</entry><entry>30</entry><entry>31</entry><entry>32</entry><entry>33</entry><entry>34</entry><entry>35</entry><entry>36</entry></row><row><entry>intraPredAngle</entry><entry>&#x2212;17</entry><entry>&#x2212;19</entry><entry>&#x2212;21</entry><entry>&#x2212;23</entry><entry>&#x2212;26</entry><entry>&#x2212;29</entry><entry>&#x2212;32</entry><entry>&#x2212;29</entry><entry>&#x2212;26</entry></row><row><entry>PredModeIntra</entry><entry>37</entry><entry>38</entry><entry>39</entry><entry>40</entry><entry>41</entry><entry>42</entry><entry>43</entry><entry>44</entry><entry>45</entry></row><row><entry>intraPredAngle</entry><entry>&#x2212;23</entry><entry>&#x2212;21</entry><entry>&#x2212;19</entry><entry>&#x2212;17</entry><entry>&#x2212;15</entry><entry>&#x2212;13</entry><entry>&#x2212;11</entry><entry>&#x2212;9</entry><entry>&#x2212;7</entry></row><row><entry>PredModeIntra</entry><entry>46</entry><entry>47</entry><entry>48</entry><entry>49</entry><entry>50</entry><entry>51</entry><entry>52</entry><entry>53</entry><entry>54</entry></row><row><entry>intraPredAngle</entry><entry>&#x2212;5</entry><entry>&#x2212;3</entry><entry>&#x2212;2</entry><entry>&#x2212;1</entry><entry>0</entry><entry>1</entry><entry>2</entry><entry>3</entry><entry>5</entry></row><row><entry>PredModeIntra</entry><entry>55</entry><entry>56</entry><entry>57</entry><entry>58</entry><entry>59</entry><entry>60</entry><entry>61</entry><entry>62</entry><entry>63</entry></row><row><entry>intraPredAngle</entry><entry>7</entry><entry>9</entry><entry>11</entry><entry>13</entry><entry>15</entry><entry>17</entry><entry>19</entry><entry>21</entry><entry>23</entry></row><row><entry>PredModeIntra</entry><entry>64</entry><entry>65</entry><entry>66</entry><entry>67</entry><entry>68</entry><entry>69</entry><entry>70</entry><entry>71</entry><entry>72</entry></row><row><entry>intraPredAngle</entry><entry>26</entry><entry>29</entry><entry>32</entry><entry>35</entry><entry>39</entry><entry>45</entry><entry>49</entry><entry>54</entry><entry>60</entry></row><row><entry>PredModeIntra</entry><entry>73</entry><entry>74</entry><entry>75</entry><entry>76</entry><entry/><entry/><entry/><entry/><entry/></row><row><entry>intraPredAngle</entry><entry>68</entry><entry>79</entry><entry>93</entry><entry>114</entry></row><row><entry namest="1" nameend="10" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0354" num="0341">When a current block is a non-square, and an intra-prediction mode for the current block which is obtained in S<b>2502</b> belongs to a transform range, the intra-prediction mode for the current block may be transformed into a wide angle intra-prediction mode. The transform range may be determined on the basis of at least one of a size, a shape, or a ratio of the current block. In this connection, the ratio may represent a ratio between a width and a height of the current block.</p><p id="p-0355" num="0342">When a current block is a non-square where a width is greater than a height, a transform range may be set from an intra-prediction mode index (for example, 66) of an top-right diagonal direction to (an intra-prediction mode index of the top-right diagonal direction&#x2212;N). In this connection, N may be determined on the basis of a ratio of the current block. When an intra-prediction mode for the current block belongs to a transform range, the intra-prediction mode may be transformed into a wide angle intra-prediction mode. The transform may be subtracting a predefined value from the intra-prediction mode, and the predefined value may be the total number (for example, 67) of intra-prediction modes excluding a wide angle intra-prediction mode.</p><p id="p-0356" num="0343">In the above example, intra-prediction mode from the number 66 to the number 53 may be respectively transformed into wide angle intra-prediction modes from the number &#x2212;1 to the number &#x2212;14.</p><p id="p-0357" num="0344">When a current block is a non-square where a height is greater than a width, a transform range may be set from an intra-prediction mode index (for example, 2) of a bottom-left diagonal direction to (the intra-prediction mode index of the lower-left diagonal direction+M). In this connection, M may be determined on the basis of a ratio of the current block. When an intra-prediction mode for the current block belongs to a transform range, the intra-prediction mode may be transformed into a wide angle intra-prediction mode. The transform may be adding a predefined value to the intra-prediction mode, and the predefined value may be the total number (for example, 65) of directional intra-prediction mode excluding a wide angle intra-prediction mode.</p><p id="p-0358" num="0345">In the above example, intra-prediction mode from the number 2 to the number 15 may be respectively transformed into wide angle intra-prediction modes from the number 67 to the number 80</p><p id="p-0359" num="0346">Hereinafter, intra-prediction modes belonging to a transform range are referred to as wide angle intra prediction replacement modes.</p><p id="p-0360" num="0347">A transform range may be determined on the basis of a ratio of the current block. In an example, Tables 4 and 5 respectively show a transform range of a case where 35 intra-prediction modes excluding a wide angle intra-prediction mode are defined, and a case where 67 intra-prediction modes excluding a wide angle intra-prediction mode are defined.</p><p id="p-0361" num="0000"><tables id="TABLE-US-00004" num="00004"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="161pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 4</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>Condition</entry><entry>Replaced Intra Prediction Modes</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>W/H = 2</entry><entry>Modes 2, 3, 4</entry></row><row><entry>W/H &#x3e; 2</entry><entry>Modes 2, 3, 4, 5, 6</entry></row><row><entry>W/H = 1</entry><entry>None</entry></row><row><entry>H/W = 1/2</entry><entry>Modes 32, 33, 34</entry></row><row><entry>H/W &#x3c; 1/2</entry><entry>Modes 30, 31, 32, 33, 34</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0362" num="0000"><tables id="TABLE-US-00005" num="00005"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="161pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 5</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>Condition</entry><entry>Replaced Intra Prediction Modes</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>W/H = 2</entry><entry>Modes 2, 3, 4, 5, 6, 7</entry></row><row><entry>W/H &#x3e; 2</entry><entry>Modes 2, 3, 4, 5, 6, 7, 8, 9, 10, 11</entry></row><row><entry>W/H = 1</entry><entry>None</entry></row><row><entry>H/W = 1/2</entry><entry>Modes 61, 62, 63, 64, 65, 66</entry></row><row><entry>H/W &#x3c; 1/2</entry><entry>Modes 57, 58, 59, 60, 61, 62, 63, 64, 65, 66</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0363" num="0348">As examples shown in Tables 4 and 5, the number of wide angle intra prediction replacement modes included in a transform range may vary according to a ratio of the current block.</p><p id="p-0364" num="0349">The ratio of the current block may be further subdivided to set a transform range as shown in Table 6 below.</p><p id="p-0365" num="0000"><tables id="TABLE-US-00006" num="00006"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="63pt" align="left"/><colspec colname="2" colwidth="154pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 6</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>Condition</entry><entry>Replaced Intra Prediction Modes</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>W/H = 16</entry><entry>Modes 12, 13, 14, 15</entry></row><row><entry>W/H = 8</entry><entry>Modes 12, 13</entry></row><row><entry>W/H = 4</entry><entry>Modes 2, 3, 4, 5, 6, 7, 8, 9, 10, 11</entry></row><row><entry>H/W = 2</entry><entry>Modes 2, 3, 4, 5, 6, 7</entry></row><row><entry>H/W = 1</entry><entry>None</entry></row><row><entry>W/H = 1/2</entry><entry>Modes 61, 62, 63, 64, 65, 66</entry></row><row><entry>W/H = 1/4</entry><entry>Modes 57, 58, 59, 60, 61, 62, 63, 64, 65, 66</entry></row><row><entry>W/H = 1/8</entry><entry>Modes 55, 56</entry></row><row><entry>H/W = 1/16</entry><entry>Modes 53, 54, 55, 56</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0366" num="0350">When the non-adjacent reference sample line is determined as the reference sample line for the current block or when the multi-line intra prediction encoding method for selecting one of the plurality of reference sample lines is used, the prediction method may be configured not to use the wide angle intra prediction mode. That is, although the current block has a non-square shape, and the intra prediction mode for the current block belongs to the transform range, the intra prediction mode for the current block may not be transformed into the wide angle intra prediction mode.</p><p id="p-0367" num="0351">Alternatively, when the intra prediction mode for the current block is determined as the wide angle intra prediction mode, the prediction method may be configured such that the non-adjacent reference sample lines are unavailable as the reference sample line for the current block or may be configured not to use the multi-line intra prediction encoding method for selecting one of the plurality of reference sample lines. When the multi-line intra prediction encoding method is not used, the adjacent reference sample line may be determined as the reference sample line for the current block.</p><p id="p-0368" num="0352">When the wide angle intra prediction mode is not used, each of refW and refH may be set to a sum of nTbW and nTbH. Accordingly, the non-adjacent reference sample line spaced from the current block by i may include (nTbW+nTbH+offsetX[i]) top reference samples and (nTbW+nTbH+offsetY[i]) left reference samples except for the left-top reference sample. That is, the non-adjacent reference sample line spaced from the current block by i may include (2nTbW+2nTbH+offsetX[i]+offsetY[i]+1) reference samples. For example, when a value of whRatio is greater than 1, a value of offsetX may be set to be larger than a value of offsetY. In one example, when the value of offsetX may be set to 1, and the value of offsetY may be set to 0. To the contrary, when the value of whRatio is smaller than 1, the value of offsetY may be set to be larger than the value of offsetX. In one example, the value of offsetX may be set to 0, and the value of offsetY may be set to 1.</p><p id="p-0369" num="0353">Since wide angle intra-prediction modes are used in addition to legacy intra-prediction modes, resource for encoding wide angle intra-prediction modes may be increased, and thus encoding efficiency may be reduced. Accordingly, rather than encoding a wide angle intra-prediction mode as it is, a replaced intra-prediction mode for the wide angle intra-prediction modes are encoded so as to improve encoding efficiency.</p><p id="p-0370" num="0354">In an example, when a current block is encoded by using a wide angle intra-prediction mode of the number 67, the number 2 that is a wide angle replacement intra-prediction mode of the number 67 may be encoded as an intra-prediction mode for the current block. In addition, when a current block is encoded by using a wide angle intra-prediction mode of the number &#x2212;1, the number 66 that is a wide angle replacement intra-prediction mode of the number &#x2212;1 may be encoded as an intra-prediction mode for the current block.</p><p id="p-0371" num="0355">The decoder may decode an intra-prediction mode for the current block, and determine whether or not the decoded intra-prediction mode belongs to a transform range. When the decoded intra-prediction mode is a wide angle replacement intra-prediction mode, the intra-prediction mode may be transformed into a wide angle intra-prediction mode.</p><p id="p-0372" num="0356">Alternatively, when a current block is encoded through a wide angle intra-prediction mode, the wide angle intra-prediction mode may be encoded as it is.</p><p id="p-0373" num="0357">Encoding of an intra prediction mode may be performed based on an MPM list described above. Specifically, when a neighboring block is encoded in a wide angle intra prediction mode, an MPM may be set based on a wide angle replacement intra prediction mode corresponding to the wide angle intra prediction mode.</p><p id="p-0374" num="0358">A residual image may be derived by subtracting a prediction image from an original image. In this connection, when the residual image is converted into a frequency domain, even though high frequency components are removed from frequency components, subjective image quality of the image does not drop significantly. Accordingly, when values of high frequency components are transformed into small values, or when values of high frequency components are set to 0, compression efficiency may be increased without causing large visual distortion. Reflecting the above feature, transform may be performed on a current block so as to decompose a residual image to two-dimensional frequency components. The transform may be performed by using transform methods such as DCT (discrete cosine transform), DST (discrete sine transform), etc.</p><p id="p-0375" num="0359">DCT is to decompose (or transform) a residual image into a two-dimensional frequency component by using cosine transform and DST is to compose (or transform) a residual image into a two-dimensional frequency component by using sine transform. As a result of transforming a residual image, frequency components may be represented as a base image. In an example, when DCT transform is performed for a N&#xd7;N sized block, N2 basic pattern components may be obtained. A size of each of basic pattern components included in a N&#xd7;N sized block may be obtained through transform. According to a used transform method, a size of a basic pattern component may be referred to as a DCT coefficient or a DST coefficient.</p><p id="p-0376" num="0360">A transform method DCT is mainly used to transform an image that a lot of non-zero low frequency components are distributed. A transform method DST is mainly used for an image that a lot of high frequency components are distributed.</p><p id="p-0377" num="0361">It is also possible to transform a residual image by using a transform method other than DCT or DST.</p><p id="p-0378" num="0362">Hereinafter, transforming a residual image into two-dimensional frequency components is referred to as two-dimensional image transform. In addition, a size of basic pattern components obtained by transform is referred to as a transform coefficient. In an example, a transform coefficient may mean a DCT coefficient or a DST coefficient. When both the after-described first transform and second transform are applied, a transform coefficient may mean a basic pattern component generated by a result of the second transform. In addition, a residual sample to which transform skip is applied is also referred to as a transform coefficient.</p><p id="p-0379" num="0363">A transform method may be determined in a unit of a block. A transform method may be determined based on at least one of a prediction encoding mode of a current block, a size of a current block or a shape of a current block. In an example, when a current block is encoded by an intra-prediction mode and a size of a current block is smaller than N&#xd7;N, transform may be performed by using a DST transform method. On the other hand, when the condition is not satisfied, transform may be performed by using a DCT transform method.</p><p id="p-0380" num="0364">Two-dimensional image transform may not be performed for some blocks of a residual image. Not performing two-dimensional image transform may be referred to as transform skip. The transform skip represents that the first transform and the second transform are not applied to the current block. When transform skip is applied, quantization may be applied to residual values for which transform is not performed.</p><p id="p-0381" num="0365">Whether transform skip is allowed for a current block may be determined based on at least one of a size or a shape of a current block. In an example, only when a size of a current block is smaller than a threshold value, transform skip may be applied. The threshold value is related to at least one of a width, a height or the number of samples of a current block, and may be defined as 32&#xd7;32, etc. Alternatively, transform skip may be allowed only for a square block. In an example, transform skip may be allowed for a 32&#xd7;32, 16&#xd7;16, 8&#xd7;8 or 4&#xd7;4 sized square block. Alternatively, only when a sub-partition intra encoding method is not used, transform skip may be allowed.</p><p id="p-0382" num="0366">Alternatively, when a sub-partition intra encoding method is applied to a current block, it may be determined for each sub-block whether to apply transform skip.</p><p id="p-0383" num="0367"><figref idref="DRAWINGS">FIG. <b>29</b></figref> is a diagram showing an example in which whether transform skip is performed or not is determined per sub-block.</p><p id="p-0384" num="0368">Transform skip may be applied only for part of a plurality of sub-blocks. In an example, as in an example shown in <figref idref="DRAWINGS">FIG. <b>29</b></figref>, it may be set to apply transform skip to a sub-block at a top position of a current block and not to apply transform skip for a sub-block at a bottom position.</p><p id="p-0385" num="0369">A transform type of a sub-block that transform skip is not allowed may be determined based on information signaled in a bitstream. In an example, a transform type may be determined based on tu_mts_idx which will be described after.</p><p id="p-0386" num="0370">Alternatively, a transform type of a sub-block may be determined based on a size of a sub-block. In an example, a horizontal directional transform type may be determined based on whether a width of a sub-block is equal to or greater than and/or equal to or less than a threshold value, and a vertical directional transform type may be determined based on whether a height of a sub-block is equal to or greater than and/or equal to or less than a threshold value.</p><p id="p-0387" num="0371">After performing transform on a current block by using DCT or DST, transform may be performed again on the transformed current block. In this connection, transform based on DCT or DST may be defined as first transform, and performing transform again on a block to which first transform is applied may be defined as second transform.</p><p id="p-0388" num="0372">First transform may be performed by using any one of a plurality of transform core candidates. In an example, first transform may be performed by using any one of DCT2, DCT8, or DST7.</p><p id="p-0389" num="0373">Different transform cores may be used for a horizontal direction and a vertical direction. Information representing a combination of a transform core of a horizontal direction and a transform core of a vertical direction may be signaled in a bitstream.</p><p id="p-0390" num="0374">A processing unit of first transform may differ with second transform. In an example, first transform may be performed on an 8&#xd7;8 block, and second transform may be performed on a 4&#xd7;4 sized sub-block within the transformed 8&#xd7;8 block. Alternatively, the second transform may be performed for transform coefficients which belong to 3 4&#xd7;4 sized sub-blocks. The 3 sub-blocks may include a sub-block positioned at the top-left of a current block, a sub-block neighboring the right of the sub-block and a sub-block neighboring the bottom of the sub-block. Alternatively, the second transform may be performed for a 8&#xd7;8 sized block.</p><p id="p-0391" num="0375">It is also possible that transform coefficients in a remaining region on which the second transform is not performed may be set to 0.</p><p id="p-0392" num="0376">Alternatively, first transform may be performed on a 4&#xd7;4 block, and second transform may be performed on a region having an 8&#xd7;8 size including the transformed 4&#xd7;4 block.</p><p id="p-0393" num="0377">Information representing whether or not to perform second transform may be signaled in a bitstream. In an example, a flag representing whether the second transform is performed or not, or index information specifying whether the second transform is performed or not and a transform kernel used for the second transform may be signaled. In an example, when the index information is 0, it represents that the second transform is not performed for a current block. On the other hand, when the index information is greater than 0, a transform kernel for the second transform may be determined by the index information.</p><p id="p-0394" num="0378">Alternatively, whether to perform the second transform may be determined based on whether a horizontal directional transform core and a vertical directional transform core are identical with each other. In one example, the second transform may be performed only when the horizontal directional transform core and the vertical directional transform core are identical with each other. Alternatively, the second transform may be performed only when the horizontal directional transform core and the vertical directional transform core are different from each other.</p><p id="p-0395" num="0379">Alternatively, the second transform may be allowed only when a predefined transform core is used for the horizontal directional transform and the vertical directional transform. In one example, when a DCT2 transform core is used for transform in the horizontal direction and transform in the vertical direction, the second transform may be allowed. Alternatively, when a sub-partition intra encoding method is applied to a current block, the second transform may be allowed only when a DCT2 transform core is used for transform in a horizontal direction and transform in a vertical direction.</p><p id="p-0396" num="0380">Alternatively, it may be determined whether to perform the second transform based on the number of non-zero transform coefficients of the current block. In one example, when the number of the non-zero transforms coefficient of the current block is smaller than or equal to a threshold, the prediction method may be configured not to use the second transform. When the number of the non-zero transform coefficients of the current block is greater than the threshold, the prediction method may be configured to use the second transform. As long as the current block is encoded using intra prediction, the prediction method may be configured to use the second transform.</p><p id="p-0397" num="0381">Alternatively, whether the second transform is performed or not may be determined based on a position of the last non-zero transform coefficient of a current block. In an example, when at least one of an x-axis coordinate or a y-axis coordinate of the last non-zero transform coefficient of a current block is greater than a threshold value, or when at least one of an x-axis coordinate or a y-axis coordinate of a sub-block to which the last non-zero transform coefficient of a current block belongs is greater than a threshold value, the second transform may not be performed. In this case, a threshold value may be predefined in an encoding device and a decoding device. Alternatively, a threshold value may be determined based on a size or a shape of a current block.</p><p id="p-0398" num="0382">Alternatively, when only a transform coefficient of a DC component exists in a current block, it may be set not to perform the second transform. In this case, a DC component represents a transform coefficient at a top-left position in a current block.</p><p id="p-0399" num="0383">Alternatively, when matrix-based intra-prediction is applied to a current block, it may be set not to perform the second transform.</p><p id="p-0400" num="0384">Information representing a transform type of a current block may be signaled in a bitstream. The information may be index information, tu_mts_idx, representing one of combinations of a transform type for a horizontal direction and a transform type for a vertical direction.</p><p id="p-0401" num="0385">Based on transform type candidates specified by index information, tu_mts_idx, a transform core for a vertical direction and a transform core for a horizontal direction may be determined. Table 7 represents transform type combinations according to tu_mts_idx.</p><p id="p-0402" num="0000"><tables id="TABLE-US-00007" num="00007"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="91pt" align="center"/><colspec colname="2" colwidth="126pt" align="center"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 7</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>transform type</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="91pt" align="center"/><colspec colname="2" colwidth="35pt" align="center"/><colspec colname="3" colwidth="91pt" align="center"/><tbody valign="top"><row><entry>tu_mts_idx</entry><entry>horizontal</entry><entry>vertical</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row><row><entry>0</entry><entry>DCT-II</entry><entry>DCT-II</entry></row><row><entry>1</entry><entry>DST-VII</entry><entry>DST-VII</entry></row><row><entry>2</entry><entry>DCT-VIII</entry><entry>DST-VII</entry></row><row><entry>3</entry><entry>DST-VII</entry><entry>DCT-VIII</entry></row><row><entry>4</entry><entry>DCT-VIII</entry><entry>DCT-VIII</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0403" num="0386">A transform type may be determined as one of DCT2, DST7 or DCT8. Alternatively, transform skip may be inserted in a transform type candidate.</p><p id="p-0404" num="0387">When Table 7 is used, DCT2 may be applied in a horizontal direction and in a vertical direction when tu_mts_idx is 0. When tu_mts_idx is 2, DCT8 may be applied in a horizontal direction and DCT7 may be applied in a vertical direction.</p><p id="p-0405" num="0388">When a sub-partition intra encoding method is applied, a transform core of a sub-block may be independently determined. In an example, information for specifying a transform type combination candidate may be encoded and signaled per sub-block. Accordingly, a transform core between sub-blocks may be different.</p><p id="p-0406" num="0389">Alternatively, sub-blocks may use the same transform type. In this case, tu_mts_idx specifying a transform type combination candidate may be signaled only for the first sub-block. Alternatively, tu_mts_idx may be signaled in a coding block level and a transform type of sub-blocks may be determined by referring to tu_mts_idx signaled in a coding block level. Alternatively, a transform type may be determined based on at least one of a size, a shape or an intra-prediction mode of one among sub-blocks and a determined transform type may be set to be used for all sub-blocks.</p><p id="p-0407" num="0390"><figref idref="DRAWINGS">FIG. <b>30</b></figref> is a diagram showing an example in which sub-blocks use the same transform type.</p><p id="p-0408" num="0391">When a coding block is partitioned in a horizontal direction, a transform type of a sub-block at a top position of a coding block (Sub-CU<b>0</b>) may be set the same as that of a sub-block at a bottom position (Sub-CU<b>1</b>). In an example, as in an example shown in <figref idref="DRAWINGS">FIG. <b>30</b>(<i>a</i>)</figref>, when a horizontal transform type and a vertical transform type are determined based on tu_mts_idx signaled for a top sub-block, a determined transform type may be also applied to a bottom sub-block.</p><p id="p-0409" num="0392">When a coding block is partitioned in a vertical direction, a transform type of a sub-block at a left position of a coding block (Sub-CU<b>0</b>) may be set the same as that of a sub-block at a right position (Sub-CU<b>1</b>). In an example, as in an example shown in <figref idref="DRAWINGS">FIG. <b>30</b>(<i>b</i>)</figref>, when a horizontal transform type and a vertical transform type are determined based on tu_mts_idx signaled for a left sub-block, a determined transform type may be also applied to a right sub-block.</p><p id="p-0410" num="0393">Whether index information is encoded or not may be determined based on at least one of a size or a shape of a current block, the number of non-zero coefficients, whether the second transform is performed or whether a sub-partition intra encoding method is applied. In an example, when a sub-partition intra encoding method is applied to a current block, or when the number of non-zero coefficients is equal to or smaller than a threshold value, signaling of index information may be omitted. When signaling of index information is omitted, a default transform type may be applied to a current block.</p><p id="p-0411" num="0394">A default transform type may include at least one of DCT2 or DST7. When there are a plurality of default transform types, one of a plurality of default transform types may be selected by considering at least one of a size, a shape or an intra-prediction mode of a current block, whether the second transform is performed or whether a sub-partition intra encoding method is applied. In an example, one of a plurality of transform types may be determined as a horizontal directional transform type based on whether a width of a current block is in a preset range, and one of a plurality of transform types may be determined as a vertical directional transform type based on whether a height of a current block is in a preset range. Alternatively, a default mode may be determined differently according to a size, a shape or an intra-prediction mode of a current block or whether the second transform is performed.</p><p id="p-0412" num="0395">Alternatively, when only a transform coefficient of a DC component exists in a current block, a horizontal directional transform type and a vertical directional transform type may be set as a default transform type. In an example, when only a transform coefficient of a DC component exists in a current block, a horizontal directional transform type and a vertical directional transform type may be set as DCT2.</p><p id="p-0413" num="0396">A threshold value may be determined based on a size or a shape of a current block. In an example, when a size of a current block is equal to or smaller than 32&#xd7;32, a threshold value may be set to be 2, and when a current block is greater than 32&#xd7;32 (e.g., when a current block is a 32&#xd7;64 or 64&#xd7;32 sized coding block) , a threshold value may be set to be 4.</p><p id="p-0414" num="0397">A plurality of look-up tables may be prestored in an encoding device/a decoding device. At least one of an index value assigned to transform type combination candidates, a type of transform type combination candidates or the number of transform type combination candidates may be different for each of the plurality of look-up tables.</p><p id="p-0415" num="0398">Based on at least one of a size, a shape or an intra-prediction mode of a current block, whether the second transform is applied or not, or whether transform skip is applied to a neighboring block, a look-up table for a current block may be selected.</p><p id="p-0416" num="0399">In an example, when a size of a current block is equal to or less than 4&#xd7;4, or when a current block is encoded by inter-prediction, a first look-up table may be used and when a size of a current block is greater than 4&#xd7;4, or when a current block is encoded by intra-prediction, a second look-up table may be used.</p><p id="p-0417" num="0400">Alternatively, information indicating one of a plurality of look-up tables may be signaled in a bitstream. A decoding device may select a look-up table for a current block based on the information.</p><p id="p-0418" num="0401">In another example, an index assigned to a transform type combination candidate may be adaptively determined based on at least one of a size, a shape, a prediction encoding mode or an intra-prediction mode of a current block, whether the second transform is applied or not, or whether transform skip is applied to a neighboring block. In an example, an index assigned to transform skip when a size of a current block is 4&#xd7;4 may be smaller than an index assigned to transform skip when a size of a current block is greater than 4&#xd7;4. Concretely, when a size of a current block is 4&#xd7;4, an index 0 may be assigned to transform skip and when a current block is greater than 4&#xd7;4 and equal to or less than 16&#xd7;16, an index greater than 0 (e.g., an index 1) may be assigned to transform skip. When a current block is greater than 16&#xd7;16, the maximum value (e.g., 5) may be assigned to an index of transform skip.</p><p id="p-0419" num="0402">Alternatively, when a current block is encoded by inter-prediction, an index 0 may be assigned to transform skip. When a current block is encoded by intra-prediction, an index greater than 0 (e.g., an index 1) may be assigned to transform skip.</p><p id="p-0420" num="0403">Alternatively, when a current block is a 4&#xd7;4 sized block encoded by inter-prediction, an index 0 may be assigned to transform skip. On the other hand, when a current block is not encoded by inter-prediction, or when a current block is greater than 4&#xd7;4, an index greater than 0 (e.g., an index 1) may be assigned to transform skip.</p><p id="p-0421" num="0404">It is also possible to use transform type combination candidates different from transform type combination candidates enumerated in Table 9. In an example, a transform type combination candidate which is consisted of transform skip applied to one of a horizontal directional transform or a vertical directional transform and a transform core such as DCT2, DCT8 or DST7, etc. applied to the other can be used. In this case, whether transform skip will be used as a transform type candidate for a horizontal direction or a vertical direction may be determined based on at least one of a size (e.g., a width and/or a height), a shape, a prediction encoding mode or an intra-prediction mode of a current block.</p><p id="p-0422" num="0405">Information representing whether index information for determining a transform type of a current block is explicitly signaled may be signaled in a bitstream. In an example, sps_explicit_intra_mts_flag, information representing whether an explicit transform type determination is allowed for a block encoded by intra-prediction, and/or sps_explicit_inter_mts_flag, information representing whether an explicit transform type determination is allowed for a block encoded by inter-prediction, may be signaled at a sequence level.</p><p id="p-0423" num="0406">When an explicit transform type determination is allowed, a transform type of a current block may be determined based on index information, tu_mts_idx, signaled in a bitstream. On the other hand, when an explicit transform type determination is not allowed, a transform type may be determined based on at least one of a size or a shape of a current block, whether it is allowed to perform transform in a unit of a sub-block, a position of a sub-block including a non-zero transform coefficient, whether the second transform is performed or not, or whether a sub-partition intra encoding method is applied or not. In an example, a horizontal directional transform type of a current block may be determined based on a width of a current block and a vertical directional transform type of a current block may be determined based on a height of a current block. For example, when a width of a current block is smaller than 4 or greater than 16, a horizontal directional transform type may be determined as DCT2. Otherwise, a horizontal directional transform type may be determined as DST7. When a height of a current block is smaller than 4 or greater than 16, a vertical directional transform type may be determined as DCT2. Otherwise, a vertical directional transform type may be determined as DST7. In this case, a threshold value which is to be compared with a width and a height may be determined based on at least one of a size, a shape or an intra-prediction mode of a current block to determine a horizontal directional transform type and a vertical directional transform type.</p><p id="p-0424" num="0407">Alternatively, when a current block has a square shape whose height and width are the same, a horizontal directional transform type and a vertical directional transform type may be set the same, but when a current block has a non-square shape whose height and width are different from each other, a horizontal directional transform type and a vertical directional transform type may be set differently. In an example, when a width of a current block is greater than a height, a horizontal directional transform type may be determined as DST7 and a vertical directional transform type may be determined as DCT2. When a height of a current block is greater than a width, a vertical directional transform type may be determined as DST7 and a horizontal directional transform type may be determined as DCT2.</p><p id="p-0425" num="0408">The number and/or type of transform type candidates or the number and/or type of transform type combination candidates may be different according to whether an explicit transform type determination is allowed or not. In an example, when an explicit transform type determination is allowed, DCT2, DST7 and DCT8 may be used as transform type candidates. Accordingly, each of a horizontal directional transform type and a vertical directional transform type may be set as DCT2, DST8 or DCT8. When an explicit transform type determination is not allowed, only DCT2 and DST7 may be used as a transform type candidate. Accordingly, each of a horizontal directional transform type and a vertical directional transform type may be determined as DCT2 or DST7.</p><p id="p-0426" num="0409">The decoder may perform inverse-transform (second inverse-transform) to the second transform and may perform inverse-transform (first inverse-transform) to the first transform resultant from the second inverse-transform. As a result of performing the second inverse-transform and the first inverse-transform, residual signals for the current block may be obtained.</p><p id="p-0427" num="0410">When transform and quantization are performed by the encoder, the decoder may obtain the residual block via inverse-quantization and inverse-transform. The decoder may add the prediction block and the residual block to each other to obtain the reconstructed block for the current block.</p><p id="p-0428" num="0411">When the reconstructed block of the current block is obtained, loss of information as occurring in the process of the quantization and encoding may be reduced via the in-loop filtering. The in-loop filter may include at least one of a deblocking filter, a sample adaptive offset filter (SAO), or an adaptive loop filter (ALF). Hereinafter, a reconstructed block before an in-loop filter is applied is referred to as a first reconstructed block and a reconstructed block after an in-loop filter is applied is referred to as a second reconstructed block.</p><p id="p-0429" num="0412">The second reconstructed block may be obtained by applying at least one of a deblocking filter, SAO or ALF to the first reconstructed block. In this connection, SAO or ALF may be applied after the deblocking filter is applied.</p><p id="p-0430" num="0413">A deblocking filter is to alleviate quality degradation (e.g. Blocking Artifact) on a boundary of a block which occurs as quantization is performed per block. To apply the deblocking filter, a blocking strength (BS) between the first reconstructed block and a neighboring reconstructed block may be determined.</p><p id="p-0431" num="0414"><figref idref="DRAWINGS">FIG. <b>31</b></figref> is a flow diagram showing a process of determining a blocking strength.</p><p id="p-0432" num="0415">In an example shown in <figref idref="DRAWINGS">FIG. <b>31</b></figref>, P represents a first reconstructed block and Q represents a neighboring reconstructed block. In this connection, the neighboring reconstructed block may neighbor a left or top of the current block.</p><p id="p-0433" num="0416">An example shown in <figref idref="DRAWINGS">FIG. <b>31</b></figref> showed that a blocking strength is determined considering a prediction encoding mode of P and Q, whether a transform coefficient which is not 0 is included, whether inter-prediction is performed by using the same reference picture or whether the difference value of motion vectors is equal to or greater than a threshold value.</p><p id="p-0434" num="0417">Based on a blocking strength, whether a deblocking filter is applied may be determined. In an example, when the blocking strength is 0, filtering may not be performed.</p><p id="p-0435" num="0418">SAO is to alleviate ringing artifact which occurs as quantization is performed in a frequency region. SAO may be performed by adding or subtracting an offset determined by considering a pattern of a first reconstructed image. The determination method of the offset includes Edge Offset (EO) or Band Offset (BO). EO represents a method determining the offset of a current sample according to a pattern of neighboring pixels. BO represents a method applying a common offset to a group of pixels with a similar brightness value in a region. Concretely, pixel brightness may be partitioned into 32 uniform sections and pixels with a similar brightness value may be set as one group. In an example, 4 adjacent bands among 32 bands may be set as one group and the same offset value may be applied to samples belonging to 4 bands.</p><p id="p-0436" num="0419">ALF is a method of generating a second reconstructed image by applying a filter with a predefined size/shape to a first reconstructed image or a reconstructed image that a deblocking filter is applied. The following Equation 8 represents an example in which ALF is applied.</p><p id="p-0437" num="0000"><maths id="MATH-US-00002" num="00002"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mrow>      <msup>       <mi>R</mi>       <mo>&#x2032;</mo>      </msup>      <mo>(</mo>      <mrow>       <mi>i</mi>       <mo>,</mo>       <mi>j</mi>      </mrow>      <mo>)</mo>     </mrow>     <mo>=</mo>     <mrow>      <munderover>       <mo>&#x2211;</mo>       <mrow>        <mi>k</mi>        <mo>=</mo>        <mrow>         <mo>-</mo>         <mfrac>          <mi>N</mi>          <mn>2</mn>         </mfrac>        </mrow>       </mrow>       <mfrac>        <mi>N</mi>        <mn>2</mn>       </mfrac>      </munderover>      <mrow>       <munderover>        <mo>&#x2211;</mo>        <mrow>         <mi>l</mi>         <mo>=</mo>         <mrow>          <mo>-</mo>          <mfrac>           <mi>N</mi>           <mn>2</mn>          </mfrac>         </mrow>        </mrow>        <mfrac>         <mi>N</mi>         <mn>2</mn>        </mfrac>       </munderover>       <mrow>        <mrow>         <mi>f</mi>         <mo>&#x2061;</mo>         <mo>(</mo>         <mrow>          <mi>k</mi>          <mo>,</mo>          <mi>l</mi>         </mrow>         <mo>)</mo>        </mrow>        <mo>&#xb7;</mo>        <mrow>         <mi>R</mi>         <mo>&#x2061;</mo>         <mo>(</mo>         <mrow>          <mrow>           <mi>i</mi>           <mo>+</mo>           <mi>k</mi>          </mrow>          <mo>,</mo>          <mrow>           <mi>j</mi>           <mo>+</mo>           <mi>l</mi>          </mrow>         </mrow>         <mo>)</mo>        </mrow>       </mrow>      </mrow>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>[</mo>     <mrow>      <mi>Equation</mi>      <mo>&#x2062;</mo>      <mtext>   </mtext>      <mn>8</mn>     </mrow>     <mo>]</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0438" num="0420">Any one of predefined filter candidates may be selected in a basis of a picture, a coding tree unit, a coding block, a prediction block or a transform block. At least one of a size or shape of each filter candidate may be different.</p><p id="p-0439" num="0421"><figref idref="DRAWINGS">FIG. <b>32</b></figref> represents predefined filter candidates.</p><p id="p-0440" num="0422">As in an example shown in <figref idref="DRAWINGS">FIG. <b>32</b></figref>, at least any one of a 5&#xd7;5, 7&#xd7;7 or 9&#xd7;9 sized diamond shape may be selected.</p><p id="p-0441" num="0423">Only a 5&#xd7;5 sized diamond shape may be used for a chroma component.</p><p id="p-0442" num="0424">A method of partitioning a picture into a plurality of regions and encoding/decoding the plurality of regions in parallel may be considered for the real-time or low delay encoding of a high resolution image such as a panoramic video, a 360-degree video or 4K/8K UHD (Ultra High Definition). Concretely, according to a purpose of processing, a picture may be partitioned into tiles or slices (or tile groups).</p><p id="p-0443" num="0425">A tile represents a base unit for parallel encoding/decoding. Each tile may be processed in parallel. A tile may have a rectangular shape. Alternatively, a non-rectangular tile may be allowed.</p><p id="p-0444" num="0426">Information representing whether a non-rectangular tile is allowed or whether there is a non-rectangular tile may be signaled in a bitstream.</p><p id="p-0445" num="0427">In encoding/decoding a tile, it may be set not to use data of other tile. A parallel processing of tiles may be supported by removing encoding/decoding dependency between tiles. Concretely, a probability table of CABAC (Context Adaptive Binary Arithmetic Coding) context may be initialized per tile and an in-loop filter may be set not to be applied on a boundary of tiles. In addition, data in other tile may not be used as a candidate for deriving a motion vector. For example, data in other tile may be set not to be used as a merge candidate, a motion vector prediction candidate (AMVP candidate) or a motion information candidate. In addition, data in another tile may be set not to be used for context computation of a symbol.</p><p id="p-0446" num="0428">Information on video encoding/decoding may be signaled by a slice header. Information signaled by the slice header may be commonly applied to coding tree units or tiles included in the slice. The slice also can be referred to as a tile group.</p><p id="p-0447" num="0429"><figref idref="DRAWINGS">FIG. <b>33</b></figref> is a diagram showing a picture partitioning method according to an embodiment of the present disclosure.</p><p id="p-0448" num="0430">First, whether a current picture is partitioned into a plurality of processing units may be determined S<b>3310</b>. In this connection, a processing unit may include at least one of a tile or a slice. In an example, a syntax, no_pic_partition_flag, indicating whether a current picture is partitioned into a plurality of tiles or slices, may be signaled in a bitstream. If a value of the syntax, no_pic_partition_flag, is 0, it represents that a current picture is partitioned into at least one tile or at least one slice. On the other hand, if a value of a syntax, no_pic_partition_flag, is 1, it represents that a current picture is not partitioned into a plurality of tiles or slices.</p><p id="p-0449" num="0431">When it is determined that a current picture is not to be partitioned into a plurality of processing units, a partitioning process of the current picture may be ended. In this connection, it may be understood that the current picture is composed of a single tile and a single slice (or a single tile group).</p><p id="p-0450" num="0432">Alternatively, information representing whether a plurality of tiles exist in a picture may be signaled in a bitstream. The information may include at least one of a 1-bit flag representing whether a plurality of tiles exist in a picture or information specifying the number of tiles in a picture.</p><p id="p-0451" num="0433">When it is determined that a current picture is to be partitioned into a plurality of processing units, tile partitioning information may be signaled in a bitstream. A picture may be partitioned into at least one tile based on the signaled tile partitioning information S<b>3320</b>.</p><p id="p-0452" num="0434">When a current picture is partitioned into a plurality of tiles, a slice may be determined by combining a plurality of tiles or partitioning a tile S<b>3330</b>.</p><p id="p-0453" num="0435">Hereinafter, according to the present disclosure, a tile partitioning method and a slice determination method will be described in detail.</p><p id="p-0454" num="0436"><figref idref="DRAWINGS">FIG. <b>34</b></figref> represents an example in which a picture is partitioned into a plurality of tiles.</p><p id="p-0455" num="0437">A tile may include at least one coding tree unit. A boundary of the tile may be set to match a boundary of a coding tree unit. In other words, a partitioning type that one coding tree unit is partitioned into plural may not be allowed.</p><p id="p-0456" num="0438">When a picture is partitioned into a plurality of tiles, a height of adjacent tiles or a width of adjacent tiles may be set to have the same value.</p><p id="p-0457" num="0439">In an example, as in an example shown in <figref idref="DRAWINGS">FIG. <b>34</b></figref>, a height of tiles belonging to the same tile row and/or a width of tiles belonging to the same tile column may be set the same. Tiles belonging to the same tile row may be referred to as a horizontal directional tile set and tiles belonging to the same tile column may be referred to as a vertical directional tile set.</p><p id="p-0458" num="0440">Alternatively, information representing whether a width and/or a height of a tile to be encoded/decoded is set the same as a width and/or a height of a previous tile may be signaled.</p><p id="p-0459" num="0441">Information representing a partitioning shape of a picture may be signaled in a bitstream. The information may be encoded and signaled by a picture parameter set, a sequence parameter set or a slice header.</p><p id="p-0460" num="0442">Information representing a partitioning shape of a picture may include at least one of information indicating whether tiles are partitioned in a uniform size, information representing the number of tile columns or information representing the number of tile rows. In this case, the number of tile columns represents the number of vertical directional tile sets and the number of tile rows represents the number of horizontal directional tile sets.</p><p id="p-0461" num="0443">Information indicating whether tiles are partitioned in a uniform size may be a 1-bit flag, uniform spacing flag. When it is determined that a picture is partitioned in a uniform size, remaining tiles except for tiles adjacent to a right and/or bottom boundary of the picture may have the same size.</p><p id="p-0462" num="0444">When it is determined that tiles are partitioned in an uniform size, a syntax, tile_cols_width_minus1, representing a width of a tile, and a syntax, tile_rows_height_minus1, representing a height of a tile may be signaled.</p><p id="p-0463" num="0445">A syntax, tile_cols_width_minus1, represents a value subtracting 1 from the number of coding tree unit columns included by a tile in an uniform size. A syntax, tile_rows_height_minus1, represents a value subtracting 1 from the number of coding tree unit rows included by a tile in an uniform size.</p><p id="p-0464" num="0446">The last tile column may have a width value specified by a syntax, tile_cols_width_minus1, or a value smaller than it. In addition, the last tile row may have a height value specified by a syntax, tile_rows_height_minus1, or a value smaller than it. In an example, when an index of the last tile column is m, a value subtracting a sum of widths of the 0-th to (m&#x2212;1)-th tile columns from a width of a current picture may be set as a width of the last tile column. In an example, when an index of the last tile row is n, a value subtracting a sum of heights of the 0-th to (n&#x2212;1)-th tile rows from a height of a current picture may be set as a height of the last tile row. In other words, a width of a tile positioned on a right boundary of a current picture and/or a height of a tile positioned on a lower boundary of a current picture may be respectively smaller than or the same as a width and/or a height of other tile.</p><p id="p-0465" num="0447">As a picture is partitioned by using at least one of a vertical line or a horizontal line across a picture, each tile belongs to a different column and/or row. To determine a partitioning shape of the picture, information representing the number of tile columns and/or tile rows may be signaled. In an example, information, num_tile_row_minus1, representing the number of tile rows, and information, num_tile_column_minus1, representing the number of tile columns generated by partitioning the picture may be signaled in a bitstream. A syntax, num_tile_row_minus1, represents a value subtracting 1 from the number of tile rows and a syntax, num_tile_column_minus1, represents a value subtracting 1 from the number of tile columns.</p><p id="p-0466" num="0448">In an example shown in <figref idref="DRAWINGS">FIG. <b>34</b></figref>, the number of tile columns is 4 and the number of tile rows is 3. Accordingly, num_tile_columns_minus1 may represent 3 and num_tile_rows_minus1 may represent 2.</p><p id="p-0467" num="0449">A syntax, num_tile_column_minus1, representing the number of tile columns, and/or a syntax, num_tile_rows_minus1, representing the number of tile rows may be signaled when a value of a syntax, uniform_tile_spacing_flag, is 0. In other words, when a current picture is determined not to be partitioned into tiles whose height and width are uniform, a syntax, num_tile_column_minus1, representing the number of tile columns, and/or a syntax, num_tile_rows_minus1, representing the number of tile rows may be signaled.</p><p id="p-0468" num="0450">A syntax representing a width of each tile column and a syntax representing a height of each tile row may be signaled in a bitstream. In an example, tile_cols_width_minus1[i] may represent a width of the i-th tile column and tile_rows_height_minus1[j] may represent a height of the j-th tile row.</p><p id="p-0469" num="0451">A syntax, tile_cols_width_minus1[i], represents a value subtracting 1 from the number of coding tree unit columns configuring the i-th tile column. Signaling of a syntax, tile_cols_width_minus1[i], may be omitted for the last tile column. A width of the last tile column may be derived by subtracting a width of previous tile columns from a width of a current picture.</p><p id="p-0470" num="0452">A syntax, tile_rows_height_minus1[j], represents a value subtracting 1 from the number of coding tree unit rows constituting the j-th tile row. Signaling of a syntax, tile_rows_height_minus1[j], may be omitted for the last tile row. A height of the last tile row may be derived by subtracting a height of previous tile rows from a height of a current picture.</p><p id="p-0471" num="0453">Meanwhile, information representing a size of a coding tree unit may be signaled through a sequence parameter set or through a picture parameter set.</p><p id="p-0472" num="0454">One tile may be configured with at least one coding tree unit. Remaining tiles excluding a tile adjacent to the right or the lower boundary of a picture may be set not to be configured by including a region smaller than a coding tree unit. In other words, the boundary of a tile matches that of a coding tree unit.</p><p id="p-0473" num="0455">According to a partitioning shape of a picture, tiles may have the same size in all regions excluding a picture boundary. Alternatively, a height of tiles which are adjacent horizontally may be set to be the same or a width of tiles which are adjacent vertically may be set to be the same.</p><p id="p-0474" num="0456">Information representing whether a current picture is partitioned into a plurality of tiles may be signaled in a bitstream. In an example, a syntax, single_tile_in_pic_flag, may be signaled in a bitstream. When a syntax, single_tile_in_pic_flag, is 1, it represents that a current picture is not partitioned into a plurality of tiles. On the other hand, when single_tile_in_pic_flag is 0, it represents that a current picture may be partitioned into a plurality of tiles.</p><p id="p-0475" num="0457">When it is determined that a current picture may be partitioned into a plurality of tiles, at least one of information for determining the number of tile columns and tile rows, information representing whether tiles are uniformly partitioned or information for determining a size of a tile column and a tile row may be encoded.</p><p id="p-0476" num="0000"><tables id="TABLE-US-00008" num="00008"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="168pt" align="left"/><colspec colname="2" colwidth="49pt" align="center"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 8</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>pic_parameter_set_rbsp ( ) {</entry><entry/></row><row><entry>&#x2003;pps_pic_parameter_set_id</entry><entry>ue (v)</entry></row><row><entry>&#x2003;pps_seq_parameter_set_id</entry><entry>ue (v)</entry></row><row><entry>&#x2003;transform_skip_enabled_flag</entry><entry>&#x2002;u (1)</entry></row><row><entry>&#x2003;single_tile_in_pic_flag</entry><entry>&#x2002;u (1)</entry></row><row><entry>&#x2003;if( !single_tile_in_pic_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;num_tile_columns_minus1</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;num_tile_rows_minus1</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;uniform_tile_spacing_flag</entry><entry>&#x2002;u (1)</entry></row><row><entry>&#x2003;&#x2003;if ( !uniform_tile_spacing_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;for ( i = 0; i &#x3c; num_tile_columns_minus1; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;tile_column_width_minus1[ i ]</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for ( i = 0; i &#x3c; num_tile_rows_minus1; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;tile_row_height_minus1[ i ]</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0477" num="0458">Information for determining a tile size may be encoded and signaled. In an example, a syntax element, tile_width_minus1[i], representing a width of the i-th tile column, and a syntax element, tile_height_minus1[i], representing a height of the i-th tile row may be encoded in a bitstream.</p><p id="p-0478" num="0459">A size of a current tile column or a current tile row may be derived based on size information of a previous tile column or a previous tile row, instead of signaling size information of each tile column or each tile row.</p><p id="p-0479" num="0460">For it, information for specifying the number of tile columns whose width is explicitly signaled in a current picture may be signaled in a bitstream. In an example, a syntax, num_exp_tile_columns_minus1, for determining the number of tile columns whose width is signaled, may be signaled in a bitstream. A syntax, num_exp_tile_columns_minus1, may be a value subtracting 1 from the number of tile columns whose width is signaled.</p><p id="p-0480" num="0461">As many as the number determined based on a syntax, num_exp_tile_columns_minus1, a syntax for specifying a width of a tile column may be encoded and signaled. In an example, a syntax, tile_width_minus1[i], representing a width of the i-th tile column, may be signaled in a bitstream. A syntax, tile_width_minus1[i], may represent a value subtracting 1 from the number of coding tree unit columns included in a tile row.</p><p id="p-0481" num="0462">When an index i of a tile column is smaller than the number of tile columns whose width is explicitly signaled, a width of the corresponding tile column may be determined based on a syntax, tile_width_minus1[i], signaled in a bitstream.</p><p id="p-0482" num="0463">On the other hand, When an index j of a tile column is equal to or greater than the number of tile columns whose width is explicitly signaled, a width of the corresponding tile column may be determined based on a syntax, tile_width_minus1[l], which is signaled last. In this case, l may represent an index of a tile column whose width is signaled last and may be an integer smaller than j. In an example, when a value subtracting a width of previous tile columns from a width of a current picture is equal to or greater than a value adding 1 to a syntax, tile_width_minus1[l], a width of a tile column j may be set as a value adding 1 to a syntax, tile_width_minus1[l]. On the other hand, when a value subtracting widths of previous tile columns from a width of a current picture is smaller than a value adding 1 to a syntax, tile_width_minus1[l], a difference value subtracting widths of previous tile columns from a width of a current picture may be set as a width of a tile column j.</p><p id="p-0483" num="0464">Table 9 shows a process in which a width of a tile column is determined.</p><p id="p-0484" num="0000"><tables id="TABLE-US-00009" num="00009"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="21pt" align="left"/><colspec colname="2" colwidth="196pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 9</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;</entry><entry>remainingWidthInCtbsY = PicWidthInCtbsY</entry></row><row><entry/><entry>for ( i = 0; i &#x3c;= num_exp_tile_columns_minus1; i++ ) {</entry></row><row><entry/><entry>&#x2003;&#x2003;colWidth[ i ] = tile_column_width_minus1[ i ] + 1</entry></row><row><entry/><entry>&#x2003;&#x2003;remainingWidthInCtbsY = colWidth[ i ]</entry></row><row><entry/><entry>}</entry></row><row><entry/><entry>uniformTileColWidth =</entry></row><row><entry/><entry>tile_column_width_minus1[ num_exp_tile_columns_minus1 ] + 1</entry></row><row><entry/><entry>while ( remainingWidthInCtbsY &#x3e;= uniformTileColWidth ) {</entry></row><row><entry/><entry>&#x2003;&#x2003;colWidth[ i++ ] = uniformTileColWidth</entry></row><row><entry/><entry>&#x2003;&#x2003;remainingWidthInCtbsY &#x2212;= uniformTileColWidth</entry></row><row><entry/><entry>}</entry></row><row><entry/><entry>if( remainingWidthInCtbsY &#x3e; 0 )</entry></row><row><entry/><entry>&#x2003;&#x2003;colWidth[ i++ ] = remainingWidthInCtbsY</entry></row><row><entry/><entry>NumTileColumns = i</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0485" num="0465">In Table 9, a variable, PicWidthInCtbsY, represents the number of coding tree unit columns included by a current picture. In an example, a variable, PicWidthInCtbsY, may be derived as in the following Equation 9.</p><p id="p-0486" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>PicWidthInCtbs<i>Y</i>=Ceil(pic_width_in_luma_samples/CtbSize<i>Y</i>) &#x2003;&#x2003;[Equation 9]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0487" num="0466">A variable, reminingWidthInCtbsY, represents a value subtracting accumulated widths of tile columns from a variable, PicWidthInCtbsY. In an example, for a tile column whose index is reminingWidthInCtbsY may be derived by subtracting a value which is a sum of widths from the 0-th to (i&#x2212;1)-th tile columns from PicWidthInCtbsY.</p><p id="p-0488" num="0467">As in an example shown in Table 9, a variable, uniformTileColWidth, may be derived by adding 1 to tile_column_width_minus1[num_exp_tile_columns_minus1], a width of a tile column which is explicitly signaled last. In this case, when a variable, remainingWidthInCtbY, representing the number of remaining coding tree unit columns in a current picture is equal to or greater than a variable, uniformTileColWidth, a remaining region may be partitioned in a size of a variable, uniformTileColWidth.</p><p id="p-0489" num="0468">On the other hand, when a variable, remainingWidthInCtbY, representing the number of remaining coding tree unit columns in a current picture is smaller than a variable, uniformTileColWidth, a remaining region may be set as the last tile column as it is.</p><p id="p-0490" num="0469">On the other hand, When an index j of a tile column is equal to or greater than the number of tile columns whose width is explicitly signaled, a width of the corresponding tile column may be set as a smaller value of a variable uniformTileColWidth and remainingWidthInCtbY.</p><p id="p-0491" num="0470">In other words, a width of remaining tile columns excluding tile columns whose width is explicitly signaled may have a value smaller than or equal to a width of the last tile column among tile columns whose width is explicitly signaled.</p><p id="p-0492" num="0471">Information for specifying the number of tile columns whose width is explicitly signaled in a current picture may be signaled in a bitstream. In an example, a syntax, num_exp_tile_columns_minus1, for determining the number of tile columns whose width is signaled, may be signaled in a bitstream. A syntax, num_exp_tile_columns_minus1, may be a value subtracting 1 from the number of tile columns whose width is signaled.</p><p id="p-0493" num="0472">As many as the number determined based on a syntax, num_exp_tile_rows_minus1, a syntax for specifying a height of a tile row may be encoded and signaled. In an example, a syntax, tile_height_minus1[i], representing a height of the i-th tile row may be signaled in a bitstream. A syntax, tile_height_minus1[i] may represent a value subtracting 1 from the number of coding tree unit rows included in a tile row.</p><p id="p-0494" num="0473">When an index i of a tile row is smaller than the number of tile rows whose height is explicitly signaled, a height of the corresponding tile row may be determined based on a syntax, tile_height_minus1[i], signaled in a bitstream.</p><p id="p-0495" num="0474">On the other hand, When an index j of a tile row is equal to or greater than the number of tile rows whose height is explicitly signaled, a height of the corresponding tile row may be determined based on a syntax, tile_height_minus1[l], which is signaled last. In this case, l may represent an index of a tile row whose height is signaled last and may be an integer smaller than j.</p><p id="p-0496" num="0475">In an example, when a value subtracting heights of previous tile rows from a height of a current picture is equal to or greater than a value adding 1 to a syntax, tile_height_minus1[l], a height of a tile row j may be set as a value adding 1 to a syntax, tile_height_minus1[l]. On the other hand, when a value subtracting heights of previous tile rows from a height of a current picture is smaller than a value adding 1 to a syntax, tile_height_minus1[l], a difference value subtracting heights of previous tile rows from a height of a current picture may be set as a height of a tile row j.</p><p id="p-0497" num="0476">Table 10 shows a process in which a height of a tile row is determined.</p><p id="p-0498" num="0000"><tables id="TABLE-US-00010" num="00010"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="189pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 10</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;</entry><entry>remainingHeightInCtbsY = PicHeightInCtbsY </entry></row><row><entry/><entry>for ( j = 0; j &#x3c; num_exp_tile_rows_minus1; j++ ) {</entry></row><row><entry/><entry>&#x2003;&#x2003;RowHeight[ j ] = tile_row_height_minus1[ j ] + 1</entry></row><row><entry/><entry>&#x2003;&#x2003;remainingHeightInCtbsY &#x2212;= RowHeight[ j ]</entry></row><row><entry/><entry>}</entry></row><row><entry/><entry>uniformTileRowHeight =</entry></row><row><entry/><entry>tile_row_height_minus1[ num_exp_tile_rows_minus1 ] + 1</entry></row><row><entry/><entry>while( remainingHeightInCtbsY &#x3e;= uniformTileRowHeight ) {</entry></row><row><entry/><entry>&#x2003;&#x2003;RowHeight[ j++ ] = uniformTileRowHeight</entry></row><row><entry/><entry>&#x2003;&#x2003;remainingHeightInCtbsY &#x2212;= uniformTileRowHeight</entry></row><row><entry/><entry>}</entry></row><row><entry/><entry>if( remainingHeightInCtbsY &#x3e; 0 )</entry></row><row><entry/><entry>&#x2003;&#x2003;RowHeight[ j++ ] = remainingHeightInCtbsY</entry></row><row><entry/><entry>NumTileRows = j</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0499" num="0477">In Table 10, a variable, PicHeightInCtbsY, represents the number of coding tree unit rows included by a current picture. In an example, a variable, PicWidthInCtbsY, may be derived as in the following Equation 10.</p><p id="p-0500" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>PicHeightInCtbs<i>Y</i>=Ceil(pic_height_in_luma_samples/CtbSize<i>Y</i>) &#x2003;&#x2003;[Equation 10]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0501" num="0478">A variable, reminingHeightInCtbsY, represents a value subtracting accumulated heights of tile rows from a variable, PicHeightInCtbsY. In an example, for a tile row whose index is i, remainingHeightInCtbsY may be derived by subtracting a value which is a sum of heights from the 0-th to (i&#x2212;1)-th tile rows from PicHeightInCtbsY.</p><p id="p-0502" num="0479">As in an example shown in Table 10, a variable, uniformTileRowHeight, may be derived by adding 1 to tile_row_height_minus1[num_exp_tile_rows_minus1], a height of a tile row which is explicitly signaled last. In this case, when a variable, remainingHeightInCtbY, representing the number of remaining coding tree unit rows in a current picture is equal to or greater than a variable, uniformTileRowHeight, a remaining region may be partitioned in a size of a variable, uniformTileRowHeight.</p><p id="p-0503" num="0480">On the other hand, when a variable, remainingHeightInCtbY, representing the number of remaining coding tree unit rows in a current picture is smaller than a variable, uniformTileRowHeight, a remaining region may be set as the last tile row as it is.</p><p id="p-0504" num="0481">On the other hand, When an index j of a tile row is equal to or greater than the number of tile rows whose height is explicitly signaled, a height of the corresponding tile row may be set as a smaller value of a variable uniformTileRowHeight and remainingHeightInCtbY.</p><p id="p-0505" num="0482">In other words, a height of remaining tile rows excluding tile rows whose height is explicitly signaled may have a value smaller than or equal to a width of the last tile row among tile rows whose height is explicitly signaled.</p><p id="p-0506" num="0483">Table 11 illustrates a syntax table which includes a syntax representing the number of tile columns whose width is explicitly signaled and a syntax representing the number of tile rows whose height is explicitly signaled.</p><p id="p-0507" num="0000"><tables id="TABLE-US-00011" num="00011"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="168pt" align="left"/><colspec colname="2" colwidth="49pt" align="center"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 11</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>pic_parameter_set_rbsp ( ) {</entry><entry/></row><row><entry>&#x2003;...</entry><entry/></row><row><entry>&#x2003;single_tile_in_pic_flag</entry><entry>&#x2002;u (1)</entry></row><row><entry>&#x2003;if ( !single_tile_in_pic_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;log2_pps_ctu_size_minus5</entry><entry>&#x2002;u (2)</entry></row><row><entry>&#x2003;&#x2003;num_exp_tile_columns_minus1</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;num_exp_tile_rows_minus1</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c;= num_exp_tile_columns_minus1;</entry><entry/></row><row><entry>i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;tile_column_width_minus1[ i ]</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c;= num_exp_tile_rows_minus1; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;tile_row_height_minus1[ i ]</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;loop_filter_across_tiles_enabled_flag</entry><entry>&#x2002;u (1)</entry></row><row><entry>&#x2003;&#x2003;loop_filter_across_slices_enabled_flag</entry><entry>&#x2002;u (1)</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0508" num="0484">When both a value of a syntax, num_exp_tile_columns_minus1, and a value of a syntax, num_exp_tile_row_minus1, are 0, each of a syntax, tile_column_width_minus1, and a syntax, tile_row_height_minus1, may be signaled. In this case, when a width indicated by a syntax, tile_column_width_minus1[0], is the same as a width of a current picture (e.g., when a value of tile_column_width_minus1[0] is (PicWidthInCtbsY&#x2212;1)), a height indicated by a syntax, tile_row_height_minus1[0], should be set as a value different from a height of a current picture. In other words, a value of a syntax, tile_row_height_minus1[0], may be set as a value smaller than (PicHeightInCtbsY&#x2212;1). As a value of a syntax, tile_row_height_minus1[0], is set as a value smaller than (PicHeightInCtbsY&#x2212;1), a picture is partitioned into at least two or more tiles.</p><p id="p-0509" num="0485">Meanwhile, a syntax, loop_filter_across_tiles_enabled_flag, represents whether it is allowed to apply an in-loop filter on a boundary of tiles in a picture which refers to a picture parameter set. In this case, an in-loop filter may include at least one of a deblocking filter, ALF or SAO. When a value of a flag, loop_filter_across_tiles_enabled_flag, is 1, it represents that an in-loop filter which crosses a boundary of tiles in a picture referring to a picture parameter set may be applied. On the other hand, when a value of a flag, loop_filter_across_tiles_enabled_flag, is 0, it represents that it is not allowed to apply an in-loop filter on a boundary of tiles in a picture which refers to a picture parameter set.</p><p id="p-0510" num="0486">A syntax, loop_filter_across_slices_enabled_flag, represents whether it is allowed to apply an in-loop filter on a boundary of slices in a picture which refers to a picture parameter set. In this case, an in-loop filter may include at least one of a deblocking filter, ALF or SAO. When a value of a flag, loop_filter_across_slices_enabled_flag, is 1, it represents that an in-loop filter which crosses a boundary of slices in a picture referring to a picture parameter set may be applied. On the other hand, when a value of a flag, loop_filter_across_slices_enabled_flag, is 0, it represents that it is not allowed to apply an in-loop filter on a boundary of slices in a picture which refers to a picture parameter set.</p><p id="p-0511" num="0487">At least one or more tiles or parts of a tile may be defined as one processing unit. In an example, a plurality of tiles may be defined as one slice.</p><p id="p-0512" num="0488">Alternatively, one tile may be partitioned into a plurality of slices.</p><p id="p-0513" num="0489">One slice may include at least one coding tree unit column. When a tile is partitioned into a plurality of slices, information representing a height of each slice may be signaled in a bitstream.</p><p id="p-0514" num="0490">Image encoding/decoding information may be signaled through a slice header. Information signaled through a slice header may be commonly applied to tiles and/or blocks belong to a slice.</p><p id="p-0515" num="0491">Information representing a slice type may be signaled via a bitstream. The information represents a definition method of a slice in a current picture. In an example, a syntax, rect_slice_flag, representing a slice type may be signaled in a bitstream.</p><p id="p-0516" num="0492">A syntax, rect_slice_flag, represents whether a slice is defined based on a raster scanning order of tiles or whether a slice is defined in a rectangular shape. In an example, when rect_slice_flag is 0, it represents that a slice is defined based on a raster scanning order of tiles. On the other hand, when rect_slice_flag is 1, it represents that a slice is defined in a rectangular shape.</p><p id="p-0517" num="0493">Hereinafter, the two methods for determining a slice will be described in detail.</p><p id="p-0518" num="0494">A definition method based on raster scanning is to specify at least one or more tiles according to a raster scanning order and define at least one or more specified tiles as a slice. When a definition method based on raster scanning is followed, one or more consecutive tile(s) may be defined as a slice. In this case, consecutive tiles may be determined according to a raster scanning order. When a raster scanning slice is applied, a non-rectangular slice may be generated.</p><p id="p-0519" num="0495"><figref idref="DRAWINGS">FIGS. <b>35</b> and <b>36</b></figref> are diagrams showing an example in which a slice is defined based on a raster order.</p><p id="p-0520" num="0496">In an example, in an example shown in <figref idref="DRAWINGS">FIG. <b>35</b></figref>, when it is assumed that the first slice, slice<b>0</b>, includes 3 tiles, the first slice, slice<b>0</b>, may be defined as including Tile<b>0</b> to Tile<b>2</b> according to a raster scanning order. When it is assumed that the second slice, slice<b>1</b>, includes 6 tiles, the second slice, slice<b>1</b>, may be defined as including Tile<b>3</b> to Tile<b>8</b> according to a raster scanning order. The last slice, slice<b>2</b>, may include residual tiles, Tile<b>9</b> to Tile<b>11</b>, according to a raster scanning order.</p><p id="p-0521" num="0497">When a slice is defined based on a raster scanning order, information representing the number of tiles included by each slice may be signaled. Signaling of information representing the number of tiles included by a slice may be omitted for the last slice.</p><p id="p-0522" num="0498">When a slice includes a plurality of tiles, a width or a height of tiles included in a slice may be different. In an example, it was shown that a height of Tile<b>3</b> among tiles included by the second slice, slice<b>1</b>, is different from other tiles.</p><p id="p-0523" num="0499">A definition method of a slice in a rectangular shape is a partitioning method which allows only a slice in a rectangular shape. When a definition method of a slice in a rectangular shape is applied, tiles positioned at four corners of a slice belong to the same row or the same column.</p><p id="p-0524" num="0500"><figref idref="DRAWINGS">FIG. <b>37</b></figref> is a diagram showing an example in which only a slice in a rectangular shape is allowed.</p><p id="p-0525" num="0501">As in an example shown in <figref idref="DRAWINGS">FIG. <b>37</b></figref>, the fourth slice, slice<b>3</b>, includes Tile<b>5</b>, Tile<b>6</b>, Tile<b>9</b> and Tile<b>10</b>. As in a shown example, when a slice includes a plurality of tiles, a rectangle which has a top-left tile and a bottom-right tile as two vertices thereof may be defined as one slice.</p><p id="p-0526" num="0502">A boundary of a slice may match that of a picture and/or that of a tile. In an example, a left boundary or a top boundary of a slice may be set as a boundary of a picture, or a left boundary or a top boundary of a slice may be set as a boundary of a tile.</p><p id="p-0527" num="0503">Alternatively, when a method of defining a rectangular slice is applied, one tile may be partitioned into a plurality of rectangular slices.</p><p id="p-0528" num="0504">When a method of defining a rectangular slice is applied, a syntax representing the number of slices in a picture may be encoded and signaled. In an example, a syntax, num_slices_in_pic_minus1, representing the number of slices in a picture may be signaled in a bitstream. A syntax, num_slices_in_pic_minus1, may represent a value subtracting 1 from the number of slices in a picture. Accordingly, a decoder may determine the total number of slices by adding 1 to a value indicated by a syntax, num_slices_in_pic_minus1.</p><p id="p-0529" num="0505">Instead of a syntax, num_slices_in_pic_minus1, a syntax, num_slices_in_pic_minus2, representing a value subtracting 2 from the number of slices in a picture, may be encoded.</p><p id="p-0530" num="0506">When a definition method of a slice in a rectangular shape is applied, information for identifying tiles included by each slice may be signaled to determine tiles included by each slice. The information may be used to specify at least one of the first tile or the last tile of a slice. An order between tiles may be determined according a predetermined scanning order. In an example, when a raster scanning order is applied, the first tile indicates a tile at a top-left position of a slice and the last tile indicates a tile at a bottom-right position of a slice.</p><p id="p-0531" num="0507">Information for identifying at least one of an index of a tile at a top-left position of a slice or an index of a tile at a bottom-right position of the slice may be signaled in a bitstream.</p><p id="p-0532" num="0508">Difference information between an index of a tile included in the first slice and an index of a tile included in the second slice may be encoded and signaled. In this case, the first slice and the second slice may be determined based on a scanning order and each slice may be occupied by a different tile.</p><p id="p-0533" num="0509">In an example, when a tile constituting the first slice and a tile constituting the second slice are different, an index of the second slice may be obtained by adding 1 to an index i of the first slice.</p><p id="p-0534" num="0510">Alternatively, when the first tile is partitioned to include a plurality of slices, difference information between the first slice included in the first tile and the second slice including the second tile which is the next tile of the first tile in a scanning order or between the first slice included in the first tile and the second slice included in the second tile may be encoded. In this case, difference information may be encoded only for the first slice or the last slice among a plurality of slices included in the first tile.</p><p id="p-0535" num="0511">A tile used to derive difference information between the first slice and the second slice may be positioned at a top-left, top-right, bottom-right, bottom-left or center of a slice.</p><p id="p-0536" num="0512">In an example, a syntax, tile_idx_delta[i], representing an index difference between a top-left tile of the i-th slice and a top-left tile of a subsequent slice (i.e., the (i+1)-th slice), may be signaled in a bitstream. A syntax, tile_idx_delta[i], may represent an absolute value of a difference between an index of a top-left tile of the i-th slice and an index of a top-left tile of the i+1-th slice.</p><p id="p-0537" num="0513">Alternatively, a syntax, tile_idx_delta_minus1[i], derived by subtracting 1 from an absolute value of an index difference between a top-left tile of the i-th slice and a top-left tile of a subsequent slice may be encoded/decoded. Table 12 represents a syntax structure including the above syntax.</p><p id="p-0538" num="0000"><tables id="TABLE-US-00012" num="00012"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="245pt" align="left"/><colspec colname="2" colwidth="42pt" align="center"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 12</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>pic_parameter_set_rbsp ( ) {</entry><entry/></row><row><entry>&#x2003;...</entry><entry/></row><row><entry>&#x2003;single_tile_in_pic_flag</entry><entry>&#x2002;u (1)</entry></row><row><entry>&#x2003;if ( !single_tile_in_pic_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;log2_pps_ctu_size_minus5</entry><entry>&#x2002;u (2)</entry></row><row><entry>&#x2003;&#x2003;num_exp_tile_columns_minus1</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;num_exp_tile_rows_minus1</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;for ( i = 0; i &#x3c;= num_exp_tile_columns_minus1; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;tile_column_width_minus1[ i ]</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;for ( i = 0; i &#x3c;= num_exp_tile_rows_minus1; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;tile_row_height_minus1[ i ]</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;loop_filter_across_tiles_enabled_flag</entry><entry>&#x2002;u (1)</entry></row><row><entry>&#x2003;&#x2003;loop_filter_across_slices_enabled_flag</entry><entry>&#x2002;u (1)</entry></row><row><entry>&#x2003;&#x2003;rect_slice_flag</entry><entry>&#x2002;u (1)</entry></row><row><entry>&#x2003;&#x2003;if( rect_slice_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;num_slices_in_pic_minus1</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( i = 0; i &#x3c; num_slices_in_pic_minus1; i++ )</entry><entry/></row><row><entry>{</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_width_in_tiles_minus1[ i ]</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ]</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( slice_width_in_tiles_minus1[ i ] ==</entry><entry/></row><row><entry>0 &#x26;&#x26; slice_height_in_tiles_minus1[ i ]</entry><entry/></row><row><entry>== 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;num_slices_in_tile_minus1[ i ]</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;numSlicesInTileMinus1=</entry><entry/></row><row><entry>num_slices_in_tile_minus1[ i ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;for ( j = 0; j &#x3c;</entry><entry/></row><row><entry>numSlicesInTileMinus1; j++ )</entry><entry/></row><row><entry>&#x2003;slice_height_in_ctu_minus1[ i ] [ j ]</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( tile_idx_delta_present_flag &#x26;&#x26; i &#x3c;</entry><entry/></row><row><entry>num_slices_in_pic_minus1 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;tile_idx_delta_minus1[ i ]</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if (i&#x3e;0 &#x2225; ==</entry><entry/></row><row><entry>num_slices_in_pic_minus1&#x2212;1)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;tile_idx_delta_sign[ i ]</entry><entry>&#x2002;u (1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;...</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;...</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0539" num="0514">A syntax, tile_idx_delta_sign[i], representing a sign of a tile index difference value between slices may be also encoded/decoded. In an example, when a value of a syntax, tile_idx_delta_sign[i], is 1, it represents that a sign of a difference value indicated by tile_idx_delta[i] is a positive number and when a value of a syntax, tile_idx_delta_sign[i], is 0, it represents that a sign of a difference value indicated by tile_idx_delta[i] is a negative number.</p><p id="p-0540" num="0515">Encoding/decoding of a syntax, tile_idx_delta_sign, may be omitted for a slice that i is 0.</p><p id="p-0541" num="0516">Based on difference information, a position of a top-left tile in the (i+1)-th slice may be determined. Concretely, an index of a top-left tile of the (i+1)-th slice may be derived by adding an index of a top-left tile of the i-th slice and a syntax, tile_idx_delta[i].</p><p id="p-0542" num="0517">A tile index difference value between a first slice (i.e., a slice that i is 0) and a second slice (i.e., a slice that i is 1) in a picture may be always set as a positive number. Accordingly, for a first slice in a picture, encoding/decoding of tile_idx_delta_sign[i] may be omitted and a value thereof may be inferred to 1.</p><p id="p-0543" num="0518">In addition, a tile index difference value between a previous slice of a last slice in a picture (e.g., a slice that i is a value subtracting 1 from num_slices_in_pic_minus1) and a last slice in a picture (e.g., a slice that i is a value indicated by num_slices_in_pic_minus1) is always set as a positive number. Accordingly, for a previous slice of a last slice, encoding/decoding of tile_idx_delta_sign[i] may be omitted and a value thereof may inferred to 1.</p><p id="p-0544" num="0519">For a last slice, encoding/decoding of a syntax, tile_idx_delta[i], representing a difference with a subsequent slice may be omitted.</p><p id="p-0545" num="0520">Information specifying at least one of a width or a height of a slice may be encoded/decoded. In an example, at least one of a syntax, slice_width_in_tiles_minus1[i], representing a width of the i-th slice, or a syntax, slice_height_in_tiles_minus1[i], representing a height of the i-th slice may be signaled in a bitstream.</p><p id="p-0546" num="0521">A syntax, slice_width_in_tiles_minus1[i], represents a value subtracting 1 from the number of tile columns included in the i-th slice. A syntax, slice_height_in_tiles_minus1[i], represents a value subtracting 1 from the number of tile rows included in the i-th slice.</p><p id="p-0547" num="0522">The i-th slice may be configured with as many tile columns as the number determined based on a syntax, slice_width_in_tiles_minus1[i], and as many tile rows as the number determined based on a syntax, slice_height_in_tiles_minus1[i]. In this case, a top-left tile of the i-th tile column may have an index value determined based on tile_idx_delta[i] or tile_idx_delta_minus1[i].</p><p id="p-0548" num="0523">Alternatively, a syntax, slice_height_in_tiles_minus1[i], representing a height of a slice, may be signaled only for a slice adjacent to a left boundary of a picture and encoding of a syntax, slice_height_in_tiles_minus1[i], may be omitted for other slices. A height of a slice that encoding of a syntax, slice_height_in_tiles_minus1[i], is omitted may be set the same as that of a slice adjacent to a left boundary of a current picture among slices included in the same row.</p><p id="p-0549" num="0524">When a flag, rect_slice_flag, representing a slice type is encoded and a value of the flag, rect_slice_flag, is 1, a syntax, num_slices_in_pic_minus1, representing the number of slices in a picture may be encoded.</p><p id="p-0550" num="0525">When it is determined that a picture includes a plurality of slices, a syntax, slice_width_in_tiles_minus1[i], representing a width of each slice, and a syntax, slice_height_in_tiles_minus1[i], representing a height of each slice may be encoded and signaled.</p><p id="p-0551" num="0526">In addition, a syntax, tile_idx_delta[i], representing a difference between an index of a tile included in the i-th slice and an index of a tile included in the (i+1)-th slice may be signaled. For the last tile, encoding of a syntax, tile_idx_delta[i], may be omitted.</p><p id="p-0552" num="0527">An encoder may determine whether to encode a syntax, tile_idx_delta[i], representing a difference of a tile index and encode a flag, tile_idx_delta_present_flag, representing whether a syntax, tile_idx_delta[i], is encoded or not according to the determination. A syntax, tile_idx_delta[i], may be encoded only when a value of a flag, tile_idx_delta_present_flag, is 1.</p><p id="p-0553" num="0528">One tile may be partitioned into a plurality of slices. In an example, a plurality of slices may be generated by partitioning a tile in a horizontal direction.</p><p id="p-0554" num="0529">When it is determined that a slice does not include a plurality of tiles, whether a tile will be partitioned into a plurality of slices may be determined. In an example, when both a syntax, slice_width_in_tiles_minus1[i], and a syntax, slice_height_in_tiles_minus1[i], are 0, it represents that a slice is constituted with only a single tile, or that a tile is partitioned into a plurality of slices.</p><p id="p-0555" num="0530">When both a syntax, slice_width_in_tiles_minus1[i], and a syntax, slice_height_in_tiles_minus1[i], are 0, information representing whether a tile is partitioned into a plurality of slices may be signaled.</p><p id="p-0556" num="0531">In an example, a syntax, num_slices_in_tile_minus1[i], representing the number of slices included by a tile may be signaled. A syntax, num_slices_in_tile_minus1[i], represents a value subtracting 1 from the number of slices included by the i-th tile.</p><p id="p-0557" num="0532">Alternatively, a syntax, num_exp_slices_in_tile[i], representing information on the number of slice heights which should be explicitly signaled may be signaled in a bitstream. A syntax, num_exp_slices_in_tile[i], may have a value which is the same as or smaller than the number of slices included by a tile.</p><p id="p-0558" num="0533">When a syntax, num_exp_slices_in_tile[i], is 0, it represents that a tile is not partitioned into a plurality of slices. When a syntax, num_exp_slices_in_tile[i], is greater than 0, it represents that a tile may be partitioned into a plurality of slices.</p><p id="p-0559" num="0534">Information representing a height of a slice may be signaled as many as a value indicated by a syntax, num_exp_slices_in_tile[i]. In an example, when a syntax, num_exp_slices_in_tile[i], is greater than 1, a syntax, exp_slice_height_in_ctu_minus1[j], representing a height of the j-th slice in a tile, may be signaled.</p><p id="p-0560" num="0535">When an index j of a slice is smaller than the number of slices whose height is explicitly signaled, a width of a slice j may be determined based on a syntax, exp_slice_height_in_ctu_minus1[j], signaled in a bitstream. On the other hand, when an index k of a slice is equal to or greater than the number of slices whose height is explicitly signaled, a height of a slice k may be determined based on a syntax, exp_slice_height_in_ctu_minus1[l], which is signaled last. In this case, l may represent an index of a slice whose height is signaled last and may be an integer smaller than k.</p><p id="p-0561" num="0536">In an example, when a value subtracting a height of previous slices from a height of a tile is equal to or greater than a value adding 1 to a syntax, exp_slice_height_in_ctu_minus1[l], a height of a slice k may be set as a value adding 1 to a syntax, exp_slice_height_in_ctu_minus1[l]. On the other hand, when a value subtracting a height of previous slices from a height of a tile is smaller than a value adding 1 to a syntax, exp_slice_height_in_ctu_minus1[l], a difference value subtracting a height of previous slices from a height of a tile may be set as a height of a slice k.</p><p id="p-0562" num="0537">In other words, a height of remaining slices excluding slices whose height is explicitly signaled may have a value smaller than or the same as a height of the last slice of slices whose height is explicitly signaled.</p><p id="p-0563" num="0538">When the number of tile columns in a current picture is 1, encoding of a syntax, slice_width_in_tiles_minus1, may be omitted. In addition, when the number of tile rows in a current picture is 1, encoding of a syntax, slice_height_in_tiles_minus1, may be omitted.</p><p id="p-0564" num="0539">Alternatively, encoding of at least one of information representing a width of a slice or information representing a height of a slice may be omitted.</p><p id="p-0565" num="0540">In an example, encoding of a syntax, slice_width_in_tiles_minus1, representing a width of a slice may be omitted and a distance with a tile at a predetermined position in an adjacent slice may be set as a width of a slice. Concretely, a top-left tile of the (i+1)-th slice adjacent to the right of the i-th slice may be specified by a syntax, top_left_brick_idx_delta[i]. A width of the i-th slice may be derived by a difference between an x-coordinate of a top-left tile in the i-th slice (e.g., an x-coordinate of a top-left sample) and an x-coordinate of a top-left tile in the (i+1)-th slice (e.g., an x-coordinate of a top-left sample).</p><p id="p-0566" num="0541">Alternatively, encoding of a syntax, slice_height_in_tiles_minus1, representing a height of a slice may be omitted and a distance with a tile at a predetermined position in an adjacent slice may be set as a width of a slice. Concretely, a top-left tile of the j-th slice positioned at the bottom of the i-th slice may be specified by a syntax, top_left_brick_idx_delta[j&#x2212;1]. A height of the i-th slice may be derived by a difference between a y-coordinate of a top-left tile in the i-th slice (e.g., a y-coordinate of a top-left sample) and a y-coordinate of a top-left tile in the j-th slice (e.g., a y-coordinate of a top-left sample).</p><p id="p-0567" num="0542">Alternatively, in defining a slice in a rectangular shape, information representing whether difference value information is used may be signaled in a bitstream. In an example, tile_idx_delta_present_flag representing whether difference value information is used may be signaled in a bitstream. When a value of a syntax, tile_idx_delta_present_flag, is 1, it represents that a syntax representing a difference value of a tile index is encoded and signaled. In an example, when a value of a syntax, tile_idx_delta_present_flag, is 1, the i-th slice may be defined by a syntax, slice_width_in_tiles_minus1[i], and a syntax, slice_height_in_tiles_minus1[i], representing a size of a slice and difference value information for determining a position of a top-left tile or a position of a top-right tile in a slice (e.g., tile_idx_delta[i]).</p><p id="p-0568" num="0543">When a value of a syntax, tile_idx_delta_present_flag, is 0, a position/a size of the i-th slice may be defined by a syntax, slice_width_in_tiles_minus1[i], and a syntax, slice_height_in_tiles_minus1[i], representing a size of a slice. When a value of a syntax, tile_idx_delta_prsent_flag, is 0, a slice adjoining a left boundary of a current picture and a slice adjacent to the right of the slice may have the same height. Accordingly, information representing a height of a slice may be signaled only for a slice adjoining a left boundary of a current picture and signaling of information representing a height of a slice may be omitted for a slice which does not adjoin a left boundary of a current picture.</p><p id="p-0569" num="0544">Based on an index of a tile in a slice, whether to signal information representing a size of a slice may be determined. In an example, Table 13 represents a syntax structure that whether to signal information determining a size of a slice is determined based on a tile index in a slice.</p><p id="p-0570" num="0000"><tables id="TABLE-US-00013" num="00013"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="245pt" align="left"/><colspec colname="2" colwidth="42pt" align="center"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 13</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>pic_parameter_set_rbsp ( ) {</entry><entry/></row><row><entry>&#x2003;...</entry><entry/></row><row><entry>&#x2003;if( NumTilesInPic &#x3e; 1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;rect_slice_flag</entry><entry>&#x2002;u (1)</entry></row><row><entry>&#x2003;if( rect_slice_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;single_slice_per_subpic_flag</entry><entry>&#x2002;u (1)</entry></row><row><entry>&#x2003;if( rect_slice_flag &#x26;&#x26; !single_slice_per_subpic_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;num_slices_in_pic_minus1</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;if( num_slices_in_pic_minus1 &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;tile_idx_delta_present_flag</entry><entry>&#x2002;u (1)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c; num_slices_in_pic_minus1; i++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( NumTileColumns &#x3e; 1 &#x26;&#x26; (SliceTopLeftTileIdx[ i ] %</entry><entry/></row><row><entry>NumTileColumns) != ( (NumTileColumns &#x2212;1 ) ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_width_in_tiles_minus1[ i ]</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( NumTileRows &#x3e; 1 &#x26;&#x26; (SliceTopLeftTileIdx[ i ] /</entry><entry/></row><row><entry>NumTileColumns != NumTileRows&#x2212;1) &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;( tile_idx_delta_present_flag &#x2225; tileIdx %</entry><entry/></row><row><entry>NumTileColumns = = 0 ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ]</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( slice_width_in_tiles_minus1[ i ] = = 0 &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ] = = 0 &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;RowHeight[ SliceTopLeftTileIdx[ i ] / NumTileColumns ]</entry><entry/></row><row><entry>&#x3e; 1 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;num_exp_slices_in_tile[ i ]</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;numExpSlicesInTile = num_exp_slices_in_tile[ i ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c; numExpSlicesInTile; j++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;exp_slice_height_in_ctus_minus1[ j ]</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;i += NumSlicesInTile[ i ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( tile_idx_delta_present_flag &#x26;&#x26; i &#x3c;</entry><entry/></row><row><entry>num_slices_in_pic_minus1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;tile_idx_delta[ i ]</entry><entry>se (v)</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0571" num="0545">In Table 13, a variable, tileIdx, represents an index of a tile included by the i-th slice. Concretely, an index of a tile at a predefined position in the i-th slice may be set as a variable, tileIdx. A tile at a predefined position may represent a top-left tile.</p><p id="p-0572" num="0546">A variable, NumTileColumns, represents the number of tile columns included by a picture. In an example, a position of a tile column to which a top-left tile belongs may be determined based on a modular arithmetic(%) between an index of a top-left tile in the i-th slice and a value subtracting 1 from a variable, NumTileColums. In an example, n, a result value by the modular arithmetic, represents that a top-left tile belongs to a tile column whose index is n. In other words, when a value of remainder is (NumTileColumns&#x2212;1), which is obtained through dividing SliceTopLeftTileIdx[i], a top-left tile index of the i-th slice, by a variable, NumTileColumn, it may be determined that the i-th slice is included in a last tile column.</p><p id="p-0573" num="0547">Based on a position of a top-left tile in a slice, whether information representing a slice size is signaled may be determined. Concretely, whether information representing a slice size is signaled may be determined based on whether a tile column to which a top-left tile of a slice belongs corresponds to the rightmost tile column in a picture.</p><p id="p-0574" num="0548">In an example, when a top-left tile in a slice belongs to the rightmost tile column in a picture, signaling of a syntax, slice_width_in_tiles_minus1[i], representing a width of a slice may be omitted. In an example, as in Table 13, when a result of performing a modular operation for SliceTopLeftTileIdx[i], a top-left tile index of the i-th slice, with a variable, NumTileColumn, is the same as a value subtracting 1 from NumTileColumns, the number of tile columns in a picture, encoding/decoding of a syntax, slice_width_in_tiles_minus1[i], may be omitted. In this case, a value of a syntax, slice_width_in_tiles_minus1[i], may be inferred to 0.</p><p id="p-0575" num="0549">A position of a tile row to which a top-left tile belongs may be determined based on a division operation between an index of a top-left tile in the i-th slice and a variable, NumTileColumns. In an example, when a quotient of a division operation is m, it represents that a top-left tile is included in a tile row whose index is m. In other words, as in Table 13, when a quotient is (NumTileRows&#x2212;1), which is obtained through dividing SliceTopLeftTileIdx[i], a top-left tile index of the i-th slice, by a variable, NumTileColumn, it may be determined that the i-th slice is included in a last tile row.</p><p id="p-0576" num="0550">When a top-left tile in a slice belongs to the lowest tile row in a picture, signaling of a syntax, slice_height_in_tiles_minus[i], representing a height of a slice may be omitted. In an example, when a result of a division operation is the same as a value subtracting 1 from NumTileRows, the number of tile rows in a picture, encoding/decoding of a syntax, slice_height_in_tiles_minus1[i], may be omitted. In this case, a value of a syntax, slice_height_in_tiles_minus1[i], may be inferred to be 0.</p><p id="p-0577" num="0551">When a top-left tile in a slice belongs to the rightmost column and the lowest row in a picture at the same time, encoding of a syntax, slice_width_in_tiles_minus1[i], and a syntax, slice_height_in_tiles_minus1[i], may be omitted. In this case, values of two syntaxes may be inferred to be 0.</p><p id="p-0578" num="0552">When a top-left tile in a slice is not included in the lowest row in a picture, whether to encode/decode a syntax, slice_height_in_tiles_minus1[i], representing a height of a slice may be determined by considering at least one of whether a top-left tile in a slice belongs to the leftmost column in a picture and/or whether difference information between tile indexes is encoded or not.</p><p id="p-0579" num="0553">In an example, although a top-left tile in a slice is not included in the lowest row in a picture, encoding/decoding of a syntax, slice_height_in_tiles_minus1[i], representing a height of a slice may be omitted when a tile index difference is encoded (e.g., when tile_idx_delta_present_flag is 1).</p><p id="p-0580" num="0554">Alternatively, although a top-left tile in a slice does not belong to the lowest row in a picture, encoding/decoding of a syntax, slice_height_in_tiles_minus1[i], may be omitted when a top-left tile does not belong to the leftmost column in a slice.</p><p id="p-0581" num="0555">When a top-left tile in a slice does not belong to the lowest row in a picture, but encoding/decoding of a syntax, slice_height_in_tiles_minus1[i], is omitted, the syntax may be set the same as slice_height_in_tiles_minus[i&#x2212;1], a height of a previous slice.</p><p id="p-0582" num="0556">Table 14 represents semantics on a syntax, slice_width_in_tiles_minus1[i], and a syntax, slice_height_in_tilesminus1[i].</p><p id="p-0583" num="0000"><tables id="TABLE-US-00014" num="00014"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="14pt" align="left"/><colspec colname="2" colwidth="287pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 14</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;</entry><entry>slice_height_in_tiles_minus1[ i ] plus 1 specifies the height of the i-th rectangular slice in</entry></row><row><entry/><entry>units of tile rows. The value of slice_height_in_tiles_minus1[ i ] shall be in the range of 0</entry></row><row><entry/><entry>to NumTileRows &#x2212; 1, inclusive.</entry></row><row><entry/><entry>When slice_height_in_tiles_minus1[ i ] is not present, the following applies:</entry></row><row><entry/><entry>-&#x2003;&#x2003;&#x2003;If sliceTopLeftTileIdx[ i ] / NumTilColumns is equal to NumTileRows&#x2212;1, it is inferred</entry></row><row><entry/><entry>to be equal to 0.</entry></row><row><entry/><entry>-&#x2003;&#x2003;&#x2003;Otherwise, &#x2003;&#x2002;if &#x2002;&#x2003;i &#x2003;&#x2002;is &#x2003;&#x2002;less &#x2003;&#x2002;than &#x2003;&#x2002;num_slices_in_pic_minus1 &#x2003;&#x2002;and</entry></row><row><entry/><entry>slice_height_in_tiles_minus1[ i ] is not present, it is inferred to be equal to NumTileRows</entry></row><row><entry/><entry>= = 1 ? 0 : slice_height_in_tiles_minus1[ i &#x2212; 1 ].</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0584" num="0557">In an example of Table 14, it was illustrated that a syntax, tile_idx_delta_present_flag, representing whether information representing a difference of a tile index is encoded is encoded/decoded when the number of slices included in a current picture is equal to or greater than 1.</p><p id="p-0585" num="0558">When both a value of a syntax, slice_height_in_tiles_minus1[i], representing a height of the i-th slice, and a value of a syntax, slice_width_in_tiles_minus1[i], representing a width of the i-th slice are 0, a syntax, num_exp_slices_in_tile[i], for determining a partitioning shape of a tile including the i-th slice may be additionally encoded/decoded. But, when a height of a tile including the i-th slice is 1, a tile may not be partitioned into a plurality of slices. Accordingly, when a height of a tile including the i-th slice is 1, encoding/decoding of a syntax, num_exp_slices_in_tile[i], may be omitted and a value thereof may be inferred to 0.</p><p id="p-0586" num="0559">When the number of slices in a picture is 2, two rectangular slices may be generated by partitioning a picture in a horizontal direction or in a vertical direction.</p><p id="p-0587" num="0560"><figref idref="DRAWINGS">FIG. <b>38</b></figref> is a diagram showing an example on a case in which a picture is configured with two slices.</p><p id="p-0588" num="0561"><figref idref="DRAWINGS">FIG. <b>38</b>(<i>a</i>)</figref> represents an example in which a picture is partitioned in a horizontal direction and <figref idref="DRAWINGS">FIG. <b>38</b>(<i>b</i>)</figref> represents an example in which a picture is partitioned in a vertical direction.</p><p id="p-0589" num="0562">As in a shown example, when a picture includes only two slices, two slices may be respectively classified only by a syntax representing a width of a slice or a syntax representing a height of a slice.</p><p id="p-0590" num="0563">In an example, as in an example shown in <figref idref="DRAWINGS">FIG. <b>38</b>(<i>a</i>)</figref>, when a picture is partitioned in a horizontal direction, slice <b>0</b> may be specified based on a syntax, slice_width_in_tiles_minus1[<b>0</b>], representing a width of a slice whose index is 0, and a syntax, slice_height_in_tiles_minus1[<b>0</b>], representing a height of a slice whose index is 0. For slice <b>1</b>, encoding/decoding of a syntax for determining a size of a slice may be omitted and a remaining region excluding slice <b>0</b> in a picture may be set as slice <b>1</b>. In addition, an index of a top-left tile of slice <b>1</b> may be derived by subtracting 1 from a multiplication of the number of tile rows and the number of tile columns included in slice <b>0</b>.</p><p id="p-0591" num="0564">As in an example shown in <figref idref="DRAWINGS">FIG. <b>38</b>(<i>b</i>)</figref>, when a picture is partitioned in a vertical direction, slice <b>0</b> may be specified based on a syntax, slice_width_in_tiles_minus1[<b>0</b>], representing a width of a slice whose index is 0, and a syntax, slice_height_in_tiles_minus1[<b>0</b>], representing a height of a slice whose index is 0. For slice <b>1</b>, encoding/decoding of a syntax for determining a size of a slice may be omitted and a remaining region excluding slice <b>0</b> in a picture may be set as slice <b>1</b>. In addition, an index of a top-left tile of slice <b>1</b> may be derived to be the same as the number of tile rows included in slice <b>1</b>.</p><p id="p-0592" num="0565">As above, when only two slices are included in a picture, an index of a top-left tile in all slices may be derived although encoding of information representing a difference of a tile index is omitted. Accordingly, when the number of slices included in a picture is equal to or less than 2, encoding/decoding of a syntax, tile_idx_delta_present_flag, representing whether tile index difference information is encoded/decoded may be omitted and that value may be inferred to 0. Accordingly, encoding/decoding of tile_idx_delta[i] per slice may be omitted.</p><p id="p-0593" num="0566">Table 15 represents a syntax structure that encoding/decoding of a syntax, tile_idx_delta_present_flag, is omitted when the number of slices included by a current picture is equal to or less than 2.</p><p id="p-0594" num="0000"><tables id="TABLE-US-00015" num="00015"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="245pt" align="left"/><colspec colname="2" colwidth="42pt" align="center"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 15</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>pic_parameter_set_rbsp ( ) {</entry><entry/></row><row><entry>&#x2003;...</entry><entry/></row><row><entry>&#x2003;if( NumTilesInPic &#x3e; 1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;rect_slice_flag</entry><entry>&#x2002;u (1)</entry></row><row><entry>&#x2003;if( rect_slice_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;single_slice_per_subpic_flag</entry><entry>&#x2002;u (1)</entry></row><row><entry>&#x2003;if( rect_slice_flag &#x26;&#x26; !single_slice_per_subpic_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;num_slices_in_pic_minus1</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;if( num_slices_in_pic_minus1 &#x3e; l )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;tile_idx_delta_present_flag</entry><entry>&#x2002;u (1)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c; num_slices_in_pic_minus1; i++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( NumTileColumns &#x3e; 1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_width_in_tiles_minus1[ i ]</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( NumTileRows &#x3e; 1 &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;( tile_idx_delta_present_flag &#x2225;</entry><entry/></row><row><entry>SliceTopLeftTileIdx[ i ] % NumTileColumns = = 0 ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1 [ i ]</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( slice_width_in_tiles_minus1[ i ] = = 0 &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ] = = 0 &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;RowHeight[ SliceTopLeftTileIdx[ i ] / NumTileColumns ]</entry><entry/></row><row><entry>&#x3e; 1 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;num_exp_slices_in_tile[ i ]</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;numExpSlicesInTile = num_exp_slices_in_tile [ i ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c; numExpSlicesInTile; j++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;exp_slice_height_in_ctus_minus1[ j ]</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;i += NumSlicesInTile[ i ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if(tile_idx_delta_present_flag &#x26;&#x26; i &#x3c;</entry><entry/></row><row><entry>num_slices_in_pic_minus1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;tile_idx_delta[ i ]</entry><entry>se (v)</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0595" num="0567">As in an example of Table 15, a syntax, tile_idx_delta_present_flag, may be encoded/decoded only when a syntax, num_slices_in_pic_minus1, is greater than 1.</p><p id="p-0596" num="0568">Even when the number of tile columns in a picture is 1 or when the number of tile rows is 1, a position of a top-left tile in each slice may be identified although tile index difference information is not used.</p><p id="p-0597" num="0569"><figref idref="DRAWINGS">FIG. <b>39</b></figref> is a diagram illustrating a case in which the number of tile columns or tile rows in a picture is 1.</p><p id="p-0598" num="0570"><figref idref="DRAWINGS">FIG. <b>39</b>(<i>a</i>)</figref> illustrates an example in which a picture includes 1 tile column and <figref idref="DRAWINGS">FIG. <b>39</b>(<i>b</i>)</figref> illustrates an example in which a picture includes 1 tile row.</p><p id="p-0599" num="0571">When a picture includes 1 tile column, an index of a top-left tile of a slice may be derived based on a height of a previous slice. In an example, as in an example shown in <figref idref="DRAWINGS">FIG. <b>40</b>(<i>a</i>)</figref>, when a first tile is partitioned into 2 slices, both a syntax, slice_width_in_tiles_minus1[<b>0</b>], representing a width and a syntax, slice_width_in_tiles_minus1[<b>0</b>], representing a height for a first slice, slice<b>0</b>, among two slices are set to be 0. As a second slice, slice<b>1</b>, belongs to the same tile as a first slice, slice<b>0</b>, encoding/decoding of a syntax, slice_width_in_tiles_minus1[i], and a syntax, slice_width-in_tiles_minus1[i], representing a height may be omitted for a second slice, slice<b>1</b>.</p><p id="p-0600" num="0572">An index of a left tile of a third slice may be set as the number of tile rows signaled for previous slices. In an example, from slice_height_in_tiles_minus1[<b>0</b>], a syntax signaled for slice<b>0</b>, it may be recognized that 1 tile row is organized with a slice, so an index of a top-left tile row of slice<b>2</b> may be set to be 1.</p><p id="p-0601" num="0573">An index of a top-left tile row of slice<b>3</b> may be derived based on a height of a tile row of previous slices. In an example, from a syntax, slice_height_in_tiles_minus1[<b>0</b>], signaled for slice<b>0</b>, and a syntax, slice_height_width_in_tiles_minus1[<b>2</b>], signaled for slice<b>2</b>, it may be recognized that a total of 3 tile rows are organized with slices, so an index of a top-left tile row of slice<b>3</b> may be set to be 3.</p><p id="p-0602" num="0574">In other words, when a picture includes 1 tile column, the number of tile rows occupied by previous slices may be determined as an index of a top-left tile of a subsequent slice.</p><p id="p-0603" num="0575">When a picture includes 1 tile row, an index of a top-left tile of a slice may be derived based on a width of a previous slice. In an example, as in an example shown in <figref idref="DRAWINGS">FIG. <b>40</b>(<i>b</i>)</figref>, when a first tile is set as 1 slice, both a syntax, slice_width_in_tiles_minus1[<b>0</b>], representing a width and a syntax, slice_width_in_tiles_minus1[<b>0</b>], representing a height for a first slice, slice<b>0</b>, are set to be 0.</p><p id="p-0604" num="0576">An index of a left tile of a second slice may be set as the number of tile columns signaled for a previous slice. In an example, from a syntax, slice_width_in_tiles_minus1[<b>0</b>], signaled for slice<b>0</b>, it may be recognized that 1 tile column is organized with a slice, so an index of a top-left tile row of slice<b>1</b> may be set to be 1.</p><p id="p-0605" num="0577">An index of a top-left tile row of slice<b>2</b> may be derived based on a height of a tile column of previous slices. In an example, from a syntax, slice_width_in_tiles_minus1[<b>0</b>], signaled for slice<b>0</b>, and a syntax, slice_width_width_in_tiles_minus1[<b>1</b>], signaled for slice<b>1</b>, it may be recognized that a total of 3 tile columns are organized with slices, so an index of a top-left tile row of slice<b>2</b> may be set to be 3.</p><p id="p-0606" num="0578">In other words, when a picture includes 1 tile row, the number of tile columns occupied by previous slices may be determined as an index of a top-left tile of a subsequent slice.</p><p id="p-0607" num="0579">As above, when a picture is configured with only 1 tile column or 1 tile row, an index of a top-left tile of each slice may be specified without tile index difference information. Accordingly, when the number of tile columns or tile rows included in a picture is 1, encoding/decoding of a syntax, tile_idx_delta_present_flag, representing whether tile index difference information is encoded/decoded may be omitted and that value may be inferred to 0. Accordingly, encoding/decoding of tile_idx_delta[i] per slice may be omitted.</p><p id="p-0608" num="0580">Table 16 represents a syntax structure that encoding/decoding of a syntax, tile_idx_delta_present_flag, is omitted when the number of tile columns or tile rows included by a current picture is 1.</p><p id="p-0609" num="0000"><tables id="TABLE-US-00016" num="00016"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="245pt" align="left"/><colspec colname="2" colwidth="42pt" align="center"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 16</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>pic_parameter_set_rbsp ( ) {</entry><entry/></row><row><entry>&#x2003;...</entry><entry/></row><row><entry>&#x2003;&#x2003;if( !no_pic_partition_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;...</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( NumTilesInPic &#x3e; 1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;rect_slice_flag</entry><entry>&#x2002;u (1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( rect_slice_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;single_slice_per_subpic_flag</entry><entry>&#x2002;u (1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( rect_slice_flag &#x26;&#x26; !single_slice_per_subpic_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;num_slices_in_pic_minus1</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( num_slices_in_pic_minus1 &#x3e; 0 &#x26;&#x26; NumTileColumns &#x3e; 1 &#x26;&#x26;</entry><entry/></row><row><entry>NumTileRows &#x3e; 1)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;tile_idx_delta_present_flag</entry><entry>&#x2002;u (1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;...</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0610" num="0581">As described above, when a syntax, slice_width_in_tiles_minus1[i], representing a width of a slice, and a syntax, slice_height_in_tiles_minus1[i], representing a height of a slice, are 0, it may represent that a slice is configured with one tile or that one tile is configured with a plurality of slices.</p><p id="p-0611" num="0582">When one tile is configured with a plurality of slices, a height of the plurality of slices may be set to have the same value or slices excluding a last slice among the plurality of slices may be set to have the same height. In this case, height information may be signaled only for a first slice in a tile.</p><p id="p-0612" num="0583">When the number of slices in a picture is two, a size and a position of each slice may be determined only by a tile index difference between two slices. Accordingly, when a value of a syntax, tile_idx_delta_present_flag, representing that a tile index difference is encoded is 1 and a value of a syntax, num_slice_in_pic_minus1, representing the number of slices in a picture is 1, encoding/decoding of a syntax, slice_width_in_tiles_minus1, representing a width of a slice, and a syntax, slice_height_in_tiles_minus1, representing a height of a slice may be omitted. Table 17 represents an example therefor.</p><p id="p-0613" num="0000"><tables id="TABLE-US-00017" num="00017"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="245pt" align="left"/><colspec colname="2" colwidth="42pt" align="center"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 17</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>pic_parameter_set_rbsp ( ) {</entry><entry/></row><row><entry>...</entry><entry/></row><row><entry>&#x2003;if( NumTilesInPic &#x3e; 1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;rect_slice_flag</entry><entry>&#x2002;u (1)</entry></row><row><entry>&#x2003;if( rect_slice_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;single_slice_per_subpic_flag</entry><entry>&#x2002;u (1)</entry></row><row><entry>&#x2003;if( rect_slice_flag &#x26;&#x26; !single_slice_per_subpic_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;num_slices_in_pic_minus1</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;if( num_slices_in_pic_minus1 &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;tile_idx_delta_present_flag</entry><entry>&#x2002;u (1)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c; num_slices_in_pic_minus1; i++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( NumTileColumns &#x3e; 1 &#x2225; ! (tile_idx_delta_present_flag</entry><entry/></row><row><entry>&#x26;&#x26; num_slices_in_pic_minus1 ==1) )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_width_in_tiles_minus1[ i ]</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( NumTileRows &#x3e;1 &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;( tile_idx_delta_present_flag &#x2225;</entry><entry/></row><row><entry>SliceTopLeftTileIdx[ i ] % NumTileColumns = = 0 ) &#x2225; !</entry><entry/></row><row><entry>(tile_idx_delta_present_flag &#x26;&#x26; num_slices_in_pic_minus1 ==1)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ]</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( slice_width_in_tiles_minus1[ i ] = = 0 &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ] = = 0 &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;RowHeight[ SliceTopLeftTileIdx[ i ] / NumTileColumns ]</entry><entry/></row><row><entry>&#x3e; 1 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;num_exp_slices_in_tile[ i ]</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;numExpSlicesInTile = num_exp_slices_in_tile[ i ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c; numExpSlicesInTile; j++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;exp_slice_height_in_ctus_minus1[ j ]</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;i += NumSlicesInTile[ i ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( tile_idx_delta_present_flag &#x26;&#x26; i &#x3c;</entry><entry/></row><row><entry>num_slices_in_pic_minus1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;tile_idx_delta[ i ]</entry><entry>se (v)</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>...</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0614" num="0584">As illustrated in Table 17, when a value of a syntax, tile_idx_delta_present_flag, is 1 and num_slices_in_pic_minus1 is 1, encoding/decoding of a syntax, slice_width_in_tiles_minus1[i], and a syntax, slice_height_in_tiles_minus1[i], may be omitted.</p><p id="p-0615" num="0585">In other words, when a value of a syntax, tile_idx_delta_present_flag, is 0, or when a value of num_slices_in_pic_minus1 is not 1, a syntax, slice_width_in_tiles_minus1[i], and/or a syntax, slice_height_in_tiles_minus1[i], may be encoded/decoded.</p><p id="p-0616" num="0586">When encoding/decoding of a syntax, slice_width_in_tiles_minus1[i], and a syntax, slice_height_in_tiles_minus1[i], is omitted, a decoder may derive a height or a width of each slice by considering at least one of a tile index difference between two slices, the number of tile columns or the number of tile rows.</p><p id="p-0617" num="0587">In an example, when a value of a syntax, tile_idx_delta[i], representing a tile index difference between two slices is smaller than a variable, NumTileColumns, representing the number of tile columns in a picture, a value of a syntax, slice_width_in_tiles_minus1[i], may be inferred to a value subtracting 1 from a difference value indicated by a syntax, tile_idx_delta[i]. In addition, a value of a syntax, slice_height_in_tiles_minus1[i], may be inferred to a value subtracting 1 from a variable, NumTileRows, representing the number of tile rows. In other words, a width of a first slice in a picture may be set as the same value as a syntax, tile_idx_delta[<b>0</b>], and a height of a first slice may be set the same as the number of tile columns.</p><p id="p-0618" num="0588">In an example, when a value of a syntax, tile_idx_delta[i], representing a tile index difference between two slices is the same as or greater than a variable, NumTileColumns, representing the number of tile columns in a picture, a value of a syntax, slice_width_in_tiles_minus1[i], may be inferred to a value subtracting 1 from a variable, NumTileColumns, representing the number of tile columns. In addition, a value of a syntax, slice_height_in_tiles_minus1[i], may be inferred to a value dividing a syntax, tile_idx_delta[i], by the number of tile columns, NumTileColumns (i.e., tile_idx_delta[i]/NumTileColumn). In other words, a width of a first slice in a picture may be set as the same value as the number of tile columns and a height of a first slice may be set as the same value as a quotient obtained by dividing a syntax, tile_idx_delta[<b>0</b>], by a variable, NumTileColumn.</p><p id="p-0619" num="0589">When both a value of a syntax, slice_width_in_tiles_minus1[i], representing a size of the i-th slice, and a syntax, slice_height_in_tiles_minus1[i], representing a height of a slice, are 0, information for determining a partitioning shape of a tile including the i-th slice, e.g., a syntax, num_exp_slice_in_tile[i] and/or exp_slice_height_in_ctus_minus1[j], may be encoded/decoded.</p><p id="p-0620" num="0590">In this case, based on a height of a tile row, whether information for determining a partitioning shape of a tile is encoded/decoded may be determined.</p><p id="p-0621" num="0591">Whether to encode/decode a syntax, tile_idx_delta[i], may be determined based on the number of tiles in a picture. Table 18 represents an example for the description.</p><p id="p-0622" num="0000"><tables id="TABLE-US-00018" num="00018"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="245pt" align="left"/><colspec colname="2" colwidth="42pt" align="center"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 18</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>pic_parameter_set_rbsp ( ) {</entry><entry/></row><row><entry>...</entry><entry/></row><row><entry>&#x2003;if( NumTilesInPic &#x3e; 1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;rect_slice_flag</entry><entry>&#x2002;u (1)</entry></row><row><entry>&#x2003;if( rect_slice_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;single_slice_per_subpic_flag</entry><entry>&#x2002;u (1)</entry></row><row><entry>&#x2003;if( rect_slice_flag &#x26;&#x26; !single_slice_per_subpic_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;num_slices_in_pic_minus1</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;if( num_slices_in_pic_minus1 &#x3e; 1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;tile_idx_delta_present_flag</entry><entry>&#x2002;u (1)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c; num_slices_in_pic_minus1; i++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( SliceTopLeftTileIdx[ i ] % NumTileColumns !=</entry><entry/></row><row><entry>NumTileColumns &#x2212;?* 1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_width_in_tiles_minus1[ i ]</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;if( SliceTopLeftTileIdx[ i ] / NumTileColumns !=</entry><entry/></row><row><entry>NumTileRows &#x2212; 1 &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;( pps_tile_idx_delta_present_flag &#x2225;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;SliceTopLeftTileIdx[ i ] % NumTileColumns = = 0 ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ]</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if( SliceTopLeftTileIdx[ i ] / NumTileColumns !=</entry><entry/></row><row><entry>NumTileRows &#x2212; 1 &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;( pps_tile_idx_delta_present_flag &#x2225;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;SliceTopLeftTileIdx[ i ] % NumTileColumns = = 0 ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;num_exp_slices_in_tile[ i ]</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;numExpSlicesInTile = num_exp_slices_in_tile[ i ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c; numExpSlicesInTile; j++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;exp_slice_height_in_ctus_minus1[ i ] [ j ]</entry><entry>ue (v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;i += NumSlicesInTile[ i ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( tile_idx_delta_present_flag &#x26;&#x26; i &#x3c;</entry><entry/></row><row><entry>num_slices_in_pic_minus1 &#x26;&#x26; NumTileInPic &#x3e;1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;tile_idx_delta[ i ]</entry><entry>se (v)</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>...</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0623" num="0592">In Table 18, a variable, NumTileInPic, represents the number of slices in a picture. When the number of tiles in a picture is equal to or less than a threshold value, encoding/decoding of a syntax, tile_idx_delta[i], representing a tile index difference value may be omitted. A threshold value may be a natural number such as, 1, 2, or 3. In Table 18, it was illustrated that a threshold value is 1. In other words, when a tile in a picture is 1, it is only possible to partition one tile into a plurality of slices. Accordingly, a syntax difference value for all slices is 0, so encoding/decoding of a syntax, tile_idx_delta[i], may be omitted.</p><p id="p-0624" num="0593">In another example, whether to encode/decode a syntax, tile_idx_delta_present_flag, representing whether a tile index difference value may be determined based on the number of tiles in a picture. In an example, when the number of tiles in a picture is equal to or less than a threshold value, encoding/decoding of a syntax, tile_idx_delta_present_flag, may be omitted. A threshold value may be a natural number such as, 1, 2, or 3. When encoding/decoding of a syntax, tile_idx_delta_present_flag, is omitted, a value of the syntax may be inferred to 0. Accordingly, a syntax, tile_idx_delta[i], representing a tile index difference value may not be encoded/decoded.</p><p id="p-0625" num="0594">In the above-described embodiments, it is possible to define a slice based on an index of a coding tree unit instead of an index of a tile.</p><p id="p-0626" num="0595">In the above-described example, it is assumed that a slice is defined by giving an order to tiles according to a raster scanning order. In another example, a slice may be defined by giving an order to tiles according to vertical scanning, horizontal scanning or diagonal scanning.</p><p id="p-0627" num="0596">Applying the embodiments as described about the decoding process or the encoding process to the encoding process or the decoding process respectively may be included in the scope of the present disclosure. Within the scope of the present disclosure, the embodiments in which operations occur in a predetermined order may be modified to embodiments in which the operations occur in a different order from the predetermined order.</p><p id="p-0628" num="0597">Although the above-described embodiment is described based on a series of the operations or the flowchart, the embodiment does not limit a time-series order of the operations of the method thereto. In another example, the operations may be performed simultaneously or in a different order therefrom as necessary. Further, in the above-described embodiment, each of the components (for example, a unit, a module, etc.) constituting the block diagram may be implemented in a form of a hardware device or software. A plurality of components may be combined with each other into a single component which may be implemented using a single hardware device or software. The above-described embodiment may be implemented using program instructions that may be executed via various computer components. The instructions may be recorded in a computer-readable storage medium. The computer-readable storage medium may contain therein program instructions, data files, data structures, or the like alone or in combination with each other. Examples of the computer-readable storage media include magnetic media such as hard disks, floppy disks, and magnetic tapes, optical storage media such as CD-ROMs, DVDs, and magneto-optical media such as floptical disks, and hardware devices such as ROM, RAM, flash memory, and the like specifically configured to store therein and execute the program instructions. The hardware device may be configured to operate as one or more software modules to perform processing according to the present disclosure, and vice versa.</p><heading id="h-0010" level="1">INDUSTRIAL AVAILABILITY</heading><p id="p-0629" num="0598">The present disclosure may be applied to an electronic device that encodes/decodes video.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-math idrefs="MATH-US-00001" nb-file="US20230007249A1-20230105-M00001.NB"><img id="EMI-M00001" he="13.04mm" wi="76.20mm" file="US20230007249A1-20230105-M00001.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00002" nb-file="US20230007249A1-20230105-M00002.NB"><img id="EMI-M00002" he="11.60mm" wi="76.20mm" file="US20230007249A1-20230105-M00002.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A method of decoding a video, the method comprising:<claim-text>partitioning a current picture into a plurality of tiles;</claim-text><claim-text>decoding partitioning information representing whether a rectangular slice type is applied or not; and</claim-text><claim-text>decoding tile index difference value information specifying a difference between an index of a top-left tile of a first slice and an index of a top-left tile of a second slice,</claim-text><claim-text>wherein the tile index difference value information is decoded from a bitstream only when a tile index difference value present flag, decoded from a bitstream, indicates that the tile index difference value information could be present in the bitstream,</claim-text><claim-text>wherein the index of the top-left tile of the second slice is determined by adding the difference specified by the tile index difference value information to the index of the top-left tile of the first slice, and</claim-text><claim-text>wherein whether to decode width information for the second slice from a bitstream or not is determined based on whether the top-left tile of the second slice is included in a rightmost tile column in the current picture.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the width information indicates a value subtracting 1 from a number of tile columns included in the second slice, and wherein when the top-left tile of the second slice is included in the rightmost tile column in the current picture, decoding the width information for the second slice is omitted and a value of the width information is inferred to 0.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein whether the top-left tile of the second slice is included in the rightmost tile column is determined based on a modular operation between the index of the top-left tile of the second slice and a number of tile columns in the current picture.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein whether to decode height information for the second slice from the bitstream or not is determined based on whether the top-left tile of the second slice is included in a lowest tile row in the current picture.</claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the height information indicates a value subtracting 1 from a number of tile rows included in the second slice, and wherein when the top-left tile of the second slice is included in the lowest tile row in the current picture, decoding the height information for the second slice is omitted and a value of the height information is inferred to 0.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein whether the top-left tile of the second slice is included in the lowest tile row is determined based on a division operation between the index of the top-left tile of the second slice and a number of tile columns in the current picture.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>,<claim-text>wherein whether to decode the tile index difference value present flag from the bitstream or not is determined based on a number of slices included in the current picture.</claim-text></claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. A method of encoding a video, the method comprising:<claim-text>partitioning a current picture into a plurality of tiles;</claim-text><claim-text>determining whether a rectangular slice type is applied or not; and</claim-text><claim-text>encoding tile index difference value information specifying a difference between an index of a top-left tile of a first slice and an index of a top-left tile of a second slice,</claim-text><claim-text>wherein a tile index difference value present flag, indicating whether the tile index difference value information is present in a bitstream or not, is further encoded in the bitstream,</claim-text><claim-text>wherein the tile index difference value information has a value derived by subtracting the index of the top-left tile of the second slice from the index of the top-left tile of the first slice, and</claim-text><claim-text>wherein whether to encode width information for the second slice into the bitstream or not is determined based on whether the top-left tile of the second slice is included in a rightmost tile column in the current picture.</claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the width information indicates a value subtracting 1 from a number of tile columns included in the second slice, and<claim-text>wherein when the top-left tile of the second slice is included in the rightmost tile column in the current picture, encoding the width information for the second slice is omitted.</claim-text></claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein whether to encode height information for the second slice into the bitstream or not is determined based on whether the top-left tile of the second slice is included in a lowest tile row in the current picture.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the height information indicates a value subtracting 1 from a number of tile rows included in the second slice, and<claim-text>wherein when the top-left tile of the second slice is included in the lowest tile row in the current picture, encoding the height information for the second slice is omitted.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. A non-transitory computer-readable medium for storing data associated with a video, comprising:<claim-text>a data stream stored in the non-transitory computer-readable medium, the data stream comprising:</claim-text><claim-text>partitioning information representing whether a rectangular slice type is applied or not,</claim-text><claim-text>tile index delta present flag indicating whether tile index value information is present or not, and</claim-text><claim-text>the tile index difference value information specifying a difference between an index of a top-left tile of a first slice and an index of a top-left tile of a second slice,</claim-text><claim-text>wherein the index of the top-left tile of the second slice is determined by adding the difference specified by the tile index difference value information to the index of the top-left tile of the first slice, and</claim-text><claim-text>wherein whether the compressed video data further comprises width information for the second slice or not is determined based on whether the top-left tile of the second slice is included in a rightmost tile column in the current picture.</claim-text></claim-text></claim></claims></us-patent-application>