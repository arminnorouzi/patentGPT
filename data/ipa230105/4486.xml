<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004487A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004487</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17780478</doc-number><date>20201116</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><priority-claims><priority-claim sequence="01" kind="national"><country>IN</country><doc-number>201941048954</doc-number><date>20191128</date></priority-claim></priority-claims><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>11</main-group><subgroup>36</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>11</main-group><subgroup>3692</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>11</main-group><subgroup>3644</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e61">SYSTEM AND METHOD FOR ANOMALY DETECTION AND ROOT CAUSE AUTOMATION USING SHRUNK DYNAMIC CALL GRAPHS</invention-title><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only"><addressbook><last-name>Bitla</last-name><first-name>Srinivas</first-name><address><city>Hyderabad</city><country>IN</country></address></addressbook><residence><country>IN</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Bitla</last-name><first-name>Srinivas</first-name><address><city>Hyderabad</city><country>IN</country></address></addressbook></inventor></inventors></us-parties><pct-or-regional-filing-data><document-id><country>WO</country><doc-number>PCT/IN2020/050981</doc-number><date>20201116</date></document-id><us-371c12-date><date>20220526</date></us-371c12-date></pct-or-regional-filing-data></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A system and method for real-time or near real-time anomaly detection and root cause automation in production environments or in other environments using shrunk dynamic call graphs are provided. The system includes an instrumentation agent that generates shrunk dynamic call graphs and exceptions/errors by injecting monitoring code or probes or call-tags into monitored application, a data agent that forwards collected data to the analysis engine over a network, an analysis engine that performs continuous clustering using machine learning, anomaly, and root cause detection. The system also includes a reporting module to report the anomaly.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="159.68mm" wi="115.91mm" file="US20230004487A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="109.81mm" wi="146.81mm" file="US20230004487A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="123.27mm" wi="148.08mm" file="US20230004487A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="123.53mm" wi="167.64mm" file="US20230004487A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="103.63mm" wi="135.04mm" file="US20230004487A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="103.55mm" wi="136.65mm" file="US20230004487A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="103.63mm" wi="138.26mm" file="US20230004487A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="103.29mm" wi="134.87mm" file="US20230004487A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="114.30mm" wi="139.28mm" file="US20230004487A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="123.78mm" wi="162.64mm" file="US20230004487A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="126.49mm" wi="154.77mm" file="US20230004487A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="128.61mm" wi="165.44mm" file="US20230004487A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="118.96mm" wi="161.46mm" file="US20230004487A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="111.84mm" wi="108.37mm" file="US20230004487A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00014" num="00014"><img id="EMI-D00014" he="117.94mm" wi="160.19mm" orientation="landscape" file="US20230004487A1-20230105-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00015" num="00015"><img id="EMI-D00015" he="119.55mm" wi="152.40mm" file="US20230004487A1-20230105-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00016" num="00016"><img id="EMI-D00016" he="128.35mm" wi="130.30mm" file="US20230004487A1-20230105-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">TECHNICAL FIELD</heading><p id="p-0002" num="0001">The embodiments herein generally relate to the detection of anomalies, more particularly, a system and method for automatically identifying anomalies and analyzing root cause in software applications and programs to reduce Mean Time To Repair (MTTR) the anomalies.</p><heading id="h-0002" level="1">DESCRIPTION OF THE RELATED ART</heading><p id="p-0003" num="0002">Nowadays everything is digitalized, identifying and troubleshooting of defects or bugs and applying code fixes is one of the important tasks in software engineering to maintain good quality of software service. Hence, lots of research work is undergoing to maintain the quality of software service at the highest levels. Engineers are spending their quality time pouring through tons of log files, trying to reproduce the defect or failure in development environments as they troubleshoot to find the root cause. Mean Time To Repair (MTTR) indicates the average amount of time required to repair a defect and companies strive hard to keep MTTR as low as possible. With currently available tools, this troubleshooting is still a manual task, which needs an engineer's experience, skill and time to analyze the problem to identify the root cause. This may take several days to several weeks which in turn causing MTTR to shoot high.</p><p id="p-0004" num="0003">Since call graphs are an essential starting point for all inter-procedural analyses, many tools and frameworks such as instrumentation agents have been developed to generate the call graphs of a computer program. A call graph is a control flow graph, which represents calling relationships between subroutines in the computer program. Each node represents a method/procedure/function/subroutine and each edge (f, g) indicates that the method &#x201c;f&#x201d; calls method &#x201c;g&#x201d;. The call graph basically shows the calling relationships between the program's methods. The call graphs may be dynamic or static. A dynamic call graph is a record of an execution of the program, for example as output by a profiler. The dynamic call graph can be exact, but only describes one run of the program or request. A static call graph is a call graph intended to represent every possible run of the program.</p><p id="p-0005" num="0004">The dynamic call graphs have meaning and extracting such meaning will help in the detection of anomalies in program execution. As mentioned earlier, the dynamic call graphs are very detailed representations of one execution of the program. Generating such detailed graphs is very expensive operations in terms of time and memory. There will be approximately 1 to 20 million method entry or exits in one run of an average complex program or request and recording such a huge number of method calls takes huge amounts of memory and CPU cycles. Hence generating dynamic call graphs in production environments, where faster response times are not just important but demanded, is prohibitive. However, despite their prohibitive nature in production environments, because of the fact that there is meaning in dynamic call graphs and to extract such meaning, advanced methods are needed.</p><p id="p-0006" num="0005">Existing approaches to detect anomalies are dependent on manual interpretation. Further, existing approaches are detecting anomalies by considering metrics like response times, error rate, memory usage, CPU usage, business transaction load.</p><p id="p-0007" num="0006">Accordingly, there is a need for an efficient system and method for automatically identifying anomalies and root cause in real-time production applications to reduce Mean Time To Repair (MTTR) the anomalies.</p><heading id="h-0003" level="1">SUMMARY</heading><p id="p-0008" num="0007">In view of the foregoing, an embodiment herein provides a processor-implemented method for identifying an anomaly and a root cause of the anomaly in an application using a plurality of shrunk dynamic call graphs. The method includes, generating, using an instrumentation agent, a one or more shrunk dynamic call graphs by providing a shrink factor to the instrumentation agent when the application receives a one or more input requests, wherein the plurality of input requests is received from a user device. The method includes, identifying, using a machine learning model, an anomalous group of the plurality of shrunk dynamic call graphs associated with the plurality of input requests that are failed, from one or more groups of the plurality of shrunk dynamic call graphs. The method includes, identifying a deviation in the plurality of shrunk dynamic call graphs of the plurality of input requests that are failed by comparing the plurality of shrunk dynamic call graphs associated with the plurality of input requests that are fai led from the anomalous group with the plurality of shrunk dynamic call graphs associated with the plurality of input requests that are successful. The method includes, identifying an anomaly based on the deviation in the plurality of shrunk dynamic call graphs associated with the plurality of input requests that are failed and an exception thrown around the deviation point as the root cause of the identified anomaly in the application.</p><p id="p-0009" num="0008">In some embodiments, the identification of the anomalous group of the one or more shrunk dynamic call graphs includes (i) obtaining a centroid of a dataset of each input request (ii) obtaining a one or more centroids of each of the one or more groups of the one or more of shrunk dynamic call graphs, (iii) obtaining a one or more centroids based on the exception thrown in each input request, (iv) obtaining, using the one or more centroids, a farthest centroid from the centroid of the dataset, (iv) identifying, using the farthest centroid, a first anomalous group of the one or more shrunk dynamic call graphs associated with the one or more input requests that are failed, (v) identifying, using the farthest centroid, a second anomalous group based on the exception associated with the one or more input requests that are failed, and (vi) identifying the anomalous group if the first anomalous group of the one or more of shrunk dynamic call graphs and the second anomalous group based on the exception are same.</p><p id="p-0010" num="0009">In some embodiments, the method includes creating, using the machine learning model, the one or more groups of the one or more shrunk dynamic call graphs based on a similarity between the one or more shrunk dynamic call graphs after removing repeating patterns in the one or more shrunk dynamic call graphs.</p><p id="p-0011" num="0010">In some embodiments, the one or more groups of the one or more shrunk dynamic call graphs are created when (i) a distance between two points in each group is lower, and (ii) a minimum number of points are used to form a dense region in each group.</p><p id="p-0012" num="0011">In some embodiments, the one or more shrunk dynamic call graphs includes a crest point and a trough point with an absolute height.</p><p id="p-0013" num="0012">In some embodiments, generating the one or more shrunk dynamic call graphs includes (i) identifying a subroutine in the application that receives and handles the plurality of input requests; (ii) inserting probes at each subroutine entry and each subroutine exit in the application; (iii) tracking a running height, a running crest, and a running trough of the subroutine being entered; (iv) obtaining a crest point in the one or more shrunk dynamic call graphs by comparing an absolute difference of the running crest, and the running trough to the shrink factor; (v) repeating the step (ii) and tracking a running height, a running crest, and a running trough of the subroutine being exited; and (vi) obtaining a trough point in the one or more shrunk dynamic call graphs by comparing an absolute difference of the running crest, and the running trough to the shrink factor.</p><p id="p-0014" num="0013">In some embodiments, the crest point or the trough point of one or more shrunk dynamic call graphs is generated when a difference between two adjacent points is greater than the shrink factor. The shrink factor is a constant that specifies an amount of detail captured from the application.</p><p id="p-0015" num="0014">In one aspect, there is provided a system for identifying an anomaly and a root cause of the anomaly in an application using a one or more shrunk dynamic call graphs. The system includes a processor and a non-transitory computer-readable storage medium storing one or more sequences of instructions, which when executed by the processor, causes to: (i) generate, using an instrumentation agent, a one or more shrunk dynamic call graphs by providing a shrink factor to the instrumentation agent when the application receives a one or more input requests, wherein the one or more input requests is received from a user device; (ii) identify, using a machine learning model, an anomalous group of the one or more shrunk dynamic call graphs associated with the plurality of input requests that are failed, from one or more groups of the one or more shrunk dynamic call graphs; (iii) identify a deviation in the one or more shrunk dynamic call graphs of the one or more input requests that are failed by comparing the one or more shrunk dynamic call graphs associated with the one or more input requests that are failed from the anomalous group with the one or more shrunk dynamic call graphs associated with the one or more input requests that are successful; and (iv) identify an anomaly based on the deviation in the one or more shrunk dynamic call graphs associated with the one or more input requests that are failed and an exception thrown around the deviation point as the root cause of identified anomaly in the application.</p><p id="p-0016" num="0015">In some embodiments, the system identities the anomalous group of the one or more shrunk dynamic call graphs by (i) obtaining a centroid of a dataset of each input request, (ii) obtaining a one or more centroids of each of the one or more groups of the one or more shrunk dynamic call graphs, (iii) Obtaining a one or more centroids based on the exception thrown in each input request, (iv) obtaining, using the one or more centroids, a farthest centroid from the centroid of the dataset, (iv) identifying, using the farthest centroid, a first anomalous group of the one or more shrunk dynamic call graphs associated with the one or more input requests that are failed, (v) identifying, using the farthest centroid, a second anomalous group based on the exception associated with the one or more input requests that are failed, and (vi) identifying the anomalous group if the first anomalous group of the one or more shrunk dynamic call graphs and the second anomalous group based on the exception are same.</p><p id="p-0017" num="0016">In some embodiments, the system creates, using the machine learning model, the one or more groups of the one or more shrunk dynamic call graphs based on a similarity between the one or more shrunk dynamic call graphs after removing repeating patterns in the plurality of shrunk dynamic call graphs.</p><p id="p-0018" num="0017">In some embodiments, the system creates the one or more groups of the one or more shrunk dynamic call graphs when (i) a distance between two points in the group is lower, and (ii) a minimum number of points to form a dense region in the group are essential while creating the group of the one or more shrunk dynamic call graphs of a similar one or more input requests.</p><p id="p-0019" num="0018">In some embodiments, the system generates the one or more shrunk dynamic call graphs by: (i) identifying a subroutine in the application that receives and handles the one or more input requests; (ii) inserting probes at each subroutine entry and each subroutine exit in the application; (iii) tracking a running height, a running crest, and a running trough of the subroutine being entered; (iv) obtaining a crest point in the plurality of shrunk dynamic call graphs by comparing an absolute difference of the running crest, and the running trough to the shrink factor; (v) repeating the step (ii) and tracking a running height, a running crest, and a running trough of the subroutine being exited; and (vi) obtaining a trough point in the one or more shrunk dynamic call graphs by comparing an absolute difference of the running crest, and the running trough to the shrink factor.</p><p id="p-0020" num="0019">In another aspect, there is provided one or more non-transitory computer-readable storage medium storing the one or more sequence of instructions, which when executed by one or more processors, causes to perform a method for identifying an anomaly and a root cause of the anomaly in an application using a one or more shrunk dynamic call graphs. The method includes, generating, using an instrumentation agent, a one or more shrunk dynamic call graphs by providing a shrink factor to the instrumentation agent when the application receives a one or more input requests, wherein the one or more input requests is received from a user device. The method includes, identifying, using a machine learning model, an anomalous group of the one or more shrunk dynamic call graphs associated with the one or more input requests that are failed, from one or more groups of the one or more shrunk dynamic call graphs. The method includes, identifying a deviation in the one or more shrunk dynamic call graphs of the one or more input requests that are failed by comparing the one or more shrunk dynamic call graphs associated with the one or more input requests that are failed from the anomalous group with the one or more shrunk dynamic call graphs associated with of the one or more input requests that are successful. The method includes, identifying an anomaly based on the deviation in the one or more shrunk dynamic call graphs associated with the one or more input requests that are failed and an exception thrown around the deviation point as the root cause of identified anomaly in the application.</p><p id="p-0021" num="0020">In some embodiments, the non-transitory computer-readable storage medium storing the one or more sequence of instructions the identifying the anomalous group of the one or more shrunk dynamic call graphs associated with comprises (i) obtaining a centroid of a dataset of each input request, (ii) obtaining a one or more centroids of each of the one or more groups of the one or more shrunk dynamic call graphs, (iii) obtaining a one or more centroids based on the exception thrown in each input request, (iv) obtaining, using the one or more centroids, a farthest centroid from the centroid of the dataset, (iv) identifying, using the farthest centroid, a first anomalous group of the one or more shrunk dynamic call graphs associated with the one or more input requests that are failed, (v) identifying, using the farthest centroid, a second anomalous group based on the exception associated with the one or more input requests that are failed, and (vi) identifying the anomalous group if the first anomalous group of the one or more shrunk dynamic call graphs and the second anomalous group based on the exception are same. In non-transitory computer-readable storage medium storing the one or more sequence of instructions the method further includes creating, using the machine learning model, the one or more groups of the one or more shrunk dynamic call graphs based on a similarity between the one or more shrunk dynamic call graphs after removing repeating patterns in the one or more shrunk dynamic call graphs.</p><p id="p-0022" num="0021">In some embodiments, the non-transitory computer-readable storage medium storing the one or more sequence of instructions, generating the one or more shrunk dynamic call graphs includes (i) identifying a subroutine in the application that receives and handles the one or more input requests; (ii) inserting probes at each subroutine entry and each process exit in the application; (iii) tracking a running height, a running crest, and a running trough of the subroutine being entered; (iv) obtaining a crest point in the plurality of shrunk dynamic call graphs by comparing an absolute difference of the running crest, and the running trough to the shrink factor; (v) repeating the step (ii) and tracking a running height, a running crest, and a running trough of the subroutine being exited; and (vi) obtaining a trough point in the one or more shrunk dynamic call graphs by comparing an absolute difference of the running crest, and the running trough to the shrink factor.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0023" num="0022">The embodiments herein will be better understood from the following detailed description with reference to the drawings, in which:</p><p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a system view that illustrates interaction between a user, a monitored system and an analysis engine according to an embodiment herein;</p><p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. <b>2</b>A</figref> is an exemplary graphical representation of a sample dynamic call graph collected from a live running application according to an embodiment herein;</p><p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. <b>2</b>B</figref> is an exemplary graphical representation of three dynamic call graphs for three executions of the same program according to an embodiment herein;</p><p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates a schematic representation of anomaly detecting and root cause automation system according to an embodiment herein;</p><p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. <b>4</b>A</figref> is an exemplary visual representation of the dynamic call graph drawn with stack depth as height on the y-axis and call number as length on the x-axis according to an embodiment herein;</p><p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. <b>4</b>B</figref> shows a resulting graph after removing intermediate nodes in the process of shrinking according to an embodiment herein;</p><p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. <b>4</b>C</figref> shows a resulting shrunk dynamic call graph after shrinking with shrink factor 1 according to an embodiment herein;</p><p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. <b>4</b>D</figref> shows a resulting shrunk dynamic call graph after shrinking with shrink factor <b>3</b> according to an embodiment herein;</p><p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. <b>5</b>A</figref> shows an exemplary shrunk dynamic call graph collected from a running program using shrink factor <b>60</b> according to an embodiment herein;</p><p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. <b>5</b>B</figref> shows the shrunk dynamic call graph after removing repeating patterns according to an embodiment herein;</p><p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. <b>5</b>C</figref> shows one set of three invocations of an operation type forming into same cluster using DBSCAN according to an embodiment herein;</p><p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. <b>5</b>D</figref> shows another set of three invocations of an operation type forming into another duster using DBSCAN according to an embodiment herein;</p><p id="p-0036" num="0035"><figref idref="DRAWINGS">FIG. <b>6</b>A</figref> illustrates a comparison of anomaly shrunk dynamic call graph to success shrunk dynamic call graph to identify the deviation point according to an embodiment herein;</p><p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. <b>6</b>B</figref> illustrates an exemplary cluster report for clusters created by DBSCAN for an operation type during test execution of e-commerce application according to an embodiment herein;</p><p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a flow diagram that illustrates a method of anomaly detecting and root cause automation according to an embodiment herein;</p><p id="p-0039" num="0038"><figref idref="DRAWINGS">FIG. <b>8</b></figref> illustrates an exploded view of a computing device according to an embodiment herein; and</p><p id="p-0040" num="0039"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a schematic diagram of a computer architecture in accordance with the embodiments herein.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0005" level="1">DETAILED DESCRIPTION OF THE DRAWINGS</heading><p id="p-0041" num="0040">The embodiments herein and the various features and advantageous details thereof are explained more fully with reference to the non-limiting embodiments that are illustrated in the accompanying drawings and detailed in the following description. Descriptions of well-known components and processing techniques are omitted so as to not unnecessarily obscure the embodiments herein. The examples used herein are intended merely to facilitate an understanding of ways in which the embodiments herein may be practiced and to further enable those of skill in the art to practice the embodiments herein. Accordingly, the examples should not be construed as limiting the scope of the embodiments herein.</p><p id="p-0042" num="0041">As mentioned, there is a need for a system and method for automatically identifying anomalies and analyzing the root cause of the anomalies in real-time production applications to reduce Mean Time To Repair (MTTR) the anomalies. The embodiments herein achieve this by proposing a system that detects anomalies in real-time production applications and analyze the root cause of the anomalies based on shrunk dynamic call graphs. Referring now to the drawings, and more particularly to <figref idref="DRAWINGS">FIGS. <b>1</b> through <b>9</b></figref>, where similar reference characters denote corresponding features consistently throughout the figures, preferred embodiments are shown.</p><p id="p-0043" num="0042"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a system view <b>100</b> that illustrates the interaction between a user <b>102</b>, a monitored system <b>104</b> and an analysis engine <b>106</b> according to an embodiment herein. The monitored system <b>104</b> includes a first processor and a first memory that stores a first set of instructions that are executed by the first processor. The monitored system <b>104</b> includes, but is not limited to, a handheld device, a mobile phone, a kindle, a Personal Digital Assistant (PDA), a tablet, a laptop, a music player, a computer, an electronic notebook, or a smartphone and the like. The monitored system <b>104</b> runs an application to be monitored and detects for one or more anomalies. The analysis engine <b>106</b> includes a second processor and a second memory that stores a second set of instructions which are executed by the second processor. The analysis engine <b>106</b> includes, but is not limited to, a handheld device, a mobile phone, a kindle, a Personal Digital Assistant (PDA), a tablet, a laptop, a music player, a computer, an electronic notebook, or a smartphone and the like. The user <b>102</b> is a user of the monitored system <b>104</b>. In one embodiment, the user <b>102</b> may interact with the monitored system <b>104</b> using standard tools or interfaces like web browser over http protocol. The monitored system <b>104</b> is provided with an instrumentation agent. The instrumentation agent instruments the application running on the monitored system <b>104</b>. In one embodiment, the instrumentation agent inserts monitoring code or call tags into the monitored system <b>104</b>. The instrumentation agent generates one or more shrunk dynamic call graphs by providing a shrink factor and an exception from the monitored system <b>104</b> for each input request from the user <b>102</b>. The monitored system <b>104</b> interacts with the analysis engine <b>106</b> and transmits the shrunk dynamic call graph to the analysis engine <b>106</b> over a network. The network includes, but is not limited to, a wireless network, a wired network, a combination of the wired network and the wireless network or Internet, and the like. The analysis engine <b>106</b> identifies, using a machine learning model, an anomalous group of the one or more shrunk dynamic call graphs associated with the one or more input requests that are failed, from one or more groups of the one or more shrunk dynamic call graphs. The analysis engine <b>106</b> identifies a deviation in the one or more shrunk dynamic call graphs of the one or more input requests that are failed by comparing the one or more shrunk dynamic call graphs associated with the one or more input requests that are failed from the anomalous group with the one or more shrunk dynamic call graphs associated with the one or more input requests that are successful. The analysis engine <b>106</b> identifies an anomaly based on the deviation in the one or more shrunk dynamic call graphs associated with the one or more input requests that are failed and an exception thrown around the deviation point as the root cause of the identified anomaly in the monitored application.</p><p id="p-0044" num="0043"><figref idref="DRAWINGS">FIG. <b>2</b>A</figref> is an exemplary graphical representation of a sample dynamic call graph collected from a live running application according to an embodiment herein. The dynamic call graph has call stack depth on the vertical axis and method invocation count or call number on the horizontal axis. The dynamic call graph recording starts when program's starting method (such as main( ) method or in the case of web application when the web server receives a request and invokes a starting method to start request processing such as service( ) method) is invoked and ends when such method exits. An instrumentation agent inserts monitoring code or probes or call-tags at each method entry and exit points of each class in the live running application. The probes at method entry may record as method being entered. In one embodiment, the probes at method entry may record optionally a method name, a class name, and a package name. In an exemplary scenario, the probes record &#x3e;com.sg.SampleProgram.main at the time of method entry where&#x3e; means a method entry and com.sg.SampleProgram.main is a package name, class name, and method name. The probes at method exit may record as the method being exited. In one embodiment, the probes may record optionally a method name, a class name, and a package name. In an exemplary scenario, the probes record &#x3c;com.sg.SampleProgram.main at the time of method exit where &#x3c;means a method exit and com.sg.SampleProgram.main is a package name, class name, and method name. The method where the dynamic call graph recording starts and ends is also inserted with additional probes that will start and end dynamic call graph recording. At the time of entry into such a method, first, a place holder data structure is created and stored in a map with currently running thread name of the running application as the key. The map with the thread name as the key is used to store place holder data structure to avoid data corruption in a multithreaded environment. As methods are entered and exited, this place holder data structure is appended with entry/exit recordings by method entry/exit probes. At the time of the exiting method that ends recording, the recordings in the place holder data structure corresponding to the currently running thread will be persisted into a file on the hard disk and corresponding entry is removed from the map.</p><p id="p-0045" num="0044"><figref idref="DRAWINGS">FIG. <b>2</b>B</figref> is an exemplary graphical representation of three dynamic call graphs for three executions of the same program according to an embodiment herein. In <figref idref="DRAWINGS">FIG. <b>2</b>B, <b>204</b> and <b>206</b></figref> represent dynamic call graphs of successful execution of the live running application and <b>208</b> represents dynamic call graph of failed execution of the live running application which includes significant deviation from the dynamic call graphs <b>204</b> and <b>206</b>. The dynamic call graphs <b>208</b> of failed executions of the live running application have major deviations compared to the dynamic call graphs <b>204</b> and <b>206</b> of the successful executions of the live running application. The failed executions of the live running application execute different code branches after error/exception which becomes visible in the call graph representation.</p><p id="p-0046" num="0045"><figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates a schematic representation of anomaly detecting and root cause automation system <b>100</b> according to an embodiment herein. The anomaly detecting and root cause automation system <b>100</b> includes a user input module <b>302</b> that sends input requests to a monitored application <b>306</b>, a monitored system <b>304</b> that runs the monitored application <b>306</b> and an analysis engine <b>312</b>. In one embodiment, the input request may include http request 1, or http request 2, or http request 3. The monitored application <b>306</b> includes instrumentation agent <b>308</b> that scans millions of lines of application code of the monitored application <b>306</b> and automatically injects monitoring code or probes or call tags in the monitored application <b>306</b>. The instrumentation agent <b>308</b> (monitoring code or probes or call tags) generates one or more shrunk dynamic call graphs by providing a shrink factor and an exception from the monitored application <b>306</b> when the user input module <b>302</b> initiates a request to the monitored system <b>304</b>. The shrunk dynamic call graph is a less detailed representation of a dynamic call graph of the monitored application <b>306</b>. The shrunk dynamic call graph is obtained as a result of ignoring finer details in the dynamic call graphs and retaining only overall meaning (large patterns or major changes or summary or important nodes) of the dynamic call graphs. In one embodiment, the shrunk dynamic call graphs considered as a skeleton of the dynamic call graph and the shrunk dynamic call graphs can be generated faster without losing overall meaning and helps in making certain decisions. The monitored system <b>304</b> transfers the shrunk dynamic call graph to the analysis engine <b>312</b> over a network. The analysis engine <b>312</b> detects anomalies in the monitored application <b>306</b> based on the shrunk dynamic call graphs. In one embodiment the analysis engine <b>312</b> compares the shrunk dynamic call graphs of the monitored application <b>306</b> with the shrunk dynamic call graphs of the successful execution to identify a deviation point in the shrunk dynamic call graphs of the monitored application <b>306</b>.</p><p id="p-0047" num="0046">In one embodiment, large patterns in the dynamic call graphs generated for multiple runs of an operation of the monitored application <b>306</b> are mostly similar. In one embodiment, the similar patterns can be extracted using pattern recognition methods or machine learning algorithms from multiple executions of an operation of the monitored application <b>306</b> and extracted knowledge of patterns is used to detect anomalies in subsequent executions of the same operation of the monitored application <b>306</b>. In one embodiment, any deviation in the patterns of subsequent executions of the monitored application <b>306</b> compared to the knowledge of patterns from majority executions of the monitored application <b>306</b> indicates anomalous behavior. As the shrunk dynamic call graphs retain large patterns or overall meaning of dynamic call graphs, this raises the need for efficient ways to generate shrunk dynamic call graphs.</p><p id="p-0048" num="0047">The shrunk dynamic call graphs of the monitored application <b>306</b> are either stored on the hard disk of monitored system <b>304</b> or forwarded to the analysis engine <b>312</b> over the network. In an embodiment, a data agent <b>310</b> collects the shrunk dynamic call graphs and the errors or exceptions from the hard disk of the monitored system <b>304</b> and forwards the collected shrunk dynamic call graphs and the errors or exceptions to the analysis engine <b>312</b> over the network. The continuous clustering system <b>314</b> in the analysis engine <b>312</b> analyses, using machine learning, the shrunk dynamic call graphs to find anomalies in the monitored application <b>306</b>, determine the root cause of the anomalies and provide alerts. A data store <b>316</b> in the analysis engine <b>312</b> stores detected anomalies and root causes of the anomalies by the analysis engine <b>312</b>. The analysis engine <b>312</b> runs on a separate machine with a processor and memory. In an embodiment, the analysis engine <b>312</b> can be on-prem or on cloud and should be connectable over a network protocol. In some embodiments, in case of haps request as input, admin user interface <b>318</b> may send to the analysis engine <b>312</b> directly, as it is a secured version.</p><p id="p-0049" num="0048"><figref idref="DRAWINGS">FIG. <b>4</b>A</figref> is an exemplary visual representation of the dynamic call graph drawn with stack depth as height on the y-axis and call number as length on the x-axis according to an embodiment herein. The first invoked method is assigned by a call number 0, next invoked method is assigned by a call number 1 and so on. The peak points (6:D, 7:D, 5:X, 3:F, 4:B, 6:D, 7:X) on the graph are called as crest points and the lowest points (1:main, 5:D, 4:C, 2:B, 2F, 1:A, 3:B, 0:main) on the graph are called as trough points.</p><p id="p-0050" num="0049">In one embodiment, a shrink factor defines the amount of detail that needs to be removed from the dynamic call graph of the monitored application for generating the shrunk dynamic call graph, wherein the shrunk dynamic call graph includes only crest points and trough points with absolute height difference between any two adjacent points is greater than the given shrink factor. The peak points of the dynamic call graphs are considered as crest nodes, and the lowest points of the dynamic call graphs are considered as trough nodes. In one embodiment, a greater amount of detail is removed from the dynamic call graph when the shrink factor is higher. In one embodiment, a lesser amount of detail is removed from the dynamic call graph when the shrink factor is smaller.</p><p id="p-0051" num="0050">In one embodiment, the method of shrinking includes (i) removing intermediate nodes in the dynamic call graph, (ii) retaining only crest nodes and trough nodes in the dynamic call graph, (iii) moving resulting nodes to left by the number of preceding nodes removed, (iv) removing every edge in the resulting nodes whose height is less than or equal to shrink factor, (v) removing nodes of the removed edge, (vi) joining broken links, and (vii) moving resulting nodes to left by the number of preceding nodes removed to generate the shrunk dynamic call graph.</p><p id="p-0052" num="0051"><figref idref="DRAWINGS">FIG. <b>4</b>B</figref> shows a resulting graph after removing intermediate nodes in the process of shrinking (after steps i, ii, and iii) according to an embodiment herein. The shrinking process removes nodes <b>2</b>:A, <b>3</b>:B, <b>4</b>:A, <b>5</b>:C, <b>6</b>:F, <b>6</b>:D, <b>5</b>:F, <b>4</b>:X, <b>3</b>:A, <b>3</b>:C, <b>3</b>:B, <b>2</b>:C, <b>2</b>:A, <b>3</b>:C, <b>4</b>:B, <b>5</b>:B, <b>5</b>:D, <b>4</b>:B, <b>4</b>:B, <b>5</b>:B, <b>6</b>:F, <b>6</b>:X, <b>5</b>:F, <b>4</b>:B, <b>3</b>:B, <b>2</b>:C and <b>1</b>:A from the dynamic call graph of the <figref idref="DRAWINGS">FIG. <b>4</b>A</figref>.</p><p id="p-0053" num="0052"><figref idref="DRAWINGS">FIG. <b>4</b>C</figref> shows a resulting shrunk dynamic call graph after shrinking with shrink factor 1 according to an embodiment herein. After steps iv, v, vi and vii on the graph in <figref idref="DRAWINGS">FIG. <b>4</b>B</figref>, the edge <b>3</b>:F-<b>2</b>:F of height 1, and it's nodes <b>3</b>:F and <b>2</b>:F are removed and the broken links are joined to form a longer edge <b>7</b>:D-<b>2</b>:B (Note that edge <b>4</b>:C-<b>5</b>:X is also removed in the shrinking process). Edge <b>2</b>:B-<b>3</b>:F merges into edge <b>2</b>:B-<b>4</b>:B.</p><p id="p-0054" num="0053"><figref idref="DRAWINGS">FIG. <b>4</b>D</figref> shows a resulting shrunk dynamic call graph after shrinking a dynamic call graph in <figref idref="DRAWINGS">FIG. <b>4</b>A</figref> with shrink factor 3 according to an embodiment herein.</p><p id="p-0055" num="0054">In one embodiment, shrink factor defines, to instrumentation agent <b>308</b>, the amount of detail that needs to be recorded from running programs such that the resulting shrunk dynamic call graph contains only crest points and trough points with absolute height difference between any 2. adjacent points is greater than the given shrink factor.</p><p id="p-0056" num="0055">In one embodiment, while generating shrunk dynamic call graphs directly from the live running application, the appropriate shrink factor is provided as input to the probes. In an embodiment, the shrink factor is configurable and updatable dynamically. The amount of detail generated by the probes in shrunk dynamic call graphs of the live running application depends on the shrink factor applied. In one embodiment, the amount of detail generated in the shrunk dynamic call graph is maximum when the shrink factor is less. The amount of detail generated in the shrunk dynamic call graph is minimum when the shrink factor is high. In an embodiment, using appropriate shrink factor the probes capture less detail in the shrunk dynamic call graph without distorting the meaning. In an embodiment, the desired shrink factor may be determined by testing the live running application with different shrink factors and choosing the one with the best result.</p><p id="p-0057" num="0056">In one embodiment, a method of the live running application that receives and handles input requests from user <b>102</b> is identified, In an exemplary embodiment, the method is a start-end method for shrunk dynamic call graphs. The instrumentation agent <b>308</b> inserts the method entry probe at every method entry and the method exit probe at every method exit of all classes of the monitored application <b>306</b> in the monitored system <b>304</b>. The probes at method entry or exit tracks three parameters, a running height (or depth of the stack), a running crest and a running trough. The probe compares the absolute difference of the running crest and the running trough to the shrink factor and chooses to record running crest/trough based on the value of an index variable, where index is a running counter indicating number of nodes recorded. The recorded data includes an entry/exit, a method name, a class name and a package name of the recorded running crest/trough's node. In an exemplary embodiment, the instrumentation agent records at method entry includes 10&#x3e;com.sg.SampleProgram.main (or just 10), where 10 is a running crest/trough, &#x3e;means it is a method entry, com.sg.SampleProgram is class name including package name and main is the method being entered. In one embodiment, the start-end method is also inserted with additional probes that will start and end capturing shrunk dynamic call graph, capture the received HTTP method, GET/POST request parameters, thread name, HTTP response status code, session information, etc. In one embodiment, at the time of method entry, the monitored system <b>304</b> creates a place holder data structure and stores in a map with currently running thread name of the live running application as key. In one embodiment, to avoid data corruption in a multithreaded environment, the map with the thread name as the key is used to store the place holder data structure. When the place holder data structure is created, the place holder data structure will be updated with the operation name of the request, it can be http URL in a web application. The operation name may be used in an analysis part for grouping shrunk dynamic call graphs of the same operation. As methods are entered and exited, including the start-end method, this place holder data structure is appended with running trough/running crest recordings by probes. At the time of exiting the start-end method, the recordings in the place holder data structure, corresponding to the currently running thread, will be persisted into a file on the hard disk and then corresponding entry is removed from the map. In one embodiment, additional probe is executed at entry into the start-end method to record the first node of the shrunk dynamic call graph.</p><p id="p-0058" num="0057">In one embodiment, the instrumentation agent <b>308</b> inserts appropriate probes to collect thrown errors and exceptions while executing a live running application. The thrown errors and exceptions are recorded and marked with the nearest running crest/running; trough of shrunk dynamic call graph being recorded.</p><p id="p-0059" num="0058"><figref idref="DRAWINGS">FIG. <b>5</b>A</figref> shows an exemplary shrunk dynamic call graph collected from a running program using shrink factor <b>60</b> according to an embodiment herein. The instrumentation agent <b>308</b> continuously generates shrunk dynamic call graphs for each input request or invocation from the user <b>102</b> for the live running application. The instrumentation agent <b>308</b> stores them on a hard disk or forwards them to the analysis engine <b>312</b> over the network. In one embodiment, if the shrunk dynamic call graphs are stored on the hard disk, the data agent <b>310</b> continuously forwards the shrunk dynamic call graphs to the analysis engine <b>312</b> over the network.</p><p id="p-0060" num="0059">In one embodiment, the shrunk dynamic call graph is a skeleton representation of a dynamic call graph and captures the meaning of the dynamic call graph of the live running application in 10 to 30 recordings or nodes. In one embodiment, as the shrunk dynamic call graph is only a skeleton representation of dynamic call graph, its generation from running program may consume very less memory and thus it helps in an exponential increase in response times.</p><p id="p-0061" num="0060">In <figref idref="DRAWINGS">FIG. <b>5</b>A</figref>, a pattern <b>89</b>-<b>161</b> is repeating 3 times in the shrunk dynamic call graph. The repeating patterns are formed due to loops or recursive execution of code in the live running application which can be considered noise. The repeating patterns except a single pattern can be safely removed without losing the meaning. The repeating patterns are removed from all shrunk dynamic call graphs. The resulting shrunk dynamic call graph after removing repeating patterns in <figref idref="DRAWINGS">FIG. <b>5</b>A</figref> is shown in <figref idref="DRAWINGS">FIG. <b>5</b>B</figref>.</p><p id="p-0062" num="0061">In one embodiment, the monitored system performs real-time data analysis. The analysis engine <b>312</b> uses unsupervised learning algorithms such as DBSCAN.</p><p id="p-0063" num="0062">In one embodiment, the shrunk dynamic call graphs of same operation type look similar because they execute same code branches in the live running application. In an embodiment, the shrunk dynamic call graphs are grouped into homogenous groups according to the operation type (HTTP URL or functionality) and DBSCAN is applied separately for each group. Though the shrunk dynamic call graphs of the same operation type appear similar, they may have small differences. Due to this small difference in the shrunk dynamic call graphs, the shrunk dynamic call graphs form into multiple clusters when DBSCAN is applied.</p><p id="p-0064" num="0063"><figref idref="DRAWINGS">FIG. <b>5</b>C</figref> shows one set of three invocations of an operation type forming into the same cluster using DBSCAN according to an embodiment herein. <figref idref="DRAWINGS">FIG. <b>5</b>C</figref> includes three invocations of &#x201c;add item to cart&#x201d; operation in an e-commerce application that all look similar. Though the invocation 3 appears different at node <b>131</b> at length <b>1</b> however all three invocations invocation1, invocation2 and invocation3 forms into the same cluster using DBSCAN with appropriate minPoints and epsilon parameters.</p><p id="p-0065" num="0064"><figref idref="DRAWINGS">FIG. <b>5</b>D</figref> shows another set of three invocations of an operation type forming into another cluster using DBSCAN according to an embodiment herein. <figref idref="DRAWINGS">FIG. <b>5</b>D</figref> shows three invocations of the same &#x201c;add item to cart&#x201d; operation in the same e-commerce application that appears the same. The invocation 4, invocation 5 and invocation 6 forms into another cluster using DBSCAN.</p><p id="p-0066" num="0065">In one embodiment, the anomaly detecting and root cause automation system <b>100</b> uses machine learning which requires large amounts of data. In one embodiment, the anomaly detecting and root cause automation system <b>100</b> waits for the running application to execute for some time while user <b>102</b> is accessing the application in monitored system <b>304</b>. The anomaly detecting and root cause automation system <b>100</b> (i) removes the repeating patterns from the shrunk dynamic call graphs after collecting enough data, (ii) applies unsupervised machine learning algorithms like DBSCAN to create clusters. The number of clusters in data is unknown, as the anomaly detecting and root cause automation system <b>100</b> is performing real-time analysis and clustering. In one embodiment, the DBSCAN automatically creates clusters based on minPoints, epsilon, and a distance function. In an embodiment, the DBSCAN filters out noise due to class loading (in a few programming languages) using an appropriate minPoints.</p><p id="p-0067" num="0066">In one embodiment, minPoints specifies the minimum number of points to form a dense region or a cluster. For example, if the minPoints parameter as 5, then at least 5 points is required to form a dense region or a cluster. In one embodiment, with DBSCAN's minPoints parameter, an anomaly occurs at least minPoints number of times for them to form into a cluster. If the epsilon is smaller, the number of clusters created by DBSCAN is larger and vice-versa. In an embodiment, the optimal values of epsilon are detected by the elbow method or silhouette method.</p><p id="p-0068" num="0067">In one embodiment, the DBSCAN continuously creates clusters as new shrunk dynamic call graphs are received. The continuous clustering is performed when shrunk dynamic call graphs are received or at regular intervals.</p><p id="p-0069" num="0068">In one embodiment, the number of clusters may vary over time. The continuous clustering occurs as a result of the dynamic reception of data over an unknown and potentially indefinite time period. In an embodiment, the clusters are formed incrementally.</p><p id="p-0070" num="0069">In one embodiment, as the anomaly detecting analysis in real-time is automated, the labeling of clusters is also automated and real-time. The output data from the anomaly detecting and root cause automation system <b>100</b> indicates to distinguish between an anomaly execution and a successful execution. In one embodiment, the anomaly detecting and root cause automation system <b>100</b> assumes that anomalies occur rarely. In one embodiment, if the majority of the invocations of an operation type are successful, the indication from the output data of the anomaly detecting and root cause automation system <b>100</b> is obtained. In one embodiment, the anomaly detecting and root cause automation system <b>100</b> helps when more than 50% of the invocations of an operation are successful.</p><p id="p-0071" num="0070">In one embodiment, the analysis engine <b>106</b> for each operation type, a) creating clusters based on shrunk dynamic call graphs with unsupervised machine learning algorithm DBSCAN b) finding the centroid C of all shrunk dynamic call graphs c) finding centroids K<b>1</b>, K<b>2</b>, K<b>3</b> etc., for each cluster d) using centroids, finding the centroid Ki that is farthest from centroid C and take note of its cluster. The farthest centroid Ki from centroid C is an outlier and its cluster is a point for becoming an anomaly. The recorded cluster of centroid Ki is a candidate for becoming an anomaly since the centroid C of the dataset drifts towards majority invocations (dense population) which are successful. The data points of anomaly invocations lie far away from the centroid C of the dataset.</p><p id="p-0072" num="0071">In another preferred embodiment, the analysis engine <b>106</b> detects outlier cluster based on exceptions or error data of the Shrunk Dynamic Call Graphs by (a) calculating count of each exception or error from the entire dataset of the operation type of the running program; (b) providing weights to exceptions or errors based on number of times that occurred, (c) calculating average exception weight for every cluster obtained using DBSCAN by (i) adding weights of every exception or error of every data item of the cluster (ii) ignoring duplicate exception or error while adding weights to exception/error of the data item in the cluster and (iii) dividing result with number of data items in the cluster, (d) identifying and recording the cluster with highest average exception weight. The cluster with the highest average exception weight becomes an anomaly candidate, If the cluster with the highest average exception weight and the cluster of farthest centroid Ki are the same, then the analysis engine <b>106</b> considers that cluster as anomaly and report for review and action.</p><p id="p-0073" num="0072"><figref idref="DRAWINGS">FIG. <b>6</b>A</figref> illustrates a comparison of an anomaly shrunk dynamic call graph to a success shrunk dynamic call graph to identify the deviation point according to an embodiment herein. In <figref idref="DRAWINGS">FIG. <b>6</b>A</figref>, the shrunk dynamic call graph of anomaly invocation continues to execute like a success invocation until it deviates after node of height <b>80</b> (at length <b>4</b>) as highlighted in circle <b>602</b>. The shrunk dynamic call graph of anomaly invocation is compared to the shrunk dynamic call graph of success invocation. By finding which exception/error thrown in the data item of anomaly invocation compared to data item of success invocation, around nodes <b>80</b> and <b>171</b> of anomaly invocation may give root cause exception/error of anomaly. When the instrumentation agent collects exceptions/errors, the node around which the exceptions/errors are thrown is also marked.</p><p id="p-0074" num="0073">The analysis engine <b>106</b> considers that cluster as an anomaly and generates a report that includes anomaly information for review and action. In one embodiment, the report may include (a) HTTP URL of the request in case of web application or operation type, (b) HTTP request type such as GET, POST, UPDATE, (c) thread name that processed the invocation, (d) HTTP request parameters (GET parameters or POST parameters), (e) HTTP session-id or user details, (f) HTTP response status code, (g) exception or error causing the anomaly, (h) All exceptions or errors thrown while processing anomalous invocation, (i) anomaly cluster size, which indicates number of times the operation has been anomalous.</p><p id="p-0075" num="0074">In an alternate embodiment, the analysis engine <b>106</b> gives ranks to clusters of shrunk dynamic call graphs by, (i) finding centroid C of entire dataset of the operation type of the running program (ii) finding centroids K1, K2, K3 etc of each cluster of the operation type of the running program (iii) calculating the distance Di of each cluster centroid Ki to the centroid C, arranging the distances Di of the clusters in descending order, ranking the clusters based on the distance to centroid C. The cluster whose centroid K is farthest from the centroid C is ranked as first. Clusters are also similarly ranked using exceptions/errors data. Average of both ranks is calculated for each cluster. The cluster with highest average rank is a possible anomaly cluster and reported for review and action. Other clusters may also be reported in the order of average rank with appropriate severity.</p><p id="p-0076" num="0075">In one embodiment, it is possible in a production-grade application that each invocation of an operation is successful. In such a case, the anomaly detecting and root cause automation system <b>100</b> finds each cluster is successfully processed. In an embodiment, the anomaly detecting and root cause automation system <b>100</b> is using two types of data, shrunk dynamic call graphs and exceptions/errors in determining anomalous cluster and the anomaly detecting and root cause automation system <b>100</b> marks a cluster as anomaly only if both types of data determines the same cluster as outlier. In an embodiment, if shrunk dynamic call graphs data processing finds a cluster as an outlier and not by exceptions/error data processing, no cluster is detected as anomalous and, in that case, each invocation of an operation is successful. In an embodiment, the anomaly detecting and root cause automation system <b>100</b> avoids marking a cluster as an anomaly when each invocation of an operation is successful, giving accurate results.</p><p id="p-0077" num="0076">In another embodiment, if needed an additional layer of protection can be placed by defining the percentage majority of invocations, which are successful, is at least 80%. In an embodiment, if the anomaly detecting and root cause automation system <b>100</b> finds a cluster as anomalous, such cluster size is less than 20% of the size of the dataset of that operation type, or as needed and appropriate the ratio can be set as 70% to 30% and this value is dynamically configurable/updatable.</p><p id="p-0078" num="0077">In one embodiment, it is suggested to instrument all methods of all classes in the application/program. There is exponential performance gain in generating shrunk dynamic call graphs compared to generating dynamic call graphs. However, it is essential to understand that the system doesn't need to instrument all methods of all classes of monitored application <b>306</b>. The system can still capture the overall meaning by instrumenting only a partial code base. For this instrumentation agent <b>308</b> can be designed to restrict a set of methods/classes/packages to be instrumented through include and exclude filters and accordingly perform probe insertion. How much % of the codebase or what classes/packages to be instrumented can be decided based on a few test-runs of the application. In a complex application/program as low as 20% of codebase instrumentation is enough to generate meaningful shrunk dynamic call graphs. With only 20% code instrumented, overhead on the monitored application <b>306</b> is guaranteed to reduce by a factor of 5 on top of exponential performance gain in generating shrunk dynamic call graphs.</p><p id="p-0079" num="0078">In one embodiment, the meaning captured in the shrunk dynamic call graphs with one set of shrink factor, by including and excluding filters is different from the meaning captured in the shrunk dynamic call graphs with other set of shrink factor, include and exclude filters. In one embodiment, before using the anomaly detecting and root cause automation system in production applications appropriate values for settings need to be identified/calculated and used.</p><p id="p-0080" num="0079">In one embodiment, the instrumentation agents continuously generate shrunk dynamic call graphs (for every http request or invocation) from running applications.</p><p id="p-0081" num="0080"><figref idref="DRAWINGS">FIG. <b>6</b>B</figref> illustrates an exemplary cluster report for clusters created by DBSCAN for an operation type during test execution of e-commerce application according to an embodiment herein. <figref idref="DRAWINGS">FIG. <b>6</b>B</figref> shows one anomaly cluster <b>604</b> of size 80 and 6 success clusters of different sizes. The size of the bar indicates number of executions of the operation.</p><p id="p-0082" num="0081"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a flow diagram that illustrates a method of anomaly detecting and root cause automation system according to an embodiment herein. At step <b>702</b>, generating, using an instrumentation agent, a plurality of shrunk dynamic call graphs by providing a shrink factor to the instrumentation agent when the application receives a plurality of input requests, wherein the plurality of input requests is received from a user device. At step <b>704</b>, identifying, using a machine learning model, an anomalous group of the plurality of shrunk dynamic call graphs associated with the plurality of input requests that are failed, from one or more groups of the plurality of shrunk dynamic call graphs. At step <b>706</b>, identifying a deviation in the plurality of shrunk dynamic call graphs of the plurality of input requests that are failed by comparing the plurality of shrunk dynamic call graphs associated with the plurality of input requests that are failed from the anomalous group with the plurality of shrunk dynamic call graphs associated with the plurality of input requests that are successful. At step <b>708</b>, identifying an anomaly based on the deviation in the plurality of shrunk dynamic call graphs associated with the plurality of input requests that are failed and an exception thrown around the deviation point as the root cause of the identified anomaly in the application.</p><p id="p-0083" num="0082"><figref idref="DRAWINGS">FIG. <b>8</b></figref> illustrates an exploded view of the computing device (e.g. the user device <b>104</b>) of <figref idref="DRAWINGS">FIG. <b>1</b></figref> according to the embodiments herein. The computing device having a memory <b>802</b> having a set of computer instructions, a bus <b>804</b>, a display <b>806</b>, a speaker <b>808</b>, and a processor <b>810</b> capable of processing a set of instructions to perform any one or more of the methodologies herein, according to an embodiment herein. The processor <b>810</b> may also enable digital content to be consumed in the form of a video for output via one or more displays <b>806</b> or audio for output via speaker and/or earphones <b>808</b>. The processor <b>810</b> may also carry out the methods described herein and in accordance with the embodiments herein.</p><p id="p-0084" num="0083">The embodiments herein can take the form of, an entirely hardware embodiment, an entire software embodiment or an embodiment including both hardware and software elements. The embodiments that are implemented in software include but are not limited to, firmware, resident software, microcode, etc. Furthermore, the embodiments herein can take the form of a computer program product accessible from a computer-usable or computer-readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description, a computer-usable or computer-readable medium can be any apparatus that can comprise, store, communicate, propagate, or transport the program for use by or in connection with the instruction execution system, apparatus, or device.</p><p id="p-0085" num="0084">The medium can be an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system (or apparatus or device) or a propagation medium. Examples of a computer-readable medium include a semiconductor or solid-state memory, magnetic tape, a removable computer diskette, a random access memory (RAM), a read-only memory (ROM), a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk-read-only memory (CD-ROM), compact disk-read/write (CD-R/W) and DVD.</p><p id="p-0086" num="0085">A data processing system suitable for storing and/or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus. The memory elements can include local memory employed during actual execution of the program code, bulk storage, and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.</p><p id="p-0087" num="0086">Input/output (I/O) devices (including but not limited to keyboards, displays, pointing devices, remote controls, etc.) can be coupled to the system either directly or through intervening I/O controllers. Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Moderns, cable modem, and Ethernet cards are just a few of the currently available types of network adapters.</p><p id="p-0088" num="0087">A representative hardware environment for practicing the embodiments herein is depicted in <figref idref="DRAWINGS">FIG. <b>9</b></figref>, with reference to <figref idref="DRAWINGS">FIGS. <b>1</b> through <b>8</b></figref>. This schematic drawing illustrates a hardware configuration of a server/computer system/computing device in accordance with the embodiments herein. The system includes at least one processing device CPU <b>10</b> that may be interconnected via system bus <b>14</b> to various devices such as a random access memory (RAM) <b>12</b>, read-only memory (ROM) <b>16</b>, and an input/output (I/O) adapter <b>18</b>. The I/O adapter <b>18</b> can connect to peripheral devices, such as disk units <b>38</b> and program storage devices <b>40</b> that are readable by the system. The system can read the inventive instructions on the program storage devices <b>40</b> and follow these instructions to execute the methodology of the embodiments herein. The system further includes a user interface adapter <b>22</b> that connects a keyboard <b>28</b>, mouse <b>30</b>, speaker <b>32</b>, microphone <b>34</b>, and/or other user interface devices such as a touch screen device (not shown) to the bus <b>14</b> to gather user input. Additionally, a communication adapter <b>20</b> connects the bus <b>14</b> to a data processing network <b>42</b>, and a display adapter <b>24</b> connects the bus <b>14</b> to a display device <b>26</b>, which provides a graphical user interface (GUI) <b>36</b> of the output data in accordance with the embodiments herein, or which may be embodied as an output device such as a monitor, printer, or transmitter, for example. The system and/or method is used for identifying failures and defects in software applications. This helps in reducing huge maintenance costs of Information Technology (IT) organizations. The method provides an automated and real-time or near real-time solution for detecting anomalies and their root cause without manual intervention in programs, web applications, server-side applications, and back-end systems. This method is independent of any programming language.</p><p id="p-0089" num="0088">The foregoing description of the specific embodiments will so fully reveal the general nature of the embodiments herein that others can, by applying current knowledge, readily modify and/or adapt for various applications such specific embodiments without departing from the generic concept, and, therefore, such adaptations and modifications should and are intended to be comprehended within the meaning and range of equivalents of the disclosed embodiments. It is to be understood that the phraseology or terminology employed herein is for the purpose of description and not of limitation. Therefore, while the embodiments herein have been described in terms of preferred embodiments, those skilled in the art will recognize that the embodiments herein can be practiced with modification within the spirit and scope.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A processor-implemented method for identifying an anomaly and a root cause of the anomaly in an application using a plurality of shrunk dynamic call graphs, the method comprising:<claim-text>generating, using an instrumentation agent, a plurality of shrunk dynamic call graphs by providing a shrink factor to the instrumentation agent when the application receives a. plurality of input requests, wherein the plurality of input requests is received from a user device;</claim-text><claim-text>identifying, using a machine learning model, an anomalous group of the plurality of shrunk dynamic call graphs associated with the plurality of input requests that are failed, from one or more groups of the plurality of shrunk dynamic call graphs;</claim-text><claim-text>identifying a deviation in the plurality of shrunk dynamic call graphs of the plurality of input requests that are failed by comparing the plurality of shrunk dynamic call graphs associated with the plurality of input requests that are failed from the anomalous group with the plurality of shrunk dynamic call graphs associated with the plurality of input requests that are successful; and</claim-text><claim-text>identifying an anomaly based on the deviation in the plurality of shrunk dynamic call graphs associated with the plurality of input requests that are failed and an exception thrown around the deviation point as the root cause of the identified anomaly in the application.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The method as claimed in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein identifying the anomalous group of the plurality of shrunk dynamic call graphs comprises (i) obtaining a centroid of a dataset of each input request, (ii) obtaining a plurality of centroids of each of the one or more groups of the plurality of shrunk dynamic call graphs, (iii) obtaining a plurality of centroids based on the exception thrown in each input request, (iv) obtaining, using the plurality of centroids, a farthest centroid from the centroid of the dataset, (iv) identifying, using the farthest centroid, a first anomalous group of the plurality of shrunk dynamic call graphs associated with the plurality of input requests that are failed, (v) identifying, using the farthest centroid, a second anomalous group based on the exception associated with the plurality of input requests that are failed, and (vi) identifying the anomalous group if the first anomalous group of the plurality of shrunk dynamic call graphs and the second anomalous group based on the exception are same.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The method as claimed in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the method comprises creating, using the machine learning model, the one or more groups of the plurality of shrunk dynamic call graphs based on a similarity between the plurality of shrunk dynamic call graphs after removing repeating patterns in the plurality of shrunk dynamic call graphs.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The method as claimed in <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the one or more groups of the plurality of shrunk dynamic call graphs are created when (i) a distance between two points in each group is lower, and (ii) a minimum number of points are used to form a dense region in each group.</claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the plurality of shrunk dynamic call graphs comprises a crest point and a trough point with an absolute height.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The method as claimed in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein generating the plurality of shrunk dynamic call graphs comprises<claim-text>(i) identifying a subroutine in the application that receives and handles the plurality of input requests;</claim-text><claim-text>(ii) inserting probes at each subroutine entry and each subroutine exit in the application;</claim-text><claim-text>(iii) tracking a running height, a running crest, and a running trough of the subroutine being entered:</claim-text><claim-text>(iv) obtaining a crest point in the plurality of shrunk dynamic call graphs by comparing an absolute difference of the running crest, and the running trough to the shrink factor;</claim-text><claim-text>(v) repeating the step (ii) and tracking a running height, a running crest, and a running trough of the subroutine being exited; and</claim-text><claim-text>(vi) obtaining a trough point in the plurality of shrunk dynamic call graphs by comparing an absolute difference of the running crest, and the running trough to the shrink factor.</claim-text></claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the crest point or the trough point of plurality of shrunk dynamic call graphs is generated when a difference between two adjacent points is greater than the shrink factor.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the shrink factor is a constant that specifies an amount of detail captured from the application.</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. A system for identifying an anomaly and a root cause of the anomaly in an application using a plurality of shrunk dynamic call graphs, comprising:<claim-text>a processor; and<claim-text>a non-transitory computer-readable storage medium storing one or more sequences of instructions, which when executed by the processor, causes to:<claim-text>generate, using an instrumentation agent, a plurality of shrunk dynamic call graphs by providing a shrink factor to the instrumentation agent when the application receives a plurality of input requests, wherein the plurality of input requests is received from a user device;</claim-text><claim-text>identify, using a machine learning model, an anomalous group of the plurality of shrunk dynamic call graphs associated with the plurality of input requests that are failed, from one or more groups of the plurality of shrunk dynamic call graphs;</claim-text><claim-text>identify a deviation in the plurality of shrunk dynamic call graphs of the plurality of input requests that are failed by comparing the plurality of shrunk dynamic call graphs associated with the plurality of input requests that are failed from the anomalous group with the plurality of shrunk dynamic call graphs associated with the plurality of input requests that are successful; and</claim-text><claim-text>identify an anomaly based on the deviation in the plurality of shrunk dynamic call graphs associated with the plurality of input requests that are failed and an exception thrown around the deviation point as the root cause of identified anomaly in the application.</claim-text></claim-text></claim-text></claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The system as claimed in <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the processor identifies the anomalous group of the plurality of shrunk dynamic call graphs by (i) obtaining a centroid of a dataset of each input request, (ii) obtaining a plurality of centroids of each of the one or more groups of the plurality of shrunk dynamic call graphs, (iii) obtaining a plurality of centroids based on the exception thrown in each input request, (iv) obtaining, using the plurality of centroids, a farthest centroid from the centroid of the dataset, (iv) identifying, using the farthest centroid, a first anomalous group of the plurality of shrunk dynamic call graphs associated with the plurality of input requests that are failed, (v) identifying, using the farthest centroid, a second anomalous group based on the exception associated with the plurality of input requests that are failed, and (vi) identiling the anomalous group if the first anomalous group of the plurality of shrunk dynamic call graphs and the second anomalous group based on the exception are same.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The system as claimed in <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the processor creates, using the machine learning model, the one or more groups of the plurality of shrunk dynamic call graphs based on a similarity between the plurality of shrunk dynamic call graphs after removing repeating patterns in the plurality of shrunk dynamic call graphs.</claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The system as claimed in <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the processor creates the one or more groups of the plurality of shrunk dynamic call graphs when (i) a distance between two points in the group is lower, and (ii) a minimum number of points to form a dense region in the group are essential while creating the group of the plurality of shrunk dynamic call graphs of a similar plurality of input requests.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The system as claimed in <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the processor generates the plurality of shrunk dynamic call graphs by:<claim-text>(i) identifying a subroutine in the application that receives and handles the plurality of input requests;</claim-text><claim-text>(ii) inserting probes at each subroutine entry and each subroutine exit in the application;</claim-text><claim-text>(iii) tracking a running height, a running crest, and a running trough of the subroutine being entered:</claim-text><claim-text>(iv) obtaining a crest point in the plurality of shrunk dynamic call graphs by comparing an absolute difference of the running crest, and the running trough to the shrink factor;</claim-text><claim-text>(v) repeating the step (ii) and tracking a running height, a. running crest, and a running trough of the subroutine being exited; and</claim-text><claim-text>(vi) obtaining a trough point in the plurality of shrunk dynamic call graphs by comparing an absolute difference of the running crest, and the running trough to the shrink factor.</claim-text></claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. A non-transitory computer-readable storage medium storing the one or more sequence of instructions, which when executed by one or more processors, causes to perform a method for identifying an anomaly and a root cause of the anomaly in an application using a plurality of shrunk dynamic call graphs, by performing the steps of:<claim-text>generating, using an instrumentation agent, a plurality of shrunk dynamic call graphs by providing a shrink factor to the instrumentation agent when the application receives a plurality of input requests, wherein the plurality of input requests is received from a user device;</claim-text><claim-text>identifying, using a machine learning model, an anomalous group of the plurality of shrunk dynamic call graphs associated with the plurality of input requests that are failed from one or more groups of the plurality of shrunk dynamic call graphs;</claim-text><claim-text>identifying a deviation in the plurality of shrunk dynamic call graphs of the plurality of input requests that are failed by comparing the plurality of shrunk dynamic call graphs associated with the plurality of input requests that are failed from the anomalous group with the plurality of shrunk dynamic call graphs associated with of the plurality of input requests that are successful; and</claim-text><claim-text>identifying an anomaly based on the deviation in the plurality of shrunk dynamic call graphs associated with the plurality of input requests that are failed and an exception thrown around the deviation point as the root cause of identified anomaly in the application.</claim-text></claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The non-transitory computer-readable storage medium storing the one or more sequence of instructions as claimed in <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein identifying the anomalous group of the plurality of shrunk dynamic call graphs associated with comprises (i) obtaining a centroid of a dataset of each input request, (ii) obtaining a plurality of centroids of each of the one or more groups of the plurality of shrunk dynamic call graphs, (iii) obtaining a plurality of centroids based on the exception thrown in each input request, (iv) obtaining, using the plurality of centroids, a farthest centroid from the centroid of the dataset, (iv) identifying, using the farthest centroid, first anomalous group of the plurality of shrunk dynamic call graphs associated with the plurality of input requests that are failed, (v) identifying, using the farthest centroid, a second anomalous group based on the exception associated with the plurality of input requests that are failed, and (vi) identifying the anomalous group if the first anomalous group of the plurality of shrunk dynamic call graphs and the second anomalous group based on the exception are same.</claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The non-transitory computer-readable storage medium storing the one or more sequence of instructions as claimed in <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the method further includes creating, using the machine learning model, the one or more groups of the plurality of shrunk dynamic call graphs based on a similarity between the plurality of shrunk dynamic call graphs after removing repeating patterns in the plurality of shrunk dynamic call graphs.</claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The non-transitory computer-readable storage medium storing the one or more sequence of instructions as claimed in <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein generating the plurality of shrunk dynamic call graphs comprises,<claim-text>(i) identifying a subroutine in the application that receives and handles the plurality of input requests;</claim-text><claim-text>(ii) inserting probes at each subroutine entry and each subroutine exit in the application;</claim-text><claim-text>(iii) tracking a running height, a running crest, and a running trough of the subroutine being entered;</claim-text><claim-text>(iv) obtaining a crest point in the plurality of shrunk dynamic call graphs by comparing an absolute difference of the running crest, and the running trough to the shrink factor;</claim-text><claim-text>(v) repeating the step (ii) and tracking a running height, a running crest, and a running trough of the subroutine being exited; and</claim-text><claim-text>(vi) obtaining a trough point in the plurality of shrunk dynamic call graphs by comparing an absolute difference of the running crest, and the running trough to the shrink factor.</claim-text></claim-text></claim></claims></us-patent-application>