<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230005210A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230005210</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17930378</doc-number><date>20220907</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>T</subclass><main-group>15</main-group><subgroup>06</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>T</subclass><main-group>15</main-group><subgroup>04</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>T</subclass><main-group>15</main-group><subgroup>00</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>T</subclass><main-group>1</main-group><subgroup>20</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>T</subclass><main-group>3</main-group><subgroup>40</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>T</subclass><main-group>15</main-group><subgroup>10</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>T</subclass><main-group>15</main-group><subgroup>06</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>T</subclass><main-group>15</main-group><subgroup>04</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>T</subclass><main-group>15</main-group><subgroup>005</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>T</subclass><main-group>1</main-group><subgroup>20</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>T</subclass><main-group>3</main-group><subgroup>40</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>T</subclass><main-group>15</main-group><subgroup>10</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">TECHNIQUES FOR RAY CONE TRACING AND TEXTURE FILTERING</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>17039574</doc-number><date>20200930</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11443475</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17930378</doc-number></document-id></child-doc></relation></continuation><us-provisional-application><document-id><country>US</country><doc-number>63030162</doc-number><date>20200526</date></document-id></us-provisional-application><us-provisional-application><document-id><country>US</country><doc-number>63022033</doc-number><date>20200508</date></document-id></us-provisional-application></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>NVIDIA CORPORATION</orgname><address><city>Santa Clara</city><state>CA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>AKENINE-MOLLER</last-name><first-name>Tomas</first-name><address><city>Lund</city><country>SE</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>BOKSANSKY</last-name><first-name>Jakub</first-name><address><city>Munchen</city><country>DE</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>WRIGHT</last-name><first-name>Oli</first-name><address><city>Northwich</city><country>GB</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">One embodiment of a method for computing a texture color includes tracing a ray cone through a graphics scene, determining a curvature of a first surface within the graphics scene at a point where the ray cone hits the first surface based on differential barycentric coordinates associated with the point, determining, based on the curvature of the first surface, a width of the ray cone at a subsequent point where the ray cone hits a second surface within the graphics scene, and computing a texture color based on the width of the ray cone</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="206.76mm" wi="141.39mm" file="US20230005210A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="220.56mm" wi="143.43mm" file="US20230005210A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="226.91mm" wi="131.15mm" file="US20230005210A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="198.12mm" wi="146.13mm" file="US20230005210A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="121.67mm" wi="126.58mm" orientation="landscape" file="US20230005210A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="232.58mm" wi="83.31mm" orientation="landscape" file="US20230005210A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="131.74mm" wi="128.10mm" orientation="landscape" file="US20230005210A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="246.55mm" wi="152.82mm" file="US20230005210A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading><p id="p-0002" num="0001">This application is a continuation of the co-pending application titled, &#x201c;TECHNIQUES FOR RAY CONE TRACING AND TEXTURE FILTERING,&#x201d; filed on Sep. 30, 2020 and having Ser. No. 17/039,574, which claims the priority benefit of United States provisional patent application titled &#x201c;TEXTURE FILTERING TECHNIQUES FOR RAY TRACING,&#x201d; filed on May 26, 2020, and having Ser. No. 63/030,162, and also claims the priority benefit of United States provisional patent application titled, &#x201c;TEXTURE FILTERING TECHNIQUES FOR RAY TRACING,&#x201d; filed on May 8, 2020, and having Ser. No. 63/022,033. The subject matter of these related applications is hereby incorporated herein by reference.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">BACKGROUND</heading><heading id="h-0003" level="1">Technical Field</heading><p id="p-0003" num="0002">Embodiments of the present disclosure relate generally to computer science and computer graphics and, more specifically, to techniques for ray cone tracing and texture filtering.</p><heading id="h-0004" level="1">Description of the Related Art</heading><p id="p-0004" num="0003">In three-dimensional (3D) computer graphics, ray tracing is a popular technique for rendering images, such as the frames of a movie or video game. Ray tracing techniques trace the path of light rays and simulate the effects of the light rays interacting with virtual objects within a virtual scene. Ray cone tracing techniques are similar to ray tracing techniques, except ray cone tracing techniques trace cones through a scene. Ray cone tracing techniques can solve various sampling and aliasing problems that affect ray tracing techniques.</p><p id="p-0005" num="0004">One approach for implementing ray cone tracing uses an initial G-buffer rasterizing pass to determine and store surface spread angles, which represent curvatures on the surfaces of objects within a scene and are used to determine how ray cones grow and shrink while being traced through the scene. However, G-buffer rasterizing passes are quite expensive in terms of both the computational and storage resources required to determine and store the surface spread angles.</p><p id="p-0006" num="0005">In addition, conventional ray cone tracing techniques compute mipmap sampling levels separately for multiple textures with different sizes. Mipmaps are pre-calculated images at different &#x201c;levels,&#x201d; which are progressively lower resolution representations of the same image. As a general matter, separately computing mipmap sampling levels, according to conventional ray cone tracing techniques, is computationally expensive.</p><p id="p-0007" num="0006">As the foregoing illustrates, what is needed in the art are more effective techniques for rendering graphics scenes using ray cone tracing.</p><heading id="h-0005" level="1">SUMMARY</heading><p id="p-0008" num="0007">One embodiment of the present disclosure sets forth a computer-implemented method for computing a texture color. The method includes tracing a ray cone through a graphics scene. The method also includes determining a curvature of a first surface within the graphics scene at a point where the ray cone hits the first surface based on differential barycentric coordinates associated with the point. The method further includes determining, based on the curvature of the first surface, a width of the ray cone at a subsequent point where the ray cone hits a second surface within the graphics scene. In addition, the method includes computing a texture color based on the width of the ray cone.</p><p id="p-0009" num="0008">Another embodiment of the present disclosure sets forth a computer-implemented method for computing a texture color. The method includes determining a set of differential barycentric coordinates associated with a hit point at which a ray cone intersects a first surface within a graphics scene. The method also includes determining a first surface spread angle associated with the hit point based on the set of differential barycentric coordinates, and determining, based on the first surface spread angle, a width of the ray cone at a subsequent hit point where the ray cone intersects a second surface within the graphics scene. The method further includes determining a first level-of-detail parameter value based on the width of the ray cone, and performing one or more texture filtering operations based on the first level-of-detail parameter value. In addition, the method includes computing a texture color based on results of the one or more texture filtering operations.</p><p id="p-0010" num="0009">Other embodiments of the present disclosure include, without limitation, one or more computer-readable media including instructions for performing one or more aspects of the disclosed techniques as well as one or more computing systems for performing one or more aspects of the disclosed techniques.</p><p id="p-0011" num="0010">At least one technological advantage of the disclosed techniques relative to the prior art is that differential normals used to determine a mipmap sampling level are determined without requiring a separate G-buffer rasterizing pass. As a result, the disclosed techniques are faster and require less storage space than conventional ray cone tracing techniques. Further, techniques are disclosed for determining surface spread angles that produce more correctly rendered images than surface spread angles determined using conventional techniques. In addition, the disclosed techniques permit mipmap sampling levels for multiple textures with different resolutions to be determined more efficiently than conventional ray cone tracing techniques. These technological advantages represent one or more technological advancements relative to prior art approaches.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0006" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0012" num="0011">So that the manner in which the above recited features of the various embodiments can be understood in detail, a more particular description of the inventive concepts, briefly summarized above, may be had by reference to various embodiments, some of which are illustrated in the appended drawings. It is to be noted, however, that the appended drawings illustrate only typical embodiments of the inventive concepts and are therefore not to be considered limiting of scope in any way, and that there are other equally effective embodiments.</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram illustrating a computer system configured to implement one or more aspects of the present embodiments.</p><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a block diagram of a parallel processing unit included in the parallel processing subsystem of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, according to various embodiments.</p><p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a block diagram of a general processing cluster included in the parallel processing unit of <figref idref="DRAWINGS">FIG. <b>2</b></figref>, according to various embodiments.</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. <b>4</b></figref> illustrates an exemplary ray cone being traced through a virtual three-dimensional scene, according to various embodiments.</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>5</b></figref> illustrates exemplary reflection interactions at different types of surface geometry, according to various embodiments.</p><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>6</b></figref> illustrates an approach for determining differential barycentric coordinates, according to various embodiments.</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a flow diagram of method steps for computing the color of a pixel via a ray cone tracing technique, according to various embodiments.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0007" level="1">DETAILED DESCRIPTION</heading><p id="p-0020" num="0019">In the following description, numerous specific details are set forth to provide a more thorough understanding of the various embodiments. However, it will be apparent to one skilled in the art that the inventive concepts may be practiced without one or more of these specific details.</p><heading id="h-0008" level="1">General Overview</heading><p id="p-0021" num="0020">Embodiments of the present disclosure provide improved ray cone tracing techniques for texture filtering. The improved ray cone tracing techniques have many real-world applications, including video games, film production rendering, architectural and design applications, and any other applications in which images can be rendered using ray cone tracing. In the improved ray cone tracing techniques, when a ray cone being traced through a virtual three-dimensional (3D) scene hits a surface within the scene, a curvature of the surface is determined based on differential barycentric coordinates. The curvature of the surface is then used to determine a width of the ray cone when the ray cone hits another surface within the scene. In turn, the width of the ray cone is used to determine a texture color that can be applied to the pixel of an image being rendered.</p><p id="p-0022" num="0021">Various techniques are disclosed for determining the curvature of the surface at the point where the ray cone hits the surface. In general, the curvature of the surface is determined based on differential normals associated with the surface at the point, which are themselves determined based on differential barycentric coordinates.</p><p id="p-0023" num="0022">Further, the curvature of the surface can be determined as the larger of the absolute value of two curvatures along different dimensions, among other things. In addition, if the surface is associated with multiple textures with different resolutions, then a parameter value that is independent of resolution, as well as a parameter value that is dependent on resolution, can be determined.</p><p id="p-0024" num="0023">The ray cone tracing techniques of the present disclosure have many real-world applications. For example, the ray cone tracing techniques can be used to efficiently render images and/or frames within a video game. In particular, the disclosed ray cone tracing techniques require less storage space and produce more correctly-rendered images than conventional ray cone tracing techniques. The rendered images and/or frames may also appear more lifelike than images and/or frames rendered using some other rendering techniques, such as rasterization.</p><p id="p-0025" num="0024">As another example, the ray cone tracing techniques can be used in the production-quality rendering of films. The production of animated films as well computer-generated imagery (CGI) and special effects within live action films, often requires high-quality rendering of frames of those films. The disclosed ray cone tracing techniques can be used to render the frames of a film more efficiently and correctly than some other techniques, such as conventional ray cone tracing techniques.</p><p id="p-0026" num="0025">As yet another example, the disclosed ray cone tracing techniques can be used to render the designs of architectural structures and other objects. Architectural and design applications oftentimes provide renderings to show how particular designs would look in real life. The disclosed ray cone tracing techniques can be used to more efficiently and correctly render images of designs than some other techniques, such as conventional ray cone tracing techniques.</p><p id="p-0027" num="0026">The above examples are not in any way intended to be limiting. As persons skilled in the art will appreciate, as a general matter, the ray cone tracing techniques described herein can be implemented in any application where convention ray tracing and/or ray cone tracing techniques are currently employed.</p><heading id="h-0009" level="1">System Overview</heading><p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram illustrating a computer system <b>100</b> configured to implement one or more aspects of the present embodiments. As persons skilled in the art will appreciate, computer system <b>100</b> can be any type of technically feasible computer system, including, without limitation, a server machine, a server platform, a desktop machine, laptop machine, or a hand-held/mobile device. In some embodiments, computer system <b>100</b> is a server machine operating in a data center or a cloud computing environment that provides scalable computing resources as a service over a network.</p><p id="p-0029" num="0028">In various embodiments, computer system <b>100</b> includes, without limitation, a central processing unit (CPU) <b>102</b> and a system memory <b>104</b> coupled to a parallel processing subsystem <b>112</b> via a memory bridge <b>105</b> and a communication path <b>113</b>. Memory bridge <b>105</b> is further coupled to an I/O (input/output) bridge <b>107</b> via a communication path <b>106</b>, and <b>1</b>/O bridge <b>107</b> is, in turn, coupled to a switch <b>116</b>.</p><p id="p-0030" num="0029">In one embodiment, I/O bridge <b>107</b> is configured to receive user input information from optional input devices <b>108</b>, such as a keyboard or a mouse, and forward the input information to CPU <b>102</b> for processing via communication path <b>106</b> and memory bridge <b>105</b>. In some embodiments, computer system <b>100</b> may be a server machine in a cloud computing environment. In such embodiments, computer system <b>100</b> may not have input devices <b>108</b>. Instead, computer system <b>100</b> may receive equivalent input information by receiving commands in the form of messages transmitted over a network and received via the network adapter <b>118</b>. In one embodiment, switch <b>116</b> is configured to provide connections between I/O bridge <b>107</b> and other components of the computer system <b>100</b>, such as a network adapter <b>118</b> and various add-in cards <b>120</b> and <b>121</b>.</p><p id="p-0031" num="0030">In one embodiment, I/O bridge <b>107</b> is coupled to a system disk <b>114</b> that may be configured to store content and applications and data for use by CPU <b>102</b> and parallel processing subsystem <b>112</b>. In one embodiment, system disk <b>114</b> provides non-volatile storage for applications and data and may include fixed or removable hard disk drives, flash memory devices, and CD-ROM (compact disc read-only-memory), DVD-ROM (digital versatile disc-ROM), Blu-ray, HD-DVD (high definition DVD), or other magnetic, optical, or solid state storage devices. In various embodiments, other components, such as universal serial bus or other port connections, compact disc drives, digital versatile disc drives, film recording devices, and the like, may be connected to <b>1</b>/O bridge <b>107</b> as well.</p><p id="p-0032" num="0031">In various embodiments, memory bridge <b>105</b> may be a Northbridge chip, and <b>1</b>/O bridge <b>107</b> may be a Southbridge chip. In addition, communication paths <b>106</b> and <b>113</b>, as well as other communication paths within computer system <b>100</b>, may be implemented using any technically suitable protocols, including, without limitation, AGP (Accelerated Graphics Port), HyperTransport, or any other bus or point-to-point communication protocol known in the art.</p><p id="p-0033" num="0032">In some embodiments, parallel processing subsystem <b>112</b> comprises a graphics subsystem that delivers pixels to an optional display device <b>110</b> that may be any conventional cathode ray tube, liquid crystal display, light-emitting diode display, or the like. In such embodiments, the parallel processing subsystem <b>112</b> incorporates circuitry optimized for graphics and video processing, including, for example, video output circuitry. As described in greater detail below in conjunction with <figref idref="DRAWINGS">FIGS. <b>2</b></figref>, such circuitry may be incorporated across one or more parallel processing units (PPUs), also referred to herein as parallel processors, included within parallel processing subsystem <b>112</b>. In other embodiments, the parallel processing subsystem <b>112</b> incorporates circuitry optimized for general purpose and/or compute processing. Again, such circuitry may be incorporated across one or more PPUs included within parallel processing subsystem <b>112</b> that are configured to perform such general purpose and/or compute operations. In yet other embodiments, the one or more PPUs included within parallel processing subsystem <b>112</b> may be configured to perform graphics processing, general purpose processing, and compute processing operations. System memory <b>104</b> includes at least one device driver configured to manage the processing operations of the one or more PPUs within parallel processing subsystem <b>112</b>. In addition, the system memory <b>104</b> includes a rendering application <b>130</b>. The rendering application <b>130</b> can be any technically-feasible application that renders virtual 3D scenes using ray cone tracing techniques disclosed herein. For example, the rendering application <b>130</b> could be a gaming application or a rendering application that is used in film production. Although described herein primarily with respect to the rendering application <b>130</b>, techniques disclosed herein can also be implemented, either entirely or in part, in other software and/or hardware, such as in the parallel processing subsystem <b>112</b>.</p><p id="p-0034" num="0033">In various embodiments, parallel processing subsystem <b>112</b> may be integrated with one or more of the other elements of <figref idref="DRAWINGS">FIG. <b>1</b></figref> to form a single system.</p><p id="p-0035" num="0034">For example, parallel processing subsystem <b>112</b> may be integrated with CPU <b>102</b> and other connection circuitry on a single chip to form a system on chip (SoC).</p><p id="p-0036" num="0035">In one embodiment, CPU <b>102</b> is the master processor of computer system <b>100</b>, controlling and coordinating operations of other system components. In one embodiment, CPU <b>102</b> issues commands that control the operation of PPUs. In some embodiments, communication path <b>113</b> is a PCI Express link, in which dedicated lanes are allocated to each PPU, as is known in the art. Other communication paths may also be used. PPU advantageously implements a highly parallel processing architecture. A PPU may be provided with any amount of local parallel processing memory (PP memory).</p><p id="p-0037" num="0036">It will be appreciated that the system shown herein is illustrative and that variations and modifications are possible. The connection topology, including the number and arrangement of bridges, the number of CPUs <b>102</b>, and the number of parallel processing subsystems <b>112</b>, may be modified as desired. For example, in some embodiments, system memory <b>104</b> could be connected to CPU <b>102</b> directly rather than through memory bridge <b>105</b>, and other devices would communicate with system memory <b>104</b> via memory bridge <b>105</b> and CPU <b>102</b>. In other embodiments, parallel processing subsystem <b>112</b> may be connected to I/O bridge <b>107</b> or directly to CPU <b>102</b>, rather than to memory bridge <b>105</b>. In still other embodiments, I/O bridge <b>107</b> and memory bridge <b>105</b> may be integrated into a single chip instead of existing as one or more discrete devices. Lastly, in certain embodiments, one or more components shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref> may not be present. For example, switch <b>116</b> could be eliminated, and network adapter <b>118</b> and add-in cards <b>120</b>, <b>121</b> would connect directly to <b>1</b>/O bridge <b>107</b>.</p><p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a block diagram of a parallel processing unit (PPU) <b>202</b> included in the parallel processing subsystem <b>112</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, according to various embodiments. Although <figref idref="DRAWINGS">FIG. <b>2</b></figref> depicts one PPU <b>202</b>, as indicated above, parallel processing subsystem <b>112</b> may include any number of PPUs <b>202</b>. As shown, PPU <b>202</b> is coupled to a local parallel processing (PP) memory <b>204</b>. PPU <b>202</b> and PP memory <b>204</b> may be implemented using one or more integrated circuit devices, such as programmable processors, application specific integrated circuits (ASICs), or memory devices, or in any other technically feasible fashion.</p><p id="p-0039" num="0038">In some embodiments, PPU <b>202</b> comprises a graphics processing unit (GPU) that may be configured to implement a graphics rendering pipeline to perform various operations related to generating pixel data based on graphics data supplied by CPU <b>102</b> and/or system memory <b>104</b>. When processing graphics data, PP memory <b>204</b> can be used as graphics memory that stores one or more conventional frame buffers and, if needed, one or more other render targets as well. Among other things, PP memory <b>204</b> may be used to store and update pixel data and deliver final pixel data or display frames to an optional display device <b>110</b> for display. In some embodiments, PPU <b>202</b> also may be configured for general-purpose processing and compute operations. In some embodiments, computer system <b>100</b> may be a server machine in a cloud computing environment. In such embodiments, computer system <b>100</b> may not have a display device <b>110</b>. Instead, computer system <b>100</b> may generate equivalent output information by transmitting commands in the form of messages over a network via the network adapter <b>118</b>.</p><p id="p-0040" num="0039">In some embodiments, CPU <b>102</b> is the master processor of computer system <b>100</b>, controlling and coordinating operations of other system components. In one embodiment, CPU <b>102</b> issues commands that control the operation of PPU <b>202</b>. In some embodiments, CPU <b>102</b> writes a stream of commands for PPU <b>202</b> to a data structure (not explicitly shown in either <figref idref="DRAWINGS">FIG. <b>1</b></figref> or <figref idref="DRAWINGS">FIG. <b>2</b></figref>) that may be located in system memory <b>104</b>, PP memory <b>204</b>, or another storage location accessible to both CPU <b>102</b> and PPU <b>202</b>. A pointer to the data structure is written to a command queue, also referred to herein as a pushbuffer, to initiate processing of the stream of commands in the data structure. In one embodiment, the PPU <b>202</b> reads command streams from the command queue and then executes commands asynchronously relative to the operation of CPU <b>102</b>. In embodiments where multiple pushbuffers are generated, execution priorities may be specified for each pushbuffer by an application program via device driver to control scheduling of the different pushbuffers.</p><p id="p-0041" num="0040">In one embodiment, PPU <b>202</b> includes an I/O (input/output) unit <b>205</b> that communicates with the rest of computer system <b>100</b> via the communication path <b>113</b> and memory bridge <b>105</b>. In one embodiment, I/O unit <b>205</b> generates packets (or other signals) for transmission on communication path <b>113</b> and also receives all incoming packets (or other signals) from communication path <b>113</b>, directing the incoming packets to appropriate components of PPU <b>202</b>. For example, commands related to processing tasks may be directed to a host interface <b>206</b>, while commands related to memory operations (e.g., reading from or writing to PP memory <b>204</b>) may be directed to a crossbar unit <b>210</b>. In one embodiment, host interface <b>206</b> reads each command queue and transmits the command stream stored in the command queue to a front end <b>212</b>.</p><p id="p-0042" num="0041">As mentioned above in conjunction with <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the connection of PPU <b>202</b> to the rest of computer system <b>100</b> may be varied. In some embodiments, parallel processing subsystem <b>112</b>, which includes at least one PPU <b>202</b>, is implemented as an add-in card that can be inserted into an expansion slot of computer system <b>100</b>. In other embodiments, PPU <b>202</b> can be integrated on a single chip with a bus bridge, such as memory bridge <b>105</b> or <b>1</b>/O bridge <b>107</b>. Again, in still other embodiments, some or all of the elements of PPU <b>202</b> may be included along with CPU <b>102</b> in a single integrated circuit or system of chip (SoC).</p><p id="p-0043" num="0042">In one embodiment, front end <b>212</b> transmits processing tasks received from host interface <b>206</b> to a work distribution unit (not shown) within task/work unit <b>207</b>. In one embodiment, the work distribution unit receives pointers to processing tasks that are encoded as task metadata (TMD) and stored in memory. The pointers to TMDs are included in a command stream that is stored as a command queue and received by the front end unit <b>212</b> from the host interface <b>206</b>. Processing tasks that may be encoded as TMDs include indices associated with the data to be processed as well as state parameters and commands that define how the data is to be processed. For example, the state parameters and commands could define the program to be executed on the data. Also for example, the TMD could specify the number and configuration of the set of CTAs. Generally, each TMD corresponds to one task. The task/work unit <b>207</b> receives tasks from the front end <b>212</b> and ensures that GPCs <b>208</b> are configured to a valid state before the processing task specified by each one of the TMDs is initiated. A priority may be specified for each TMD that is used to schedule the execution of the processing task. Processing tasks also may be received from the processing cluster array <b>230</b>. Optionally, the TMD may include a parameter that controls whether the TMD is added to the head or the tail of a list of processing tasks (or to a list of pointers to the processing tasks), thereby providing another level of control over execution priority.</p><p id="p-0044" num="0043">In one embodiment, PPU <b>202</b> implements a highly parallel processing architecture based on a processing cluster array <b>230</b> that includes a set of C general processing clusters (GPCs) <b>208</b>, where C&#x3e;1. Each GPC <b>208</b> is capable of executing a large number (e.g., hundreds or thousands) of threads concurrently, where each thread is an instance of a program. In various applications, different GPCs <b>208</b> may be allocated for processing different types of programs or for performing different types of computations. The allocation of GPCs <b>208</b> may vary depending on the workload arising for each type of program or computation.</p><p id="p-0045" num="0044">In one embodiment, memory interface <b>214</b> includes a set of D of partition units <b>215</b>, where D&#x2265;1. Each partition unit <b>215</b> is coupled to one or more dynamic random access memories (DRAMs) <b>220</b> residing within PPM memory <b>204</b>. In some embodiments, the number of partition units 215 equals the number of DRAMs <b>220</b>, and each partition unit <b>215</b> is coupled to a different DRAM <b>220</b>. In other embodiments, the number of partition units <b>215</b> may be different than the number of DRAMs <b>220</b>. Persons of ordinary skill in the art will appreciate that a DRAM <b>220</b> may be replaced with any other technically suitable storage device. In operation, various render targets, such as texture maps and frame buffers, may be stored across DRAMs <b>220</b>, allowing partition units <b>215</b> to write portions of each render target in parallel to efficiently use the available bandwidth of PP memory <b>204</b>.</p><p id="p-0046" num="0045">In one embodiment, a given GPC <b>208</b> may process data to be written to any of the DRAMs <b>220</b> within PP memory <b>204</b>. In one embodiment, crossbar unit <b>210</b> is configured to route the output of each GPC <b>208</b> to the input of any partition unit <b>215</b> or to any other GPC <b>208</b> for further processing. GPCs <b>208</b> communicate with memory interface <b>214</b> via crossbar unit <b>210</b> to read from or write to various DRAMs <b>220</b>. In some embodiments, crossbar unit <b>210</b> has a connection to I/O unit <b>205</b>, in addition to a connection to PP memory <b>204</b> via memory interface <b>214</b>, thereby enabling the processing cores within the different GPCs <b>208</b> to communicate with system memory <b>104</b> or other memory not local to PPU <b>202</b>. In the embodiment of <figref idref="DRAWINGS">FIG. <b>2</b></figref>, crossbar unit <b>210</b> is directly connected with I/O unit <b>205</b>. In various embodiments, crossbar unit <b>210</b> may use virtual channels to separate traffic streams between the GPCs <b>208</b> and partition units <b>215</b>.</p><p id="p-0047" num="0046">In one embodiment, GPCs <b>208</b> can be programmed to execute processing tasks relating to a wide variety of applications, including, without limitation, linear and nonlinear data transforms, filtering of video and/or audio data, modeling operations (e.g., applying laws of physics to determine position, velocity and other attributes of objects), image rendering operations (e.g., tessellation shader, vertex shader, geometry shader, and/or pixel/fragment shader programs), general compute operations, etc. In operation, PPU <b>202</b> is configured to transfer data from system memory <b>104</b> and/or PP memory <b>204</b> to one or more on-chip memory units, process the data, and write result data back to system memory <b>104</b> and/or PP memory <b>204</b>. The result data may then be accessed by other system components, including CPU <b>102</b>, another PPU <b>202</b> within parallel processing subsystem <b>112</b>, or another parallel processing subsystem <b>112</b> within computer system <b>100</b>.</p><p id="p-0048" num="0047">In one embodiment, any number of PPUs <b>202</b> may be included in a parallel processing subsystem <b>112</b>. For example, multiple PPUs <b>202</b> may be provided on a single add-in card, or multiple add-in cards may be connected to communication path <b>113</b>, or one or more of PPUs <b>202</b> may be integrated into a bridge chip. PPUs <b>202</b> in a multi-PPU system may be identical to or different from one another. For example, different PPUs <b>202</b> might have different numbers of processing cores and/or different amounts of PP memory <b>204</b>. In implementations where multiple PPUs <b>202</b> are present, those PPUs may be operated in parallel to process data at a higher throughput than is possible with a single PPU <b>202</b>. Systems incorporating one or more PPUs <b>202</b> may be implemented in a variety of configurations and form factors, including, without limitation, desktops, laptops, handheld personal computers or other handheld devices, servers, workstations, game consoles, embedded systems, and the like.</p><p id="p-0049" num="0048"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a block diagram of a general processing cluster (GPC) <b>208</b> included in the parallel processing unit (PPU) <b>202</b> of <figref idref="DRAWINGS">FIG. <b>2</b></figref>, according to various embodiments. As shown, the GPC <b>208</b> includes, without limitation, a pipeline manager <b>305</b>, one or more texture units <b>315</b>, a preROP unit <b>325</b>, a work distribution crossbar <b>330</b>, and an L1.5 cache <b>335</b>.</p><p id="p-0050" num="0049">In one embodiment, GPC <b>208</b> may be configured to execute a large number of threads in parallel to perform graphics, general processing and/or compute operations. As used herein, a &#x201c;thread&#x201d; refers to an instance of a particular program executing on a particular set of input data. In some embodiments, single-instruction, multiple-data (SIMD) instruction issue techniques are used to support parallel execution of a large number of threads without providing multiple independent instruction units. In other embodiments, single-instruction, multiple-thread (SIMT) techniques are used to support parallel execution of a large number of generally synchronized threads, using a common instruction unit configured to issue instructions to a set of processing engines within GPC <b>208</b>. Unlike a SIMD execution regime, where all processing engines typically execute identical instructions, SIMT execution allows different threads to more readily follow divergent execution paths through a given program. Persons of ordinary skill in the art will understand that a SIMD processing regime represents a functional subset of a SIMT processing regime.</p><p id="p-0051" num="0050">In one embodiment, operation of GPC <b>208</b> is controlled via a pipeline manager <b>305</b> that distributes processing tasks received from a work distribution unit (not shown) within task/work unit <b>207</b> to one or more streaming multiprocessors (SMs) <b>310</b>. Pipeline manager <b>305</b> may also be configured to control a work distribution crossbar <b>330</b> by specifying destinations for processed data output by SMs <b>310</b>.</p><p id="p-0052" num="0051">In various embodiments, GPC <b>208</b> includes a set of M of SMs <b>310</b>, where M&#x2265;1. Also, each SM <b>310</b> includes a set of functional execution units (not shown), such as execution units and load-store units. Processing operations specific to any of the functional execution units may be pipelined, which enables a new instruction to be issued for execution before a previous instruction has completed execution. Any combination of functional execution units within a given SM <b>310</b> may be provided. In various embodiments, the functional execution units may be configured to support a variety of different operations including integer and floating point arithmetic (e.g., addition and multiplication), comparison operations, Boolean operations (AND, OR, <b>50</b>R), bit-shifting, and computation of various algebraic functions (e.g., planar interpolation and trigonometric, exponential, and logarithmic functions, etc.). Advantageously, the same functional execution unit can be configured to perform different operations.</p><p id="p-0053" num="0052">In one embodiment, each SM <b>310</b> is configured to process one or more thread groups. As used herein, a &#x201c;thread group&#x201d; or &#x201c;warp&#x201d; refers to a group of threads concurrently executing the same program on different input data, with one thread of the group being assigned to a different execution unit within an SM <b>310</b>. A thread group may include fewer threads than the number of execution units within the SM <b>310</b>, in which case some of the execution may be idle during cycles when that thread group is being processed. A thread group may also include more threads than the number of execution units within the SM <b>310</b>, in which case processing may occur over consecutive clock cycles. Since each SM <b>310</b> can support up to G thread groups concurrently, it follows that up to G*M thread groups can be executing in GPC <b>208</b> at any given time.</p><p id="p-0054" num="0053">Additionally, in one embodiment, a plurality of related thread groups may be active (in different phases of execution) at the same time within an SM <b>310</b>. This collection of thread groups is referred to herein as a &#x201c;cooperative thread array&#x201d; (&#x201c;CTA&#x201d;) or &#x201c;thread array.&#x201d; The size of a particular CTA is equal to m*k, where k is the number of concurrently executing threads in a thread group, which is typically an integer multiple of the number of execution units within the SM <b>310</b>, and m is the number of thread groups simultaneously active within the SM <b>310</b>. In some embodiments, a single SM <b>310</b> may simultaneously support multiple CTAs, where such CTAs are at the granularity at which work is distributed to the SMs <b>310</b>.</p><p id="p-0055" num="0054">In one embodiment, each SM <b>310</b> contains a level one (L1) cache or uses space in a corresponding L1 cache outside of the SM <b>310</b> to support, among other things, load and store operations performed by the execution units. Each SM <b>310</b> also has access to level two (L2) caches (not shown) that are shared among all GPCs <b>208</b> in PPU <b>202</b>. The L2 caches may be used to transfer data between threads. Finally, SMs <b>310</b> also have access to off-chip &#x201c;global&#x201d; memory, which may include PP memory <b>204</b> and/or system memory <b>104</b>. It is to be understood that any memory external to PPU <b>202</b> may be used as global memory. Additionally, as shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, a level one-point-five (L1.5) cache <b>335</b> may be included within GPC <b>208</b> and configured to receive and hold data requested from memory via memory interface <b>214</b> by SM <b>310</b>. Such data may include, without limitation, instructions, uniform data, and constant data. In embodiments having multiple SMs <b>310</b> within GPC <b>208</b>, the SMs <b>310</b> may beneficially share common instructions and data cached in L1.5 cache <b>335</b>.</p><p id="p-0056" num="0055">In one embodiment, each GPC <b>208</b> may have an associated memory management unit (MMU) <b>320</b> that is configured to map virtual addresses into physical addresses. In various embodiments, MMU <b>320</b> may reside either within GPC <b>208</b> or within the memory interface <b>214</b>. The MMU <b>320</b> includes a set of page table entries (PTEs) used to map a virtual address to a physical address of a tile or memory page and optionally a cache line index. The MMU <b>320</b> may include address translation lookaside buffers (TLB) or caches that may reside within SMs <b>310</b>, within one or more L1 caches, or within GPC <b>208</b>.</p><p id="p-0057" num="0056">In one embodiment, in graphics and compute applications, GPC <b>208</b> may be configured such that each SM <b>310</b> is coupled to a texture unit <b>315</b> for performing texture mapping operations, such as determining texture sample positions, reading texture data, and filtering texture data.</p><p id="p-0058" num="0057">In one embodiment, each SM <b>310</b> transmits a processed task to work distribution crossbar <b>330</b> in order to provide the processed task to another GPC <b>208</b> for further processing or to store the processed task in an L2 cache (not shown), parallel processing memory <b>204</b>, or system memory <b>104</b> via crossbar unit <b>210</b>. In addition, a pre-raster operations (preROP) unit <b>325</b> is configured to receive data from SM <b>310</b>, direct data to one or more raster operations (ROP) units within partition units <b>215</b>, perform optimizations for color blending, organize pixel color data, and perform address translations.</p><p id="p-0059" num="0058">It will be appreciated that the architecture described herein is illustrative and that variations and modifications are possible. Among other things, any number of processing units, such as SMs <b>310</b>, texture units <b>315</b>, or preROP units <b>325</b>, may be included within GPC <b>208</b>. Further, as described above in conjunction with <figref idref="DRAWINGS">FIG. <b>2</b></figref>, PPU <b>202</b> may include any number of GPCs <b>208</b> that are configured to be functionally similar to one another so that execution behavior does not depend on which GPC <b>208</b> receives a particular processing task. Further, each GPC <b>208</b> operates independently of the other GPCs <b>208</b> in PPU <b>202</b> to execute tasks for one or more application programs.</p><heading id="h-0010" level="1">Ray Cone Tracing and Texture Filtering Techniques</heading><p id="p-0060" num="0059"><figref idref="DRAWINGS">FIG. <b>4</b></figref> illustrates an exemplary ray cone being traced through a virtual three-dimensional scene, according to various embodiments. As shown, a ray cone <b>400</b>, which is an augmentation to a ray <b>402</b>, is traced through a pixel <b>401</b> in a screen space into a scene that includes three objects <b>410</b>, <b>412</b>, and <b>414</b>. When the ray cone <b>400</b> hits one of the objects <b>410</b>, <b>412</b>, <b>414</b>, the ray cone <b>400</b> reflects off in a direction, depending on material properties of the object. In addition, an angle of the ray cone <b>402</b> grows or shrinks (or stays the same) based on the surface curvature of the object. In general, the angle of the ray cone <b>400</b> grows if the surface curvature at a hit point where the ray <b>402</b> intersects geometry of the object is convex, and vice versa.</p><p id="p-0061" num="0060"><figref idref="DRAWINGS">FIG. <b>5</b></figref> illustrates exemplary reflection interactions at different types of surface geometry, according to various embodiments. In embodiments, a surface spread angle &#x3b2; is used to model how a ray cone footprint grows/shrinks due to the curvature of a surface at a hit point. Intuitively, the surface spread angle &#x3b2; models the extra spread induced by the curvature at a hit point. As described in greater detail below, the surface spread angle can be used to estimate the width of a ray cone at a later hit point, which can correspond to the size of a filter used during texture filtering. Texture filtering techniques determine the texture color of a texture mapped pixel by averaging nearby pixels in a texture. The texture color can then be used to determine a pixel color in a rendered image. When a ray cone hits a textured surface (as opposed to a metallic surface with no texture) in a scene, texture filtering can be performed by averaging nearby pixels within a width of the ray cone at the hit point. The averaging can be performed using, e.g., mipmapping.</p><p id="p-0062" num="0061">As shown in panel A, at a planar surface <b>502</b> with no curvature, an angle of a ray cone <b>500</b> neither grows nor shrinks in size when the ray cone <b>500</b> reflects at a hit point on the planar surface <b>502</b>. In such a case, the surface spread angle &#x3b2; is zero.</p><p id="p-0063" num="0062">As shown in panel B, at a convex surface <b>512</b> with positive curvature, an angle of a ray cone <b>510</b> increases in size when the ray cone <b>510</b> reflects at a hit point on the convex surface <b>512</b>. In such a case, the surface spread angle &#x3b2; is &#x3e;0.</p><p id="p-0064" num="0063">As shown in panel C, at a concave surface <b>522</b> with negative curvature, an angle of a ray cone <b>520</b> decreases in size when the ray cone <b>520</b> reflects at a hit point on the concave surface. In such a case, the surface spread angle &#x3b2; is &#x3c;0.</p><p id="p-0065" num="0064">Returning to <figref idref="DRAWINGS">FIG. <b>4</b></figref>, an angle of the ray cone <b>400</b> shrinks after hitting the object <b>410</b>, because the surface curvature at the hit point <b>420</b> is negative. After shrinking to zero size, the ray cone <b>400</b> grows in size again. Then, the angle of ray cone <b>400</b> grows after the ray cone <b>400</b> hits the object <b>412</b>, because the surface curvature at the hit point <b>422</b> is convex.</p><p id="p-0066" num="0065">Assuming the rectangular object <b>414</b> is textured and the other objects <b>410</b> and <b>412</b> are perfectly reflective, a texture lookup can be performed at the hit point <b>424</b> on the object <b>414</b> based on the footprint of the cone <b>400</b> and the normal at the hit point <b>424</b>. Although described with respect to a texture lookup at the hit point <b>424</b> as an example, texture lookups can generally be performed at a second hit point (e.g., hit point <b>422</b>) and all hit points thereafter. In some embodiments, the rendering application <b>130</b> instructs a texture unit in a GPU (q, the texture unit <b>315</b> described above in conjunction with <figref idref="DRAWINGS">FIG. <b>3</b></figref>) to perform texture filtering at a hit point (e.g., the hit point <b>424</b>) based on a mipmap level determined using the width of the ray cone at the hit point, and a result of the texture filtering is used to render a textured reflection on the leftmost object <b>410</b>, as described in greater detail below. Although described herein primarily with respect to a mipmap, the ray cone can be used with other texture filtering techniques, such as anisotropic filtering, in some embodiments. The surface spread angles at the hit points <b>420</b> and <b>422</b> at which the ray cone <b>400</b> reflects off of the objects <b>410</b> and <b>412</b>, respectively, can be used to compute how much the ray cone <b>400</b> grows or shrinks, and to determine the width of the ray cone at the hit point <b>424</b>, which is also referred to as the &#x201c;footprint&#x201d; of the ray cone and is used in texture filtering to determine a texture color. In some embodiments, the rendering application <b>130</b> determines the surface spread angle at a hit point by determining differential normals using differential barycentric coordinates at the hit point, and then determining the surface spread angle based on the differential normals, as described in greater detail below in conjunction with <figref idref="DRAWINGS">FIG. <b>6</b></figref>. By determining differential normals on the fly, the G-buffer rasterization pass used to compute and store surface spread angles in conventional ray cone tracing techniques can be avoided, thereby improving computational efficiency.</p><p id="p-0067" num="0066"><figref idref="DRAWINGS">FIG. <b>6</b></figref> illustrates an approach for determining differential barycentric coordinates, according to various embodiments. As shown, a triangle <b>600</b>, which is shown to be representative of the triangle at which a ray associated with a ray cone intersects geometry of an object at a hit point (not shown), includes three vertices <b>602</b>, <b>604</b>, and <b>606</b>. Barycentric coordinates (u,v) are also shown. As described, differential barycentric coordinates, which are the barycentric coordinates u and v differentiated with respect to x and y, are computed to determine differential normals, which can in turn be used to determine the surface spread angle at a hit point where a ray cone intersects scene geometry. Let the normal of the triangle <b>600</b> be denoted by f and the vertices <b>602</b>, <b>604</b>, and <b>606</b> be denoted by P<sub>0</sub>, P<sub>1</sub>, and P<sub>2</sub>, respectively. Differential barycentric coordinates can be computed using plane equations that go through edges of the triangle <b>600</b> and evaluate to (<b>1</b>) zero for points on an edge, and (2) one for a vertex that is not an edge vertex.</p><p id="p-0068" num="0067">Assume that a plane equation goes through P<sub>0 </sub>and P<sub>1</sub>, which as shown in connected to the barycentric coordinate u. Then, a normal <b>608</b>, denoted as m<sub>u</sub>, of the edge that is also perpendicular to the triangle normal f can be computed as:</p><p id="p-0069" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>m</i><sub>u</sub>=(<i>P</i><sub>2</sub><i>&#x2212;P</i><sub>0</sub>)&#xd7;<i>f=e</i><sub>2</sub><i>&#xd7;f.</i>&#x2003;&#x2003;(1)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0070" num="0000">Similarly for the other barycentric coordinate v, a normal m&#x2dc; can be computed as:</p><p id="p-0071" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>m</i><sub>v</sub>=(<i>P</i><sub>1</sub><i>&#x2212;P</i><sub>0</sub>)&#xd7;<i>f=e</i><sub>1</sub><i>&#xd7;f.</i>&#x2003;&#x2003;(2)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0072" num="0000">The plane equation is then m<sub>u</sub>&#xb7;(X&#x2212;P<sub>0</sub>)=0, where X is any point on the plane with normal m<sub>u</sub>. The edge equation can rewritten as e<sub>u</sub>(X)=m<sub>u</sub>&#xb7;(X&#x2212;P<sub>0</sub>), assuming the plane equation is normalized so that e<sub>u</sub>(P<sub>1</sub>)=1, which can be obtained as e&#x2032;<sub>u</sub>(X)=e<sub>u</sub>(X)/e<sub>u</sub>(P<sub>1</sub>). Only a normal vector of the plane equation is needed for the foregoing computations, and the normal vector, denoted herein as I<sub>u</sub>, is then:</p><p id="p-0073" num="0000"><maths id="MATH-US-00001" num="00001"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <msub>      <mi>I</mi>      <mi>u</mi>     </msub>     <mo>=</mo>     <mrow>      <mrow>       <mfrac>        <mn>1</mn>        <mrow>         <msub>          <mi>m</mi>          <mi>u</mi>         </msub>         <mo>&#xb7;</mo>         <mrow>          <mo>(</mo>          <mrow>           <msub>            <mi>P</mi>            <mn>1</mn>           </msub>           <mo>-</mo>           <msub>            <mi>P</mi>            <mn>0</mn>           </msub>          </mrow>          <mo>)</mo>         </mrow>        </mrow>       </mfrac>       <mo>&#x2062;</mo>       <msub>        <mi>m</mi>        <mi>u</mi>       </msub>      </mrow>      <mo>=</mo>      <mrow>       <mfrac>        <mn>1</mn>        <mrow>         <msub>          <mi>m</mi>          <mi>u</mi>         </msub>         <mo>&#xb7;</mo>         <msub>          <mi>e</mi>          <mn>1</mn>         </msub>        </mrow>       </mfrac>       <mo>&#x2062;</mo>       <mrow>        <msub>         <mi>m</mi>         <mi>u</mi>        </msub>        <mo>.</mo>       </mrow>      </mrow>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mn>3</mn>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0074" num="0068">Similarly for the other barycentric coordinate v, I<sub>v </sub>can be computed as:</p><p id="p-0075" num="0000"><maths id="MATH-US-00002" num="00002"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <msub>      <mi>I</mi>      <mi>v</mi>     </msub>     <mo>=</mo>     <mrow>      <mrow>       <mfrac>        <mn>1</mn>        <mrow>         <msub>          <mi>m</mi>          <mi>v</mi>         </msub>         <mo>&#xb7;</mo>         <mrow>          <mo>(</mo>          <mrow>           <msub>            <mi>P</mi>            <mn>2</mn>           </msub>           <mo>-</mo>           <msub>            <mi>P</mi>            <mn>0</mn>           </msub>          </mrow>          <mo>)</mo>         </mrow>        </mrow>       </mfrac>       <mo>&#x2062;</mo>       <msub>        <mi>m</mi>        <mi>v</mi>       </msub>      </mrow>      <mo>=</mo>      <mrow>       <mfrac>        <mn>1</mn>        <mrow>         <msub>          <mi>m</mi>          <mi>v</mi>         </msub>         <mo>&#xb7;</mo>         <msub>          <mi>e</mi>          <mn>2</mn>         </msub>        </mrow>       </mfrac>       <mo>&#x2062;</mo>       <mrow>        <msub>         <mi>m</mi>         <mi>v</mi>        </msub>        <mo>.</mo>       </mrow>      </mrow>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mn>4</mn>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0076" num="0069">In addition, the triangle plane normal f can be computed as f=e<sub>i</sub>&#xd7;e<sub>2</sub>, which does not need to be normalized, as the plane equations (3) and (4) are already normalized. A plane equation for the third barycentric coordinate w does not need to be computed. In particular, w=1&#x2212;u&#x2212;v, so the barycentric differential</p><p id="p-0077" num="0000"><maths id="MATH-US-00003" num="00003"><math overflow="scroll"> <mfrac>  <mrow>   <mo>&#x2202;</mo>   <mi>w</mi>  </mrow>  <mrow>   <mo>&#x2202;</mo>   <mi>x</mi>  </mrow> </mfrac></math></maths></p><p id="p-0078" num="0000">can be computed from barycentric differentials</p><p id="p-0079" num="0000"><maths id="MATH-US-00004" num="00004"><math overflow="scroll"> <mrow>  <mrow>   <mfrac>    <mrow>     <mo>&#x2202;</mo>     <mtext> </mtext>     <mi>u</mi>    </mrow>    <mrow>     <mo>&#x2202;</mo>     <mtext> </mtext>     <mi>x</mi>    </mrow>   </mfrac>   <mo>&#x2062;</mo>   <mtext>   </mtext>   <mi>and</mi>   <mo>&#x2062;</mo>   <mtext>   </mtext>   <mfrac>    <mrow>     <mo>&#x2202;</mo>     <mtext> </mtext>     <mi>v</mi>    </mrow>    <mrow>     <mo>&#x2202;</mo>     <mtext> </mtext>     <mi>x</mi>    </mrow>   </mfrac>   <mo>&#x2062;</mo>   <mtext>   </mtext>   <mi>as</mi>   <mo>&#x2062;</mo>   <mtext>   </mtext>   <mfrac>    <mrow>     <mo>&#x2202;</mo>     <mtext> </mtext>     <mi>w</mi>    </mrow>    <mrow>     <mo>&#x2202;</mo>     <mtext> </mtext>     <mi>x</mi>    </mrow>   </mfrac>  </mrow>  <mo>=</mo>  <mrow>   <mrow>    <mo>-</mo>    <mfrac>     <mrow>      <mo>&#x2202;</mo>      <mtext> </mtext>      <mi>u</mi>     </mrow>     <mrow>      <mo>&#x2202;</mo>      <mtext> </mtext>      <mi>x</mi>     </mrow>    </mfrac>   </mrow>   <mo>-</mo>   <mrow>    <mfrac>     <mrow>      <mo>&#x2202;</mo>      <mtext> </mtext>      <mi>v</mi>     </mrow>     <mrow>      <mo>&#x2202;</mo>      <mtext> </mtext>      <mi>x</mi>     </mrow>    </mfrac>    <mo>.</mo>   </mrow>  </mrow> </mrow></math></maths></p><p id="p-0080" num="0070">Using the plane equations I<sub>u </sub>and I<sub>v </sub>differential barycentric coordinates can be computed, from which differential normals can be computed, a surface spread angle can be computed using the differential normals, the width of the ray cone at a later hit point can be determined from the surface spread angle, and a mipmap sampling level, which is a level-of-detail parameter value, can be determined based on the width of the ray cone. As described, mipmaps include pre-calculated images at different levels, which are progressively lower resolution representations of the same image that can be obtained via low pass filtering. In some embodiments, the differential barycentric coordinates can be computed as:</p><p id="p-0081" num="0000"><maths id="MATH-US-00005" num="00005"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mrow>      <mo>(</mo>      <mrow>       <mfrac>        <mrow>         <mo>&#x2202;</mo>         <mtext> </mtext>         <mi>u</mi>        </mrow>        <mrow>         <mo>&#x2202;</mo>         <mtext> </mtext>         <mi>x</mi>        </mrow>       </mfrac>       <mo>,</mo>       <mfrac>        <mrow>         <mo>&#x2202;</mo>         <mtext> </mtext>         <mi>v</mi>        </mrow>        <mrow>         <mo>&#x2202;</mo>         <mtext> </mtext>         <mi>x</mi>        </mrow>       </mfrac>       <mo>,</mo>       <mfrac>        <mrow>         <mo>&#x2202;</mo>         <mtext> </mtext>         <mi>u</mi>        </mrow>        <mrow>         <mo>&#x2202;</mo>         <mtext> </mtext>         <mi>y</mi>        </mrow>       </mfrac>       <mo>,</mo>       <mfrac>        <mrow>         <mo>&#x2202;</mo>         <mtext> </mtext>         <mi>v</mi>        </mrow>        <mrow>         <mo>&#x2202;</mo>         <mtext> </mtext>         <mi>y</mi>        </mrow>       </mfrac>      </mrow>      <mo>)</mo>     </mrow>     <mo>=</mo>     <mrow>      <mrow>       <mo>(</mo>       <mrow>        <mrow>         <msub>          <mi>I</mi>          <mi>u</mi>         </msub>         <mo>&#xb7;</mo>         <mfrac>          <mrow>           <mo>&#x2202;</mo>           <mtext> </mtext>           <msup>            <mi>O</mi>            <mo>&#x2032;</mo>           </msup>          </mrow>          <mrow>           <mo>&#x2202;</mo>           <mtext> </mtext>           <mi>x</mi>          </mrow>         </mfrac>        </mrow>        <mo>,</mo>        <mrow>         <msub>          <mi>I</mi>          <mi>v</mi>         </msub>         <mo>&#xb7;</mo>         <mfrac>          <mrow>           <mo>&#x2202;</mo>           <mtext> </mtext>           <msup>            <mi>O</mi>            <mo>&#x2032;</mo>           </msup>          </mrow>          <mrow>           <mo>&#x2202;</mo>           <mtext> </mtext>           <mi>x</mi>          </mrow>         </mfrac>        </mrow>        <mo>,</mo>        <mrow>         <msub>          <mi>I</mi>          <mi>u</mi>         </msub>         <mo>&#xb7;</mo>         <mfrac>          <mrow>           <mo>&#x2202;</mo>           <mtext> </mtext>           <msup>            <mi>O</mi>            <mo>&#x2032;</mo>           </msup>          </mrow>          <mrow>           <mo>&#x2202;</mo>           <mtext> </mtext>           <mi>y</mi>          </mrow>         </mfrac>        </mrow>        <mo>,</mo>        <mrow>         <msub>          <mi>I</mi>          <mi>v</mi>         </msub>         <mo>&#xb7;</mo>         <mfrac>          <mrow>           <mo>&#x2202;</mo>           <mtext> </mtext>           <msup>            <mi>O</mi>            <mo>&#x2032;</mo>           </msup>          </mrow>          <mrow>           <mo>&#x2202;</mo>           <mtext> </mtext>           <mi>y</mi>          </mrow>         </mfrac>        </mrow>       </mrow>       <mo>)</mo>      </mrow>      <mo>.</mo>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mn>5</mn>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0082" num="0071">The differential barycentric coordinates can be then used to calculate (non-normalized,</p><p id="p-0083" num="0000">which is indicated by the bar above n) differential normals and</p><p id="p-0084" num="0000"><maths id="MATH-US-00006" num="00006"><math overflow="scroll"> <mrow>  <mfrac>   <mrow>    <mo>&#x2202;</mo>    <mtext> </mtext>    <mover>     <mi>n</mi>     <mo>_</mo>    </mover>   </mrow>   <mrow>    <mo>&#x2202;</mo>    <mtext> </mtext>    <mi>x</mi>   </mrow>  </mfrac>  <mo>&#x2062;</mo>  <mtext>   </mtext>  <mi>and</mi>  <mo>&#x2062;</mo>  <mtext>   </mtext>  <mfrac>   <mrow>    <mo>&#x2202;</mo>    <mtext> </mtext>    <mover>     <mi>n</mi>     <mo>_</mo>    </mover>   </mrow>   <mrow>    <mo>&#x2202;</mo>    <mtext> </mtext>    <mi>y</mi>   </mrow>  </mfrac> </mrow></math></maths></p><p id="p-0085" num="0000">at a hit point as:</p><p id="p-0086" num="0000"><maths id="MATH-US-00007" num="00007"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mrow>      <mfrac>       <mrow>        <mo>&#x2202;</mo>        <mtext> </mtext>        <mover>         <mi>n</mi>         <mo>_</mo>        </mover>       </mrow>       <mrow>        <mo>&#x2202;</mo>        <mtext> </mtext>        <mi>x</mi>       </mrow>      </mfrac>      <mo>=</mo>      <mrow>       <mrow>        <mfrac>         <mrow>          <mo>&#x2202;</mo>          <mtext> </mtext>          <mi>u</mi>         </mrow>         <mrow>          <mo>&#x2202;</mo>          <mtext> </mtext>          <mi>x</mi>         </mrow>        </mfrac>        <mo>&#x2062;</mo>        <mrow>         <mo>(</mo>         <mrow>          <msub>           <mi>n</mi>           <mn>1</mn>          </msub>          <mo>-</mo>          <msub>           <mi>n</mi>           <mn>0</mn>          </msub>         </mrow>         <mo>)</mo>        </mrow>       </mrow>       <mo>+</mo>       <mrow>        <mfrac>         <mrow>          <mo>&#x2202;</mo>          <mtext> </mtext>          <mi>v</mi>         </mrow>         <mrow>          <mo>&#x2202;</mo>          <mtext> </mtext>          <mi>x</mi>         </mrow>        </mfrac>        <mo>&#x2062;</mo>        <mrow>         <mo>(</mo>         <mrow>          <msub>           <mi>n</mi>           <mn>2</mn>          </msub>          <mo>-</mo>          <msub>           <mi>n</mi>           <mn>0</mn>          </msub>         </mrow>         <mo>)</mo>        </mrow>       </mrow>      </mrow>     </mrow>     <mo>,</mo>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mn>6</mn>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0087" num="0000">and similarly for</p><p id="p-0088" num="0000"><maths id="MATH-US-00008" num="00008"><math overflow="scroll"> <mrow>  <mfrac>   <mrow>    <mo>&#x2202;</mo>    <mtext> </mtext>    <mover>     <mi>n</mi>     <mo>_</mo>    </mover>   </mrow>   <mrow>    <mo>&#x2202;</mo>    <mtext> </mtext>    <mi>y</mi>   </mrow>  </mfrac>  <mo>.</mo> </mrow></math></maths></p><p id="p-0089" num="0000">In turn, the differential normals can be used to a determine a surface spread angle, without requiring a G-buffer rasterizing pass. Equation (6) comes from differentiating an interpolation of the vertex normals n<sub>i</sub>. Given the barycentric coordinates (u,v), vertex normals n<sub>i </sub>can be interpolated as:</p><p id="p-0090" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i><o ostyle="single">n</o></i>=(1&#x2014;<i>u&#x2212;v</i>)<i>n</i><sub>0</sub><i>+un</i><sub>1</sub><i>+vn</i><sub>2</sub><i>=n</i><sub>0</sub><i>+u</i>(<i>n</i><sub>1</sub><i>&#x2212;n</i><sub>0</sub>)+<i>v</i>(<i>n</i><sub>2</sub><i>&#x2212;n</i><sub>0</sub>),&#x2003;&#x2003;(7)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0091" num="0000">where the bar above n is used to indicate that n is not normalized. The normalized normal n=<o ostyle="single">n</o>/||<o ostyle="single">n</o>|| can then be differentiated as</p><p id="p-0092" num="0000"><maths id="MATH-US-00009" num="00009"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mfrac>      <mrow>       <mo>&#x2202;</mo>       <mtext> </mtext>       <mi>n</mi>      </mrow>      <mrow>       <mo>&#x2202;</mo>       <mtext> </mtext>       <mi>x</mi>      </mrow>     </mfrac>     <mo>=</mo>     <mfrac>      <mrow>       <mrow>        <mrow>         <mo>(</mo>         <mrow>          <mover>           <mi>n</mi>           <mo>_</mo>          </mover>          <mo>&#xb7;</mo>          <mover>           <mi>n</mi>           <mo>_</mo>          </mover>         </mrow>         <mo>)</mo>        </mrow>        <mo>&#x2062;</mo>        <mfrac>         <mrow>          <mo>&#x2202;</mo>          <mtext> </mtext>          <mi>n</mi>         </mrow>         <mrow>          <mo>&#x2202;</mo>          <mtext> </mtext>          <mi>x</mi>         </mrow>        </mfrac>       </mrow>       <mo>-</mo>       <mrow>        <mrow>         <mo>(</mo>         <mrow>          <mover>           <mi>n</mi>           <mo>_</mo>          </mover>          <mo>&#xb7;</mo>          <mfrac>           <mrow>            <mo>&#x2202;</mo>            <mtext> </mtext>            <mover>             <mi>n</mi>             <mo>_</mo>            </mover>           </mrow>           <mrow>            <mo>&#x2202;</mo>            <mtext> </mtext>            <mi>x</mi>           </mrow>          </mfrac>         </mrow>         <mo>)</mo>        </mrow>        <mo>&#x2062;</mo>        <mover>         <mi>n</mi>         <mo>_</mo>        </mover>       </mrow>      </mrow>      <msup>       <mrow>        <mo>(</mo>        <mrow>         <mover>          <mi>n</mi>          <mo>_</mo>         </mover>         <mo>&#xb7;</mo>         <mover>          <mi>n</mi>          <mo>_</mo>         </mover>        </mrow>        <mo>)</mo>       </mrow>       <mrow>        <mn>3</mn>        <mo>/</mo>        <mn>2</mn>       </mrow>      </msup>     </mfrac>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mn>8</mn>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0093" num="0000">with respect to the x-direction, and similarly for</p><p id="p-0094" num="0000"><maths id="MATH-US-00010" num="00010"><math overflow="scroll"> <mfrac>  <mrow>   <mo>&#x2202;</mo>   <mi>n</mi>  </mrow>  <mrow>   <mo>&#x2202;</mo>   <mi>y</mi>  </mrow> </mfrac></math></maths></p><p id="p-0095" num="0000">for the y-direction. In equation (8), <o ostyle="single">n</o><br/>is from equation (7) and</p><p id="p-0096" num="0000"><maths id="MATH-US-00011" num="00011"><math overflow="scroll"> <mfrac>  <mrow>   <mo>&#x2202;</mo>   <mtext> </mtext>   <mover>    <mi>n</mi>    <mo>_</mo>   </mover>  </mrow>  <mrow>   <mo>&#x2202;</mo>   <mtext> </mtext>   <mi>x</mi>  </mrow> </mfrac></math></maths></p><p id="p-0097" num="0000">can be computed, using the differential barycentric<br/>coordinates</p><p id="p-0098" num="0000"><maths id="MATH-US-00012" num="00012"><math overflow="scroll"> <mrow>  <mrow>   <mo>(</mo>   <mrow>    <mfrac>     <mrow>      <mo>&#x2202;</mo>      <mtext> </mtext>      <mi>u</mi>     </mrow>     <mrow>      <mo>&#x2202;</mo>      <mtext> </mtext>      <mi>x</mi>     </mrow>    </mfrac>    <mo>,</mo>    <mfrac>     <mrow>      <mo>&#x2202;</mo>      <mtext> </mtext>      <mi>v</mi>     </mrow>     <mrow>      <mo>&#x2202;</mo>      <mtext> </mtext>      <mi>x</mi>     </mrow>    </mfrac>    <mo>,</mo>    <mfrac>     <mrow>      <mo>&#x2202;</mo>      <mtext> </mtext>      <mi>u</mi>     </mrow>     <mrow>      <mo>&#x2202;</mo>      <mtext> </mtext>      <mi>y</mi>     </mrow>    </mfrac>    <mo>,</mo>    <mfrac>     <mrow>      <mo>&#x2202;</mo>      <mtext> </mtext>      <mi>v</mi>     </mrow>     <mrow>      <mo>&#x2202;</mo>      <mtext> </mtext>      <mi>y</mi>     </mrow>    </mfrac>   </mrow>   <mo>)</mo>  </mrow>  <mo>,</mo> </mrow></math></maths></p><p id="p-0099" num="0000">according to equation (6), and similarly for</p><p id="p-0100" num="0000"><maths id="MATH-US-00013" num="00013"><math overflow="scroll"> <mrow>  <mfrac>   <mrow>    <mo>&#x2202;</mo>    <mover>     <mi>n</mi>     <mo>_</mo>    </mover>   </mrow>   <mrow>    <mo>&#x2202;</mo>    <mtext> </mtext>    <mi>y</mi>   </mrow>  </mfrac>  <mo>.</mo> </mrow></math></maths></p><p id="p-0101" num="0072">Given the differential normals of equation (6) at a hit point, the surface spread angle &#x3b2; can be determined in various ways. In some embodiments, the surface spread angle &#x3b2; can be determined as:</p><p id="p-0102" num="0000"><maths id="MATH-US-00014" num="00014"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mi>&#x3b2;</mi>     <mo>=</mo>     <mrow>      <mo>{</mo>      <mtable>       <mtr>        <mtd>         <mrow>          <mrow>           <mi>max</mi>           <mo>&#x2061;</mo>           <mo>(</mo>           <mrow>            <msub>             <mi>&#x3b2;</mi>             <mi>x</mi>            </msub>            <mo>,</mo>            <msub>             <mi>&#x3b2;</mi>             <mi>y</mi>            </msub>           </mrow>           <mo>)</mo>          </mrow>          <mo>,</mo>         </mrow>        </mtd>        <mtd>         <mrow>          <mrow>           <mi>if</mi>           <mo>&#x2062;</mo>           <mtext>   </mtext>           <msub>            <mi>&#x3b2;</mi>            <mi>x</mi>           </msub>          </mrow>          <mo>&#x2265;</mo>          <mrow>           <mn>0</mn>           <mo>&#x2062;</mo>           <mtext>   </mtext>           <mi>and</mi>           <mo>&#x2062;</mo>           <mtext>   </mtext>           <msub>            <mi>&#x3b2;</mi>            <mi>y</mi>           </msub>          </mrow>          <mo>&#x2265;</mo>          <mn>0</mn>         </mrow>        </mtd>       </mtr>       <mtr>        <mtd>         <mrow>          <mrow>           <mi>min</mi>           <mo>&#x2061;</mo>           <mo>(</mo>           <mrow>            <msub>             <mi>&#x3b2;</mi>             <mi>x</mi>            </msub>            <mo>,</mo>            <msub>             <mi>&#x3b2;</mi>             <mi>y</mi>            </msub>           </mrow>           <mo>)</mo>          </mrow>          <mo>,</mo>         </mrow>        </mtd>        <mtd>         <mrow>          <mrow>           <mrow>            <mi>if</mi>            <mo>&#x2062;</mo>            <mtext>   </mtext>            <msub>             <mi>&#x3b2;</mi>             <mi>x</mi>            </msub>           </mrow>           <mo>&#x3c;</mo>           <mrow>            <mn>0</mn>            <mo>&#x2062;</mo>            <mtext>   </mtext>            <mi>and</mi>            <mo>&#x2062;</mo>            <mtext>   </mtext>            <msub>             <mi>&#x3b2;</mi>             <mi>y</mi>            </msub>           </mrow>           <mo>&#x3c;</mo>           <mn>0</mn>          </mrow>          <mo>,</mo>         </mrow>        </mtd>       </mtr>       <mtr>        <mtd>         <mrow>          <mrow>           <msub>            <mi>&#x3b2;</mi>            <mi>x</mi>           </msub>           <mo>+</mo>           <msub>            <mi>&#x3b2;</mi>            <mi>y</mi>           </msub>          </mrow>          <mo>,</mo>         </mrow>        </mtd>        <mtd>         <mi>otherwise</mi>        </mtd>       </mtr>      </mtable>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mn>9</mn>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0103" num="0000">where &#x3b2;<sub>x </sub>and &#x3b2;<sub>y </sub>are computed from the differential normals as:</p><p id="p-0104" num="0000"><maths id="MATH-US-00015" num="00015"><math overflow="scroll"> <mrow>  <mrow>   <msub>    <mi>&#x3b2;</mi>    <mi>x</mi>   </msub>   <mo>=</mo>   <mrow>    <mrow>     <mi>arctan</mi>     <mo>&#x2061;</mo>     <mo>(</mo>     <mrow>      <mo>&#xf605;</mo>      <mfrac>       <mrow>        <mo>&#x2202;</mo>        <mtext> </mtext>        <mi>n</mi>       </mrow>       <mrow>        <mo>&#x2202;</mo>        <mtext> </mtext>        <mi>x</mi>       </mrow>      </mfrac>      <mo>&#xf606;</mo>     </mrow>     <mo>)</mo>    </mrow>    <mo>&#x2062;</mo>    <mtext>   </mtext>    <mi>sign</mi>    <mo>&#x2062;</mo>    <mtext>   </mtext>    <mrow>     <mo>(</mo>     <mrow>      <mi>r</mi>      <mo>&#xb7;</mo>      <mfrac>       <mrow>        <mo>&#x2202;</mo>        <mtext> </mtext>        <mi>n</mi>       </mrow>       <mrow>        <mo>&#x2202;</mo>        <mtext> </mtext>        <mi>x</mi>       </mrow>      </mfrac>     </mrow>     <mo>)</mo>    </mrow>   </mrow>  </mrow>  <mo>,</mo>  <mtext></mtext>  <mrow>   <msub>    <mi>&#x3b2;</mi>    <mi>y</mi>   </msub>   <mo>=</mo>   <mrow>    <mrow>     <mo>-</mo>     <mrow>      <mi>arctan</mi>      <mo>&#x2061;</mo>      <mo>(</mo>      <mrow>       <mo>&#xf605;</mo>       <mfrac>        <mrow>         <mo>&#x2202;</mo>         <mtext> </mtext>         <mi>n</mi>        </mrow>        <mrow>         <mo>&#x2202;</mo>         <mtext> </mtext>         <mi>y</mi>        </mrow>       </mfrac>       <mo>&#xf606;</mo>      </mrow>      <mo>)</mo>     </mrow>    </mrow>    <mo>&#x2062;</mo>    <mtext>   </mtext>    <mi>sign</mi>    <mo>&#x2062;</mo>    <mtext>   </mtext>    <mrow>     <mo>(</mo>     <mrow>      <mi>u</mi>      <mo>&#xb7;</mo>      <mfrac>       <mrow>        <mo>&#x2202;</mo>        <mtext> </mtext>        <mi>n</mi>       </mrow>       <mrow>        <mo>&#x2202;</mo>        <mtext> </mtext>        <mi>y</mi>       </mrow>      </mfrac>     </mrow>     <mo>)</mo>    </mrow>   </mrow>  </mrow>  <mo>,</mo> </mrow></math></maths></p><p id="p-0105" num="0000">where (v,u,r) is the camera frame including the view direction v, the up vector u, and the right vector r, which is perpendicular to both v and u. The rationale behind the surface spread of equation (9) is to compute one angle per x and y. If the surface is convex, then both of the angles will be positive. On the other hand, if the surface is concave, then both angles will be negative. In such cases, the angle with the largest magnitude is used. Otherwise, if one angle is positive and the other angle is negative, which can occur on the surface of a hyperbolic paraboloid, then a sum of the angles is used. The intuition behind the sum is that if a surface point is &#x201c;as much&#x201d; convex as concave, then the sum will be zero and the behavior is that of a planar surface.</p><p id="p-0106" num="0073">In other embodiments, the surface spread angle &#x3b2; can be determined as:</p><p id="p-0107" num="0000"><maths id="MATH-US-00016" num="00016"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mi>&#x3b2;</mi>     <mo>=</mo>     <mrow>      <mo>{</mo>      <mrow>       <mtable>        <mtr>         <mtd>          <mtable>           <mtr>            <mtd>             <mrow>              <msub>               <mi>&#x3b2;</mi>               <mi>x</mi>              </msub>              <mo>,</mo>             </mrow>            </mtd>            <mtd>             <mrow>              <mrow>               <mi>if</mi>               <mo>&#x2062;</mo>               <mtext>   </mtext>               <mrow>                <semantics definitionURL="">                 <mo>&#x2758;</mo>                 <annotation encoding="Mathematica">"\[LeftBracketingBar]"</annotation>                </semantics>                <msub>                 <mi>&#x3b2;</mi>                 <mi>x</mi>                </msub>                <semantics definitionURL="">                 <mo>&#x2758;</mo>                 <annotation encoding="Mathematica">"\[RightBracketingBar]"</annotation>                </semantics>               </mrow>              </mrow>              <mo>&#x2265;</mo>              <mrow>               <semantics definitionURL="">                <mo>&#x2758;</mo>                <annotation encoding="Mathematica">"\[LeftBracketingBar]"</annotation>               </semantics>               <msub>                <mi>&#x3b2;</mi>                <mi>y</mi>               </msub>               <semantics definitionURL="">                <mo>&#x2758;</mo>                <annotation encoding="Mathematica">"\[RightBracketingBar]"</annotation>               </semantics>              </mrow>             </mrow>            </mtd>           </mtr>          </mtable>         </mtd>        </mtr>        <mtr>         <mtd>          <mtable>           <mtr>            <mtd>             <msub>              <mi>&#x3b2;</mi>              <mi>y</mi>             </msub>            </mtd>            <mtd>             <mi>otherwise</mi>            </mtd>           </mtr>          </mtable>         </mtd>        </mtr>       </mtable>       <mo>.</mo>      </mrow>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mn>10</mn>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0108" num="0074">The surface spread angle of equation (10) uses the largest angle &#x3b2;<sub>x </sub>or &#x3b2;<sub>y</sub>, meaning that the curvature with the largest magnitude dictates the value of the surface spread angle &#x3b2;. Selecting the curvature with the largest magnitude ensures that texture filtering based on the surface spread angle is conservative, i.e., the texture filtering tends to produce more blurring than aliasing. Excessive blurring is generally preferable over excessive aliasing, which can produce noisy, flickering results.</p><p id="p-0109" num="0075">In other embodiments, the surface spread angle &#x3b2; can be determined as:</p><p id="p-0110" num="0000"><maths id="MATH-US-00017" num="00017"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mi>&#x3b2;</mi>     <mo>=</mo>     <mrow>      <mfrac>       <mn>1</mn>       <mn>2</mn>      </mfrac>      <mo>&#x2062;</mo>      <mrow>       <mrow>        <mo>(</mo>        <mrow>         <msub>          <mi>&#x3b2;</mi>          <mi>x</mi>         </msub>         <mo>+</mo>         <msub>          <mi>&#x3b2;</mi>          <mi>y</mi>         </msub>        </mrow>        <mo>)</mo>       </mrow>       <mo>.</mo>      </mrow>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mn>11</mn>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0111" num="0000">The surface spread of equation (11) is an approximation of the mean curvature.</p><p id="p-0112" num="0076">In other embodiments, the surface spread angle &#x3b2; can be determined as:</p><p id="p-0113" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>&#x3b2;=2&#x221a;{square root over (&#x3b2;<sub>x</sub><sup>2</sup>+&#x3b2;<sub>x</sub><sup>2</sup>)}&#xb7;(|&#x3b2;<sub>x</sub>|&#x2265;|&#x3b2;<sub>y</sub>|?sign(&#x3b2;<sub>x</sub>):sign(&#x3b2;<sub>y</sub>)).&#x2003;&#x2003;(12)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0114" num="0000">The part of equation (12) inside the parenthesis causes the part to the left of the left parenthesis to be multiplied with the sign of &#x3b2;<sub>x </sub>if the absolute value of &#x3b2;<sub>x </sub>is greater than or equal to the absolute value of &#x3b2;<sub>y</sub>, and otherwise the part to the left of the left parenthesis is multiplied by the sign of &#x3b2;<sub>y</sub>.</p><p id="p-0115" num="0077">As described, the rendering application <b>130</b> can use the surface spread angle &#x3b2; to determine the width of the ray cone at a later hit point (e.g., the hit point <b>424</b>), which can in turned be used to determine a mipmap sampling level, and the rendering application <b>130</b> can then instruct a texture unit in a GPU to perform texture filtering in which a mipmap is sampled at the sampling level. It should be understood that GPU implementations of texture filtering are well-known. For example, the GPU could perform bilinear interpolation in the closest mipmap level. As another example, the sampling level of the mipmap can be a non-integer that is between two levels, in which case the GPU may blend the bilinear filtering results from the two mipmap levels based on a fraction of the non-integer value determined using the width of the ray cone at the hit point.</p><p id="p-0116" num="0078">More formally, let the mipmap sampling level be denoted by a parameter X It is well known that the parameter X for the i<sup>th </sup>hit point can be computed as:</p><p id="p-0117" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>&#x3bb;<sub>i</sub>=&#x394;<sub>i</sub>+log<sub>2</sub><i>|W</i><sub>i</sub>|&#x2212;log<sub>2</sub><i>|n</i><sub>i</sub><i>&#xb7;d</i><sub>i</sub>|,&#x2003;&#x2003;(13)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0118" num="0000">where &#x394;<sub>i </sub>is defined as:</p><p id="p-0119" num="0000"><maths id="MATH-US-00018" num="00018"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mrow>      <msub>       <mi>&#x394;</mi>       <mi>i</mi>      </msub>      <mo>=</mo>      <mrow>       <mfrac>        <mn>1</mn>        <mn>2</mn>       </mfrac>       <mo>&#x2062;</mo>       <mrow>        <msub>         <mi>log</mi>         <mn>2</mn>        </msub>        <mo>(</mo>        <mfrac>         <msub>          <mi>t</mi>          <mi>a</mi>         </msub>         <msub>          <mi>p</mi>          <mi>a</mi>         </msub>        </mfrac>        <mo>)</mo>       </mrow>      </mrow>     </mrow>     <mo>,</mo>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mn>14</mn>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0120" num="0000">with t<sub>a</sub>=wh|(t<sub>1x</sub>&#x2212;t<sub>0x</sub>)(t<sub>2y</sub>&#x2212;t<sub>0y</sub>)&#x2212;(t<sub>2x</sub>&#x2212;t<sub>0x</sub>)(t<sub>1y</sub>&#x2212;t<sub>0y</sub>)|=wht<sub>t</sub>, and P<sub>a</sub>=|(P<sub>1x</sub>&#x2212;P<sub>0x</sub>)(P<sub>2y</sub>&#x2212;P<sub>0y</sub>)&#x2212;(P<sub>2x</sub>&#x2212;P<sub>0x</sub>)(P<sub>1y</sub>&#x2212;P<sub>0y</sub>)|, where w&#xd7;h is the texture resolution.</p><p id="p-0121" num="0079">In addition, the width of the ray cone at the i<sup>th </sup>hit point W<sub>i </sub>can be computed as:</p><p id="p-0122" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>W</i><sub>i</sub><i>=W</i><sub>i&#x2212;1</sub><i>+y</i><sub>i</sub><i>t</i><sub>i</sub>,&#x2003;&#x2003;(15)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0123" num="0000">where y<sub>i</sub>=y<sub>i&#x2212;1</sub>+&#x3b2;<sub>i&#x2212;1</sub>. Returning to the example of <figref idref="DRAWINGS">FIG. <b>4</b></figref>, the width of the ray cone <b>400</b> at the hit point <b>422</b> is W<sub>0</sub>=at<sub>0</sub>=y<sub>0</sub>t<sub>0</sub>, where a has been introduced as a=y<sub>0</sub>; the width of the ray cone <b>400</b> at the hit point <b>424</b> is W<sub>1</sub>=W<sub>0</sub>+y<sub>1</sub>t<sub>0</sub>=at<sub>o</sub>+(a+&#x3b2;<sub>0</sub>)t<sub>1</sub>, where &#x3b2;<sub>0 </sub>is the surface spread angle at the first hit point, etc.</p><p id="p-0124" num="0080">In some embodiments, the rendering application <b>130</b> can use a modification to equation (14) that more efficiently handles multiple textures with different sizes, per triangle, which are also referred to herein as resolutions. For example, one texture could be a base color texture, another texture could be a specular color texture indicating shininess, another texture could be a normal map indicating how normals change over a surface, another texture could be an emissive texture, etc., and the multiple textures could have different resolutions. Equation (14) bakes the texture resolution w x h into Ai, which is not ideal when multiple textures with different resolutions are applied to a triangle, because a separate mipmap sampling level parameter value Xi, needs to be used per texture. However, equation (14) can be rewritten as:</p><p id="p-0125" num="0000"><maths id="MATH-US-00019" num="00019"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <msub>      <mi>&#x394;</mi>      <mi>i</mi>     </msub>     <mo>=</mo>     <mrow>      <mrow>       <mfrac>        <mn>1</mn>        <mn>2</mn>       </mfrac>       <mo>&#x2062;</mo>       <mrow>        <msub>         <mi>log</mi>         <mn>2</mn>        </msub>        <mo>(</mo>        <mfrac>         <msub>          <mi>t</mi>          <mi>a</mi>         </msub>         <msub>          <mi>p</mi>          <mi>a</mi>         </msub>        </mfrac>        <mo>)</mo>       </mrow>      </mrow>      <mo>=</mo>      <mrow>       <mrow>        <mfrac>         <mn>1</mn>         <mn>2</mn>        </mfrac>        <mo>&#x2062;</mo>        <mrow>         <mi>log</mi>         <mo>&#x2061;</mo>         <mo>(</mo>         <mfrac>          <msub>           <mi>wht</mi>           <mi>t</mi>          </msub>          <msub>           <mi>p</mi>           <mi>a</mi>          </msub>         </mfrac>         <mo>)</mo>        </mrow>       </mrow>       <mo>=</mo>       <mrow>        <mrow>         <mfrac>          <mn>1</mn>          <mn>2</mn>         </mfrac>         <mo>&#x2062;</mo>         <mrow>          <msub>           <mi>log</mi>           <mn>2</mn>          </msub>          <mo>(</mo>          <mi>wh</mi>          <mo>)</mo>         </mrow>        </mrow>        <mo>+</mo>        <mrow>         <mfrac>          <mn>1</mn>          <mn>2</mn>         </mfrac>         <mo>&#x2062;</mo>         <mrow>          <mrow>           <msub>            <mi>log</mi>            <mn>2</mn>           </msub>           <mo>(</mo>           <mfrac>            <msub>             <mi>t</mi>             <mi>t</mi>            </msub>            <msub>             <mi>p</mi>             <mi>a</mi>            </msub>           </mfrac>           <mo>)</mo>          </mrow>          <mo>.</mo>         </mrow>        </mrow>       </mrow>      </mrow>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mn>16</mn>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0126" num="0081">In equation (16)</p><p id="p-0127" num="0000"><maths id="MATH-US-00020" num="00020"><math overflow="scroll"> <mrow>  <mo>,</mo>  <mrow>   <mfrac>    <mn>1</mn>    <mn>2</mn>   </mfrac>   <mo>&#x2062;</mo>   <mrow>    <msub>     <mi>log</mi>     <mn>2</mn>    </msub>    <mo>(</mo>    <mi>wh</mi>    <mo>)</mo>   </mrow>  </mrow> </mrow></math></maths></p><p id="p-0128" num="0000">is a texture resolution-dependent term that includes the width and height of the texture image, and</p><p id="p-0129" num="0000"><maths id="MATH-US-00021" num="00021"><math overflow="scroll"> <mrow>  <mfrac>   <mn>1</mn>   <mn>2</mn>  </mfrac>  <mo>&#x2062;</mo>  <mrow>   <msub>    <mi>log</mi>    <mn>2</mn>   </msub>   <mo>(</mo>   <mfrac>    <msub>     <mi>t</mi>     <mi>t</mi>    </msub>    <msub>     <mi>p</mi>     <mi>a</mi>    </msub>   </mfrac>   <mo>)</mo>  </mrow> </mrow></math></maths></p><p id="p-0130" num="0000">is a texture resolution-independent term (although still dependent on texture coordinates). Further, rather than computing the mipmap sampling level parameter value Ai, the rendering application <b>130</b> can first compute part of the mipmap sampling level parameter value Ait that is independent of texture resolution:</p><p id="p-0131" num="0000"><maths id="MATH-US-00022" num="00022"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mrow>      <msub>       <mi>&#x3bb;</mi>       <mi>it</mi>      </msub>      <mo>=</mo>      <mrow>       <mrow>        <mfrac>         <mn>1</mn>         <mn>2</mn>        </mfrac>        <mo>&#x2062;</mo>        <mrow>         <msub>          <mi>log</mi>          <mn>2</mn>         </msub>         <mo>(</mo>         <mfrac>          <msub>           <mi>t</mi>           <mi>t</mi>          </msub>          <msub>           <mi>p</mi>           <mi>a</mi>          </msub>         </mfrac>         <mo>)</mo>        </mrow>       </mrow>       <mo>+</mo>       <mrow>        <msub>         <mi>log</mi>         <mn>2</mn>        </msub>        <mo>&#x2062;</mo>        <mrow>         <semantics definitionURL="">          <mo>&#x2758;</mo>          <annotation encoding="Mathematica">"\[LeftBracketingBar]"</annotation>         </semantics>         <msub>          <mi>W</mi>          <mi>i</mi>         </msub>         <semantics definitionURL="">          <mo>&#x2758;</mo>          <annotation encoding="Mathematica">"\[RightBracketingBar]"</annotation>         </semantics>        </mrow>       </mrow>       <mo>-</mo>       <mrow>        <msub>         <mi>log</mi>         <mn>2</mn>        </msub>        <mo>&#x2062;</mo>        <mrow>         <semantics definitionURL="">          <mo>&#x2758;</mo>          <annotation encoding="Mathematica">"\[LeftBracketingBar]"</annotation>         </semantics>         <mrow>          <msub>           <mi>n</mi>           <mi>i</mi>          </msub>          <mo>&#xb7;</mo>          <msub>           <mi>d</mi>           <mi>i</mi>          </msub>         </mrow>         <semantics definitionURL="">          <mo>&#x2758;</mo>          <annotation encoding="Mathematica">"\[RightBracketingBar]"</annotation>         </semantics>        </mrow>       </mrow>      </mrow>     </mrow>     <mo>,</mo>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mn>17</mn>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0132" num="0000">which can be shared among all textures for a triangle. Then, just before a particular texture j is sampled, the rendering application <b>130</b> can compute the final &#x3bb;<sub>ij </sub>for that texture as:</p><p id="p-0133" num="0000"><maths id="MATH-US-00023" num="00023"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <msub>      <mi>&#x3bb;</mi>      <mi>ij</mi>     </msub>     <mo>=</mo>     <mrow>      <msub>       <mi>&#x3bb;</mi>       <mi>it</mi>      </msub>      <mo>+</mo>      <mrow>       <mfrac>        <mn>1</mn>        <mn>2</mn>       </mfrac>       <mo>&#x2062;</mo>       <mrow>        <mrow>         <msub>          <mi>log</mi>          <mn>2</mn>         </msub>         <mo>(</mo>         <mrow>          <msub>           <mi>w</mi>           <mi>j</mi>          </msub>          <mo>&#x2062;</mo>          <msub>           <mi>h</mi>           <mi>j</mi>          </msub>         </mrow>         <mo>)</mo>        </mrow>        <mo>.</mo>       </mrow>      </mrow>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mn>18</mn>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0134" num="0082">Referring generally to <figref idref="DRAWINGS">FIG. <b>4</b>-<b>6</b></figref>, persons skilled in the art will understand that the foregoing examples are presented for clarity and not meant to limit the scope of the present embodiments. As a general matter, any technically feasible approach to modifying or permuting graphics objects can be applied, and any technically feasible approach to detecting modified or permuted graphics objects can equally be applied.</p><p id="p-0135" num="0083"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a flow diagram of method steps for ray cone tracing, according to various embodiments. Although the method steps are described in conjunction with the systems of <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>3</b></figref>, persons skilled in the art will understand that any system configured to perform the method steps in any order falls within the scope of the present embodiments. Although described with respect to tracing a single ray, the method steps can be repeated to trace multiple rays when rendering an image.</p><p id="p-0136" num="0084">As shown, a method <b>700</b> begins at step <b>702</b>, where the rendering application <b>130</b> traces a ray cone through a pixel in a screen space into a scene until a second hit point. The second hit point occurs after the ray cone hits and reflects off of geometry within the scene at a first hit point, and the reflected ray cone then hits geometry within the scene again at the second hit point. Step <b>702</b> assumes that such a second hit point exists. If there is no second hit point, then the method <b>700</b> ends.</p><p id="p-0137" num="0085">At step <b>704</b>, the rendering application <b>130</b> determines differential barycentric coordinates at the hit point. In some embodiments, the rendering application <b>130</b> determines differential barycentric coordinates based on plane equations according to equations (1)-(5).</p><p id="p-0138" num="0086">At step <b>706</b>, the rendering application <b>130</b> determines differential normals based on the differential barycentric coordinates. In some embodiments, the rendering application <b>130</b> determines differential normals according to equation (6).</p><p id="p-0139" num="0087">At step <b>708</b>, the rendering application <b>130</b> determines a surface spread angle based on the differential normals. In some embodiments, the rendering application <b>130</b> may determine the surface spread angle according to equation (9). In other embodiments, the rendering application <b>130</b> may determine the surface spread angle according to equation (10). In other embodiments, the rendering application <b>130</b> may determine the surface spread angle according to equation (11). In yet further embodiments, the rendering application <b>130</b> may determine the surface spread angle according to equation (12).</p><p id="p-0140" num="0088">At step <b>710</b>, if the surface at the hit point is not textured, then the method <b>700</b> continues to step <b>712</b>, where the rendering application <b>130</b> applies shading computations, computes a reflected ray cone, and traces a reflected ray with the reflected ray cone until a next hit point. In some embodiments, the reflected ray cone may grow or shrink, depending on a surface spread angle that is determined in one of a number of ways based on differential normals, which are themselves computed based on differential barycentric coordinates at the hit point, as described above in conjunction with <b>6</b>. Assuming a next hit point exists, the method <b>700</b> then returns to step <b>704</b>, where the rendering application <b>130</b> determines differential barycentric coordinates at the next hit point.</p><p id="p-0141" num="0089">On the other hand, if the rendering application <b>130</b> determines that the surface at the hit point is textured at step <b>710</b>, then the method <b>700</b> proceeds directly to step <b>714</b>, where the rendering application <b>130</b> determines a mipmap sampling level based on the surface spread angle(s) determined at previous hit point(s), which can be used to determine the width of the ray cone at a current hit point. In some embodiments, the rendering application <b>130</b> determines a mipmap sampling level parameter value &#x3bb;<sub>i </sub>according to equations (13)-(15). In some embodiments, the rendering application <b>130</b> further handles multiple textures with different dimensions that are applied to a triangle by first computing part of the mipmap sampling level parameter value that is independent of texture resolution, and then computing the remainder of the mipmap sampling level parameter value based on the textures themselves, according to equations (16)-(17).</p><p id="p-0142" num="0090">At step <b>716</b>, the rendering application <b>130</b> causes the texture unit in a GPU (e.g., the texture unit <b>315</b> described above in conjunction with <figref idref="DRAWINGS">FIG. <b>3</b></figref>) to perform texture filtering based on the mipmap sampling level and a hit point. In some embodiments, the texture unit may perform trilinear mipmapping and sample the mipmap at the mipmap sampling level.</p><p id="p-0143" num="0091">At step <b>718</b>, the rendering application <b>130</b> receives a texture filter value from the texture unit, after the texture unit has performed the texture filtering based on the mipmap sampling level and the hit point.</p><p id="p-0144" num="0092">At step <b>720</b>, the rendering application <b>130</b> applies or accumulates the texture filter value to the pixel that the ray cone was traced through at step <b>702</b>. The applied or accumulated texture filter value contributes to the color of the pixel in a rendered image. As described, the rendered image can be, e.g., an image or frame within a video game or film, an image generated by an architectural or design application or any other application, or the like.</p><p id="p-0145" num="0093">Although described herein with respect to applying or accumulating the texture filter value to the pixel, in other embodiments, the texture filter value may be used in any technically feasible manner.</p><p id="p-0146" num="0094">At step <b>722</b>, the rendering application <b>130</b> applies shading computations, computes a reflected ray cone, and traces a reflection ray with the reflected ray cone until a next hit point. Similar to step <b>706</b>, a rate at which the reflected ray cone grows or shrinks depends on the surface spread angle, determined at step <b>712</b>. Assuming a next hit point exists, the method <b>700</b> returns to step <b>704</b>, where the rendering application <b>130</b> determines differential barycentric coordinates at the next hit point.</p><p id="p-0147" num="0095">In sum, the disclosed techniques avoid a separate G-buffer rasterizing pass during ray cone tracing by determining differential barycentric coordinates at a hit point, which are used to determine differential normals that are then used to determine surface spread angles which are used to compute a width of the ray cone, from which mipmap sampling levels can be determined and used to sample a mipmap during a texture filtering operation. Various techniques are disclosed for computing surface spread angles based on distinct angles computed for the x and y axes. In addition, techniques are disclosed for determining mipmap sampling level parameter values for multiple textures having different sizes by first computing part of a mipmap sampling level parameter value that is independent of resolution, and then computing the remainder of the mipmap sampling level parameter value based on the multiple textures.</p><p id="p-0148" num="0096">At least one technological advantage of the disclosed techniques relative to the prior art is that differential normals used to determine a mipmap sampling level are determined without requiring a separate G-buffer rasterizing pass. As a result, the disclosed techniques are faster and require less storage space than conventional ray cone tracing techniques. Further, techniques are disclosed for determining surface spread angles that produce more correctly rendered images than surface spread angles determined using conventional techniques. In addition, the disclosed techniques permit mipmap sampling levels for multiple textures with different resolutions to be determined more efficiently than conventional ray cone tracing techniques. These technological advantages represent one or more technological advancements relative to prior art approaches.</p><p id="p-0149" num="0097">1. In some embodiments, a computer-implemented method for computing a texture color comprises tracing a ray cone through a graphics scene, determining a curvature of a first surface within the graphics scene at a point where the ray cone hits the first surface based on differential barycentric coordinates associated with the point, determining, based on the curvature of the first surface, a width of the ray cone at a subsequent point where the ray cone hits a second surface within the graphics scene, and computing a texture color based on the width of the ray cone.</p><p id="p-0150" num="0098">2. The computer-implemented method of clause 1, wherein the curvature of the first surface is determined by determining whether the absolute value of a first curvature associated with a first dimension is larger than the absolute value of a second curvature associated with a second dimension.</p><p id="p-0151" num="0099">3. The computer-implemented method of clauses 1 or 2, wherein computing the texture color comprises determining a level-of-detail parameter value based on the width of the ray cone, and performing one or more texture filtering operations based on the level-of-detail parameter value.</p><p id="p-0152" num="0100">4. The computer-implemented method of any of clauses 1-3, further comprising generating a rendered image, wherein generating the rendered image comprises applying or accumulating the texture color to a pixel in the rendered image.</p><p id="p-0153" num="0101">5. The computer-implemented method of any of clauses 1-4, wherein the rendered image is one of an image or a frame associated with a video game, a film, or an architectural or design application.</p><p id="p-0154" num="0102">6. In some embodiments, a computer-implemented method for computing a texture color comprises determining a set of differential barycentric coordinates associated with a hit point at which a ray cone intersects a first surface within a graphics scene, determining a first surface spread angle associated with the hit point based on the set of differential barycentric coordinates, determining, based on the first surface spread angle, a width of the ray cone at a subsequent hit point where the ray cone intersects a second surface within the graphics scene, determining a first level-of-detail parameter value based on the width of the ray cone, performing one or more texture filtering operations based on the first level-of-detail parameter value, and computing a texture color based on results of the one or more texture filtering operations.</p><p id="p-0155" num="0103">7. The computer-implemented method of clause 6, wherein determining the first surface spread angle comprises determining a set of differential normals associated with the first surface at the hit point based on the set of differential barycentric coordinates, and determining the first surface spread angle based on the set of differential normals.</p><p id="p-0156" num="0104">8. The computer-implemented method of clauses 6 or 7, wherein determining the first surface spread angle comprises determining a second surface spread angle associated with a first dimension and a third surface spread angle associated with a second dimension, and determining the first surface spread angle based on the second surface spread angle and the third surface spread angle.</p><p id="p-0157" num="0105">9. The computer-implemented method of any of clauses 6-8, wherein determining the first surface spread angle comprises selecting one of the second surface spread angle or the third surface spread angle that has a larger absolute value.</p><p id="p-0158" num="0106">10. The computer-implemented method of any of clauses 6-9, wherein the first surface spread angle is determined by determining an average of the second surface spread angle and the third surface spread angle.</p><p id="p-0159" num="0107">11. The computer-implemented method of any of clauses 6-10, wherein determining the first surface spread angle based on the second surface spread angle and the third surface spread angle comprises selecting the larger of the second surface spread angle and the third surface spread angle if the second surface spread angle and the third surface spread angle are both positive angles, selecting the smaller of the second surface spread angle and the third surface spread angle if the second surface spread angle and the third surface spread angle are both negative angles, or determining a sum of the second surface spread angle and the third surface spread angle if only one of the second surface spread angle or the third surface spread angle is a positive angle.</p><p id="p-0160" num="0108">12. The computer-implemented method of any of clauses 6-11, wherein determining the first surface spread angle based on the second surface spread angle and the third surface spread angle comprises determining a product of a term and a sign of the second surface spread angle if an absolute value of the second surface spread angle is greater than an absolute value of the third surface spread angle, or determining a product of the term and a sign of the third surface spread angle if the absolute value of the third surface spread angle is greater than the absolute value of the second surface spread angle, wherein the term equals a product of two and a sum of a square root of the second surface spread angle squared and the third surface spread angle squared.</p><p id="p-0161" num="0109">13. The computer-implemented method of any of clauses 6-12, wherein the second surface is associated with a plurality of textures having different resolutions, and determining the first level-of-detail parameter comprises, determining a second level-of-detail parameter value that is independent of texture resolution, and determining the first level-of-detail parameter value based on the second second-level-of-detail parameter value.</p><p id="p-0162" num="0110">14. In some embodiments, one or more non-transitory computer-readable media storing program instructions that, when executed by at least one processor, cause the at least one processor to perform the steps of determining a set of differential barycentric coordinates associated with a hit point at which a ray cone intersects a first surface within a graphics scene, determining a first surface spread angle associated with the hit point based on the set of differential barycentric coordinates, determining, based on the first surface spread angle, a width of the ray cone at a subsequent hit point where the ray cone intersects a second surface within the graphics scene, determining a first level-of-detail parameter value based on the width of the ray cone, performing one or more texture filtering operations based on the first level-of-detail parameter value, and computing a texture color based on results of the one or more texture filtering operations.</p><p id="p-0163" num="0111">15. The one or more non-transitory computer-readable media of clause 14, wherein the at least one processor includes a graphics processing unit (GPU), and the one or more texture filtering operations are performed via a texture unit included in the GPU.</p><p id="p-0164" num="0112">16. The one or more non-transitory computer-readable media of clauses 14 or 15, wherein determining the first surface spread angle comprises determining a set of differential normals associated with the first surface at the hit point based on the set of differential barycentric coordinates, and determining the first surface spread angle based on the set of differential normals.</p><p id="p-0165" num="0113">17. The one or more non-transitory computer-readable media of any of clauses 14-16, wherein determining the first surface spread angle comprises determining a second surface spread angle associated with a first dimension and a third surface spread angle associated with a second dimension, and selecting one of the second surface spread angle or the third surface spread angle that has a larger absolute value.</p><p id="p-0166" num="0114">18. The one or more non-transitory computer-readable media of any of clauses 14-17, wherein determining the first surface spread angle comprises determining a second surface spread angle associated with a first dimension and a third surface spread angle associated with a second dimension, and determining an average of the second surface spread angle and the third surface spread angle.</p><p id="p-0167" num="0115">19. The one or more non-transitory computer-readable media of any of clauses 14-18, wherein determining the first surface spread angle comprises determining a second surface spread angle associated with a first dimension and a third surface spread angle associated with a second dimension, selecting the larger of the second surface spread angle and the third surface spread angle if the second surface spread angle and the third surface spread angle are both positive angles, selecting the smaller of the second surface spread angle and the third surface spread angle if the second surface spread angle and the third surface spread angle are both negative angles, or determining a sum of the second surface spread angle and the third surface spread angle if only one of the second surface spread angle or the third surface spread angle is a positive angle.</p><p id="p-0168" num="0116">20. The one or more non-transitory computer-readable media of any of clauses 14-19, wherein determining the first surface spread angle comprises determining a second surface spread angle associated with a first dimension and a third surface spread angle associated with a second dimension, determining a product of a term and a sign of the second surface spread angle if an absolute value of the second surface spread angle is greater than an absolute value of the third surface spread angle, or determining a product of the term and a sign of the third surface spread angle if the absolute value of the third surface spread angle is greater than the absolute value of the second surface spread angle, wherein the term equals a product of two and a sum of a square root of the second surface spread angle squared and the third surface spread angle squared.</p><p id="p-0169" num="0117">21. The one or more non-transitory computer-readable media of any of clauses 14-20, wherein the second surface is associated with a plurality of textures having different resolutions, and determining the first level-of-detail parameter comprises, determining a second level-of-detail parameter value that is independent of texture resolution, and determining the first level-of-detail parameter value based on the second second-level-of-detail parameter value.</p><p id="p-0170" num="0118">22. The one or more non-transitory computer-readable media of any of clauses 14-21, wherein the first level-of-detail parameter value indicates a mipmap sampling level.</p><p id="p-0171" num="0119">23. In some embodiments, a system comprises one or more memories storing instructions, and one or more processors that are coupled to the one or more memories and, when executing the instructions, are configured to determine a set of differential barycentric coordinates associated with a hit point at which a ray cone intersects a first surface within a graphics scene, determine a first surface spread angle associated with the hit point based on the set of differential barycentric coordinates, determine, based on the first surface spread angle, a width of the ray cone at a subsequent hit point where the ray cone intersects a second surface within the graphics scene, determine a first level-of-detail parameter value based on the width of the ray cone, perform one or more texture filtering operations based on the first level-of-detail parameter value, and compute a texture color based on results of the one or more texture filtering operations.</p><p id="p-0172" num="0120">Any and all combinations of any of the claim elements recited in any of the claims and/or any elements described in this application, in any fashion, fall within the contemplated scope of the present disclosure and protection.</p><p id="p-0173" num="0121">The descriptions of the various embodiments have been presented for purposes of illustration, but are not intended to be exhaustive or limited to the embodiments disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the described embodiments.</p><p id="p-0174" num="0122">Aspects of the present embodiments may be embodied as a system, method or computer program product. Accordingly, aspects of the present disclosure may take the form of an entirely hardware embodiment, an entirely software embodiment (including firmware, resident software, micro-code, etc.) or an embodiment combining software and hardware aspects that may all generally be referred to herein as a &#x201c;module&#x201d; or &#x201c;system.&#x201d; Furthermore, aspects of the present disclosure may take the form of a computer program product embodied in one or more computer readable medium(s) having computer readable program code embodied thereon.</p><p id="p-0175" num="0123">Any combination of one or more computer readable medium(s) may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be, for example, but not limited to, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, or device, or any suitable combination of the foregoing. More specific examples (a non-exhaustive list) of the computer readable storage medium would include the following: an electrical connection having one or more wires, a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or Flash memory), an optical fiber, a portable compact disc read-only memory (CD-ROM), an optical storage device, a magnetic storage device, or any suitable combination of the foregoing. In the context of this document, a computer readable storage medium may be any tangible medium that can contain, or store a program for use by or in connection with an instruction execution system, apparatus, or device.</p><p id="p-0176" num="0124">Aspects of the present disclosure are described above with reference to flowchart illustrations and/or block diagrams of methods, apparatus (systems) and computer program products according to embodiments of the disclosure. It will be understood that each block of the flowchart illustrations and/or block diagrams, and combinations of blocks in the flowchart illustrations and/or block diagrams, can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine. The instructions, when executed via the processor of the computer or other programmable data processing apparatus, enable the implementation of the functions/acts specified in the flowchart and/or block diagram block or blocks. Such processors may be, without limitation, general purpose processors, special-purpose processors, application-specific processors, or field-programmable gate arrays.</p><p id="p-0177" num="0125">The flowchart and block diagrams in the figures illustrate the architecture, functionality, and operation of possible implementations of systems, methods and computer program products according to various embodiments of the present disclosure. In this regard, each block in the flowchart or block diagrams may represent a module, segment, or portion of code, which comprises one or more executable instructions for implementing the specified logical function(s). It should also be noted that, in some alternative implementations, the functions noted in the block may occur out of the order noted in the figures. For example, two blocks shown in succession may, in fact, be executed substantially concurrently, or the blocks may sometimes be executed in the reverse order, depending upon the functionality involved. It will also be noted that each block of the block diagrams and/or flowchart illustration, and combinations of blocks in the block diagrams and/or flowchart illustration, can be implemented by special purpose hardware-based systems that perform the specified functions or acts, or combinations of special purpose hardware and computer instructions.</p><p id="p-0178" num="0126">While the preceding is directed to embodiments of the present disclosure, other and further embodiments of the disclosure may be devised without departing from the basic scope thereof, and the scope thereof is determined by the claims that follow.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-math idrefs="MATH-US-00001" nb-file="US20230005210A1-20230105-M00001.NB"><img id="EMI-M00001" he="6.01mm" wi="76.20mm" file="US20230005210A1-20230105-M00001.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00002" nb-file="US20230005210A1-20230105-M00002.NB"><img id="EMI-M00002" he="6.01mm" wi="76.20mm" file="US20230005210A1-20230105-M00002.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00003" nb-file="US20230005210A1-20230105-M00003.NB"><img id="EMI-M00003" he="5.67mm" wi="76.20mm" file="US20230005210A1-20230105-M00003.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00004" nb-file="US20230005210A1-20230105-M00004.NB"><img id="EMI-M00004" he="5.67mm" wi="76.20mm" file="US20230005210A1-20230105-M00004.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00005" nb-file="US20230005210A1-20230105-M00005.NB"><img id="EMI-M00005" he="6.01mm" wi="76.20mm" file="US20230005210A1-20230105-M00005.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00006" nb-file="US20230005210A1-20230105-M00006.NB"><img id="EMI-M00006" he="6.01mm" wi="76.20mm" file="US20230005210A1-20230105-M00006.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00007" nb-file="US20230005210A1-20230105-M00007.NB"><img id="EMI-M00007" he="5.67mm" wi="76.20mm" file="US20230005210A1-20230105-M00007.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00008" nb-file="US20230005210A1-20230105-M00008.NB"><img id="EMI-M00008" he="6.01mm" wi="76.20mm" file="US20230005210A1-20230105-M00008.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00009" nb-file="US20230005210A1-20230105-M00009.NB"><img id="EMI-M00009" he="9.91mm" wi="76.20mm" file="US20230005210A1-20230105-M00009.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00010" nb-file="US20230005210A1-20230105-M00010.NB"><img id="EMI-M00010" he="6.01mm" wi="76.20mm" file="US20230005210A1-20230105-M00010.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00011" nb-file="US20230005210A1-20230105-M00011.NB"><img id="EMI-M00011" he="5.67mm" wi="76.20mm" file="US20230005210A1-20230105-M00011.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00012" nb-file="US20230005210A1-20230105-M00012.NB"><img id="EMI-M00012" he="6.01mm" wi="76.20mm" file="US20230005210A1-20230105-M00012.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00013" nb-file="US20230005210A1-20230105-M00013.NB"><img id="EMI-M00013" he="6.01mm" wi="76.20mm" file="US20230005210A1-20230105-M00013.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00014" nb-file="US20230005210A1-20230105-M00014.NB"><img id="EMI-M00014" he="9.48mm" wi="76.20mm" file="US20230005210A1-20230105-M00014.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00015" nb-file="US20230005210A1-20230105-M00015.NB"><img id="EMI-M00015" he="13.04mm" wi="76.20mm" file="US20230005210A1-20230105-M00015.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00016" nb-file="US20230005210A1-20230105-M00016.NB"><img id="EMI-M00016" he="6.35mm" wi="76.20mm" file="US20230005210A1-20230105-M00016.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00017" nb-file="US20230005210A1-20230105-M00017.NB"><img id="EMI-M00017" he="5.25mm" wi="76.20mm" file="US20230005210A1-20230105-M00017.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00018" nb-file="US20230005210A1-20230105-M00018.NB"><img id="EMI-M00018" he="6.01mm" wi="76.20mm" file="US20230005210A1-20230105-M00018.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00019" nb-file="US20230005210A1-20230105-M00019.NB"><img id="EMI-M00019" he="6.01mm" wi="76.20mm" file="US20230005210A1-20230105-M00019.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00020" nb-file="US20230005210A1-20230105-M00020.NB"><img id="EMI-M00020" he="5.25mm" wi="76.20mm" file="US20230005210A1-20230105-M00020.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00021" nb-file="US20230005210A1-20230105-M00021.NB"><img id="EMI-M00021" he="6.01mm" wi="76.20mm" file="US20230005210A1-20230105-M00021.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00022" nb-file="US20230005210A1-20230105-M00022.NB"><img id="EMI-M00022" he="6.01mm" wi="76.20mm" file="US20230005210A1-20230105-M00022.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00023" nb-file="US20230005210A1-20230105-M00023.NB"><img id="EMI-M00023" he="5.25mm" wi="76.20mm" file="US20230005210A1-20230105-M00023.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A computer-implemented method for computing a texture color, the method comprising:<claim-text>determining a surface spread angle at a first point where a ray cone intersects a first surface within a graphics scene based on one or more differential barycentric coordinates at the first point;</claim-text><claim-text>determining, based on the surface spread angle, a width of a reflected ray cone at a second point where the reflected ray cone intersects a second surface within the graphics scene; and</claim-text><claim-text>computing the texture color based on the width of the reflected ray cone.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The computer-implemented method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein computing the texture color comprises:<claim-text>determining a size of a filter based on the width of the reflected ray cone; and</claim-text><claim-text>performing one or more texture filtering operations based on the size of the filter.</claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The computer-implemented method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the one or more texture filtering operations include at least one mipmapping operation or anisotropic filtering operation.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The computer-implemented method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein computing the texture color comprises:<claim-text>determining a mipmap sampling level based on the width of the reflected ray cone; and</claim-text><claim-text>performing one or more mipmapping operations based on the mipmap sampling level.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The computer-implemented method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein determining the surface spread angle comprises:<claim-text>determining one or more differential normals associated with the first surface at the first point based on the one or more differential barycentric coordinates; and</claim-text><claim-text>determining the surface spread angle based on the one or more differential normals.</claim-text></claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The computer-implemented method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein determining the surface spread angle comprises:<claim-text>determining a first differential normal and a second differential normal based on the one or more differential barycentric coordinates;</claim-text><claim-text>determining a first surface spread angle associated with a first dimension based on the first differential normal;</claim-text><claim-text>determining a second surface spread angle associated with a second dimension based on the second differential normal; and</claim-text><claim-text>determining the surface spread angle based on the first surface spread angle and the second surface spread angle.</claim-text></claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The computer-implemented method of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein determining the surface spread angle comprises selecting one of the first surface spread angle or the second surface spread angle that has a larger absolute value.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The computer-implemented method of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein determining the surface spread angle comprises computing an average of the first surface spread angle and the second surface spread angle.</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The computer-implemented method of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein determining the surface spread angle comprises:<claim-text>selecting a larger of the first surface spread angle and the second surface spread angle if the first surface spread angle and the second surface spread angle are both positive angles;</claim-text><claim-text>selecting a smaller of the first surface spread angle and the second surface spread angle if the first surface spread angle and the second surface spread angle are both negative angles; or</claim-text><claim-text>computing a sum of the first surface spread angle and the second surface spread angle if only one of the first surface spread angle and the second surface spread angle is a positive angle.</claim-text></claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The computer-implemented method of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein determining the surface spread angle comprises:<claim-text>determining a product of a term and a sign of the first surface spread angle if an absolute value of the first surface spread angle is greater than an absolute value of the second surface spread angle; or</claim-text><claim-text>determining a product of the term and a sign of the second surface spread angle if the absolute value of the second surface spread angle is greater than the absolute value of the first surface spread angle,</claim-text><claim-text>wherein the term equals a product of two and a sum of a square root of the first surface spread angle squared and the second surface spread angle squared.</claim-text></claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. One or more non-transitory computer-readable storage media including instructions that, when executed by at least one processor, cause the at least one processor to perform steps for computing a texture color, the steps comprising:<claim-text>determining a surface spread angle at a first point where a ray cone intersects a first surface within a graphics scene based on one or more differential barycentric coordinates at the first point;</claim-text><claim-text>determining, based on the surface spread angle, a width of a reflected ray cone at a second point where the reflected ray cone intersects a second surface within the graphics scene; and</claim-text><claim-text>computing the texture color based on the width of the reflected ray cone.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The one or more non-transitory computer-readable storage media of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein computing the texture color comprises:<claim-text>determining a size of a filter based on the width of the reflected ray cone; and</claim-text><claim-text>performing one or more texture filtering operations based on the size of the filter.</claim-text></claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The one or more non-transitory computer-readable storage media of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein computing the texture color comprises:<claim-text>determining a level-of-detail parameter value based on the width of the reflected ray cone; and</claim-text><claim-text>performing one or more texture filtering operations based on the level-of-detail parameter value; and</claim-text><claim-text>computing the texture color based on results of the one or more texture filtering operations.</claim-text></claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The one or more non-transitory computer-readable storage media of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the level-of-detail parameter value indicates a mipmap sampling level.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The one or more non-transitory computer-readable storage media of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the at least one processor includes a graphics processing unit (GPU), and the texture color is computed via a texture unit included in the GPU.</claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The one or more non-transitory computer-readable storage media of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein determining the surface spread angle comprises:<claim-text>determining one or more differential normals associated with the first surface at the first point based on the one or more differential barycentric coordinates; and</claim-text><claim-text>determining the surface spread angle based on the one or more differential normals.</claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The one or more non-transitory computer-readable storage media of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein determining the surface spread angle comprises selecting one of a first surface spread angle associated with a first dimension or a second surface spread angle associated with a second dimension that has a larger absolute value.</claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The one or more non-transitory computer-readable storage media of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein determining the surface spread angle comprises computing an average of a first surface spread angle associated with a first dimension and a second surface spread angle associated with a second dimension.</claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The one or more non-transitory computer-readable storage media of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein determining the surface spread angle comprises:<claim-text>selecting a larger of a first surface spread angle associated with a first dimension and a second surface spread angle associated with a second dimension if the first surface spread angle and the second surface spread angle are both positive angles;</claim-text><claim-text>selecting a smaller of the first surface spread angle and the second surface spread angle if the first surface spread angle and the second surface spread angle are both negative angles; or</claim-text><claim-text>computing a sum of the first surface spread angle and the second surface spread angle if only one of the first surface spread angle and the second surface spread angle is a positive angle.</claim-text></claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. A system, comprising:<claim-text>one or more memories storing instructions; and</claim-text><claim-text>one or more processors that are coupled to the one or more memories and,<claim-text>when executing the instructions, are configured to:</claim-text><claim-text>determine a surface spread angle at a first point where a ray cone intersects a first surface within a graphics scene based on one or more differential barycentric coordinates at the first point,</claim-text><claim-text>determine, based on the surface spread angle, a width of a reflected ray cone at a second point where the reflected ray cone intersects a second surface within the graphics scene, and</claim-text></claim-text><claim-text>compute a texture color based on the width of the reflected ray cone.</claim-text></claim-text></claim></claims></us-patent-application>