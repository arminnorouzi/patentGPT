<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230007308A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230007308</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17894832</doc-number><date>20220824</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>70</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>136</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>176</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>172</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>174</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>70</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>136</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>176</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>172</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>174</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">DERIVATION OF THE HEIGHT OF A SUBPICTURE</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>PCT/US2021/019228</doc-number><date>20210223</date></document-id><parent-status>PENDING</parent-status></parent-doc><child-doc><document-id><country>US</country><doc-number>17894832</doc-number></document-id></child-doc></relation></continuation><us-provisional-application><document-id><country>US</country><doc-number>62980963</doc-number><date>20200224</date></document-id></us-provisional-application></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Bytedance Inc.</orgname><address><city>Los Angeles</city><state>CA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Wang</last-name><first-name>Ye-kui</first-name><address><city>San Diego</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Zhang</last-name><first-name>Li</first-name><address><city>San Diego</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>Zhang</last-name><first-name>Kai</first-name><address><city>San Diego</city><state>CA</state><country>US</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A method includes performing a conversion between a video including a video picture and a bitstream of the video according to a rule, wherein the video picture including a subpicture, a tile, and a slice, and wherein the rule specifies that, due to the subpicture including the slice that is partitioned from the tile, the conversion is performed by refraining from counting a height of the subpicture using a number of tiles of the video picture.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="61.21mm" wi="131.23mm" file="US20230007308A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="199.90mm" wi="108.03mm" orientation="landscape" file="US20230007308A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="212.43mm" wi="104.39mm" orientation="landscape" file="US20230007308A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="169.84mm" wi="128.78mm" orientation="landscape" file="US20230007308A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="122.34mm" wi="125.56mm" orientation="landscape" file="US20230007308A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="131.91mm" wi="120.65mm" orientation="landscape" file="US20230007308A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="193.97mm" wi="133.10mm" orientation="landscape" file="US20230007308A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="208.62mm" wi="151.89mm" orientation="landscape" file="US20230007308A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="227.41mm" wi="140.21mm" orientation="landscape" file="US20230007308A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="133.10mm" wi="151.05mm" orientation="landscape" file="US20230007308A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="133.27mm" wi="151.05mm" orientation="landscape" file="US20230007308A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="133.27mm" wi="151.05mm" orientation="landscape" file="US20230007308A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="133.27mm" wi="151.05mm" orientation="landscape" file="US20230007308A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="183.73mm" wi="151.05mm" orientation="landscape" file="US20230007308A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00014" num="00014"><img id="EMI-D00014" he="133.27mm" wi="151.05mm" orientation="landscape" file="US20230007308A1-20230105-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00015" num="00015"><img id="EMI-D00015" he="133.27mm" wi="151.05mm" orientation="landscape" file="US20230007308A1-20230105-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00016" num="00016"><img id="EMI-D00016" he="133.27mm" wi="151.05mm" orientation="landscape" file="US20230007308A1-20230105-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00017" num="00017"><img id="EMI-D00017" he="133.52mm" wi="151.05mm" orientation="landscape" file="US20230007308A1-20230105-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">CROSS REFERENCE TO RELATED APPLICATIONS</heading><p id="p-0002" num="0001">This application is a continuation of International Patent Application No. PCT/US2021/019228 filed on Feb. 23, 2021, which claims the priority to and benefits of U.S. Provisional Patent Application No. U.S. 62/980,963 filed on Feb. 24, 2020, all of which are hereby incorporated by reference in their entireties.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">TECHNICAL FIELD</heading><p id="p-0003" num="0002">This patent document relates to image and video coding and decoding.</p><heading id="h-0003" level="1">BACKGROUND</heading><p id="p-0004" num="0003">Digital video accounts for the largest bandwidth use on the internet and other digital communication networks. As the number of connected user devices capable of receiving and displaying video increases, it is expected that the bandwidth demand for digital video usage will continue to grow.</p><heading id="h-0004" level="1">SUMMARY</heading><p id="p-0005" num="0004">The present document discloses techniques that can be used by video encoders and decoders for processing coded representation of video using control information useful for decoding of the coded representation.</p><p id="p-0006" num="0005">In one example aspect, a video processing method is disclosed. The method includes performing a conversion between a video comprising one or more video pictures and a bitstream of the video, wherein each video picture comprises one or more tiles that include one or more tile columns, wherein the bitstream conforms to a format rule, and wherein the format rule specifies that a tile column index is derived for each coding tree unit (CTU) column of a tile of a video picture.</p><p id="p-0007" num="0006">In another example aspect, a video processing method is disclosed. The method includes performing a conversion between a video comprising one or more video pictures and a bitstream of the video, wherein each video picture comprises one or more tiles that include one or more tile rows, wherein the bitstream conforms to a format rule, and wherein the format rule specifies that a tile row index is derived for each coding tree unit (CTU) row of a tile of a video picture.</p><p id="p-0008" num="0007">In another example aspect, a video processing method is disclosed. The method includes performing a conversion between a video comprising at least one video picture and a bitstream of the video according to a rule, wherein the at least one video picture comprises one or more slices and one or more subpictures, and wherein the rule specifies that an order of slice indices of the one or more slices in the at least one video picture is indicated responsive to a syntax element associated with the at least one picture indicative of whether a single slice is included per subpicture of the at least one video picture.</p><p id="p-0009" num="0008">In another example aspect, a video processing method is disclosed. The method includes performing a conversion between a video unit of a video region of a video and a bitstream of a video, wherein the bitstream conforms to a format rule, wherein the format rule specifies that a first control information at a first level the video region in the bitstream controls whether a second control information is included at a second level of the video unit in the bitstream, wherein the second level is smaller than the first level, wherein the first control information and the second control information include information about whether or how a luma mapping and chroma scaling (LMCS) tool is applied to the video unit, and wherein the LMCS tool includes using a chroma residue scaling (CRS), or a luma reshaping process (RP) for the conversion.</p><p id="p-0010" num="0009">In another example aspect, a video processing method is disclosed. The method includes performing a conversion between a video and a bitstream of the video according to a rule, wherein the rule specifies that a luma mapping and chroma scaling (LMCS) tool is enabled when a first syntax element in a referred sequence parameter set indicates that the LMCS tool is enabled, wherein the rule specifies that the LMCS tool is not used when the first syntax element indicates that the LMCS tool is disabled, wherein the rule specifies that the LMCS tool is enabled for all slices associated with picture header of a video picture when a second syntax element in the bitstream indicates that the LMCS tool is enabled at the picture header level of the video, wherein the rule specifies that the LMCS tool is not used for all slices associated with the picture header when the second syntax element indicates that the LMCS tool is disabled at a picture header level of the video, wherein the rule specifies that the LMCS tool is used for a current slice associated with a slice header of a video picture when a third syntax element selectively included in the bitstream indicates that the LMCS tool is enabled at a slice header level of the video, and wherein the rule specifies that the LMCS tool is not used for the current slice when the third syntax element indicates that the LMCS tool is disabled at the slice header level of the video.</p><p id="p-0011" num="0010">In another example aspect, a video processing method is disclosed. The method includes performing a conversion between a video comprising one or more video pictures and a bitstream of a video according to a rule, wherein the rule specifies that whether an adaptive motion vector difference resolution (AMVR) is used in a motion vector coding of an affine inter mode based on a syntax element selectively included in a referred sequence parameter set (SPS) that indicates whether the AMVR is enabled, wherein the rule specifies that the AMVR is not used in the motion vector coding of the affine inter mode when the syntax element indicates that the AMVR is disabled, and wherein the rule specifies that the AMVR is inferred not to be used in the motion vector coding of the affine inter mode when the syntax element when the syntax element is not included in the SPS.</p><p id="p-0012" num="0011">In another example aspect, a video processing method is disclosed. The method includes performing a conversion between a video comprising a video picture and a bitstream of the video according to a rule, wherein the video picture comprising a subpicture, a tile, and a slice, and wherein the rule specifies that, due to the subpicture comprising the slice that is partitioned from the tile, the conversion is performed by refraining from counting a height of the subpicture using a number of tiles of the video picture.</p><p id="p-0013" num="0012">In another example aspect, a video processing method is disclosed. The method includes performing a conversion between a video comprising a video picture and a bitstream of the video, wherein the bitstream indicates a height of a subpicture of the video picture that is counted based on a number of coding tree units (CTUs) of the video picture.</p><p id="p-0014" num="0013">In another example aspect, a video processing method is disclosed. The method includes making a determination, according to a rule, about whether a height of a subpicture of a video picture of a video is less than a height of a tile row of the video picture; and performing, using the determination, a conversion between the video and a bitstream of the video.</p><p id="p-0015" num="0014">In another example aspect, a video processing method is disclosed. The method includes performing a conversion between a video comprising one or more video pictures, wherein each video picture comprises one or more tiles and a coded representation of a video, wherein the coded representation conforms to a format rule; wherein the format rule specifies first information that is signalled in the coded representation and second information that is derived from the coded representation, wherein at least the first information or the second information relates to row indexes or column indexes of the one or more tiles.</p><p id="p-0016" num="0015">In another example aspect, a video processing method is disclosed. The method includes performing a conversion between a video unit of a video region of a video and a coded representation of a video, wherein the coded representation conforms to a format rule; wherein the format rule specifies that a first control information at the video region controls whether a second control information is included at the video unit level; wherein the first control information and/or the second control information includes information about luma mapping and chroma scaling (LMCS) or chroma residue scaling (CRS) or a reshaping process (RP) used for the conversion.</p><p id="p-0017" num="0016">In yet another example aspect, a video encoder apparatus is disclosed. The video encoder comprises a processor configured to implement the above-described methods.</p><p id="p-0018" num="0017">In yet another example aspect, a video decoder apparatus is disclosed. The video decoder comprises a processor configured to implement the above-described methods.</p><p id="p-0019" num="0018">In yet another example aspect, a computer readable medium having code stored thereon is disclosed. The code embodies one of the methods described herein in the form of processor-executable code.</p><p id="p-0020" num="0019">These, and other features are described throughout the present document.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0005" level="1">BRIEF DESCRIPTION OF DRAWINGS</heading><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. <b>1</b></figref> shows an example of raster scan slice partitioning of a picture, where the picture is divided into 12 tiles and 3 raster scan slices.</p><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. <b>2</b></figref> shows an example of rectangular slice partitioning of a picture, where the picture is divided into 24 tiles (6 tile columns and 4 tile rows) and 9 rectangular slices.</p><p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. <b>3</b></figref> shows an example of a picture partitioned into tiles and rectangular slices, where the picture is divided into 4 tiles (2 tile columns and 2 tile rows) and 4 rectangular slices.</p><p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. <b>4</b></figref> shows a picture that is partitioned into 15 tiles, 24 slices and 24 subpictures.</p><p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a block diagram of an example video processing system.</p><p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a block diagram of a video processing apparatus.</p><p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a flowchart for an example method of video processing.</p><p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a block diagram that illustrates a video coding system according to various embodiments of the present disclosure.</p><p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a block diagram that illustrates an encoder according to various embodiments of the present disclosure.</p><p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a block diagram that illustrates a decoder according to various embodiments of the present disclosure.</p><p id="p-0031" num="0030"><figref idref="DRAWINGS">FIGS. <b>11</b> to <b>19</b></figref> are flowcharts for example methods of video processing.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0006" level="1">DETAILED DESCRIPTION</heading><p id="p-0032" num="0031">Section headings are used in the present document for ease of understanding and do not limit the applicability of techniques and embodiments disclosed in each section only to that section. Furthermore, H.266 terminology is used in some description only for ease of understanding and not for limiting scope of the disclosed techniques. As such, the techniques described herein are applicable to other video codec protocols and designs also. In the present document, editing changes are shown to text by open and close double brackets (e.g., [[ ]]) indicating cancelled text in between the double brackets, and boldface italic text indicating added text, with respect to the current draft of the VVC specification.</p><heading id="h-0007" level="1">1. Summary</heading><p id="p-0033" num="0032">This document is related to video coding technologies. Specifically, it is about support of subpictures, LMCS, and AMVR. The aspects on subpictures include the derivation of the number of tile rows and columns included in one subpicture as well as the derivation of the list of raster scan CTU addresses for CTUs included in a slice when each subpicture contains only one slice. The aspects on LMCS are about signalling of enabling of LMCS on different levels. The aspects on AMVR are about the semantics of sps_affine_ammr_enabled_flag. The ideas may be applied individually or in various combination, to any video coding standard or non-standard video codec that supports single-layer and/or multi-layer video coding, e.g., the being-developed Versatile Video Coding (VVC).</p><heading id="h-0008" level="1">2. Abbreviations</heading><p id="p-0034" num="0000"><ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0033">ALF Adaptive Loop Filter</li>        <li id="ul0002-0002" num="0034">AMVR Adaptive Motion Vector difference Resolution</li>        <li id="ul0002-0003" num="0035">APS Adaptation Parameter Set</li>        <li id="ul0002-0004" num="0036">AU Access Unit</li>        <li id="ul0002-0005" num="0037">AUD Access Unit Delimiter</li>        <li id="ul0002-0006" num="0038">AVC Advanced Video Coding</li>        <li id="ul0002-0007" num="0039">CLVS Coded Layer Video Sequence</li>        <li id="ul0002-0008" num="0040">CPB Coded Picture Buffer</li>        <li id="ul0002-0009" num="0041">CRA Clean Random Access</li>        <li id="ul0002-0010" num="0042">CTU Coding Tree Unit</li>        <li id="ul0002-0011" num="0043">CVS Coded Video Sequence</li>        <li id="ul0002-0012" num="0044">DPB Decoded Picture Buffer</li>        <li id="ul0002-0013" num="0045">DPS Decoding Parameter Set</li>        <li id="ul0002-0014" num="0046">EOB End Of Bitstream</li>        <li id="ul0002-0015" num="0047">EOS End Of Sequence</li>        <li id="ul0002-0016" num="0048">GDR Gradual Decoding Refresh</li>        <li id="ul0002-0017" num="0049">HEVC High Efficiency Video Coding</li>        <li id="ul0002-0018" num="0050">HRD Hypothetical Reference Decoder</li>        <li id="ul0002-0019" num="0051">IDR Instantaneous Decoding Refresh</li>        <li id="ul0002-0020" num="0052">JEM Joint Exploration Model</li>        <li id="ul0002-0021" num="0053">LMCS Luma Mapping with Chroma Scaling</li>        <li id="ul0002-0022" num="0054">MCTS Motion-Constrained Tile Sets</li>        <li id="ul0002-0023" num="0055">NAL Network Abstraction Layer</li>        <li id="ul0002-0024" num="0056">OLS Output Layer Set</li>        <li id="ul0002-0025" num="0057">PH Picture Header</li>        <li id="ul0002-0026" num="0058">PPS Picture Parameter Set</li>        <li id="ul0002-0027" num="0059">PTL Profile, Tier and Level</li>        <li id="ul0002-0028" num="0060">PU Picture Unit</li>        <li id="ul0002-0029" num="0061">RBSP Raw Byte Sequence Payload</li>        <li id="ul0002-0030" num="0062">SEI Supplemental Enhancement Information</li>        <li id="ul0002-0031" num="0063">SPS Sequence Parameter Set</li>        <li id="ul0002-0032" num="0064">SVC Scalable Video Coding</li>        <li id="ul0002-0033" num="0065">VCL Video Coding Layer</li>        <li id="ul0002-0034" num="0066">VPS Video Parameter Set</li>        <li id="ul0002-0035" num="0067">VTM VVC Test Model</li>        <li id="ul0002-0036" num="0068">VUI Video Usability Information</li>        <li id="ul0002-0037" num="0069">VVC Versatile Video Coding</li>    </ul>    </li></ul></p><heading id="h-0009" level="1">3. Initial Discussion</heading><p id="p-0035" num="0070">Video coding standards have evolved primarily through the development of the well-known International Telecommunication Union (ITU) Telecommunication Standardization Sector (ITU-T) and International Organization for Standardization (ISO)/International Electrotechnical Commission (IEC) standards. The ITU-T produced H.261 and H.263, ISO/IEC produced Moving Picture Experts Group (MPEG)-1 and MPEG-4 Visual, and the two organizations jointly produced the H.262/MPEG-2 Video and H.264/MPEG-4 Advanced Video Coding (AVC) and H.265/High Efficiency Video Coding (HEVC)standards. Since H.262, the video coding standards are based on the hybrid video coding structure wherein temporal prediction plus transform coding are utilized. To explore the future video coding technologies beyond HEVC, the Joint Video Exploration Team (WET) was founded by Video Coding Experts Group (VCEG) and MPEG jointly in 2015. Since then, many new methods have been adopted by JVET and put into the reference software named Joint Exploration Model (JEM). The JVET meeting is concurrently held once every quarter, and the new coding standard is targeting at 50% bitrate reduction as compared to HEVC. The new video coding standard was officially named as Versatile Video Coding (VVC) in the April 2018 JVET meeting, and the first version of VVC test model (VTM) was released at that time. As there are continuous effort contributing to VVC standardization, new coding techniques are being adopted to the VVC standard in every JVET meeting. The VVC working draft and test model VTM are then updated after every meeting. The VVC project is now aiming for technical completion (FDIS) at the July 2020 meeting.</p><heading id="h-0010" level="1">3.1. Picture Partitioning Schemes in HEVC</heading><p id="p-0036" num="0071">HEVC includes four different picture partitioning schemes, namely regular slices, dependent slices, tiles, and Wavefront Parallel Processing (WPP), which may be applied for Maximum Transfer Unit (MTU) size matching, parallel processing, and reduced end-to-end delay.</p><p id="p-0037" num="0072">Regular slices are similar as in H.264/AVC. Each regular slice is encapsulated in its own NAL unit, and in-picture prediction (intra sample prediction, motion information prediction, coding mode prediction) and entropy coding dependency across slice boundaries are disabled. Thus a regular slice can be reconstructed independently from other regular slices within the same picture (though there may still have interdependencies due to loop filtering operations).</p><p id="p-0038" num="0073">The regular slice is the only tool that can be used for parallelization that is also available, in virtually identical form, in H.264/AVC. Regular slices based parallelization does not require much inter-processor or inter-core communication (except for inter-processor or inter-core data sharing for motion compensation when decoding a predictively coded picture, which is typically much heavier than inter-processor or inter-core data sharing due to in-picture prediction). However, for the same reason, the use of regular slices can incur substantial coding overhead due to the bit cost of the slice header and due to the lack of prediction across the slice boundaries. Further, regular slices (in contrast to the other tools mentioned below) also serve as the key mechanism for bitstream partitioning to match MTU size requirements, due to the in-picture independence of regular slices and that each regular slice is encapsulated in its own NAL unit. In many cases, the goal of parallelization and the goal of MTU size matching place contradicting demands to the slice layout in a picture. The realization of this situation led to the development of the parallelization tools mentioned below.</p><p id="p-0039" num="0074">Dependent slices have short slice headers and allow partitioning of the bitstream at treeblock boundaries without breaking any in-picture prediction. Basically, dependent slices provide fragmentation of regular slices into multiple NAL units, to provide reduced end-to-end delay by allowing a part of a regular slice to be sent out before the encoding of the entire regular slice is finished.</p><p id="p-0040" num="0075">In WPP, the picture is partitioned into single rows of coding tree blocks (CTBs). Entropy decoding and prediction are allowed to use data from CTBs in other partitions. Parallel processing is possible through parallel decoding of CTB rows, where the start of the decoding of a CTB row is delayed by two CTBs, so to ensure that data related to a CTB above and to the right of the subject CTB is available before the subject CTB is being decoded. Using this staggered start (which appears like a wavefront when represented graphically), parallelization is possible with up to as many processors/cores as the picture contains CTB rows. Because in-picture prediction between neighboring treeblock rows within a picture is permitted, the required inter-processor/inter-core communication to enable in-picture prediction can be substantial. The WPP partitioning does not result in the production of additional NAL units compared to when it is not applied, thus WPP is not a tool for MTU size matching. However, if MTU size matching is required, regular slices can be used with WPP, with certain coding overhead.</p><p id="p-0041" num="0076">Tiles define horizontal and vertical boundaries that partition a picture into tile columns and rows. Tile column runs from the top of a picture to the bottom of the picture. Likewise, tile row runs from the left of the picture to the right of the picture. The number of tiles in a picture can be derived simply as number of tile columns multiply by number of tile rows.</p><p id="p-0042" num="0077">The scan order of CTBs is changed to be local within a tile (in the order of a CTB raster scan of a tile), before decoding the top-left CTB of the next tile in the order of tile raster scan of a picture. Similar to regular slices, tiles break in-picture prediction dependencies as well as entropy decoding dependencies. However, they do not need to be included into individual NAL units (same as WPP in this regard); hence tiles may not be used for MTU size matching. Each tile can be processed by one processor/core, and the inter-processor/inter-core communication required for in-picture prediction between processing units decoding neighboring tiles is limited to conveying the shared slice header in cases where a slice is spanning more than one tile, and loop filtering related sharing of reconstructed samples and metadata. When more than one tile or WPP segment is included in a slice, the entry point byte offset for each tile or WPP segment other than the first one in the slice is signalled in the slice header.</p><p id="p-0043" num="0078">For simplicity, restrictions on the application of the four different picture partitioning schemes have been specified in HEVC. A given coded video sequence may not include both tiles and wavefronts for most of the profiles specified in HEVC. For each slice and tile, either or both of the following conditions may be fulfilled: 1) all coded treeblocks in a slice belong to the same tile; 2) all coded treeblocks in a tile belong to the same slice. Finally, a wavefront segment contains exactly one CTB row, and when WPP is in use, if a slice starts within a CTB row, it may end in the same CTB row.</p><p id="p-0044" num="0079">A recent amendment to HEVC is specified in the JCT-VC output document JCTVC-AC1005, J. Boyce, A. Ramasubramonian, R. Skupin, G. J. Sullivan, A. Tourapis, Y.-K. Wang (editors), &#x201c;HEVC Additional Supplemental Enhancement Information (Draft 4),&#x201d; Oct. 24, 2017, publicly available herein: http://phenix.int-evry.fr/jct/doc_end_user/documents/29_Macau/wg11/JCTVC-AC1005-v2. zip. With this amendment included, HEVC specifies three MCTS-related SEI messages, namely temporal MCTSs SEI message, MCTSs extraction information set SEI message, and MCTSs extraction information nesting SEI message.</p><p id="p-0045" num="0080">The temporal MCTSs SEI message indicates existence of MCTSs in the bitstream and signals the MCTSs. For each MCTS, motion vectors are restricted to point to full-sample locations inside the MCTS and to fractional-sample locations that require only full-sample locations inside the MCTS for interpolation, and the usage of motion vector candidates for temporal motion vector prediction derived from blocks outside the MCTS is disallowed. This way, each MCTS may be independently decoded without the existence of tiles not included in the MCTS.</p><p id="p-0046" num="0081">The MCTSs extraction information sets SEI message provides supplemental information that can be used in the MCTS sub-bitstream extraction (specified as part of the semantics of the SEI message) to generate a conforming bitstream for a MCTS set. The information consists of a number of extraction information sets, each defining a number of MCTS sets and containing RBSP bytes of the replacement VPSs, SPSs, and PPSs to be used during the MCTS sub-bitstream extraction process. When extracting a sub-bitstream according to the MCTS sub-bitstream extraction process, parameter sets (VPSs, SPSs, and PPSs) need to be rewritten or replaced, slice headers need to be slightly updated because one or all of the slice address related syntax elements (including first_slice_segment_in_pic_flag and slice_segment_address) typically would need to have different values.</p><heading id="h-0011" level="1">3.2. Partitioning of Pictures in VVC</heading><p id="p-0047" num="0082">In VVC, A picture is divided into one or more tile rows and one or more tile columns. A tile is a sequence of CTUs that covers a rectangular region of a picture. The CTUs in a tile are scanned in raster scan order within that tile.</p><p id="p-0048" num="0083">A slice consists of an integer number of complete tiles or an integer number of consecutive complete CTU rows within a tile of a picture.</p><p id="p-0049" num="0084">Two modes of slices are supported, namely the raster scan slice mode and the rectangular slice mode. In the raster scan slice mode, a slice contains a sequence of complete tiles in a tile raster scan of a picture. In the rectangular slice mode, a slice contains either a number of complete tiles that collectively form a rectangular region of the picture or a number of consecutive complete CTU rows of one tile that collectively form a rectangular region of the picture. Tiles within a rectangular slice are scanned in tile raster scan order within the rectangular region corresponding to that slice.</p><p id="p-0050" num="0085">A subpicture contains one or more slices that collectively cover a rectangular region of a picture.</p><p id="p-0051" num="0086"><figref idref="DRAWINGS">FIG. <b>1</b></figref> shows an example of raster scan slice partitioning of a picture, where the picture is divided into 12 tiles and 3 raster scan slices.</p><p id="p-0052" num="0087"><figref idref="DRAWINGS">FIG. <b>2</b></figref> shows an example of rectangular slice partitioning of a picture, where the picture is divided into 24 tiles (6 tile columns and 4 tile rows) and 9 rectangular slices.</p><p id="p-0053" num="0088"><figref idref="DRAWINGS">FIG. <b>3</b></figref> shows an example of a picture partitioned into tiles and rectangular slices, where the picture is divided into 4 tiles (2 tile columns and 2 tile rows) and 4 rectangular slices.</p><p id="p-0054" num="0089"><figref idref="DRAWINGS">FIG. <b>4</b></figref> shows an example of subpicture partitioning of a picture, where a picture is partitioned into 18 tiles, 12 on the left-hand side each covering one slice of 4 by 4 CTUs and 6 tiles on the right-hand side each covering 2 vertically-stacked slices of 2 by 2 CTUs, altogether resulting in 24 slices and 24 subpictures of varying dimensions (each slice is a subpicture).</p><heading id="h-0012" level="1">3.3. Signalling of SPS/PPS/Picture Header/Slice Header in VVC (as JVET-Q2001-vC)</heading><heading id="h-0013" level="2">7.3.2.3 Sequence Parameter Set RBSP Syntax</heading><p id="p-0055" num="0090"></p><p id="p-0056" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="231pt" align="left"/><colspec colname="2" colwidth="35pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>seq_parameter_set_rbsp( ) {</entry><entry/></row><row><entry>&#x2003;sps_seq_parameter_set_id</entry><entry>u(4)</entry></row><row><entry>&#x2003;sps_video_parameter_set_id</entry><entry>u(4)</entry></row><row><entry>&#x2003;sps_max_sublayers_minus1</entry><entry>u(3)</entry></row><row><entry>&#x2003;sps_reserved_zero_4bits</entry><entry>u(4)</entry></row><row><entry>&#x2003;sps_ptl_dpb_hrd_params_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_ptl_dpb_hrd_params_present_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;profile_tier_level( 1, sps_max_sublayers_minus1 )</entry><entry/></row><row><entry>&#x2003;gdr_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;chroma_format_idc</entry><entry>u(2)</entry></row><row><entry>&#x2003;if( chroma_format_idc = = 3 )</entry><entry/></row><row><entry>&#x2003;&#x2003;separate_colour_plane_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;res_change_in_clvs_allowed_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;pic_width_max_in_luma_samples</entry><entry>ue(v)</entry></row><row><entry>&#x2003;pic_height_max_in_luma_samples</entry><entry>ue(v)</entry></row><row><entry>&#x2003;sps_conformance_window_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_conformance_window_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_conf_win_left_offset</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;sps_conf_win_right_offset</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;sps_conf_win_top_offset</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;sps_conf_win_bottom_offset</entry><entry>ue(v)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;sps_log2_ctu_size_minus5</entry><entry>u(2)</entry></row><row><entry>&#x2003;subpic_info_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( subpic_info_present_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_num_subpics_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;sps_independent_subpics_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;for( &#x2003;i&#x2003;=&#x2003;0;&#x2003;sps_num_subpics_minus1&#x2003;&#x3e;&#x2003;0&#x2003;&#x26;&#x26;&#x2003;i&#x2003;&#x3c;=</entry><entry/></row><row><entry>sps_num_subpics_minus1; i++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( i &#x3e; 0 &#x26;&#x26; pic_width_max_in_luma_samples &#x3e; CtbSizeY )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;subpic_ctu_top_left_x[ i ]</entry><entry>u(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( i &#x3e; 0 &#x26;&#x26; pic_height_max_in_luma_samples &#x3e; CtbSizeY ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;subpic_ctu_top_left_y[ i ]</entry><entry>u(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( &#x2003;&#x2003;i&#x2003;&#x2003;&#x3c;&#x2003;&#x2003;sps_num_subpics_minus1&#x2003;&#x2003;&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;pic_width_max_in_luma_samples &#x3e; CtbSizeY )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;subpic_width_minus1[ i ]</entry><entry>u(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( &#x2003;&#x2003;i&#x2003;&#x2003;&#x3c;&#x2003;&#x2003;sps_num_subpics_minus1&#x2003;&#x2003;&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;pic_height_max_in_luma_samples &#x3e; CtbSizeY )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;subpic_height_minus1[ i ]</entry><entry>u(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( !sps_independent_subpics_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;subpic_treated_as_pic_flag[ i ]</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;loop_filter_across_subpic_enabled_flag[ i ]</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_subpic_id_len_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;subpic_id_mapping_explicitly_signalled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( subpic_id_mapping_explicitly_signalled_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;subpic_id_mapping_in_sps_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( subpic_id_mapping_in_sps_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;for( i = 0; i &#x3c;= sps_num_subpics_minus1; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;sps_subpic_id[ i ]</entry><entry>u(v)</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;bit_depth_minus8</entry><entry>ue(v)</entry></row><row><entry>&#x2003;sps_entropy_coding_sync_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_entropy_coding_sync_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_wpp_entry_point_offsets_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_weighted_pred_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_weighted_bipred_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;log2_max_pic_order_cnt_lsb_minus4</entry><entry>u(4)</entry></row><row><entry>&#x2003;sps_poc_msb_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_poc_msb_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;poc_msb_len_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;num_extra_ph_bits_bytes</entry><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;extra_ph_bits_struct( num_extra_ph_bits_bytes )</entry><entry/></row><row><entry>&#x2003;num_extra_sh_bits_bytes</entry><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;extra_sh_bits_struct( num_extra_sh_bits_bytes )</entry><entry/></row><row><entry>&#x2003;if( sps_max_sublayers_minus1 &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_sublayer_dpb_params_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_ptl_dpb_hrd_params_present_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;dpb_parameters( sps_max_sublayers_minus1,</entry><entry/></row><row><entry>sps_sublayer_dpb_params_flag )</entry><entry/></row><row><entry>&#x2003;long_term_ref_pics_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;inter_layer_ref_pics_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_idr_rpl_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;rpl1_same_as_rpl0_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c; !rpl1_same_as_rpl0_flag ? 2 : 1; i++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;num_ref_pic_lists_in_sps[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;for(j = 0; j &#x3c; num_ref_pic_lists_in_sps[ i ]; j++)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ref_pic_list_struct( i, j )</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( ChromaArrayType != 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;qtbtt_dual_tree_intra_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;log2_min_luma_coding_block_size_minus2</entry><entry>ue(v)</entry></row><row><entry>&#x2003;partition_constraints_override_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_log2_diff_min_qt_min_cb_intra_slice_luma</entry><entry>ue(v)</entry></row><row><entry>&#x2003;sps_max_mtt_hierarchy_depth_intra_slice_luma</entry><entry>ue(v)</entry></row><row><entry>&#x2003;if( sps_max_mtt_hierarchy_depth_intra_slice_luma != 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_log2_diff_max_bt_min_qt_intra_slice_luma</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;sps_log2_diff_max_tt_min_qt_intra_slice_luma</entry><entry>ue(v)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;sps_log2_diff_min_qt_min_cb_inter_slice</entry><entry>ue(v)</entry></row><row><entry>&#x2003;sps_max_mtt_hierarchy_depth_inter_slice</entry><entry>ue(v)</entry></row><row><entry>&#x2003;if( sps_max_mtt_hierarchy_depth_inter_slice != 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_log2_diff_max_bt_min_qt_inter_slice</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;sps_log2_diff_max_tt_min_qt_inter_slice</entry><entry>ue(v)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( qtbtt_dual_tree_intra_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_log2_diff_min_qt_min_cb_intra_slice_chroma</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;sps_max_mtt_hierarchy_depth_intra_slice_chroma</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;if( sps_max_mtt_hierarchy_depth_intra_slice_chroma != 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;sps_log2_diff_max_bt_min_qt_intra_slice_chroma</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;sps_log2_diff_max_tt_min_qt_intra_slice_chroma</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;sps_max_luma_transform_size_64_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( ChromaArrayType != 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_joint_cbcr_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;same_qp_table_for_chroma</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;numQpTables&#x2003;=&#x2003;same_qp_table_for_chroma&#x2003;?&#x2003;1&#x2003;:&#x2003;( </entry><entry/></row><row><entry>sps_joint_cbcr_enabled_flag ? 3 : 2 )</entry><entry/></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c; numQpTables; i++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;qp_table_start_minus26[ i ]</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;num_points_in_qp_table_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c;= num_points_in_qp_table_minus1[ i ]; j++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;delta_qp_in_val_minus1[ i ][ j ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;delta_qp_diff_val[ i ][ j ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;sps_sao_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_alf_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_alf_enabled_flag &#x26;&#x26; ChromaArrayType != 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_ccalf_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_transform_skip_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_transform_skip_enabled_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;log2_transform_skip_max_size_minus2</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;sps_bdpcm_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;sps_ref_wraparound_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_temporal_mvp_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_temporal_mvp_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_sbtmvp_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_amvr_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_bdof_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_bdof_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_bdof_pic_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_smvd_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_dmvr_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_dmvr_enabled_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_dmvr_pic_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_mmvd_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_isp_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_mrl_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_mip_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( ChromaArrayType != 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_cclm_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( chroma_format_idc = = 1 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_chroma_horizontal_collocated_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;sps_chroma_vertical_collocated_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;sps_mts_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_mts_enabled_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_explicit_mts_intra_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;sps_explicit_mts_inter_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;six_minus_max_num_merge_cand</entry><entry>ue(v)</entry></row><row><entry>&#x2003;sps_sbt_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_affine_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_affine_enabled_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;five_minus_max_num_subblock_merge_cand</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;sps_affine_type_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( sps_amvr_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;sps_affine_amvr_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;sps_affine_prof_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( sps_affine_prof_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;sps_prof_pic_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;sps_palette_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( ChromaArrayType = = 3 &#x26;&#x26; ! sps_max_luma_trans-</entry><entry/></row><row><entry>form_size_64_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_act_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_transform_skip_enabled_flag | | sps_palette_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;min_qp_prime_ts_minus4</entry><entry>ue(v)</entry></row><row><entry>&#x2003;sps_bcw_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_ibc_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_ibc_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;six_minus_max_num_ibc_merge_cand</entry><entry>ue(v)</entry></row><row><entry>&#x2003;sps_ciip_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_mmvd_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_fpel_mmvd_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( MaxNumMergeCand &#x3e;= 2 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_gpm_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( sps_gpm_enabled_flag &#x26;&#x26; MaxNumMergeCand &#x3e;= 3 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;max_num_merge_cand_minus_max_num_gpm_cand</entry><entry>ue(v)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;sps_lmcs_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_lfnst_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_ladf_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_ladf_enabled_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_num_ladf_intervals_minus2</entry><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;sps_ladf_lowest_interval_qp_offset</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c; sps_num_ladf_intervals_minus2 + 1; i++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;sps_ladf_qp_offset[ i ]</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;sps_ladf_delta_threshold_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;log2_parallel_merge_level_minus2</entry><entry>ue(v)</entry></row><row><entry>&#x2003;sps_scaling_list_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_dep_quant_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( !sps_dep_quant_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_sign_data_hiding_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_virtual_boundaries_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_virtual_boundaries_enabled_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_virtual_boundaries_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( sps_virtual_boundaries_present_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;sps_num_ver_virtual_boundaries</entry><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( i = 0; i &#x3c; sps_num_ver_virtual_boundaries; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;sps_virtual_boundaries_pos_x[ i ]</entry><entry>u(13)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;sps_num_hor_virtual_boundaries</entry><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( i = 0; i &#x3c; sps_num_hor_virtual_boundaries; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;sps_virtual_boundaries_pos_y[ i ]</entry><entry>u(13)</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( sps_ptl_dpb_hrd_params_present_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;sps_general_hrd_params_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( sps_general_hrd_params_present_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;general_hrd_parameters( )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( sps_max_sublayers_minus1 &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;sps_sublayer_cpb_params_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;firstSubLayer&#x2003;=&#x2003;sps_sublayer_cpb_params_present_flag&#x2003;?&#x2003;0&#x2003;:</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;sps_max_sublayers_minus1</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ols_hrd_parameters( firstSubLayer, sps_max_sublayers_minus1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;field_seq_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;vui_parameters_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( vui_parameters_present_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;vui_parameters( ) /* Specified in ITU-T H.SEI | ISO/IEC 23002-7 */</entry><entry/></row><row><entry>&#x2003;sps_extension_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_extension_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;while( more_rbsp_data( ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;sps_extension_data_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;rbsp_trailing_bits( )</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0014" level="2">7.3.2.4 Picture Parameter Set RBSP Syntax</heading><p id="p-0057" num="0091"></p><p id="p-0058" num="0000"><tables id="TABLE-US-00002" num="00002"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="238pt" align="left"/><colspec colname="2" colwidth="35pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>pic_parameter_set_rbsp( ) {</entry><entry/></row><row><entry>&#x2003;pps_pic_parameter_set_id</entry><entry>ue(v)</entry></row><row><entry>&#x2003;pps_seq_parameter_set_id</entry><entry>u(4)</entry></row><row><entry>&#x2003;mixed_nalu_types_in_pic_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;pic_width_in_luma_samples</entry><entry>ue(v)</entry></row><row><entry>&#x2003;pic_height_in_luma_samples</entry><entry>ue(v)</entry></row><row><entry>&#x2003;pps_conformance_window_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( pps_conformance_window_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;pps_conf_win_left_offset</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;pps_conf_win_right_offset</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;pps_conf_win_top_offset</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;pps_conf_win_bottom_offset</entry><entry>ue(v)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;scaling_window_explicit_signalling_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( scaling_window_explicit_signalling_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;scaling_win_left_offset</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;scaling_win_right_offset</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;scaling_win_top_offset</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;scaling_win_bottom_offset</entry><entry>ue(v)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;output_flag_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;subpic_id_mapping_in_pps_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( subpic_id_mapping_in_pps_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;pps_num_subpics_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;pps_subpic_id_len_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c;= pps_num_subpic_minus1; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;pps_subpic_id[ i ]</entry><entry>u(v)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;no_pic_partition_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( !no_pic_partition_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;pps_log2_ctu_size_minus5</entry><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;num_exp_tile_columns_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;num_exp_tile_rows_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c;= num_exp_tile_columns_minus1; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;tile_column_width_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c;= num_exp_tile_rows_minus1; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;tile_row_height_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;if( NumTilesInPic &#x3e; 1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;rect_slice_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( rect_slice_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;single_slice_per_subpic_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( rect_slice_flag &#x26;&#x26; !single_slice_per_subpic_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;num_slices_in_pic_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( num_slices_in_pic_minus1 &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;tile_idx_delta_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( i = 0; i &#x3c; num_slices_in_pic_minus1; i++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( NumTileColumns &#x3e; 1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;slice_width_in_tiles_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if(&#x2003;&#x2003;NumTileRows&#x2003;&#x2003;&#x3e;&#x2003;&#x2003;1&#x2003;&#x2003;&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;( tile_idx_delta_present_flag&#x2003;| |&#x2003;tileIdx % NumTileColumns</entry><entry/></row><row><entry>= = 0 ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if(&#x2003;slice_width_in_tiles_minus1[ i ]&#x2003;&#x2003;= =&#x2003;&#x2003;0&#x2003;&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ]&#x2003;&#x2003;= =&#x2003;&#x2003;0&#x2003;&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;RowHeight[ SliceTopLeftTileIdx[ i ] / NumTileColumns ] &#x3e; 1 )</entry><entry/></row><row><entry>{</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;num_exp_slices_in_tile[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;numExpSlicesInTile = num_exp_slices_in_tile[ i ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;for(j = 0; j &#x3c; numExpSlicesInTile; j++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;exp_slice_height_in_ctus_minus1[ j ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;i += NumSlicesInTile[ i ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( tile_idx_delta_present_flag &#x26;&#x26; i &#x3c; num_slices_in_pic_minus1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;tile_idx_delta[ i ]</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;loop_filter_across_tiles_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;loop_filter_across_slices_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;cabac_init_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c; 2; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;num_ref_idx_default_active_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;rpl1_idx_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;init_qp_minus26</entry><entry>se(v)</entry></row><row><entry>&#x2003;cu_qp_delta_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;pps_chroma_tool_offsets_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( pps_chroma_tool_offsets_present_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;pps_cb_qp_offset</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;pps_cr_qp_offset</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;pps_joint_cbcr_qp_offset_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( ppsjoint_cbcr_qp_offset_present_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;pps_joint_cbcr_qp_offset_value</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;pps_slice_chroma_qp_offsets_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;pps_cu_chroma_qp_offset_list_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( pps_cu_chroma_qp_offset_list_enabled_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;chroma_qp_offset_list_len_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c;= chroma_qp_offset_list_len_minus1; i++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;cb_qp_offset_list[ i ]</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;cr_qp_offset_list[ i ]</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( pps_joint_cbcr_qp_offset_present_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;joint_cbcr_qp_offset_list[ i ]</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;pps_weighted_pred_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;pps_weighted_bipred_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;deblocking_filter_control_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( deblocking_filter_control_present_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;deblocking_filter_override_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;pps_deblocking_filter_disabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( !pps_deblocking_filter_disabled_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;pps_beta_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;pps_tc_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;pps_cb_beta_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;pps_cb_tc_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;pps_cr_beta_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;pps_cr_tc_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;rpl_info_in_ph_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( deblocking_filter_override_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;dbf_info_in_ph_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sao_info_in_ph_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;alf_info_in_ph_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( ( pps_weighted_pred_flag&#x2003;| |&#x2003;pps_weighted_bipred_flag )&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry>rpl_present_in_ph_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;wp_info_in_ph_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;qp_delta_info_in_ph_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;pps_ref_wraparound_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( pps_ref_wraparound_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;pps_ref_wraparound_offset</entry><entry>ue(v)</entry></row><row><entry>&#x2003;picture_header_extension_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;slice_header_extension_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;pps_extension_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( pps_extension_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;while( more_rbsp_data( ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;pps_extension_data_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;rbsp_trailing_bits( )</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0015" level="2">7.3.2.7 Picture Header Structure Syntax</heading><p id="p-0059" num="0092"></p><p id="p-0060" num="0000"><tables id="TABLE-US-00003" num="00003"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="224pt" align="left"/><colspec colname="2" colwidth="42pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>picture_header_structure( ) {</entry><entry/></row><row><entry>&#x2003;gdr_or_irap_pic_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( gdr_or_irap_pic_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;gdr_pic_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;ph_inter_slice_allowed_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( ph_inter_slice_allowed_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;ph_intra_slice_allowed_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;non_reference_picture_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;ph_pic_parameter_set_id</entry><entry>ue(v)</entry></row><row><entry>&#x2003;ph_pic_order_cnt_lsb</entry><entry>u(v)</entry></row><row><entry>&#x2003;if( gdr_or_irap_pic_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;no_output_of_prior_pics_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( gdr_pic_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;recovery_poc_cnt</entry><entry>ue(v)</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c; NumExtraPhBits; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;ph_extra_bit[ i ]</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_poc_msb_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;ph_poc_msb_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( ph_poc_msb_present_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;poc_msb_val</entry><entry>u(v)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( sps_alf_enabled_flag &#x26;&#x26; alf_info_in_ph_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;ph_alf_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( ph_alf_enabled_flag) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_num_alf_aps_ids_luma</entry><entry>u(3)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( i = 0; i &#x3c; ph_num_alf_aps_ids_luma; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_alf_aps_id_luma[ i ]</entry><entry>u(3)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( ChromaArrayType != 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_alf_chroma_idc</entry><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( ph_alf_chroma_idc &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_alf_aps_id_chroma</entry><entry>u(3)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( sps_ccalf_enabled_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_cc_alf_cb_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( ph_cc_alf_cb_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;ph_cc_alf_cb_aps_id</entry><entry>u(3)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_cc_alf_cr_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( ph_cc_alf_cr_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;ph_cc_alf_cr_aps_id</entry><entry>u(3)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( sps_lmcs_enabled_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;ph_lmcs_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( ph_lmcs_enabled_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_lmcs_aps_id</entry><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( ChromaArrayType != 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_chroma_residual_scale_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( sps_scaling_list_enabled_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;ph_scaling_list_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( ph_scaling_list_present_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_scaling_list_aps_id</entry><entry>u(3)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if(&#x2003;&#x2003;sps_virtual_boundaries_enabled_flag&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry>!sps_virtual_boundaries_present_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;ph_virtual_boundaries_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( ph_virtual_boundaries_present_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_num_ver_virtual_boundaries</entry><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( i = 0; i &#x3c; ph_num_ver_virtual_boundaries; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_virtual_boundaries_pos_x[ i ]</entry><entry>u(13)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;ph_num_hor_virtual_boundaries</entry><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( i = 0; i &#x3c; ph_num_hor_virtual_boundaries; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_virtual_boundaries_pos_y[ i ]</entry><entry>u(13)</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( output_flag_present_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;pic_output_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( rpl_info_in_ph_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;ref_pic_lists( )</entry><entry/></row><row><entry>&#x2003;if( partition_constraints_override_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;partition_constraints_override_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( ph_intra_slice_allowed_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;if( partition_constraints_override_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_log2_diff_min_qt_min_cb_intra_slice_luma</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;ph_max_mtt_hierarchy_depth_intra_slice_luma</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( ph_max_mtt_hierarchy_depth_intra_slice_luma != 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_log2_diff_max_bt_min_qt_intra_slice_luma</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_log2_diff_max_tt_min_qt_intra_slice_luma</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( qtbtt_dual_tree_intra_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_log2_diff_min_qt_min_cb_intra_slice_chroma</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_max_mtt_hierarchy_depth_intra_slice_chroma</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( ph_max_mtt_hierarchy_depth_intra_slice_chroma != 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;ph_log2_diff_max_bt_min_qt_intra_slice_chroma</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;ph_log2_diff_max_tt_min_qt_intra_slice_chroma</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;if( cu_qp_delta_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_cu_qp_delta_subdiv_intra_slice</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;if( pps_cu_chroma_qp_offset_list_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_cu_chroma_qp_offset_subdiv_intra_slice</entry><entry>ue(v)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( ph_inter_slice_allowed_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;if( partition_constraints_override_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_log2_diff_min_qt_min_cb_inter_slice</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;ph_max_mtt_hierarchy_depth_inter_slice</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( ph_max_mtt_hierarchy_depth_inter_slice != 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_log2_diff_max_bt_min_qt_inter_slice</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_log2_diff_max_tt_min_qt_inter_slice</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;if( cu_qp_delta_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_cu_qp_delta_subdiv_inter_slice</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;if( pps_cu_chroma_qp_offset_list_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_cu_chroma_qp_offset_subdiv_inter_slice</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;if( sps_temporal_mvp_enabled_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_temporal_mvp_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( ph_temporal_mvp_enabled_flag &#x26;&#x26; rpl_info_in_ph_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_collocated_from_10_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if(&#x2003;&#x2003;(&#x2003;&#x2003;ph_collocated_from_10_flag&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;num_ref_entries[ 0 ][ RplsIdx[ 0 ] ]&#x2003;&#x2003;&#x3e;&#x2003;&#x2003;1&#x2003;&#x2003;)&#x2003;&#x2003;| |</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;(&#x2003;&#x2003;&#x2003;!ph_collocated_from_10_flag&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;num_ref_entries[ l ][ RplsIdx[ l ] ] &#x3e; 1 ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_collocated_ref_idx</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;mvd_l1_zero_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( sps_fpel_mmvd_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_fpel_mmvd_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( sps_bdof_pic_present_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_disable_bdof_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( sps_dmvr_pic_present_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_disable_dmvr_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( sps_prof_pic_present_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_disable_prof_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( ( pps_weighted_pred_flag | | pps_weighted_bipred_flag ) &#x26;&#x26;</entry><entry/></row><row><entry>wp_info_in_ph_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;pred_weight_table( )</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( qp_delta_info_in_ph_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;ph_qp_delta</entry><entry>se(v)</entry></row><row><entry>&#x2003;if( sps_joint_cbcr_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;ph_joint_cbcr_sign_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_sao_enabled_flag &#x26;&#x26; sao_info_in_ph_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;ph_sao_luma_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( ChromaArrayType != 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_sao_chroma_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( sps_dep_quant_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;ph_dep_quant_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_sign_data_hiding_enabled_flag &#x26;&#x26; !ph_dep_quant_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;pic_sign_data_hiding_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( deblocking_filter_override_enabled_flag &#x26;&#x26; dbf_info_in_ph_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;ph_deblocking_filter_override_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( ph_deblocking_filter_override_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_deblocking_filter_disabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( !ph_deblocking_filter_disabled_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_beta_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_tc_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_cb_beta_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_cb_tc_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_cr_beta_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_cr_tc_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( picture_header_extension_present_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;ph_extension_length</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c; ph_extension_length; i++)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_extension_data_byte[ i ]</entry><entry>u(8)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0016" level="2">7.3.7.1 General Slice Header Syntax</heading><p id="p-0061" num="0093"></p><p id="p-0062" num="0000"><tables id="TABLE-US-00004" num="00004"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="238pt" align="left"/><colspec colname="2" colwidth="42pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>slice_header( ) {</entry><entry/></row><row><entry>&#x2003;picture_header_in_slice_header_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( picture_header_in_slice_header_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;picture_header_structure( )</entry><entry/></row><row><entry>&#x2003;if( subpic_info_present_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_subpic_id</entry><entry>u(v)</entry></row><row><entry>&#x2003;if( ( rect_slice_flag &#x26;&#x26; NumSlicesInSubpic[ CurrSubpicIdx ] &#x3e; 1 ) | |</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;( !rect_slice_flag &#x26;&#x26; NumTilesInPic &#x3e; 1 ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_address</entry><entry>u(v)</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c; NumExtraPhBits; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;sh_extra_bit[ i ]</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( !rect_slice_flag &#x26;&#x26; NumTilesInPic &#x3e; 1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;num_tiles_in_slice_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;if( ph_inter_slice_allowed_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_type</entry><entry>ue(v)</entry></row><row><entry>&#x2003;if( sps_alf_enabled_flag &#x26;&#x26; !alf_info_in_ph_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_alf_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( slice_alf_enabled_flag) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;slice_num_alf_aps_ids_luma</entry><entry>u(3)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( i = 0; i &#x3c; slice_num_alf_aps_ids_luma; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_alf_aps_id_luma[ i ]</entry><entry>u(3)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( ChromaArrayType != 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_alf_chroma_idc</entry><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( slice_alf_chroma_idc)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_alf_aps_id_chroma</entry><entry>u(3)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( sps_ccalf_enabled_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_cc_alf_cb_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( slice_cc_alf_cb_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;slice_cc_alf_cb_aps_id</entry><entry>u(3)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_cc_alf_cr_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( slice_cc_alf_cr_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;slice_cc_alf_cr_aps_id</entry><entry>u(3)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( separate_colour_plane_flag = = 1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;colour_plane_id</entry><entry>u(2)</entry></row><row><entry>&#x2003;if( !rpl_info_in_ph_flag &#x26;&#x26; ( ( nal_unit_type != IDR_W_RADL &#x26;&#x26;</entry><entry/></row><row><entry>nal_unit_type&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;! =</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;IDR_N_LP ) | | sps_idr_rpl_present_flag ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;ref_pic_lists( )</entry><entry/></row><row><entry>&#x2003;if( ( rpl_info_in_ph_flag | | ( ( nal_unit_type != IDR_W_RADL &#x26;&#x26;</entry><entry/></row><row><entry>nal_unit_type&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;! =</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;IDR_N_LP)&#x2003;&#x2003;&#x2003;| |&#x2003;&#x2003;&#x2003;sps_idr_rpl_present_flag ) )&#x2003;&#x2003;&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;( slice_type != I &#x26;&#x26; num_ref_entries[ 0 ][ RplsIdx[ 0 ] ] &#x3e; 1 ) | |</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;( slice_type = = B &#x26;&#x26; num_ref_entries[ 1 ][ RplsIdx[ l ] ] &#x3e; l ) ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;num_ref_idx_active_override_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( num_ref_idx_active_override_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;for( i = 0; i &#x3c; ( slice_type = = B ? 2: 1 ); i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( num_ref_entries[ i ][ Rplsldx[ i ] ] &#x3e; 1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;num_ref_idx_active_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( slice_type != I ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;if( cabac_init_present_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;cabac_init_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( ph_temporal_mvp_enabled_flag &#x26;&#x26; !rpl_info_in_ph_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( slice_type = = B )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_collocated_from_10_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( ( slice_collocated_from_10_flag &#x26;&#x26; NumRefIdxActive[ 0 ] &#x3e; 1 )</entry><entry/></row><row><entry>| |</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;( ! slice_collocated_from_10_flag &#x26;&#x26; NumRefIdxActive[ 1 ] &#x3e; 1 ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_collocated_ref_idx</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;if( !wp_info_in_ph_flag&#x2003;&#x26;&#x26;&#x2003;( ( pps_weighted_pred_flag&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry>slice_type&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;= =&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;P&#x2003;&#x2003;&#x2003;)&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;| |</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;( pps_weighted_bipred_flag &#x26;&#x26; slice_type = = B ) ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;pred_weight_table( )</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( !qp_delta_info_in_ph_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_qp_delta</entry><entry>se(v)</entry></row><row><entry>&#x2003;if( pps_slice_chroma_qp_offsets_present_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_cb_qp_offset</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;slice_cr_qp_offset</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;if( sps_joint_cbcr_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;slice_joint_cbcr_qp_offset</entry><entry>se(v)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( pps_cu_chroma_qp_offset_list_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;cu_chroma_qp_offset_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_sao_enabled_flag &#x26;&#x26; !sao_info_in_ph_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_sao_luma_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( ChromaArrayType != 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;slice_sao_chroma_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( deblocking_filter_override_enabled_flag &#x26;&#x26; !dbf_info_in_ph_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_deblocking_filter_override_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( slice_deblocking_filter_override_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_deblocking_filter_disabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( !slice_deblocking_filter_disabled_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;slice_beta_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;slice_tc_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;slice_cb_beta_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;slice_cb_tc_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;slice_cr_beta_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;slice_cr_tc_offset_div2</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;slice_ts_residual_coding_disabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( ph_lmcs_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_lmcs_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( pic_scaling_list_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_scaling_list_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( NumEntryPoints &#x3e; 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;offset_len_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c; NumEntryPoints; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;entry_point_offset_minus1[ i ]</entry><entry>u(v)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( slice_header_extension_present_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_header_extension_length</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c; slice_header_extension_length; i++)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;slice_header_extension_data_byte[ i ]</entry><entry>u(8)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;byte_alignment( )</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0017" level="1">3.4. The Specifications in JVET-Q2001-vC for Tiles, Slices and Subpictures</heading><heading id="h-0018" level="1">3 Definitions</heading><p id="p-0063" num="0000"><ul id="ul0003" list-style="none">    <li id="ul0003-0001" num="0000">    <ul id="ul0004" list-style="none">        <li id="ul0004-0001" num="0094">picture-level slice index: An index of a slice to the list of slices in a picture in the order as they are signalled in the PPS when the rect slice flag is equal to 1.</li>        <li id="ul0004-0002" num="0095">subpicture-level slice index: An index of a slice to the list of slices in a subpicture in the order as they are signalled in the PPS when the rect slice flag is equal to 1.</li>    </ul>    </li></ul></p><heading id="h-0019" level="2">6.5.1 CTB Raster Scanning, Tile Scanning, and Subpicture Scanning Processes</heading><p id="p-0064" num="0096">The variable NumTileColumns, specifying the number of tile columns, and the list colWidth[i] for i ranging from 0 to NumTileColumn&#x2212;1, inclusive, specifying the width of the i-th tile column in units of CTBs, are derived as follows:</p><p id="p-0065" num="0000"><tables id="TABLE-US-00005" num="00005"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="259pt" align="left"/><colspec colname="2" colwidth="28pt" align="right"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>remainingWidthInCtbsY = PicWidthInCtbsY</entry><entry>(23)</entry></row><row><entry>for( i = 0; i &#x3c; num_exp_tile_columns_minus1; i++ ) {</entry><entry/></row><row><entry>&#x2003;colWidth[ i ] = tile_column_width_minus1[ i ] + 1</entry><entry/></row><row><entry>&#x2003;remainingWidthInCtbsY &#x2212;= colWidth[ i ]</entry><entry/></row><row><entry>}</entry><entry/></row><row><entry>uniformTileColWidth = tile_column_width_minus1[ num_exp_tile_columns_minus1 ] + 1</entry><entry/></row><row><entry>while( remainingWidthInCtbsY &#x3e;= uniformTileColWidth ) {</entry><entry/></row><row><entry>&#x2003;col Width[ i++ ] = uniformTileColWidth</entry><entry/></row><row><entry>&#x2003;remainingWidthInCtbsY &#x2212;= uniformTileColWidth</entry><entry/></row><row><entry>}</entry><entry/></row><row><entry>if( remainingWidthInCtbsY &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;colWidth[ i++ ] = remainingWidthInCtbsY</entry><entry/></row><row><entry>NumTileColumns = i</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>The variable NumTileRows, specifying the number of tile rows, and the list RowHeight[j] for j ranging from 0 to NumTileRows&#x2212;1, inclusive, specifying the height of the j-th tile row in units of CTBs, are derived as follows:</p><p id="p-0066" num="0000"><tables id="TABLE-US-00006" num="00006"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="245pt" align="left"/><colspec colname="2" colwidth="28pt" align="right"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>remainingHeightInCtbsY = PicHeightInCtbsY</entry><entry>(24)</entry></row><row><entry>for( j = 0; j &#x3c; num_exp_tile_rows_minus1; j++ ) {</entry><entry/></row><row><entry>RowHeight[ j ] = tile_row_height_minus1[ j ] + 1</entry><entry/></row><row><entry>remainingHeightInCtbsY &#x2212;= RowHeight[ j ]</entry><entry/></row><row><entry>}</entry><entry/></row><row><entry>uniformTileRowHeight = tile_row_height_minus1[ num_exp_tile_rows_minus1 ] + 1</entry><entry/></row><row><entry>while( remainingHeightInCtbsY &#x3e;= uniformTileRowHeight ) {</entry><entry/></row><row><entry>RowHeight[ j++ ] = uniformTileRowHeight</entry><entry/></row><row><entry>remainingHeightInCtbsY &#x2212;= uniformTileRowHeight</entry><entry/></row><row><entry>}</entry><entry/></row><row><entry>if( remainingHeightInCtbsY &#x3e; 0 )</entry><entry/></row><row><entry>RowHeight[ j++ ] = remainingHeightInCtbsY</entry><entry/></row><row><entry>NumTileRows = j</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0067" num="0097">The variable NumTilesInPic is set equal to NumTileColumns*NumTileRows.</p><p id="p-0068" num="0000">The list tileColBd[i] for i ranging from 0 to NumTileColumns, inclusive, specifying the location of the i-th tile column boundary in units of CTBs, is derived as follows:</p><p id="p-0069" num="0000"><tables id="TABLE-US-00007" num="00007"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="168pt" align="left"/><colspec colname="2" colwidth="49pt" align="right"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>for( tileColBd[ 0 ] = 0, i = 0; i &#x3c; NumTileColumns; i++ )</entry><entry>(25)</entry></row><row><entry>tileColBd[ i + 1 ] = tileColBd[ i ] + colWidth[ i ] </entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><ul id="ul0005" list-style="none">    <li id="ul0005-0001" num="0000">    <ul id="ul0006" list-style="none">        <li id="ul0006-0001" num="0098">NOTE 1&#x2014;The size of the array tileColBd[ ] is one greater than the actual number of tile columns in the derivation of CtbToTileColBd[ ].<br/>The list tileRowBd[j] for j ranging from 0 to NumTileRows, inclusive, specifying the location of the j-th tile row boundary in units of CTBs, is derived as follows:</li>    </ul>    </li></ul></p><p id="p-0070" num="0000"><tables id="TABLE-US-00008" num="00008"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="168pt" align="left"/><colspec colname="2" colwidth="49pt" align="right"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>for( tileRowBd[ 0 ] = 0, j = 0; j &#x3c; NumTileRows; j++ )</entry><entry>(26)</entry></row><row><entry>tileRowBd[ j + 1 ] = tileRowBd[ j ] + RowHeight[ j ] </entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><ul id="ul0007" list-style="none">    <li id="ul0007-0001" num="0000">    <ul id="ul0008" list-style="none">        <li id="ul0008-0001" num="0099">NOTE 2&#x2014;The size of the array tileRowBd[ ] in the above derivation is one greater than the actual number of tile rows in the derivation of CtbToTileRowBd[ ].<br/>The list CtbToTileColBd[ctbAddrX] for ctbAddrX ranging from 0 to PicWidthInCtbsY, inclusive, specifying the conversion from a horizontal CTB address to a left tile column boundary in units of CTBs, is derived as follows:</li>    </ul>    </li></ul></p><p id="p-0071" num="0000"><tables id="TABLE-US-00009" num="00009"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="259pt" align="left"/><colspec colname="2" colwidth="35pt" align="center"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>tileX = 0</entry><entry/></row><row><entry>for( ctbAddrX = 0; ctbAddrX &#x3c;= PicWidthInCtbsY; ctbAddrX++ ) {</entry><entry/></row><row><entry>&#x2003;if( ctbAddrX = = tileColBd[ tileX + 1 ] )</entry><entry>(27)</entry></row><row><entry>&#x2003;&#x2003;tileX++</entry><entry/></row><row><entry>&#x2003;CtbToTileColBd[ ctbAddrX ] = tileColBd[ tileX ]</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><ul id="ul0009" list-style="none">    <li id="ul0009-0001" num="0000">    <ul id="ul0010" list-style="none">        <li id="ul0010-0001" num="0100">NOTE 3&#x2014;The size of the array CtbToTileColBd[ ] in the above derivation is one greater than the actual number of picture width in CTBs in the derivation slice_data( ) signalling.<br/>The list CtbToTileRowBd[ctbAddrY] for ctbAddrY ranging from 0 to PicHeightInCtbsY, inclusive, specifying the conversion from a vertical CTB address to a top tile column boundary in units of CTBs, is derived as follows:</li>    </ul>    </li></ul></p><p id="p-0072" num="0000"><tables id="TABLE-US-00010" num="00010"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="259pt" align="left"/><colspec colname="2" colwidth="35pt" align="center"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>tileY = 0</entry><entry/></row><row><entry>for( ctbAddrY = 0; ctbAddrY &#x3c;= PicHeightInCtbsY; ctbAddrY++ ) {</entry><entry/></row><row><entry>&#x2003;if( ctbAddrY = = tileRowBd[ tileY + 1 ] )</entry><entry>(28)</entry></row><row><entry>&#x2003;&#x2003;tileY++</entry><entry/></row><row><entry>&#x2003;CtbToTileRowBd[ ctbAddrY ] = tileRowBd[ tileY ]</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><ul id="ul0011" list-style="none">    <li id="ul0011-0001" num="0000">    <ul id="ul0012" list-style="none">        <li id="ul0012-0001" num="0101">NOTE 4&#x2014;the size of the array CtbToTileRowBd[ ] in the above derivation is one greater than the actual number of picture height in CTBs in the slice_data( ) signalling.<br/>For rectangular slices, the list NumCtusInSlice[i] for i ranging from 0 to num_slices_in_pic_minus1, inclusive, specifying the number of CTU in the i-th slice, the list SliceTopLeftTileIdx[i] for i ranging from 0 to num_slices_in_pic_minus1, inclusive, specifying the index of the top-left tile of the slice, and the matrix CtbAddrInSlice[i][j] for i ranging from 0 to num_slices_in_pic_minus1, inclusive, and j ranging from 0 to NumCtusInSlice[i]&#x2212;1, inclusive, specifying the picture raster scan address of the j-th CTB within the i-th slice, are derived as follows:</li>    </ul>    </li></ul></p><p id="p-0073" num="0000"><tables id="TABLE-US-00011" num="00011"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="259pt" align="left"/><colspec colname="2" colwidth="35pt" align="center"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>if( single_slice_per_subpic_flag ) {</entry><entry/></row><row><entry>&#x2003;for( i = 0; i &#x3c;= sps_num_subpics_minus1; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;NumCtusInSlice[ i ] = 0</entry><entry/></row><row><entry>&#x2003;for( i = 0; i &#x3c; PicSizeInCtbsY; i ++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;sliceIdx = subpic_info_present_flag ? CtbToSubpicIdx[ i ] : 0</entry><entry/></row><row><entry>&#x2003;&#x2003;CtbAddrInSlice[ sliceIdx ][ NumCtusInSlice[ sliceIdx ] ] = i</entry><entry/></row><row><entry>&#x2003;&#x2003;NumCtusInSlice[ sliceIdx ]++</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>} else {</entry><entry/></row><row><entry>&#x2003;tileIdx = 0</entry><entry/></row><row><entry>&#x2003;for( i = 0; i &#x3c;= num_slices_in_pic_minus1; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;NumCtusInSlice[ i ] = 0</entry><entry/></row><row><entry>&#x2003;for( i = 0; i &#x3c;= num_slices_in_pic_minus1; i++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;SliceTopLeftTileIdx[ i ] = tileIdx</entry><entry/></row><row><entry>&#x2003;&#x2003;tileX = tileIdx % NumTileColumns</entry><entry/></row><row><entry>&#x2003;&#x2003;tileY = tileIdx / NumTileColumns</entry><entry/></row><row><entry>&#x2003;&#x2003;if( i = = num_slices_in_pic_minus1 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;slice_width_in_tiles_minus1[ i ] = NumTileColumns &#x2212; 1 &#x2212; tileX</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ] = NumTileRows &#x2212; 1 &#x2212; tileY</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;NumSlicesInTile[ i ] = 1</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;if( slice_width_in_tiles_minus1[ i ] = = 0 &#x26;&#x26; slice_height_in_tiles_minus1[ i ]</entry><entry/></row><row><entry>= = 0 ) {</entry><entry>(29)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;ctbY = tileRowBd[ tileY ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c; NumSlicesInTile[ i ] &#x2212; 1; j++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;AddCtbsToSlice( i, tileColBd[ tileX ], tileColBd[ tileX + 1 ],</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;ctbY, ctbY + SliceHeightInCtusMinus1[ i ] + 1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ctbY += SliceHeightInCtusMinus1[ i ] + 1</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;i++</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;AddCtbsToSlice( i, tileColBd[ tileX ], tileColBd[ tileX + 1 ], ctbY,</entry><entry/></row><row><entry>tileRowBd[ tileY + 1 ] )</entry><entry/></row><row><entry>&#x2003;&#x2003;} else</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c;= slice_height_in_tiles_minus1[ i ]; j++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;for( k = 0; k &#x3c;= slice_width_in_tiles_minus1[ i ]; k++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;AddCtbsToSlice( i, tileColBd[ tileX + k ], tileColBd[ tileX + k + 1 ],</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;tileRowBd[ tileY + j ], tileRowBd[ tileY + j + 1 ] )</entry><entry/></row><row><entry>&#x2003;&#x2003;if( tile_idx_delta_present_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;tileIdx += tile_idx_delta[ i ]</entry><entry/></row><row><entry>&#x2003;&#x2003;else {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;tileIdx += slice_width_in_tiles_minus1[ i ] + 1</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( tileIdx % NumTileColumns = = 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;tileIdx += slice_height_in_tiles_minus1[ i ]* NumTileColumns</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>Where the function AddCtbsToSlice(sliceIdx, startX, stopX, startY, stopY) is specified as follows:</p><p id="p-0074" num="0000"><tables id="TABLE-US-00012" num="00012"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="259pt" align="left"/><colspec colname="2" colwidth="35pt" align="center"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>for( ctbY = startY; ctbY &#x3c; stopY; ctbY++ )</entry><entry/></row><row><entry>&#x2003;for( ctbX = startX; ctbX &#x3c; stopX; ctbX++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;CtbAddrInSlice[ sliceIdx ][ NumCtusInSlice[ sliceIdx ] ] =</entry><entry/></row><row><entry>ctbY * PicWidthInCtbsY + ctbX</entry><entry>(30)</entry></row><row><entry>&#x2003;&#x2003;NumCtusInSlice[ sliceIdx ]++</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>For bitstream conformance, the values of NumCtusInSlice[i] for i ranging from 0 to num_slices_in_pic_minus1, inclusive, may be greater than 0. Additionally, for bitstream conformance, the matrix CtbAddrInSlice[i][j] for i ranging from 0 to num_slices_in_pic_minus1, inclusive, and j ranging from 0 to NumCtusInSlice[i]&#x2212;1, inclusive, may include all CTB addresses in the range 0 to PicSizeInCtbsY&#x2212;1 once and only once.<br/>The list CtbToSubpicIdx[ctbAddrRs] for ctbAddrRs ranging from 0 to PicSizeInCtbsY&#x2212;1, inclusive, specifying the conversion from a CTB address in picture raster scan to a subpicture index, is derived as follows:</p><p id="p-0075" num="0000"><tables id="TABLE-US-00013" num="00013"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="259pt" align="left"/><colspec colname="2" colwidth="35pt" align="center"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>for( ctbAddrRs = 0; ctbAddrRs &#x3c; PicSizeInCtbsY; ctbAddrRs++ ) {</entry><entry/></row><row><entry>&#x2003;posX = ctbAddrRs % PicWidthInCtbsY</entry><entry/></row><row><entry>&#x2003;posY = ctbAddrRs / PicWidthInCtbsY</entry><entry/></row><row><entry>&#x2003;CtbToSubpicIdx[ ctbAddrRs ] = &#x2212;1</entry><entry/></row><row><entry>for( i = 0; CtbToSubpicIdx[ ctbAddrRs ] &#x3c; 0 &#x26;&#x26; i &#x3c;= sps_num_subpics_minus1;</entry><entry/></row><row><entry>i++ ) {</entry><entry>(31)</entry></row><row><entry>&#x2003;&#x2003;if( ( posX &#x3e;= subpic_ctu_top_left_x[ i ] ) &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;( posX &#x3c; subpic_ctu_top_left_x[ i ] + subpic_width_minus1[ i ] + 1 )</entry><entry/></row><row><entry>&#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;( posY &#x3e;= subpic_ctu_top_left_y[ i ] ) &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;( posY &#x3c; subpic_ctu_top_left_y[ i ] + subpic_height_minus1[ i ] + 1 ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;CtbToSubpicIdx[ ctbAddrRs ] = i</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>The list NumSlicesInSubpic[i], specifying the number of rectangular slices in the i-th subpicture, is derived as follows:</p><p id="p-0076" num="0000"><tables id="TABLE-US-00014" num="00014"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="259pt" align="left"/><colspec colname="2" colwidth="35pt" align="center"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>for( j = 0;j &#x3c;= sps_num_subpics_minus1; j++ )</entry><entry/></row><row><entry>&#x2003;NumSlicesInSubpic[ j ] = 0</entry><entry/></row><row><entry>for( i = 0; i &#x3c;= num_slices_in_pic_minus1; i++ ) {</entry><entry/></row><row><entry>&#x2003;posX = CtbAddrInSlice[ i ][ 0 ] % PicWidthInCtbsY</entry><entry/></row><row><entry>&#x2003;posY = CtbAddrInSlice[ i ][ 0 ] / PicWidthInCtbsY</entry><entry/></row><row><entry>&#x2003;for( j = 0; j &#x3c;= sps_num_subpics_minus1; j++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;if( ( posX &#x3e;= subpic_ctu_top_left_x[ j ] ) &#x26;&#x26;</entry><entry>(32)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;( posX &#x3c; subpic_ctu_top_left_x[ j ] + subpic_width_minus1[ j ] + 1 )</entry><entry/></row><row><entry>&#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;( posY &#x3e;= subpic_ctu_top_left_y[ j ] ) &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;( posY &#x3c; subpic_ctu_top_left_y[ j ] + subpic_height_minus1[ j ] + 1 ) ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;NumSlicesInSubpic[ j ]++</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>}</entry><entry/></row><row><entry>...</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0020" level="2">7.3.4.3 Picture Parameter Set RBSP Semantics</heading><p id="p-0077" num="0102">subpic_id_mapping_in_pps_flag equal to 1 specifies that the subpicture ID mapping is signalled in the PPS. subpic_id_mapping_in_pps_flag equal to 0 specifies that the subpicture ID mapping is not signalled in the PPS. If subpic_id_mapping_explicitly_signalled_flag is 0 or subpic_id_mapping_in_sps_flag is equal to 1, the value of subpic_id_mapping_in_pps_flag may be equal to 0. Otherwise (subpic_id_mapping_explicitly_signalled_flag is equal to 1 and subpic_id_mapping_in_sps_flag is equal to 0), the value of subpic_id_mapping_in_pps_flag may be equal to 1.<br/>pps_num_subpics_minus1 may be equal to sps_num_subpics_minus1.<br/>pps_subpic_id_len_minus1 may be equal to sps_subpic_id_len_minus1.<br/>pps_subpic_id[i] specifies the subpicture ID of the i-th subpicture. The length of the pps_subpic_id[i] syntax element is pps_subpic_id_len_minus1+1 bits.<br/>The variable SubpicIdVal[i], for each value of i in the range of 0 to sps_num_subpics_minus1, inclusive, is derived as follows:</p><p id="p-0078" num="0000"><tables id="TABLE-US-00015" num="00015"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="259pt" align="left"/><colspec colname="2" colwidth="35pt" align="center"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>for( i = 0; i &#x3c;= sps_num_subpics_minus1; i++ )</entry><entry/></row><row><entry>&#x2003;if( subpic_id_mapping_explicitly_signalled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;SubpicIdVal[ i ] = subpic_id_mapping_in_pps_flag ? pps_subpic_id[ i ] :</entry><entry/></row><row><entry>sps_subpic_id[ i ]</entry><entry>(80)</entry></row><row><entry>&#x2003;else</entry><entry/></row><row><entry>&#x2003;&#x2003;SubpicIdVal[ i ] = i</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>For bitstream conformance, both of the following constraints may apply:<ul id="ul0013" list-style="none">    <li id="ul0013-0001" num="0000">    <ul id="ul0014" list-style="none">        <li id="ul0014-0001" num="0103">For any two different values of i and j in the range of 0 to sps_num_subpics_minus1, inclusive, SubpicIdVal[i] may not be equal to SubpicIdVal[j].</li>        <li id="ul0014-0002" num="0104">When the current picture is not the first picture of the CLVS, for each value of i in the range of 0 to sps_num_subpics_minus1, inclusive, if the value of SubpicIdVal[i] is not equal to the value of SubpicIdVal[i] of the previous picture in decoding order in the same layer, the nal_unit_type for all coded slice NAL units of the subpicture in the current picture with subpicture index i may be equal to a particular value in the range of IDR_W_RADL to CRA_NUT, inclusive.<br/>no_pic_partition_flag equal to 1 specifies that no picture partitioning is applied to each picture referring to the PPS. no_pic_partition_flag equal to 0 specifies each picture referring to the PPS may be partitioned into more than one tile or slice.<br/>For bitstream conformance, the value of no_pic_partition_flag may be the same for all PPSs that are referred to by coded pictures within a CLVS.<br/>For bitstream conformance, the value of no_pic_partition_flag may not be equal to 1 when the value of sps_num_subpics_minus1+1 is greater than 1.<br/>pps_log 2_ctu_size_minus5 plus 5 specifies the luma coding tree block size of each CTU. pps_log 2_ctu_size_minus5 may be equal to sps_log_2_ctu_size_minus5.<br/>num_exp_tile_columns_minus1 plus 1 specifies the number of explicitly provided tile column widths. The value of num_exp_tile_columns_minus1 may be in the range of 0 to PicWidthInCtbsY&#x2212;1, inclusive. When no_pic_partition_flag is equal to 1, the value of num_exp_tile_columns_minus1 is inferred to be equal to 0.<br/>num_exp_tile_rows_minus1 plus 1 specifies the number of explicitly provided tile row heights. The value of num_exp_tile_rows_minus1 may be in the range of 0 to PicHeightInCtbsY&#x2212;1, inclusive. When no_pic_partition_flag is equal to 1, the value of num_tile_rows_minus1 is inferred to be equal to 0.<br/>tile_column_width_minus1[i] plus 1 specifies the width of the i-th tile column in units of CTBs for i in the range of 0 to num_exp_tile_columns_minus1&#x2212;1, inclusive. tile_column_width_minus1[num_exp_tile_columns_minus1] is used to derive the width of the tile columns with index greater than or equal to num_exp_tile_columns_minus1 as specified in clause 6.5.1. The value of tile_column_width_minus1[i] may be in the range of 0 to PicWidthInCtbsY&#x2212;1, inclusive. When not present, the value of tile_column_width_minus1[0] is inferred to be equal to PicWidthInCtbsY&#x2212;1.<br/>tile_row_height_minus1[i] plus 1 specifies the height of the i-th tile row in units of CTBs for i in the range of 0 to num_exp_tile_rows_minus1&#x2212;1, inclusive. tile_row_height_minus1[num_exp_tile_rows_minus1] is used to derive the height of the tile rows with index greater than or equal to num_exp_tile_rows_minus1 as specified in clause 6.5.1. The value of tile_row_height_minus1[i] may be in the range of 0 to PicHeightInCtbsY&#x2212;1, inclusive. When not present, the value of tile_row_height_minus1[0] is inferred to be equal to PicHeightInCtbsY&#x2212;1.<br/>rect_slice_flag equal to 0 specifies that tiles within each slice are in raster scan order and the slice information is not signalled in PPS. rect_slice_flag equal to 1 specifies that tiles within each slice cover a rectangular region of the picture and the slice information is signalled in the PPS. When not present, rect_slice_flag is inferred to be equal to 1. When subpic_info_present_flag is equal to 1, the value of rect_slice_flag may be equal to 1.<br/>single_slice_per_subpic_flag equal to 1 specifies that each subpicture consists of one and only one rectangular slice. single_slice_per_subpic_flag equal to 0 specifies that each subpicture may consist of one or more rectangular slices. When single_slice_per_subpic_flag is equal to 1, num_slices_in_pic_minus1 is inferred to be equal to sps_num_subpics_minus1. When not present, the value of single_slice_per_subpic_flag is inferred to be equal to 0.<br/>num_slices_in_pic_minus1 plus 1 specifies the number of rectangular slices in each picture referring to the PPS. The value of num_slices_in_pic_minus1 may be in the range of 0 to MaxSlicesPerPicture&#x2212;1, inclusive, where MaxSlicesPerPicture is specified in Annex A. When no_pic_partition_flag is equal to 1, the value of num_slices_in_pic_minus1 is inferred to be equal to 0.<br/>tile_idx_delta_present_flag equal to 0 specifies that tile_idx_delta values are not present in the PPS and all rectangular slices in pictures referring to the PPS are specified in raster order according to the process defined in clause 6.5.1. The tile_idx_delta_present_flag equal to 1 specifies that tile_idx_delta values may be present in the PPS and all rectangular slices in pictures referring to the PPS are specified in the order indicated by the values of tile_idx_delta. When not present, the value of tile_idx_delta_present_flag is inferred to be equal to 0.<br/>slice_width_in_tiles_minus1[i] plus 1 specifies the width of the i-th rectangular slice in units of tile columns. The value of slice_width_in_tiles_minus1[i] may be in the range of 0 to NumTileColumns&#x2212;1, inclusive.<br/>When slice_width_in_tiles_minus1[i] is not present, the following applies:</li>        <li id="ul0014-0003" num="0105">If NumTileColumns is equal to 1, the value of slice_width_in_tiles_minus1[i] is inferred to be equal to 0.</li>        <li id="ul0014-0004" num="0106">Otherwise, the value of slice_width_in_tiles_minus1[i] is inferred as specified in clause 6.5.1.<br/>slice_height_in_tiles_minus1[i] plus 1 specifies the height of the i-th rectangular slice in units of tile rows. The value of slice_height_in_tiles_minus1[i] may be in the range of 0 to NumTileRows&#x2212;1, inclusive.<br/>When slice_height_in_tiles_minus1[i] is not present, the following applies:</li>        <li id="ul0014-0005" num="0107">If NumTileRows is equal to 1, or tile_idx_delta_present_flag is equal to 0 and tileIdx % NumTileColumns is greater than 0), the value of slice_height_in_tiles_minus1[i] is inferred to be equal to 0.</li>        <li id="ul0014-0006" num="0108">Otherwise (NumTileRows is not equal to 1, and tile_idx_delta_present_flag is equal to 1 or tileIdx % NumTileColumns is equal to 0), when tile_idx_delta_present_flag is equal to 1 or tileIdx % NumTileColumns is equal to 0, the value of slice_height_in_tiles_minus1[i] is inferred to be equal to slice_height_in_tiles_minus1[i&#x2212;1].<br/>num_exp_slices_in_tile[i] specifies the number of explicitly provided slice heights in the current tile that contains more than one rectangular slices. The value of num_exp_slices_in_tile[i] may be in the range of 0 to RowHeight[tileY]&#x2212;1, inclusive, where tileY is the tile row index containing the i-th slice. When not present, the value of num_exp_slices_in_tile[i] is inferred to be equal to 0. When num_exp_slices_in_tile[i] is equal to 0, the value of the variable NumSlicesInTile[i] is derived to be equal to 1.<br/>exp_slice_height_in_ctus_minus1[j] plus 1 specifies the height of the j-th rectangular slice in the current tile in units of CTU rows. The value of exp_slice_height_in_ctus_minus1[j] may be in the range of 0 to RowHeight[tileY]&#x2212;1, inclusive, where tileY is the tile row index of the current tile.<br/>When num_exp_slices_in_tile[i] is greater than 0, the variable NumSlicesInTile[i] and SliceHeightInCtusMinus1[i+k] for k in the range of 0 to NumSlicesInTile[i]&#x2212;1 are derived as follows:</li>    </ul>    </li></ul></p><p id="p-0079" num="0000"><tables id="TABLE-US-00016" num="00016"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="259pt" align="left"/><colspec colname="2" colwidth="35pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>remainingHeightlnCtbsY = RowHeight[ SliceTopLeftTileIdx[ i ] / NumTileColumns ]</entry><entry/></row><row><entry>numExpSliceInTile = num_exp_slices_in_tile[ i ]</entry><entry/></row><row><entry>for( j = 0; j &#x3c; numExpSliceInTile &#x2212; 1; j++ ) {</entry><entry/></row><row><entry>&#x2003;SliceHeightInCtusMinus1[ i++ ] = exp_slice_height_in_ctu_minus1[ j ]</entry><entry/></row><row><entry>&#x2003;remainingHeightInCtbsY &#x2212;= SliceHeightInCtusMinus1[ j ]</entry><entry/></row><row><entry>}</entry><entry/></row><row><entry>uniformSliceHeightMinus1 = SliceHeightInCtusMinus1[ i &#x2212; 1 ]</entry><entry>(81)</entry></row><row><entry>while( remainingHeightInCtbsY &#x3e;= (uniformSliceHeightMinus1 + 1) ) {</entry><entry/></row><row><entry>&#x2003;SliceHeightInCtusMinus1[ i++ ] = uniformSliceHeightMinus1</entry><entry/></row><row><entry>&#x2003;remainingHeightInCtbsY &#x2212;= (uniformSliceHeightMinus1 + 1)</entry><entry/></row><row><entry>&#x2003;j++</entry><entry/></row><row><entry>}</entry><entry/></row><row><entry>if( remainingHeightInCtbsY &#x3e; 0 ) {</entry><entry/></row><row><entry>&#x2003;SliceHeightInCtusMinus1[ i++ ] = remainingHeightInCtbsY</entry><entry/></row><row><entry>&#x2003;j++</entry><entry/></row><row><entry>}</entry><entry/></row><row><entry>NumSlicesInTile[ i ] = j</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>tile_idx_delta[i] specifies the difference between the tile index of the first tile in the i-th rectangular slice and the tile index of the first tile in the (i+1)-th rectangular slice. The value of tile_idx_delta[i] may be in the range of &#x2212;NumTilesInPic+1 to NumTilesInPic&#x2212;1, inclusive. When not present, the value of tile_idx_delta[i] is inferred to be equal to 0. When present, the value of tile_idx_delta[i] may not be equal to 0.<br/>7.4.2.4.5 Order of VCL NAL Units and their Association to Coded Pictures<br/>The order of the VCL NAL units within a coded picture is constrained as follows:<ul id="ul0015" list-style="none">    <li id="ul0015-0001" num="0000">    <ul id="ul0016" list-style="none">        <li id="ul0016-0001" num="0109">For any two coded slice NAL units A and B of a coded picture, let subpicIdxA and subpicIdxB be their subpicture level index values, and sliceAddrA and sliceddrB be their slice_address values.</li>        <li id="ul0016-0002" num="0110">When either of the following conditions is true, coded slice NAL unit A may precede coded slice NAL unit B:        <ul id="ul0017" list-style="none">            <li id="ul0017-0001" num="0111">subpicIdxA is less than subpicIdxB.</li>            <li id="ul0017-0002" num="0112">subpicIdxA is equal to subpicIdxB and sliceAddrA is less than sliceAddrB.</li>        </ul>        </li>    </ul>    </li></ul></p><heading id="h-0021" level="2">7.4.8.1 General Slice Header Semantics</heading><p id="p-0080" num="0113">The variable CuQpDeltaVal, specifying the difference between a luma quantization parameter for the coding unit containing cu_qp_delta_abs and its prediction, is set equal to 0. The variables CuQpOffset<sub>Cb</sub>, CuQpOffset<sub>Cr</sub>, and CuQpOffset<sub>CbCr</sub>, specifying values to be used when determining the respective values of the Qp&#x2032;<sub>Cb</sub>, Qp&#x2032;<sub>Cr</sub>, and Qp&#x2032;<sub>CbCr </sub>quantization parameters for the coding unit containing cu_chroma_qp_offset_flag, are all set equal to 0.<br/>picture_header_in_slice_header_flag equal to 1 specifies that the PH syntax structure is present in the slice header. picture_header_in_slice_header_flag equal to 0 specifies that the PH syntax structure is not present in the slice header.<br/>For bitstream conformance, the value of picture_header_in_slice_header_flag may be the same in all coded slices in a CLVS.<br/>When picture_header_in_slice_header_flag is equal to 1 for a coded slice, for bitstream conformance, no VCL NAL unit with nal_unit_type equal to PH_NUT may be present in the CLVS.<br/>When picture_header_in_slice_header_flag is equal to 0, all coded slices in the current picture may have picture_header_in_slice_header_flag is equal to 0, and the current PU may have a PH NAL unit.<br/>slice_subpic_id specifies the subpicture ID of the subpicture that contains the slice. If slice_subpic_id is present, the value of the variable CurrSubpicIdx is derived to be such that SubpicIdVal[CurrSubpicIdx] is equal to slice_subpic_id. Otherwise (slice_subpic_id is not present), CurrSubpicIdx is derived to be equal to 0. The length of slice_subpic_id is sps_subpic_id_len_minus1+1 bits.<br/>slice_address specifies the slice address of the slice. When not present, the value of slice_address is inferred to be equal to 0. When rect_slice_flag is equal to 1 and NumSlicesInSubpic[CurrSubpicIdx] is equal to 1, the value of slice_address is inferred to be equal to 0.<br/>If rect_slice_flag is equal to 0, the following applies:<ul id="ul0018" list-style="none">    <li id="ul0018-0001" num="0000">    <ul id="ul0019" list-style="none">        <li id="ul0019-0001" num="0114">The slice address is the raster scan tile index.</li>        <li id="ul0019-0002" num="0115">The length of slice_address is Ceil(Log 2 (NumTilesInPic)) bits.</li>        <li id="ul0019-0003" num="0116">The value of slice_address may be in the range of 0 to NumTilesInPic&#x2212;1, inclusive.<br/>Otherwise (rect_slice_flag is equal to 1), the following applies:</li>        <li id="ul0019-0004" num="0117">The slice address is the subpicture-level slice index of the slice.</li>        <li id="ul0019-0005" num="0118">The length of slice_address is Ceil(Log2(NumSlicesInSubpic[CurrSubpicIdx])) bits.</li>        <li id="ul0019-0006" num="0119">The value of slice_address may be in the range of 0 to NumSlicesInSubpic[CurrSubpicIdx]&#x2212;1, inclusive.<br/>For bitstream conformance, the following constraints may apply:</li>        <li id="ul0019-0007" num="0120">If rect_slice_flag is equal to 0 or subpic_info_present_flag is equal to 0, the value of slice_address may not be equal to the value of slice_address of any other coded slice NAL unit of the same coded picture.</li>        <li id="ul0019-0008" num="0121">Otherwise, the pair of slice_subpic_id and slice_address values may not be equal to the pair of slice_subpic_id and slice_address values of any other coded slice NAL unit of the same coded picture.</li>        <li id="ul0019-0009" num="0122">The shapes of the slices of a picture may be such that each CTU, when decoded, may have its entire left boundary and entire top boundary consisting of a picture boundary or consisting of boundaries of previously decoded CTU(s).<br/>sh_extra_bit[i] may be equal to 1 or 0. Decoders conforming to this version of this Specification may ignore the value of sh_extra_bit[i]. Its value does not affect decoder conformance to profiles specified in this version of specification.<br/>num_tiles_in_slice_minus1 plus 1, when present, specifies the number of tiles in the slice. The value of num_tiles_in_slice_minus1 may be in the range of 0 to NumTilesInPic&#x2212;1, inclusive. The variable NumCtusInCurrSlice, which specifies the number of CTUs in the current slice, and the list CtbAddrInCurrSlice[i], for i ranging from 0 to NumCtusInCurrSlice 1, inclusive, specifying the picture raster scan address of the i-th CTB within the slice, are derived as follows:</li>    </ul>    </li></ul></p><p id="p-0081" num="0000"><tables id="TABLE-US-00017" num="00017"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="259pt" align="left"/><colspec colname="2" colwidth="35pt" align="center"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>if( rect_slice_flag ) {</entry><entry/></row><row><entry>&#x2003;picLevelSliceIdx = slice_address</entry><entry/></row><row><entry>&#x2003;for( j = 0; j &#x3c; CurrSubpicIdx; j++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;picLevelSliceIdx += NumSlicesInSubpic[ j ]</entry><entry/></row><row><entry>&#x2003;NumCtusInCurrSlice = NumCtusInSlice[ picLevelSliceIdx ]</entry><entry/></row><row><entry>&#x2003;for( i = 0; i &#x3c; NumCtusInCurrSlice; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;CtbAddrInCurrSlice[ i ] = CtbAddrInSlice[ picLevelSliceIdx ][ i ]</entry><entry>(117)</entry></row><row><entry>} else {</entry><entry/></row><row><entry>&#x2003;NumCtusInCurrSlice = 0</entry><entry/></row><row><entry>&#x2003;for( tileIdx = slice address; tileIdx &#x3c;= slice_address + num_tiles_in_slice_minus1;</entry><entry/></row><row><entry>tileIdx++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;tileX = tileIdx % NumTileColumns</entry><entry/></row><row><entry>&#x2003;&#x2003;tileY = tileIdx / NumTileColumns</entry><entry/></row><row><entry>&#x2003;&#x2003;for( ctbY = tileRowBd[ tileY ]; ctbY &#x3c; tileRowBd[ tileY + 1 ]; ctbY++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;for( ctbX = tileColBd[ tileX ]; ctbX &#x3c; tileColBd[ tileX + 1 ]; ctbX++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;CtbAddrInCurrSlice[ NumCtusInCurrSlice ] =</entry><entry/></row><row><entry>ctbY * PicWidthInCtb + ctbX</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;NumCtusInCurrSlice++</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>The variables SubpicLeftBoundaryPos, SubpicTopBoundaryPos, SubpicRightBoundaryPos, and SubpicBotBoundaryPos are derived as follows:</p><p id="p-0082" num="0000"><tables id="TABLE-US-00018" num="00018"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="259pt" align="left"/><colspec colname="2" colwidth="35pt" align="center"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;if( subpic_treated_as_pic _flag[ CurrSubpicIdx ] ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;SubpicLeftBoundaryPos = subpic_ctu_top_left_x[ CurrSubpicIdx ] * CtbSizeY</entry><entry/></row><row><entry>&#x2003;&#x2003;SubpicRightBoundaryPos = Min( pic_width_max_in_luma_samples &#x2212; 1,</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;( subpic_ctu_top_left_x[ CurrSubpicIdx ] +</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;subpic_width_minus1[ CurrSubpicIdx ] + 1 ) * CtbSizeY &#x2212; 1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;SubpicTopBoundaryPos = subpic_ctu_top_left_y[ CurrSubpicIdx ] *CtbSizeY</entry><entry>(118)</entry></row><row><entry>&#x2003;&#x2003;SubpicBotBoundaryPos = Min( pic_height_max_in_luma_samples &#x2212; 1,</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;( subpic_ctu_top_left_y[ CurrSubpicIdx ] +</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;subpic_height_minus1[ CurrSubpicIdx ] + 1 ) * CtbSizeY &#x2212; 1 )</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>...</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0022" level="1">3.5. Luma Mapping with Chroma Scaling (LMCS)</heading><p id="p-0083" num="0123">LMCS includes two aspects: luma mapping (reshaping process, denoted by RP) and luma dependent chroma residual scaling (CRS). For the luma signal, the LMCS mode operates based on two domains are involved wherein including a first domain that is an original domain and a second domain that is a reshaped domain which maps luma samples to particular values according reshaping models. In addition, for the chroma signal, residual scaling may be applied wherein the scaling factors are derived from luma samples.</p><p id="p-0084" num="0124">The related syntax elements and semantics in SPS, picture header (PH) and slice header (SH) are described as follows:</p><heading id="h-0023" level="2">Syntax Tables</heading><heading id="h-0024" level="2">7.3.2.3 Sequence Parameter Set RBSP Syntax</heading><p id="p-0085" num="0125"></p><p id="p-0086" num="0000"><tables id="TABLE-US-00019" num="00019"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="168pt" align="left"/><colspec colname="2" colwidth="49pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>seq_parameter_set_rbsp( ) {</entry><entry/></row><row><entry>&#x2003;sps_seq_parameter_set_id</entry><entry>u(4)</entry></row><row><entry>&#x2003;sps_video_parameter_set_id</entry><entry>u(4)</entry></row><row><entry>&#x2003;sps_max_sublayers minus1</entry><entry>u(3)</entry></row><row><entry>&#x2003;sps_reserved_zero_4bits</entry><entry>u(4)</entry></row><row><entry>. . .</entry><entry/></row><row><entry>&#x2003;sps_affine_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_affine_enabled flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;five_minus_max_num_subblock_merge_cand</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;sps_affine_type_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( sps_amvr_enabled_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;sps_affine_amvr_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;sps_affine_prof_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( sps_affine_prof_enabled_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;sps_prof_pic_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>. . .</entry><entry/></row><row><entry>&#x2003;sps_lmcs_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_lfnst_enabled_flag</entry><entry>u(1)</entry></row><row><entry>. . .</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0025" level="2">7.3.2.7 Picture Header Structure Syntax</heading><p id="p-0087" num="0126"></p><p id="p-0088" num="0000"><tables id="TABLE-US-00020" num="00020"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="210pt" align="left"/><colspec colname="2" colwidth="49pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>picture_header_structure( ) {</entry><entry/></row><row><entry>&#x2003;gdr_or_irap_pic_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( gdr_or_irap_pic_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;gdr_pic_flag</entry><entry>u(1)</entry></row><row><entry>. . .</entry><entry/></row><row><entry>&#x2003;if( sps_lmcs_enabled_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;ph_lmcs_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( ph_lmcs_enabled_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_lmcs_aps_id</entry><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( ChromaArrayType != 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_chroma_residual_scale_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( sps_scaling_list_enabled_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;ph_scaling_list_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( ph_scaling_list_present_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_scaling_list_aps_id</entry><entry>u(3)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if(&#x2003;&#x2003;&#x2003;sps_virtual_boundaries_enabled_flag&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry>!sps_virtual_boundaries_present_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;ph_virtual_boundaries_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( ph_virtual_boundaries_present_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_num_ver_virtual_boundaries</entry><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( i = 0; i &#x3c; ph_num_ver_virtual_boundaries; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_virtual_boundaries_pos_x[ i ]</entry><entry>u(13)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;ph_num_hor_virtual_boundaries</entry><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( i = 0; i &#x3c; ph_num_hor_virtual_boundaries; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_virtual_boundaries_pos_y[ i ]</entry><entry>u(13)</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0026" level="2">7.3.7 Slice Header Syntax</heading><heading id="h-0027" level="2">7.3.7.1 General Slice Header Syntax</heading><p id="p-0089" num="0127"></p><p id="p-0090" num="0000"><tables id="TABLE-US-00021" num="00021"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="175pt" align="left"/><colspec colname="2" colwidth="42pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>slice_header( ) {</entry><entry/></row><row><entry>&#x2003;picture_header_in_slice_header_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;slice_ts_residual_coding_disabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( ph_lmcs_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_lmcs_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( pic_scaling_list_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_scaling_list_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( NumEntryPoints &#x3e; 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;offset_len_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c; NumEntryPoints; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;entry_point_offset_minus1[ i ]</entry><entry>u(v)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( slice_header_extension_present_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_header_extension_length</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c; slice_header_extension_length; i++)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;slice_header_extension_data_byte[ i ]</entry><entry>u(8)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;byte_alignment( )</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0028" level="2">Semantics</heading><p id="p-0091" num="0128">sps_lmcs_enabled_flag equal to 1 specifies that luma mapping with chroma scaling is used in the CLVS. sps_lmcs_enabled_flag equal to 0 specifies that luma mapping with chroma scaling is not used in the CLVS.<br/>ph_lmcs_enabled_flag equal to 1 specifies that luma mapping with chroma scaling is enabled for all slices associated with the PH. ph_lmcs_enabled_flag equal to 0 specifies that luma mapping with chroma scaling may be disabled for one, or more, or all slices associated with the PH. When not present, the value of ph_lmcs_enabled_flag is inferred to be equal to 0.<br/>ph_lmcs_aps_id specifies the adaptation parameter set id of the LMCS APS that the slices associated with the PH refers to. The TemporalId of the APS NAL unit having aps_params_type equal to LMCS_APS and adaptation_parameter_set_id equal to ph_lmcs_aps_id may be less than or equal to the TemporalId of the picture associated with PH.<br/>ph_chroma_residual_scale_flag equal to 1 specifies that chroma residual scaling is enabled for the all slices associated with the PH. ph_chroma_residual_scale_flag equal to 0 specifies that chroma residual scaling may be disabled for one, or more, or all slices associated with the PH. When ph_chroma_residual_scale_flag is not present, it is inferred to be equal to 0.<br/>slice_lmcs_enabled_flag equal to 1 specifies that luma mapping with chroma scaling is enabled for the current slice. slice_lmcs_enabled_flag equal to 0 specifies that luma mapping with chroma scaling is not enabled for the current slice. When slice_lmcs_enabled_flag is not present, it is inferred to be equal to 0.</p><heading id="h-0029" level="1">3.6. Adaptive Motion Vector Difference Resolution (AMVR) for Affine Coded Blocks</heading><p id="p-0092" num="0129">Affine AMVR is a coding tool that allows an affine inter coded block to transmit the MV differences in different resolutions, such as in the precision of &#xbc; luma sample (default, with amwr_flag set to 0), 1/16 luma sample, 1 luma sample.</p><p id="p-0093" num="0130">The related syntax elements and semantics in SPS are described as follows:</p><heading id="h-0030" level="2">Syntax Tables</heading><heading id="h-0031" level="2">7.3.2.3 Sequence Parameter Set RBSP Syntax</heading><p id="p-0094" num="0131"></p><p id="p-0095" num="0000"><tables id="TABLE-US-00022" num="00022"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="168pt" align="left"/><colspec colname="2" colwidth="49pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>seq_parameter_set_rbsp( ) {</entry><entry/></row><row><entry>&#x2003;sps_seq_parameter_set_id</entry><entry>u(4)</entry></row><row><entry>&#x2003;sps_video_parameter_set_id</entry><entry>u(4)</entry></row><row><entry>&#x2003;sps_max_sublayers_minus1</entry><entry>u(3)</entry></row><row><entry>&#x2003;sps_reserved_zero_4bits</entry><entry>u(4)</entry></row><row><entry>. . .</entry><entry/></row><row><entry>&#x2003;sps_affine_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_affine_enabled_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;five_minus_max_num_subblock_merge_cand</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;sps_affine_type_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( sps_amvr_enabled_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;sps_affine_amvr_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;sps_affine_prof_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( sps_affine_prof_enabled _flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;sps_prof_pic_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>. . .</entry><entry/></row><row><entry>&#x2003;sps_lmcs_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;sps_lfnst_enabled_flag</entry><entry>u(1)</entry></row><row><entry>. . .</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0032" level="2">Semantics</heading><p id="p-0096" num="0132">sps_affine_amvr_enabled_flag equal to 1 specifies that adaptive motion vector difference resolution is used in motion vector coding of affine inter mode. sps_affine_amvr_enabled_flag equal to 0 specifies that adaptive motion vector difference resolution is not used in motion vector coding of affine inter mode. When not present, the value of sps_affine_amvr_enabled_flag is inferred to be equal to 0.</p><heading id="h-0033" level="2">D.7 Subpicture Level Information SEI Message</heading><heading id="h-0034" level="2">D.7.1 Subpicture Level Information SEI Message Syntax</heading><p id="p-0097" num="0133"></p><p id="p-0098" num="0000"><tables id="TABLE-US-00023" num="00023"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="175pt" align="left"/><colspec colname="2" colwidth="42pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>subpic_level_info( payloadSize ) {</entry><entry/></row><row><entry>&#x2003;num_ref_levels_minus1</entry><entry>u(3)</entry></row><row><entry>&#x2003;sli_cbr_constraint_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;explicitfractionpresentflag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( explicit_fraction_present_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;sli_num_subpics_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;while( !byte_aligned( ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;sli_alignment_zero_bit</entry><entry>f(1)</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c;= num_ref_levels_minus1; i++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;ref_level_idc[ i ]</entry><entry>u(8)</entry></row><row><entry>&#x2003;&#x2003;if( explicit_fraction_present_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c;= sli_num_subpics_minus1; j++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ref_level_fraction_minus1[ i ][ j ]</entry><entry>u(8)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0035" level="2">D.7.2 Subpicture Level Information SEI Message Semantics</heading><p id="p-0099" num="0134">The subpicture level information SEI message contains information about the level that subpicture sequences in the bitstream conform to when testing the conformance of the extracted bitstreams containing the subpicture sequences according to Annex A.<br/>When a subpicture level information SEI message is present for any picture of a CLVS, a subpicture level information SEI message may be present for the first picture of the CLVS. The subpicture level information SEI message persists for the current layer in decoding order from the current picture until the end of the CLVS. All subpicture level information SEI messages that apply to the same CLVS may have the same content. A subpicture sequence consists of all subpictures within a CLVS that have the same value of subpicture index.<br/>For bitstream conformance, when a subpicture level information SEI message is present for a CLVS, the value of subpic_treated_as_pic_flag[i] may be equal to 1 for each value of i in the range of 0 to sps_num_subpics_minus1, inclusive.<br/>num_ref_levels_minus1 plus 1 specifies the number of reference levels signalled for each of the sps_num_subpics_minus1+1 subpictures.<br/>sli_cbr_constraint_flag equal to 0 specifies that to decode the sub-bitstreams resulting from extraction of any subpicture of the bitstream according to clause C.7 by using the HRD using any CPB specification in the extracted sub-bitstream, the hypothetical stream scheduler (HSS) operates in an intermittent bit rate mode. sli_cbr_constraint_flag equal to 1 specifies that the HSS operates in a constant bit rate (CBR) mode.<br/>explicit_fraction_present_flag equal to 1 specifies that the syntax elements ref_level_fraction_minus1[i] are present. explicit fraction present flag equal to 0 specifies that the syntax elements ref_level_fraction_minus1[i] are not present.<br/>sli_num_subpics_minus1 plus 1 specifies the number of subpictures in the pictures of the CLVS. When present, the value of sli_num_subpics_minus1 may be equal to the value of sps_num_subpics_minus1 in the SPS referred to by the pictures in the CLVS.<br/>sli_alignment_zero_bit may be equal to 0.<br/>ref_level_idc[i] indicates a level to which each subpicture conforms as specified in Annex A. Bitstreams may not contain values of ref_level_idc other than those specified in Annex A. Other values of ref_level_idc[i] are reserved for future use by ITU-T ISO/IEC. For bitstream conformance, the value of ref_level_idc[i] may be less than or equal to ref_level_idc[k] for any value of k greater than i.<br/>ref_level_fraction_minus1[i][j] plus 1 specifies the fraction of the level limits associated with ref_level_idc[i] that the j-th subpicture conforms to as specified in clause A.4.1.<br/>The variable SubpicSizeY[j] is set equal to (subpic_width_minus1 [j]+1)*CtbSizeY*(subpic_height_minus1[j]+1)*CtbSizeY<br/>When not present, the value of ref_level_fraction_minus1[i][j] is inferred to be equal to Ceil(256*SubpicSizeY[j]&#xf7;PicSizeInSamplesY*MaxLumaPs(general_level_idc)&#xf7;MaxLu maPs(ref_level_idc[i])&#x2212;1.<br/>The variable RefLevelFraction[i][j] is set equal to ref_level_fraction_minus1[i][j]+1. The variables SubpicNumTileCols[j] and SubpicNumTileRows[j] are derived as follows:</p><p id="p-0100" num="0000"><tables id="TABLE-US-00024" num="00024"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="259pt" align="left"/><colspec colname="2" colwidth="35pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>for( i = 0; i &#x3c;= sps_num_subpics_minus1; i++) {</entry><entry/></row><row><entry>&#x2003;SubpicNumTileCols[ i ] = 1</entry><entry/></row><row><entry>&#x2003;SubpicNumTileRows[ i ] = 1</entry><entry/></row><row><entry>&#x2003;for( ctbAddrRs = subpic_ctu_top_left_x[ i ] + 1; ctbAddrRs &#x3c;=</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;subpic_ctu_top_left_x[ i ] + subpic_width_minus1[ i ]; ctbAddrRs++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;if( CtbToTileColBd[ ctbAddrRs ] != CtbToTileColBd[ ctbAddrRs &#x2212; l ] )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;SubpicNumTileCols[ i ]++</entry><entry>(D.5)</entry></row><row><entry>&#x2003;for( ctbAddrRs = ( subpic_ctu_top_left_y[ i ] + 1 ) * PicWidthInCtbsY;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ctbAddrRs &#x3c;= ( subpic_ctu_top_left_y[ i ] + subpic_height_minus1[ i ]</entry><entry/></row><row><entry>) * PicWidthInCtbsY;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ctbAddrRs += PicWidthInCtbsY )</entry><entry/></row><row><entry>&#x2003;&#x2003;if( CtbToTileRowBd[ ctbAddrRs ] !=</entry><entry/></row><row><entry>CtbToTileRowBd[ ctbAddrRs &#x2212; PicWidthInCtbsY ] )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;SubpicNumTileRows[ i ]++</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>The variables SubpicCpbSizeVcl[i][j] and SubpicCpbSizeNal[i][j] are derived as follows:</p><p id="p-0101" num="0000"><tables id="TABLE-US-00025" num="00025"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="259pt" align="left"/><colspec colname="2" colwidth="35pt" align="center"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;SubpicCpbSizeVcl[ i ][ j ] =</entry><entry/></row><row><entry>&#x2003;Floor( CpbVclFactor * MaxCPB * RefLevelFraction[ i ][ j ] &#xf7; 256)</entry><entry>(D.6)</entry></row><row><entry>&#x2003;SubpicCpbSizeNal[ i ][ j ] =</entry><entry/></row><row><entry>&#x2003;Floor( CpbNalFactor * MaxCPB * RefLevelFraction[ i ][ j ] &#xf7; 256)</entry><entry>(D.7)</entry></row><row><entry>with MaxCPB derived from ref_level_idc[ i ] as specified in clause A.4.2.</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>The variables SubpicBitRateVcl[i][j] and SubpicBitRateNal[i][j] are derived as follows:</p><p id="p-0102" num="0000"><tables id="TABLE-US-00026" num="00026"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="259pt" align="left"/><colspec colname="2" colwidth="35pt" align="center"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;SubpicBitRateVcl[ i ][ j ] =</entry><entry/></row><row><entry>&#x2003;Floor( CpbVclFactor * MaxBR * RefLevelFraction[ i ][ j ] &#xf7; 256)</entry><entry>(D.8)</entry></row><row><entry>&#x2003;SubpicBitRateNal[ i ][ j ] =</entry><entry/></row><row><entry>&#x2003;Floor( CpbNalFactor * MaxBR * RefLevelFraction[ i ][ j ] &#xf7; 256)</entry><entry>(D.9)</entry></row><row><entry>with MaxBR derived from ref_level_idc[ i ] as specified in clause A.4.2.</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><ul id="ul0020" list-style="none">    <li id="ul0020-0001" num="0000">    <ul id="ul0021" list-style="none">        <li id="ul0021-0001" num="0135">NOTE 1&#x2014;When a subpicture is extracted, the resulting bitstream has a CpbSize (either indicated in the SPS or inferred) that is greater than or equal to SubpicCpbSizeVcl[i][j] and SubpicCpbSizeNal[i][j] and a BitRate (either indicated in the SPS or inferred) that is greater than or equal to SubpicBitRateVcl[i][j] and SubpicBitRateNal[i][j].<br/>For bitstream conformance, the bitstreams resulting from extracting the j-th subpicture for j in the range of 0 to sps_num_subpics_minus1, inclusive, and conforming to a profile with general_tier_flag equal to 0 and level equal to ref_level_idc[i] for i in the range of 0 to num_ref_level_minus1, inclusive, may obey the following constraints for each bitstream conformance test as specified in Annex C:</li>        <li id="ul0021-0002" num="0136">Ceil(256*SubpicSizeY[j]&#xf7;RefLevelFraction[i][j]) may be less than or equal to MaxLumaPs, where MaxLumaPs is specified in Table A.1 for level ref_level_idc[i].</li>        <li id="ul0021-0003" num="0137">The value of Ceil(256*(subpic_width_minus1[j]+1)*CtbSizeY&#xf7;RefLevelFraction[i][j]) may be less than or equal to Sqrt(MaxLumaPs*8).</li>        <li id="ul0021-0004" num="0138">The value of Ceil(256*(subpic_height_minus1[j]+1)*CtbSizeY&#xf7;RefLevelFraction[i][j]) may be less than or equal to Sqrt(MaxLumaPs*8).</li>        <li id="ul0021-0005" num="0139">The value of SubpicNumTileCols[j] may be less than or equal to MaxTileCols and of SubpicNumTileRows[j] may be less than or equal to MaxTileRows, where MaxTileCols and MaxTileRows are specified in Table A.1 for level ref_level_idc[i].</li>        <li id="ul0021-0006" num="0140">The value of SubpicNumTileCols[j]*SubpicNumTileRows[j] may be less than or equal to MaxTileCols*MaxTileRows*RefLevelFraction[i][j], where MaxTileCols and MaxTileRows are specified in Table A.1 for level ref_level_idc[i].</li>        <li id="ul0021-0007" num="0141">The sum of the NumByteslnNalUnit variables for AU 0 corresponding to the j-th subpicture may be less than or equal to FormatCapabilityFactor*(Max(SubpicSizeY[j], fR*MaxLumaSr*RefLevelFraction[i][j]&#xf7;256)+MaxLumaSr*(AuCpbRemovalTime[0]&#x2212;AuNominalRemovalTime[0])*RefLevelFr action[i][j])&#xf7;(256*MinCr) for the value of SubpicSizelnSamplesY of AU 0, where MaxLumaSr and FormatCapabilityFactor are the values specified in Table A.2 and Table A.3, respectively, that apply to AU 0, at level ref_level_idc[i], and MinCr is derived as indicated in A.4.2.</li>        <li id="ul0021-0008" num="0142">The sum of the NumByteslnNalUnit variables for AU n (with n greater than 0) corresponding to the j-th subpicture may be less than or equal to FormatCapabilityFactor*MaxLumaSr*(AuCpbRemovalTime[n]&#x2212;AuCpbRemovalTime[n&#x2212;1])*RefLevelFraction[i][j]&#xf7;(256*MinCr), where MaxLumaSr and FormatCapabilityFactor are the values specified in Table A.2 and Table A.3 respectively, that apply to AU n, at level ref_level_idc[i], and MinCr is derived as indicated in A.4.2.<br/>For any subpicture set containing one ore more subpictures and consisting of a list of subpicture indices SubpicSetlndices and a number of subpictures in the subpicture set NumSubpicslnSet, the level information of the subpicture set is derived.<br/>The variable SubpicSetAccLevelFraction[i] for the total level fraction with respect to the reference level ref_level_idc[i], and the variables SubpicSetCpbSizeVcl[i], SubpicSetCpbSizeNal[i], SubpicSetBitRateVcl[i], and SubpicSetBitRateNal[i] of the subpicture set, are derived as follows:</li>    </ul>    </li></ul></p><p id="p-0103" num="0000"><tables id="TABLE-US-00027" num="00027"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="259pt" align="left"/><colspec colname="2" colwidth="35pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>for (i = 0; i &#x3c;= num_ref_level_minus1; i ++) {</entry><entry/></row><row><entry>&#x2003;SubpicSetAccLevelFraction[ i ] = 0</entry><entry/></row><row><entry>&#x2003;SubpicSetCpbSizeVcl[ i ] = 0</entry><entry/></row><row><entry>&#x2003;SubpicSetCpbSizeNal[ i ] = 0</entry><entry/></row><row><entry>&#x2003;SubpicSetNumTiles[ i ] = 0</entry><entry/></row><row><entry>&#x2003;for (j = 0; j &#x3c; NumSubpicsInSet; j ++) {</entry><entry/></row><row><entry>&#x2003;&#x2003;CurrSubpicIdx = SubpicSetIndices[ j ]</entry><entry/></row><row><entry>&#x2003;&#x2003;SubpicSetAccLevelFraction[ i ] += RefLevelFraction[ i ][ CurrSubpicIdx ]</entry><entry>(D.10)</entry></row><row><entry>&#x2003;&#x2003;SubpicSetCpbSizeVcl[ i ] += SubpicSetCpbSizeVcl[ i ][ CurrSubpicIdx ]</entry><entry/></row><row><entry>&#x2003;&#x2003;SubpicSetCpbSizeNal[ i ] += SubpicSetCpbSizeNal[ i ][ CurrSubpicIdx ]</entry><entry/></row><row><entry>&#x2003;&#x2003;SubpicSetBitRateVcl[ i ] += SubpicSetBitRateVcl[ i ][ CurrSubpicIdx ]</entry><entry/></row><row><entry>&#x2003;&#x2003;SubpicSetBitRateNal[ i ] += SubpicSetBitRateNal[ i ][ CurrSubpicIdx ]</entry><entry/></row><row><entry>&#x2003;&#x2003;SubpicSetNumTiles[ i ] += SubpicNumTileCols[ CurrSubpicIdx ] *</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;SubpicNumTileRow[ CurrSubpicIdx ]</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>The value of the subpicture set sequence level indicator, SubpicSetLevelIdc, is derived as follows:</p><p id="p-0104" num="0000"><tables id="TABLE-US-00028" num="00028"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="294pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>SubpicSetLevelIdc = general_level_idc</entry></row><row><entry>for (i = num_ref_level_minus1; i &#x3e;= 0; i&#x2212; &#x2212; )</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="259pt" align="left"/><colspec colname="2" colwidth="35pt" align="center"/><tbody valign="top"><row><entry>&#x2003;if( SubpicSetNumTiles[ i ] &#x3c;= ( MaxTileCols * MaxTileRows ) &#x26;&#x26;</entry><entry>(D.11)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="294pt" align="left"/><tbody valign="top"><row><entry>&#x2003;&#x2003;&#x2003;SubpicSetAccLevelFraction[ i ] &#x3c;= 256 )</entry></row><row><entry>&#x2003;&#x2003;SubpicSetLevelIdc = ref_level_idc[ i ]</entry></row><row><entry>where MaxTileCols and MaxTileRows are specified in Table A.1 for ref_level_idc[ i ]</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>The subpicture set bitstream conforming to a profile with general_tier_flag equal to 0 and a level equal to SubpicSetLevelIdc may obey the following constraints for each bitstream conformance test as specified in Annex C:<ul id="ul0022" list-style="none">    <li id="ul0022-0001" num="0000">    <ul id="ul0023" list-style="none">        <li id="ul0023-0001" num="0143">For the VCL HRD parameters, SubpicSetCpbSizeVcl[i] may be less than or equal to CpbVclFactor*MaxCPB, where CpbVclFactor is specified in Table A.3 and MaxCPB is specified in Table A.1 in units of CpbVclFactor bits.</li>        <li id="ul0023-0002" num="0144">For the NAL HRD parameters, SubpicSetCpbSizeNal[i] may be less than or equal to CpbNalFactor*MaxCPB, where CpbNalFactor is specified in Table A.3, and MaxCPB is specified in Table A.1 in units of CpbNalFactor bits.</li>        <li id="ul0023-0003" num="0145">For the VCL HRD parameters, SubpicSetBitRateVcl[i] may be less than or equal to CpbVclFactor*MaxBR, where CpbVclFactor is specified in Table A.3 and MaxBR is specified in Table A.1 in units of CpbVclFactor bits.</li>        <li id="ul0023-0004" num="0146">For the NAL HRD parameters, SubpicSetBitRateNal[i] may be less than or equal to CpbNalFactor*MaxCR, where CpbNalFactor is specified in Table A.3, and MaxBR is specified in Table A.1 in units of CpbNalFactor bits.</li>        <li id="ul0023-0005" num="0147">NOTE 2&#x2014;When a subpicture set is extracted, the resulting bitstream has a CpbSize (either indicated in the SPS or inferred) that is greater than or equal to SubpicSetCpbSizeVcl[i][j] and SubpicSetCpbSizeNal[i][j] and a BitRate (either indicated in the SPS or inferred) that is greater than or equal to SubpicSetBitRateVcl[i][j] and SubpicSetBitRateNal[i][j].</li>    </ul>    </li></ul></p><heading id="h-0036" level="1">4. Technical Problems Addressed by Disclosed Technical Solutions</heading><p id="p-0105" num="0148">The existing designs for subpictures and LMCS in VVC have the following problems:<ul id="ul0024" list-style="none">    <li id="ul0024-0001" num="0000">    <ul id="ul0025" list-style="none">        <li id="ul0025-0001" num="0149">1) The derivation of the list SubpicNumTileRows[ ] (specifying the number of tile rows included in a subpicture) is Equation D.5 is incorrect, as the index value idx in CtbToTileRowBd[idx] in the equation can be greater than the greatest allowed value. Furthermore, the deviation of both SubpicNumTileRows[ ] and SubpicNumTileCols[ ] (specifying the number of tile columns included in a subpicture) uses a CTU based operation, which is unnecessarily complicated.</li>        <li id="ul0025-0002" num="0150">2) The derivation of the array CtbAddrInSlice in Equation 29 when single_slice_per_subpic_flag is equal to 1 is incorrect, as the values of raster scan CTB addresses in the array for each slice needs to be in decoding order of CTUs instead of in raster scan order of CTUs.</li>        <li id="ul0025-0003" num="0151">3) The LMCS signalling is inefficient. When ph_lmcs_enabled_flag is equal to 1, in most cases LMCS would be enabled for all slices of the picture. However, in the current VVC design, for the case when LMCS is enabled for all slices of a picture, not only ph_lmcs_enabled_flag is equal to 1, the slice_lmcs_enabled_flag with value 1 needs to be signalled for each slice.        <ul id="ul0026" list-style="none">            <li id="ul0026-0001" num="0152">a. The semantics of ph_lmcs_enabled_flag is conflicting with the motivation of signalling slice level LMCS flag when ph_lmcs_enabled_flag is true. In current VVC, when ph_lmcs_enabled_flag is true, it means all slices may enable LMCS. Therefore, there is no need to further signal LMCS enabling flags in slice header.</li>            <li id="ul0026-0002" num="0153">b. In addition, when the picture header tells LMCS is enabled, typically, for all slices,</li>        </ul>        </li>    </ul>    </li></ul></p><p id="p-0106" num="0154">LMCS are all enabled. The controlling of LCMS in slice header is mainly for handling corner cases. Therefore, if the PH LMCS flag is true and SH LMCS flag is always signalled, which may result in unnecessary bits signalled for common user cases.<ul id="ul0027" list-style="none">    <li id="ul0027-0001" num="0000">    <ul id="ul0028" list-style="none">        <li id="ul0028-0001" num="0155">4) The semantics of the SPS affine AMVR flag is not correct since for each affine inter coded CU, the affine AMVR could be enabled or disabled.</li>    </ul>    </li></ul></p><heading id="h-0037" level="1">5. Examples of Techniques and Embodiments</heading><p id="p-0107" num="0156">To solve the above problems, and some other problems not mentioned, methods as summarized below are disclosed. The items should be considered as examples to explain the general concepts and should not be interpreted in a narrow way. Furthermore, these items can be applied individually or combined in any manner.</p><p id="p-0108" num="0157">Related to Subpictures for Solving the First and Second Problems<ul id="ul0029" list-style="none">    <li id="ul0029-0001" num="0000">    <ul id="ul0030" list-style="none">        <li id="ul0030-0001" num="0158">1. One or more of the following approaches are disclosed:        <ul id="ul0031" list-style="none">            <li id="ul0031-0001" num="0159">a. The tile column index of each CTU column of a picture is derived.</li>            <li id="ul0031-0002" num="0160">b. The derivation of the number of tile columns included in a subpicture is based on the tile column indices of the left-most and/or right-most CTUs included in the subpicture.</li>            <li id="ul0031-0003" num="0161">c. The tile row index of each CTU row of a picture is derived.</li>            <li id="ul0031-0004" num="0162">d. The derivation of the number of tile rows included in a subpicture is based on the tile row indices of the top and/or bottom CTUs included in the subpicture.</li>            <li id="ul0031-0005" num="0163">e. The term picture-level slice index is defined as follows: an index, defined when rect_slice_flag is equal to 1, of a slice to the list of slices in a picture in the order as the slices are signalled in the PPS when single_slice_per_subpic_flag is equal to 0, or in the order increasing subpicture indices of the subpicture corresponding to the slices when single_slice_per_subpic_flag is equal to 1.</li>            <li id="ul0031-0006" num="0164">f. In one example, the height of a subpicture may not be counted in terms of tiles when the subpicture contain a slice which is partitioned from a tile.</li>            <li id="ul0031-0007" num="0165">g. In one example, the height of a subpicture may be counted in terms of CTUs instead of tiles.</li>            <li id="ul0031-0008" num="0166">h. Whether the height of a subpicture is less than one tile row is derived.            <ul id="ul0032" list-style="none">                <li id="ul0032-0001" num="0167">i. In one example, whether the height of a subpicture is less than one tile row is derived to be true when the subpicture only includes CTUs from one tile row and when either the top CTUs in the subpicture are not the top CTUs of the tile row or the bottom CTUs in the subpicture are not the bottom CTUs of the tile row.</li>                <li id="ul0032-0002" num="0168">ii. When it is indicated that each subpicture contains only one slice and the height of a subpicture is less than one tile row, for each slice with picture-level slice index i of a picture, the value of CtbAddrInSlice[i][j] for j in the range of 0 to the number of CTUs in the slice minus 1, inclusive, is derived to be the picture raster scan CTU address of the j-th CTU in CTU raster scan of the subpicture.</li>                <li id="ul0032-0003" num="0169">iii. In one example, whether the height of a subpicture is less than one tile row is derived to be true when the distance between the top CTUs in the subpicture and the bottom CTUs in the subpicture are less than the height of a tile in terms of CTUs.</li>                <li id="ul0032-0004" num="0170">iv. When it is indicated that each subpicture contains only one slice and the height of a subpicture is greater than or equal to one tile row, for each slice with picture-level slice index i of a picture, the value of CtbAddrInSlice[i][j] for j in the range of 0 to the number of CTUs in the slice minus 1, inclusive, is derived to be the picture raster scan CTU address of the j-th CTU in the following order of CTUs:                <ul id="ul0033" list-style="none">                    <li id="ul0033-0001" num="0171">1) The CTUs in different tiles in the subpicture are ordered such that a first CTU in a first tile with a less value of tile index goes before a second CTU in a second tile with a greater value of tile index.</li>                    <li id="ul0033-0002" num="0172">2) The CTUs within one tile in the subpicture are ordered in CTU raster scan of the tile.</li>                </ul>                </li>            </ul>            </li>        </ul>        </li>    </ul>    </li></ul></p><p id="p-0109" num="0173">Related to LMCS for Solving the Third Problem (Including the Sub-Problems)<ul id="ul0034" list-style="none">    <li id="ul0034-0001" num="0000">    <ul id="ul0035" list-style="none">        <li id="ul0035-0001" num="0174">2. Two-level control of LMCS (which includes two aspects: luma mapping (reshaping process, denoted by RP) and luma dependent chroma residual scaling (CRS)) is introduced, wherein a higher level (e.g., a picture level) and a lower level (e.g., a slice level) control are used and whether the lower level control information is present is dependent on the high level control information. In addition, the following applies:        <ul id="ul0036" list-style="none">            <li id="ul0036-0001" num="0175">a. In a first example, one or more of the sub-bullets below is applied:            <ul id="ul0037" list-style="none">                <li id="ul0037-0001" num="0176">i. A first indicator (e.g., ph_lmcs_enabled_type) may be signalled at the higher level (e.g., in picture header (PH)) to specify how LMCS is enabled at lower level which is a non-binary value.                <ul id="ul0038" list-style="none">                    <li id="ul0038-0001" num="0177">1) In one example, when the first indicator is equal to X (e.g., X=2), it specifies that LMCS is enabled for all slices associated with the PH; when the first indicator is equal to Y(Y !=X) (e.g., Y=1), it specifies that LMCS is enabled for one, or more, but not all slices associated with the PH; when the first indicator is equal to Z(Z!=X and Z!=Y) (e.g., Z=0), it specifies that LMCS is disabled for all slices associated with the PH.</li>                    <li id="ul0038-0002" num="0000">&#x2003;a) Alternatively, furthermore, when the first indicator is not present, the value of the indicator is inferred to be equal to a default value, such as Z.</li>                    <li id="ul0038-0003" num="0178">2) In one example, when the first indicator is equal to X (e.g., X=2), it specifies that LMCS is disabled for all slices associated with the PH; when the first indicator is equal to Y (Y !=X) (e.g., Y=1), it specifies that LMCS is disabled for one, or more, but not all slices associated with the PH; when the first indicator is equal to Z(Z!=X and Z!=Y) (e.g., Z=0), it specifies that LMCS is enabled for all slices associated with the PH.</li>                    <li id="ul0038-0004" num="0000">&#x2003;a) Alternatively, furthermore, when the first indicator is not present, the value of the indicator is inferred to be equal to a default value, such as X.</li>                    <li id="ul0038-0005" num="0179">3) Alternatively, furthermore, the first indicator may be conditionally signalled according to the value of a LMCS enabling flag in sequence level (e.g., sps_lmcs_enabled_flag).</li>                    <li id="ul0038-0006" num="0180">4) Alternatively, furthermore, the first indicator may be coded with u(v), or u(2) or ue(v).</li>                    <li id="ul0038-0007" num="0181">5) Alternatively, furthermore, the first indicator may be coded with a truncated unary code.</li>                    <li id="ul0038-0008" num="0182">6) Alternatively, furthermore, the LMCS APS information (e.g., ph_lmcs_aps_id) used by slices and/or CS enabling flag (e.g., ph_chroma_residual_scale_flag) may be signalled under the condition check of the values of the first indicator.</li>                </ul>                </li>                <li id="ul0037-0002" num="0183">ii. A second indicator of enabling/disabling LMCS for the lower level (e.g., slice_lmcs_enabled_flag) may be signalled at the lower level (e.g., in slice header) and it may be conditionally signalled by checking the value of the first indicator.                <ul id="ul0039" list-style="none">                    <li id="ul0039-0001" num="0184">1) In one example, the second indicator may be signalled under the condition check of &#x2018;the first indicator is equal to Y&#x2019;.</li>                    <li id="ul0039-0002" num="0000">&#x2003;a) Alternatively, the second indicator may be signalled under the condition check of &#x2018;the value of first indicator&#x3e;&#x3e;1&#x2019; or &#x2018;the value of first indicator/2&#x2019; or &#x2018;the value of first indicator &#x26; 0x01&#x2019;.</li>                    <li id="ul0039-0003" num="0000">&#x2003;b) Alternatively, furthermore, it may be inferred to be enabled when the first indicator is equal to X; or inferred to be disabled when the first indicator is equal to Z.</li>                </ul>                </li>            </ul>            </li>            <li id="ul0036-0002" num="0185">b. In a second example, one or more of the sub-bullets below is applied:            <ul id="ul0040" list-style="none">                <li id="ul0040-0001" num="0186">i. More than one indicator may be signalled at the higher level (e.g., in picture header (PH)) to specify how LMCS is enabled at lower level which is a non-binary value.                <ul id="ul0041" list-style="none">                    <li id="ul0041-0001" num="0187">1) In one example, two indicators may be signalled in PH.</li>                    <li id="ul0041-0002" num="0000">&#x2003;a) In one example, a first indicator specifies whether there is at least one slice associated with the PH that enables LMCS. And second indicator specifies whether all slices associated with the PH enable LMCS.</li>                    <li id="ul0041-0003" num="0000">&#x2003;i. Alternatively, furthermore, the second indicator may be conditionally signalled according to the value of the first indicator, e.g., when the first indicator specifies there is at least one slice that enables LMCS.</li>                    <li id="ul0041-0004" num="0000">&#x2003;i. Alternatively, furthermore, when the second indicator is not present, it is inferred that all slices enable LMCS.</li>                    <li id="ul0041-0005" num="0000">&#x2003;ii. Alternatively, furthermore, a third indicator may be conditionally signalled in SH according to the value of the second indicator, e.g., when the second indicator specifies that not all of slices enable LMCS.</li>                    <li id="ul0041-0006" num="0000">&#x2003;i. Alternatively, furthermore, when the third indicator is not present, it may be inferred according to the value of the first and/or second indicator (e.g., inferred to be equal to the value of the first indicator).</li>                    <li id="ul0041-0007" num="0000">&#x2003;b) Alternatively, a first indicator specifies whether there is at least one slice associated with the PH that disable LMCS. And a second indicator specifies whether all slices associated with the PH disable LMCS.</li>                    <li id="ul0041-0008" num="0000">&#x2003;i. Alternatively, furthermore, the second indicator may be conditionally signalled according to the value of the first indicator, e.g., when the first indicator specifies there is at least one slice that disable LMCS.</li>                    <li id="ul0041-0009" num="0000">&#x2003;i. Alternatively, furthermore, when the second indicator is not present, it is inferred that all slices associated with the PH disable LMCS.</li>                    <li id="ul0041-0010" num="0000">&#x2003;ii. Alternatively, furthermore, a third indicator may be conditionally signalled in SH according to the value of the second indicator, e.g., when the second indicator specifies that not all of slices disable LMCS.</li>                    <li id="ul0041-0011" num="0000">&#x2003;i. Alternatively, furthermore, when the third indicator is not present, it may be inferred according to the value of the first and/or second indicator (e.g., inferred to be equal to the value of the first indicator).</li>                    <li id="ul0041-0012" num="0188">2) Alternatively, furthermore, the first indicator may be conditionally signalled according to the value of a LMCS enabling flag in sequence level (e.g., sps_lmcs_enabled_flag).</li>                </ul>                </li>                <li id="ul0040-0002" num="0189">ii. A third indicator of enabling/disabling LMCS for the lower level (e.g., slice_lmcs_enabled_flag) may be signalled at the lower level (e.g., in slice header) and it may be conditionally signalled by checking the value of the first indicator and/or second indicator.                <ul id="ul0042" list-style="none">                    <li id="ul0042-0001" num="0190">1) In one example, the third indicator may be signalled under the condition check of &#x2018;not all slices enable LMCS&#x2019; or &#x2018;not all slices disable LMCS&#x2019;.</li>                </ul>                </li>            </ul>            </li>            <li id="ul0036-0003" num="0191">c. In yet another example, the first and/or second and/or third indicator mentioned in the first/second example may be used to control the usage of RP or CRS instead of LMCS.</li>        </ul>        </li>        <li id="ul0035-0002" num="0192">3. The semantics of the three LMCS flags in the SPS/PH/SH are updated as follows:        <ul id="ul0043" list-style="none">            <li id="ul0043-0001" num="0193">sps_lmcs_enabled_flag equal to 1 specifies that luma mapping with chroma scaling [[is used]]<img id="CUSTOM-CHARACTER-00001" he="3.22mm" wi="16.59mm" file="US20230007308A1-20230105-P00001.TIF" alt="custom-character" img-content="character" img-format="tif"/> in the CLVS. sps_lmcs_enabled_flag equal to 0 specifies that luma mapping with chroma scaling is not used in the CLVS.</li>        </ul>        </li>        <li id="ul0035-0003" num="0194">ph_lmcs_enabled_flag equal to 1 specifies that luma mapping with chroma scaling [[is enabled]]<img id="CUSTOM-CHARACTER-00002" he="3.22mm" wi="16.59mm" file="US20230007308A1-20230105-P00002.TIF" alt="custom-character" img-content="character" img-format="tif"/> for all slices associated with the PH. ph_lmcs_enabled_flag equal to 0 specifies that luma mapping with chroma scaling [[may be disabled for one, or more, or]]<img id="CUSTOM-CHARACTER-00003" he="3.22mm" wi="20.83mm" file="US20230007308A1-20230105-P00003.TIF" alt="custom-character" img-content="character" img-format="tif"/> all slices associated with the PH. When not present, the value of ph_lmcs_enabled_flag is inferred to be equal to 0.</li>        <li id="ul0035-0004" num="0195">slice_lmcs_enabled_flag equal to 1 specifies that luma mapping with chroma scaling is [[enabled]]<img id="CUSTOM-CHARACTER-00004" he="2.46mm" wi="6.69mm" file="US20230007308A1-20230105-P00004.TIF" alt="custom-character" img-content="character" img-format="tif"/> for the current slice. slice_lmcs_enabled_flag equal to 0 specifies that luma mapping with chroma scaling is not [[enabled]]<img id="CUSTOM-CHARACTER-00005" he="2.46mm" wi="6.69mm" file="US20230007308A1-20230105-P00005.TIF" alt="custom-character" img-content="character" img-format="tif"/> for the current slice. When slice_lmcs_enabled_flag is not present, it is inferred to be equal to 0.</li>        <li id="ul0035-0005" num="0196">a. The PH and/or SH LMCS signalling is changed such that when LMCS is used for all slices of the picture, no LMCS signalling is present in the SH.        <ul id="ul0044" list-style="none">            <li id="ul0044-0001" num="0197">i. Alternatively, furthermore, how the LMCS is inferred depend on the PH LMCS signalling.            <ul id="ul0045" list-style="none">                <li id="ul0045-0001" num="0198">1) In one example, it is inferred to be enabled when LMCS is used for all slices of the picture; and it is inferred to be disabled when LMCS is not used for all slices of the picture.</li>            </ul>            </li>        </ul>        </li>    </ul>    </li></ul></p><p id="p-0110" num="0199">Related to Affine AMVR<ul id="ul0046" list-style="none">    <li id="ul0046-0001" num="0000">    <ul id="ul0047" list-style="none">        <li id="ul0047-0001" num="0200">4. The semantics of the Affine AMVR flag in the SPS are updated as follows: sps_affine_amvr_enabled_flag equal to 1 specifies that adaptive motion vector difference resolution [[is]]<img id="CUSTOM-CHARACTER-00006" he="3.22mm" wi="9.91mm" file="US20230007308A1-20230105-P00006.TIF" alt="custom-character" img-content="character" img-format="tif"/> used in motion vector coding of affine inter mode.</li>        <li id="ul0047-0002" num="0201">sps_affine_amvr_enabled_flag equal to 0 specifies that adaptive motion vector difference resolution is not used in motion vector coding of affine inter mode. When not present, the value of sps_affine_amvr_enabled_flag is inferred to be equal to 0.</li>    </ul>    </li></ul></p><heading id="h-0038" level="1">6. Embodiments</heading><heading id="h-0039" level="1">6.1. Embodiment 1: Support of Subpictures</heading><p id="p-0111" num="0202">This embodiment is for item 1 and its sub-items.</p><heading id="h-0040" level="1">3 Definitions</heading><p id="p-0112" num="0000"><ul id="ul0048" list-style="none">    <li id="ul0048-0001" num="0000">    <ul id="ul0049" list-style="none">        <li id="ul0049-0001" num="0203"><img id="CUSTOM-CHARACTER-00007" he="3.22mm" wi="32.43mm" file="US20230007308A1-20230105-P00007.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00008" he="3.22mm" wi="31.41mm" file="US20230007308A1-20230105-P00008.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00009" he="3.22mm" wi="36.66mm" file="US20230007308A1-20230105-P00009.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00010" he="3.22mm" wi="12.02mm" file="US20230007308A1-20230105-P00010.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00011" he="2.46mm" wi="22.94mm" file="US20230007308A1-20230105-P00011.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00012" he="2.46mm" wi="26.84mm" file="US20230007308A1-20230105-P00012.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00013" he="2.46mm" wi="23.62mm" file="US20230007308A1-20230105-P00013.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00014" he="2.46mm" wi="19.73mm" file="US20230007308A1-20230105-P00014.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00015" he="2.46mm" wi="21.17mm" file="US20230007308A1-20230105-P00015.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00016" he="2.46mm" wi="17.27mm" file="US20230007308A1-20230105-P00016.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00017" he="2.46mm" wi="25.40mm" file="US20230007308A1-20230105-P00017.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00018" he="2.46mm" wi="26.84mm" file="US20230007308A1-20230105-P00012.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00019" he="2.46mm" wi="23.62mm" file="US20230007308A1-20230105-P00013.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00020" he="2.46mm" wi="18.71mm" file="US20230007308A1-20230105-P00018.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00021" he="2.46mm" wi="32.85mm" file="US20230007308A1-20230105-P00019.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00022" he="2.46mm" wi="25.06mm" file="US20230007308A1-20230105-P00020.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00023" he="2.46mm" wi="31.07mm" file="US20230007308A1-20230105-P00021.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00024" he="2.46mm" wi="4.57mm" file="US20230007308A1-20230105-P00022.TIF" alt="custom-character" img-content="character" img-format="tif"/></li>        <li id="ul0049-0002" num="0204">[[picture-level slice index: An index of a slice to the list of slices in a picture in the order as they are signalled in the PPS when the rect_slice_flag is equal to 1.]]</li>    </ul>    </li></ul></p><heading id="h-0041" level="2">6.5.1 CTB Raster Scanning, Tile Scanning, and Subpicture Scanning Processes</heading><p id="p-0113" num="0205">The <img id="CUSTOM-CHARACTER-00025" he="2.46mm" wi="4.23mm" file="US20230007308A1-20230105-P00023.TIF" alt="custom-character" img-content="character" img-format="tif"/> CtbToTileColBd[ctbAddrX]<img id="CUSTOM-CHARACTER-00026" he="2.46mm" wi="32.43mm" file="US20230007308A1-20230105-P00024.TIF" alt="custom-character" img-content="character" img-format="tif"/> for ctbAddrX ranging from 0 to PicWidthInCtbsY, inclusive, specifying the conversion from a horizontal CTB address to a left tile column boundary in units of CTBs <img id="CUSTOM-CHARACTER-00027" he="2.46mm" wi="27.52mm" file="US20230007308A1-20230105-P00025.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00028" he="3.22mm" wi="21.17mm" file="US20230007308A1-20230105-P00026.TIF" alt="custom-character" img-content="character" img-format="tif"/> respectively, are derived as follows:</p><p id="p-0114" num="0000"><tables id="TABLE-US-00029" num="00029"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>tileX = 0</entry></row><row><entry>for( ctbAddrX = 0; ctbAddrX &#x3c;= PicWidthInCtbsY; ctbAddrX++ ) {</entry></row><row><entry>&#x2003;if( ctbAddrX = = tileColBd[ tileX + 1 ] )</entry></row><row><entry>&#x2003;&#x2003;(27)</entry></row><row><entry>&#x2003;&#x2003;tileX++</entry></row><row><entry>&#x2003;CtbToTileColBd[ ctbAddrX ] = tileColBd[ tileX ]</entry></row><row><entry>&#x2003;<img id="CUSTOM-CHARACTER-00029" he="2.46mm" wi="17.61mm" file="US20230007308A1-20230105-P00027.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;<img id="CUSTOM-CHARACTER-00030" he="2.46mm" wi="11.68mm" file="US20230007308A1-20230105-P00028.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;<img id="CUSTOM-CHARACTER-00031" he="1.78mm" wi="7.45mm" file="US20230007308A1-20230105-P00029.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>}</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><ul id="ul0050" list-style="none">    <li id="ul0050-0001" num="0000">    <ul id="ul0051" list-style="none">        <li id="ul0051-0001" num="0206">NOTE 3&#x2014;The size of the <img id="CUSTOM-CHARACTER-00032" he="2.46mm" wi="8.47mm" file="US20230007308A1-20230105-P00030.TIF" alt="custom-character" img-content="character" img-format="tif"/> CtbToTileColBd[ ] and <img id="CUSTOM-CHARACTER-00033" he="3.22mm" wi="29.29mm" file="US20230007308A1-20230105-P00031.TIF" alt="custom-character" img-content="character" img-format="tif"/> in the above derivation <img id="CUSTOM-CHARACTER-00034" he="2.46mm" wi="4.57mm" file="US20230007308A1-20230105-P00032.TIF" alt="custom-character" img-content="character" img-format="tif"/> one greater than the actual picture width in CTBs.<br/>The lists CtbToTileRowBd[ctbAddrY]<img id="CUSTOM-CHARACTER-00035" he="3.22mm" wi="42.67mm" file="US20230007308A1-20230105-P00033.TIF" alt="custom-character" img-content="character" img-format="tif"/> for ctbAddrY ranging from 0 to PicHeightInCtbsY, inclusive, specifying the conversion from a vertical CTB address to a top tile column boundary in units of CTBs <img id="CUSTOM-CHARACTER-00036" he="3.22mm" wi="30.31mm" file="US20230007308A1-20230105-P00034.TIF" alt="custom-character" img-content="character" img-format="tif"/> respectively, <img id="CUSTOM-CHARACTER-00037" he="2.46mm" wi="4.57mm" file="US20230007308A1-20230105-P00035.TIF" alt="custom-character" img-content="character" img-format="tif"/> derived as follows:</li>    </ul>    </li></ul></p><p id="p-0115" num="0000"><tables id="TABLE-US-00030" num="00030"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>tileY = 0</entry></row><row><entry>for( ctbAddrY = 0; ctbAddrY &#x3c;= PicHeightInCtbsY; ctbAddrY++ ) {</entry></row><row><entry>&#x2003;if( ctbAddrY = = tileRowBd[ tileY + 1 ] )</entry></row><row><entry>&#x2003;(28)</entry></row><row><entry>&#x2003;&#x2003;tileY++</entry></row><row><entry>&#x2003;CtbToTileRowBd[ ctbAddrY ] = tileRowBd[ tileY ]</entry></row><row><entry>&#x2003;<img id="CUSTOM-CHARACTER-00038" he="2.46mm" wi="29.29mm" file="US20230007308A1-20230105-P00036.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;<img id="CUSTOM-CHARACTER-00039" he="2.46mm" wi="6.69mm" file="US20230007308A1-20230105-P00037.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>}</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><ul id="ul0052" list-style="none">    <li id="ul0052-0001" num="0000">    <ul id="ul0053" list-style="none">        <li id="ul0053-0001" num="0207">NOTE 4&#x2014;The sizes of the arrays CtbToTileRowBd[ ]<img id="CUSTOM-CHARACTER-00040" he="3.22mm" wi="30.73mm" file="US20230007308A1-20230105-P00038.TIF" alt="custom-character" img-content="character" img-format="tif"/> in the above derivation are one greater than the actual picture height in CTBs.<br/><img id="CUSTOM-CHARACTER-00041" he="3.22mm" wi="41.32mm" file="US20230007308A1-20230105-P00039.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00042" he="3.22mm" wi="37.08mm" file="US20230007308A1-20230105-P00040.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00043" he="3.22mm" wi="30.31mm" file="US20230007308A1-20230105-P00041.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00044" he="3.22mm" wi="48.34mm" file="US20230007308A1-20230105-P00042.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00045" he="3.22mm" wi="37.08mm" file="US20230007308A1-20230105-P00043.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00046" he="3.22mm" wi="36.66mm" file="US20230007308A1-20230105-P00044.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00047" he="2.79mm" wi="33.19mm" file="US20230007308A1-20230105-P00045.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00048" he="3.22mm" wi="31.41mm" file="US20230007308A1-20230105-P00046.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00049" he="3.22mm" wi="52.24mm" file="US20230007308A1-20230105-P00047.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00050" he="3.22mm" wi="4.91mm" file="US20230007308A1-20230105-P00048.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00051" he="3.22mm" wi="38.78mm" file="US20230007308A1-20230105-P00049.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00052" he="3.22mm" wi="49.36mm" file="US20230007308A1-20230105-P00050.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00053" he="3.22mm" wi="35.64mm" file="US20230007308A1-20230105-P00051.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00054" he="3.22mm" wi="25.74mm" file="US20230007308A1-20230105-P00052.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00055" he="3.22mm" wi="22.94mm" file="US20230007308A1-20230105-P00053.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00056" he="3.22mm" wi="29.29mm" file="US20230007308A1-20230105-P00054.TIF" alt="custom-character" img-content="character" img-format="tif"/></li>    </ul>    </li></ul></p><p id="p-0116" num="0000"><tables id="TABLE-US-00031" num="00031"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry><img id="CUSTOM-CHARACTER-00057" he="2.46mm" wi="25.74mm" file="US20230007308A1-20230105-P00055.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;<img id="CUSTOM-CHARACTER-00058" he="2.46mm" wi="24.72mm" file="US20230007308A1-20230105-P00056.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;&#x2003;<img id="CUSTOM-CHARACTER-00059" he="2.46mm" wi="15.49mm" file="US20230007308A1-20230105-P00057.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;<img id="CUSTOM-CHARACTER-00060" he="2.46mm" wi="18.03mm" file="US20230007308A1-20230105-P00058.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;&#x2003;<img id="CUSTOM-CHARACTER-00061" he="2.79mm" wi="23.62mm" file="US20230007308A1-20230105-P00059.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;<img id="CUSTOM-CHARACTER-00062" he="2.46mm" wi="20.15mm" file="US20230007308A1-20230105-P00060.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;&#x2003;<img id="CUSTOM-CHARACTER-00063" he="2.46mm" wi="26.08mm" file="US20230007308A1-20230105-P00061.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;<img id="CUSTOM-CHARACTER-00064" he="2.46mm" wi="29.63mm" file="US20230007308A1-20230105-P00062.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;<img id="CUSTOM-CHARACTER-00065" he="2.79mm" wi="29.97mm" file="US20230007308A1-20230105-P00063.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;&#x2003;<img id="CUSTOM-CHARACTER-00066" he="2.79mm" wi="33.53mm" file="US20230007308A1-20230105-P00064.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;&#x2003;<img id="CUSTOM-CHARACTER-00067" he="2.79mm" wi="25.06mm" file="US20230007308A1-20230105-P00065.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;<img id="CUSTOM-CHARACTER-00068" he="2.46mm" wi="20.83mm" file="US20230007308A1-20230105-P00066.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;&#x2003;<img id="CUSTOM-CHARACTER-00069" he="2.79mm" wi="27.18mm" file="US20230007308A1-20230105-P00067.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;<img id="CUSTOM-CHARACTER-00070" he="2.46mm" wi="28.96mm" file="US20230007308A1-20230105-P00068.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;<img id="CUSTOM-CHARACTER-00071" he="2.79mm" wi="30.31mm" file="US20230007308A1-20230105-P00069.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;&#x2003;<img id="CUSTOM-CHARACTER-00072" he="2.79mm" wi="27.86mm" file="US20230007308A1-20230105-P00070.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;<img id="CUSTOM-CHARACTER-00073" he="2.46mm" wi="32.43mm" file="US20230007308A1-20230105-P00071.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;<img id="CUSTOM-CHARACTER-00074" he="2.46mm" wi="18.71mm" file="US20230007308A1-20230105-P00072.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;<img id="CUSTOM-CHARACTER-00075" he="2.79mm" wi="22.27mm" file="US20230007308A1-20230105-P00073.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;&#x2003;&#x2003;<img id="CUSTOM-CHARACTER-00076" he="2.79mm" wi="23.96mm" file="US20230007308A1-20230105-P00074.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;<img id="CUSTOM-CHARACTER-00077" he="2.79mm" wi="20.49mm" file="US20230007308A1-20230105-P00075.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;<img id="CUSTOM-CHARACTER-00078" he="2.46mm" wi="1.44mm" file="US20230007308A1-20230105-P00076.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry><img id="CUSTOM-CHARACTER-00079" he="2.79mm" wi="37.08mm" file="US20230007308A1-20230105-P00077.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;<img id="CUSTOM-CHARACTER-00080" he="2.79mm" wi="24.72mm" file="US20230007308A1-20230105-P00078.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;<img id="CUSTOM-CHARACTER-00081" he="2.79mm" wi="30.73mm" file="US20230007308A1-20230105-P00079.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;<img id="CUSTOM-CHARACTER-00082" he="2.46mm" wi="31.75mm" file="US20230007308A1-20230105-P00080.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry><img id="CUSTOM-CHARACTER-00083" he="2.46mm" wi="40.89mm" file="US20230007308A1-20230105-P00081.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry><img id="CUSTOM-CHARACTER-00084" he="2.79mm" wi="17.27mm" file="US20230007308A1-20230105-P00082.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;<img id="CUSTOM-CHARACTER-00085" he="2.79mm" wi="16.59mm" file="US20230007308A1-20230105-P00083.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;<img id="CUSTOM-CHARACTER-00086" he="2.46mm" wi="31.07mm" file="US20230007308A1-20230105-P00084.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;<img id="CUSTOM-CHARACTER-00087" he="2.46mm" wi="20.15mm" file="US20230007308A1-20230105-P00085.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;<img id="CUSTOM-CHARACTER-00088" he="2.46mm" wi="25.06mm" file="US20230007308A1-20230105-P00086.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;<img id="CUSTOM-CHARACTER-00089" he="1.78mm" wi="16.26mm" file="US20230007308A1-20230105-P00087.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;<img id="CUSTOM-CHARACTER-00090" he="2.46mm" wi="34.21mm" file="US20230007308A1-20230105-P00088.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><ul id="ul0054" list-style="none">    <li id="ul0054-0001" num="0000">    <ul id="ul0055" list-style="none">        <li id="ul0055-0001" num="0208"><img id="CUSTOM-CHARACTER-00091" he="3.22mm" wi="47.24mm" file="US20230007308A1-20230105-P00089.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00092" he="3.22mm" wi="40.56mm" file="US20230007308A1-20230105-P00090.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00093" he="2.46mm" wi="24.38mm" file="US20230007308A1-20230105-P00091.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00094" he="2.46mm" wi="30.73mm" file="US20230007308A1-20230105-P00092.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00095" he="2.46mm" wi="31.41mm" file="US20230007308A1-20230105-P00093.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00096" he="2.12mm" wi="29.29mm" file="US20230007308A1-20230105-P00094.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00097" he="2.46mm" wi="39.54mm" file="US20230007308A1-20230105-P00095.TIF" alt="custom-character" img-content="character" img-format="tif"/><br/>When rect_slice_flag is equal to 1, the list NumCtusInSlice[i] for i ranging from 0 to num_slices_in_pic_minus1, inclusive, specifying the number of CTUs in the i-th slice, the list SliceTopLeftTileIdx[i] for i ranging from 0 to num_slices_in_pic_minus1, inclusive, specifying the tile index of the tile containing the first CTU in the slice, and the matrix CtbAddrInSlice[i][j] for i ranging from 0 to num_slices_in_pic_minus1, inclusive, and j ranging from 0 to NumCtusInSlice[i]&#x2212;1, inclusive, specifying the picture raster scan address of the j-th CTB within the i-th slice, and the variable NumSlicesInTile[i], specifying the number of slices in the tile containing the i-th slice, are derived as follows:</li>    </ul>    </li></ul></p><p id="p-0117" num="0000"><tables id="TABLE-US-00032" num="00032"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;if( single_slice_per_subpic_flag ) {</entry></row><row><entry>&#x2003;&#x2003;<img id="CUSTOM-CHARACTER-00098" he="2.46mm" wi="21.17mm" file="US20230007308A1-20230105-P00096.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;<img id="CUSTOM-CHARACTER-00099" he="2.46mm" wi="24.72mm" file="US20230007308A1-20230105-P00097.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;&#x2003;&#x2003;<img id="CUSTOM-CHARACTER-00100" he="2.46mm" wi="22.27mm" file="US20230007308A1-20230105-P00098.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;&#x2003;&#x2003;<img id="CUSTOM-CHARACTER-00101" he="2.46mm" wi="42.33mm" file="US20230007308A1-20230105-P00099.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;<img id="CUSTOM-CHARACTER-00102" he="2.46mm" wi="37.08mm" file="US20230007308A1-20230105-P00100.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;<img id="CUSTOM-CHARACTER-00103" he="2.46mm" wi="22.61mm" file="US20230007308A1-20230105-P00101.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;<img id="CUSTOM-CHARACTER-00104" he="2.46mm" wi="25.74mm" file="US20230007308A1-20230105-P00102.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;<img id="CUSTOM-CHARACTER-00105" he="2.46mm" wi="19.05mm" file="US20230007308A1-20230105-P00103.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;<img id="CUSTOM-CHARACTER-00106" he="2.46mm" wi="25.06mm" file="US20230007308A1-20230105-P00104.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009; + &#x2009;<img id="CUSTOM-CHARACTER-00107" he="2.46mm" wi="28.19mm" file="US20230007308A1-20230105-P00105.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;<img id="CUSTOM-CHARACTER-00108" he="2.46mm" wi="25.40mm" file="US20230007308A1-20230105-P00106.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;<img id="CUSTOM-CHARACTER-00109" he="2.46mm" wi="25.40mm" file="US20230007308A1-20230105-P00107.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009; + &#x2009;<img id="CUSTOM-CHARACTER-00110" he="2.46mm" wi="28.96mm" file="US20230007308A1-20230105-P00108.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;&#x2003;&#x2003;<img id="CUSTOM-CHARACTER-00111" he="2.46mm" wi="29.63mm" file="US20230007308A1-20230105-P00109.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;<img id="CUSTOM-CHARACTER-00112" he="2.46mm" wi="25.40mm" file="US20230007308A1-20230105-P00110.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;<img id="CUSTOM-CHARACTER-00113" he="2.79mm" wi="1.10mm" file="US20230007308A1-20230105-P00111.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;<img id="CUSTOM-CHARACTER-00114" he="2.46mm" wi="10.24mm" file="US20230007308A1-20230105-P00112.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;<img id="CUSTOM-CHARACTER-00115" he="2.46mm" wi="25.06mm" file="US20230007308A1-20230105-P00113.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;<img id="CUSTOM-CHARACTER-00116" he="2.46mm" wi="27.52mm" file="US20230007308A1-20230105-P00114.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;<img id="CUSTOM-CHARACTER-00117" he="2.46mm" wi="25.74mm" file="US20230007308A1-20230105-P00115.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;<img id="CUSTOM-CHARACTER-00118" he="2.46mm" wi="27.52mm" file="US20230007308A1-20230105-P00116.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;<img id="CUSTOM-CHARACTER-00119" he="2.46mm" wi="45.55mm" file="US20230007308A1-20230105-P00117.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;<img id="CUSTOM-CHARACTER-00120" he="2.46mm" wi="14.82mm" file="US20230007308A1-20230105-P00118.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;<img id="CUSTOM-CHARACTER-00121" he="2.46mm" wi="31.07mm" file="US20230007308A1-20230105-P00119.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;<img id="CUSTOM-CHARACTER-00122" he="2.46mm" wi="16.59mm" file="US20230007308A1-20230105-P00120.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;<img id="CUSTOM-CHARACTER-00123" he="2.46mm" wi="25.40mm" file="US20230007308A1-20230105-P00121.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;<img id="CUSTOM-CHARACTER-00124" he="2.46mm" wi="25.74mm" file="US20230007308A1-20230105-P00122.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;<img id="CUSTOM-CHARACTER-00125" he="2.46mm" wi="22.27mm" file="US20230007308A1-20230105-P00123.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;<img id="CUSTOM-CHARACTER-00126" he="2.46mm" wi="26.84mm" file="US20230007308A1-20230105-P00124.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;&#x2003;&#x2003;<img id="CUSTOM-CHARACTER-00127" he="2.46mm" wi="1.44mm" file="US20230007308A1-20230105-P00125.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;&#x2003;<img id="CUSTOM-CHARACTER-00128" he="2.46mm" wi="1.44mm" file="US20230007308A1-20230105-P00125.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry>&#x2003;[[ for( i = 0; i &#x3c;= sps_num_subpics_minus1; i++ )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;NumCtusInSlice[ i ] = 0</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c; PicSizeInCtbsY; i ++ ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;sliceIdx = subpic_info_present_flag ? CtbToSubpicIdx[ i ] : 0</entry></row><row><entry>&#x2003;&#x2003;&#x2003;CtbAddrInSlice[ sliceIdx ][ NumCtusInSlice[ sliceIdx ] ] = i</entry></row><row><entry>&#x2003;&#x2003;&#x2003;NumCtusInSlice[ sliceIdx ]++</entry></row><row><entry>&#x2003;&#x2003;}]]</entry></row><row><entry>&#x2003;} else {</entry></row><row><entry>&#x2003;&#x2003;tileIdx = 0</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c;= num_slices_in_pic_minus1; i++ )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;NumCtusInSlice[ i ] = 0</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c;= num_slices_in_pic_minus1; i++ ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;SliceTopLeftTileIdx[ i ] = tileIdx</entry></row><row><entry>&#x2003;&#x2003;&#x2003;tileX = tileIdx % NumTileColumns</entry></row><row><entry>&#x2003;&#x2003;&#x2003;tileY = tileIdx / NumTileColumns</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( i &#x3c; num_slices_in_pic_minus1 ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;sliceWidthInTiles[ i ] = slice_width_in_tiles_minus1[ i ] + 1</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;sliceHeightInTiles[ i ] = slice_height_in_tiles_minus1[ i ] + 1</entry></row><row><entry>&#x2003;&#x2003;&#x2003;} else {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;sliceWidthInTiles[ i ] = NumTileColumns &#x2212; tileX</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;sliceHeightInTiles[ i ] = NumTileRows &#x2212; tileY</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;NumSlicesInTile[ i ] = 1</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( slicWidthInTiles[ i ] = = 1 &#x26;&#x26; sliceHeightInTiles[ i ] = = 1 ) {&#x2003;&#x2003;(30)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( num_exp_slices_in_tile[ i ] = = 0 ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;NumSlicesInTile[ i ] = 1</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;sliceHeightInCtus[ i ] =</entry></row><row><entry>&#x2003;RowHeight[ SliceTopLeftTileIdx[ i ] / NumTileColumns ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;} else {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;remainingHeightInCtbsY =</entry></row><row><entry>&#x2003;RowHeight[ SliceTopLeftTileIdx[ i ] / NumTileColumns ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c; num_exp_slices_in_tile[ i ] &#x2212; 1; j++) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;sliceHeightInCtus[ i + j ] = exp_slice_height_in_ctus_minus1[ i ][ j ] + 1</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;remainingHeightInCtbsY &#x2212;= sliceHeightInCtus[ i + j ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;uniformSliceHeight = exp_slice_height_in_ctus_minus1[ i ][ j ] + 1</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;while( remainingHeightInCtbsY &#x3e;= uniformSliceHeight ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;sliceHeightInCtus[ i + j ] = uniformSliceHeight</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;remainingHeightInCtbsY &#x2212;= uniformSliceHeight</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;j++</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if( remainingHeightInCtbsY &#x3e; 0 ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;sliceHeightInCtus[ i + j ] = remainingHeightInCtbsY</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;j++</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;NumSlicesInTile[ i ] = j</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ctbY = tileRowBd[ tileY ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c; NumSlicesInTile i ]; j++ ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;AddCtbsToSlice( i, tileColBd[ tileX ], tileColBd[ tileX + 1 ],</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;ctbY, ctbY + sliceHeightInCtus[ i ] )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;ctbY += sliceHeightInCtus[ i ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if( j &#x3c; NumSlicesInTile[ i ] - 1 )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;i++</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;&#x2003;} else</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c; sliceHeightInTiles[ i ]; j++ )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;for( k = 0; k &#x3c; sliceWidthInTiles[ i ]; k++ )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;AddCtbsToSlice( i, tileColBd[ tileX + k ], tileColBd[ tileX + k + 1 ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;tileRowBd[ tileY + j ], tileRowBd[ tileY + j + 1 ])</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( i &#x3c; num_slices_in_pic_minus1 ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( tile_idx_delta_present_flag)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;tileIdx += tile_idx_delta[ i ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;else {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;tileIdx += sliceWidthInTiles[ i ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if( tileIdx % NumTileColumns = = 0 )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;tileIdx += ( sliceHeightInTiles[ i ] &#x2212; 1 ) * NumTileColumns</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;}</entry></row><row><entry>....</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0042" level="2">D.7.2 Subpicture Level Information SEI Message Semantics</heading><p id="p-0118" num="0209">ref_level_fraction_minus1[i][j] plus 1 specifies the fraction of the level limits associated with ref_level_idc[i] that the j-th subpicture conforms to as specified in clause A.4.1.<br/>The variable SubpicSizeY[j] is set equal to (subpic_width_minus1 [j]+1)*CtbSizeY*(subpic_height_minus1[j]+1)*CtbSizeY When not present, the value of ref_level_fraction_minus1[i][j] is inferred to be equal to Ceil(256*SubpicSizeY[j]&#xf7;PicSizeInSamplesY*MaxLumaPs(general_level_idc)&#xf7;MaxLu maPs(ref_level_idc[i])&#x2212;1.<br/>The variable RefLevelFraction[i][j] is set equal to ref_level_fraction_minus1[i][j]+1. [[The variables SubpicNumTileCols[j] and SubpicNumTileRows[j] are derived as follows:</p><p id="p-0119" num="0000"><tables id="TABLE-US-00033" num="00033"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>for( i = 0; i &#x3c;= sps_num_subpics_minus1; i++) {</entry></row><row><entry>&#x2003;SubpicNumTileCols[ i ] = 1</entry></row><row><entry>&#x2003;SubpicNumTileRows[ i ] = 1</entry></row><row><entry>&#x2003;for( ctbAddrRs = subpic_ctu_top_left_x[ i ] + 1; ctbAddrRs &#x3c;=</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;subpic_ctu_top_left_x[ i ] + subpic_width_minus1[ i ]; ctbAddrRs++ )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( CtbToTileColBd[ ctbAddrRs ] != CtbToTileColBd[ ctbAddrRs &#x2212; 1 ] )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;SubpicNumTileCols[ i ]++ &#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;(D.5)</entry></row><row><entry>&#x2003;&#x2003;for( ctbAddrRs = ( subpic_ctu_top_left_y[ i ] + 1 ) * PicWidthInCtbsY;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ctbAddrRs &#x3c;= ( subpic_ctu_top_left_y[ i ] + subpic_height_minus1[ i ]</entry></row><row><entry>&#x2003;) * PicWidthInCtbsY;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ctbAddrRs += PicWidthInCtbsY )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( CtbToTileRowBd[ ctbAddrRs ] !=</entry></row><row><entry>&#x2003;CtbToTileRowBd[ ctbAddrRs &#x2212; PicWidthInCtbsY ] )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;SubpicNumTileRows[ i ]++</entry></row><row><entry>&#x2003;}]]</entry></row><row><entry>. . .</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><ul id="ul0056" list-style="none">    <li id="ul0056-0001" num="0000">    <ul id="ul0057" list-style="none">        <li id="ul0057-0001" num="0210">The value of <img id="CUSTOM-CHARACTER-00129" he="3.22mm" wi="26.08mm" file="US20230007308A1-20230105-P00126.TIF" alt="custom-character" img-content="character" img-format="tif"/>[j] may be less than or equal to MaxTileCols and of <img id="CUSTOM-CHARACTER-00130" he="3.22mm" wi="27.52mm" file="US20230007308A1-20230105-P00127.TIF" alt="custom-character" img-content="character" img-format="tif"/>[j] may be less than or equal to MaxTileRows, where MaxTileCols and MaxTileRows are specified in Table A.1 for level ref_level_idc[i].</li>        <li id="ul0057-0002" num="0211">The value of <img id="CUSTOM-CHARACTER-00131" he="3.22mm" wi="26.08mm" file="US20230007308A1-20230105-P00128.TIF" alt="custom-character" img-content="character" img-format="tif"/>[j]*<img id="CUSTOM-CHARACTER-00132" he="3.22mm" wi="27.52mm" file="US20230007308A1-20230105-P00129.TIF" alt="custom-character" img-content="character" img-format="tif"/>[j] may be less than or equal to MaxTileCols*MaxTileRows*RefLevelFraction[i][j], where MaxTileCols and MaxTileRows are specified in Table A.1 for level ref_level_idc[i].<br/>The variable SubpicSetAccLevelFraction[i] for the total level fraction with respect to the reference level ref_level_idc[i], and the variables SubpicSetCpbSizeVcl[i], SubpicSetCpbSizeNal[i], SubpicSetBitRateVcl[i], and SubpicSetBitRateNal[i] of the subpicture set, are derived as follows:</li>    </ul>    </li></ul></p><p id="p-0120" num="0000"><tables id="TABLE-US-00034" num="00034"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="266pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;for (i = 0; i &#x3c;= num_ref_level_minus1; i ++) {</entry></row><row><entry>&#x2003;&#x2003;SubpicSetAccLevelFraction[ i ] = 0</entry></row><row><entry>&#x2003;&#x2003;SubpicSetCpbSizeVcl[ i ] = 0</entry></row><row><entry>&#x2003;&#x2003;SubpicSetCpbSizeNal[ i ] = 0</entry></row><row><entry>&#x2003;&#x2003;SubpicSetNumTiles[ i ] = 0</entry></row><row><entry>&#x2003;&#x2003;for (j = 0; j &#x3c; NumSubpicsInSet; j ++) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;CurrSubpicIdx = SubpicSetIndices[ j ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;SubpicSetAccLevelFraction[ i ] += RefLevelFraction[ i ][ CurrSubpicIdx ] (D.10)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;SubpicSetCpbSizeVcl[ i ] += SubpicSetCpbSizeVcl[ i ][ CurrSubpicIdx ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;SubpicSetCpbSizeNal[ i ] += SubpicSetCpbSizeNal[ i ][ CurrSubpicIdx ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;SubpicSetBitRateVcl[ i ] += SubpicSetBitRateVcl[ i ][ CurrSubpicIdx ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;SubpicSetBitRateNal[ i ] += SubpicSetBitRateNal[ i ][ CurrSubpicIdx ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;SubpicSetNumTiles[ i ] += &#x2009;<img id="CUSTOM-CHARACTER-00133" he="2.79mm" wi="20.49mm" file="US20230007308A1-20230105-P00130.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;[ CurrSubpicIdx ] *</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;<img id="CUSTOM-CHARACTER-00134" he="2.46mm" wi="21.51mm" file="US20230007308A1-20230105-P00131.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;[ CurrSubpicIdx ]</entry></row><row><entry>&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;}</entry></row><row><entry>. . .</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0043" level="1">6.2. Embodiment 2: Support of LMCS</heading><p id="p-0121" num="0212">In this embodiment, the syntax and semantics of LMCS related syntax elements in picture header are modified, such that when LMCS is used for all slices of the picture, no LMCS signalling is present in the SH.</p><heading id="h-0044" level="2">7.3.2.7 Picture Header Structure Syntax</heading><p id="p-0122" num="0213"></p><p id="p-0123" num="0000"><tables id="TABLE-US-00035" num="00035"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="182pt" align="left"/><colspec colname="2" colwidth="35pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>picture_header_structure( ) {</entry><entry/></row><row><entry>&#x2003;gdr_or_irap_pic_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( gdr_or_irap_pic_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;gdr_pic_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;ph_inter_slice_allowed_flag</entry><entry>u(I)</entry></row><row><entry>&#x2003;if( ph_inter_slice_allowed_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;ph_intra_slice_allowed_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;non_reference_picture_flag</entry><entry>u(I)</entry></row><row><entry>&#x2003;ph_pic_parameter_set_id</entry><entry>ue(v)</entry></row><row><entry>&#x2003;ph_pic_order_cnt_lsb</entry><entry>u(v)</entry></row><row><entry>&#x2003;if( gdr_or_irap_pic_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;no_output_of_prior_pics_flag</entry><entry>u(I)</entry></row><row><entry>&#x2003;if( gdr_pic_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;recovery_poc_cnt</entry><entry>ue(v)</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c; NumExtraPhBits; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;ph_extra_bit[ i ]</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_poc_msb_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;ph_poc_msb_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( ph_poc_msb_present_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;poc_msb_val</entry><entry>u(v)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( sps_alf_enabled_flag &#x26;&#x26; alf_info_in_ph_flag ) {</entry><entry/></row><row><entry>. . .</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( sps_lmcs_enabled_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;[[ph_lmcs_enabled_flag ]] ph_lmcs_enabled_type</entry><entry>[[u(1)]]</entry></row><row><entry/><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;if( [[ph_lmcs_enabled_flag]] ph_lmcs_enabled_type ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_lmcs_aps_id</entry><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( ChromaArrayType != 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ph_chroma_residual_scale_flag</entry><entry>u(I)</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( picture_header_extension_present_flag ) {</entry><entry/></row><row><entry>. . .</entry><entry/></row><row><entry>&#x2003;&#x2003;ph_extension_length</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c; ph_extension_length; i++)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ph_extension_data_byte[ i ]</entry><entry>u(8)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0045" level="2">7.3.7.1 General Slice Header Syntax</heading><p id="p-0124" num="0214"></p><p id="p-0125" num="0000"><tables id="TABLE-US-00036" num="00036"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="182pt" align="left"/><colspec colname="2" colwidth="35pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>slice_header( ) {</entry><entry/></row><row><entry>&#x2003;picture_header_in_slice_header_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;slice_ts_residual_coding_disabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if([[ph_lmcs_enabled_flag]] ph_lmcs_enabled_type = = N )</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_lmcs_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( pic_scaling_list_enabled_flag)</entry><entry/></row><row><entry>&#x2003;&#x2003;slice_scaling_list_present_flag</entry><entry>u(1)</entry></row><row><entry>. . .</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>ph_lmcs_enabled<img id="CUSTOM-CHARACTER-00135" he="2.12mm" wi="6.01mm" file="US20230007308A1-20230105-P00132.TIF" alt="custom-character" img-content="character" img-format="tif"/>[[flag]] equal to <img id="CUSTOM-CHARACTER-00136" he="2.46mm" wi="14.48mm" file="US20230007308A1-20230105-P00133.TIF" alt="custom-character" img-content="character" img-format="tif"/>[[1]] specifies that luma mapping with chroma scaling is enabled for all slices associated with the PH. <img id="CUSTOM-CHARACTER-00137" he="2.46mm" wi="18.71mm" file="US20230007308A1-20230105-P00134.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00138" he="2.46mm" wi="17.27mm" file="US20230007308A1-20230105-P00135.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00139" he="2.46mm" wi="30.73mm" file="US20230007308A1-20230105-P00136.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00140" he="2.46mm" wi="33.19mm" file="US20230007308A1-20230105-P00137.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00141" he="2.46mm" wi="33.53mm" file="US20230007308A1-20230105-P00138.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00142" he="2.46mm" wi="33.53mm" file="US20230007308A1-20230105-P00139.TIF" alt="custom-character" img-content="character" img-format="tif"/><img id="CUSTOM-CHARACTER-00143" he="2.12mm" wi="28.96mm" file="US20230007308A1-20230105-P00140.TIF" alt="custom-character" img-content="character" img-format="tif"/>ph_lmcs_enabled_flag equal to 0 specifies that luma mapping with chroma scaling [[may be disabled for one, or more, or]] is disabled for all slices associated with the PH. When not present, the value of ph_lmcs_enabled_flag is inferred to be equal to 0.<br/>slice_lmcs_enabled_flag equal to 1 specifies that luma mapping with chroma scaling is enabled for the current slice. slice_lmcs_enabled_flag equal to 0 specifies that luma mapping with chroma scaling is not enabled for the current slice. When slice_lmcs_enabled_flag is not present, it is inferred to be equal to [[0]]<img id="CUSTOM-CHARACTER-00144" he="2.46mm" wi="29.97mm" file="US20230007308A1-20230105-P00141.TIF" alt="custom-character" img-content="character" img-format="tif"/><br/>In above examples, the values of M and N may be set to 1 and 2, respectively. Alternatively, the values of M and N may be set to 2 and 1, respectively</p><p id="p-0126" num="0215"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a block diagram showing an example video processing system <b>1900</b> in which various techniques disclosed herein may be implemented. Various implementations may include some or all of the components of the system <b>1900</b>. The system <b>1900</b> may include input <b>1902</b> for receiving video content. The video content may be received in a raw or uncompressed format, e.g., 8 or 10 bit multi-component pixel values, or may be in a compressed or encoded format. The input <b>1902</b> may represent a network interface, a peripheral bus interface, or a storage interface. Examples of network interface include wired interfaces such as Ethernet, passive optical network (PON), etc. and wireless interfaces such as Wi-Fi or cellular interfaces.</p><p id="p-0127" num="0216">The system <b>1900</b> may include a coding component <b>1904</b> that may implement the various coding or encoding methods described in the present document. The coding component <b>1904</b> may reduce the average bitrate of video from the input <b>1902</b> to the output of the coding component <b>1904</b> to produce a coded representation of the video. The coding techniques are therefore sometimes called video compression or video transcoding techniques. The output of the coding component <b>1904</b> may be either stored, or transmitted via a communication connected, as represented by the component <b>1906</b>. The stored or communicated bitstream (or coded) representation of the video received at the input <b>1902</b> may be used by the component <b>1908</b> for generating pixel values or displayable video that is sent to a display interface <b>1910</b>. The process of generating user-viewable video from the bitstream representation is sometimes called video decompression. Furthermore, while certain video processing operations are referred to as &#x201c;coding&#x201d; operations or tools, it will be appreciated that the coding tools or operations are used at an encoder and corresponding decoding tools or operations that reverse the results of the coding will be performed by a decoder.</p><p id="p-0128" num="0217">Examples of a peripheral bus interface or a display interface may include universal serial bus (USB) or high definition multimedia interface (HDMI) or Displayport, and so on. Examples of storage interfaces include serial advanced technology attachment (SATA), peripheral component interconnect (PCI), integrated drive electronics (IDE) interface, and the like. The techniques described in the present document may be embodied in various electronic devices such as mobile phones, laptops, smartphones or other devices that are capable of performing digital data processing and/or video display.</p><p id="p-0129" num="0218"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a block diagram of a video processing apparatus <b>3600</b>. The apparatus <b>3600</b> may be used to implement one or more of the methods described herein. The apparatus <b>3600</b> may be embodied in a smartphone, tablet, computer, Internet of Things (IoT) receiver, and so on. The apparatus <b>3600</b> may include one or more processors <b>3602</b>, one or more memories <b>3604</b> and video processing hardware <b>3606</b>. The processor(s) <b>3602</b> may be configured to implement one or more methods described in the present document. The memory (memories) <b>3604</b> may be used for storing data and code used for implementing the methods and techniques described herein. The video processing hardware <b>3606</b> may be used to implement, in hardware circuitry, some techniques described in the present document.</p><p id="p-0130" num="0219"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a block diagram that illustrates an example video coding system <b>100</b> that may utilize the techniques of this disclosure.</p><p id="p-0131" num="0220">As shown in <figref idref="DRAWINGS">FIG. <b>8</b></figref>, video coding system <b>100</b> may include a source device <b>110</b> and a destination device <b>120</b>. Source device <b>110</b> generates encoded video data which may be referred to as a video encoding device. Destination device <b>120</b> may decode the encoded video data generated by source device <b>110</b> which may be referred to as a video decoding device.</p><p id="p-0132" num="0221">Source device <b>110</b> may include a video source <b>112</b>, a video encoder <b>114</b>, and an input/output (I/O) interface <b>116</b>.</p><p id="p-0133" num="0222">Video source <b>112</b> may include a source such as a video capture device, an interface to receive video data from a video content provider, and/or a computer graphics system for generating video data, or a combination of such sources. The video data may comprise one or more pictures. Video encoder <b>114</b> encodes the video data from video source <b>112</b> to generate a bitstream. The bitstream may include a sequence of bits that form a coded representation of the video data. The bitstream may include coded pictures and associated data. The coded picture is a coded representation of a picture. The associated data may include sequence parameter sets, picture parameter sets, and other syntax structures. I/O interface <b>116</b> may include a modulator/demodulator (modem) and/or a transmitter. The encoded video data may be transmitted directly to destination device <b>120</b> via I/O interface <b>116</b> through network <b>130</b><i>a</i>. The encoded video data may also be stored onto a storage medium/server <b>130</b><i>b </i>for access by destination device <b>120</b>.</p><p id="p-0134" num="0223">Destination device <b>120</b> may include an I/O interface <b>126</b>, a video decoder <b>124</b>, and a display device <b>122</b>.</p><p id="p-0135" num="0224">I/O interface <b>126</b> may include a receiver and/or a modem. I/O interface <b>126</b> may acquire encoded video data from the source device <b>110</b> or the storage medium/server <b>130</b><i>b</i>. Video decoder <b>124</b> may decode the encoded video data. Display device <b>122</b> may display the decoded video data to a user. Display device <b>122</b> may be integrated with the destination device <b>120</b>, or may be external to destination device <b>120</b> which may be configured to interface with an external display device.</p><p id="p-0136" num="0225">Video encoder <b>114</b> and video decoder <b>124</b> may operate according to a video compression standard, such as the High Efficiency Video Coding (HEVC) standard, Versatile Video Coding (VVM) standard and other current and/or further standards.</p><p id="p-0137" num="0226"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a block diagram illustrating an example of video encoder <b>200</b>, which may be video encoder <b>114</b> in the system <b>100</b> illustrated in <figref idref="DRAWINGS">FIG. <b>8</b></figref>.</p><p id="p-0138" num="0227">Video encoder <b>200</b> may be configured to perform any or all of the techniques of this disclosure. In the example of <figref idref="DRAWINGS">FIG. <b>9</b></figref>, video encoder <b>200</b> includes a plurality of functional components. The techniques described in this disclosure may be shared among the various components of video encoder <b>200</b>. In some examples, a processor may be configured to perform any or all of the techniques described in this disclosure.</p><p id="p-0139" num="0228">The functional components of video encoder <b>200</b> may include a partition unit <b>201</b>, a predication unit <b>202</b> which may include a mode select unit <b>203</b>, a motion estimation unit <b>204</b>, a motion compensation unit <b>205</b>, an intra prediction unit <b>206</b>, a residual generation unit <b>207</b>, a transform unit <b>208</b>, a quantization unit <b>209</b>, an inverse quantization unit <b>210</b>, an inverse transform unit <b>211</b>, a reconstruction unit <b>212</b>, a buffer <b>213</b>, and an entropy encoding unit <b>214</b>.</p><p id="p-0140" num="0229">In other examples, video encoder <b>200</b> may include more, fewer, or different functional components. In an example, predication unit <b>202</b> may include an intra block copy (IBC) unit. The IBC unit may perform predication in an IBC mode in which at least one reference picture is a picture where the current video block is located.</p><p id="p-0141" num="0230">Furthermore, some components, such as motion estimation unit <b>204</b> and motion compensation unit <b>205</b> may be highly integrated, but are represented in the example of <figref idref="DRAWINGS">FIG. <b>9</b></figref> separately for purposes of explanation.</p><p id="p-0142" num="0231">Partition unit <b>201</b> may partition a picture into one or more video blocks. Video encoder <b>200</b> and video decoder <b>300</b> may support various video block sizes.</p><p id="p-0143" num="0232">Mode select unit <b>203</b> may select one of the coding modes, intra or inter, e.g., based on error results, and provide the resulting intra- or inter-coded block to a residual generation unit <b>207</b> to generate residual block data and to a reconstruction unit <b>212</b> to reconstruct the encoded block for use as a reference picture. In some examples, the mode select unit <b>203</b> may select a combination of intra and inter predication (CIIP) mode in which the predication is based on an inter predication signal and an intra predication signal. Mode select unit <b>203</b> may also select a resolution for a motion vector (e.g., a sub-pixel or integer pixel precision) for the block in the case of inter predication.</p><p id="p-0144" num="0233">To perform inter prediction on a current video block, motion estimation unit <b>204</b> may generate motion information for the current video block by comparing one or more reference frames from buffer <b>213</b> to the current video block. Motion compensation unit <b>205</b> may determine a predicted video block for the current video block based on the motion information and decoded samples of pictures from buffer <b>213</b> other than the picture associated with the current video block.</p><p id="p-0145" num="0234">Motion estimation unit <b>204</b> and motion compensation unit <b>205</b> may perform different operations for a current video block, for example, depending on whether the current video block is in an I slice, a P slice, or a B slice.</p><p id="p-0146" num="0235">In some examples, motion estimation unit <b>204</b> may perform uni-directional prediction for the current video block, and motion estimation unit <b>204</b> may search reference pictures of list 0 or list 1 for a reference video block for the current video block. Motion estimation unit <b>204</b> may then generate a reference index that indicates the reference picture in list 0 or list 1 that contains the reference video block and a motion vector that indicates a spatial displacement between the current video block and the reference video block. Motion estimation unit <b>204</b> may output the reference index, a prediction direction indicator, and the motion vector as the motion information of the current video block. Motion compensation unit <b>205</b> may generate the predicted video block of the current block based on the reference video block indicated by the motion information of the current video block.</p><p id="p-0147" num="0236">In other examples, motion estimation unit <b>204</b> may perform bi-directional prediction for the current video block, motion estimation unit <b>204</b> may search the reference pictures in list 0 for a reference video block for the current video block and may also search the reference pictures in list 1 for another reference video block for the current video block. Motion estimation unit <b>204</b> may then generate reference indexes that indicate the reference pictures in list 0 and list 1 containing the reference video blocks and motion vectors that indicate spatial displacements between the reference video blocks and the current video block. Motion estimation unit <b>204</b> may output the reference indexes and the motion vectors of the current video block as the motion information of the current video block. Motion compensation unit <b>205</b> may generate the predicted video block of the current video block based on the reference video blocks indicated by the motion information of the current video block.</p><p id="p-0148" num="0237">In some examples, motion estimation unit <b>204</b> may output a full set of motion information for decoding processing of a decoder.</p><p id="p-0149" num="0238">In some examples, motion estimation unit <b>204</b> may not output a full set of motion information for the current video. Rather, motion estimation unit <b>204</b> may signal the motion information of the current video block with reference to the motion information of another video block. For example, motion estimation unit <b>204</b> may determine that the motion information of the current video block is sufficiently similar to the motion information of a neighboring video block.</p><p id="p-0150" num="0239">In one example, motion estimation unit <b>204</b> may indicate, in a syntax structure associated with the current video block, a value that indicates to the video decoder <b>300</b> that the current video block has the same motion information as the other video block.</p><p id="p-0151" num="0240">In another example, motion estimation unit <b>204</b> may identify, in a syntax structure associated with the current video block, another video block and a motion vector difference (MVD). The motion vector difference indicates a difference between the motion vector of the current video block and the motion vector of the indicated video block. The video decoder <b>300</b> may use the motion vector of the indicated video block and the motion vector difference to determine the motion vector of the current video block.</p><p id="p-0152" num="0241">As discussed above, video encoder <b>200</b> may predictively signal the motion vector. Two examples of predictive signalling techniques that may be implemented by video encoder <b>200</b> include advanced motion vector predication (AMVP) and merge mode signalling.</p><p id="p-0153" num="0242">Intra prediction unit <b>206</b> may perform intra prediction on the current video block. When intra prediction unit <b>206</b> performs intra prediction on the current video block, intra prediction unit <b>206</b> may generate prediction data for the current video block based on decoded samples of other video blocks in the same picture. The prediction data for the current video block may include a predicted video block and various syntax elements.</p><p id="p-0154" num="0243">Residual generation unit <b>207</b> may generate residual data for the current video block by subtracting (e.g., indicated by the minus sign) the predicted video block(s) of the current video block from the current video block. The residual data of the current video block may include residual video blocks that correspond to different sample components of the samples in the current video block.</p><p id="p-0155" num="0244">In other examples, there may be no residual data for the current video block for the current video block, for example in a skip mode, and residual generation unit <b>207</b> may not perform the subtracting operation.</p><p id="p-0156" num="0245">Transform processing unit <b>208</b> may generate one or more transform coefficient video blocks for the current video block by applying one or more transforms to a residual video block associated with the current video block.</p><p id="p-0157" num="0246">After transform processing unit <b>208</b> generates a transform coefficient video block associated with the current video block, quantization unit <b>209</b> may quantize the transform coefficient video block associated with the current video block based on one or more quantization parameter (QP) values associated with the current video block.</p><p id="p-0158" num="0247">Inverse quantization unit <b>210</b> and inverse transform unit <b>211</b> may apply inverse quantization and inverse transforms to the transform coefficient video block, respectively, to reconstruct a residual video block from the transform coefficient video block. Reconstruction unit <b>212</b> may add the reconstructed residual video block to corresponding samples from one or more predicted video blocks generated by the predication unit <b>202</b> to produce a reconstructed video block associated with the current block for storage in the buffer <b>213</b>.</p><p id="p-0159" num="0248">After reconstruction unit <b>212</b> reconstructs the video block, loop filtering operation may be performed to reduce video blocking artifacts in the video block.</p><p id="p-0160" num="0249">Entropy encoding unit <b>214</b> may receive data from other functional components of the video encoder <b>200</b>. When entropy encoding unit <b>214</b> receives the data, entropy encoding unit <b>214</b> may perform one or more entropy encoding operations to generate entropy encoded data and output a bitstream that includes the entropy encoded data.</p><p id="p-0161" num="0250">Some embodiments of the disclosed technology include making a decision or determination to enable a video processing tool or mode. In an example, when the video processing tool or mode is enabled, the encoder will use or implement the tool or mode in the processing of a block of video, but may not necessarily modify the resulting bitstream based on the usage of the tool or mode. That is, a conversion from the block of video to the bitstream (or the bitstream representation) of the video will use the video processing tool or mode when it is enabled based on the decision or determination. In another example, when the video processing tool or mode is enabled, the decoder will process the bitstream with the knowledge that the bitstream has been modified based on the video processing tool or mode. That is, a conversion from the bitstream of the video to the block of video will be performed using the video processing tool or mode that was enabled based on the decision or determination.</p><p id="p-0162" num="0251"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a block diagram illustrating an example of video decoder <b>300</b> which may be video decoder <b>124</b> in the system <b>100</b> illustrated in <figref idref="DRAWINGS">FIG. <b>8</b></figref>.</p><p id="p-0163" num="0252">The video decoder <b>300</b> may be configured to perform any or all of the techniques of this disclosure. In the example of <figref idref="DRAWINGS">FIG. <b>10</b></figref>, the video decoder <b>300</b> includes a plurality of functional components. The techniques described in this disclosure may be shared among the various components of the video decoder <b>300</b>. In some examples, a processor may be configured to perform any or all of the techniques described in this disclosure.</p><p id="p-0164" num="0253">In the example of <figref idref="DRAWINGS">FIG. <b>10</b></figref>, video decoder <b>300</b> includes an entropy decoding unit <b>301</b>, a motion compensation unit <b>302</b>, an intra prediction unit <b>303</b>, an inverse quantization unit <b>304</b>, an inverse transformation unit <b>305</b>, and a reconstruction unit <b>306</b> and a buffer <b>307</b>. Video decoder <b>300</b> may, in some examples, perform a decoding pass generally reciprocal to the encoding pass described with respect to video encoder <b>200</b> (<figref idref="DRAWINGS">FIG. <b>9</b></figref>).</p><p id="p-0165" num="0254">Entropy decoding unit <b>301</b> may retrieve an encoded bitstream. The encoded bitstream may include entropy coded video data (e.g., encoded blocks of video data). Entropy decoding unit <b>301</b> may decode the entropy coded video data, and from the entropy decoded video data, motion compensation unit <b>302</b> may determine motion information including motion vectors, motion vector precision, reference picture list indexes, and other motion information. Motion compensation unit <b>302</b> may, for example, determine such information by performing the AMVP and merge mode.</p><p id="p-0166" num="0255">Motion compensation unit <b>302</b> may produce motion compensated blocks, possibly performing interpolation based on interpolation filters. Identifiers for interpolation filters to be used with sub-pixel precision may be included in the syntax elements.</p><p id="p-0167" num="0256">Motion compensation unit <b>302</b> may use interpolation filters as used by video encoder <b>200</b> during encoding of the video block to calculate interpolated values for sub-integer pixels of a reference block. Motion compensation unit <b>302</b> may determine the interpolation filters used by video encoder <b>200</b> according to received syntax information and use the interpolation filters to produce predictive blocks.</p><p id="p-0168" num="0257">Motion compensation unit <b>302</b> may use some of the syntax information to determine sizes of blocks used to encode frame(s) and/or slice(s) of the encoded video sequence, partition information that describes how each macroblock of a picture of the encoded video sequence is partitioned, modes indicating how each partition is encoded, one or more reference frames (and reference frame lists) for each inter-encoded block, and other information to decode the encoded video sequence.</p><p id="p-0169" num="0258">Intra prediction unit <b>303</b> may use intra prediction modes for example received in the bitstream to form a prediction block from spatially adjacent blocks. Inverse quantization unit <b>304</b> inverse quantizes, i.e., de-quantizes, the quantized video block coefficients provided in the bitstream and decoded by entropy decoding unit <b>301</b>. Inverse transform unit <b>305</b> applies an inverse transform.</p><p id="p-0170" num="0259">Reconstruction unit <b>306</b> may sum the residual blocks with the corresponding prediction blocks generated by motion compensation unit <b>302</b> or intra prediction unit <b>303</b> to form decoded blocks. If desired, a deblocking filter may also be applied to filter the decoded blocks in order to remove blockiness artifacts. The decoded video blocks are then stored in buffer <b>307</b>, which provides reference blocks for subsequent motion compensation/intra predication and also produces decoded video for presentation on a display device.</p><p id="p-0171" num="0260">A listing of solutions preferred by some embodiments is provided next.</p><p id="p-0172" num="0261">The following solutions show example embodiments of techniques discussed in the previous section (e.g., item 1).</p><p id="p-0173" num="0262">1. A video processing method (e.g., method <b>900</b> depicted in <figref idref="DRAWINGS">FIG. <b>7</b></figref>), comprising: performing (<b>902</b>) a conversion between a video comprising one or more video pictures, wherein each video picture comprises one or more tiles and a coded representation of a video, wherein the coded representation conforms to a format rule; wherein the format rule specifies first information that is signalled in the coded representation and second information that is derived from the coded representation, wherein at least the first information or the second information relates to row indexes or column indexes of the one or more tiles.</p><p id="p-0174" num="0263">2. The method of solution 1, wherein the format rule specifies that a tile column index of each coding tree unit column of each video picture is derived.</p><p id="p-0175" num="0264">3. The method of solution 1, wherein the format rule specifies that a tile row index of each coding tree unit row of each video picture is derived.</p><p id="p-0176" num="0265">The following solutions show example embodiments of techniques discussed in the previous section (e.g., item 2). In these solutions, a video region may be a video picture and a video unit may be a video block or a coding tree unit or a video slice.</p><p id="p-0177" num="0266">4. A method of video processing, comprising: performing a conversion between a video unit of a video region of a video and a coded representation of a video, wherein the coded representation conforms to a format rule; wherein the format rule specifies that a first control information at the video region controls whether a second control information is included at the video unit level; wherein the first control information and/or the second control information includes information about luma mapping and chroma scaling (LMCS) or chroma residue scaling (CRS) or a reshaping process (RP) used for the conversion.</p><p id="p-0178" num="0267">5. The method of solution 4, wherein the first control information comprises an indicator indicating whether the second control information is included in the coded representation.</p><p id="p-0179" num="0268">6. The method of solutions 4-5, wherein a specific value of the first control information indicates that LMCS is disabled for all video units in the video region.</p><p id="p-0180" num="0269">7. The method of any of solutions 4-6, wherein the second control information controls enabling of LMCS at the video unit.</p><p id="p-0181" num="0270">8. The method of solution 4, wherein the first control information comprises multiple indicators.</p><p id="p-0182" num="0271">9. The method of any of solutions 1 to 8, wherein the conversion comprises encoding the video into the coded representation.</p><p id="p-0183" num="0272">10. The method of any of solutions 1 to 8, wherein the conversion comprises decoding the coded representation to generate pixel values of the video.</p><p id="p-0184" num="0273">11. A video decoding apparatus comprising a processor configured to implement a method recited in one or more of solutions 1 to 10.</p><p id="p-0185" num="0274">12. A video encoding apparatus comprising a processor configured to implement a method recited in one or more of solutions 1 to 10.</p><p id="p-0186" num="0275">13. A computer program product having computer code stored thereon, the code, when executed by a processor, causes the processor to implement a method recited in any of solutions 1 to 10.</p><p id="p-0187" num="0276">14.A method, apparatus or system described in the present document.</p><p id="p-0188" num="0277">In the solutions described herein, an encoder may conform to the format rule by producing a coded representation according to the format rule. In the solutions described herein, a decoder may use the format rule to parse syntax elements in the coded representation with the knowledge of presence and absence of syntax elements according to the format rule to produce decoded video.</p><p id="p-0189" num="0278"><figref idref="DRAWINGS">FIG. <b>11</b></figref> is a flowchart for an example method <b>1100</b> of video processing. Operation <b>1102</b> includes performing a conversion between a video comprising one or more video pictures and a bitstream of the video, wherein each video picture comprises one or more tiles that include one or more tile columns, wherein the bitstream conforms to a format rule, and wherein the format rule specifies that a tile column index is derived for each coding tree unit (CTU) column of a tile of a video picture.</p><p id="p-0190" num="0279">In some embodiments of method <b>1100</b>, the tile column index for a ctbAddrX-th tile column, denoted as ctbToTileColIdx[ctbAddrX], is derived as follows:</p><p id="p-0191" num="0000"><tables id="TABLE-US-00037" num="00037"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="14pt" align="left"/><colspec colname="2" colwidth="203pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>tileX = 0</entry></row><row><entry/><entry>for( ctbAddrX = 0; ctbAddrX &#x3c;= PicWidthInCtbsY; ctbAddrX++ ) {</entry></row><row><entry/><entry>&#x2003;if( ctbAddrX = = tileColBd[ tileX + 1 ] )</entry></row><row><entry/><entry>&#x2003;tileX++</entry></row><row><entry/><entry>&#x2003;ctbToTileColIdx[ ctbAddrX ] = tileX</entry></row><row><entry/><entry>},</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>wherein PicWidthInCtbsY represents a width of the video picture in units of coded tree blocks (CTBs), and wherein tileColBd[i] represents a location of an i-th tile column boundary in units of CTBs.</p><p id="p-0192" num="0280">In some embodiments of method <b>1100</b>, each video picture also comprises one or more subpictures, each subpicture comprises one or more slices that collectively form a rectangular subset of the video picture, and the format rule further specifies that a width of a subpicture in units of tile columns included is derived based on tile column indices of a left-most CTU and/or a right-most CTU included in the subpicture.</p><p id="p-0193" num="0281">In some embodiments of method <b>1100</b>, the width of an i-th subpicture in units of tiles columns, denoted as SubpicWidthInTiles[i], is derived as follows:</p><p id="p-0194" num="0000"><tables id="TABLE-US-00038" num="00038"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="21pt" align="left"/><colspec colname="2" colwidth="182pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry/><entry>for( i = 0; i &#x3c;= sps_num_subpics_minus1; i++ ) {</entry></row><row><entry/><entry/><entry>&#x2003;leftX = sps_subpic_ctu_top_left_x[ i ]</entry></row><row><entry/><entry/><entry>&#x2003;rightX = leftX + sps_subpic_width_minus1[ i ]</entry></row><row><entry/><entry/><entry>&#x2003;SubpicWidthInTiles[ i ] = ctbToTileColIdx</entry></row><row><entry/><entry/><entry>&#x2003;[ rightX ] + 1 &#x2212; ctbToTileColIdx[ leftX ]</entry></row><row><entry/><entry/><entry>},</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>wherein sps_num_subpics_minus1 represents a number of subpictures in the video picture, wherein sps_subpic_ctu_top_left_x[i] represents a horizontal position of top-left CTU of the i-th subpicture, wherein sps_subpic_width_minus1[i] plus 1 specifies the width of the i-th subpicture, and wherein ctbToTileColIdx[rightX] and ctbToTileColIdx[leftX] represent the tile column indices of a left-most CTU and a right-most CTU, respectively, included in the subpicture.</p><p id="p-0195" num="0282">In some embodiments of method <b>1100</b>, in response to a tile being partitioned into multiple rectangular slices and only a subset of the rectangular slices of the tile is included in the subpicture, the tile is counted as one tile in the value of the width of the subpicture.</p><p id="p-0196" num="0283"><figref idref="DRAWINGS">FIG. <b>12</b></figref> is a flowchart for an example method <b>1200</b> of video processing. Operation <b>1202</b> includes performing a conversion between a video comprising one or more video pictures and a bitstream of the video, wherein each video picture comprises one or more tiles that include one or more tile rows, wherein the bitstream conforms to a format rule, and wherein the format rule specifies that a tile row index is derived for each coding tree unit (CTU) row of a tile of a video picture.</p><p id="p-0197" num="0284">In some embodiments of method <b>1200</b>, the tile row index for a ctbAddrY-th tile row, denoted as ctbToTileRowIdx[ctbAddrY], is derived as follows:</p><p id="p-0198" num="0000"><tables id="TABLE-US-00039" num="00039"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="14pt" align="left"/><colspec colname="2" colwidth="203pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>tileY = 0</entry></row><row><entry/><entry>for( ctbAddrY = 0; ctbAddrY &#x3c;= PicHeightInCtbsY; ctbAddrY++ ) {</entry></row><row><entry/><entry>&#x2003;if( ctbAddrY = = tileRowBd[ tileY + 1 ] )</entry></row><row><entry/><entry>&#x2003;&#x2003;tileY++</entry></row><row><entry/><entry>&#x2003;ctbToTileRowIdx[ ctbAddrY ] = tileY</entry></row><row><entry/><entry>},</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>wherein PicHeightInCtbsY represents a height of the video picture in units of coded tree blocks (CTBs), and wherein tileRowBd[i] represents a location of an i-th tile row boundary in units of CTBs.</p><p id="p-0199" num="0285">In some embodiments of method <b>1200</b>, each video picture also comprises one or more subpictures, each subpicture comprises one or more slices that collectively form a rectangular subset of the video picture, and the format rule further specifies that a height of a subpicture in units of tile rows is derived based on tile row indices of a top CTU and/or a bottom CTU included in the subpicture.</p><p id="p-0200" num="0286">In some embodiments of method <b>1200</b>, the height of an i-th subpicture in units of tile rows, denoted as SubpicHeightInTiles[i], is derived as follows:</p><p id="p-0201" num="0000"><tables id="TABLE-US-00040" num="00040"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="14pt" align="left"/><colspec colname="2" colwidth="189pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry/><entry>for( i = 0; i &#x3c;= sps_num_subpics_minus1; i++ ) {</entry></row><row><entry/><entry/><entry>&#x2003;topY = sps_subpic_ctu_top_left_y[ i ]</entry></row><row><entry/><entry/><entry>&#x2003;bottomY = topY + sps_subpic_height_minus1[ i ]</entry></row><row><entry/><entry/><entry>&#x2003;SubpicHeightInTiles[ i ] = ctbToTileRowIdx</entry></row><row><entry/><entry/><entry>&#x2003;[ botY ] + 1 &#x2212; ctbToTileRowIdx[ topY ]</entry></row><row><entry/><entry/><entry>},</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>wherein sps_num_subpics_minus1 represents a number of subpictures in the video picture, wherein sps_subpic_ctu_top_left_y[i] represents a vertical position of top-left CTUs of the i-th subpicture, wherein sps_subpic_height_minus1[i] plus 1 specifies the height of the i-th subpicture, and wherein ctbToTileRowIdx[botY] and ctbToTileRowIdx[topY] represent the tile row indices of a bottom CTU and a top CTU, respectively, included in the subpicture.</p><p id="p-0202" num="0287">In some embodiments of method <b>1200</b>, in response to a tile being partitioned into multiple rectangular slices and only a subset of the rectangular slices of the tile is included in the subpicture, the tile is counted as one tile in the value of the height of the subpicture.</p><p id="p-0203" num="0288"><figref idref="DRAWINGS">FIG. <b>13</b></figref> is a flowchart for an example method <b>1300</b> of video processing. Operation <b>1302</b> includes performing a conversion between a video comprising at least one video picture and a bitstream of the video according to a rule, wherein the at least one video picture comprises one or more slices and one or more subpictures, and wherein the rule specifies that an order of slice indices of the one or more slices in the at least one video picture is indicated responsive to a syntax element associated with the at least one picture indicative of whether a single slice is included per subpicture of the at least one video picture.</p><p id="p-0204" num="0289">In some embodiments of method <b>1300</b>, the rule further specifies that the slice indices are indicated in response to each slice in the at least one video picture being a rectangular slice. In some embodiments of method <b>1300</b>, the rule specifies that in case that the syntax element indicates that each of the one or more subpicture includes a single rectangular slice, then the order corresponds to increasing values of subpicture indices of the one or more subpictures in the video picture, and the subpicture indices of the one or more subpictures are indicated in a sequence parameter set (SPS) referred to by the at least one video picture. In some embodiments of method <b>1300</b>, the rule specifies that in case that the syntax element indicates that each subpicture includes one or more rectangular slices, then the order corresponds to an order in which the one or more slices are included in a picture parameter set (PPS) referred to by the at least one video picture. In some embodiments of method <b>1300</b>, the syntax element is included in a picture parameter set (PPS) referred to by the at least one video picture.</p><p id="p-0205" num="0290"><figref idref="DRAWINGS">FIG. <b>14</b></figref> is a flowchart for an example method <b>1400</b> of video processing. Operation <b>1402</b> includes performing a conversion between a video unit of a video region of a video and a bitstream of a video, wherein the bitstream conforms to a format rule, wherein the format rule specifies that a first control information at a first level the video region in the bitstream controls whether a second control information is included at a second level of the video unit in the bitstream, wherein the second level is smaller than the first level, wherein the first control information and the second control information include information about whether or how a luma mapping and chroma scaling (LMCS) tool is applied to the video unit, and wherein the LMCS tool includes using a chroma residue scaling (CRS), or a luma reshaping process (RP) for the conversion.</p><p id="p-0206" num="0291">In some embodiments of method <b>1400</b>, the first control information selectively includes a first indicator indicating whether the LMCS tool is enabled for one or more slices at the first level of the video region to specify whether the LMCS tool is enabled at the second level of the video unit, and the first indicator is a non-binary value. In some embodiments of method <b>1400</b>, the first level of the video region includes a picture header. In some embodiments of method <b>1400</b>, the first level of the video region includes a picture header, the first control information includes the first indicator, the LMCS tool is enabled for all slices of the picture header when the first indicator is equal to a first value, the LMCS tool is enabled for less than all slices of the picture header when the first indicator is equal to a second value, the LMCS tool is disabled for all slices of the picture header when the first indicator is equal to a third value, and the first value, the second value, and the third value are different from each other. In some embodiments of method <b>1400</b>, a value of the first indicator is inferred to be a default value when the first control information excludes the first indicator.</p><p id="p-0207" num="0292">In some embodiments of method <b>1400</b>, the first level of the video region includes a picture header, the first control information includes the first indicator, the LMCS tool is disabled for all slices of the picture header when the first indicator is equal to a first value, the LMCS tool is disabled for less than all slices of the picture header when the first indicator is equal to a second value, the LMCS tool is enabled for all slices of the picture header when the first indicator is equal to a third value, and the first value, the second value, and the third value are different from each other. In some embodiments of method <b>1400</b>, whether the first indicator is selectively included in the first control information based on a value of a syntax element in the bitstream that indicates whether the LMCS tool is enabled at a sequence level. In some embodiments of method <b>1400</b>, the first indicator is coded with u(v) or u(2) or ue(v). In some embodiments of method <b>1400</b>, the first indicator is coded with a truncated unary code.</p><p id="p-0208" num="0293">In some embodiments of method <b>1400</b>, an adaptation parameter set (APS) Information of the LMCS tool used by the one or more slices and/or a chroma scaling syntax element is included in the bitstream based on a value of the first indicator indicating whether the LMCS tool is enabled for the one or more slices at the first level of the video region. In some embodiments of method <b>1400</b>, the second control information selectively includes a second indicator indicating whether the LMCS tool is enabled or disabled for one or more slices at the second level of the video unit, and the second indicator is included in the bitstream based on a value of a first indicator included in the first control information, and the first indicator indicates whether the LMCS tool is enabled or disabled for the one or more slices at the second level of the video unit. In some embodiments of method <b>1400</b>, the second control information comprises a slice header. In some embodiments of method <b>1400</b>, the second indicator is included in the second control information in response to the first indicator being equal to a first value. In some embodiments of method <b>1400</b>, the second indicator is included in the second control information in response to performing a condition check of: the first indicator&#x3e;&#x3e;1, or the first indicator/2, or the first indicator &#x26; 0x01, wherein &#x3e;&#x3e;describes a right shift operation, and wherein &#x26; describes a bitwise logical and operation.</p><p id="p-0209" num="0294">In some embodiments of method <b>1400</b>, the second indicator is inferred to indicate that the LMCS tool is enabled for the one or more slices at the second level of the video unit in response to the first indicator being equal to a first value, or the second indicator is inferred to indicate that the LMCS tool is disabled for the one or more slices at the second level of the video unit in response to the first indicator being equal to a third value, and the first value, a second value of the first indicator, and the third value are different from each other. In some embodiments of method <b>1400</b>, the first control information comprises multiple indicators that indicate whether the LMCS tool is enabled for one or more slices at the first level of the video region to specify whether the LMCS tool is enabled at the second level of the video unit, and the multiple indicators have non-binary values. In some embodiments of method <b>1400</b>, the multiple indicators include at least two indicators included in a picture header. In some embodiments of method <b>1400</b>, the at least two indicators include a first indicator that specifies whether the LMCS tool is enabled for at least one slice associated with the picture header, and the at least two indicators selectively include a second indicator that specifies whether the LMCS tool is enabled for all slices associated with the picture header. In some embodiments of method <b>1400</b>, the second indicator is selectively present in the multiple indicators based on a value of the first indicator.</p><p id="p-0210" num="0295">In some embodiments of method <b>1400</b>, the value of the first indicator indicates that the LMCS tool is enabled for at least one slice. In some embodiments of method <b>1400</b>, the LMCS tool is inferred to be enabled for all slices associated with the picture header in response to the second indicator being absent from the bitstream. In some embodiments of method <b>1400</b>, the at least two indicators include a third indicator that is selectively included in a slice header based on a second value of the second indicator. In some embodiments of method <b>1400</b>, the second value of the second indictor indicates that the LMCS tool is disabled for all of the slices. In some embodiments of method <b>1400</b>, a value for the third indicator is inferred based on a first value of the first indicator and/or the second value of the second indicator in response to the third indicator being absent from the bitstream. In some embodiments of method <b>1400</b>, the at least two indicators include a first indicator that specifies whether the LMCS tool is disabled for at least one slice associated with the picture header, and the at least two indicators selectively include a second indicator that specifies whether the LMCS tool is disabled for all slices associated with the picture header. In some embodiments of method <b>1400</b>, the second indicator is present in the multiple indicators based on a value of the first indicator. In some embodiments of method <b>1400</b>, the value of the first indicator specifies that the LMCS tool is disabled for at least one slice. In some embodiments of method <b>1400</b>, the LMCS tool is inferred to be disabled for all slices associated with the picture header in response to the second indicator being absent from the bitstream. In some embodiments of method <b>1400</b>, the at least two indicators selectively include a third indicator in a slice header based on a second value of the second indicator.</p><p id="p-0211" num="0296">In some embodiments of method <b>1400</b>, the second value of the second indicator specifies that the LMCS tool is enabled for all of the slices. In some embodiments of method <b>1400</b>, a value for the third indicator is inferred based on a first value of the first indicator and/or a second value of the second indicator in response to the third indicator being absent from the bitstream. In some embodiments of method <b>1400</b>, the multiple indicators selectively include a first indicator based on a value of a syntax element that indicates whether the LMCS tool is enabled at a sequence level. In some embodiments of method <b>1400</b>, the multiple indicators selectively include a third indicator that indicates whether the LMCS tool is enabled or disabled at the second level of the video unit, and the third indicator is selectively present based on a first value of the first indicator and/or a second value of the second indicator. In some embodiments of method <b>1400</b>, the third indicator is selectively present based on the second indicator indicating that the LMCS tool is not enabled for all slices or that the LMCS tool is not disabled for all slices. In some embodiments of method <b>1400</b>, the first indicator, the second indicator, and/or the third indicator control a usage of the CRS or the luma RP.</p><p id="p-0212" num="0297"><figref idref="DRAWINGS">FIG. <b>15</b></figref> is a flowchart for an example method <b>1500</b> of video processing. Operation <b>1502</b> includes performing a conversion between a video and a bitstream of the video according to a rule, wherein the rule specifies that a luma mapping and chroma scaling (LMCS) tool is enabled when a first syntax element in a referred sequence parameter set indicates that the LMCS tool is enabled, wherein the rule specifies that the LMCS tool is not used when the first syntax element indicates that the LMCS tool is disabled, wherein the rule specifies that the LMCS tool is enabled for all slices associated with picture header of a video picture when a second syntax element in the bitstream indicates that the LMCS tool is enabled at the picture header level of the video, wherein the rule specifies that the LMCS tool is not used for all slices associated with the picture header when the second syntax element indicates that the LMCS tool is disabled at a picture header level of the video, wherein the rule specifies that the LMCS tool is used for a current slice associated with a slice header of a video picture when a third syntax element selectively included in the bitstream indicates that the LMCS tool is enabled at a slice header level of the video, and wherein the rule specifies that the LMCS tool is not used for the current slice when the third syntax element indicates that the LMCS tool is disabled at the slice header level of the video.</p><p id="p-0213" num="0298">In some embodiments of method <b>1500</b>, the rule specifies that the third syntax element is not included the slice header in the bitstream when the LMCS tool is used for all slices of the video picture. In some embodiments of method <b>1500</b>, whether the LMCS tool is enabled or disabled is based on the second syntax element. In some embodiments of method <b>1500</b>, the LMCS tool is enabled when the LMCS tool is used for all slices of the video picture, and the LMCS tool is disabled when the LMCS tool is not used for all slices of the video picture.</p><p id="p-0214" num="0299"><figref idref="DRAWINGS">FIG. <b>16</b></figref> is a flowchart for an example method <b>1600</b> of video processing. Operation <b>1602</b> includes performing a conversion between a video comprising one or more video pictures and a bitstream of a video according to a rule, wherein the rule specifies that whether an adaptive motion vector difference resolution (AMVR) is used in a motion vector coding of an affine inter mode based on a syntax element selectively included in a referred sequence parameter set (SPS) that indicates whether the AMVR is enabled, wherein the rule specifies that the AMVR is not used in the motion vector coding of the affine inter mode when the syntax element indicates that the AMVR is disabled, and wherein the rule specifies that the AMVR is inferred not to be used in the motion vector coding of the affine inter mode when the syntax element when the syntax element is not included in the SPS.</p><p id="p-0215" num="0300"><figref idref="DRAWINGS">FIG. <b>17</b></figref> is a flowchart for an example method <b>1700</b> of video processing. Operation <b>1702</b> includes performing a conversion between a video comprising a video picture and a bitstream of the video according to a rule, wherein the video picture comprising a subpicture, a tile, and a slice, and wherein the rule specifies that, due to the subpicture comprising the slice that is partitioned from the tile, the conversion is performed by refraining from counting a height of the subpicture using a number of tiles of the video picture.</p><p id="p-0216" num="0301">In some embodiments of method <b>1700</b>, the height of the subpicture is counted based on a number of coding tree units (CTUs). In some embodiments of method <b>1700</b>, the height of the subpicture is less than one tile row.</p><p id="p-0217" num="0302"><figref idref="DRAWINGS">FIG. <b>18</b></figref> is a flowchart for an example method <b>1800</b> of video processing. Operation <b>1802</b> includes performing a conversion between a video comprising a video picture and a bitstream of the video, wherein the bitstream indicates a height of a subpicture of the video picture that is counted based on a number of coding tree units (CTUs) of the video picture.</p><p id="p-0218" num="0303">In some embodiments of method <b>1800</b>, the height of the subpicture is not based on a number of tiles of the video picture. In some embodiments of method <b>1800</b>, the height of the subpicture is less than one tile row.</p><p id="p-0219" num="0304"><figref idref="DRAWINGS">FIG. <b>19</b></figref> is a flowchart for an example method <b>1900</b> of video processing. Operation <b>1902</b> includes making a determination, according to a rule, about whether a height of a subpicture of a video picture of a video is less than a height of a tile row of the video picture. Operation <b>1904</b> includes performing, using the determination, a conversion between the video and a bitstream of the video.</p><p id="p-0220" num="0305">In some embodiments of method <b>1900</b>, the rule specifies that the height of the subpicture is less than one tile row when: the subpicture only includes coding tree units (CTUs) from the one tile row, and either a first set of CTUs located on top of the subpicture are not the same as a second set of CTUs located on top of the one tile row, or a third set of CTUs located on the bottom of the subpicture are not the same as a fourth set of CTUs located on the bottom of the one tile row. In some embodiments of method <b>1900</b>, when each subpicture of the video picture includes only one slice and the height of the subpicture is less than one tile row, for each slice with picture-level slice index i of the video picture, a value of CtbAddrInSlice[i][j] is derived from a picture raster scan CTU address of a j-th CTU in a CTU raster scan of the subpicture, and j is in a range of 0 to a number of CTUs in a slice minus 1, inclusive.</p><p id="p-0221" num="0306">In some embodiments of method <b>1900</b>, the rule specifies that the height of the subpicture is less than the one tile row when: a distance between a first set of CTUs located on top of the subpicture and a second set of CTUs located on the bottom of the subpicture is less than a second height of a tile of the video picture, wherein the second height of the tile is based on a number of CTUs of the subpicture. In some embodiments of method <b>1900</b>, when each subpicture of the video picture includes only one slice and the height of the subpicture is greater than or equal to one tile row, for each slice with picture-level slice index i of the video picture, a value of CtbAddrInSlice[i][j] is derived from a picture raster scan CTU address of a j-th CTU in an order of CTUs in the subpicture, and j is in a range of 0 to a number of CTUs in a slice minus 1, inclusive.</p><p id="p-0222" num="0307">In some embodiments of method <b>1900</b>, the order of the CTUs in the subpicture is such that a first CTU in a first tile with a first tile index is placed before a second CTU in a second tile with a second tile index, and a value of the first tile index is less than that of the second tile index. In some embodiments of method <b>1900</b>, the order of the CTUs in the subpicture is such that CTUs within one tile in the subpicture are ordered in a raster scan of the CTUs in the one tile.</p><p id="p-0223" num="0308">In some embodiments of method(s) <b>1100</b>-<b>1900</b>, the performing the conversion comprising encoding the video into the bitstream. In some embodiments of method(s) <b>1100</b>-<b>1900</b>, the performing the conversion comprises encoding the video into the bitstream, and the method further comprises storing the bitstream in a non-transitory computer-readable recording medium. In some embodiments of method(s) <b>1100</b>-<b>1900</b>, the performing the conversion comprises decoding the video from the bitstream.</p><p id="p-0224" num="0309">In some embodiments, a video decoding apparatus comprising a processor configured to implement operations described for any one or more of methods <b>1100</b> to <b>1900</b>. In some embodiments, a video encoding apparatus comprising a processor configured to implement operations described for any one or more of methods <b>1100</b> to <b>1900</b>. In some embodiments, a computer program product having computer instructions stored thereon, the instructions, when executed by a processor, causes the processor to implement operations described for any one or more of methods <b>1100</b> to <b>1900</b>. In some embodiments, a non-transitory computer-readable storage medium that stores a bitstream generated according to operations described for any one or more of methods <b>1100</b> to <b>1900</b>. In some embodiments, a non-transitory computer-readable storage medium storing instructions that cause a processor to implement operations described for any one or more of methods <b>1100</b> to <b>1900</b>. In some embodiments, method of bitstream generation, comprising: generating a bitstream of a video according to operations described for any one or more of methods <b>1100</b> to <b>1900</b>, and storing the bitstream on a computer-readable program medium. In some embodiments, a method, an apparatus, a bitstream generated according to a disclosed method or a system described in the present document.</p><p id="p-0225" num="0310">In the present document, the term &#x201c;video processing&#x201d; may refer to video encoding, video decoding, video compression or video decompression. For example, video compression algorithms may be applied during conversion from pixel representation of a video to a corresponding bitstream representation or vice versa. The bitstream representation of a current video block may, for example, correspond to bits that are either co-located or spread in different places within the bitstream, as is defined by the syntax. For example, a macroblock may be encoded in terms of transformed and coded error residual values and also using bits in headers and other fields in the bitstream. Furthermore, during conversion, a decoder may parse a bitstream with the knowledge that some fields may be present, or absent, based on the determination, as is described in the above solutions. Similarly, an encoder may determine that certain syntax fields are or are not to be included and generate the coded representation accordingly by including or excluding the syntax fields from the coded representation.</p><p id="p-0226" num="0311">The disclosed and other solutions, examples, embodiments, modules and the functional operations described in this document can be implemented in digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this document and their structural equivalents, or in combinations of one or more of them. The disclosed and other embodiments can be implemented as one or more computer program products, i.e., one or more modules of computer program instructions encoded on a computer readable medium for execution by, or to control the operation of, data processing apparatus. The computer readable medium can be a machine-readable storage device, a machine-readable storage substrate, a memory device, a composition of matter effecting a machine-readable propagated signal, or a combination of one or more them. The term &#x201c;data processing apparatus&#x201d; encompasses all apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, or multiple processors or computers. The apparatus can include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or a combination of one or more of them. A propagated signal is an artificially generated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus.</p><p id="p-0227" num="0312">A computer program (also known as a program, software, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program does not necessarily correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub programs, or portions of code). A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.</p><p id="p-0228" num="0313">The processes and logic flows described in this document can be performed by one or more programmable processors executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an field programmable gate array (FPGA) or an application specific integrated circuit (ASIC).</p><p id="p-0229" num="0314">Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read only memory or a random-access memory or both. The essential elements of a computer are a processor for performing instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto optical disks, or optical disks. However, a computer need not have such devices. Computer readable media suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., erasable programmable read-only memory (EPROM), electrically EPROM (EEPROM), and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto optical disks; and compact disc read-only memory (CD ROM) and digital versatile disc read-only memory (DVD-ROM) disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.</p><p id="p-0230" num="0315">While this patent document contains many specifics, these should not be construed as limitations on the scope of any subject matter or of what may be claimed, but rather as descriptions of features that may be specific to particular embodiments of particular techniques. Certain features that are described in this patent document in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.</p><p id="p-0231" num="0316">Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. Moreover, the separation of various system components in the embodiments described in this patent document should not be understood as requiring such separation in all embodiments.</p><p id="p-0232" num="0317">Only a few implementations and examples are described and other implementations, enhancements and variations can be made based on what is described and illustrated in this patent document.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A method of video processing, comprising:<claim-text>performing a conversion between a video comprising a video picture and a bitstream of the video,</claim-text><claim-text>wherein the video picture comprises one or more tiles that form one or more tile rows and one or more tile columns,</claim-text><claim-text>wherein the bitstream conforms to a format rule, and</claim-text><claim-text>wherein the format rule specifies that a tile row index is derived for each coding tree block (CTB) row of a tile of the video picture.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the tile row index for a ctbAddrY-th tile row, denoted as ctbToTileRowIdx[ctbAddrY], is derived as follows:</claim-text><claim-text><tables id="TABLE-US-00041" num="00041"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="14pt" align="left"/><colspec colname="2" colwidth="203pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>tileY = 0</entry></row><row><entry/><entry>for( ctbAddrY = 0; ctbAddrY &#x3c;= PicHeightInCtbsY; ctbAddrY++ ) {</entry></row><row><entry/><entry>&#x2003;if( ctbAddrY = = tileRowBd[ tileY + 1 ] )</entry></row><row><entry/><entry>&#x2003;&#x2003;tileY++</entry></row><row><entry/><entry>&#x2003;ctbToTileRowIdx[ ctbAddrY ] = tileY</entry></row><row><entry/><entry>},</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><claim-text>wherein PicHeightInCtbsY represents a height of the video picture in units of CTBs, and wherein tileRowBd[i] represents a location of an i-th tile row boundary in units of CTBs.</claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>,<claim-text>wherein the video picture also comprises one or more subpictures,</claim-text><claim-text>wherein each of the one or more subpictures comprises one or more slices that collectively form a rectangular subset of the video picture, and</claim-text><claim-text>wherein the format rule further specifies that a height of a subpicture in units of tile rows is derived based on tile row indices of a top CTB and/or a bottom CTB included in the subpicture.</claim-text></claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein a height of an i-th subpicture in units of tile rows, denoted as SubpicHeightInTiles[i], is derived as follows:</claim-text><claim-text><tables id="TABLE-US-00042" num="00042"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="14pt" align="left"/><colspec colname="2" colwidth="189pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry/><entry>for( i = 0; i &#x3c;= sps_num_subpics_minus1; i++ ) {</entry></row><row><entry/><entry/><entry>&#x2003;topY = sps_subpic_ctu_top_left_y[ i ]</entry></row><row><entry/><entry/><entry>&#x2003;bottomY = topY + sps_subpic_height_minus1[ i ]</entry></row><row><entry/><entry/><entry>&#x2003;SubpicHeightInTiles[ i ] = ctbToTileRowIdx</entry></row><row><entry/><entry/><entry>&#x2003;[ botY ] + 1 &#x2212; ctbToTileRowIdx[ topY ]</entry></row><row><entry/><entry/><entry>},</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><claim-text>wherein sps_num_subpics_minus1 plus 1 represents a number of subpictures in the video picture,</claim-text><claim-text>wherein sps_subpic_ctu_top_left_y[i] represents a vertical position of a top-left CTB of the i-th subpicture,</claim-text><claim-text>wherein sps_subpic_height_minus1[i] plus 1 specifies the height of the i-th subpicture, and</claim-text><claim-text>wherein ctbToTileRowIdx[botY] and ctbToTileRowIdx[topY] represent the tile row indices of the bottom CTB and the top CTB, respectively, included in the subpicture.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein in response to the tile being partitioned into a plurality of rectangular slices and only a subset of the rectangular slices of the tile being included in the subpicture, the tile is counted as one tile in a value of the height of the subpicture.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the format rule further specifies that a tile column index is derived for each CTB column of the tile of the video picture, and<claim-text>wherein the tile column index for a ctbAddrX-th tile column, denoted as ctbToTileColIdx[ctbAddrX], is derived as follows:</claim-text></claim-text><claim-text><tables id="TABLE-US-00043" num="00043"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="14pt" align="left"/><colspec colname="2" colwidth="203pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>tileX = 0</entry></row><row><entry/><entry>for( ctbAddrX = 0; ctbAddrX &#x3c;= PicWidthInCtbsY; ctbAddrX++ ) {</entry></row><row><entry/><entry>&#x2003;if( ctbAddrX = = tileColBd[ tileX + 1 ] )</entry></row><row><entry/><entry>&#x2003;tileX++</entry></row><row><entry/><entry>&#x2003;ctbToTileColIdx[ ctbAddrX ] = tileX</entry></row><row><entry/><entry>},</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><claim-text>wherein PicWidthInCtbsY represents a width of the video picture in units of CTBs, and</claim-text><claim-text>wherein tileColBd[i] represents a location of an i-th tile column boundary in units of CTBs.</claim-text></claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref>,<claim-text>wherein the video picture also comprises one or more subpictures,</claim-text><claim-text>wherein each of the one or more subpictures comprises one or more slices that collectively form a rectangular subset of the video picture, and</claim-text><claim-text>wherein the format rule further specifies that a width of a subpicture in units of tile columns included is derived based on tile column indices of a left-most CTB and/or a right-most CTB included in the subpicture, and</claim-text><claim-text>wherein a width of an i-th subpicture in units of tiles columns, denoted as SubpicWidthInTiles[i], is derived as follows:</claim-text></claim-text><claim-text><tables id="TABLE-US-00044" num="00044"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="14pt" align="left"/><colspec colname="2" colwidth="189pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry/><entry>for( i = 0; i &#x3c;= sps_num_subpics_minus1; i++ ) {</entry></row><row><entry/><entry/><entry>&#x2003;leftX = sps_subpic_ctu_top_left_x[ i ]</entry></row><row><entry/><entry/><entry>&#x2003;rightX = leftX + sps_subpic_width_minus1[ i ]</entry></row><row><entry/><entry/><entry>&#x2003;SubpicWidthInTiles[ i ] = ctbToTileColIdx</entry></row><row><entry/><entry/><entry>&#x2003;[ rightX ] + 1 &#x2212; ctbToTileColIdx[ leftX ]</entry></row><row><entry/><entry/><entry>},</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><claim-text>wherein sps_num_subpics_minus1 plus 1 represents a number of subpictures in the video picture,</claim-text><claim-text>wherein sps_subpic_ctu_top_left_x[i] represents a horizontal position of a top-left CTB of the i-th subpicture,</claim-text><claim-text>wherein sps_subpic_width_minus1[i] plus 1 specifies the width of the i-th subpicture, and</claim-text><claim-text>wherein ctbToTileColIdx[rightX] and ctbToTileColIdx[leftX] represent the tile column indices of the left-most CTB and the right-most CTB, respectively, included in the subpicture.</claim-text></claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the video picture comprises one or more slices and one or more subpictures,<claim-text>wherein the format rule further specifies that an order of slice indices of the one or more slices in the video picture is indicated in response to a syntax element associated with the video picture indicative of whether a single slice is included per subpicture of the video picture, and</claim-text><claim-text>wherein the slice indices are indicated in response to each slice in the video picture being a rectangular slice.</claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the format rule further specifies that when the syntax element indicates that each of the one or more subpictures includes a single rectangular slice, the order corresponds to increasing values of subpicture indices of the one or more subpictures in the video picture.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the format rule further specifies that when the syntax element indicates that each of the one or more subpictures is allowed to include one or more rectangular slices, the order corresponds to an order in which the one or more slices are included in a picture parameter set (PPS) referred to by the video picture.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>making a determination, according to the format rule, about whether a height of a subpicture of the video picture is less than a height of a tile row of the video picture; and</claim-text><claim-text>performing, using the determination, the conversion.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref>,<claim-text>wherein when each subpicture of the video picture includes only one slice and the height of the subpicture is less than one tile row, for each slice with a picture-level slice index i of the video picture, a value of CtbAddrInSlice[i][j] specifying a picture raster scan CTB address of a j-th CTB within a slice is derived from the picture raster scan CTB address of the j-th CTB in a CTB raster scan of the subpicture, and</claim-text><claim-text>wherein i is in a range of 0 to a number of slices in the video picture minus 1, inclusive and j is in a range of 0 to a number of coding tree units (CTUs) in the slice minus 1, inclusive.</claim-text></claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the format rule further specifies that the height of the subpicture is less than one tile row when a distance between a first set of coding tree units (CTUs) located on top of the subpicture and a second set of CTUs located at a bottom of the subpicture is less than a second height of a tile of the video picture, wherein the second height of the tile is based on a number of CTUs of the tile.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref>,<claim-text>wherein when each subpicture of the video picture includes only one slice and the height of the subpicture is greater than or equal to one tile row, for each slice with a picture-level slice index i of the video picture, a value of CtbAddrInSlice[i][j] specifying a picture raster scan CTB address of a j-th CTB within a slice is derived from the picture raster scan CTB address of the j-th CTB in an order of CTBs in the subpicture,</claim-text><claim-text>wherein i is in a range of 0 to a number of slices in the video picture minus 1, inclusive and j is in a range of 0 to a number of coding tree units (CTUs) in the slice minus 1, inclusive,</claim-text><claim-text>wherein the order of the CTBs in the subpicture is such that a first CTB in a first tile with a first tile index is placed before a second CTB in a second tile with a second tile index,</claim-text><claim-text>wherein a value of the first tile index is less than a value of the second tile index, and</claim-text><claim-text>wherein an order of the CTBs within one tile in the subpicture is ordered in a raster scan of the CTUs in the one tile.</claim-text></claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein performing the conversion comprises encoding the video into the bitstream.</claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein performing the conversion comprises decoding the video from the bitstream.</claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. An apparatus for processing video data comprising a processor and a non-transitory memory with instructions thereon, wherein the instructions upon execution by the processor, cause the processor to:<claim-text>perform a conversion between a video comprising a video picture and a bitstream of the video,</claim-text><claim-text>wherein the video picture comprises one or more tiles that form one or more tile rows and one or more tile columns,</claim-text><claim-text>wherein the bitstream conforms to a format rule, and</claim-text><claim-text>wherein the format rule specifies that a tile row index is derived for each coding tree block (CTB) row of a tile of the video picture.</claim-text></claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The apparatus of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the tile row index for a ctbAddrY-th tile row, denoted as ctbToTileRowIdx[ctbAddrY], is derived as follows:</claim-text><claim-text><tables id="TABLE-US-00045" num="00045"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="14pt" align="left"/><colspec colname="2" colwidth="203pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>tileY = 0</entry></row><row><entry/><entry>for( ctbAddrY = 0; ctbAddrY &#x3c;= PicHeightInCtbsY; ctbAddrY++ ) {</entry></row><row><entry/><entry>&#x2003;if( ctbAddrY = = tileRowBd[ tileY + 1 ] )</entry></row><row><entry/><entry>&#x2003;&#x2003;tileY++</entry></row><row><entry/><entry>&#x2003;ctbToTileRowIdx[ ctbAddrY ] = tileY</entry></row><row><entry/><entry>},</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><claim-text>wherein PicHeightInCtbsY represents a height of the video picture in units of CTBs, and</claim-text><claim-text>wherein tileRowBd[i] represents a location of an i-th tile row boundary in units of CTBs.</claim-text></claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. A non-transitory computer-readable storage medium storing instructions that cause a processor to:<claim-text>perform a conversion between a video comprising a video picture and a bitstream of the video,</claim-text><claim-text>wherein the video picture comprises one or more tiles that form one or more tile rows and one or more tile columns,</claim-text><claim-text>wherein the bitstream conforms to a format rule, and</claim-text><claim-text>wherein the format rule specifies that a tile row index is derived for each coding tree block (CTB) row of a tile of the video picture.</claim-text></claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. A non-transitory computer-readable recording medium storing a bitstream of a video which is generated by a method performed by a video processing apparatus, wherein the method comprises:<claim-text>generating the bitstream of the video comprising a video picture according to a format rule,</claim-text><claim-text>wherein the video picture comprises one or more tiles that form one or more tile rows and one or more tile columns,</claim-text><claim-text>wherein the bitstream conforms to a format rule, and</claim-text><claim-text>wherein the format rule specifies that a tile row index is derived for each coding tree block (CTB) row of a tile of the video picture.</claim-text></claim-text></claim></claims></us-patent-application>