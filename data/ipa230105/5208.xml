<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230005209A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230005209</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17363259</doc-number><date>20210630</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>T</subclass><main-group>15</main-group><subgroup>06</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>T</subclass><main-group>1</main-group><subgroup>20</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>7</main-group><subgroup>487</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>7</main-group><subgroup>499</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>50</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>T</subclass><main-group>15</main-group><subgroup>06</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>T</subclass><main-group>1</main-group><subgroup>20</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>7</main-group><subgroup>4876</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>7</main-group><subgroup>4873</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>7</main-group><subgroup>49978</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>5027</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">CIRCUITRY AND METHOD</invention-title><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Arm Limited</orgname><address><city>Cambridge</city><country>GB</country></address></addressbook><residence><country>GB</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>VALSARAJU</last-name><first-name>Harsha</first-name><address><city>Austin</city><state>TX</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Bruguera</last-name><first-name>Javier Diaz</first-name><address><city>Cambridge</city><country>GB</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">Circuitry comprises ray tracing circuitry comprising a plurality of floating-point circuitries to perform floating-point processing operations to detect intersection between a virtual ray defined by a ray direction and a test region, the floating-point circuitries operating to a given precision to generate an output floating-point value comprising a significand and an exponent; in which at least some of the plurality of floating-point circuitries are configured to round using a predetermined directed rounding mode any denormal floating-point value generated by operation of that circuitry so as to output normal values, a denormal floating-point value being a floating-point value in which the significand comprises one or more leading zeroes.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="112.95mm" wi="113.37mm" file="US20230005209A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="220.30mm" wi="138.26mm" file="US20230005209A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="168.40mm" wi="147.91mm" file="US20230005209A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="178.22mm" wi="132.00mm" file="US20230005209A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="223.44mm" wi="153.75mm" file="US20230005209A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="215.98mm" wi="153.33mm" orientation="landscape" file="US20230005209A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="199.22mm" wi="152.91mm" orientation="landscape" file="US20230005209A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="233.51mm" wi="149.69mm" orientation="landscape" file="US20230005209A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="205.66mm" wi="151.81mm" orientation="landscape" file="US20230005209A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="193.38mm" wi="152.65mm" orientation="landscape" file="US20230005209A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="206.25mm" wi="151.98mm" orientation="landscape" file="US20230005209A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="226.14mm" wi="145.88mm" file="US20230005209A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="49.19mm" wi="44.79mm" file="US20230005209A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">BACKGROUND</heading><p id="p-0002" num="0001">This disclosure relates to circuitry and methods.</p><p id="p-0003" num="0002">In the field of computer graphics, it is known to use a graphics processing unit, or in other words a specialised processor, to implement graphics processing commands which may be prepared by another processor.</p><p id="p-0004" num="0003">The graphics processing unit may make use of so-called &#x201c;ray tracing&#x201d; during the execution of graphics processing commands.</p><p id="p-0005" num="0004">It is in this context that the present disclosure arises.</p><heading id="h-0002" level="1">SUMMARY</heading><p id="p-0006" num="0005">In an example arrangement there is provided circuitry comprising:</p><p id="p-0007" num="0006">ray tracing circuitry comprising a plurality of floating-point circuitries to perform floating-point processing operations to detect intersection between a virtual ray defined by a ray direction and a test region, the floating-point circuitries operating to a given precision to generate an output floating-point value comprising a significand and an exponent;</p><p id="p-0008" num="0007">in which at least some of the plurality of floating-point circuitries are configured to round using a predetermined directed rounding mode any denormal floating-point value generated by operation of that circuitry so as to output normal values (for example, only normal values), a denormal floating-point value being a floating-point value in which the significand comprises one or more leading zeroes.</p><p id="p-0009" num="0008">In another example arrangement there is provided a graphics processing unit having a hardware ray tracing accelerator comprising the circuitry of claim <b>1</b>.</p><p id="p-0010" num="0009">In another example arrangement there is provided a method comprising:</p><p id="p-0011" num="0010">ray tracing by a plurality of floating-point processing operations to detect intersection between a virtual ray defined by a ray direction and a test region, the floating-point processing operations operating to a given precision to generate an output floating-point value comprising a significand and an exponent; and</p><p id="p-0012" num="0011">for at least some of the plurality of floating-point circuitries, rounding using a predetermined directed rounding mode any denormal floating-point value generated by that floating-point processing operation so as to output normal values (for example, only normal values), a denormal floating-point value being a floating-point value in which the significand comprises one or more leading zeroes.</p><p id="p-0013" num="0012">In another example arrangement there is provided a non-transitory computer-readable medium to store computer-readable code for fabrication of the circuitry discussed above.</p><p id="p-0014" num="0013">Further respective aspects and features of the present disclosure are defined by the appended claims.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0015" num="0014">The present technique will be described further, by way of example only, with reference to embodiments thereof as illustrated in the accompanying drawings, in which:</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. <b>1</b></figref> schematically illustrates a data processing apparatus;</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>2</b></figref> schematically illustrates a graphics processing unit;</p><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>3</b></figref> schematically illustrates the use of ray tracing circuitry;</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>4</b></figref> schematically illustrates a ray tracing process;</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>5</b></figref> schematically illustrates a bounding volume hierarchy (BVH);</p><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. <b>6</b></figref> schematically illustrates ray box test circuitry;</p><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. <b>7</b></figref> schematically illustrates ray triangle test circuitry;</p><p id="p-0023" num="0022"><figref idref="DRAWINGS">FIGS. <b>8</b>-<b>13</b></figref> schematically illustrate circuitry specific to the arrangements of <figref idref="DRAWINGS">FIG. <b>6</b> or <b>7</b></figref>; and</p><p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. <b>14</b></figref> is a schematic flowchart illustrating a method.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0004" level="1">DESCRIPTION OF EMBODIMENTS</heading><heading id="h-0005" level="1">Circuitry Overview</heading><p id="p-0025" num="0024">Referring now to the drawings, <figref idref="DRAWINGS">FIG. <b>1</b></figref> schematically illustrates a data processing system comprising a processing element or central processing unit (CPU) <b>100</b>, connected via interconnect circuitry <b>110</b> to a graphics processing unit (GPU) <b>120</b> and to a memory <b>130</b>.</p><p id="p-0026" num="0025">The CPU <b>100</b> performs general-purpose computation, which in this example arrangement refers to computational tasks which are not performed by the GPU <b>120</b>. The GPU <b>120</b> is itself a specialised circuitry which is designed and implemented to perform computation relating to the creation of images very efficiently. The image information generated by the GPU <b>120</b> may output to a display device or display device driver, not shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0027" num="0026">GPUs are not restricted to performing image-based operations and can in fact be used for other processing tasks such as implementing machine learning or artificial intelligence applications. However, several aspects of the functionality are typically well-suited to executing rendering, or the like, in order to generate image data.</p><p id="p-0028" num="0027">In operation, the CPU <b>100</b> would typically generate a set of GPU processing tasks which are provided to the GPU <b>120</b> via the interconnect <b>110</b> for execution. Task data, such as data defining the tasks, and/or data to be processed by the tasks, may be stored in the memory system <b>130</b> to allow the GPU <b>120</b> to access each task and its associated task data in an execution order and the GPU <b>120</b> may similarly store the results of its computation in the memory system <b>130</b>.</p><p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. <b>2</b></figref> schematically illustrates an example structure of the GPU <b>120</b>, comprising an interface <b>200</b> for retrieving data and instructions from the interconnect <b>110</b> and providing data such as processing results back to the interconnect <b>110</b>, and a cache <b>210</b> for storing data and/or instructions for input or processed data for output. A memory management unit (MMU) <b>220</b> can perform address translation where this is required.</p><p id="p-0030" num="0029">A job manager <b>230</b> controls the execution of processing tasks or jobs established by the CPU <b>110</b>, with the GPU-specific execution been performed by a set of shader cores <b>240</b> and tiler circuitry <b>250</b>. The shader cores <b>240</b> are provided with hardware accelerators <b>242</b> to handle at least ray tracing operations. Note that although these are drawn schematically in <figref idref="DRAWINGS">FIG. <b>2</b></figref> as being part of the shader cores, they may instead be coprocessors connected to interact with the shader cores.</p><p id="p-0031" num="0030">The shader cores are processing units specifically optimised or designed for handling instructions, for example in the form of shader code in order to manipulate the pixels and polygon vertices within an image so as to render portions of that image.</p><p id="p-0032" num="0031">The tiler circuitry oversees the division of the GPU rendering operations into those corresponding to discrete regions or tiles of the rendered image. This process can reduce the instantaneous memory and data transfer requirements which occur during the rendering process by the GPU <b>120</b>.</p><p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. <b>3</b></figref> schematically illustrates at least a part of the functionality of the GPU of <figref idref="DRAWINGS">FIG. <b>2</b></figref>, in part representing tasks performed by one or more hardware accelerators <b>242</b>.</p><p id="p-0034" num="0033">A source geometry <b>300</b>, for example generated by the CPU <b>100</b> as part of the representation of a virtual scene to be rendered, is provided to a generator <b>310</b> of a so-called bounding volume hierarchy (BVH). The concepts underlying the use of a BVH will be discussed further below. The preparation of the BVH can be performed at the GPU or could be performed by the CPU so that data defining the BVH is then passed to the GPU as part of the specification of a rendering task.</p><p id="p-0035" num="0034">One or more of the hardware accelerators <b>242</b> act as ray tracing circuitry <b>320</b>. Ray tracing will be described in further detail below. The ray tracing circuitry <b>320</b> may have associated control circuitry <b>330</b>, or a control function may be implemented as part of the ray tracing circuitry <b>320</b>.</p><p id="p-0036" num="0035">As will be discussed below, the ray tracing circuitry <b>320</b> may comprise a plurality of floating-point circuitries to perform floating-point processing operations to detect intersection between a virtual ray defined by a ray direction and a test region, the floating-point circuitries operating to a given precision to generate an output floating-point value comprising a significand and an exponent.</p><p id="p-0037" num="0036">The GPU (for example, one or more shader cores <b>240</b>) may also provide other rendering functionality <b>340</b> typical to the functions of a GPU and which is not described here.</p><heading id="h-0006" level="1">Ray-Tracing</heading><p id="p-0038" num="0037">Ray tracing is a rendering technique that can potentially produce very realistic lighting effects. It typically comprises a family of algorithms built upon casting rays from a camera, shade intersection points and intersection points for secondary illumination for sampling visibility and simulate the interaction of light with the virtual objects in a synthetic 3D scene. Physically-based global illumination solutions can be built upon ray tracing, for example simulating direct illumination, shadows, specular and glossy reflection, refraction, diffusion, caustics, indirect illumination, participating media, or the like.</p><p id="p-0039" num="0038"><figref idref="DRAWINGS">FIG. <b>4</b></figref> provides a simplified schematic representation of a ray-tracing process. This technique is used during image rendering by the ray tracing circuitry <b>320</b> to generate pixels or samples of an image by tracing so-called rays or light paths and simulating the effects of light encountering objects in the scene being viewed. It can be used as an alternative to other forms of rendering such as so-called scanline rendering. Because the processing requirements can be high, dedicated ray-tracing hardware can be provided such as the ray tracing circuitry <b>320</b> of <figref idref="DRAWINGS">FIG. <b>3</b></figref>.</p><p id="p-0040" num="0039">In a physical system, light emanating from a light source hits an object and is reflected and/or refracted towards the viewing position such as a user's eye or a camera. In contrast, in rendering systems using ray-tracing, the simulation is performed by emitting simulated &#x201c;rays&#x201d; from a viewing position such as a virtual camera and determining what interactions they undergo when they hit an object or (whether before or after hitting an object) a light source.</p><p id="p-0041" num="0040">Referring to <figref idref="DRAWINGS">FIG. <b>4</b></figref>, a virtual camera <b>400</b> is viewing a virtual object <b>450</b> in a virtual environment. The aim of the rendering process is to generate a rendered image <b>410</b> formed of multiple pixels such as an arbitrary pixel <b>430</b>.</p><p id="p-0042" num="0041">In the ray tracing technique, multiple virtual rays <b>420</b> are emitted from the virtual camera <b>400</b>, passing through pixel positions such as the position of the arbitrary pixel <b>430</b> in the image <b>410</b> to be rendered. In some cases the virtual rays impact a virtual object <b>450</b>,for example at a position <b>440</b>. At this location on the virtual object <b>450</b>, the object surface's colour, orientation, reflectivity and other optical properties affect the further propagation of the ray. A further set of simulated rays <b>460</b> is emitted from the point <b>440</b> to detect whether any of those virtual rays <b>460</b> impact a light source or indeed another object. If they do impact a light source such as an example light source <b>470</b>, properties of that light source are used to determine the lighting incident upon the location <b>440</b>. In other examples, if the rays <b>460</b> impact another object, then depending upon the optical properties of the location <b>440</b> and its orientation, a reflection of that other object may be rendered at the surface of the object <b>450</b>.</p><p id="p-0043" num="0042">Note that the ray tracing process to be described below can be applied to any of these ray tracing operations; for example those relating to the rays intersecting the object <b>450</b> and/or the rays intersecting the object or light source <b>470</b>.</p><p id="p-0044" num="0043">As mentioned above, the ray-tracing process can be very computationally expensive, particularly where the virtual scene includes many virtual objects and virtual light sources. Each virtual ray must be tested as to whether it intersects with each object in the scene.</p><heading id="h-0007" level="1">Bounding Volume Hierarchies</heading><p id="p-0045" num="0044">So-called bounding volume hierarchies (BVHs) will now be described briefly with reference to <figref idref="DRAWINGS">FIG. <b>5</b></figref>.</p><p id="p-0046" num="0045">A BVH is a hierarchical tree structure of volumes which provides a way of representing objects within a virtual environment. BVHs were first proposed as a technique for reducing the quantity of computation required to implement ray tracing. In principle, to perform ray tracing, rays have to be tested for intersection with every point on an object. In contrast, a BVH provides a hierarchical set of volumes enclosing an object. These are hierarchical in the sense that a highest level of the BVH represents a largest volume and successive lower levels down to so- called leaf nodes each representing a single triangular primitive (a) are contained within the next higher level and (b) are smaller than the next higher level.</p><p id="p-0047" num="0046">Therefore, each geometric object in the generated virtual environment is contained within or &#x201c;wrapped&#x201d; in a bounding volume forming the lowest level or leaf nodes of the tree structure. In <figref idref="DRAWINGS">FIG. <b>5</b></figref>, four example geometric objects A, B, C, D are represented, with each having a respective leaf node <b>530</b>, <b>540</b>, <b>550</b>, <b>560</b> providing a definition of a bounding volume containing just a single primitive representing that geometric object. At a next higher level, the leaf nodes are grouped as small localised sets of leaf nodes and are enclosed within a larger bounding volumes defined by tree structure nodes <b>510</b>, <b>520</b>. These in turn are recursively grouped and enclosed within other, more extensive, bounding volumes defined by higher level nodes such as a node <b>500</b> of <figref idref="DRAWINGS">FIG. <b>5</b></figref>. Ultimately, there will be a single bounding volume as a highest level node in the tree structure.</p><p id="p-0048" num="0047">In a ray tracing arrangement using a BVH, a simulated ray is first tested to detect whether it intersects with a particular volume. If so, the volume is recursively divided until the ray hits the object. The process can be improved by forming bounding volumes such that they are generally similar to the shape of the underlying object or objects so as to avoid performing too many detections on effectively empty space within a bounding volume.</p><p id="p-0049" num="0048">In an empirical example, direct implementation of ray tracing (without the use of BVHs) is indeed complex and expensive. To render a complete image at least 1 ray must be cast per pixel. For a 1920&#xd7;1080 image 2,073,600 primary rays are required. In addition, each ray must be tested against each primitive triangle. The result in an example arrangement is that about 212 intersections need to be computed. This quantity of competition can be heavily reduced in an example arrangement using BVHs, for example one in which primitive triangles are in a BVH node tree, with a default value of six boxes per node and a warp of rays traverses the tree in a coherent way.</p><heading id="h-0008" level="1">Hardware Acceleration&#x2014;Overview</heading><p id="p-0050" num="0049">Although ray tracing can be performed by programmable shader cores executing appropriate computer software instructions, in example arrangements, the GPU makes use of hardware acceleration to provide the ray tracing circuitry <b>320</b>.</p><p id="p-0051" num="0050">In the example to be described below, two hardware accelerators are provided at each shader core and collectively provide the functionality of the ray tracing circuitry <b>320</b>. These are (a) circuitry to provide a ray-box intersection test or in other words a test for the intersection between a so-called warp of rays (16 rays) and a wide node (a set of six boxes or volumes), as shown schematically in <figref idref="DRAWINGS">FIG. <b>6</b></figref>; and (b) circuitry to provide a ray-triangle intersection test to compute the intersection between a warp of rays (16 rays) and triangles in leaf nodes, as shown schematically in <figref idref="DRAWINGS">FIG. <b>7</b></figref>.</p><p id="p-0052" num="0051">Techniques will be described which potentially allow pipelined operation with relatively low, or at least reduced in comparison with some other designs, latency.</p><p id="p-0053" num="0052">Both the ray-box and ray-triangle intersection circuitries in these examples use a single-precision floating-point representation for inputs and internal variables and require a large number of floating-point additions and multiplications and some floating-point divisions.</p><p id="p-0054" num="0053">A low-latency (or at least reduced latency) implementation is obtained by (i) employing parallelism, (ii) using a fully pipelined design, and (iii) simplifying the microarchitecture of the floating-point operations so that every floating-point operation with the rounding, but the division, fits in just 1 cycle.</p><p id="p-0055" num="0054">Each floating-point operation is mapped in the circuitry as soon as its operands are ready, and the hardware operators are not reused. This way the number of parallel operations is potentially improved although potentially at the expense of a larger integrated circuit area.</p><p id="p-0056" num="0055">The pipelined design approach means that the intersection of one ray with six boxes of each BVH level is processed per cycle. Note that in an alternative, the intersection of one ray with one box could be tested per cycle so that multiple passes to test the intersection with the six boxes of the node. However, this approach would potentially need a larger number of cycles per BVH level.</p><p id="p-0057" num="0056">The microarchitecture of the floating-point operators is simplified by removing the input and output denormal support.</p><p id="p-0058" num="0057">The term &#x201c;denormal&#x201d;, sometimes expressed as &#x201c;sub-normal&#x201d;, referring to numbers where, in a given numerical representation, the representation would require an exponent that is below the smallest representable exponent. Where denormal support is provided, such numbers may be represented using leading zeros in the significand.</p><p id="p-0059" num="0058">In some systems, denormal support is used to avoid the accidental generation of zero values in place of values which are simply just very small (or sub-normal), for example so as to avoid subsequent divide-by-zero errors or the like.</p><p id="p-0060" num="0059">In contrast the present embodiments instead use a fixed directed rounding modes for every single floating-point operation, and using a reduced precision in the floating-point operations in ray-box intersection. Regarding the absence of denormal support, denormal results in ray-box intersection test are rounded to a minimum normal representation or zero based on rounding mode for conservative box coordinates; on the other hand, denormal inputs and outputs in the ray-triangle intersection test are flushed to 0.</p><p id="p-0061" num="0060">Therefore, this provides an example in which at least some of the plurality of floating-point circuitries of the ray tracing circuitry are configured to round using a predetermined directed rounding mode any denormal floating-point value generated by operation of that circuitry so as to output normal values (for example, only normal values), a denormal floating-point value being a floating-point value in which the significand comprises one or more leading zeroes.</p><p id="p-0062" num="0061">The ray-box intersection test can use single-precision adders and multipliers with reduced-precision mantissas. While the standard single-precision representation has 24-bit mantissas, the ray-box intersection test module produces accurate results with smaller mantissas: the number of fraction bits is 7, 10, 13 or 15 bits (noting that the number of mantissa bits is equal to the number of fraction bits +1, giving respective mantissa word lengths of 8, 11, 14 and 16 bits). Smaller precision modules are much smaller than standard single-precision adders and single-precision multipliers; for example, the smallest adders used in the present examples potentially occupy about half the integrated circuit area of a single-precision adder. In the diagrams to be described below, single precision is represented by the initials &#x201c;SP&#x201d;.</p><p id="p-0063" num="0062">These simplifications make possible that the floating-point additions and multiplications in the ray-box intersection test and the ray-triangle intersection test modules fit in just one cycle. Regarding the single-precision division, the usually long-latency division implementation (in the previously proposed ray tracing circuitry) by a reciprocal and multiplication. Reciprocal module is implemented with a maximum error of 1 unit in the last place or bit position (&#x201c;ulp&#x201d;) to bring down reciprocal latency to one cycle. This way, the division can be accomplished in potentially just two cycles&#x2014;in other examples more cycles could be allowed for a corresponding potential reduction in power consumption.</p><p id="p-0064" num="0063">An overview of the two main circuitries is provided by <figref idref="DRAWINGS">FIGS. <b>6</b></figref> (ray box test) and <b>7</b> (ray triangle test).</p><p id="p-0065" num="0064">Referring to <figref idref="DRAWINGS">FIG. <b>6</b></figref>, the ray box test circuitry comprises two main modules: ray_box_test <b>600</b> and six instances of test_ray_aabb <b>610</b> (one for each of the BVH boxes to be tested). In ray_box_test <b>600</b>, the node and ray information are unpacked, some special cases are handled and some computations relating to parent distance calculations are carried out. The six instances of test_ray_aabb are controlled by information passed to them from ray_box_test <b>600</b> to compute each of the six children's distance from the origin and to determine whether or not the ray intersects the respective box.</p><p id="p-0066" num="0065">In these examples, the ray tracing circuitry is configured to detect intersection of the virtual ray with a hierarchical set of bounding volumes. For example, at a given hierarchy level, each bounding volume comprises a predetermined number (such as six in this example) of bounding volumes at a next lower hierarchy level. The use of six instances of test_ray_aabb <b>610</b> provides an example in which the ray tracing circuitry is configured, for the given hierarchy level, to detect intersection of the virtual ray with each of the bounding volumes at the next lower hierarchy level, for example by using the predetermined number of intersection-detecting circuitries operable in parallel, one intersection-detecting circuitry being configured to detect intersection for a respective one of the predetermined number of bounding volumes at a next lower hierarchy level</p><p id="p-0067" num="0066">The inputs to ray_box_test <b>600</b> are as follows, noting that the ray box test circuitry operates at any arbitrary level in the BVH except for the leaf level:<ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0067">node (for example (x, y, z)) coordinates of a predetermined point such as a predetermined lower vertex of the parent volume to be tested, along with six offsets (which are therefore always positive), one for each child volume</li>        <li id="ul0002-0002" num="0068">ray_info (for example, data defining a ray vector and its origin) and the output is:</li>        <li id="ul0002-0003" num="0069">visit (indicating a result, for example in the form of a six bit vector with each bit indicating a &#x201c;yes/no&#x201d; outcome for whether the ray intersects a respective one of the six child boxes.</li>    </ul>    </li></ul></p><p id="p-0068" num="0070">Note that if the output vector &#x201c;visit&#x201d; indicates &#x201c;yes&#x201d; for any of the child boxes, then that child box becomes the parent box for a next iteration of the ray box test operation.</p><p id="p-0069" num="0071">Referring to <figref idref="DRAWINGS">FIG. <b>7</b></figref>, the ray triangle test circuitry also comprises two modules as drawn: ray_triangle_test_wrapper <b>700</b> and ray_triangle_test <b>710</b>. The ray_triangle_test_wrapper <b>700</b> unpacks the input operands, handles some special cases and instantiates and passes information to the ray_triangle_test <b>710</b>, which in turn determines whether or not the ray intersects the triangle.</p><p id="p-0070" num="0072">The inputs to ray_triangle_test_wrapper <b>700</b> are as follows:<ul id="ul0003" list-style="none">    <li id="ul0003-0001" num="0000">    <ul id="ul0004" list-style="none">        <li id="ul0004-0001" num="0073">tri_info (providing information on the triangle to be tested, in particular in this example 3 sets of coordinates each defining a respective vertex)</li>        <li id="ul0004-0002" num="0074">flags (for example parameters for the triangle to be tested such as opacity; note that in the case of an opaque triangle, a &#x201c;miss&#x201d; (non-intersection) is returned as the result)</li>        <li id="ul0004-0003" num="0075">ray_info(for example, data defining a ray vector and its origin) and the output is:</li>        <li id="ul0004-0004" num="0076">hit (indicating a result as to whether the ray intersects the triangle or not, the distance along the ray to the point of intersection and barycentric coordinates of the point of intersection, where the barycentric coordinates are coordinates according to a system by which the location of a point is specified by reference to the triangle) These circuitries will now be described in more detail with reference to <figref idref="DRAWINGS">FIGS. <b>8</b>-<b>13</b></figref>.</li>    </ul>    </li></ul></p><heading id="h-0009" level="1">FIG. <b>8</b> (Ray_Box_Test <b>600</b>)</heading><p id="p-0071" num="0077">Referring to <figref idref="DRAWINGS">FIG. <b>8</b></figref>, in common with at least some of the other diagrams to be described, a representation of a pipelined operation by the division of the diagram into horizontal sections or slices separated by a broken horizontal line and denoted by pipeline cycles P0, P1, P2 and so on. The operations at P0 are performed first, followed by operations at P1 and successive instances of Pn. These may be performed in adjacent or successive cycles but this is not necessarily a requirement, just that (for any given one of the diagrams) Pm takes place after Pn where m&#x3e;n.</p><p id="p-0072" num="0078">Therefore, in these examples, the ray tracing circuitry is configured to perform processing operations according to clock cycles of a succession of clock cycles. In some examples, each of the floating-point circuitries is configured to perform a respective floating- point operation according to a single respective one of the succession of clock cycles. In at least some examples, the ray tracing circuitry operates as pipelined circuitry having a plurality of successive pipeline stages.</p><p id="p-0073" num="0079">The input parameter ray_info provides an origin <b>800</b> and an inverse direction <b>805</b> (an inverse or reciprocal direction) representation is used. The input parameter node provides parent coordinates <b>812</b>. The precision of representation of these and other values within the circuitry to be described is denoted by a number of bits (&#x201c;b&#x201d;) and also where relevant a floating- point representation such as a 32 bit floating-point (FP) representation &#x201c;FP32&#x201d;.</p><p id="p-0074" num="0080">In other words, the ray tracing circuitry is responsive to ray data indicating the ray direction, the ray data defining a reciprocal of a ray vector representing the ray direction, which conveniently allows the ray tracing circuitry to use multiplier circuitry configured to perform a division by the ray vector by implementing a multiplication by the ray data defining the reciprocal of the ray vector.</p><p id="p-0075" num="0081">Circuitry <b>810</b> derives, for each of the (x, y, z) coordinates, a distance of the parent vertex from the origin along the direction of the ray. This is calculated twice by the respective units <b>810</b> to generate the same outcome but with different rounding: one derivation (to generate &#x201c;Parent dist lo&#x201d;) is rounded towards the ray direction and the other derivation (to generate &#x201c;Parent dist hi&#x201d;) is rounded away from the ray direction. The floating-point adders implemented by the circuitry <b>810</b> operate to a 15 bit precision. However, the output variables Parent_dist_lo and Parent_dist_hi <b>815</b> are provided to a 10 bit precision the sending <b>822</b> each instance of ray_box_aabb. This addition and rounding is performed in a single cycle. In connection with the precision of operation associated with these circuitries, and as denoted by the notation contained within the respective boxes as drawn in <figref idref="DRAWINGS">FIG. <b>8</b></figref>, the following notes are provided:<ul id="ul0005" list-style="none">    <li id="ul0005-0001" num="0000">    <ul id="ul0006" list-style="none">        <li id="ul0006-0001" num="0082">&#x201c;Precision&#x201d; represents the number of fraction bits with useful information. For example: Parent Coordinates are FP32 numbers with 15 fraction bits. The lower 8 bits are always 0 and so do not contain useful information.</li>        <li id="ul0006-0002" num="0083">The input origin <b>800</b> needs to be rounded/truncated to have only 13 bits of precision before being subtracted from the parent coordinates <b>812</b>. This is done to save circuit area in an integrated circuit implementation.</li>        <li id="ul0006-0003" num="0084">For calculating Parent_dist_hi, origin <b>800</b> needs to be rounded away from the direction of the ray. For calculating Parent_dist_lo, origin <b>800</b> needs to be rounded towards the direction of the ray. This ensures that the box coordinates are still conservative (the constructed box might be slightly bigger than if it were using full precision, but it is noted in this context that that it considered acceptable to report a false hit, but not a false miss).</li>        <li id="ul0006-0004" num="0085">Instead of adding a rounding module to truncate &#x201c;origin&#x201d;, the example arrangement provides logic or circuitry in the adders within the circuitries <b>810</b> to do this along with the FP addition. This allows the circuitries to save implementation area and perform both origin rounding and parent distance calculation in the same cycle. That is why the notation associated with the boxes <b>810</b> has an extra &#x201c;+1b incr&#x201d; term. In other word the adders in the boxes <b>810</b> have an additional &#x201c;incr&#x201d; input. If the origin needs to be rounded to zero (i.e truncated to 13 bits), &#x201c;incr &#x201d; would be 0. If the origin needs to be rounded away from zero, incr input would be 1, implying that origin need to incremented by 1 at origin bit position 10.</li>    </ul>    </li></ul></p><p id="p-0076" num="0086">Circuitry <b>825</b> detects one or more conditions relating to invalidity of the data so as to generate an input valid bit <b>830</b> which is provided to output circuitry <b>835</b> and used to gate the &#x201c;visit&#x201d; outputs <b>840</b> received back from each of the ray_box_aabb (the generation of which will be described below). If the input valid bit <b>830</b> indicates &#x201c;invalid&#x201d; then the output circuitry <b>835</b> (for example, an AND circuit in which each of the visit signals is subject to an AND combination with the input valid bit) sets the eventual output visit signals <b>845</b> to 0 (miss).</p><p id="p-0077" num="0087">The inverse direction <b>805</b> has its precision reduced to 10 bits, rounded up (Inv Dir hi) or down (Inv Dir lo) for sending <b>852</b> each instance of ray_box_aabb. This is achieved by circuitry <b>855</b> which increments a given bit of Inv Dir to generate a value which is subjected to reduced precision to generate Inv Dir hi. In the example shown, the size of the incrementor is 19 bits wide. The increment happens at bit 13 (inv_dir[31:13]+1&#x2032;b1).</p><p id="p-0078" num="0088">Therefore, the data sent to each instance of ray_box_aabb comprises the parent distance (lo and hi) at 10 bit precision and the inverse direction (lo and hi) at 10 bit precision, and the data received back from the instances of ray_box_aabb comprises the visit flags.</p><p id="p-0079" num="0089">Flags or indicators tmax and tmin (part of the ray_info) are also provided to ray_box_aabb. Here, tmin is the distance along the ray to start looking for intersection. Tmax is the distance along the ray to stop looking for intersections.</p><heading id="h-0010" level="1">FIG. <b>9</b> (Ray_Box_aabb <b>610</b>)</heading><p id="p-0080" num="0090"><figref idref="DRAWINGS">FIG. <b>9</b></figref> schematically illustrates one instance of ray_box_aabb <b>610</b> which receives the signal's <b>820</b>, <b>850</b> from ray_box_test <b>600</b> and generates a single instance of the visit flag <b>840</b> to be returned to ray_box_test <b>600</b>.</p><p id="p-0081" num="0091">The calculations in <figref idref="DRAWINGS">FIG. <b>9</b></figref> are also responsive to a scale value <b>900</b> which is part of the node along with parent and child coordinates. The scale value <b>900</b> is expressed as a power of two, and child vertices at the upper right <b>905</b> and lower left <b>910</b> positions are expressed relative to the vertex of the parent volume and the sign <b>915</b> of the inverse direction. Circuitry <b>920</b>, <b>930</b>, <b>935</b>, <b>940</b> operating during the pipeline stage PO generates the exponent (exp) and mantissa (mant) of 7 bit precision values child_offset_hi and child_offset_lo, being rounded upwards or downwards respectively. In particular, the circuitry <b>930</b> comprises leading zero detectors (LZD) and the circuitry <b>940</b> comprises left shifters (LSH).</p><p id="p-0082" num="0092">In more detail, at the circuitry <b>920</b> the child_hi <b>905</b> and child_lo <b>910</b> data are swapped depending on the sign of the inverse of the direction. This is not an arithmetic operation but rather a selection of child_hi or child_lo as input to the modules <b>930</b>.</p><p id="p-0083" num="0093">The outputs of the swapping circuitry <b>920</b>, which are integer numbers, are converted to a floating-point scaled number. This is done by computing the mantissa in the LZD-LSH modules <b>930</b>, <b>940</b> and the exponent in the 8-bit adders <b>935</b>.</p><p id="p-0084" num="0094">The mantissa calculation consists of detecting the number of leading zeros in the integer value (circuitry <b>930</b>, LZD) and left-shifting the integer value (circuitry <b>940</b>, LSH) to place the first non-zero bit at the most-significant position, because the floating-point value is normalized. The 8-bit integer value is converted to floating-point with 7-bit fraction plus the hidden integer bit.</p><p id="p-0085" num="0095">The exponent is computed in <b>935</b> from the scaling factor and the number of leading zeros.</p><p id="p-0086" num="0096">In a pipeline stage P<b>1</b>, adders <b>945</b>, <b>950</b> combine Parent_dist_hi with child_offset_hi using &#x201c;RAZ&#x201d; (rounding away from zero) to generate child_dist_hi expressed to a 10 bit precision, being the child volume's offset from the origin rounded up, and combine Parent_dist_lo with child_offset_lo using &#x201c;RTZ&#x201d; (rounding towards zero) to generate child_dist_lo expressed to a 10 bit precision, being the child volume's offset from the origin rounded down.</p><p id="p-0087" num="0097">In a pipeline stage P2, a pair of floating-point multipliers <b>955</b>, <b>960</b>, using RAZ and RTZ respectively generate exit <b>965</b> and entry <b>970</b> values by multiplying the inverse direction (hi and lo respectively) with the child distance (hi and lo respectively). These represent the maximum and minimum possible intersection points with the child volume under consideration, and circuitry operating in a pipeline stage P3 compares these with tmax and tmin <b>980</b> received from ray_box_test representing a range of distances along the ray which are to be checked.</p><p id="p-0088" num="0098">The logic executing in P3 generates a true outcome for the indication visit when (by an AND gate <b>975</b>) all of the following conditions (tested by respective 10 bit comparators <b>985</b>) are met:<ul id="ul0007" list-style="none">    <li id="ul0007-0001" num="0000">    <ul id="ul0008" list-style="none">        <li id="ul0008-0001" num="0099">furthest entry&#x3c;=tmax</li>        <li id="ul0008-0002" num="0100">closest exit&#x3e;=tmin</li>        <li id="ul0008-0003" num="0101">closest exit&#x3e;=furthest entry</li>    </ul>    </li></ul></p><p id="p-0089" num="0102">The visit indication <b>840</b> is returned to ray_box_test. As discussed above, for any of the child volumes for which visit is true, that child volume becomes (under the control of the control circuitry <b>330</b>) a parent volume for a next iteration of the operation of the circuitry of <figref idref="DRAWINGS">FIG. <b>6</b></figref>.</p><heading id="h-0011" level="1">Ray_Triangle_Test_Wrapper <b>700</b></heading><p id="p-0090" num="0103">In contrast to ray_test_box <b>600</b>, this simply forwards information it receives (as set out in <figref idref="DRAWINGS">FIG. <b>7</b></figref>) to the ray_triangle_test circuitry <b>710</b> and forwards the &#x201c;hit&#x201d; indication from ray_triangle_test. Therefore, detailed circuitry does not need to be described here. The testing of intersection with a triangle is performed by the ray_triangle_test circuitry <b>710</b>.</p><heading id="h-0012" level="1">FIGS. <b>10</b>-<b>13</b> (Ray_Triangle_Test Circuitry <b>710</b>)</heading><p id="p-0091" num="0104">The arrangement for testing whether a particular primitive triangle is intersected by the ray under test is instantiated when the testing performed in respect of the BVH reaches a leaf node level. Testing performed at levels above the leaf node level simply indicates that a next level down of the BVH should be tested. It is the final test performed in respect of a primitive triangle which is definitive in terms of setting display parameters of that primitive triangle. The passing of data between the ray box testing and the ray triangle testing may be performed by the control circuitry <b>330</b> as described above.</p><p id="p-0092" num="0105"><figref idref="DRAWINGS">FIGS. <b>10</b> and <b>11</b></figref> combine to illustrate the operation of the ray_triangle_test circuitry <b>710</b>, in that <figref idref="DRAWINGS">FIG. <b>10</b></figref> schematically represents pipeline cycles P0-P4 whereas <figref idref="DRAWINGS">FIG. <b>11</b></figref> schematically represents pipeline cycles P5-P10. As mentioned above, this relates to an example arrangement&#x2014;the number of cycles could be different in other examples in return for a potential change in power consumption. Referring to <figref idref="DRAWINGS">FIG. <b>10</b></figref>, the circuitry <b>710</b> receives from the ray_triangle_test_wrapper circuitry <b>700</b> data <b>1000</b> defining the origin and three vertices V0, V1 ,V2 of the triangle under test; data <b>1005</b> providing the range indications tmax, tmin mentioned above; and flags indicating an invalid input, and opaque triangle and the like and the ray direction <b>1015</b>. A top left flag <b>1010</b> will be described further below.</p><p id="p-0093" num="0106">During a cycle P0, adders <b>1025</b> add the respective x, y and z coordinates of the vertices V0, V1, V2 to that of the origin so as to generate a translated vertex distance coordinate with respect to the origin. Comparator circuitry <b>1020</b> compares the vector coordinates of the ray to detect the largest of them. The coordinates of the ray and of the outputs of the adders <b>1025</b> are reordered so that the other two coordinates are referenced relative to the largest coordinate. This has the effect of simplifying the calculations which follow to a two-dimensional problem to be resolved.</p><p id="p-0094" num="0107">During a cycle P1, circuitry <b>1030</b> generates the reciprocal of the largest coordinate, so that the other two reordered coordinates are now referred to as kx, ky and the reciprocal of the largest coordinate is referred to as dz.</p><p id="p-0095" num="0108">At a cycle P2, multipliers <b>1035</b> generate:</p><p id="p-0096" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>dx=kx*dz; </i>and<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0097" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>dy=ky*dz </i><?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0098" num="0000">and a multiplier <b>1040</b> generates values vz equal to the value dz multiplied by the z value vtnz (reordered largest coordinate) of the translated vertex distance coordinates from the origin.</p><p id="p-0099" num="0109">At a cycle P3, multipliers <b>1050</b> multiply the z value (reordered largest coordinate) of the translated vertex distance coordinates by dx and dy respectively.</p><p id="p-0100" num="0110">At a cycle P4, adders <b>1055</b> add the output of the adders <b>1050</b> to the respective x and y values (reordered non-largest coordinates) vtnx, vtny of the translated vertex distance from the origin.</p><p id="p-0101" num="0111">The variables passed onto <figref idref="DRAWINGS">FIG. <b>11</b></figref> are vxn, vyn and vzn, where n=0 . . . 2 for each of the vertices.</p><p id="p-0102" num="0112">Moving on to <figref idref="DRAWINGS">FIG. <b>11</b></figref>, at a cycle P5, multipliers <b>1100</b> perform the calculations vx[i]*vy[i&#x2212;1] for i=1, 2 and vx[i]*vy[i+1] for i=0,1. These are added together by adder circuitry <b>1105</b> in a cycle P6 to generate values e0, e1, e2.</p><p id="p-0103" num="0113">In more detail, in P5 and P6 the following are generated by the circuitries <b>1100</b>, <b>1105</b>:</p><p id="p-0104" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>e</i>0=(<i>vx</i>[2]*<i>v</i>[<i>y</i>[1])&#x2212;(<i>vy</i>[2]*<i>vx</i>[1])<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0105" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>e</i>1=(<i>vx</i>[0]*<i>v</i>[<i>y</i>[2])&#x2212;(<i>vy</i>[0]*<i>vx</i>[2])<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0106" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>e</i>2=(<i>vx</i>[1]*<i>v</i>[<i>y</i>[0])&#x2212;(<i>vy</i>[1]*<i>vx</i>[0])<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0107" num="0114">It is as the [i&#x2212;1] and [i+1] index may be considered to increment in a circular or modulo 2 fashion or in other words 0&#x2192;1&#x2192;2&#x2192;0,</p><p id="p-0108" num="0000"><maths id="MATH-US-00001" num="00001"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mrow>      <mo>(</mo>      <mrow>       <mi>i</mi>       <mo>+</mo>       <mn>1</mn>      </mrow>      <mo>)</mo>     </mrow>     <mo>=</mo>     <mn>1</mn>    </mrow>   </mtd>   <mtd>    <mrow>     <mrow>      <mi>If</mi>      <mo>&#x2062;</mo>      <mrow>       <mtext> </mtext>       <mtext>  </mtext>      </mrow>      <mo>&#x2062;</mo>      <mi>i</mi>     </mrow>     <mo>=</mo>     <mn>0</mn>    </mrow>   </mtd>  </mtr>  <mtr>   <mtd>    <mrow>     <mo>=</mo>     <mn>2</mn>    </mrow>   </mtd>   <mtd>    <mrow>     <mrow>      <mi>if</mi>      <mo>&#x2062;</mo>      <mtext>   </mtext>      <mi>i</mi>     </mrow>     <mo>=</mo>     <mn>1</mn>    </mrow>   </mtd>  </mtr>  <mtr>   <mtd>    <mrow>     <mo>=</mo>     <mn>0</mn>    </mrow>   </mtd>   <mtd>    <mrow>     <mrow>      <mi>if</mi>      <mo>&#x2062;</mo>      <mtext>   </mtext>      <mi>i</mi>     </mrow>     <mo>=</mo>     <mn>2</mn>    </mrow>   </mtd>  </mtr>  <mtr>   <mtd>    <mrow>     <mrow>      <mo>(</mo>      <mrow>       <mi>i</mi>       <mo>-</mo>       <mn>1</mn>      </mrow>      <mo>)</mo>     </mrow>     <mo>=</mo>     <mn>2</mn>    </mrow>   </mtd>   <mtd>    <mrow>     <mrow>      <mi>if</mi>      <mo>&#x2062;</mo>      <mtext>   </mtext>      <mi>i</mi>     </mrow>     <mo>=</mo>     <mn>0</mn>    </mrow>   </mtd>  </mtr>  <mtr>   <mtd>    <mrow>     <mo>=</mo>     <mn>0</mn>    </mrow>   </mtd>   <mtd>    <mrow>     <mrow>      <mi>if</mi>      <mo>&#x2062;</mo>      <mtext>   </mtext>      <mi>i</mi>     </mrow>     <mo>=</mo>     <mn>1</mn>    </mrow>   </mtd>  </mtr>  <mtr>   <mtd>    <mrow>     <mo>=</mo>     <mn>1</mn>    </mrow>   </mtd>   <mtd>    <mrow>     <mrow>      <mi>if</mi>      <mo>&#x2062;</mo>      <mtext>   </mtext>      <mi>i</mi>     </mrow>     <mo>=</mo>     <mn>2</mn>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0109" num="0115">At a cycle P7, various actions are taken. Multiplier circuitry <b>1110</b> multiplies en*vzn to generate tsc(x, y, z). This is part of the scaled depth of vertices computation. This computation is done in cycles P7, P8 and P9. A final scaled depth, t_scaled, is obtained in P9, as t_scaled=tsc(x)+tsc(y)+tsc(z).</p><p id="p-0110" num="0116">Adder circuitry <b>1115</b> adds e0+e1. Tie-break circuitry <b>1120</b> (to be described further with reference to <figref idref="DRAWINGS">FIGS. <b>12</b> and <b>13</b></figref> acts in respect of dealing with a tie-break situation and culling circuitry <b>1125</b> responsive to the flags discussed above generates a culling signal which overrides the generation of a hit.</p><p id="p-0111" num="0117">At a cycle P<b>8</b>, detector circuitry <b>1130</b> detects from the e0, e1, e2 values whether the ray is outside of the triangle and if so provides an indication <b>1135</b> to hit logic <b>1140</b> to be described below. Adder circuitry <b>1145</b> generates det=(e0 +e1+e2) and adder circuitry <b>1150</b> adds tsc(x) +tsc(y).</p><p id="p-0112" num="0118">At a cycle P9, det is multiplied by tmax and tmin by multipliers to provide scaled tmax, tmin. Reciprocal circuitry <b>1160</b> calculates the reciprocal of det, Inv det, circuitry <b>1165</b> checks the determinant det and adder circuitry <b>1170</b> generates t_scaled=tsc(x)+tsc(y)+tsc(z). If the determinant is zero then this is assumed to be indicative of there not being a hit.</p><p id="p-0113" num="0119">Finally, at a cycle P10, comparator circuitry <b>1175</b> compares the scaled tmax, tmin with t_scaled to confirm that any intersection lies within the required ray range defined by tmax, tmin, the output being provided to the hit logic <b>1140</b>, multipliers <b>1180</b> multiply each of e0, e1 by Inv det and multiplier circuitry <b>1185</b> multiplies t_scaled by Inv det. The outputs of the two multipliers <b>1180</b> and the multiplier <b>1185</b> are provided to and gates <b>1190</b> where they are gated by a signal <b>1195</b> generated by the hit logic. In particular, if the ray hits the triangle, hit=1, the barycentric coordinates of the actual intersection, hit_u and hit_v, and the distance from origin, hit_t, are provided as an output. The barycentric coordinates and the distanced are forced to be 0 if a hit does not happen, hit=0.</p><heading id="h-0013" level="1">FIGS. <b>12</b>-<b>13</b> (Tie Break Rule Circuitry <b>1120</b>)</heading><p id="p-0114" num="0120">A so-called tie-break situation can occur when a particular pixel position lies on the boundary between two or more triangles (for example, intersection can happen on an edge shared by 2 triangles or on a vertex shared by multiple triangles). Fundamentally, intersection is deemed to occur if a pixel position is within a triangle or if it is on an edge defined by the so-called top-left rule. So, given that the intersection test performed by the circuitry described above will give a true outcome if the intersection position is within the triangle or on an edge, the top-left rule decides whether an edge intersection is with an edge complying with the top-left rule such that the current triangle would &#x201c;win&#x201d; over another triangle sharing that edge.</p><p id="p-0115" num="0121">The relevant testing can be applied without knowledge of an adjacent triangle, simply by detecting whether an edge such as an edge at which an intersection is detected would comply with the top-left rule. If it would, then the intersection is detected as a valid hit. If not, then an intersection with the adjacent triangle would win and so the intersection is detected not to be a valid hit.</p><p id="p-0116" num="0122">As shown schematically in <figref idref="DRAWINGS">FIG. <b>12</b></figref>, three instances of top-left rule circuitry <b>1200</b> act on respective ones of the three triangle edges. <figref idref="DRAWINGS">FIG. <b>13</b></figref> shows one such instance. In terms of timing, the circuitry <b>1200</b> receives data during P0 defining the two vertices which in turn defined the edge to be considered and return a value &#x201c;is_top_left&#x201d; relevant to that edge during P2. The tie break rule circuitry <b>1120</b> detects, for an intersection at a given edge, whether the is_top_left flag is set to indicate that the given edge would win against an adjacent triangle. If so, then the hit logic <b>1140</b> is controlled to allow a hit at that edge, but if not the hit logic <b>1140</b> is controlled to deny a hit at that edge. The processing relating to the tie-break rule circuitry <b>1120</b> is performed at P7 as shown schematically by <figref idref="DRAWINGS">FIG. <b>12</b></figref>.</p><p id="p-0117" num="0123">The circuitry <b>1200</b> therefore provides an example of conflict detection circuitry configured to determine, for a detection of an intersection between a given virtual ray and a set of two or more contiguous test regions, which of the set of two or more contiguous test regions is intersected by the given virtual ray. In the present example, the conflict detection circuitry <b>1200</b> is operable in parallel with the ray tracing circuitry to provide the determination of which of the set of two or more contiguous test regions is intersected by the given virtual ray for use by the ray tracing circuitry at a given pipeline stage (P2, P7 as drawn) of operation of the ray tracing circuitry.</p><p id="p-0118" num="0124">The top-left rule as used here (in a two-dimensional variant) defines that a point is considered to overlap the triangle if it meets some predetermined conditions, as derived by the circuitry example of <figref idref="DRAWINGS">FIG. <b>13</b></figref> discussed below.<ul id="ul0009" list-style="none">    <li id="ul0009-0001" num="0000">    <ul id="ul0010" list-style="none">        <li id="ul0010-0001" num="0125">First create another ray perpendicular to the ray direction.</li>        <li id="ul0010-0002" num="0126">Perform a dot product of this new ray with the edge vector of interest.</li>        <li id="ul0010-0003" num="0127">If dot product is positive, point is inside the triangle. If dot product is negative, point is outside the triangle.</li>        <li id="ul0010-0004" num="0128">If the point lies on a vertex, dot-products with both the edges of interest should return positive values to be considered a hit.</li>    </ul>    </li></ul></p><p id="p-0119" num="0129">Referring to <figref idref="DRAWINGS">FIG. <b>13</b></figref>, the circuitry <b>1200</b> receives the ray direction <b>1300</b> and the two vertices <b>1310</b> of the edge under consideration. These are expressed according to the raw (not reordered) coordinates discussed above.</p><p id="p-0120" num="0130">At the cycle P0, circuitry <b>1315</b> computes a vector perpendicular to the ray direction <b>1300</b>. Adder circuitry <b>1320</b> adds the x and y coordinates of the two vertices (as reordered) and comparator circuitry <b>1325</b> compares the pairs of coordinates for the two vertices in a lexicographic order, which is to say the non-re-ordered order x,y,z. Here, the sign of the dot product between the perpendicular direction to the ray and the edge gives the relative orientation. If the dot product is 0 the vertices are compared at the circuitry <b>1325</b> to obtain the relative orientation.</p><p id="p-0121" num="0131">At the cycle P1, multiplier circuitry <b>1330</b> multiplies the respective x and y coordinates of the perpendicular and the output of the adder <b>1320</b>.</p><p id="p-0122" num="0132">At the cycle P2, comparator circuitry <b>1335</b> compares the x and y products generated by the multiplier circuitry <b>1330</b> to produce either an equality indicator eq or a greater than indicator gt representing the result of a comparison between the two components of the dot product. One of these is selected as the is_top_left output in response to the output lex_order of the comparator circuitry <b>1325</b>.</p><p id="p-0123" num="0133">In more detail, the dot product is not calculated completely because only the sign of the dot product is needed. To get the complete dot product an adder would be needed after the multiplications in <b>1330</b>. The sign of the dot product is in fact derived by the comparator <b>1335</b>.</p><p id="p-0124" num="0134">If the two inputs to the comparator are equal then the lexicographic order is used</p><p id="p-0125" num="0135">The lexicographic order is computed in parallel to the dot product in <b>1325</b> to be used after the comparator.</p><heading id="h-0014" level="1">Summary of Features</heading><p id="p-0126" num="0136">The circuitry described above is a fully pipelined unit. Each floating-point operation other than division is completed in one pipeline cycle. Parallel processing is provided of three coordinates and three vertices. Sub-normal or denormal values are simply not allowed. Only two rounding modes are employed.</p><heading id="h-0015" level="1">Method Example</heading><p id="p-0127" num="0137"><figref idref="DRAWINGS">FIG. <b>14</b></figref> is a schematic flowchart illustrating a method comprising:</p><p id="p-0128" num="0138">ray tracing (at a step <b>1400</b>) by a plurality of floating-point processing operations to detect intersection between a virtual ray defined by a ray direction and a test region, the floating-point processing operations operating to a given precision to generate an output floating-point value comprising a significand and an exponent; and</p><p id="p-0129" num="0139">for at least some of the plurality of floating-point circuitries, rounding (at a step <b>1410</b>) using a predetermined directed rounding mode any denormal floating-point value generated by that floating-point processing operation so as to output normal values (for example, only normal values), a denormal floating-point value being a floating-point value in which the significand comprises one or more leading zeroes.</p><heading id="h-0016" level="1">Other Example Implementations</heading><p id="p-0130" num="0140">Concepts described herein may be embodied in computer-readable code for fabrication of an apparatus that embodies the described concepts. For example, the computer-readable code can be used at one or more stages of a semiconductor design and fabrication process, including an electronic design automation (EDA) stage, to fabricate an integrated circuit comprising the apparatus embodying the concepts. The above computer-readable code may additionally or alternatively enable the definition, modelling, simulation, verification and/or testing of an apparatus embodying the concepts described herein.</p><p id="p-0131" num="0141">For example, the computer-readable code for fabrication of an apparatus embodying the concepts described herein can be embodied in code defining a hardware description language (HDL) representation of the concepts. For example, the code may define a register-transfer-level (RTL) abstraction of one or more logic circuits for defining an apparatus embodying the concepts. The code may be define a HDL representation of the one or more logic circuits embodying the apparatus in Verilog, SystemVerilog, Chisel, or VHDL (Very High-Speed Integrated Circuit Hardware Description Language) as well as intermediate representations such as FIRRTL. Computer-readable code may provide definitions embodying the concept using system-level modelling languages such as SystemC and SystemVerilog or other behavioural representations of the concepts that can be interpreted by a computer to enable simulation, functional and/or formal verification, and testing of the concepts.</p><p id="p-0132" num="0142">Additionally or alternatively, the computer-readable code may embody computer-readable representations of one or more netlists. The one or more netlists may be generated by applying one or more logic synthesis processes to an RTL representation. Alternatively or additionally, the one or more logic synthesis processes can generate from the computer-readable code a bitstream to be loaded into a field programmable gate array (FPGA) to configure the FPGA to embody the described concepts. The FPGA may be deployed for the purposes of verification and test of the concepts prior to fabrication in an integrated circuit or the FPGA may be deployed in a product directly.</p><p id="p-0133" num="0143">The computer-readable code may comprise a mix of code representations for fabrication of an apparatus, for example including a mix of one or more of an RTL representation, a netlist representation, or another computer-readable definition to be used in a semiconductor design and fabrication process to fabricate an apparatus embodying the invention. Alternatively or additionally, the concept may be defined in a combination of a computer-readable definition to be used in a semiconductor design and fabrication process to fabricate an apparatus and computer-readable code defining instructions which are to be executed by the defined apparatus once fabricated.</p><p id="p-0134" num="0144">Such computer-readable code can be disposed in any known transitory computer-readable medium (such as wired or wireless transmission of code over a network) or non-transitory computer-readable medium such as semiconductor, magnetic disk, or optical disc.</p><p id="p-0135" num="0145">An integrated circuit fabricated using the computer-readable code may comprise components such as one or more of a central processing unit, graphics processing unit, neural processing unit, digital signal processor or other components that individually or collectively embody the concept.</p><p id="p-0136" num="0146">Therefore, it will be appreciated that example embodiments may encompass a non-transitory computer-readable medium to store computer-readable code for fabrication of the circuitry discussed above.</p><heading id="h-0017" level="1">General Matters</heading><p id="p-0137" num="0147">In the present application, the words &#x201c;configured to . . . &#x201d; are used to mean that an element of an apparatus has a configuration able to carry out the defined operation. In this context, a &#x201c;configuration&#x201d; means an arrangement or manner of interconnection of hardware or software. For example, the apparatus may have dedicated hardware which provides the defined operation, or a processor or other processing device may be programmed to perform the function. &#x201c;Configured to&#x201d; does not imply that the apparatus element needs to be changed in any way in order to provide the defined operation.</p><p id="p-0138" num="0148">Although illustrative embodiments of the invention have been described in detail herein with reference to the accompanying drawings, it is to be understood that the invention is not limited to those precise embodiments, and that various changes and modifications can be effected therein by one skilled in the art without departing from the scope and spirit of the invention as defined by the appended claims.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-math idrefs="MATH-US-00001" nb-file="US20230005209A1-20230105-M00001.NB"><img id="EMI-M00001" he="18.71mm" wi="76.20mm" file="US20230005209A1-20230105-M00001.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. Circuitry comprising:<claim-text>ray tracing circuitry comprising a plurality of floating-point circuitries to perform floating-point processing operations to detect intersection between a virtual ray defined by a ray direction and a test region, the floating-point circuitries operating to a given precision to generate an output floating-point value comprising a significand and an exponent;</claim-text><claim-text>in which at least some of the plurality of floating-point circuitries are configured to round using a predetermined directed rounding mode any denormal floating-point value generated by operation of that circuitry so as to output normal values, a denormal floating-point value being a floating-point value in which the significand comprises one or more leading zeroes.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The circuitry of <claim-ref idref="CLM-00001">claim 1</claim-ref>, in which at least some of the plurality of floating-point circuitries are configured to round to zero any denormal floating-point value generated by operation of that circuitry.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The circuitry of <claim-ref idref="CLM-00001">claim 1</claim-ref>, in which at least some of the plurality of floating-point circuitries are configured to round to a minimum normal representation any denormal floating-point value generated by operation of that circuitry.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The circuitry of <claim-ref idref="CLM-00001">claim 1</claim-ref>, in which the ray tracing circuitry is responsive to ray data indicating the ray direction, the ray data defining a reciprocal of a ray vector representing the ray direction;<claim-text>the ray tracing circuitry comprising multiplier circuitry configured to perform a division by the ray vector by implementing a multiplication by the ray data defining the reciprocal of the ray vector.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The circuitry of <claim-ref idref="CLM-00001">claim 1</claim-ref>, in which the ray tracing circuitry is configured to perform processing operations according to clock cycles of a succession of clock cycles.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The circuitry of <claim-ref idref="CLM-00005">claim 5</claim-ref>, in which each of the floating-point circuitries is configured to perform a respective floating-point operation according to a single respective one of the succession of clock cycles.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The circuitry of <claim-ref idref="CLM-00005">claim 5</claim-ref>, in which the ray tracing circuitry operates as pipelined circuitry having a plurality of successive pipeline stages.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The circuitry of <claim-ref idref="CLM-00007">claim 7</claim-ref>, comprising conflict detection circuitry configured to determine, for a detection of an intersection between a given virtual ray and a set of two or more contiguous test regions, which of the set of two or more contiguous test regions is intersected by the given virtual ray.</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The circuitry of <claim-ref idref="CLM-00008">claim 8</claim-ref>, in which the conflict detection circuitry is operable in parallel with the ray tracing circuitry to provide the determination of which of the set of two or more contiguous test regions is intersected by the given virtual ray for use by the ray tracing circuitry at a given pipeline stage of operation of the ray tracing circuitry.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The circuitry of <claim-ref idref="CLM-00001">claim 1</claim-ref>, in which the ray tracing circuitry is configured to detect intersection of the virtual ray with a hierarchical set of bounding volumes.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The circuitry of <claim-ref idref="CLM-00010">claim 10</claim-ref>, in which, at a given hierarchy level, each bounding volume comprises a predetermined number of bounding volumes at a next lower hierarchy level.</claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The circuitry of <claim-ref idref="CLM-00011">claim 11</claim-ref>, in which the ray tracing circuitry is configured, for the given hierarchy level, to detect intersection of the virtual ray with each of the bounding volumes at the next lower hierarchy level.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The circuitry of <claim-ref idref="CLM-00012">claim 12</claim-ref>, in which the ray tracing circuitry comprises the predetermined number of intersection-detecting circuitries operable in parallel, one intersection-detecting circuitry being configured to detect intersection for a respective one of the predetermined number of bounding volumes at a next lower hierarchy level.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The circuitry of <claim-ref idref="CLM-00013">claim 13</claim-ref>, in which the predetermined number is 6.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The circuitry of <claim-ref idref="CLM-00003">claim 3</claim-ref>, in which:<claim-text>the ray tracing circuitry is responsive to ray data indicating the ray direction, the ray data defining a reciprocal of a ray vector representing the ray direction;</claim-text><claim-text>the ray tracing circuitry comprising multiplier circuitry configured to perform a division by the ray vector by implementing a multiplication by the ray data defining the reciprocal of the ray vector;</claim-text><claim-text>the ray tracing circuitry is configured to perform processing operations according to clock cycles of a succession of clock cycles, in which each of the floating-point circuitries is configured to perform a respective floating-point operation according to a single respective one of the succession of clock cycles, in which the ray tracing circuitry operates as pipelined circuitry having a plurality of successive pipeline stages; and</claim-text><claim-text>in which the ray tracing circuitry is configured to detect intersection of the virtual ray with a hierarchical set of bounding volumes, in which, at a given hierarchy level, each bounding volume comprises a predetermined number of bounding volumes at a next lower hierarchy level and in which the ray tracing circuitry is configured, for the given hierarchy level, to detect intersection of the virtual ray with each of the bounding volumes at the next lower hierarchy level and in which the ray tracing circuitry comprises the predetermined number of intersection-detecting circuitries operable in parallel, one intersection-detecting circuitry being configured to detect intersection for a respective one of the predetermined number of bounding volumes at a next lower hierarchy level.</claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The circuitry of <claim-ref idref="CLM-00015">claim 15</claim-ref>, comprising conflict detection circuitry configured to determine, for a detection of an intersection between a given virtual ray and a set of two or more contiguous test regions, which of the set of two or more contiguous test regions is intersected by the given virtual ray, in which the conflict detection circuitry is operable in parallel with the ray tracing circuitry to provide the determination of which of the set of two or more contiguous test regions is intersected by the given virtual ray for use by the ray tracing circuitry at a given pipeline stage of operation of the ray tracing circuitry.</claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. A graphics processing unit having a hardware ray tracing accelerator comprising the circuitry of <claim-ref idref="CLM-00001">claim 1</claim-ref>.</claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. A non-transitory computer-readable medium to store computer-readable code for fabrication of the circuitry of <claim-ref idref="CLM-00001">claim 1</claim-ref>.</claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. A method comprising:<claim-text>performing ray tracing circuitry by a plurality of floating-point processing operations to detect intersection between a virtual ray defined by a ray direction and a test region, the floating-point processing operations operating to a given precision to generate an output floating-point value comprising a significand and an exponent; and</claim-text><claim-text>for at least some of the plurality of floating-point circuitries, rounding using a predetermined directed rounding mode any denormal floating-point value generated by that floating-point processing operation so as to output normal values, a denormal floating-point value being a floating-point value in which the significand comprises one or more leading zeroes.</claim-text></claim-text></claim></claims></us-patent-application>