<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004410A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004410</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17902520</doc-number><date>20220902</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>451</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>50</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20180201</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>452</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>5077</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>2209</main-group><subgroup>5011</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">SYSTEMS AND METHODS OF AUTO-SCALING A VIRTUAL DESKTOP ENVIRONMENT</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>17696311</doc-number><date>20220316</date></document-id><parent-status>PENDING</parent-status></parent-doc><child-doc><document-id><country>US</country><doc-number>17902520</doc-number></document-id></child-doc></relation></continuation><us-provisional-application><document-id><country>US</country><doc-number>63161700</doc-number><date>20210316</date></document-id></us-provisional-application></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Nerdio, Inc.</orgname><address><city>Chicago</city><state>IL</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Vladimirskiy</last-name><first-name>Vadim</first-name><address><city>Chicago</city><state>IL</state><country>US</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A system for dynamically auto-scaling allocated capacity of a virtual desktop environment includes: base capacity resources and burst capacity resources and memory coupled to a controller; wherein, in response to executing program instructions, the controller is configured to: in response to receiving a log in request from a first user device, connect the first user device to a first host pool to which the first device user is assigned; execute a load-balancing module to determine a first session host virtual machine to which to connect the first user device; and execute an auto-scaling module comprising a user-selectable auto-scaling trigger and a user-selectable conditional auto-scaling action, wherein, in response to recognition of the conditional auto-scaling action, the controller powers on or powers off one or more base capacity resources or creates or destroys one or more burst capacity resources.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="49.95mm" wi="158.75mm" file="US20230004410A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="160.78mm" wi="128.27mm" file="US20230004410A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="203.37mm" wi="173.48mm" orientation="landscape" file="US20230004410A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="230.46mm" wi="82.63mm" orientation="landscape" file="US20230004410A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="218.95mm" wi="74.93mm" orientation="landscape" file="US20230004410A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="205.32mm" wi="84.50mm" orientation="landscape" file="US20230004410A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="182.03mm" wi="100.41mm" orientation="landscape" file="US20230004410A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="242.74mm" wi="84.58mm" orientation="landscape" file="US20230004410A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="242.65mm" wi="84.33mm" orientation="landscape" file="US20230004410A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="196.60mm" wi="86.44mm" orientation="landscape" file="US20230004410A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="189.40mm" wi="92.63mm" orientation="landscape" file="US20230004410A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="246.04mm" wi="145.46mm" orientation="landscape" file="US20230004410A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="258.66mm" wi="171.11mm" orientation="landscape" file="US20230004410A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="242.99mm" wi="124.80mm" orientation="landscape" file="US20230004410A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00014" num="00014"><img id="EMI-D00014" he="259.93mm" wi="139.11mm" orientation="landscape" file="US20230004410A1-20230105-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00015" num="00015"><img id="EMI-D00015" he="261.45mm" wi="145.46mm" orientation="landscape" file="US20230004410A1-20230105-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00016" num="00016"><img id="EMI-D00016" he="261.37mm" wi="157.40mm" orientation="landscape" file="US20230004410A1-20230105-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">CROSS-REFERENCE TO PRIOR APPLICATIONS</heading><p id="p-0002" num="0001">The present application comprises a continuation of U.S. application Ser. No. 17/696,311 filed Mar. 16, 2022, which claims the benefit of priority to U.S. Provisional Application No. 63/161,700 filed Mar. 16, 2021, the entireties of which are incorporated herein by reference.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">BACKGROUND OF THE INVENTION</heading><p id="p-0003" num="0002">The present subject matter relates generally to the real-time auto-scaling of a virtual desktop environment. More specifically, the present invention relates to systems and methods for automatically scaling up and down allocated capacity of a virtual desktop environment and for providing dynamic cost estimation tools and visualization tools for the scalable environment.</p><p id="p-0004" num="0003">End-user experience is extremely important for virtual desktop technology adoption. End-user experience depends primarily on performance. Performance depends on working in a properly-sized computing environment that is providing the right amount of compute resources at the right time. If the environment is undersized, the resulting poor computing performance leads to a poor user experience. On the other side of the analysis, if the environment is oversized, user experience will be excellent, but the costs of operating the environment will be higher than necessary.</p><p id="p-0005" num="0004">In public cloud environments, the cost of the virtual desktop environment is determined by the allocated capacity. Allocated capacity is the amount of the allocated resources and the period of time for which the resources are allocated. For example, the allocated capacity may be defined by the number of CPU cores, GB of RAM, and GB of storage, etc. are allocated to a customer for a specified period of time. In public cloud environments, the cost of allocated capacity is independent from the utilization of the allocated capacity. In other words, the cost of allocated capacity is not affected by the utilization or lack of utilization of the allocated capacity. Generally speaking, if one allocates a large amount of capacity for a specified time, the full cost of that allocation will be incurred, even if the allocated capacity is never used.</p><p id="p-0006" num="0005">Accordingly, in a public cloud environment, there is a constant challenge of balancing an appropriately-sized amount of capacity with the actual demand for that capacity. This is especially important in virtual desktop scenarios where insufficient capacity leads to poor end-user experience and excess capacity leads to high costs. Complicating the challenge is that demand is typically not constant over time. For example, a typical business environment presents very different virtual desktop demands during normal business operating hours as compared to times outside of those business operating hours. Thus, what may be appropriate capacity at a given time during a given day of the week, may be considered unnecessary over-capacity on a different day and/or time.</p><p id="p-0007" num="0006">In typical public cloud environments, IT administrators are forced to estimate the &#x201c;peak demand&#x201d; on a particular system (i.e., how much capacity will be needed at peak utilization times) and then allocate the resources necessary to support the peak capacity at all times not being able to perfectly predict when these peaks will occur. As a result, the system administrator is paying for excess capacity at all times when the actual system demand is below peak demand. In normal business environments, it is rare that the actual system demands require all of the allocated resources more than an occasional minority of the time. As a result, the majority of the time, the system administrator is paying for excess (i.e., under-utilized) capacity.</p><p id="p-0008" num="0007">Accordingly, there is a need for dynamically auto-scaling allocated capacity of a virtual desktop environment.</p><p id="p-0009" num="0008">As noted above, the typical public cloud environment does not provide any meaningfully dynamic scaling tools for increasing or decreasing allocated capacity. Additionally, there are specific challenges that may arise when dealing with scaling down allocated capacity of a system that is in use.</p><p id="p-0010" num="0009">Virtual desktop sessions are tied to a specific virtual machine (VM). It is currently not possible to dynamically &#x201c;move&#x201d; a virtual desktop session from one VM to another without logging the user out of their current session, which requires saving all data and closing all applications. Therefore, it is important to consider all of the implications when scaling in (i.e., scaling down) capacity to make it as non-disruptive as possible to the end-users while at the same time optimizing cost savings.</p><p id="p-0011" num="0010">In the process of normal operation, session host VMs can become &#x201c;broken,&#x201d; meaning they can go into a state where they cannot properly serve user desktop sessions. When this happens in existing virtual desktop environments, the host pool capacity is diminished and manual remediation is required to figure out what caused the problem and to manually repair the session hot VMs. In order to automatically scale the virtual desktop environment, it would be beneficial to further automatically heal any broken hosts.</p><p id="p-0012" num="0011">Accordingly, there is a need for systems and methods for managing a scale in process for a virtual desktop environment, as described herein.</p><p id="p-0013" num="0012">One major benefit of public cloud environments are their utility-like, consumption-based billing. Unfortunately, the flexibility in configuring the various options available to a system administrator leads to a tremendous amount of complexity required to understand cost implications of choices made when configuring a virtual desktop environment. In many cases, it is only after the invoice is received at the end of the month that the costs are clear.</p><p id="p-0014" num="0013">Any system that manages to incorporate scaling in virtual desktop environments to provide costs savings in compute and storage costs in a public cloud, consumption-driven environment, will have additional complexities in understanding the even more complex cost implications.</p><p id="p-0015" num="0014">Accordingly, there is a need for systems and methods for providing dynamic cost estimation tools and visualization tools for a virtual desktop environment, as described herein.</p><heading id="h-0003" level="1">BRIEF SUMMARY OF THE INVENTION</heading><p id="p-0016" num="0015">To meet the needs described above and others, the present disclosure provides systems and methods for automatically scaling up and down allocated capacity of a virtual desktop environment and for providing dynamic cost estimation tools and visualization tools for the scalable environment.</p><p id="p-0017" num="0016">In order to facilitate a more complete and coherent description of the present subject matter, it is helpful to first describe and define key elements of the system. First, as used herein, a &#x201c;VM&#x201d; is a virtual machine. A &#x201c;Virtual Desktop&#x201d; is a streamed Windows&#xae; operating system session running on a VM in a cloud environment. However, it is understood that the operating system is not limited to a Windows-based system. In other embodiments, a Virtual Desktop may be provided using a different operating system. A &#x201c;Multi-Session Desktop&#x201d; is a VM hosting multiple virtual desktops sessions using a multi-session operating system (e.g., Windows Server or Windows 10 multi-session). A &#x201c;Single-Session Desktop,&#x201d; also known as &#x201c;Single User Desktop&#x201d; is a virtual desktop session running on its own VM as the only desktop session on that VM. A &#x201c;User Session&#x201d; is a connection of a user to virtual desktop resource (i.e., session host). Sessions can be active (i.e., user currently logged into a virtual desktop) or disconnected (i.e., user was active on a virtual desktop session host, but has since disconnected without logging off). In a disconnected state, applications stay open on the virtual desktop session. A &#x201c;Session Host&#x201d; (or &#x201c;Host&#x201d;) is a Windows VM acting as a provider of single-session or multi-session desktop sessions. A &#x201c;Host Pool&#x201d; is a collection of session hosts. Users connect to a host pool and are directed to one of the session host members of the pool depending on load and any related load balancing algorithm. A &#x201c;Pooled Host Pool&#x201d; is a host pool in which a desktop session is served from any session host VM, as determined by current load and load balancing algorithm. A &#x201c;Personal Host Pool&#x201d; is a host pool in which each user's desktop session is served by a specific/persistent session host VM. In a personal host pool, only one VM in a personal host pool can serve a single user. As used herein, &#x201c;Scale Out&#x201d; means increasing capacity of a host pool by powering on adding additional members session host VMs to the host pool. After the scale out completes, the new virtual desktop sessions will be &#x201c;landed&#x201d; on the newly added capacity. &#x201c;Scale In&#x201d; means decreasing capacity of a host pool by powering off or removing session host VMs. &#x201c;Scale Up&#x201d; means increasing capacity by sizing a VM up (e.g., the number of CPUs and/or GB of RAM). A scale up requires a reboot in order to make the change in capacity. &#x201c;Scale Down&#x201d; means decreasing capacity by sizing a VM down. A scale down requires a reboot to make the change in capacity. A &#x201c;Connection Broker&#x201d; is a software service that receives users' connection request to virtual desktops and decides which session host VM to which to route the session depending on load and any load balancing algorithm. Lastly, in &#x201c;Drain Mode,&#x201d; session hosts do not accept any new connections, but any existing user sessions are unaffected.</p><p id="p-0018" num="0017">In the systems and methods taught herein, a scale out mechanism is provided to detect increases in demand on the system and dynamically grow the system capacity to meet demand, rather than keeping the system capacity always on even when not used. Various examples are provided.</p><p id="p-0019" num="0018">In the context of a virtual desktop environment, when a user connects to a host pool to which the user is assigned, a connection broker service uses a load-balancing algorithm to determine which session host VM to which to connect this user. For instance, with a &#x201c;breadth first&#x201d; load balancing algorithm, the session would be landed on the session host with the least number of sessions. In traditional virtual desktop environments, when the system is overloaded, meaning the user sessions exceed the system's available capacity, new sessions will either be denied (if the maximum session setting is set per host) or landed on already overloaded session hosts, which would lead to poor performance for the user. However, in the systems and methods taught herein, an auto-scale system scales out (i.e., grow capacity) when demand exceeds a certain user-defined threshold.</p><p id="p-0020" num="0019">In the systems and methods provided herein, there are two types of capacity in a virtual desktop environment: (1) base capacity; and (2) burst capacity. Base capacity comprises a minimum number of VMs that are pre-provisioned and always available in the host pool. The VMs may be on or off, but they are created in advance (i.e., pre-provisioned) and are always available in the host pool. Base capacity VMs are quick to power on, since they already exist, but they constantly consume operating system (OS) disk storage, which means that they cost money even when not running. By contrast, burst capacity comprises VMs that are created on demand based on an auto-scale trigger. Burst capacity VMs do not consume resources until they are created (on demand), but they take longer to create than simply powering on the preexisting base capacity VMs.</p><p id="p-0021" num="0020">In designing an auto-scale configuration for a virtual desktop environment, the first step is to define the possible host pool sizing in terms of the number of VMs and the number of powered on VMs at any given time.</p><p id="p-0022" num="0021">For example, in some embodiments of the systems and methods provided herein, the active session host VM may be defined as: (1) VM Started; or (2) WVD Agent Available. VM Started means the active session host VM is a running VM. The VM is considered active regardless of whether it's available for connectivity for a virtual desktop session or not. WVD agent Available means a VM is reporting that it's available for virtual desktop session connection. The Base Host Pool Capacity is the number of VMs that are pre-provisioned and available in the host pool, at a minimum, at all times. The VMs are counted whether they are on or off. The Min Active Host Capacity is the number of VMs that are &#x201c;active&#x201d; at all times. The Burst Beyond Base Capacity is the number of VMs that can be created, on demand, above and beyond the base capacity &#x201c;if needed&#x201d;.</p><p id="p-0023" num="0022">In a primary embodiment of the systems and methods described herein, the host pool sizing definition provides the base capacity and burst capacity, from which one can derive the minimum size of the host pool (i.e., the base capacity) and the maximum size of the host pool (i.e., the base capacity plus the burst capacity). It also defines the minimum number of active VMs (i.e., the min active host capacity) and the maximum active VMs (i.e., the base capacity and the burst capacity). Each of these factors may be determined by user controls that enable an administrator to configure the system. Depending on how an administrator configures the system, it is contemplated that any given virtual desktop environment may include only base capacity, only burst capacity, or any combination of the two. The balance between the base capacity and the burst capacity can be optimized for quick start time, cost savings, performance, etc.</p><p id="p-0024" num="0023">In the systems and methods provided herein, the actual size of the host pool at any given time is controlled by the scaling logic, which provides scale out control using two operations: (1) powering on the base capacity VMs; and (2) creating additional VMs from the available burst capacity.</p><p id="p-0025" num="0024">With respect to the size of the host pool, the system may be configured to automatically make a certain amount of capacity available in anticipation of user demand (rather than in response to user demand). This is referred to herein as pre-staging capacity. For instance, if users of the virtual desktop environment typically start work at 8 AM Monday-Friday, the system may determine how long it takes to pre-stage the needed capacity so the system can begin pre-staging the appropriate base capacity and/or burst capacity early enough before 8 AM to have everything ready by 8 AM. The system may do so by calculating the average scale out duration and calculating the offset from 8 AM to begin the operation. For example, a pre-staging user control may include controls for setting which days of the week to perform a pre-staging operation, the time by which the pre-staging should be complete, and the number of hosts to be active by the time by which the pre-staging should be complete.</p><p id="p-0026" num="0025">Once the pre-staging is complete and the system is in use, user defined scaling logic may control any scale out that takes place in the pooled host pool based on various factors such as: (1) CPU usage; (2) average active sessions per host; (3) available sessions; (4) user experience; (5) event-triggered; (6) machine learning based artificial intelligence triggers; etc. Similarly, user defined scaling logic may control any scale out in the personal host pool based on various factors such as: (1) work hours power on/off; (2) start VM on logon; etc.</p><p id="p-0027" num="0026">In a first example, the user-defined scaling logic may include an auto-scale trigger based on CPU usage within the system. For example, the scaling logic may be defined such that the system creates a defined number of new hosts when CPU utilization across all hosts exceeds a defined percentage of capacity for a defined duration. Such a command may be &#x201c;start or create (scale out) up to 1 host (s) if CPU utilization across all hosts exceeds 65% for 5 minutes.&#x201d;</p><p id="p-0028" num="0027">This scaling logic allows the system to determine when the host pool is &#x201c;getting busy&#x201d; and, in anticipation of a new user login, add additional hosts. The duration variable allows the system to avoid scaling out when there are momentary CPU spikes and only scale out when there is sustained high CPU activity. Monitoring the average utilization across all existing hosts helps to identify when that system is getting busy. If the CPU usage is already very high (i.e., running into the limits), adding more capacity is &#x201c;too late&#x201d; because the existing users who are already connected to hosts in the host pool are already overwhelming their hosts. Accordingly, it is important to add capacity before the system becomes too busy, so users are more equally balanced and user performance is not adversely affected. Setting the number of hosts to scale out informs the system of the batch size of the number of hosts that will be added, either powered on (e.g., base capacity) or created (e.g., burst capacity), once the CPU threshold is tripped. In small environments, adding a single host at a time may be sufficient, but in very large environments, with a high &#x201c;user arrival rate,&#x201d; it may be necessary to add multiple hosts to the host pool at the same time to accommodate the high demand.</p><p id="p-0029" num="0028">In a second example, the user-defined scaling logic may include an auto-scale trigger based on the average active sessions per host within the system. For example, the scaling logic may be defined such that the system creates a defined number of new hosts when the average active sessions per host exceeds a defined number. Such a command may be &#x201c;start or create (scale out) up to 1 host (s) if the average active sessions across all hosts exceeds 1.&#x201d; In this example, when the average active sessions across all hosts in the host pool exceed a certain value, the system automatically adds capacity by either powering on base capacity VMs or creating new burst capacity VMs. This is a trigger that can be used when the number of sessions a host can accommodate is known. For example, if a host can accommodate 10 sessions, it may be useful to add more session hosts when the average exceeds 8 or 9. In this example, the number of hosts to add can be 1 or more. In small environment adding hosts in batches of 1 may be sufficient. In large environments, with high user arrival rates, it may be necessary to add hosts in larger batches.</p><p id="p-0030" num="0029">In a third example, the user-defined scaling logic may include an auto-scale trigger based on the available sessions within the system. For example, the scaling logic may be defined such that the system creates a defined number of new hosts when the number of available sessions drops below a defined number. Such a command may be &#x201c;maintain up to 5 available sessions, subject to host pool sizing maximum base capacity plus burst capacity.&#x201d;</p><p id="p-0031" num="0030">In this example, the system automatically maintains a pre-defined number of available sessions in the virtual desktop environment up to the maximum capacity (i.e., base capacity plus burst capacity). In this scenario, the number of sessions a host can accommodate is known and the system is told to maintain a &#x201c;buffer&#x201d; of available sessions. As users login, the number of available sessions decreases. Once the number of available sessions falls below the specified buffer, new hosts are either powered on (e.g., base capacity) or created (e.g., burst capacity) and the buffer grows.</p><p id="p-0032" num="0031">In this example, it is important to know how many sessions a host can accommodate, otherwise there is no way to know how many available sessions there are at any given time. When the number of sessions a host can accommodate is known, the system will behave as follows. The host pool sizing determines the minimum number of active hosts. This number is multiplied by the maximum sessions per host to get the initial buffer size. As users log in, the number of available sessions decreases. Once the number of available sessions is below the specified amount (e.g., 5), another host is made active by powering on additional base capacity or by creating hosts from the burst capacity. The buffer then grows by the maximum sessions per host multiplied by the number of new hosts. This continues until all host capacity is on, at which point the buffer will continue to decrease down to 0.</p><p id="p-0033" num="0032">In a fourth example, the user-defined scaling logic may include an auto-scale trigger based on the user virtual desktop experience. The user virtual desktop experience can be measured in terms of input delay latency or other metrics that represents how well the user's virtual desktop session is responding. As the system gets busier, the responsiveness decreases and user experiences becomes worse. An auto-scale trigger can be based on user experience decreasing below a certain threshold. When this happens, the auto-scale logic will add new capacity to the host pool by either powering on or creating new VMs. As with other auto-scale triggers, the batch size can be customized.</p><p id="p-0034" num="0033">In a fifth example, the user-defined scaling logic may include an auto-scale trigger based on various real-world events. For example, various real-world events can signal that users are ready to start work and sufficient capacity should be made available to accommodate their logins. For instance, there may be a sensor in the parking garage of an office building that measures how full it is and communicates this value to the system. Once the system recognizes that the garage is above a certain percentage full (i.e., a user-defined capacity), the auto-scale logic may create additional capacity for a given number of users. Each time more cars arrive in excess of the user-defined capacity, or the garage is an additional percentage full, the system automatically scales out to create additional capacity while the users are making their way to the office.</p><p id="p-0035" num="0034">In a sixth example, historical information about user logins over a period of time can be used to derive a schedule based on which the host pool should scale out in anticipation of (i.e., not in response to) user demand. During normal work days/hours, the system may scale out in anticipation of user logins. During holidays, the system may not scale out since the system anticipates that no user demand (or reduced/limited user demand) will be coming.</p><p id="p-0036" num="0035">The six examples above are all directed to auto-scaling logic that is applied to a pooled host pool. In some virtual desktop environments, personal desktops are persistently assigned to individual users. In these personal host pool systems, it is not possible to add arbitrary session host VMs and make them available to users when they are needed or remove extra VMs when they are not needed, because each user must use their own desktop VM and cannot user any others. Therefore, a special type of auto-scaling mechanism is needed for personal host pool systems in which it is not possible to create and delete VMs on demand, it is only possible to power on VMs when they are needed. The following two examples: (1) work hours power on/off; and (2) start VM on logon are provided to show how an auto-scaling logic that can be applied in a personal host pool environment.</p><p id="p-0037" num="0036">In a first example, working hours are defined. For example, working hours may be set for Monday through Sunday, 8 AM to 6 PM Central Time (UTC-06:00). Settings may be provided for &#x201c;power off aggressiveness&#x201d; (e.g., low, medium, or high) and &#x201c;power on timing&#x201d; (e.g., once or continuous). The power off aggressiveness defines how quickly the system reacts to turn off the VMs in response to non-use or manual power down. When the power on timing is set to once, the VMs are powered on a single time in response to the opening of a working hours window (and therefore can be powered off by user action). When the power on timing user control is set to continuous, the VMs remain powered on during working hours, even if the user or administrator attempts to power on or more of the VMs off manually.</p><p id="p-0038" num="0037">In a second example, the auto-scale logic automatically powers on personal desktop session host VMs when a user login is detected. In one example, in response to a user initiated a login request, the request is received by the connection broker service and the logged in database. The auto-scaling logic system then receives a trigger event or proactively polls the connection broker service and logged in database. When the system recognizes a login attempt for a powered off personal desktop VM, the auto-scaling logic causes the appropriate personal desktop session host VM automatically starts.</p><p id="p-0039" num="0038">The examples above describe scale out logic for virtual desktop environments. However, after a host pool is scaled out (whether a pooled host pool or personal host pool), if it is not scaled back in, the system is no better than a non-auto-scaling scenario in which there is more capacity allocated than is needed and costs are needlessly high. Therefore, to provide the objectives and advantages of the systems and methods described herein, the systems and methods include a mechanism to scale in (i.e., reduce capacity) of a host pool when the excess capacity is no longer needed.</p><p id="p-0040" num="0039">When implementing a scale in mechanism, it is important to recognize that virtual desktop sessions are tied to a specific VM. It is currently not possible to dynamically &#x201c;move&#x201d; a virtual desktop session from one VM to another without logging the user out of their current session, which requires saving all data and closing all applications. Therefore, it is important to consider all of the implications when scaling in capacity to make it as non-disruptive as possible to the end-users while at the same time optimizing cost savings.</p><p id="p-0041" num="0040">The following paragraphs describe six examples of auto-scaling logic for scaling in a virtual desktop environment in a pooled host pool environment. The six examples demonstrate how the scale in logic may be triggered by: (1) CPU usage; (2) average active sessions; (3) available sessions; (4) event triggers; (5) user experience; and (6) work hour schedules.</p><p id="p-0042" num="0041">In an example of auto-scaling logic applied to a scale in process based on CPU usage, scale in occurs once the CPU usage drops below a pre-configured threshold and stays there for the defined number of minutes. Once this condition is met, a specified batch of VMs is stopped or removed. For example, the logic may be defined such that the system stops or removes (i.e., scales in) up to 1 host(s) when CPU utilization across all hosts drops below 40% for 15 minutes.</p><p id="p-0043" num="0042">In an example of auto-scaling logic applied to a scale in process based on average active sessions, scale in occurs once the average active sessions per host falls below a pre-defined number. At that point, VMs are removed in defined batch sizes. For example, the logic may be defined such that the system stops or removes (i.e., scales in) up to 1 host(s) when the average active sessions across all hosts falls below 1.</p><p id="p-0044" num="0043">In an example of auto-scaling logic applied to a scale in process based on available sessions, scale in occurs once the pool of available sessions exceeds the minimum buffer. In response to the pool of available sessions exceeding the minimum buffer, hosts are powered off or removed as long as doing so maintains the minimum buffer after the operation. For example, if the minimum buffer is 5, each host can accommodate 10 sessions, and there are currently 14 available sessions, scaling in 1 host would result in 4 sessions being available (i.e., less than the minimum buffer) and, therefore, the host would not be shut down. In the same scenario, if there were 15 available sessions, then a host would be scaled in to reduce consumption without violating the minimum buffer requirement.</p><p id="p-0045" num="0044">In an example of auto-scaling logic applied to a scale in process based on event triggers, when the number of cars in the monitored parking garage drops below a certain threshold, one or more hosts are scaled in as the parking capacity indicates that users are not in the office.</p><p id="p-0046" num="0045">In an example of auto-scaling logic applied to a scale in process based on user experience, if user experience increases above a certain level, VMs are scaled in to remove unneeded capacity.</p><p id="p-0047" num="0046">As with the scale out functions described above, the scale in function may apply to either pooled host pools or personal host pools. For example, in a personal host pool setting, the auto-scale logic may be based on typical office hours. After a specified time (e.g., 6 PM), if the VM is not in use, it may be automatically powered down. The power down function may be applied once or continuously. When the power down timing is set to once, the VMs are powered down a single time in response to the closing of a working hours window (and therefore can be powered on by user action). When the power down timing user control is set to continuous, the VMs remain powered off during non-working hours, even if the user or administrator attempts to power one or more of the VMs on manually.</p><p id="p-0048" num="0047">Each of the examples of scale in logic may be subject to one or more scale in restrictions. Scale in restrictions are used to promote optimized balances of cost savings vs. end-user experience. Scale in restriction settings impose restrictions on the scenarios in which scale in can occur to avoid being overly disruptive to end users. For example, scale in should not occur during lunch hour when the system utilization drops simply because users are away from their desk. Scaling in at this time would not only cause users sessions to be disconnected, which will close their applications, but will also require a scale out to occur within an hour when users come back to their desks and resume their work. Therefore, it may be valuable to enable a user to set time periods within which scale in can occur and/or time periods in which scale in cannot occur.</p><p id="p-0049" num="0048">In addition, the systems and methods provided herein may be subject to user controls over the scale in aggressiveness. When scaling in, VMs are either shut down or destroyed (depending on base capacity vs. burst capacity settings). Either approach is disruptive to any users currently logged into these VMs. The scale in aggressiveness user settings allow system administrators to balance user disruption with cost savings. For example, in a primary embodiment, there may be three user defined aggressiveness settings: low; medium; and high.</p><p id="p-0050" num="0049">In this example, if the system administrator chooses to set the scale in aggressiveness setting to low, only hosts that have zero active and disconnected sessions will be scaled in. The system continuously monitors the virtual desktop environment for presence of such hosts and scales them in during the allowed time window (i.e., subject to the scale in restrictions described above). This setting results in the least amount of user disruption (e.g., no user disruption), but is not guaranteed to produce any cost savings if users are not disciplined about logging out of their virtual desktops when they are done using them.</p><p id="p-0051" num="0050">In this example, if the system administrator chooses to set the scale in aggressiveness setting to medium, those hosts that have no active session (i.e., those hosts with either no session at all or only disconnected sessions) can be scaled in during the allowed times. This results in disruption to disconnected sessions (i.e., applications are closed), but is more likely to produce compute saving by removing underutilized VMs.</p><p id="p-0052" num="0051">In this example, if the system administrator chooses to set the scale in aggressiveness setting to high, all hosts above the minimum active capacity are scaled in regardless of whether or not they have sessions. In prioritizing the scale in target VMs, the system may first choose to scale in those hosts with no sessions. Once the first group of hosts are scaled in, the system may then choose to scale in those hosts that have the least number of sessions, set the host to drain mode (i.e., prevent any new connections), send the users a warning message on their virtual desktop screen to give them X minutes to log out and log back in. For example, the user control may allow the administrator to define the number of minutes warning the users are given before scaling the host. The warning message may say something like, &#x201c;Sorry for the interruption. We are doing some housekeeping and need you to log out. You can log in right away and continue working. We will be terminating your session in 10 minutes if you have not logged out by then.&#x201d; When the users log out and then back in, they are connected to a different host that is not in drain mode. The system continues this process until either the utilization becomes appropriately high or the minimum number of active hosts is reached. In this high setting scale in aggressiveness scenario, scale in savings are very likely because all underutilized capacity will be scaled in when possible.</p><p id="p-0053" num="0052">In some examples of the systems and methods provided herein, the auto-scaling system includes an auto-heal function for session host VMs. In such embodiments, the auto-scaling system is continuously monitoring the status of the session hosts and is aware of any changes from a &#x201c;healthy&#x201d; state to a &#x201c;broken&#x201d; state in order to take prescriptive actions to repair broken hosts.</p><p id="p-0054" num="0053">In one example, session host status is provided by a WVD agent, which is software installed inside of each session host that facilitates a connection between the end-user and the VM serving the virtual desktop session. The WVD agent has broad visibility of what is happening on the VM and reports the status back to the WVD management service. The normal status is Available. There are several other states that can indicate a problem with the VM, including, for example: Unavailable; FSLogix not healthy; No heartbeat; SxS stack listener not ready; Shutdown; Disconnected; Upgrading; Update failed; Not joined to domain; Domain trust relationship lost; and Needs assistance.</p><p id="p-0055" num="0054">An auto-heal broken hosts GUI provides the system administrator with the ability to define what constitutes a broken host (some status may be normal or transient in some environments) and configure an action of what to do when a broken host is detected. The auto-scaling system kicks into action auto-healing broken hosts after it has fully scaled out the environment to avoid dealing with &#x201c;maintenance&#x201d; type tasks when more capacity needs to be brought online. Once the scale out process is complete, the auto-scaling system can start healing any broken hosts.</p><p id="p-0056" num="0055">As part of the configuration defining a broken host, the administrator can also specify whether a broken host should be repaired if it has any user sessions on it. It is possible for users to have connected to a host before the host went into broken state. The administrator can configure whether hosts with any session, or with active sessions, should be acted upon or not.</p><p id="p-0057" num="0056">In some examples, the remediation actions can be a combination of: restarting the session hosts one or more times, with delays in between the attempts; deleting and re-creating the session hosts from golden image; and other actions that depend on the broken session host status. For example, the system administrator can define the number of restart attempts, the time (e.g., in minutes) between restart attempts, and how to handle unrecoverable hosts (e.g., remove and re-create).</p><p id="p-0058" num="0057">Various embodiments of the systems and methods provided herein include dynamic, in-line cost estimation to the user (e.g., system administrator) while they are configuring the dynamic host pool auto-scaling. This allows the user to immediately see the impact of the selected configuration choices without having to open a separate spreadsheet or calculator application. The cost estimation tool provides the user with the &#x201c;boundaries&#x201d; of the possible costs. That is, the minimum and maximum possible costs across two dimensions of compute and storage, which constitute the 90%+ of the total cost of the typical virtual desktop environment.</p><p id="p-0059" num="0058">For example, the user interface through which the auto-scaling logic is controlled may include a chart providing the estimated monthly costs for the minimum and maximum costs for the compute and for the storage capacity.</p><p id="p-0060" num="0059">The compute cost is the cost of virtual machine compute capacity. This depends on the geographic region, selected VM family, amount of CPU/RAM/storage and other factors. Compute costs are incurred only by VMs that are running. Stopped (i.e., deallocated) VMs exist, but they do not consume compute costs.</p><p id="p-0061" num="0060">The storage cost is the cost of operating system disk storage that is attached to a VM. Factors that contribute to the storage cost include the cost of storage demands on the geographic region where it exists, the type of disk (premium SSD, standard SSD, HDD, etc.), and the size of the storage disk. Costs for storage are incurred regardless if whether the VM that it's attached to is running or stopped. The only time storage costs stop being incurred is when the VM and its associated OS disk is deleted (e.g., removal of burst capacity).</p><p id="p-0062" num="0061">The minimum cost is the cost of compute/storage under the assumptions that the system will stay at its minimum (i.e., scaled in) size and never scale out. The cost of storage depends on: (1) the number of base host pool capacity VMs, since these always exist and the OS disks consume costs; and (2) the cost of storage of any additional VMs that get created during pre-staging that are above the base capacity for the duration between pre-stage time and beginning of scale in restriction time. The cost of compute depends on: (1) the minimum active host capacity as this is the amount of computer that will be running 24/7 at a minimum; and (2) the cost of compute of pre-staged capacity between the hours of beginning of work hours (i.e., pre-stage time) and beginning of scale in restrictions.</p><p id="p-0063" num="0062">The maximum cost is the cost of compute/storage under the assumption that the system will scale out to its maximum size and never scale in. The maximum cost of storage is based on the maximum host pool size. That is the base capacity plus burst capacity running at all times. The maximum cost of compute is similarly based on assuming the system runs at all times.</p><p id="p-0064" num="0063">Some embodiments of the systems and methods taught herein capture actual compute and storage utilization on a minute-by-minute basis. This allows the systems to understand the &#x201c;actual&#x201d; costs of an environment, which is what the user would see when they receive their invoice. However, also knowing the configuration of a particular host pool and its auto-scale settings, these systems can understand the minimum possible costs (i.e., if system never scales out), maximum possible costs (i.e., if system scales out and never scales back in), peak costs (i.e., if the host pool is statically sized to accommodate peak demand&#x2014;somewhere between actual and maximum costs) and, as a result, can derive the savings delivered by the auto-scaling processes.</p><p id="p-0065" num="0064">In some embodiments, costs and savings may be captured graphically at the host pool level and then viewed over any selected period of time. For example, the system may automatically scale out days days per week based on schedule and user demand and scale back in two days per week when it's no longer needed. Savings are reflected as the difference between the peak costs (i.e., what it would cost to run the system statically powered on for the selected duration at its highest usage over the period) and actual costs.</p><p id="p-0066" num="0065">Seeing costs and savings data on a per host pool basis is useful to understand past behavior, but it is useful to see this information on an aggregated basis over a standard period of time (e.g., a month) and over multiple host pools grouped into workspaces. This aggregation over time allows the user to understand the complete costs and auto-scale savings with respect to the entire virtual desktop environment.</p><p id="p-0067" num="0066">Understanding historical costs is helpful, but ultimately decision makers need to understand the projected costs over a standardized period of time (e.g., a month). The systems and methods taught herein enable accurate monthly projections about monthly savings as a result of auto-scaling based on a short sample period of data collection. This data is extrapolated over the standardized period and can be presented in-line at the host pool and workspace level.</p><p id="p-0068" num="0067">With cloud computing costs being &#x201c;infrastructure size&#x201d; dependent (e.g., VM size, OS disk type, etc.) and each unit of infrastructure being able to deliver services to a unpredictable number of individual users (i.e., employees), it is difficult to understand the cost of a complex technology like virtual desktops, especially with auto-scaling, on a per user basis. Because the systems and methods described herein provide visibility into utilization by users, possible auto-scale size ranges of the infrastructure, and actual costs incurred by the infrastructure in response to user demand, it is possible to calculate projected, standardized unit costs on a per-user basis.</p><p id="p-0069" num="0068">In one embodiment, a system for dynamically auto-scaling allocated capacity of a virtual desktop environment includes: a scalable virtual desktop environment comprising a base capacity resources, including base compute resources and base storage resources, and a burst capacity resources, including burst compute resources and burst storage resources; a server including a controller controlling the operation of the base capacity resources and the burst capacity resources; a memory coupled to the controller, wherein the memory is configured to store program instructions executable by the controller; wherein, in response to executing the program instructions, the controller is configured to: in response to receiving a log in request from a first user device, connect the first user device to a first host pool to which the first device user is assigned; execute a load-balancing module to determine a first session host virtual machine to which to connect the first user device; and execute an auto-scaling module comprising a user-selectable auto-scaling trigger and a user-selectable conditional auto-scaling action, wherein, in response to recognition of the conditional auto-scaling action, the controller powers on or powers off one or more base capacity resources or creates or destroys one or more burst capacity resources.</p><p id="p-0070" num="0069">The controller may be further configured to: in response to receiving a log in request from a first user device, connect a second user device to a second host pool to which the second device user is assigned.</p><p id="p-0071" num="0070">The controller may be further configured to provide a host pool sizing tool including user controls for defining an active host, a base host pool capacity, a minimum active host capacity, and a burst beyond base capacity.</p><p id="p-0072" num="0071">The controller may be further configured to provide a pre-stage hosts tool including user controls for defining one or more work days, a start of work hours, and a number of hosts to be active by the start of work hours.</p><p id="p-0073" num="0072">The controller may be further configured to provide a CPU usage scaling out logic tool including user controls for an auto-scale trigger selection and a number of host to scale out when the CPU utilization exceeds a given capacity for a given duration.</p><p id="p-0074" num="0073">The controller may be further configured to provide an average active sessions per host scaling out logic tool including user controls for an auto-scale trigger selection and a number of host to scale out when the average active sessions per host exceeds a given number.</p><p id="p-0075" num="0074">The controller may be further configured to provide an available sessions scaling out logic tool including user controls for an auto-scale trigger selection, a maximum sessions per host, and a minimum number of available sessions that need to be maintained at all times.</p><p id="p-0076" num="0075">The controller may be further configured to provide a working hours scaling out logic tool including user controls for a day of the week selection tool, a time range selection tool, a setting for power off aggressiveness, and a setting for power on timing.</p><p id="p-0077" num="0076">The controller may be further configured to provide a CPU usage scaling logic tool including user controls for scale out and scale in definitions including an auto-scale trigger selection and a number of host to scale out when the CPU utilization exceeds a given capacity for a given duration, and a number of hosts to scale in when the CPU utilization drops below a given capacity for a given duration.</p><p id="p-0078" num="0077">The controller may be further configured to provide an average active sessions scaling logic tool including user controls for scale out and scale in definitions including an auto-scale trigger selection and a number of host to scale out when the average active sessions across all hosts exceeds a given value, and a number of hosts to scale in when an average active sessions across all hosts is below a given value.</p><p id="p-0079" num="0078">The controller may be further configured to provide a scale in restrictions tool including user controls for selecting times in which scale in will be restricted and a level of scale in aggressiveness to apply.</p><p id="p-0080" num="0079">The controller may be further configured to provide a scale in messaging tool including user controls for when to send a message relative to a scale in action and a control for editing a message to be sent.</p><p id="p-0081" num="0080">The controller may be further configured to provide e an auto-heal broken hosts tool including a user controls defining how to identify when to heal a broken session host, including applicable WVD agent statuses and whether hosts with any session or with active sessions should be acted upon, a number of restart attempts, a time between restart attempts, and how to handle unrecoverable hosts.</p><p id="p-0082" num="0081">An object of the invention is to provide automatic scaling features (scaling in and scaling out) in a virtual desktop environment so as to optimize the cost vs. performance characteristics of the environment.</p><p id="p-0083" num="0082">Another object of the invention is to provide tools for scaling in a virtual desktop environment with minimal disruption to users that are logged into the environment.</p><p id="p-0084" num="0083">An additional object of the invention is to provide dynamic cost estimation and visualization tools that empower system administrators to better understand the cost implications of the user directed scaling logic.</p><p id="p-0085" num="0084">An advantage of the invention is the user directed scaling logic allows a system administrator to control triggers and responses in the logic to provide greater flexibility and adaptability.</p><p id="p-0086" num="0085">Another advantage of the invention is the user directed scaling logic allows a system administrator to balance disruption vs. cost savings.</p><p id="p-0087" num="0086">Additional objects, advantages and novel features of the examples will be set forth in part in the description which follows, and in part will become apparent to those skilled in the art upon examination of the following description and the accompanying drawings or may be learned by production or operation of the examples. The objects and advantages of the concepts may be realized and attained by means of the methodologies, instrumentalities and combinations particularly pointed out in the appended claims.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0088" num="0087">The drawing figures depict one or more implementations in accord with the present concepts, by way of example only, not by way of limitations. In the figures, like reference numerals refer to the same or similar elements.</p><p id="p-0089" num="0088"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a schematic of a system for automatically scaling up and down allocated capacity of a virtual desktop environment.</p><p id="p-0090" num="0089"><figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates a host pool sizing tool.</p><p id="p-0091" num="0090"><figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates a pre-stage hosts tool.</p><p id="p-0092" num="0091"><figref idref="DRAWINGS">FIG. <b>4</b></figref> illustrates a CPU usage scaling logic tool.</p><p id="p-0093" num="0092"><figref idref="DRAWINGS">FIG. <b>5</b></figref> illustrates an average active sessions per host usage scaling logic tool.</p><p id="p-0094" num="0093"><figref idref="DRAWINGS">FIG. <b>6</b></figref> illustrates an available sessions scaling logic tool.</p><p id="p-0095" num="0094"><figref idref="DRAWINGS">FIG. <b>7</b></figref> illustrates a working hours scaling logic tool.</p><p id="p-0096" num="0095"><figref idref="DRAWINGS">FIG. <b>8</b></figref> illustrates a CPU usage scaling logic tool including scale out and scale in definitions.</p><p id="p-0097" num="0096"><figref idref="DRAWINGS">FIG. <b>9</b></figref> illustrates an average active sessions scaling logic tool including scale out and scale in definitions.</p><p id="p-0098" num="0097"><figref idref="DRAWINGS">FIG. <b>10</b></figref> illustrates a scale in restrictions tool.</p><p id="p-0099" num="0098"><figref idref="DRAWINGS">FIG. <b>11</b></figref> illustrates a scale in messaging tool.</p><p id="p-0100" num="0099"><figref idref="DRAWINGS">FIG. <b>12</b></figref> illustrates an auto-heal broken hosts GUI.</p><p id="p-0101" num="0100"><figref idref="DRAWINGS">FIG. <b>13</b></figref> illustrates a dynamic cost estimation GUI.</p><p id="p-0102" num="0101"><figref idref="DRAWINGS">FIG. <b>14</b></figref> illustrates a cost tracking GUI.</p><p id="p-0103" num="0102"><figref idref="DRAWINGS">FIG. <b>15</b></figref> illustrates an aggregated cost and savings display at host pool level over a month.</p><p id="p-0104" num="0103"><figref idref="DRAWINGS">FIG. <b>16</b></figref> illustrates an aggregated cost and savings display at workspace level over a month.</p><p id="p-0105" num="0104"><figref idref="DRAWINGS">FIG. <b>17</b></figref> illustrates a projected costs display at a host pool level.</p><p id="p-0106" num="0105"><figref idref="DRAWINGS">FIG. <b>18</b></figref> illustrates a projected costs display at a workspace level.</p><p id="p-0107" num="0106"><figref idref="DRAWINGS">FIG. <b>19</b></figref> illustrates a projected monthly unit cost display for per-named and per concurrent user on the host pool level.</p><p id="p-0108" num="0107"><figref idref="DRAWINGS">FIG. <b>20</b></figref> illustrates a projected monthly unit cost display for per-named and per concurrent user on the workspace level.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0005" level="1">DETAILED DESCRIPTION OF THE INVENTION</heading><p id="p-0109" num="0108"><figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates a schematic of a system for automatically scaling up and down allocated capacity of a virtual desktop environment <b>100</b> (system <b>100</b>). As shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the system <b>100</b> includes a user device <b>102</b> in communication with an IT environment <b>104</b>. The user device <b>102</b> shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref> is a personal computer (PC). In the example shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the various tools, controls, GUIs (i.e., graphical user interfaces), displays, described below with reference to <figref idref="DRAWINGS">FIGS. <b>2</b>-<b>20</b></figref> are presented to the user through the user device <b>102</b>. Although shown as a PC in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, in alternative embodiments, the user device <b>102</b> can be a mobile device, such as a smartphone or tablet, a server, or any other computing device through which a user, such as a system administrator, may interact with the IT environment <b>104</b> to perform the features and functions described herein.</p><p id="p-0110" num="0109"><figref idref="DRAWINGS">FIGS. <b>2</b>-<b>20</b></figref> illustrate various user controls and displays for executing the features and functions in an example embodiment of the system <b>100</b>. As noted above, in a primary embodiment, the various user controls and displays described with reference to <figref idref="DRAWINGS">FIGS. <b>2</b>-<b>20</b></figref> are presented to, and controlled by, a user through the user device <b>102</b>.</p><p id="p-0111" num="0110">In the systems and methods provided herein, there are two types of capacity in a virtual desktop environment: (1) base capacity; and (2) burst capacity. Base capacity comprises a minimum number of VMs that are pre-provisioned and always available in the host pool. The VMs may be on or off, but they are created in advance (i.e., pre-provisioned) and are always available in the host pool. Base capacity VMs are quick to power on, since they already exist, but they constantly consume operating system (OS) disk storage, which means that they cost money even when not running. By contrast, burst capacity comprises VMs that are created on demand based on an auto-scale trigger. Burst capacity VMs do not consume resources until they are created (on demand), but they take longer to create than simply powering on the preexisting base capacity VMs.</p><p id="p-0112" num="0111">In designing an auto-scale configuration for a virtual desktop environment, the first step is to define the possible host pool sizing in terms of the number of VMs and the number of powered on VMs at any given time.</p><p id="p-0113" num="0112">For this purpose, <figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates a host pool sizing tool <b>106</b> providing user controls including: a active host control <b>108</b> (e.g., VM started vs. WVD Agent Available), a base host pool capacity control <b>110</b> (e.g., the number of hosts in the pool), a minimum active host capacity control <b>112</b> (e.g., the number of hosts in the pool), and a burst beyond base capacity control <b>114</b> (e.g., up to X extra hosts in the pool).</p><p id="p-0114" num="0113">Using the active host control <b>108</b> shown in <figref idref="DRAWINGS">FIG. <b>2</b></figref>, the active session host VM may be defined as: (1) VM Started; or (2) WVD Agent Available. VM Started means the active session host VM is a running VM. The VM is considered active regardless of whether it's available for connectivity for a virtual desktop session or not. WVD agent Available means a VM is reporting that it's available for virtual desktop session connection.</p><p id="p-0115" num="0114">The base host pool capacity control <b>110</b> defines the number of VMs that are pre-provisioned and available in the host pool, at a minimum, at all times. The VMs are counted whether they are on or off.</p><p id="p-0116" num="0115">The minimum active host capacity control <b>112</b> defines the number of VMs that are &#x201c;active&#x201d; at all times.</p><p id="p-0117" num="0116">The burst beyond base capacity control <b>114</b> defines the number of VMs that can be created, on demand, above and beyond the base capacity &#x201c;if needed&#x201d;.</p><p id="p-0118" num="0117">In a primary embodiment of the systems <b>100</b> and methods described herein, the host pool sizing definition controlled by the host pool sizing tool <b>106</b> provides the base capacity and burst capacity, from which one can derive the minimum size of the host pool (i.e., the base capacity) and the maximum size of the host pool (i.e., the base capacity plus the burst capacity). It also defines the minimum number of active VMs (i.e., the min active host capacity) and the maximum active VMs (i.e., the base capacity and the burst capacity). Each of these factors may be determined by the user controls that enable an administrator to configure the system <b>100</b>. Depending on how an administrator configures the system <b>100</b>, it is contemplated that any given virtual desktop environment may include only base capacity, only burst capacity, or any combination of the two. The balance between the base capacity and the burst capacity can be optimized for quick start time, cost savings, performance, etc.</p><p id="p-0119" num="0118">In the systems <b>100</b> and methods provided herein, the actual size of the host pool at any given time is controlled by scaling logic, which provides scale out control using two operations: (1) powering on the base capacity VMs; and (2) creating additional VMs from the available burst capacity.</p><p id="p-0120" num="0119">With respect to the size of the host pool, the system <b>100</b> may be configured to automatically make a certain amount of capacity available in anticipation of user demand (rather than in response to user demand). This is referred to herein as pre-staging capacity. For instance, if users of the virtual desktop environment typically start work at 8 AM Monday-Friday, the system <b>100</b> may determine how long it takes to pre-stage the needed capacity so the system <b>100</b> can begin pre-staging the appropriate base capacity and/or burst capacity early enough before 8 AM to have everything ready by 8 AM. The system <b>100</b> may do so by calculating the average scale out duration and calculating the offset from 8 AM to begin the operation. For example, a pre-staging user control may include controls for setting which days of the week to perform a pre-staging operation, the time by which the pre-staging should be complete, and the number of hosts to be active by the time by which the pre-staging should be complete.</p><p id="p-0121" num="0120">To perform such tasks, <figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates an example of a pre-stage hosts tool <b>116</b> providing user controls including: a work days control <b>118</b> (e.g., the days of the week considered to be the work week), a work hours control <b>120</b> (e.g., what time the work day begins), and a number of hosts to be active by the start of work hours control <b>122</b>. This is an example of a pre-stage hosts tool <b>116</b> a user, such as a system administrator, may use to control the pre-stage hosts functions of the system <b>100</b>.</p><p id="p-0122" num="0121">Once the pre-staging is complete and the system <b>100</b> is in use, user defined scaling logic may control any scale out that takes place in the pooled host pool based on various factors such as: (1) CPU usage; (2) average active sessions per host; (3) available sessions; (4) user experience; (5) event-triggered; (6) machine learning based artificial intelligence triggers; etc. Similarly, user defined scaling logic may control any scale out in the personal host pool based on various factors such as: (1) work hours power on/off; (2) start VM on logon; etc.</p><p id="p-0123" num="0122">In a first example, the user-defined scaling logic may include an auto-scale trigger based on CPU usage within the system <b>100</b>. An example of a CPU usage scaling out logic tool <b>126</b> is shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref>. The CPU usage scaling out logic tool <b>126</b> shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref> includes an auto-scale trigger selection control <b>128</b> and a CPU usage scaling out logic threshold control <b>130</b> through which a user defines a number of hosts to scale out when the CPU utilization exceeds a given capacity for a given duration.</p><p id="p-0124" num="0123">As shown, the scaling logic may be defined such that the system <b>100</b> creates a defined number of new hosts when CPU utilization across all hosts exceeds a defined percentage of capacity for a defined duration. Such a command may be &#x201c;start or create (scale out) up to 1 host (s) if CPU utilization across all hosts exceeds 65% for 5 minutes&#x201d; with the user defined variables including: (i) the number of hosts to scale out; (ii) the utilization threshold that, when exceeded, triggers the scaling out; and (iii) the length of time the threshold must be exceeded before the scaling out occurs.</p><p id="p-0125" num="0124">The scaling logic of the CPU usage scaling out logic tool <b>126</b> shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref> allows the system <b>100</b> to determine when the host pool is &#x201c;getting busy&#x201d; and, in anticipation of a new user login, add additional hosts. The duration variable allows the system <b>100</b> to avoid scaling out when there are momentary CPU spikes and only scale out when there is sustained high CPU activity. Monitoring the average utilization across all existing hosts helps to identify when that system <b>100</b> is getting busy. If the CPU usage is already very high (i.e., running into the limits), adding more capacity is &#x201c;too late&#x201d; because the existing users who are already connected to hosts in the host pool are already overwhelming their hosts. Accordingly, it is important to add capacity before the system <b>100</b> becomes too busy, so users are more equally balanced and user performance is not adversely affected. Setting the number of hosts to scale out informs the system <b>100</b> of the batch size of the number of hosts that will be added, either powered on (e.g., base capacity) or created (e.g., burst capacity), once the CPU threshold is tripped. In small environments, adding a single host at a time may be sufficient, but in very large environments, with a high &#x201c;user arrival rate,&#x201d; it may be necessary to add multiple hosts to the host pool at the same time to accommodate the high demand.</p><p id="p-0126" num="0125">In a second example, the user-defined scaling logic may include an auto-scale trigger based on the average active sessions per host within the system <b>100</b>. An example of an average active sessions per host scaling out logic tool <b>132</b> is shown in <figref idref="DRAWINGS">FIG. <b>5</b></figref>. The average active sessions per host scaling out logic tool <b>132</b> shown in <figref idref="DRAWINGS">FIG. <b>5</b></figref> includes an average active sessions per host scaling out logic tool <b>132</b> including an auto-scale trigger selection control <b>134</b> and an average active sessions per host scaling out threshold control <b>136</b> through which a user defines a number of host to scale out when the average active sessions per host exceeds a given number.</p><p id="p-0127" num="0126">As shown in <figref idref="DRAWINGS">FIG. <b>5</b></figref>, the scaling logic may be defined such that the system <b>100</b> creates a defined number of new hosts when the average active sessions per host exceeds a defined number. Such a command may be &#x201c;start or create (scale out) up to 1 host (s) if the average active sessions across all hosts exceeds 1&#x201d; with the user defined variables including: (i) the number of hosts to scale out; and (ii) the average active sessions threshold that, when exceeded, triggers the scaling out.</p><p id="p-0128" num="0127">In the example shown in <figref idref="DRAWINGS">FIG. <b>5</b></figref>, when the average active sessions across all hosts in the host pool exceed a certain value, the system <b>100</b> automatically adds capacity by either powering on base capacity VMs or creating new burst capacity VMs. This is a trigger that can be used when the number of sessions a host can accommodate is known. For example, if a host can accommodate 10 sessions, it may be useful to add more session hosts when the average exceeds 8 or 9. In this example, the number of hosts to add can be 1 or more. In small environment adding hosts in batches of 1 may be sufficient. In large environments, with high user arrival rates, it may be necessary to add hosts in larger batches.</p><p id="p-0129" num="0128">In a third example, the user-defined scaling logic may include an auto-scale trigger based on the available sessions within the system <b>100</b>. An example of an available sessions scaling out logic tool <b>138</b> is shown in <figref idref="DRAWINGS">FIG. <b>6</b></figref>. The available sessions scaling out logic tool <b>138</b> shown in <figref idref="DRAWINGS">FIG. <b>6</b></figref> includes an auto-scale trigger control <b>140</b>, a maximum sessions per host control <b>142</b>, and a minimum sessions control <b>144</b> through which a user defines a maximum number of available sessions that need to be maintained at all times.</p><p id="p-0130" num="0129">As shown in <figref idref="DRAWINGS">FIG. <b>6</b></figref>, the scaling logic may be defined such that the system <b>100</b> creates a defined number of new hosts when the number of available sessions drops below a defined number. Such a command may be &#x201c;maintain up to 5 available sessions, subject to host pool sizing maximum base capacity plus burst capacity&#x201d; with the user defined variables including: (i) a maximum number of host pool sessions; and (ii) a limit of the available sessions.</p><p id="p-0131" num="0130">In the example shown in <figref idref="DRAWINGS">FIG. <b>6</b></figref>, the system <b>100</b> automatically maintains a pre-defined number of available sessions in the virtual desktop environment up to the maximum capacity (i.e., base capacity plus burst capacity). In this scenario, the number of sessions a host can accommodate is known and the system is told to maintain a &#x201c;buffer&#x201d; of available sessions. As users login, the number of available sessions decreases. Once the number of available sessions falls below the specified buffer, new hosts are either powered on (e.g., base capacity) or created (e.g., burst capacity) and the buffer grows.</p><p id="p-0132" num="0131">In this example, it is important to know how many sessions a host can accommodate, otherwise there is no way to know how many available sessions there are at any given time. When the number of sessions a host can accommodate is known, the system <b>100</b> will behave as follows. The host pool sizing determines the minimum number of active hosts. This number is multiplied by the maximum sessions per host to get the initial buffer size. As users log in, the number of available sessions decreases. Once the number of available sessions is below the specified amount (e.g., 5), another host is made active by powering on additional base capacity or by creating hosts from the burst capacity. The buffer then grows by the maximum sessions per host multiplied by the number of new hosts. This continues until all host capacity is on, at which point the buffer will continue to decrease down to 0.</p><p id="p-0133" num="0132">In a fourth example, the user-defined scaling logic may include an auto-scale trigger based on the user virtual desktop experience. The user virtual desktop experience can be measured in terms of input delay latency or other metrics that represents how well the user's virtual desktop session is responding. As the system <b>100</b> gets busier, the responsiveness decreases and user experiences becomes worse. An auto-scale trigger can be based on user experience decreasing below a certain threshold. When this happens, the auto-scale logic will add new capacity to the host pool by either powering on or creating new VMs. As with other auto-scale triggers, the batch size can be customized. For example, the user defined control may include: (i) a latency threshold for one or more tasks, such as opening a document; and (ii) a number of VMs to add or power on when the latency exceeds one or more of the defined thresholds.</p><p id="p-0134" num="0133">In a fifth example, the user-defined scaling logic may include an auto-scale trigger based on various real-world events. For example, various real-world events can signal that users are ready to start work and sufficient capacity should be made available to accommodate their logins. For instance, there may be a sensor in the parking garage of an office building that measures how full it is and communicates this value to the system <b>100</b>. Once the system <b>100</b> recognizes that the garage is X % full, the auto-scale logic may create additional capacity for a given number of users. Each time X more cars arrive, or the garage is an additional percentage full, the system <b>100</b> automatically scales out to create additional capacity while the users are making their way to the office.</p><p id="p-0135" num="0134">In a sixth example, historical information about user logins over a period of time can be used to derive a schedule based on which the host pool should scale out in anticipation of (i.e., not in response to) user demand. During normal work days/hours, the system <b>100</b> may scale out in anticipation of user logins. During holidays, the system <b>100</b> may not scale out since the system <b>100</b> anticipates that no user demand will be coming.</p><p id="p-0136" num="0135">The six examples above are all directed to auto-scaling logic that is applied to a pooled host pool. In some virtual desktop environments, personal desktops are persistently assigned to individual users. In these personal host pool systems, it is not possible to add arbitrary session host VMs and make them available to users when they are needed or remove extra VMs when they are not needed, because each user must use their own desktop VM and cannot user any others. Therefore, a special type of auto-scaling mechanism is needed for personal host pool systems in which it is not possible to create and delete VMs on demand, it is only possible to power on VMs when they are needed. The following two examples: (1) work hours power on/off; and (2) start VM on logon are provided to show how an auto-scaling logic that can be applied in a personal host pool environment.</p><p id="p-0137" num="0136">An example of a working hours scaling out logic tool <b>146</b> is shown in <figref idref="DRAWINGS">FIG. <b>7</b></figref>. The working hours scaling out logic tool <b>146</b> shown in <figref idref="DRAWINGS">FIG. <b>7</b></figref> includes a day of the week selection control <b>148</b>, a time range selection control <b>150</b>, a &#x201c;power off aggressiveness&#x201d; control <b>152</b> (e.g., low, medium, and high), and a power on timing control <b>154</b> (e.g., once vs. consistent). As further shown, the working hours scaling out logic tool <b>146</b> may further include a time zone setting control <b>156</b>.</p><p id="p-0138" num="0137">In the example shown in <figref idref="DRAWINGS">FIG. <b>7</b></figref>, working hours are defined. For example, working hours may be set for Monday through Sunday, 8 AM to 6 PM Central Time (UTC-06:00). Settings may be provided for &#x201c;power off aggressiveness&#x201d; (e.g., low, medium, or high) and &#x201c;power on timing&#x201d; (e.g., once or continuous). The power off aggressiveness defines how quickly the system <b>100</b> reacts to turn off the VMs in response to non-use or manual power down. When the power on timing is set to once, the VMs are powered on a single time in response to the opening of a working hours window (and therefore can be powered off by user action). When the power on timing user control is set to continuous, the VMs remain powered on during working hours, even if the user or administrator attempts to power on or more of the VMs off manually.</p><p id="p-0139" num="0138">In another example, the auto-scale logic automatically powers on personal desktop session host VMs when a user login is detected. In one example, in response to a user initiated a login request, the request is received by the connection broker service and the logged in database. The auto-scaling logic system then receives a trigger event or proactively polls the connection broker service and logged in database. When the system recognizes a login attempt for a powered off personal desktop VM, the auto-scaling logic causes the appropriate personal desktop session host VM automatically starts.</p><p id="p-0140" num="0139">The examples above describe scale out logic for virtual desktop environments. However, after a host pool is scaled out (whether a pooled host pool or personal host pool), if it is not scaled back in, the system is no better than a non-auto-scaling scenario in which there is more capacity allocated than is needed and costs are needlessly high. Therefore, to provide the objectives and advantages of the systems <b>100</b> and methods described herein, the systems <b>100</b> and methods include a mechanism to scale in (i.e., reduce capacity) of a host pool when the excess capacity is no longer needed.</p><p id="p-0141" num="0140">When implementing a scale in mechanism, it is important to recognize that virtual desktop sessions are tied to a specific VM. It is currently not possible to dynamically &#x201c;move&#x201d; a virtual desktop session from one VM to another without logging the user out of their current session, which requires saving all data and closing all applications. Therefore, it is important to consider all of the implications when scaling in capacity to make it as non-disruptive as possible to the end-users while at the same time optimizing cost savings.</p><p id="p-0142" num="0141">The following paragraphs describe six examples of auto-scaling logic for scaling in a virtual desktop environment in a pooled host pool environment. The six examples demonstrate how the scale in logic may be triggered by: (1) CPU usage; (2) average active sessions; (3) available sessions; (4) event triggers; (5) user experience; and (6) work hour schedules.</p><p id="p-0143" num="0142">An example of a CPU usage scaling logic tool <b>158</b> is shown in <figref idref="DRAWINGS">FIG. <b>8</b></figref>. The CPU usage scaling logic tool <b>158</b> shown in <figref idref="DRAWINGS">FIG. <b>8</b></figref> includes an auto-scale trigger control <b>160</b>, a CPU usage scale out control <b>162</b> through which a user defines a number of host to scale out when the CPU utilization exceeds a given capacity for a given duration, and a CPU usage scale in control <b>164</b> through which a user defines a number of hosts to scale in when the CPU utilization drops below a given capacity for a given duration.</p><p id="p-0144" num="0143">In the example shown in <figref idref="DRAWINGS">FIG. <b>8</b></figref>, in which auto-scaling logic is applied to a scale in process based on CPU usage, scale in occurs once the CPU usage drops below a pre-configured threshold and stays there for the defined number of minutes. Once this condition is met, a specified batch of VMs is stopped or removed. For example, the logic may be defined such that the system stops or removes (i.e., scales in) up to 1 host(s) when CPU utilization across all hosts drops below 40% for 15 minutes. As shown, the user defined variables in the example shown in <figref idref="DRAWINGS">FIG. <b>8</b></figref> include: (i) a number of hosts to scale out; (ii) a threshold CPU usage over which hosts are to be started or created; (iii) a duration for which the threshold CPU usage must be exceeded before the scale out process occurs; (iv) a number of hosts to scale in; (v) a threshold CPU usage under which hosts are to be stopped or removed; and (vi) a duration for which the threshold CPU usage must be below before the scale in process occurs.</p><p id="p-0145" num="0144">An example of an average active sessions scaling logic tool <b>166</b> is shown in <figref idref="DRAWINGS">FIG. <b>9</b></figref>. As shown in <figref idref="DRAWINGS">FIG. <b>9</b></figref>, the average active sessions scaling logic tool <b>166</b> includes an auto-scale trigger control <b>168</b>, an average sessions scale out control <b>170</b> through which a user defines a number of host to scale out when the average active sessions across all hosts exceeds a given value, and an average sessions scale in control <b>172</b> through which a user defines a number of hosts to scale in when the average active sessions across all hosts is below a given value.</p><p id="p-0146" num="0145">In the example of auto-scaling logic applied to a scale in process based on average active sessions shown in <figref idref="DRAWINGS">FIG. <b>9</b></figref>, scale in occurs once the average active sessions per host falls below a pre-defined number. At that point, VMs are removed in defined batch sizes. For example, the logic may be defined such that the system stops or removes (i.e., scales in) up to 1 host(s) when the average active sessions across all hosts falls below 1.</p><p id="p-0147" num="0146">As shown, the user defined variables in the example shown in <figref idref="DRAWINGS">FIG. <b>9</b></figref> include: (i) a number of hosts to scale out; (ii) a threshold average active sessions over which hosts are to be started or created; (iii) a number of hosts to scale in; and (iv) a threshold average active sessions under which hosts are to be stopped or removed.</p><p id="p-0148" num="0147">In another example, auto-scaling logic may be applied to a scale in process based on available sessions. In such an example, scale in occurs once the pool of available sessions exceeds the minimum buffer. In response to the pool of available sessions exceeding the minimum buffer, hosts are powered off or removed as long as doing so maintains the minimum buffer after the operation. For example, if the minimum buffer is 5, each host can accommodate 10 sessions, and there are currently 14 available sessions, scaling in 1 host would result in 4 sessions being available (i.e., less than the minimum buffer) and, therefore, the host would not be shut down. In the same scenario, if there were 15 available sessions, then a host would be scaled in to reduce consumption without violating the minimum buffer requirement.</p><p id="p-0149" num="0148">In an example of auto-scaling logic applied to a scale in process based on event triggers, when the number of cars in the monitored parking garage drops below a certain threshold, one or more hosts are scaled in as the parking capacity indicates that users are not in the office.</p><p id="p-0150" num="0149">In an example of auto-scaling logic applied to a scale in process based on user experience, if user experience increases above a certain level (e.g., latency relative to a given task drops below a defined threshold value), VMs are scaled in to remove unneeded capacity.</p><p id="p-0151" num="0150">As with the scale out functions described above, the scale in function may apply to either pooled host pools or personal host pools. For example, in a personal host pool setting, the auto-scale logic may be based on typical office hours. After a specified time (e.g., 6 PM), if the VM is not in use, it may be automatically powered down. The power down function may be applied once or continuously. When the power down timing is set to once, the VMs are powered down a single time in response to the closing of a working hours window (and therefore can be powered on by user action). When the power down timing user control is set to continuous, the VMs remain powered off during non-working hours, even if the user or administrator attempts to power one or more of the VMs on manually.</p><p id="p-0152" num="0151">Each of the examples of scale in logic may be subject to one or more scale in restrictions. Scale in restrictions are used to promote optimized balances of cost savings vs. end-user experience. Scale in restriction settings impose restrictions on the scenarios in which scale in can occur to avoid being overly disruptive to end users. For example, scale in should not occur during lunch hour when the system utilization drops simply because users are temporarily away from their desk. Scaling in at this time would not only cause users sessions to be disconnected, which will close their applications, but will also require a scale out to occur within an hour when users come back to their desks and resume their work. Therefore, it may be valuable to enable a user to set time periods within which scale in can occur and/or time periods in which scale in cannot occur.</p><p id="p-0153" num="0152">In addition, the systems and methods provided herein may be subject to user controls over the scale in aggressiveness. When scaling in, VMs are either shut down or destroyed (depending on base capacity vs. burst capacity settings). Either approach is disruptive to any users currently logged into these VMs. The scale in aggressiveness user settings allow system administrators to balance user disruption with cost savings. For example, in a primary embodiment, there may be three user defined aggressiveness settings: low; medium; and high.</p><p id="p-0154" num="0153">In this example, if the system administrator chooses to set the scale in aggressiveness setting to low, only hosts that have zero active and disconnected sessions will be scaled in. The system <b>100</b> continuously monitors the virtual desktop environment for presence of such hosts and scales them in during the allowed time window (i.e., subject to the scale in restrictions described above). This setting results in the least amount of user disruption (e.g., no user disruption), but is not guaranteed to produce any cost savings if users are not disciplined about logging out of their virtual desktops when they are done using them.</p><p id="p-0155" num="0154">In this example, if the system administrator chooses to set the scale in aggressiveness setting to medium, those hosts that have no active session (i.e., those hosts with either no session at all or only disconnected sessions) can be scaled in during the allowed times. This results in disruption to disconnected sessions (i.e., applications are closed), but is more likely to produce compute saving by removing underutilized VMs.</p><p id="p-0156" num="0155"><figref idref="DRAWINGS">FIG. <b>10</b></figref> illustrates a scale in restrictions tool <b>174</b> including a scale in time control <b>176</b> through which a user defines times in which scale in will be restricted and a scale in aggressiveness control <b>178</b> through which a user defines a level of scale in aggressiveness to apply (e.g., low, medium, or high). As further shown, the scale in restrictions tool <b>146</b> may further include a time zone setting control <b>180</b>.</p><p id="p-0157" num="0156">In the example shown in <figref idref="DRAWINGS">FIG. <b>10</b></figref>, the system administrator has chosen to set the scale in aggressiveness setting to high between 8 AM and 6 PM in the central time zone. Accordingly, during that time, all hosts above the minimum active capacity are scaled in regardless of whether or not they have sessions.</p><p id="p-0158" num="0157">In prioritizing the scale in target VMs, the system <b>100</b> may first choose to scale in those hosts with no sessions. Once the first group of hosts are scaled in, the system <b>100</b> may then choose to scale in those hosts that have the least number of sessions, set the host to drain mode (i.e., prevent any new connections), send the users a warning message on their virtual desktop screen to give them X minutes to log out and log back in.</p><p id="p-0159" num="0158">An example of a scale in messaging tool <b>182</b> is shown in <figref idref="DRAWINGS">FIG. <b>11</b></figref>. As shown in <figref idref="DRAWINGS">FIG. <b>11</b></figref>, the scale in messaging tool <b>182</b> includes a warning control <b>184</b> through which a user defines a time for when to send a message relative to a scale in action and a warning message control <b>186</b> through which a user defines a message to be sent relative to a scale in action. As shown, through the scale in messaging tool <b>182</b>, the administrator is able to define the number of minutes warning the users are given before scaling the host. The warning message may say something like, &#x201c;Sorry for the interruption. We are doing some housekeeping and need you to log out. You can log in right away and continue working. We will be terminating your session in 10 minutes if you have not logged out by then.&#x201d; When the users log out and then back in, they are connected to a different host that is not in drain mode. The system <b>100</b> continues this process until either the utilization becomes appropriately high or the minimum number of active hosts is reached. In this high setting scale in aggressiveness scenario, scale in savings are very likely because all underutilized capacity will be scaled in when possible.</p><p id="p-0160" num="0159">In some examples of the systems <b>100</b> and methods provided herein, the system <b>100</b> includes an auto-heal function for session host VMs. In such embodiments, the auto-scaling system is continuously monitoring the status of the session hosts and is aware of any changes from a &#x201c;healthy&#x201d; state to a &#x201c;broken&#x201d; state in order to take prescriptive actions to repair broken hosts.</p><p id="p-0161" num="0160">In one example, session host status is provided by a WVD agent, which is software installed inside of each session host that facilitates a connection between the end-user and the VM serving the virtual desktop session. The WVD agent has broad visibility of what is happening on the VM and reports the status back to the WVD management service. The normal status is Available. There are several other states that can indicate a problem with the VM, including, for example: Unavailable; FSLogix not healthy; No heartbeat; SxS stack listener not ready; Shutdown; Disconnected; Upgrading; Update failed; Not joined to domain; Domain trust relationship lost; and Needs assistance.</p><p id="p-0162" num="0161">An example of an auto-heal broken hosts GUI is shown in <figref idref="DRAWINGS">FIG. <b>12</b></figref>. As shown in <figref idref="DRAWINGS">FIG. <b>12</b></figref>, an example of an auto-heal broken hosts tool <b>188</b> includes an on/off control <b>190</b> for activating and deactivating the auto-heal functionality within the system <b>100</b> and a broken session host identification control <b>192</b> through which a user defines how to identify when to heal a broken session host, including the applicable WVD agent statuses (e.g., host is broken when WVD agent status is Unavailable, FSLogix not healthy; No heartbeat; SxS stack listener not ready) and whether hosts with &#x201c;any session&#x201d; or with &#x201c;active sessions&#x201d; should be acted upon. In addition, the auto-heal broken hosts tool <b>188</b> includes a number of restart attempts control <b>194</b> through which a user defines a number of restart attempts the auto-heal broken hosts tool <b>188</b> should attempt, a time between restart attempts control <b>196</b> through which a user defines a time (e.g., in minutes) between restart attempts, and a unrecoverable host control <b>198</b> through which a user defines how to handle unrecoverable hosts (e.g., remove and re-create).</p><p id="p-0163" num="0162">Accordingly, as shown in <figref idref="DRAWINGS">FIG. <b>12</b></figref>, the auto-heal broken hosts tool <b>188</b> provides the system administrator with the ability to define what constitutes a broken host (some status may be normal or transient in some environments) and configure an action of what to do when a broken host is detected. The auto-scaling system kicks into action auto-healing broken hosts after it has fully scaled out the environment to avoid dealing with &#x201c;maintenance&#x201d; type tasks when more capacity needs to be brought online. Once the scale out process is complete, the auto-scaling system can start healing any broken hosts.</p><p id="p-0164" num="0163">As part of the configuration defining a broken host, the administrator can also specify whether a broken host should be repaired if it has any user sessions on it. It is possible for users to have connected to a host before the host went into broken state. The administrator can configure whether hosts with any session, or with active sessions, should be acted upon or not.</p><p id="p-0165" num="0164">In some examples, the remediation actions can be a combination of: restarting the session hosts one or more times, with delays in between the attempts; deleting and re-creating the session hosts from golden image; and other actions that depend on the broken session host status. For example, the system administrator can define the number of restart attempts, the time (e.g., in minutes) between restart attempts, and how to handle unrecoverable hosts (e.g., remove and re-create).</p><p id="p-0166" num="0165">Various embodiments of the systems <b>100</b> and methods provided herein include dynamic, in-line cost estimation to the user (e.g., system administrator) while they are configuring the dynamic host pool auto-scaling. This allows the user to immediately see the impact of the selected configuration choices without having to open a separate spreadsheet or calculator application. The cost estimation tool provides the user with the &#x201c;boundaries&#x201d; of the possible costs. That is, the minimum and maximum possible costs across two dimensions of compute and storage, which constitute the 90%+ of the total cost of the typical virtual desktop environment.</p><p id="p-0167" num="0166">For example, the user interface through which the auto-scaling logic is controlled may include a chart providing the estimated monthly costs for the minimum and maximum costs for the compute and for the storage capacity.</p><p id="p-0168" num="0167">The compute cost is the cost of virtual machine compute capacity. This depends on the geographic region, selected VM family, amount of CPU/RAM/storage and other factors. Compute costs are incurred only by VMs that are running. Stopped (i.e., deallocated) VMs exist, but they do not consume compute costs.</p><p id="p-0169" num="0168">The storage cost is the cost of operating system disk storage that is attached to a VM. Factors that contribute to the storage cost include the cost of storage demands on the geographic region where it exists, the type of disk (premium SSD, standard SSD, HDD, etc.), and the size of the storage disk. Costs for storage are incurred regardless if whether the VM that it's attached to is running or stopped. The only time storage costs stop being incurred is when the VM and its associated OS disk is deleted (e.g., removal of burst capacity).</p><p id="p-0170" num="0169">The minimum cost is the cost of compute/storage under the assumptions that the system <b>100</b> will stay at its minimum (i.e., scaled in) size and never scale out. The cost of storage depends on: (1) the number of base host pool capacity VMs, since these always exist and the OS disks consume costs; and (2) the cost of storage of any additional VMs that get created during pre-staging that are above the base capacity for the duration between pre-stage time and beginning of scale in restriction time. The cost of compute depends on: (1) the minimum active host capacity as this is the amount of computer that will be running 24/7 at a minimum; and (2) the cost of compute of pre-staged capacity between the hours of beginning of work hours (i.e., pre-stage time) and beginning of scale in restrictions.</p><p id="p-0171" num="0170">The maximum cost is the cost of compute/storage under the assumption that the system <b>100</b> will scale out to its maximum size and never scale in. The maximum cost of storage is based on the maximum host pool size. That is the base capacity plus burst capacity running at all times. The maximum cost of compute is similarly based on assuming the system <b>100</b> runs at all times.</p><p id="p-0172" num="0171">Some embodiments of the systems <b>100</b> and methods taught herein capture actual compute and storage utilization on a minute-by-minute basis. This allows the systems <b>100</b> to understand the &#x201c;actual&#x201d; costs of an environment, which is what the user would see when they receive their invoice. However, also knowing the configuration of a particular host pool and its auto-scale settings, these systems <b>100</b> can understand the minimum possible costs (i.e., if system never scales out), maximum possible costs (i.e., if system scales out and never scales back in), peak costs (i.e., if the host pool is statically sized to accommodate peak demand&#x2014;somewhere between actual and maximum costs) and, as a result, can derive the savings delivered by the auto-scaling processes.</p><p id="p-0173" num="0172">In some embodiments, costs and savings may be captured graphically at the host pool level and then viewed over any selected period of time. For example, the system <b>100</b> may automatically scale out days days per week based on schedule and user demand and scale back in two days per week when it's no longer needed. Savings are reflected as the difference between the peak costs (i.e., what it would cost to run the system statically powered on for the selected duration at its highest usage over the period) and actual costs.</p><p id="p-0174" num="0173">Seeing costs and savings data on a per host pool basis is useful to understand past behavior, but it is useful to see this information on an aggregated basis over a standard period of time (e.g., a month) and over multiple host pools grouped into workspaces. This aggregation over time allows the user to understand the complete costs and auto-scale savings with respect to the entire virtual desktop environment.</p><p id="p-0175" num="0174">Understanding historical costs is helpful, but ultimately decision makers need to understand the projected costs over a standardized period of time (e.g., a month). The systems <b>100</b> and methods taught herein enable accurate monthly projections about monthly savings as a result of auto-scaling based on a short sample period of data collection. This data is extrapolated over the standardized period and can be presented in-line at the host pool and workspace level.</p><p id="p-0176" num="0175">With cloud computing costs being &#x201c;infrastructure size&#x201d; dependent (e.g., VM size, OS disk type, etc.) and each unit of infrastructure being able to deliver services to a unpredictable number of individual users (i.e., employees), it is difficult to understand the cost of a complex technology like virtual desktops, especially with auto-scaling, on a per user basis. Because the systems <b>100</b> and methods described herein provide visibility into utilization by users, possible auto-scale size ranges of the infrastructure, and actual costs incurred by the infrastructure in response to user demand, it is possible to calculate projected, standardized unit costs on a per-user basis.</p><p id="p-0177" num="0176"><figref idref="DRAWINGS">FIGS. <b>13</b>-<b>20</b></figref> show various tools for dynamic, in-line cost estimation.</p><p id="p-0178" num="0177"><figref idref="DRAWINGS">FIG. <b>13</b></figref> illustrates a dynamic cost estimation tool <b>200</b> in which the minimum and maximum estimated monthly costs are shown for compute and storage in an estimated monthly costs display <b>202</b>. The dynamic cost estimation tool <b>200</b> shown in <figref idref="DRAWINGS">FIG. <b>13</b></figref> includes an IT environment definition control <b>204</b>, a host pool sizing control <b>206</b>, a scaling logic control <b>208</b>, and a pre-stage hosts control <b>210</b>, the selections made within each drive the estimated monthly costs display <b>202</b>.</p><p id="p-0179" num="0178"><figref idref="DRAWINGS">FIG. <b>14</b></figref> illustrates a cost tracking display <b>212</b> in which costs and savings are presented graphically at the host pool level and can be viewed over any selected period of time.</p><p id="p-0180" num="0179"><figref idref="DRAWINGS">FIG. <b>15</b></figref> illustrates an aggregated cost and savings display <b>214</b> at host pool level over a month. <figref idref="DRAWINGS">FIG. <b>16</b></figref> illustrates an aggregated cost and savings display <b>216</b> at workspace level over a month. These tools enable a user to understand the complete costs and auto-scale savings picture over the entire auto-scaling virtual desktop environment.</p><p id="p-0181" num="0180"><figref idref="DRAWINGS">FIG. <b>17</b></figref> illustrates a projected costs at a host pool level display <b>218</b>. <figref idref="DRAWINGS">FIG. <b>18</b></figref> illustrates a projected costs at a workspace level display <b>220</b>. These tools enable a user to project the expected costs and auto-scale savings picture over the entire auto-scaling virtual desktop environment.</p><p id="p-0182" num="0181"><figref idref="DRAWINGS">FIG. <b>19</b></figref> illustrates a projected monthly unit cost for per-named and per concurrent user on the host pool level display <b>222</b>. <figref idref="DRAWINGS">FIG. <b>20</b></figref> illustrates a projected monthly unit cost for per-named and per concurrent user on the workspace level display <b>224</b>. These tools enable a user to calculate projected, standardized unit costs on a per-user basis.</p><p id="p-0183" num="0182">Aspects of the systems <b>100</b> and methods described herein are controlled by one or more controllers. The one or more controllers may be adapted to run the variety of application programs and controls described above with respect to <figref idref="DRAWINGS">FIGS. <b>2</b>-<b>20</b></figref>, access and store data, including accessing and storing data in associated databases, and enable the one or more interactions between the user device <b>102</b> and the IT environment <b>104</b> as described herein. Typically, the controller is implemented by one or more programmable data processing devices, shown, for example, as the user device <b>102</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref>. The hardware elements, operating systems, and programming languages of such devices are conventional in nature, and it is presumed that those skilled in the art are adequately familiar therewith.</p><p id="p-0184" num="0183">In the example shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the one or more controllers are embodied in a PC-based implementation of a central control processing system utilizing a central processing unit (CPU or processor), memory and an interconnect bus, shown as the user device <b>102</b>. The CPU may contain a single microprocessor, or it may contain a plurality of microprocessors for configuring the CPU as a multi-processor system. The memory may include a main memory, such as a dynamic random access memory (DRAM) and cache, as well as a read only memory, such as a PROM, EPROM, FLASH-EPROM, or the like. The system may also include any form of volatile or non-volatile memory. In operation, the memory stores at least portions of instructions for execution by the CPU and data for processing in accord with the executed instructions.</p><p id="p-0185" num="0184">The one or more controllers may also include one or more input/output interfaces for communications with one or more processing systems. One or more such interfaces may enable communications via a network, e.g., to enable sending and receiving instructions electronically. The communication links may be wired or wireless.</p><p id="p-0186" num="0185">The one or more controllers may further include appropriate input/output ports for interconnection with one or more output mechanisms (e.g., monitors, printers, touchscreens, motion-sensing input devices, etc.) and one or more input mechanisms (e.g., keyboards, mice, voice, touchscreens, bioelectric devices, magnetic readers, RFID readers, barcode readers, motion-sensing input devices, etc.) serving as one or more user interfaces for the controller. For example, the one or more controllers may include a graphics subsystem to drive the output mechanism. The links of the peripherals to the system may be wired connections or use wireless communications.</p><p id="p-0187" num="0186">Although summarized above as a PC-type implementation, and shown as such in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, those skilled in the art will recognize that the one or more controllers also encompasses systems such as host computers, servers, workstations, network terminals, and the like. Further, one or more controllers may be embodied in a device, such as a mobile electronic device, like a smartphone or tablet computer. In fact, the use of the term controller is intended to represent a broad category of components that are well known in the art. As such, it is recognized that the use of the term controller may refer to: (i) a PC-type implementation of a user device <b>102</b> communicating with the IT environment <b>104</b>, as shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>; (ii) may be a mobile device implementation of a user device <b>102</b> communicating with the IT environment <b>104</b>; (iii) may be one or more user-controlled servers or resources within the IT environment <b>104</b> itself; or (iv) may be any other user device through which a user implements the processes and controls described with respect to <figref idref="DRAWINGS">FIGS. <b>2</b>-<b>20</b></figref>, as will be understood by those skilled in the art based on the teachings provided herein.</p><p id="p-0188" num="0187">Aspects of the systems <b>100</b> and methods provided herein encompass hardware and software for controlling the relevant features and functions described with reference to <figref idref="DRAWINGS">FIGS. <b>2</b>-<b>20</b></figref>. Software may take the form of code or executable instructions for causing a controller or other programmable equipment to perform the relevant steps, where the code or instructions are carried by or otherwise embodied in a medium readable by the controller or other machine. Instructions or code for implementing such operations may be in the form of computer instruction in any form (e.g., source code, object code, interpreted code, etc.) stored in or carried by any tangible readable medium.</p><p id="p-0189" num="0188">As used herein, terms such as computer or machine &#x201c;readable medium&#x201d; refer to any medium that participates in providing instructions to a processor for execution. Such a medium may take many forms. Non-volatile storage media include, for example, optical disks, magnetic disks, and solid-state drives, such as any of the storage devices in the user device <b>102</b> shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>. Volatile storage media include dynamic memory, such as the memory of such a computer platform. Common forms of computer-readable media therefore include for example: a floppy disk, a flexible disk, hard disk, magnetic tape, any other magnetic medium, a CD-ROM, DVD, any other optical medium, punch cards paper tape, any other physical medium with patterns of holes, a RAM, a PROM and EPROM, a FLASH-EPROM, any other memory chip or cartridge, or any other medium from which a controller can read programming code and/or data. Many of these forms of computer readable media may be involved in carrying one or more sequences of one or more instructions to a processor for execution.</p><p id="p-0190" num="0189">It should be noted that various changes and modifications to the presently preferred embodiments described herein will be apparent to those skilled in the art. Such changes and modifications may be made without departing from the spirit and scope of the present invention and without diminishing its attendant advantages.</p><?detailed-description description="Detailed Description" end="tail"?></description><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A system for dynamically auto-scaling allocated capacity of a virtual desktop environment comprising:<claim-text>a scalable virtual desktop environment comprising a base capacity resources, including base compute resources and base storage resources, and a burst capacity resources, including burst compute resources and burst storage resources;</claim-text><claim-text>a server including a controller controlling the operation of the base capacity resources and the burst capacity resources;</claim-text><claim-text>a memory coupled to the controller, wherein the memory is configured to store program instructions executable by the controller;</claim-text><claim-text>wherein, in response to executing the program instructions, the controller is configured to:<claim-text>in response to receiving a log in request from a first user device, connect the first user device to a first host pool to which the first device user is assigned;</claim-text><claim-text>execute a load-balancing module to determine a first session host virtual machine to which to connect the first user device; and</claim-text><claim-text>execute an auto-scaling module comprising a user-selectable auto-scaling trigger and a user-selectable conditional auto-scaling action, wherein, in response to recognition of the conditional auto-scaling action, the controller powers on or powers off one or more base capacity resources or creates or destroys one or more burst capacity resources.</claim-text></claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein, in response to executing the program instructions, the controller is further configured to: in response to receiving a log in request from a first user device, connect a second user device to a second host pool to which the second device user is assigned.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein, in response to executing the program instructions, the controller is configured to provide a host pool sizing tool including user controls for defining an active host, a base host pool capacity, a minimum active host capacity, and a burst beyond base capacity.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein, in response to executing the program instructions, the controller is configured to provide a pre-stage hosts tool including user controls for defining one or more work days, a start of work hours, and a number of hosts to be active by the start of work hours.</claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein, in response to executing the program instructions, the controller is configured to provide a CPU usage scaling out logic tool including user controls for an auto-scale trigger selection and a number of host to scale out when the CPU utilization exceeds a given capacity for a given duration.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein, in response to executing the program instructions, the controller is configured to provide an average active sessions per host scaling out logic tool including user controls for an auto-scale trigger selection and a number of host to scale out when the average active sessions per host exceeds a given number.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein, in response to executing the program instructions, the controller is configured to provide an available sessions scaling out logic tool including user controls for an auto-scale trigger selection, a maximum sessions per host, and a minimum number of available sessions that need to be maintained at all times.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein, in response to executing the program instructions, the controller is configured to provide a working hours scaling out logic tool including user controls for a day of the week selection tool, a time range selection tool, a setting for power off aggressiveness, and a setting for power on timing.</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein, in response to executing the program instructions, the controller is configured to provide a CPU usage scaling logic tool including user controls for scale out and scale in definitions including an auto-scale trigger selection and a number of host to scale out when the CPU utilization exceeds a given capacity for a given duration, and a number of hosts to scale in when the CPU utilization drops below a given capacity for a given duration.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein, in response to executing the program instructions, the controller is configured to provide an average active sessions scaling logic tool including user controls for scale out and scale in definitions including an auto-scale trigger selection and a number of host to scale out when the average active sessions across all hosts exceeds a given value, and a number of hosts to scale in when an average active sessions across all hosts is below a given value.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein, in response to executing the program instructions, the controller is configured to provide a scale in restrictions tool including user controls for selecting times in which scale in will be restricted and a level of scale in aggressiveness to apply.</claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein, in response to executing the program instructions, the controller is configured to provide a scale in messaging tool including user controls for when to send a message relative to a scale in action and a control for editing a message to be sent.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein, in response to executing the program instructions, the controller is configured to provide an auto-heal broken hosts tool including a user controls defining how to identify when to heal a broken session host, including applicable WVD agent statuses and whether hosts with any session or with active sessions should be acted upon, a number of restart attempts, a time between restart attempts, and how to handle unrecoverable hosts.</claim-text></claim></claims></us-patent-application>