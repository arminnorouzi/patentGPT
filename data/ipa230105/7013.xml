<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230007014A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230007014</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17305303</doc-number><date>20210702</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>L</subclass><main-group>29</main-group><subgroup>06</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>K</subclass><main-group>9</main-group><subgroup>62</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>L</subclass><main-group>63</main-group><subgroup>1416</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>K</subclass><main-group>9</main-group><subgroup>6267</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>L</subclass><main-group>67</main-group><subgroup>40</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">DETECTION OF REPLACEMENT/COPY-PASTE ATTACKS THROUGH MONITORING AND CLASSIFYING API FUNCTION INVOCATIONS</invention-title><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Palo Alto Networks, Inc.</orgname><address><city>Santa Clara</city><state>CA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Narayan</last-name><first-name>Krishnan Shankar</first-name><address><city>San Jose</city><state>CA</state><country>US</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A system processes an API specification provided by a vendor to determine and classify the functions defined therein by CRUD operation type based on analysis of the function names. Classification of the function includes associating a bitmask corresponding to the class with the function name. The system then subscribes to an event stream including logged API function call events during a time window overlapping with a &#x201c;blind spot&#x201d; period of attack detection. The system analyzes incoming events to identify an associated resource and an API function call. The system classifies the function based on the determined function classes and performs a bitwise operation between bit values maintained for the identified resource that are indicative of resource state and the bitmask of the function class. If the resulting bit values indicate that the resource was both created and deleted during the time window, the system flags the resource as potentially involved in an attack.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="215.65mm" wi="139.70mm" file="US20230007014A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="245.87mm" wi="148.42mm" orientation="landscape" file="US20230007014A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="249.43mm" wi="156.04mm" orientation="landscape" file="US20230007014A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="225.64mm" wi="156.21mm" orientation="landscape" file="US20230007014A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="239.86mm" wi="141.73mm" file="US20230007014A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="241.64mm" wi="156.04mm" file="US20230007014A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="239.01mm" wi="140.72mm" file="US20230007014A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="235.88mm" wi="159.85mm" file="US20230007014A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="214.12mm" wi="145.80mm" file="US20230007014A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">BACKGROUND</heading><p id="p-0002" num="0001">The disclosure generally relates to digital data processing and to security arrangements for protecting computers.</p><p id="p-0003" num="0002">Cloud service providers (CSPs) often provide logging services for logging events occurring in a customer's cloud environment. An event recorded in log data generally corresponds to a function call made in the cloud environment by or on behalf of the customer's program code to invoke functionality of one of the various services offered by the CSP via an application programming interface (API) exposed by the service. For instance, a service can be invoked via its API to facilitate provisioning cloud resources or updating/deleting existing cloud resources. A security vendor which provides security for the customer's cloud environment can obtain audit logs generated by a CSP audit logging service and/or periodically poll for log data which captures API function calls impacting resources across the cloud environment. Due to the distributed nature of cloud computing and resulting latencies, the appearance of recorded API invocations across services and different resources in log data generally is not instantaneous, nor can the security vendor obtain the associated log data immediately. Rather, API invocations made in the cloud environment may appear in log data which the security vendor obtains via auditing or API polling after a time delay, such as up to fifteen minutes.</p><p id="p-0004" num="0003">Copy-paste or replacement attacks (also referred to herein as &#x201c;attacks&#x201d;) occur when a resource which appears to be benign has been replaced with a malicious actor to perform a task, and once the malicious, replacement resource has performed the task, the resource is again replaced by the benign, original resource. As an example, a benign file can be replaced with a file comprising malicious code, and once the malicious code has executed, the benign file is restored. Due to rapid creation and deletion of resources supported by vendors, especially among CSPs, such attacks may be difficult to detect.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0002" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0005" num="0004">Embodiments of the disclosure may be better understood by referencing the accompanying drawings.</p><p id="p-0006" num="0005"><figref idref="DRAWINGS">FIG. <b>1</b></figref> depicts a conceptual diagram of processing an API specification to classify API functions by higher-level CRUD operation.</p><p id="p-0007" num="0006"><figref idref="DRAWINGS">FIG. <b>2</b></figref> depicts a conceptual diagram of automated detection of potential attacks occurring during a blind spot period.</p><p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. <b>3</b></figref> depicts a conceptual diagram of classifying functions of an API of a CSP and leveraging the function class information for detection of potential attacks in a cloud environment occurring during a blind spot period.</p><p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. <b>4</b></figref> depicts a flowchart of example operations for classifying functions of an API provided by a vendor by type of implemented operation.</p><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a flowchart of example operations for classifying a function as corresponding to a create, update, delete, or other operation based on analyzing the name of the function.</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIGS. <b>6</b>-<b>7</b></figref> are a flowchart of example operations for detecting potential attacks occurring during a &#x201c;blind spot&#x201d; period of API polling or log auditing.</p><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>8</b></figref> depicts an example computer system with an API function classification system and an attack detection system.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0003" level="1">DESCRIPTION</heading><p id="p-0013" num="0012">The description that follows includes example systems, methods, techniques, and program flows that embody aspects of the disclosure. However, it is understood that this disclosure may be practiced without these specific details. For instance, this disclosure refers to representing associations between function names and classes with a map data structure in illustrative examples. Aspects of this disclosure can be instead applied to other data structures which provide for storing data in key-value pairs. In other instances, well-known instruction instances, protocols, structures and techniques have not been shown in detail in order not to obfuscate the description.</p><heading id="h-0004" level="1">Overview</heading><p id="p-0014" num="0013">Due to the time delay between calling an API function and logging the API function call in a cloud or Software-as-a-Service (SaaS) environments, &#x201c;blind spot&#x201d; periods can result. Blind spot periods are the periods during which API function calls may be made but will not appear in logs obtained via conventional log auditing or API polling, which are caused by latencies in event publishing and audit log delivery to a security vendor subscribing thereto. For instance, logging of API function calls may have an associated latency of fifteen minutes on average such that there is a fifteen minute delay between an API function call and the security vendor becoming aware of the API function call, such as a fifteen minute delay between a resource update event and the security vendor becoming aware of the update event. These blind spot periods can be exploited by attackers who carry out replacement/copy-paste attacks which involve rapid provisioning and destruction of resources during the blind spot period. As an example, the security vendor may identify a resource of interest based on analysis of audit logs; however, upon attempted investigation of the resource, the resource will no longer appear to exist due to the related attack being carried out during the blind spot period and the lack of indication of the resource deletion event in the audit logs as a result. Further information which could contribute to detection of the attack carried out via the resource is unavailable as a result. Additionally, due to the volume of resources and API function calls&#x2014;especially among cloud services&#x2014;manually tracking states of resources with respect to their creation and destruction on a large scale to attempt to identify attacks occurring within blind spots presents a challenge.</p><p id="p-0015" num="0014">Automated tracking of creation and deletion of individual resources of a vendor, or a CSP or SaaS application which offers an API, based on streaming events during a time period overlapping with the blind spot period as disclosed herein facilitates detection of potential attacks. Tracking creation and deletion of resources based on API function calls which impact resources entails two stages. In an API function classification stage, a system parses and processes the API specification provided by the vendor to determine and classify the functions defined therein. The functions are classified by action/event type, where classes of action/event types correspond to the higher-level create, read, update, or delete (&#x201c;CRUD&#x201d;) operation implemented by the functions within the class. The system analyzes the names of the functions to determine a type of resource associated with the function and the operation performed on that resource type, where the operation is classified as a CRUD operation or other operation type based on similarities to names of known CRUD operations. Bitmasks are used as class identifiers, where classification of the function into one of the classes includes associating the bitmask corresponding to the class with the function name.</p><p id="p-0016" num="0015">In an attack detection stage, the system subscribes to an event stream from a logging service of the vendor which logs API function calls during a time window corresponding to the blind spot period. Each incoming event is analyzed to identify a resource impacted by the event and a function call made which resulted in generation of the event. The system classifies the function call based on the function classes determined in the first stage and performs a bitwise operation between bit values maintained for the identified resource that are indicative of resource state and the bitmask of the determined function class (e.g., a bitwise OR). If the updated bit values corresponding to a resource state indicate that the resource was both created and deleted during the time window as a result of determining that function calls within the classes of &#x201c;create&#x201d; and &#x201c;delete&#x201d; impacted the resource, the resource can be flagged as potentially involved in an attack.</p><heading id="h-0005" level="1">Example Illustrations</heading><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>1</b></figref> depicts a conceptual diagram of processing an API specification to classify API functions by higher-level CRUD operation. <figref idref="DRAWINGS">FIG. <b>1</b></figref> depicts an API function classification system (&#x201c;system&#x201d;) <b>101</b>. The system <b>101</b> processes an API specification <b>105</b> of an API <b>111</b> published by a vendor <b>109</b> to classify each of a plurality of functions defined in the API specification <b>105</b> into a class corresponding to a higher-level CRUD operation. The vendor <b>109</b> may be a CSP, a vendor of a SaaS application, or any other provider of a service which has an API. The system <b>101</b> includes an API specification parser (&#x201c;parser&#x201d;) <b>103</b>, a function name analyzer (&#x201c;analyzer&#x201d;) <b>117</b>, and an API function classification structure generator (&#x201c;structure generator&#x201d;) <b>115</b>. The parser <b>103</b> parses an API specification to generate a format of the API specification by which individual function names defined therein can be accessed and further tokenized to split the function names into words of which they are comprised. The analyzer <b>117</b> identifies the tokens from parsed function names which correspond to verbs and classifies each verb into one of a set of classes which represent create events, update events, delete events, and other events. The structure generator <b>115</b> builds a file or data structure which indicates classes of each of the function names identified in the API specification.</p><p id="p-0018" num="0017">The system <b>101</b> obtains the API specification <b>105</b> from the vendor <b>109</b>. The vendor <b>109</b> may provide a function of the API <b>111</b> by which the API specification <b>105</b> can be requested and obtained, or the vendor <b>109</b> may offer the API specification <b>105</b> for download. The system <b>101</b> can obtain the API specification <b>105</b> based on invoking this function of the API <b>111</b> or based on downloading the API specification <b>105</b> from the vendor <b>109</b>. The API specification <b>105</b> can include one or more files comprising structured data. The structured data may at least include a name and a request/response schema for each operation (i.e., function) of the API. For instance, the API specification <b>105</b> can comprise a file(s) for one or more services offered by the vendor <b>109</b> having an API, where the API specification for each service is represented with JSON structured data.</p><p id="p-0019" num="0018">The parser <b>103</b> parses the API specification <b>105</b> such that function names included therein can be accessed. As an example, if the API specification <b>105</b> is represented with JSON or another format by which data are represented as key-value pairs, the parser <b>103</b> may load the JSON file(s) and generate a dictionary structure or other data structure by which individual values can be accessed via their associated keys. Since names of keys used to denote function names can vary across vendors, the parser <b>103</b> may have been configured to identify a key name known to be used in the API specification <b>105</b> based on an identity of the vendor <b>109</b>. Subsequent operations can be performed iteratively for each of the function names identifiable from the parsed representation of the API specification <b>105</b> or in stages, where each of the function names are processed at a respective stage.</p><p id="p-0020" num="0019">The parser <b>103</b> splits key-value pairs corresponding to the function names to separate the function name values from their respective keys. The parser <b>103</b> then splits each function name into tokens representing words which form the function name to generate function name tokens <b>119</b>. The manner in which the parser <b>103</b> splits the function names into words may be dependent on the identity of the vendor <b>109</b> and how the vendor <b>109</b> represents API functions in the API specification <b>105</b> (e.g., with camel case or paths). Generally, API function names comprise a verb and may include one or more nouns, where the verb specifies an action and the noun(s) can specify a resource. Splitting the function names into words therefore splits the function names into their respective verb-noun combinations. For example, for a function named &#x201c;CopyObject,&#x201d; splitting the function name into words yields individual tokens corresponding to the words &#x201c;Copy&#x201d; and &#x201c;Object,&#x201d; where &#x201c;Copy&#x201d; is a verb specifying a copy action and &#x201c;Object&#x201d; is a noun specifying an Object resource. The function name tokens <b>119</b> which the parser <b>103</b> generates comprise the tokenized API function names represented as verb/verb-noun combinations.</p><p id="p-0021" num="0020">For each function name represented in the function name tokens <b>119</b>, the analyzer <b>117</b> classifies the corresponding verb into one of a set of classes representing create actions, update actions, delete actions, and other actions, which roughly correspond to CRUD-type actions. For each of the function names and corresponding ones of the function name tokens <b>119</b>, the analyzer <b>117</b> determines which of the function name tokens <b>119</b> correspond to a verb. Determining which of the function name tokens <b>119</b> correspond to a verb can be based on known ordering of verbs and nouns for API function names defined by the vendor <b>109</b>. As an example, for the API <b>111</b> of the vendor <b>109</b>, function names may comport to a format in which the verb is the first word and the resource name is the second word(s), as is the case with &#x201c;CreateObject.&#x201d; In other examples, the analyzer <b>117</b> can implement part-of-speech tagging to determine which of the function name tokens <b>119</b> correspond to verbs and the noun(s) which are associated with each verb.</p><p id="p-0022" num="0021">The analyzer <b>117</b> then determines how to classify each verb based on verb classification rules (&#x201c;rules&#x201d;) <b>121</b>. In this example, the rules <b>121</b> indicate that classification of verbs is based on whether a verb is synonymous with create, update, or delete, and if the verb is not synonymous with any of these operation types, the verb should be classified as &#x201c;other.&#x201d; For each verb, the analyzer <b>117</b> analyzes the verb based on sets of CRUD operation synonyms (&#x201c;synonyms&#x201d;) <b>113</b>. The synonyms <b>113</b> comprise sets of synonyms for each of create, update, and delete operations. As an example, the synonyms <b>113</b> can include &#x201c;provision&#x201d; and &#x201c;remove&#x201d; in the sets of synonyms of create operations and delete operations, respectively. The analyzer <b>117</b> determines whether the verb is included in any of these sets of synonyms and, if so, classifies the associated function name into the respective class. For instance, returning to the example of &#x201c;CreateObject,&#x201d; the analyzer <b>117</b> can determine that &#x201c;Create&#x201d; is included in the set of synonyms for create operations and classifies the function name &#x201c;CreateObject&#x201d; into the class representing create operations. If the verb is not synonymous with any of the create, update, or delete operations, the analyzer <b>117</b> classifies the verb into the class of other operation types.</p><p id="p-0023" num="0022">Classes into which verbs can be classified as designated by the rules <b>121</b> can be associated with a bitmask, or binary representations of integers which are used for performing bitwise operations (also referred to as &#x201c;masking&#x201d;). In this example, the classes of create, update, delete, and other operations are denoted with bitmasks of 000, 010, 100, and 001, respectively. Classifying a function name into a class based on analysis of the verb can include associating an indication of the bitmask which identifies the class with the verb or the function name (e.g., as an attribute value of the function name, by creating a key-value pair, etc.). Classifying each of the function names identified from the API specification <b>105</b> by the analyzer <b>117</b> allows for distinguishing between functions which can be called to create a resource, update a resource, delete a resource, or perform another operation on a resource.</p><p id="p-0024" num="0023">The structure generator <b>115</b> generates a structure <b>107</b> which indicates the determined classes of the functions of the API <b>111</b>. The structure <b>107</b> may be any data structure or structured data representation which provides for associating names of functions with the bitmask representing their corresponding class. In this example, the structure <b>107</b> comprises a map data structure in which the function names are keys, and the values are the bitmasks. To generate the structure <b>107</b>, as the analyzer <b>117</b> classifies based on the rules <b>121</b>, the structure generator <b>115</b> adds key-value pairs indicating the function names and corresponding classes to the structure <b>107</b>. The structure generator <b>115</b> can add indications of functions and their classes to the structure <b>107</b> through insertion, appending, etc. depending on the data structure or structured data used to represent the classified API functions. The structure <b>107</b> which results maps each of the functions of the API <b>111</b> to a higher-level class of operation which the function implements. Events corresponding to API function calls which are subsequently detected at runtime can therefore efficiently be classified as corresponding to one of resource creation, resource update, resource deletion, or another operation on a resource based on performing a lookup of the function name in the structure <b>107</b> as is now described in reference to <figref idref="DRAWINGS">FIG. <b>2</b></figref>.</p><p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. <b>2</b></figref> depicts a conceptual diagram of automated detection of potential attacks occurring during a blind spot period. <figref idref="DRAWINGS">FIG. <b>2</b></figref> depicts an application <b>215</b> which utilizes services of a vendor <b>209</b>. As described in reference to <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the vendor <b>209</b> may be a vendor of a CSP, a provider of a SaaS application, or another entity or provider of a service which offers an API. The application <b>215</b> may thus be an instance of the SaaS application offered by the vendor <b>209</b> which serves a tenant, a cloud application running on a cloud provided by the vendor <b>209</b>, etc. Code of the application <b>215</b> can invoke functionality provided by the vendor <b>209</b> via an API <b>211</b> of the vendor. Function calls <b>217</b> made by the application <b>215</b> to the API <b>211</b> are logged as events by a logging service <b>219</b>. The logging service <b>219</b> is a logging service implemented or provided by the vendor <b>209</b>.</p><p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. <b>2</b></figref> also depicts an attack detection system (&#x201c;system&#x201d;) <b>203</b>. The system <b>203</b> detects potential attacks based on streaming events logged by the logging service <b>219</b>, determining the classes of the associated function calls and the impacted resources, and tracking states of the impacted resources based on the classes of function calls. The state of a resource refers to an aggregation of the types of operations which have been performed on that resource, where the different types of operations correspond to the classes of function calls determined as described in reference to <figref idref="DRAWINGS">FIG. <b>1</b></figref>. Example states of a resource include created, created and updated, and created, updated, and deleted.</p><p id="p-0027" num="0026">The logging service <b>219</b> has an event streaming service <b>229</b> by which the logging service <b>219</b> can publish events corresponding to logged API function calls to an API invocation event stream (&#x201c;event stream&#x201d;) <b>221</b>. The event streaming service <b>229</b> is a service provided by the vendor <b>209</b> which provides for generation of a data stream, where data points in the stream are events logged by the logging service <b>219</b> which correspond to detected calls to functions of the API <b>211</b>. The event streaming service <b>229</b> has been configured to publish API function calls logged by the logging service <b>219</b> to the event stream <b>221</b>. The system <b>203</b> subscribes to the event stream <b>221</b> via the event streaming service <b>229</b> to receive events during a time window corresponding to or overlapping with a blind spot period (e.g., a fifteen minute time window), where the logging service <b>219</b> may also have been configured to publish events to the event stream <b>221</b> during this time window. The time window may be a sliding time window of a configurable interval of time which corresponds to known latencies incurred during API function call logging in the environment of the vendor <b>209</b>. As the logging service <b>219</b> logs the function calls <b>217</b> as events, the logging service <b>219</b> publishes the events to the event stream <b>221</b> for communication to the system <b>203</b>.</p><p id="p-0028" num="0027">In this example, the logging service <b>219</b> publishes events <b>205</b>A, <b>205</b>B, <b>205</b>C (collectively the &#x201c;events <b>205</b>A-C&#x201d;) to the event stream <b>221</b> received by the system <b>203</b>. Each of the events <b>205</b>A-C comprises log data generated by the logging service <b>219</b> when logging a respective one of the function calls <b>217</b>. The events <b>205</b>A-C may comprise structured data (e.g., represented with JSON) which describes the corresponding API function call event. The data of the event <b>205</b>C, which is depicted in additional detail, comprises an event name <b>225</b>, a resource identifier (ID) <b>223</b>, and user ID information <b>227</b>. The event name <b>225</b> indicates the name of the API function which was called and resulted in generation of the event <b>205</b>C. The resource ID <b>223</b> is an identifier of the resource which was impacted/affected by the API function call indicated by the event name <b>225</b>. The user ID information <b>227</b> indicates identifying information of the user account from which the API function call originated. In this example, the event name <b>225</b> and resource ID <b>223</b> are &#x201c;deleteFunction&#x201d; and &#x201c;func_512,&#x201d; respectively. The resource identified as &#x201c;func_512&#x201d; may thus be a serverless function which was deleted through invocation of a function of the API <b>211</b> named &#x201c;deleteFunction.&#x201d;</p><p id="p-0029" num="0028">An event aggregator <b>231</b> of the system <b>203</b> aggregates events of the event stream <b>221</b> to generate aggregated events <b>201</b>. The aggregated events <b>201</b> may be a repository or other data store or structure that can be keyed or indexed by resource ID. The event aggregator <b>231</b> aggregates events by resource ID such that the aggregated events <b>201</b> tracks operations which have been performed on the identified resources. The indication of aggregated events maintained for a resource can be represented as a sequence of bit values representing Boolean values indicative of the classes of operations which have been performed on the resource, where each bit position represents a class of operation corresponding to a bitmask associated with that class in the structure <b>207</b>. As similarly described in reference to <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the structure <b>207</b> comprises indications of functions of the API <b>211</b> and their corresponding classes, where the classes roughly correspond to CRUD operations and are associated with a bitmask as a class identifier. Based on detection of an event indicating a resource ID and an API function which was called, the event aggregator <b>231</b> updates the indications of aggregated events maintained for that resource ID in accordance with event aggregation rules (&#x201c;rules&#x201d;) <b>233</b>. The rules <b>233</b> indicate creation or updates of aggregated events indicated for a resource ID which the event aggregator <b>231</b> should make based on determining the class of the function indicated in the structure <b>207</b>.</p><p id="p-0030" num="0029">The rules <b>233</b> indicate classes of API functions corresponding to events which may be determined from the event stream <b>221</b> and an associated update to aggregated event indications which the event aggregator <b>231</b> should make. The event aggregator <b>231</b> can thus aggregate events per resource based on determining a resource ID indicated in an event, determining the name of the API function that was called, referencing the structure <b>207</b> to determine the class of the API function and associated bitmask, and adding/updating an entry of the aggregated events <b>201</b> for the resource ID with the bitmask of the API function class according to the rules <b>233</b>. The entry for the resource ID can be created if the resource ID is not yet indicated in the aggregated events <b>201</b> (i.e., the API function has a class corresponding to creation/provisioning of resources) and updated if the resource ID is already indicated in the aggregated events. A sequence of bit values maintained for the entry which represents the aggregated events for the resource ID can thus be initialized or updated based on the rules <b>233</b>. As indicated by the rules <b>233</b>, aggregated event updates can include performing a bitwise OR on the existing bit values maintained for the resource with the bitmask corresponding to the function class. Utilizing bit values to represent aggregations of events and bitmasks to represent classes of operations performed on resources thus allows for performing bitwise operations to track and update resource states.</p><p id="p-0031" num="0030">With reference to the event <b>205</b>C, based on receiving the event <b>205</b>C, the event aggregator <b>231</b> determines the event name <b>225</b> which corresponds to the function of the API which was invoked. For instance, the event aggregator <b>231</b> can parse the event <b>205</b>C (e.g., if the event is represented as JSON data) and access the name of the API function via its associated key, or the key &#x201c;eventName&#x201d; in this example. The event aggregator <b>231</b> may have been configured to identify a key name known to be used for events generated by the logging service <b>219</b> based on an identity of the vendor <b>209</b>. The event aggregator <b>231</b> determines a class of the API function which was called based on identifying the class associated with the API function name in the structure <b>207</b>. The structure <b>207</b> may be searchable or indexable by event name or parsed event name to facilitate quick lookups of API function classes, where each class is associated with a bitmask representing the class. In this example, the function name &#x201c;deleteFunction&#x201d; is associated with a bitmask of 100 representing the class of functions which implement delete operations in the structure <b>207</b>.</p><p id="p-0032" num="0031">The event aggregator <b>231</b> also determines the resource ID associated with the events such that events can be aggregated by resource ID. For the event <b>205</b>C, the event aggregator <b>231</b> determines the resource ID <b>223</b> which was impacted by the call to &#x201c;deleteFunction.&#x201d; The event aggregator <b>231</b> updates indications of aggregated events <b>239</b> maintained for the resource ID <b>223</b> in a corresponding entry of the aggregated events <b>201</b> based on the operation indicated in the rules <b>233</b>. The indications of aggregated events <b>239</b> and other indications of aggregated events maintained stored in the aggregated events <b>201</b> may a field, attribute, etc. of the respective entries of the aggregated events <b>201</b>. Because the class ID determined for the event <b>205</b>C is 4, or 100 in binary, the event aggregator <b>231</b> performs a bitwise OR on the existing bit values of the indications of aggregated events <b>239</b> and the binary value 100, which flips the bit in the corresponding position to 1 representing a value of &#x201c;true&#x201d; for whether the resource corresponding to the resource ID <b>223</b> has been impacted by a delete operation.</p><p id="p-0033" num="0032">The resource state analyzer <b>235</b> analyzes states of resources reflected in the bit values maintained per resource ID in the aggregated events <b>201</b> to determine whether any of the resources have undergone both creation and deletion within the time window and thus may have been used to carry out an attack. The resource state analyzer <b>235</b> can make this determination for the resource ID <b>223</b> based on whether the updated bit values indicate a value of &#x201c;true&#x201d; in the bit positions corresponding to the classes of create and delete operations (e.g., based on performing a bitwise AND with the binary values 0100 and 1000). Because the values of both the bit positions corresponding to the class of delete operations and the class of create operations have a value of &#x201c;true,&#x201d; the resource state analyzer <b>235</b> determines that the resource with resource ID <b>223</b> was both created and deleted during the time window corresponding to the blind spot period and was potentially involved in an attack.</p><p id="p-0034" num="0033">The system <b>203</b> generates alerts <b>213</b> which indicate the resource(s) determined by the resource state analyzer <b>235</b> to have been created and deleted during the blind spot period. For instance, the system <b>203</b> may generate the alerts <b>213</b> by generating a notification, report, etc. A first of the alerts <b>213</b>, an alert <b>213</b>A, indicates the alert generated for the resource &#x201c;func_512&#x201d; having resource ID <b>223</b>. The alert <b>213</b>A indicates the resource ID <b>223</b> and the associated calls to the API <b>211</b> which were made. The alert <b>213</b>A also indicates the user ID information <b>227</b>, which is information associated with the account of the vendor <b>209</b> from which the identified function calls to the API <b>211</b> were initiated. As depicted in this example, the alerts <b>213</b> may also indicate a suggested action to take for attack remediation or to prevent similar attacks in the future. The alert <b>213</b>A indicates a suggested action of blocking the user identified by the user ID information.</p><p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. <b>3</b></figref> depicts a conceptual diagram of classifying functions of an API of a CSP and leveraging the function class information for detection of potential attacks in a cloud environment occurring during a blind spot period. <figref idref="DRAWINGS">FIG. <b>3</b></figref> depicts an example use case of an API function classification system (&#x201c;classification system&#x201d;) <b>301</b> and an attack detection system (&#x201c;detection system&#x201d;) <b>303</b> in which the API is one published by a CSP <b>309</b>. A cloud application <b>313</b> runs on a cloud <b>319</b> offered by the CSP <b>309</b>. The cloud application <b>313</b> can invoke functionality of services <b>323</b>A-N of the CSP <b>309</b> by calling functions of an API <b>311</b> offered by the CSP <b>309</b>. An API specification <b>305</b> of the API <b>111</b> includes an example service of the CSP <b>309</b> named &#x201c;ServerlessFunctions&#x201d; having example functions named &#x201c;CreateFunction,&#x201d; &#x201c;DeleteFunction,&#x201d; and &#x201c;InvokeFunction.&#x201d; A logging service <b>327</b> of the CSP <b>309</b> logs API function calls <b>325</b> made by the cloud application <b>313</b> to the API <b>311</b>, where each of the API function calls <b>325</b> can be recorded/logged as an event. Event data/metadata logged for each of the API function calls <b>325</b> may include a resource identifier (ID) of a resource affected or manipulated by the function call, a user ID associated with an account of the CSP <b>309</b> from which the function call originated, etc.</p><p id="p-0036" num="0035">The classification system <b>301</b> obtains the API specification <b>305</b> (e.g., based on downloading the API specification <b>305</b> from the CSP <b>309</b>). The classification system <b>301</b> parses the API specification <b>305</b>, determines the functions named in the API specification <b>305</b>, and classifies each of the determined functions into one of several classes representing CRUD operations or other operation types as similarly described in reference to <figref idref="DRAWINGS">FIG. <b>1</b></figref>. As also described in reference to <figref idref="DRAWINGS">FIG. <b>1</b></figref>, as a result of classifying the functions of the API <b>311</b>, each of the function names is associated with a bitmask corresponding to their class as a result of classification. In this example, &#x201c;CreateFunction&#x201d; is assigned a bitmask of 0, &#x201c;DeleteFunction&#x201d; is assigned a bitmask of 4, and &#x201c;InvokeFunction&#x201d; is assigned a bitmask of 2, or 000, 100, and 010 in binary, respectively. These bitmasks indicate that each of &#x201c;CreateFunction&#x201d;, &#x201c;DeleteFunction&#x201d;, and &#x201c;InvokeFunction&#x201d; belong to different classes of operations, such as classes of create operations, delete operations, and other operations. The classification system <b>301</b> creates a structure <b>307</b> which indicates names of functions of the API <b>311</b> and their corresponding classes represented by the bitmasks.</p><p id="p-0037" num="0036">The CSP <b>309</b> provides an event streaming service <b>331</b> which facilitates publishing of events, or API function calls logged by the logging service <b>327</b> in this example, to an event stream <b>329</b>. The detection system <b>303</b> processes and analyzes the event stream <b>329</b> for detection of potential copy-based/replacement style attacks occurring in the cloud <b>319</b>. The event stream <b>329</b> comprises events corresponding to the API function calls <b>325</b> which are logged by the logging service <b>327</b> and published to an event stream to which the detection system <b>303</b> subscribes. As the detection system <b>303</b> receives events of the event stream <b>329</b>, an event aggregator <b>315</b> of the detection system <b>303</b> aggregates events by affected (i.e., created, updated, deleted, or otherwise modified/accessed) resource. Aggregation of events by resource ID provides for grouping of events which impact the same resource so that the state of the resource can be tracked over the course of events. As part of aggregating events, the event aggregator <b>315</b> identifies the API function indicated in the event data and determines its class indicated in the structure <b>307</b>. The event aggregator <b>315</b> also determines the ID of the resource impacted by the API function call, such as based on a value of a field of a respective one of the events of the event stream <b>329</b> which indicates a resource ID associated with the event.</p><p id="p-0038" num="0037">The detection system <b>303</b> maintains bit values associated with each resource ID identified in the event stream <b>329</b>, where the bit values indicate an aggregation of events in which the corresponding one of the resources has been involved. As function classes associated with incoming events and the associated resource IDs are determined, the event aggregator <b>315</b> performs bitwise operations using the bitmask associated with the function classes and the bit values associated with the resource IDs. For instance, based on determining an API function call corresponding to an event, an ID of an impacted resource, and the associated class of the API function, the event aggregator <b>315</b> can perform a bitwise OR between bit values maintained in association with the resource ID indicating an aggregation of API function call types which have impacted that resource and a bitmask corresponding to the API function class to flip the bit in the bit position corresponding to the bitmask. Flipping a bit in a bit position corresponding to a bitmask, or setting that bit to &#x201c;true,&#x201d; indicates that an API function call associated with the class/type indicated by the bitmask has impacted the resource with the associated resource ID.</p><p id="p-0039" num="0038">If the detection system <b>303</b> detects that the aggregated events indicated by bit values maintained for a resource ID are indicative of creation and deletion of the resource during the time window of event streaming, the detection system <b>303</b> flags the resource ID and can generate an alert <b>321</b> which indicates the resource ID and associated API function calls affecting that resource. In this example, the detection system <b>303</b> determines that the aggregated events for the resource having resource ID &#x201c;func_512&#x201d; indicate creation and deletion of the resource during the time window. The detection system <b>303</b> thus generates the alert <b>321</b> which indicates the resource &#x201c;func_512&#x201d; and function calls to the API <b>311</b> which impacted the resource. The function &#x201c;func_512&#x201d; may thus be a serverless function which was created, invoked for execution of malicious code, and quickly deleted during the blind spot period.</p><p id="p-0040" num="0039"><figref idref="DRAWINGS">FIGS. <b>4</b>-<b>7</b></figref> depict example operations for detection of copy-replace attacks based on monitoring and classifying API function invocations. The example operations are described with reference to an API function classification system or an attack detection system (hereinafter the &#x201c;classification system&#x201d; and the &#x201c;detection system,&#x201d; respectively) for consistency with the earlier figures. The name chosen for the program code is not to be limiting on the claims. Structure and organization of a program can vary due to platform, programmer/architect preferences, programming language, etc. In addition, names of code units (programs, modules, methods, functions, etc.) can vary for the same reasons and can be arbitrary.</p><p id="p-0041" num="0040"><figref idref="DRAWINGS">FIG. <b>4</b></figref> depicts a flowchart of example operations for classifying functions of an API provided by a vendor by type of implemented operation. The example operations are described as being performed by the classification system.</p><p id="p-0042" num="0041">At block <b>401</b>, the classification system obtains an API specification(s) for one or more services offered by a vendor. The vendor may publish one API specification or a plurality of API specifications which each correspond to an API exposed by a different service offered by the vendor. The API specification(s) may comprise one or more files which include structured data, such as structured data represented with JSON, which indicate at least function names and a request/response schema for the functions. The classification system may obtain the API specification(s) by downloading the API specification(s) from the vendor.</p><p id="p-0043" num="0042">At block <b>403</b>, the classification system begins iterating over each file which was obtained. For instance, if the vendor published an API specification per service, where the service API specifications are packaged individually, the classification system iterates over each file for a corresponding service.</p><p id="p-0044" num="0043">At block <b>405</b>, the classification system parses the API specification. Parsing the API specification can include loading the file and converting the file to a structure or format by which the classification system can access individual elements (e.g., key-value pairs) of the API specification, such as a dictionary or other data structure.</p><p id="p-0045" num="0044">At block <b>407</b>, the classification system begins iterating over each function name in the parsed API specification. The classification system may iterate over the indications of function names based on a set of keys determined to correspond to function names. For instance, the classification system can determine which of the keys among the key-value pairs of the parsed API specification correspond to function names and access the function name values based on known naming conventions used by the vendor. The classification system can store the function name in a variable for further manipulation.</p><p id="p-0046" num="0045">At block <b>409</b>, the classification system classifies the function into one of a plurality of classes of types of CRUD operations based on analysis of the function name. The classification system splits the function name into tokens representing individual words of the function based on patterns/naming conventions used by the vendor in the API specification (e.g., splitting by camel case, splitting based on delimiters used in a path specifying the function name, etc.). The classification system then determines a CRUD operation type implemented by the function based on the verb identified from the function name, where the verb is also distinguished from the noun(s) based on the patterns/naming conventions used for function names. For instance, the classification system can compare the verb to sets of tokens corresponding to create operation types, update operation types, and delete operation types, and classify the function accordingly based on the verb matching a token in one of the sets. In other examples, the classification system can utilize part-of-speech tagging to determine the verb and then determine its synonyms as well as whether the synonyms match to a CRUD operation. Alternatively, if the verb does not match any of the tokens, the function can be classified into a class of other function types.</p><p id="p-0047" num="0046">Classifying the function can also include associating a bitmask unique to the determined class with the function name. Each of the classes of CRUD operation types or other operation types (e.g., classes of create, delete, update, and other operations) may be associated with a bitmask, such as 000 for create, 100 for delete, 001 for update, and 010 for other. Associations between classes of operation types and bitmasks can be specified in rules or policies maintained by the classification system. The classification system can determine the bitmask corresponding to the determined class (e.g., based on the rules of policies) and associate the bitmask with the function by adding the bitmask as an attribute of the function name, creating a key-value pair which associates the function name with the identifier, etc. Classification of a function into a class representing the type of CRUD operation implemented by the function is described in further detail in <figref idref="DRAWINGS">FIG. <b>5</b></figref>.</p><p id="p-0048" num="0047">At block <b>413</b>, the classification system adds an indication of the function and the corresponding class to a structure which stores associations between function names and classes. The structure can be structured data stored in a file (e.g., structured data represented with JSON) or a data structure by which function names can be associated with bitmasks identifying the classes of the function. For instance, the classification system can create a key-value pair that is added to (e.g., inserted into, appended onto, etc.) a map data structure in which one or more tokens of the function name is used as a key and the as the corresponding value. The structure can be indexable or keyable by at least part of the API function name to access the bitmasks stored therein.</p><p id="p-0049" num="0048">At block <b>413</b>, the classification system determines if an additional function is indicated in the API specification. If an additional function is indicated in the API specification, operations continue at block <b>407</b>. If there are no additional functions indicated in the API specification, operations continue at block <b>415</b>.</p><p id="p-0050" num="0049">At block <b>415</b>, the classification system determines if an additional file(s) is remaining. If there is an additional file remaining, such as a file comprising a specification of an API of another service, operations continue at block <b>403</b>. If there are no additional files remaining, operations are complete.</p><p id="p-0051" num="0050"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a flowchart of example operations for classifying a function as corresponding to a create, update, delete, or other operation based on analyzing the name of the function. The example operations are described as being performed by the classification system. The example operations assume that an API specification provided by a vendor has been obtained and parsed and that a function name has been identified from the specification (e.g., as described in <figref idref="DRAWINGS">FIG. <b>4</b></figref>).</p><p id="p-0052" num="0051">At block <b>501</b>, the classification system splits the function name into tokens based on patterns and/or function naming conventions used by the vendor. The classification system splits or parses the function name into tokens which correspond to words forming the function name. The function name may be composed of a word indicating an operation to perform on a resource and a noun(s) indicating the resource. Because representations of function names in the API specification can vary among vendors, the technique which the classification system leverages to split the function name may be based on the identity of the vendor. For instance, a first vendor may represent API function names using camel case, where words or names of resources/operations are separated by camel case (e.g., copyFile). The classification system could split the function name based on the cases of characters in the function name. As another example, a second vendor may represent API function names with paths, where words or names of resources/operations are separated by a delimiter in the path (e.g., /file/copy). The classification system could split the function name based on the delimiter.</p><p id="p-0053" num="0052">At block <b>503</b>, the classification system determines which of the tokens corresponds to the verb which specifies an action/operation. The classification system can determine the token corresponding to the verb and store it in a variable for further manipulation based on the patterns or function naming conventions. For instance, the verb may be the last word in the path for path representations of API function names or the first word in a function name represented with camel case, as is the case with /file/copy and copyFile, respectively. As another example, the classification system may implement part-of-speech tagging to distinguish the token(s) corresponding to the verb from other tokens. The classification system may comprise a part-of-speech tagger which reads the parsed function name and assigns part of speech tags to each word/token so that the words corresponding to verbs can be identified.</p><p id="p-0054" num="0053">At block <b>505</b>, the classification system analyzes the determined verb based on sets of verbs which correspond to create, update, and delete operations. The classification system can maintain a set of tokens corresponding to names of create operations, a set of tokens corresponding to names of update operations, and a set of tokens corresponding to names of delete operations. The sets of tokens may be lists or other data structures by which the names of operations can be enumerated. The sets of tokens for each operation type comprise synonyms of that operation type. For instance, the sets of tokens corresponding to names of create operations can include &#x201c;create,&#x201d; &#x201c;provision,&#x201d; &#x201c;new,&#x201d; etc., and the sets of tokens corresponding to names of delete operations can include &#x201c;delete,&#x201d; &#x201c;destroy,&#x201d; &#x201c;remove,&#x201d; etc. The classification system can analyze the verb by evaluating the verb against the sets of tokens to determine if the verb matches any of the tokens and is thus synonymous with the operation type represented by the corresponding set of tokens. In other examples, the classification system can analyze the determined verb by searching a dictionary, including as part of part-of-speech tagging, for verb classification. In such cases, the classification system searches the dictionary for the determined verb and identifies synonyms of the verb based on results of the searching the dictionary for the determined verb.</p><p id="p-0055" num="0054">At block <b>507</b>, the classification system determines if the operation can be classified as corresponding to one of a create, update, or delete operation. The function can be classified into a class of create, update, or delete operations based on similarity of the verb to CRUD contexts or can be classified into a class of other operation types if a similar CRUD operation cannot be identified. The classification system can determine that the operation can be classified as corresponding to one of a create, update, or delete operation rather than a different/other operation type if the verb could be identified among the create, update, or delete operation types based on which it was analyzed at block <b>505</b>. As another example, if a dictionary was utilized to determine synonyms of the verb, the classification system can determine if at least a first of the synonyms identified from the dictionary matches a known CRUD operation, such as the known CRUD operations indicated by the sets of CRUD tokens maintained by the classification system. For instance, the classification system can determine that the operation can be classified as create, update, or delete based on the synonym(s) identified from the dictionary matching one of create, update, delete, or another known synonym thereof. If the operation cannot be classified as corresponding to one of a create, update, or delete operation, operations continue at block <b>509</b>. If the operation can be classified as corresponding to such, operations continue at block <b>511</b>.</p><p id="p-0056" num="0055">At block <b>509</b>, the classification system associates a bitmask which identifies a class of other operation types with the function name. The classification system may maintain rules or policies which indicate the classes of operation types and corresponding bitmasks. The classification system can determine which of the bitmasks corresponds to the class of other operation types based on the rules or policies and associates that bitmask with the function name. The bitmask may be associated with the function name can by adding the bitmask as an attribute of the function name or creating a key-value pair which indicates the function name and bitmask, for example. Verbs corresponding to other operation types may be flagged for further analysis to determine if a corresponding CRUD operation type can be identified for the verb such that the sets of tokens can be updated with the verb for subsequent classification events.</p><p id="p-0057" num="0056">At block <b>511</b>, the classification system determines if the verb can be classified as corresponding to a create operation, an update operation, or a delete operation. The class representing the type of operation can be determined based on which of the create, update, or delete operation types was identified at block <b>505</b>. If the verb can be classified as corresponding to a create operation, operations continue at block <b>509</b>. If the verb can be classified as corresponding to an update operation, operations continue at block <b>515</b>. If the verb can be classified as corresponding to a delete operation, operations continue at block <b>517</b>.</p><p id="p-0058" num="0057">At block <b>513</b>, the classification system associates a bitmask which identifies a class of create operations with the function name. The classification system can determine which of the bitmasks corresponds to the class of create operation types based on the rules or policies which it maintains and associates that bitmask with the function name. The bitmask may be associated with the function name can by adding the bitmask as an attribute of the function name or creating a key-value pair which indicates the function name and bitmask, for example.</p><p id="p-0059" num="0058">At block <b>515</b>, the classification system associates a bitmask which identifies a class of update operations with the function name. The classification system can determine which of the bitmasks corresponds to the class of update operation types based on the rules or policies which it maintains and associates that bitmask with the function name. The bitmask may be associated with the function name can by adding the bitmask as an attribute of the function name or creating a key-value pair which indicates the function name and bitmask, for example.</p><p id="p-0060" num="0059">At block <b>517</b>, the classification system associates a bitmask which identifies a class of delete operations with the function name. The classification system can determine which of the bitmasks corresponds to the class of delete operation types based on the rules or policies which it maintains and associates that bitmask with the function name. The bitmask may be associated with the function name can by adding the bitmask as an attribute of the function name or creating a key-value pair which indicates the function name and bitmask, for example.</p><p id="p-0061" num="0060"><figref idref="DRAWINGS">FIGS. <b>6</b>-<b>7</b></figref> are a flowchart of example operations for detecting potential attacks occurring during a &#x201c;blind spot&#x201d; period of API polling or log auditing. The example operations are described as being performed by the detection system.</p><p id="p-0062" num="0061">At block <b>601</b>, the detection system subscribes to an event stream comprising API function call events logged during a defined time window corresponding to the blind spot period. A logging system of a vendor which provides resources being monitored has been configured to publish events corresponding to logged API function calls to an event stream via an event streaming service offered by or installed on the vendor. The detection system is thus configured to subscribe to this event stream such that events communicated during the streaming session are received by the detection system. The detection system subscribes to the event stream during a configurable window of time which should overlap or correspond to the blind spot period so that events are received as part of the event stream during the time which may not be accounted for in API poll or log audit data (e.g., a 10 minute streaming window, a 15 minute streaming window, etc.). The time window for event streaming is a moving window such that the detection system can collect data of the events occurring during a defined, controlled time window for analysis, and the time window can be incremented for subsequent analyses (e.g., for subsequent performance of the operations of <figref idref="DRAWINGS">FIGS. <b>6</b>-<b>7</b></figref>). Operations continue at transition point A, which continues at block <b>703</b> of <figref idref="DRAWINGS">FIG. <b>7</b></figref>.</p><p id="p-0063" num="0062">At block <b>703</b>, the detection system obtains an event record comprising data of a logged API function call. The detection system obtains the event record corresponding to a logged API function call published to the data stream of events by the logging service of the vendor. The event record at least indicates a name of a called API function and a user associated with an account from which the API function call was initiated. The event record may also indicate an ID of a resource impacted by the API function call, a timestamp, and/or other event data/metadata.</p><p id="p-0064" num="0063">At block <b>705</b>, the detection system determines the name of the API function which was called and an ID of the impacted resource. The detection system can determine the name of the API function and resource ID from the event record (e.g., based on corresponding key-value pairs of the event record). In some examples, multiple related resource IDs may be included in the event record. To determine the resource ID of interest in these cases, the detection system can evaluate the event record based on heuristics to determine the resource ID of interest. The heuristics may be unique to the vendor or may be shared across vendors. For instance, the event record may indicate multiple resources involved in the API function call, where one of the resources is the primary instance that is impacted. As an example, the event record may indicate an array of resources comprising a virtual server and the associated network interface(s), virtual private cloud, security group(s), subnet, etc. The heuristics may indicate keywords used in names of resource types which correspond to primary instances of interest. The detection system can analyze values of resource type fields across the set of resources based on the heuristics to determine which of the resources has a type corresponding to a primary instance of interest.</p><p id="p-0065" num="0064">At block <b>707</b>, the detection system determines the class of operation into which the API function was previously classified. The detection system can maintain or have access to a data structure or file comprising the indications of functions of the API and their corresponding class corresponding to operation type, where the class is denoted with a bitmask. The system can determine the class of the API function having a corresponding bitmask from the data structure or file by utilizing the function name as a key or index into the data structure/file. For instance, the detection system can determine the class from a map which associates function names with bitmasks representative of class of operation type, where the determined function name is used as a key to retrieve the corresponding bitmask representing the class of operation type.</p><p id="p-0066" num="0065">At block <b>708</b>, the detection system determines if bit values corresponding to aggregated indications of operation types performed on the resource already exist for the resource ID. The detection system can determine if an entry in a structure which tracks operations performed on resources, such as a repository or data store of aggregated events per resource ID, has already been created for the resource ID, where events are aggregated by performing bitwise operations between bit values maintained in an entry for the resource ID and bit values corresponding to types of operations determined from API function call events that are part of the event stream. If such bit values do not exist, operations continue at block <b>709</b>. If such bit values already exist, operations continue at block <b>710</b>.</p><p id="p-0067" num="0066">At block <b>709</b>, the detection system initializes bit values in association with the resource ID to indicate the class of operation performed on the resource. The detection system can create a new entry in the structure (e.g., the repository or data store of aggregated events) for the resource ID, where the entry indicates the bitmask associated with the class of operation determined at block <b>707</b>. Operations continue at transition point B, which continues at block <b>611</b> of <figref idref="DRAWINGS">FIG. <b>6</b></figref>.</p><p id="p-0068" num="0067">At block <b>710</b>, the detection system updates bit values associated with the resource ID to indicate the class of operation performed on the resource. The detection system can update an existing entry corresponding to the resource ID in the repository or data store of aggregated events to indicate the bitmask associated with the class of operation determined at block <b>707</b>. The detection system can perform a bitwise operation between the existing bit values which are indicated in the entry for the resource ID and the bitmask associated with a class, such as a bitwise OR. Performing a bitwise OR between these bit values sets the bit corresponding to position of the bitmask associated with the class to 1, or &#x201c;true,&#x201d; to indicate that an operation of the corresponding class has been performed on the resource in the time window. Operations continue at transition point B, which continues at block <b>611</b> of <figref idref="DRAWINGS">FIG. <b>6</b></figref>.</p><p id="p-0069" num="0068">At block <b>611</b>, the detection system determines if the resource was created and subsequently deleted within the time window. The detection system can determine that the resource was created and deleted within the time window if both the bit position corresponding to the class of create operations and the bit position corresponding to the class of delete operations (i.e., as given by their respective bitmasks) are set to 1, or &#x201c;true,&#x201d; to indicate that both create and delete operations were performed on the resource during the time window. For instance, the detection system can perform a bitwise operation between the bit values indicating aggregated events for the resource, the bitmask corresponding to the class of create operations, and the bitmask corresponding to the class of delete operations, such as a bitwise AND. Performing a bitwise AND between these bit values facilitates a determination of whether the bit positions corresponding to the classes of create and delete operations are set to 1, or &#x201c;true.&#x201d; Thus, if both bit positions of the result of the bitwise AND are set to 1, the resource can be determined to haven been created and deleted within the time window. If the resource was created and deleted in the time window, operations continue at block <b>613</b>. Otherwise, operations continue at block <b>615</b>.</p><p id="p-0070" num="0069">At block <b>613</b>, the detection system indicates that the resource was potentially used to carry out an attack. Rapid creation and deletion of a resource indicates that the resource may have been used to perform a malicious action (e.g., execution of malicious code) and was quickly deleted/destroyed to evade detection. The detection system may generate an alert, notification, report, etc. which indicates the resource ID, user(s), and API functions identified in events associated with that resource. The generated indication may also comprise a suggestion of an action which can be taken to remediate the attack or prevent additional occurrences of a similar attack, such as a suggestion that the identified user(s) be blocked.</p><p id="p-0071" num="0070">At block <b>615</b>, the detection system determines if an additional event has been logged in the time window. The detection system can determine if there are additional events based on obtaining another event record of the event stream and/or based on the time window of event streaming still being active. If an additional event has been logged, operations continue at block <b>703</b> of <figref idref="DRAWINGS">FIG. <b>7</b></figref>. If no additional events have been logged or the time window of event streaming has ended, operations are complete.</p><p id="p-0072" num="0071">Variations</p><p id="p-0073" num="0072">To reduce false positive detections of potential attacks due to legitimate scaling of resources which occurs during the blind spot period, workload scaling behaviors can be baselined during an initial observation period. For instance, during the baselining period, resource creation and deletion events occurring as a result of scaling up or down can be monitored and the count of events can be recorded and leveraged as the baseline, or an expected/average count of resource creation and deletion activities expected as a result of workload scaling. Baselines may be established per resource type or may be averaged across resource types. Once the baselines have been established, during the attack detection stage, resource creation and deletion events occurring during the blind spot can be evaluated against the baseline. Creation and deletion events within the baseline count(s) may be allowed to go undetected as potential attacks. Once creation and deletion events exceed the baseline count(s), the events can then be flagged as potential attacks. As an example, with reference to <figref idref="DRAWINGS">FIG. <b>2</b></figref>, the detection system <b>203</b> may subscribe to the event stream <b>221</b> during an initial observation period to determine baselines. The baselines may be per resource type of the vendor <b>209</b>, per function of the API <b>211</b>, or across resource types and functions, for example. Once the observation period has ended and the baselines have been established, the attack detection stage may commence during the next blind spot period. The resource state analyzer <b>235</b> may maintain the baselines as an additional criterion against which the aggregated indications of events per resource are evaluated so that the resource state analyzer <b>235</b> can determine whether the aggregated indications of events indicate that detected creation and deletion events are expected and can be allowed to pass rather than flagged as potential attacks.</p><p id="p-0074" num="0073">The flowcharts are provided to aid in understanding the illustrations and are not to be used to limit scope of the claims. The flowcharts depict example operations that can vary within the scope of the claims. Additional operations may be performed; fewer operations may be performed; the operations may be performed in parallel; and the operations may be performed in a different order. For example, the operations depicted in blocks <b>603</b>-<b>615</b> can be performed at least partially in parallel or concurrently for events detected in rapid succession. It will be understood that each block of the flowchart illustrations and/or block diagrams, and combinations of blocks in the flowchart illustrations and/or block diagrams, can be implemented by program code. The program code may be provided to a processor of a general purpose computer, special purpose computer, or other programmable machine or apparatus.</p><p id="p-0075" num="0074">As will be appreciated, aspects of the disclosure may be embodied as a system, method or program code/instructions stored in one or more machine-readable media. Accordingly, aspects may take the form of hardware, software (including firmware, resident software, micro-code, etc.), or a combination of software and hardware aspects that may all generally be referred to herein as a &#x201c;circuit,&#x201d; &#x201c;module&#x201d; or &#x201c;system.&#x201d; The functionality presented as individual modules/units in the example illustrations can be organized differently in accordance with any one of platform (operating system and/or hardware), application ecosystem, interfaces, programmer preferences, programming language, administrator preferences, etc.</p><p id="p-0076" num="0075">Any combination of one or more machine readable medium(s) may be utilized. The machine readable medium may be a machine readable signal medium or a machine readable storage medium. A machine readable storage medium may be, for example, but not limited to, a system, apparatus, or device, that employs any one of or combination of electronic, magnetic, optical, electromagnetic, infrared, or semiconductor technology to store program code. More specific examples (a non-exhaustive list) of the machine readable storage medium would include the following: a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or Flash memory), a portable compact disc read-only memory (CD-ROM), an optical storage device, a magnetic storage device, or any suitable combination of the foregoing. In the context of this document, a machine readable storage medium may be any tangible medium that can contain, or store a program for use by or in connection with an instruction execution system, apparatus, or device. A machine readable storage medium is not a machine readable signal medium.</p><p id="p-0077" num="0076">A machine readable signal medium may include a propagated data signal with machine readable program code embodied therein, for example, in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms, including, but not limited to, electro-magnetic, optical, or any suitable combination thereof. A machine readable signal medium may be any machine readable medium that is not a machine readable storage medium and that can communicate, propagate, or transport a program for use by or in connection with an instruction execution system, apparatus, or device.</p><p id="p-0078" num="0077">Program code embodied on a machine readable medium may be transmitted using any appropriate medium, including but not limited to wireless, wireline, optical fiber cable, RF, etc., or any suitable combination of the foregoing.</p><p id="p-0079" num="0078">The program code/instructions may also be stored in a machine readable medium that can direct a machine to function in a particular manner, such that the instructions stored in the machine readable medium produce an article of manufacture including instructions which implement the function/act specified in the flowchart and/or block diagram block or blocks.</p><p id="p-0080" num="0079"><figref idref="DRAWINGS">FIG. <b>8</b></figref> depicts an example computer system with an API function classification system and an attack detection system. The computer system includes a processor <b>801</b> (possibly including multiple processors, multiple cores, multiple nodes, and/or implementing multi-threading, etc.). The computer system includes memory <b>807</b>. The memory <b>807</b> may be system memory or any one or more of the above already described possible realizations of machine-readable media. The computer system also includes a bus <b>703</b> and a network interface <b>805</b>. The system also includes API function classification system <b>811</b> and attack detection system <b>813</b>. The API function classification system <b>811</b> classifies functions of an API by a higher-level type, where the action type can be one of the CRUD operations, based on analyzing names of the API functions. The attack detection system <b>813</b> detects potential copy-paste/replacement attacks based on streaming events generated from invocations of the API functions during a &#x201c;blind spot&#x201d; period and tracking states of resources based on classes of API functions which have impacted the resources. Any one of the previously described functionalities may be partially (or entirely) implemented in hardware and/or on the processor <b>801</b>. For example, the functionality may be implemented with an application specific integrated circuit, in logic implemented in the processor <b>801</b>, in a co-processor on a peripheral device or card, etc. Further, realizations may include fewer or additional components not illustrated in <figref idref="DRAWINGS">FIG. <b>8</b></figref> (e.g., video cards, audio cards, additional network interfaces, peripheral devices, etc.). The processor <b>801</b> and the network interface <b>805</b> are coupled to the bus <b>803</b>. Although illustrated as being coupled to the bus <b>803</b>, the memory <b>807</b> may be coupled to the processor <b>801</b>.</p><p id="p-0081" num="0080">While the aspects of the disclosure are described with reference to various implementations and exploitations, it will be understood that these aspects are illustrative and that the scope of the claims is not limited to them. In general, techniques for detection of copy-replace attacks through monitoring and classifying API function invocations as described herein may be implemented with facilities consistent with any hardware system or hardware systems. Many variations, modifications, additions, and improvements are possible.</p><p id="p-0082" num="0081">Plural instances may be provided for components, operations or structures described herein as a single instance. Finally, boundaries between various components, operations and data stores are somewhat arbitrary, and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of the disclosure. In general, structures and functionality presented as separate components in the example configurations may be implemented as a combined structure or component. Similarly, structures and functionality presented as a single component may be implemented as separate components. These and other variations, modifications, additions, and improvements may fall within the scope of the disclosure.</p><heading id="h-0006" level="1">Terminology</heading><p id="p-0083" num="0082">This description uses shorthand terms related to cloud technology for efficiency and ease of explanation. When referring to &#x201c;a cloud,&#x201d; this description is referring to the resources of a cloud service provider. For instance, a cloud can encompass the servers, virtual machines, and storage devices of a cloud service provider. The term &#x201c;cloud destination&#x201d; and &#x201c;cloud source&#x201d; refer to an entity that has a network address that can be used as an endpoint for a network connection. The entity may be a physical device (e.g., a server) or may be a virtual entity (e.g., virtual server or virtual storage device). In more general terms, a cloud service provider resource accessible to customers is a resource owned/manage by the cloud service provider entity that is accessible via network connections. Often, the access is in accordance with an application programming interface or software development kit provided by the cloud service provider.</p><p id="p-0084" num="0083">This description uses the term &#x201c;data stream&#x201d; to refer to a unidirectional stream of data flowing over a data connection between two entities in a session. The entities in the session may be interfaces, services, etc. The elements of the data stream will vary in size and formatting depending upon the entities communicating with the session. Although the data stream elements will be segmented/divided according to the protocol supporting the session, the entities may be handling the data at an operating system perspective and the data stream elements may be data blocks from that operating system perspective. The data stream is a &#x201c;stream&#x201d; because a data set (e.g., a volume or directory) is serialized at the source for streaming to a destination. Serialization of the data stream elements allows for reconstruction of the data set. The data stream can be characterized as &#x201c;flowing&#x201d; over a data connection because the data stream elements are continuously transmitted from the source until completion or an interruption. The data connection over which the data stream flows is a logical construct that represents the endpoints that define the data connection. The endpoints can be represented with logical data structures that can be referred to as interfaces. A session is an abstraction of one or more connections. A session may be, for example, a data connection and a management connection. A management connection is a connection that carries management messages for changing state of services associated with the session.</p><p id="p-0085" num="0084">Use of the phrase &#x201c;at least one of&#x201d; preceding a list with the conjunction &#x201c;and&#x201d; should not be treated as an exclusive list and should not be construed as a list of categories with one item from each category, unless specifically stated otherwise. A clause that recites &#x201c;at least one of A, B, and C&#x201d; can be infringed with only one of the listed items, multiple of the listed items, and one or more of the items in the list and another item not listed.</p><?detailed-description description="Detailed Description" end="tail"?></description><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A method comprising:<claim-text>based on streaming events during a time window, obtaining data of a first event of a stream of events, wherein the first event corresponds to a call to a first function of an application programming interface (API);</claim-text><claim-text>determining a classification of the first function, wherein the classification is one of a plurality of classifications corresponding to operation types;</claim-text><claim-text>based on identifying a resource indicated in the call to the first function, updating a first structure with an indication of a first of the operation types corresponding to the classification of the first function, wherein the first structure tracks which of the operation types have been performed on the resource;</claim-text><claim-text>determining if the resource has been created and deleted during the time window based, at least in part, on the updated first structure; and</claim-text><claim-text>based on determining that the resource has been created and deleted during the time window, indicating that the resource was potentially involved in an attack carried out during the time window.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprising determining a bitmask associated with the classification of the first function, wherein each of the plurality of classifications is associated with a corresponding one of a plurality of bitmasks, and wherein the first structure comprises a sequence of bit values in association with an identifier of the resource.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein updating the first structure comprises performing a bitwise operation between the bitmask associated with the classification of the first function and the sequence of bit values, and wherein the updated first structure is a result of the bitwise operation.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the bitwise operation comprises a bitwise OR operation between the bitmask and the sequence of bit values.</claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>,<claim-text>wherein each bit position of the sequence of bit values indicates whether a corresponding one of the operation types has been performed on the resource, and</claim-text><claim-text>wherein determining if the resource has been created and deleted comprises performing a bitwise operation between the sequence of bit values, a first of the plurality of bitmasks corresponding to a classification of delete operations, and a second of the plurality of bitmasks corresponding to a classification of create operations.</claim-text></claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the bitwise operation comprises a bitwise AND operation.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>,<claim-text>wherein the operation types comprise create operations, delete operations, update operations, and other operations, and</claim-text><claim-text>wherein the plurality of classifications comprises a classification of create operations, a classification of delete operations, a classification of update operations, and a classification of other operations.</claim-text></claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein identifying the resource comprises identifying an identifier of the resource included in data of the first event.</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein updating the first structure comprises initializing an entry in the first structure for the resource with an indication of the first operation type based, at least in part, on determining that an entry in the first structure for the resource has not been initialized during the time window.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprising determining a user associated with the call to the first function based, at least in part, on the data of the first event, wherein indicating that the resource was potentially involved in an attack comprises indicating information about the user.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. One or more non-transitory machine-readable media comprising program code to:<claim-text>parse a specification of an application programming interface (API), wherein the specification of the API indicates a plurality of functions,</claim-text><claim-text>for each function of the plurality of functions,<claim-text>determine a verb included in a name of the function based, at least in part, on a pattern used among names of the plurality of functions;</claim-text><claim-text>based on analysis of the verb, determine a type of operation to which the verb corresponds; and</claim-text><claim-text>classify the function into one of a plurality of operation type classes, wherein the operation type class into which the function is classified corresponds to the determined type of operation.</claim-text></claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The non-transitory machine-readable media of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the program code to determine the type of operation comprises program code to determine if the verb corresponds to a create operation, an update operation, a delete operation, or another operation type based on the analysis of the verb.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The non-transitory machine-readable media of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the program code to analyze the verb comprises program code to evaluate the verb against sets of tokens corresponding to each of create operations, delete operations, and update operations and determine if the verb matches a first token of the sets of tokens.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The non-transitory machine-readable media of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the program code to classify the function comprises program code to associate a bitmask corresponding to the operation type class with the name of the function.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The non-transitory machine-readable media of <claim-ref idref="CLM-00011">claim 11</claim-ref> further comprising program code to determine a plurality of tokens from the name of the function based, at least in part, on the pattern used among names of the plurality of functions, wherein the program code to determine the verb comprises program code to determine the verb based, at least in part, on the plurality of tokens and the pattern used among names.</claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. An apparatus comprising:<claim-text>a processor; and</claim-text><claim-text>a computer-readable medium having instructions stored thereon that are executable by the processor to cause the apparatus to,<claim-text>obtain data of a first event of a stream of events published during a time window, wherein the first event corresponds to a call to a first function of an application programming interface (API);</claim-text><claim-text>determine a classification of a plurality of classifications into which the first function was previously classified, the plurality of classifications corresponding to operation types;</claim-text><claim-text>based on identification of a resource indicated in data of the first event, update a first structure with an indication of a first of the operation types corresponding to the classification of the first function,</claim-text><claim-text>wherein the first structure tracks which of the operation types have been performed on the resource;</claim-text><claim-text>determine if the resource has been created and deleted during the time window based, at least in part, on the updated first structure; and</claim-text><claim-text>based on a determination that the resource has been created and deleted during the time window, indicate that the resource was potentially involved in an attack carried out during the time window.</claim-text></claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The apparatus of <claim-ref idref="CLM-00016">claim 16</claim-ref>, further comprising program code executable by the processor to cause the apparatus to determine a bitmask associated with the classification, wherein each of the plurality of classifications is associated with a corresponding plurality of bitmasks, and wherein the first structure comprises a sequence of bit values in association with an identifier of the resource.</claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The apparatus of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the program code executable by the processor to cause the apparatus to update the first structure comprises program code executable by the processor to cause the apparatus to perform a bitwise OR between the bitmask associated with the classification of the first function and the sequence of bit values, wherein the updated first structure is a result of the bitwise OR.</claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The apparatus of <claim-ref idref="CLM-00017">claim 17</claim-ref>,<claim-text>wherein each bit position of the sequence of bit values indicates whether a corresponding one of the operation types has been performed on the resource, and</claim-text><claim-text>wherein the program code executable by the processor to cause the apparatus to determine if the resource has been created and deleted comprises the program code executable by the processor to cause the apparatus to perform a bitwise AND between the sequence of bit values, a first of the plurality of bitmasks corresponding to a classification of delete operations, and a second of the plurality of bitmasks corresponding to a classification of create operations.</claim-text></claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The apparatus of <claim-ref idref="CLM-00016">claim 16</claim-ref> further comprising program code executable by the processor to cause the apparatus to determine a user associated with the call to the first function based, at least in part, on the data of the first event, wherein the program code executable by the processor to cause the apparatus to indicate that the resource was potentially involved in an attack comprises program code executable by the processor to cause the apparatus to indicate information about the user.</claim-text></claim></claims></us-patent-application>