<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230007299A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230007299</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17573823</doc-number><date>20220112</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>593</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>176</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>11</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>13</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>136</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>593</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>176</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>11</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>13</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>136</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">HARMONIZED DESIGN FOR OFFSET BASED REFINEMENT AND MULTIPLE REFERENCE LINE SELECTION</invention-title><us-related-documents><us-provisional-application><document-id><country>US</country><doc-number>63217061</doc-number><date>20210630</date></document-id></us-provisional-application></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Tencent America LLC</orgname><address><city>Palo Alto</city><state>CA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>ZHAO</last-name><first-name>Liang</first-name><address><city>Sunnyvale</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>ZHAO</last-name><first-name>Xin</first-name><address><city>San Jose</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>LIU</last-name><first-name>Shan</first-name><address><city>San Jose</city><state>CA</state><country>US</country></address></addressbook></inventor></inventors></us-parties><assignees><assignee><addressbook><orgname>Tencent America LLC</orgname><role>02</role><address><city>Palo Alto</city><state>CA</state><country>US</country></address></addressbook></assignee></assignees></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">Methods, apparatus, and computer readable storage medium for offset refinement for intra prediction and multiple reference line intra prediction in video decoding. The method includes receiving, by a device, a coded video bitstream for a block. The device includes a memory storing instructions and a processor in communication with the memory. The method further includes determining, by the device, whether offset refinement for intra prediction applies to the block, based on mode information of the block, the mode information of the block comprising at least one of the following: a reference line index of the block, an intra prediction mode of the block, and a size of the block; and in response to determining that the offset refinement for intra prediction applies to the block, performing, by the device, the offset refinement to generate an intra predictor for intra prediction of the block.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="122.34mm" wi="158.75mm" file="US20230007299A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="237.66mm" wi="160.61mm" orientation="landscape" file="US20230007299A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="237.74mm" wi="177.38mm" orientation="landscape" file="US20230007299A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="96.27mm" wi="130.22mm" orientation="landscape" file="US20230007299A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="211.41mm" wi="163.41mm" orientation="landscape" file="US20230007299A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="204.72mm" wi="165.44mm" orientation="landscape" file="US20230007299A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="217.51mm" wi="177.55mm" orientation="landscape" file="US20230007299A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="241.89mm" wi="178.22mm" orientation="landscape" file="US20230007299A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="246.13mm" wi="178.90mm" orientation="landscape" file="US20230007299A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="241.81mm" wi="178.14mm" orientation="landscape" file="US20230007299A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="164.00mm" wi="127.85mm" orientation="landscape" file="US20230007299A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="183.98mm" wi="162.22mm" orientation="landscape" file="US20230007299A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="173.14mm" wi="171.20mm" orientation="landscape" file="US20230007299A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="239.69mm" wi="185.76mm" orientation="landscape" file="US20230007299A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00014" num="00014"><img id="EMI-D00014" he="206.25mm" wi="111.42mm" orientation="landscape" file="US20230007299A1-20230105-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00015" num="00015"><img id="EMI-D00015" he="232.92mm" wi="164.08mm" orientation="landscape" file="US20230007299A1-20230105-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00016" num="00016"><img id="EMI-D00016" he="244.52mm" wi="163.15mm" orientation="landscape" file="US20230007299A1-20230105-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00017" num="00017"><img id="EMI-D00017" he="206.16mm" wi="161.54mm" file="US20230007299A1-20230105-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00018" num="00018"><img id="EMI-D00018" he="231.14mm" wi="177.72mm" orientation="landscape" file="US20230007299A1-20230105-D00018.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">RELATED APPLICATION</heading><p id="p-0002" num="0001">This application is a based on and claims the benefit of priority to U.S. Provisional Application No. 63/217,061 filed on Jun. 30, 2021, which is herein incorporated by reference in its entirety.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">FIELD OF THE TECHNOLOGY</heading><p id="p-0003" num="0002">The present disclosure relates to video coding and/or decoding technologies, and in particular, to improved design and signaling of offset based refinement and multiple reference line selection scheme.</p><heading id="h-0003" level="1">BACKGROUND OF THE DISCLOSURE</heading><p id="p-0004" num="0003">This background description provided herein is for the purpose of generally presenting the context of the disclosure. Work of the presently named inventors, to the extent the work is described in this background section, as well as aspects of the description that may not otherwise qualify as prior art at the time of filing of this application, are neither expressly nor impliedly admitted as prior art against the present disclosure.</p><p id="p-0005" num="0004">Video coding and decoding can be performed using inter-picture prediction with motion compensation. Uncompressed digital video can include a series of pictures, with each picture having a spatial dimension of, for example, 1920&#xd7;1080 luminance samples and associated full or subsampled chrominance samples. The series of pictures can have a fixed or variable picture rate (alternatively referred to as frame rate) of, for example, 60 pictures per second or 60 frames per second. Uncompressed video has specific bitrate requirements for streaming or data processing. For example, video with a pixel resolution of 1920&#xd7;1080, a frame rate of 60 frames/second, and a chroma subsampling of 4:2:0 at 8 bit per pixel per color channel requires close to 1.5 Gbit/s bandwidth. An hour of such video requires more than 600 GBytes of storage space.</p><p id="p-0006" num="0005">One purpose of video coding and decoding can be the reduction of redundancy in the uncompressed input video signal, through compression. Compression can help reduce the aforementioned bandwidth and/or storage space requirements, in some cases, by two orders of magnitude or more. Both lossless compression and lossy compression, as well as a combination thereof can be employed. Lossless compression refers to techniques where an exact copy of the original signal can be reconstructed from the compressed original signal via a decoding process. Lossy compression refers to coding/decoding process where original video information is not fully retained during coding and not fully recoverable during decoding. When using lossy compression, the reconstructed signal may not be identical to the original signal, but the distortion between original and reconstructed signals is made small enough to render the reconstructed signal useful for the intended application albeit some information loss. In the case of video, lossy compression is widely employed in many applications. The amount of tolerable distortion depends on the application. For example, users of certain consumer video streaming applications may tolerate higher distortion than users of cinematic or television broadcasting applications. The compression ratio achievable by a particular coding algorithm can be selected or adjusted to reflect various distortion tolerance: higher tolerable distortion generally allows for coding algorithms that yield higher losses and higher compression ratios.</p><p id="p-0007" num="0006">A video encoder and decoder can utilize techniques from several broad categories and steps, including, for example, motion compensation, Fourier transform, quantization, and entropy coding.</p><p id="p-0008" num="0007">Video codec technologies can include techniques known as intra coding. In intra coding, sample values are represented without reference to samples or other data from previously reconstructed reference pictures. In some video codecs, a picture is spatially subdivided into blocks of samples. When all blocks of samples are coded in intra mode, that picture can be referred to as an intra picture. Intra pictures and their derivatives such as independent decoder refresh pictures, can be used to reset the decoder state and can, therefore, be used as the first picture in a coded video bitstream and a video session, or as a still image. The samples of a block after intra prediction can then be subject to a transform into frequency domain, and the transform coefficients so generated can be quantized before entropy coding. Intra prediction represents a technique that minimizes sample values in the pre-transform domain. In some cases, the smaller the DC value after a transform is, and the smaller the AC coefficients are, the fewer the bits that are required at a given quantization step size to represent the block after entropy coding.</p><p id="p-0009" num="0008">Traditional intra coding such as that known from, for example, MPEG-2 generation coding technologies, does not use intra prediction. However, some newer video compression technologies include techniques that attempt coding/decoding of blocks based on, for example, surrounding sample data and/or metadata that are obtained during the encoding and/or decoding of spatially neighboring, and that precede in decoding order the blocks of data being intra coded or decoded. Such techniques are henceforth called &#x201c;intra prediction&#x201d; techniques. Note that in at least some cases, intra prediction uses reference data only from the current picture under reconstruction and not from other reference pictures.</p><p id="p-0010" num="0009">There can be many different forms of intra prediction. When more than one of such techniques are available in a given video coding technology, the technique in use can be referred to as an intra prediction mode. One or more intra prediction modes may be provided in a particular codec. In certain cases, modes can have submodes and/or may be associated with various parameters, and mode/submode information and intra coding parameters for blocks of video can be coded individually or collectively included in mode codewords. Which codeword to use for a given mode, submode, and/or parameter combination can have an impact in the coding efficiency gain through intra prediction, and so can the entropy coding technology used to translate the codewords into a bitstream.</p><p id="p-0011" num="0010">A certain mode of intra prediction was introduced with H.264, refined in H.265, and further refined in newer coding technologies such as joint exploration model (JEM), versatile video coding (VVC), and benchmark set (BMS). Generally, for intra prediction, a predictor block can be formed using neighboring sample values that have become available. For example, available values of particular set of neighboring samples along certain direction and/or lines may be copied into the predictor block. A reference to the direction in use can be coded in the bitstream or may itself be predicted.</p><p id="p-0012" num="0011">Referring to <figref idref="DRAWINGS">FIG. <b>1</b>A</figref>, depicted in the lower right is a subset of nine predictor directions specified in H.265's 33 possible intra predictor directions (corresponding to the 33 angular modes of the 35 intra modes specified in H.265). The point where the arrows converge (<b>101</b>) represents the sample being predicted. The arrows represent the direction from which neighboring samples are used to predict the sample at <b>101</b>. For example, arrow (<b>102</b>) indicates that sample (<b>101</b>) is predicted from a neighboring sample or samples to the upper right, at a 45 degree angle from the horizontal direction. Similarly, arrow (<b>103</b>) indicates that sample (<b>101</b>) is predicted from a neighboring sample or samples to the lower left of sample (<b>101</b>), in a 22.5 degree angle from the horizontal direction.</p><p id="p-0013" num="0012">Still referring to <figref idref="DRAWINGS">FIG. <b>1</b>A</figref>, on the top left there is depicted a square block (<b>104</b>) of 4&#xd7;4 samples (indicated by a dashed, boldface line). The square block (<b>104</b>) includes 16 samples, each labelled with an &#x201c;S&#x201d;, its position in the Y dimension (e.g., row index) and its position in the X dimension (e.g., column index). For example, sample S21 is the second sample in the Y dimension (from the top) and the first (from the left) sample in the X dimension. Similarly, sample S44 is the fourth sample in block (<b>104</b>) in both the Y and X dimensions. As the block is 4&#xd7;4 samples in size, S44 is at the bottom right. Further shown are example reference samples that follow a similar numbering scheme. A reference sample is labelled with an R, its Y position (e.g., row index) and X position (column index) relative to block (<b>104</b>). In both H.264 and H.265, prediction samples adjacently neighboring the block under reconstruction are used.</p><p id="p-0014" num="0013">Intra picture prediction of block <b>104</b> may begin by copying reference sample values from the neighboring samples according to a signaled prediction direction. For example, assuming that the coded video bitstream includes signaling that, for this block <b>104</b>, indicates a prediction direction of arrow (<b>102</b>)&#x2014;that is, samples are predicted from a prediction sample or samples to the upper right, at a 45-degree angle from the horizontal direction. In such a case, samples S41, S32, S23, and S14 are predicted from the same reference sample R05. Sample S44 is then predicted from reference sample R08.</p><p id="p-0015" num="0014">In certain cases, the values of multiple reference samples may be combined, for example through interpolation, in order to calculate a reference sample; especially when the directions are not evenly divisible by 45 degrees.</p><p id="p-0016" num="0015">The number of possible directions has increased as video coding technology has continued to develop. In H.264 (year 2003), for example, nine different direction are available for intra prediction. That increased to 33 in H.265 (year 2013), and JEM/VVC/BMS, at the time of this disclosure, can support up to 65 directions. Experimental studies have been conducted to help identify the most suitable intra prediction directions, and certain techniques in the entropy coding may be used to encode those most suitable directions in a small number of bits, accepting a certain bit penalty for directions. Further, the directions themselves can sometimes be predicted from neighboring directions used in the intra prediction of the neighboring blocks that have been decoded.</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>1</b>B</figref> shows a schematic (<b>180</b>) that depicts 65 intra prediction directions according to JEM to illustrate the increasing number of prediction directions in various encoding technologies developed over time.</p><p id="p-0018" num="0017">The manner for mapping of bits representing intra prediction directions to the prediction directions in the coded video bitstream may vary from video coding technology to video coding technology; and can range, for example, from simple direct mappings of prediction direction to intra prediction mode, to codewords, to complex adaptive schemes involving most probable modes, and similar techniques. In all cases, however, there can be certain directions for intro prediction that are statistically less likely to occur in video content than certain other directions. As the goal of video compression is the reduction of redundancy, those less likely directions will, in a well-designed video coding technology, may be represented by a larger number of bits than more likely directions.</p><p id="p-0019" num="0018">Inter picture prediction, or inter prediction may be based on motion compensation. In motion compensation, sample data from a previously reconstructed picture or part thereof (reference picture), after being spatially shifted in a direction indicated by a motion vector (MV henceforth), may be used for a prediction of a newly reconstructed picture or picture part (e.g., a block). In some cases, the reference picture can be the same as the picture currently under reconstruction. MVs may have two dimensions X and Y, or three dimensions, with the third dimension being an indication of the reference picture in use (akin to a time dimension).</p><p id="p-0020" num="0019">In some video compression techniques, a current MV applicable to a certain area of sample data can be predicted from other MVs, for example from those other MVs that are related to other areas of the sample data that are spatially adjacent to the area under reconstruction and precede the current MV in decoding order. Doing so can substantially reduce the overall amount of data required for coding the MVs by relying on removing redundancy in correlated MVs, thereby increasing compression efficiency. MV prediction can work effectively, for example, because when coding an input video signal derived from a camera (known as natural video) there is a statistical likelihood that areas larger than the area to which a single MV is applicable move in a similar direction in the video sequence and, therefore, can in some cases be predicted using a similar motion vector derived from MVs of neighboring area. That results in the actual MV for a given area to be similar or identical to the MV predicted from the surrounding MVs. Such an MV in turn may be represented, after entropy coding, in a smaller number of bits than what would be used if the MV is coded directly rather than predicted from the neighboring MV(s). In some cases, MV prediction can be an example of lossless compression of a signal (namely: the MVs) derived from the original signal (namely: the sample stream). In other cases, MV prediction itself can be lossy, for example because of rounding errors when calculating a predictor from several surrounding MVs.</p><p id="p-0021" num="0020">Various MV prediction mechanisms are described in H.265/HEVC (ITU-T Rec. H.265, &#x201c;High Efficiency Video Coding&#x201d;, December 2016). Out of the many MV prediction mechanisms that H.265 specifies, described below is a technique henceforth referred to as &#x201c;spatial merge&#x201d;.</p><p id="p-0022" num="0021">Specifically, referring to <figref idref="DRAWINGS">FIG. <b>2</b></figref>, a current block (<b>201</b>) comprises samples that have been found by the encoder during the motion search process to be predictable from a previous block of the same size that has been spatially shifted. Instead of coding that MV directly, the MV can be derived from metadata associated with one or more reference pictures, for example from the most recent (in decoding order) reference picture, using the MV associated with either one of five surrounding samples, denoted A0, A1, and B0, B1, B2 (<b>202</b> through <b>206</b>, respectively). In H.265, the MV prediction can use predictors from the same reference picture that the neighboring block uses.</p><heading id="h-0004" level="1">SUMMARY</heading><p id="p-0023" num="0022">The present disclosure describes various embodiments of methods, apparatus, and computer-readable storage medium for video encoding and/or decoding.</p><p id="p-0024" num="0023">According to one aspect, an embodiment of the present disclosure provides a method for offset refinement for intra prediction and multiple reference line intra prediction in video decoding. The method includes receiving, by a device, a coded video bitstream for a block. The device includes a memory storing instructions and a processor in communication with the memory. The method further includes determining, by the device, whether offset refinement for intra prediction applies to the block, based on mode information of the block, the mode information of the block comprising at least one of the following: a reference line index of the block, an intra prediction mode of the block, and a size of the block; and in response to determining that the offset refinement for intra prediction applies to the block, performing, by the device, the offset refinement to generate an intra predictor for intra prediction of the block.</p><p id="p-0025" num="0024">According to another aspect, an embodiment of the present disclosure provides an apparatus for video encoding and/or decoding. The apparatus includes a memory storing instructions; and a processor in communication with the memory. When the processor executes the instructions, the processor is configured to cause the apparatus to perform the above methods for video decoding and/or encoding.</p><p id="p-0026" num="0025">In another aspect, an embodiment of the present disclosure provides non-transitory computer-readable mediums storing instructions which when executed by a computer for video decoding and/or encoding cause the computer to perform the above methods for video decoding and/or encoding.</p><p id="p-0027" num="0026">The above and other aspects and their implementations are described in greater detail in the drawings, the descriptions, and the claims.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0028" num="0027">Further features, the nature, and various advantages of the disclosed subject matter will be more apparent from the following detailed description and the accompanying drawings.</p><p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. <b>1</b>A</figref> shows a schematic illustration of an exemplary subset of intra prediction directional modes.</p><p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. <b>1</b>B</figref> shows an illustration of exemplary intra prediction directions.</p><p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. <b>2</b></figref> shows a schematic illustration of a current block and its surrounding spatial merge candidates for motion vector prediction in one example.</p><p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. <b>3</b></figref> shows a schematic illustration of a simplified block diagram of a communication system (<b>300</b>) in accordance with an example embodiment.</p><p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. <b>4</b></figref> shows a schematic illustration of a simplified block diagram of a communication system (<b>400</b>) in accordance with an example embodiment.</p><p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. <b>5</b></figref> shows a schematic illustration of a simplified block diagram of a video decoder in accordance with an example embodiment.</p><p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. <b>6</b></figref> shows a schematic illustration of a simplified block diagram of a video encoder in accordance with an example embodiment.</p><p id="p-0036" num="0035"><figref idref="DRAWINGS">FIG. <b>7</b></figref> shows a block diagram of a video encoder in accordance with another example embodiment.</p><p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. <b>8</b></figref> shows a block diagram of a video decoder in accordance with another example embodiment.</p><p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. <b>9</b></figref> shows directional intra prediction modes according to example embodiments of the disclosure.</p><p id="p-0039" num="0038"><figref idref="DRAWINGS">FIG. <b>10</b></figref> shows non-directional intra prediction modes according to example embodiments of the disclosure.</p><p id="p-0040" num="0039"><figref idref="DRAWINGS">FIG. <b>11</b></figref> shows recursive intra prediction modes according to example embodiments of the disclosure.</p><p id="p-0041" num="0040"><figref idref="DRAWINGS">FIG. <b>12</b></figref> shows an intra prediction scheme based on various reference lines according to example embodiments of the disclosure.</p><p id="p-0042" num="0041"><figref idref="DRAWINGS">FIG. <b>13</b></figref> shows an offset-based refinement for intra prediction according to example embodiments of the disclosure.</p><p id="p-0043" num="0042"><figref idref="DRAWINGS">FIG. <b>14</b>A</figref> shows another diagram of offset-based refinement for intra prediction according to example embodiments of the disclosure.</p><p id="p-0044" num="0043"><figref idref="DRAWINGS">FIG. <b>14</b>B</figref> shows another diagram of offset-based refinement for intra prediction according to example embodiments of the disclosure.</p><p id="p-0045" num="0044"><figref idref="DRAWINGS">FIG. <b>15</b></figref> shows flow charts of a method according to an example embodiment of the disclosure.</p><p id="p-0046" num="0045"><figref idref="DRAWINGS">FIG. <b>16</b></figref> shows a schematic illustration of a computer system in accordance with example embodiments of the disclosure.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0006" level="1">DETAILED DESCRIPTION OF THE DISCLOSURE</heading><p id="p-0047" num="0046">The invention will now be described in detail hereinafter with reference to the accompanied drawings, which form a part of the present invention, and which show, by way of illustration, specific examples of embodiments. Please note that the invention may, however, be embodied in a variety of different forms and, therefore, the covered or claimed subject matter is intended to be construed as not being limited to any of the embodiments to be set forth below. Please also note that the invention may be embodied as methods, devices, components, or systems. Accordingly, embodiments of the invention may, for example, take the form of hardware, software, firmware or any combination thereof.</p><p id="p-0048" num="0047">Throughout the specification and claims, terms may have nuanced meanings suggested or implied in context beyond an explicitly stated meaning. The phrase &#x201c;in one embodiment&#x201d; or &#x201c;in some embodiments&#x201d; as used herein does not necessarily refer to the same embodiment and the phrase &#x201c;in another embodiment&#x201d; or &#x201c;in other embodiments&#x201d; as used herein does not necessarily refer to a different embodiment. Likewise, the phrase &#x201c;in one implementation&#x201d; or &#x201c;in some implementations&#x201d; as used herein does not necessarily refer to the same implementation and the phrase &#x201c;in another implementation&#x201d; or &#x201c;in other implementations&#x201d; as used herein does not necessarily refer to a different implementation. It is intended, for example, that claimed subject matter includes combinations of exemplary embodiments/implementations in whole or in part.</p><p id="p-0049" num="0048">In general, terminology may be understood at least in part from usage in context. For example, terms, such as &#x201c;and&#x201d;, &#x201c;or&#x201d;, or &#x201c;and/or,&#x201d; as used herein may include a variety of meanings that may depend at least in part upon the context in which such terms are used. Typically, &#x201c;or&#x201d; if used to associate a list, such as A, B or C, is intended to mean A, B, and C, here used in the inclusive sense, as well as A, B or C, here used in the exclusive sense. In addition, the term &#x201c;one or more&#x201d; or &#x201c;at least one&#x201d; as used herein, depending at least in part upon context, may be used to describe any feature, structure, or characteristic in a singular sense or may be used to describe combinations of features, structures or characteristics in a plural sense. Similarly, terms, such as &#x201c;a&#x201d;, &#x201c;an&#x201d;, or &#x201c;the&#x201d;, again, may be understood to convey a singular usage or to convey a plural usage, depending at least in part upon context. In addition, the term &#x201c;based on&#x201d; or &#x201c;determined by&#x201d; may be understood as not necessarily intended to convey an exclusive set of factors and may, instead, allow for existence of additional factors not necessarily expressly described, again, depending at least in part on context.</p><p id="p-0050" num="0049"><figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates a simplified block diagram of a communication system (<b>300</b>) according to an embodiment of the present disclosure. The communication system (<b>300</b>) includes a plurality of terminal devices that can communicate with each other, via, for example, a network (<b>350</b>). For example, the communication system (<b>300</b>) includes a first pair of terminal devices (<b>310</b>) and (<b>320</b>) interconnected via the network (<b>350</b>). In the example of <figref idref="DRAWINGS">FIG. <b>3</b></figref>, the first pair of terminal devices (<b>310</b>) and (<b>320</b>) may perform unidirectional transmission of data. For example, the terminal device (<b>310</b>) may code video data (e.g., of a stream of video pictures that are captured by the terminal device (<b>310</b>)) for transmission to the other terminal device (<b>320</b>) via the network (<b>350</b>). The encoded video data can be transmitted in the form of one or more coded video bitstreams. The terminal device (<b>320</b>) may receive the coded video data from the network (<b>350</b>), decode the coded video data to recover the video pictures and display the video pictures according to the recovered video data. Unidirectional data transmission may be implemented in media serving applications and the like.</p><p id="p-0051" num="0050">In another example, the communication system (<b>300</b>) includes a second pair of terminal devices (<b>330</b>) and (<b>340</b>) that perform bidirectional transmission of coded video data that may be implemented, for example, during a videoconferencing application. For bidirectional transmission of data, in an example, each terminal device of the terminal devices (<b>330</b>) and (<b>340</b>) may code video data (e.g., of a stream of video pictures that are captured by the terminal device) for transmission to the other terminal device of the terminal devices (<b>330</b>) and (<b>340</b>) via the network (<b>350</b>). Each terminal device of the terminal devices (<b>330</b>) and (<b>340</b>) also may receive the coded video data transmitted by the other terminal device of the terminal devices (<b>330</b>) and (<b>340</b>), and may decode the coded video data to recover the video pictures and may display the video pictures at an accessible display device according to the recovered video data.</p><p id="p-0052" num="0051">In the example of <figref idref="DRAWINGS">FIG. <b>3</b></figref>, the terminal devices (<b>310</b>), (<b>320</b>), (<b>330</b>) and (<b>340</b>) may be implemented as servers, personal computers and smart phones but the applicability of the underlying principles of the present disclosure may not be so limited. Embodiments of the present disclosure may be implemented in desktop computers, laptop computers, tablet computers, media players, wearable computers, dedicated video conferencing equipment, and/or the like. The network (<b>350</b>) represents any number or types of networks that convey coded video data among the terminal devices (<b>310</b>), (<b>320</b>), (<b>330</b>) and (<b>340</b>), including for example wireline (wired) and/or wireless communication networks. The communication network (<b>350</b>) may exchange data in circuit-switched, packet-switched, and/or other types of channels. Representative networks include telecommunications networks, local area networks, wide area networks and/or the Internet. For the purposes of the present discussion, the architecture and topology of the network (<b>350</b>) may be immaterial to the operation of the present disclosure unless explicitly explained herein.</p><p id="p-0053" num="0052"><figref idref="DRAWINGS">FIG. <b>4</b></figref> illustrates, as an example for an application for the disclosed subject matter, a placement of a video encoder and a video decoder in a video streaming environment. The disclosed subject matter may be equally applicable to other video applications, including, for example, video conferencing, digital TV broadcasting, gaming, virtual reality, storage of compressed video on digital media including CD, DVD, memory stick and the like, and so on.</p><p id="p-0054" num="0053">A video streaming system may include a video capture subsystem (<b>413</b>) that can include a video source (<b>401</b>), e.g., a digital camera, for creating a stream of video pictures or images (<b>402</b>) that are uncompressed. In an example, the stream of video pictures (<b>402</b>) includes samples that are recorded by a digital camera of the video source <b>401</b>. The stream of video pictures (<b>402</b>), depicted as a bold line to emphasize a high data volume when compared to encoded video data (<b>404</b>) (or coded video bitstreams), can be processed by an electronic device (<b>420</b>) that includes a video encoder (<b>403</b>) coupled to the video source (<b>401</b>). The video encoder (<b>403</b>) can include hardware, software, or a combination thereof to enable or implement aspects of the disclosed subject matter as described in more detail below. The encoded video data (<b>404</b>) (or encoded video bitstream (<b>404</b>)), depicted as a thin line to emphasize a lower data volume when compared to the stream of uncompressed video pictures (<b>402</b>), can be stored on a streaming server (<b>405</b>) for future use or directly to downstream video devices (not shown). One or more streaming client subsystems, such as client subsystems (<b>406</b>) and (<b>408</b>) in <figref idref="DRAWINGS">FIG. <b>4</b></figref> can access the streaming server (<b>405</b>) to retrieve copies (<b>407</b>) and (<b>409</b>) of the encoded video data (<b>404</b>). A client subsystem (<b>406</b>) can include a video decoder (<b>410</b>), for example, in an electronic device (<b>430</b>). The video decoder (<b>410</b>) decodes the incoming copy (<b>407</b>) of the encoded video data and creates an outgoing stream of video pictures (<b>411</b>) that are uncompressed and that can be rendered on a display (<b>412</b>) (e.g., a display screen) or other rendering devices (not depicted). The video decoder <b>410</b> may be configured to perform some or all of the various functions described in this disclosure. In some streaming systems, the encoded video data (<b>404</b>), (<b>407</b>), and (<b>409</b>) (e.g., video bitstreams) can be encoded according to certain video coding/compression standards. Examples of those standards include ITU-T Recommendation H.265. In an example, a video coding standard under development is informally known as Versatile Video Coding (VVC). The disclosed subject matter may be used in the context of VVC, and other video coding standards.</p><p id="p-0055" num="0054">It is noted that the electronic devices (<b>420</b>) and (<b>430</b>) can include other components (not shown). For example, the electronic device (<b>420</b>) can include a video decoder (not shown) and the electronic device (<b>430</b>) can include a video encoder (not shown) as well.</p><p id="p-0056" num="0055"><figref idref="DRAWINGS">FIG. <b>5</b></figref> shows a block diagram of a video decoder (<b>510</b>) according to any embodiment of the present disclosure below. The video decoder (<b>510</b>) can be included in an electronic device (<b>530</b>). The electronic device (<b>530</b>) can include a receiver (<b>531</b>) (e.g., receiving circuitry). The video decoder (<b>510</b>) can be used in place of the video decoder (<b>410</b>) in the example of <figref idref="DRAWINGS">FIG. <b>4</b></figref>.</p><p id="p-0057" num="0056">The receiver (<b>531</b>) may receive one or more coded video sequences to be decoded by the video decoder (<b>510</b>). In the same or another embodiment, one coded video sequence may be decoded at a time, where the decoding of each coded video sequence is independent from other coded video sequences. Each video sequence may be associated with multiple video frames or images. The coded video sequence may be received from a channel (<b>501</b>), which may be a hardware/software link to a storage device which stores the encoded video data or a streaming source which transmits the encoded video data. The receiver (<b>531</b>) may receive the encoded video data with other data such as coded audio data and/or ancillary data streams, that may be forwarded to their respective processing circuitry (not depicted). The receiver (<b>531</b>) may separate the coded video sequence from the other data. To combat network jitter, a buffer memory (<b>515</b>) may be disposed in between the receiver (<b>531</b>) and an entropy decoder/parser (<b>520</b>) (&#x201c;parser (<b>520</b>)&#x201d; henceforth). In certain applications, the buffer memory (<b>515</b>) may be implemented as part of the video decoder (<b>510</b>). In other applications, it can be outside of and separate from the video decoder (<b>510</b>) (not depicted). In still other applications, there can be a buffer memory (not depicted) outside of the video decoder (<b>510</b>) for the purpose of, for example, combating network jitter, and there may be another additional buffer memory (<b>515</b>) inside the video decoder (<b>510</b>), for example to handle playback timing. When the receiver (<b>531</b>) is receiving data from a store/forward device of sufficient bandwidth and controllability, or from an isosynchronous network, the buffer memory (<b>515</b>) may not be needed, or can be small. For use on best-effort packet networks such as the Internet, the buffer memory (<b>515</b>) of sufficient size may be required, and its size can be comparatively large. Such buffer memory may be implemented with an adaptive size, and may at least partially be implemented in an operating system or similar elements (not depicted) outside of the video decoder (<b>510</b>).</p><p id="p-0058" num="0057">The video decoder (<b>510</b>) may include the parser (<b>520</b>) to reconstruct symbols (<b>521</b>) from the coded video sequence. Categories of those symbols include information used to manage operation of the video decoder (<b>510</b>), and potentially information to control a rendering device such as display (<b>512</b>) (e.g., a display screen) that may or may not an integral part of the electronic device (<b>530</b>) but can be coupled to the electronic device (<b>530</b>), as is shown in <figref idref="DRAWINGS">FIG. <b>5</b></figref>. The control information for the rendering device(s) may be in the form of Supplemental Enhancement Information (SEI messages) or Video Usability Information (VUI) parameter set fragments (not depicted). The parser (<b>520</b>) may parse/entropy-decode the coded video sequence that is received by the parser (<b>520</b>). The entropy coding of the coded video sequence can be in accordance with a video coding technology or standard, and can follow various principles, including variable length coding, Huffman coding, arithmetic coding with or without context sensitivity, and so forth. The parser (<b>520</b>) may extract from the coded video sequence, a set of subgroup parameters for at least one of the subgroups of pixels in the video decoder, based upon at least one parameter corresponding to the subgroups. The subgroups can include Groups of Pictures (GOPs), pictures, tiles, slices, macroblocks, Coding Units (CUs), blocks, Transform Units (TUs), Prediction Units (PUs) and so forth. The parser (<b>520</b>) may also extract from the coded video sequence information such as transform coefficients (e.g., Fourier transform coefficients), quantizer parameter values, motion vectors, and so forth.</p><p id="p-0059" num="0058">The parser (<b>520</b>) may perform an entropy decoding/parsing operation on the video sequence received from the buffer memory (<b>515</b>), so as to create symbols (<b>521</b>).</p><p id="p-0060" num="0059">Reconstruction of the symbols (<b>521</b>) can involve multiple different processing or functional units depending on the type of the coded video picture or parts thereof (such as: inter and intra picture, inter and intra block), and other factors. The units that are involved and how they are involved may be controlled by the subgroup control information that was parsed from the coded video sequence by the parser (<b>520</b>). The flow of such subgroup control information between the parser (<b>520</b>) and the multiple processing or functional units below is not depicted for simplicity.</p><p id="p-0061" num="0060">Beyond the functional blocks already mentioned, the video decoder (<b>510</b>) can be conceptually subdivided into a number of functional units as described below. In a practical implementation operating under commercial constraints, many of these functional units interact closely with each other and can, at least partly, be integrated with one another. However, for the purpose of describing the various functions of the disclosed subject matter with clarity, the conceptual subdivision into the functional units is adopted in the disclosure below.</p><p id="p-0062" num="0061">A first unit may include the scaler/inverse transform unit (<b>551</b>). The scaler/inverse transform unit (<b>551</b>) may receive a quantized transform coefficient as well as control information, including information indicating which type of inverse transform to use, block size, quantization factor/parameters, quantization scaling matrices, and the lie as symbol(s) (<b>521</b>) from the parser (<b>520</b>). The scaler/inverse transform unit (<b>551</b>) can output blocks comprising sample values that can be input into aggregator (<b>555</b>).</p><p id="p-0063" num="0062">In some cases, the output samples of the scaler/inverse transform (<b>551</b>) can pertain to an intra coded block, i.e., a block that does not use predictive information from previously reconstructed pictures, but can use predictive information from previously reconstructed parts of the current picture. Such predictive information can be provided by an intra picture prediction unit (<b>552</b>). In some cases, the intra picture prediction unit (<b>552</b>) may generate a block of the same size and shape of the block under reconstruction using surrounding block information that is already reconstructed and stored in the current picture buffer (<b>558</b>). The current picture buffer (<b>558</b>) buffers, for example, partly reconstructed current picture and/or fully reconstructed current picture. The aggregator (<b>555</b>), in some implementations, may add, on a per sample basis, the prediction information the intra prediction unit (<b>552</b>) has generated to the output sample information as provided by the scaler/inverse transform unit (<b>551</b>).</p><p id="p-0064" num="0063">In other cases, the output samples of the scaler/inverse transform unit (<b>551</b>) can pertain to an inter coded, and potentially motion compensated block. In such a case, a motion compensation prediction unit (<b>553</b>) can access reference picture memory (<b>557</b>) to fetch samples used for inter-picture prediction. After motion compensating the fetched samples in accordance with the symbols (<b>521</b>) pertaining to the block, these samples can be added by the aggregator (<b>555</b>) to the output of the scaler/inverse transform unit (<b>551</b>) (output of unit <b>551</b> may be referred to as the residual samples or residual signal) so as to generate output sample information. The addresses within the reference picture memory (<b>557</b>) from where the motion compensation prediction unit (<b>553</b>) fetches prediction samples can be controlled by motion vectors, available to the motion compensation prediction unit (<b>553</b>) in the form of symbols (<b>521</b>) that can have, for example X, Y components (shift), and reference picture components (time). Motion compensation may also include interpolation of sample values as fetched from the reference picture memory (<b>557</b>) when sub-sample exact motion vectors are in use, and may also be associated with motion vector prediction mechanisms, and so forth.</p><p id="p-0065" num="0064">The output samples of the aggregator (<b>555</b>) can be subject to various loop filtering techniques in the loop filter unit (<b>556</b>). Video compression technologies can include in-loop filter technologies that are controlled by parameters included in the coded video sequence (also referred to as coded video bitstream) and made available to the loop filter unit (<b>556</b>) as symbols (<b>521</b>) from the parser (<b>520</b>), but can also be responsive to meta-information obtained during the decoding of previous (in decoding order) parts of the coded picture or coded video sequence, as well as responsive to previously reconstructed and loop-filtered sample values. Several type of loop filters may be included as part of the loop filter unit <b>556</b> in various orders, as will be described in further detail below.</p><p id="p-0066" num="0065">The output of the loop filter unit (<b>556</b>) can be a sample stream that can be output to the rendering device (<b>512</b>) as well as stored in the reference picture memory (<b>557</b>) for use in future inter-picture prediction.</p><p id="p-0067" num="0066">Certain coded pictures, once fully reconstructed, can be used as reference pictures for future inter-picture prediction. For example, once a coded picture corresponding to a current picture is fully reconstructed and the coded picture has been identified as a reference picture (by, for example, the parser (<b>520</b>)), the current picture buffer (<b>558</b>) can become a part of the reference picture memory (<b>557</b>), and a fresh current picture buffer can be reallocated before commencing the reconstruction of the following coded picture.</p><p id="p-0068" num="0067">The video decoder (<b>510</b>) may perform decoding operations according to a predetermined video compression technology adopted in a standard, such as ITU-T Rec. H.265. The coded video sequence may conform to a syntax specified by the video compression technology or standard being used, in the sense that the coded video sequence adheres to both the syntax of the video compression technology or standard and the profiles as documented in the video compression technology or standard. Specifically, a profile can select certain tools from all the tools available in the video compression technology or standard as the only tools available for use under that profile. To be standard-compliant, the complexity of the coded video sequence may be within bounds as defined by the level of the video compression technology or standard. In some cases, levels restrict the maximum picture size, maximum frame rate, maximum reconstruction sample rate (measured in, for example megasamples per second), maximum reference picture size, and so on. Limits set by levels can, in some cases, be further restricted through Hypothetical Reference Decoder (HRD) specifications and metadata for HRD buffer management signaled in the coded video sequence.</p><p id="p-0069" num="0068">In some example embodiments, the receiver (<b>531</b>) may receive additional (redundant) data with the encoded video. The additional data may be included as part of the coded video sequence(s). The additional data may be used by the video decoder (<b>510</b>) to properly decode the data and/or to more accurately reconstruct the original video data. Additional data can be in the form of, for example, temporal, spatial, or signal noise ratio (SNR) enhancement layers, redundant slices, redundant pictures, forward error correction codes, and so on.</p><p id="p-0070" num="0069"><figref idref="DRAWINGS">FIG. <b>6</b></figref> shows a block diagram of a video encoder (<b>603</b>) according to an example embodiment of the present disclosure. The video encoder (<b>603</b>) may be included in an electronic device (<b>620</b>). The electronic device (<b>620</b>) may further include a transmitter (<b>640</b>) (e.g., transmitting circuitry). The video encoder (<b>603</b>) can be used in place of the video encoder (<b>403</b>) in the example of <figref idref="DRAWINGS">FIG. <b>4</b></figref>.</p><p id="p-0071" num="0070">The video encoder (<b>603</b>) may receive video samples from a video source (<b>601</b>) (that is not part of the electronic device (<b>620</b>) in the example of <figref idref="DRAWINGS">FIG. <b>6</b></figref>) that may capture video image(s) to be coded by the video encoder (<b>603</b>). In another example, the video source (<b>601</b>) may be implemented as a portion of the electronic device (<b>620</b>).</p><p id="p-0072" num="0071">The video source (<b>601</b>) may provide the source video sequence to be coded by the video encoder (<b>603</b>) in the form of a digital video sample stream that can be of any suitable bit depth (for example: 8 bit, 10 bit, 12 bit, . . . ), any colorspace (for example, BT.601 YCrCb, RGB, XYZ . . . ), and any suitable sampling structure (for example YCrCb 4:2:0, YCrCb 4:4:4). In a media serving system, the video source (<b>601</b>) may be a storage device capable of storing previously prepared video. In a videoconferencing system, the video source (<b>601</b>) may be a camera that captures local image information as a video sequence. Video data may be provided as a plurality of individual pictures or images that impart motion when viewed in sequence. The pictures themselves may be organized as a spatial array of pixels, wherein each pixel can comprise one or more samples depending on the sampling structure, color space, and the like being in use. A person having ordinary skill in the art can readily understand the relationship between pixels and samples. The description below focuses on samples.</p><p id="p-0073" num="0072">According to some example embodiments, the video encoder (<b>603</b>) may code and compress the pictures of the source video sequence into a coded video sequence (<b>643</b>) in real time or under any other time constraints as required by the application. Enforcing appropriate coding speed constitutes one function of a controller (<b>650</b>). In some embodiments, the controller (<b>650</b>) may be functionally coupled to and control other functional units as described below. The coupling is not depicted for simplicity. Parameters set by the controller (<b>650</b>) can include rate control related parameters (picture skip, quantizer, lambda value of rate-distortion optimization techniques, . . . ), picture size, group of pictures (GOP) layout, maximum motion vector search range, and the like. The controller (<b>650</b>) can be configured to have other suitable functions that pertain to the video encoder (<b>603</b>) optimized for a certain system design.</p><p id="p-0074" num="0073">In some example embodiments, the video encoder (<b>603</b>) may be configured to operate in a coding loop. As an oversimplified description, in an example, the coding loop can include a source coder (<b>630</b>) (e.g., responsible for creating symbols, such as a symbol stream, based on an input picture to be coded, and a reference picture(s)), and a (local) decoder (<b>633</b>) embedded in the video encoder (<b>603</b>). The decoder (<b>633</b>) reconstructs the symbols to create the sample data in a similar manner as a (remote) decoder would create even though the embedded decoder <b>633</b> process coded video steam by the source coder <b>630</b> without entropy coding (as any compression between symbols and coded video bitstream in entropy coding may be lossless in the video compression technologies considered in the disclosed subject matter). The reconstructed sample stream (sample data) is input to the reference picture memory (<b>634</b>). As the decoding of a symbol stream leads to bit-exact results independent of decoder location (local or remote), the content in the reference picture memory (<b>634</b>) is also bit exact between the local encoder and remote encoder. In other words, the prediction part of an encoder &#x201c;sees&#x201d; as reference picture samples exactly the same sample values as a decoder would &#x201c;see&#x201d; when using prediction during decoding. This fundamental principle of reference picture synchronicity (and resulting drift, if synchronicity cannot be maintained, for example because of channel errors) is used to improve coding quality.</p><p id="p-0075" num="0074">The operation of the &#x201c;local&#x201d; decoder (<b>633</b>) can be the same as of a &#x201c;remote&#x201d; decoder, such as the video decoder (<b>510</b>), which has already been described in detail above in conjunction with <figref idref="DRAWINGS">FIG. <b>5</b></figref>. Briefly referring also to <figref idref="DRAWINGS">FIG. <b>5</b></figref>, however, as symbols are available and encoding/decoding of symbols to a coded video sequence by an entropy coder (<b>645</b>) and the parser (<b>520</b>) can be lossless, the entropy decoding parts of the video decoder (<b>510</b>), including the buffer memory (<b>515</b>), and parser (<b>520</b>) may not be fully implemented in the local decoder (<b>633</b>) in the encoder.</p><p id="p-0076" num="0075">An observation that can be made at this point is that any decoder technology except the parsing/entropy decoding that may only be present in a decoder also may necessarily need to be present, in substantially identical functional form, in a corresponding encoder. For this reason, the disclosed subject matter may at times focus on decoder operation, which allies to the decoding portion of the encoder. The description of encoder technologies can thus be abbreviated as they are the inverse of the comprehensively described decoder technologies. Only in certain areas or aspects a more detail description of the encoder is provided below.</p><p id="p-0077" num="0076">During operation in some example implementations, the source coder (<b>630</b>) may perform motion compensated predictive coding, which codes an input picture predictively with reference to one or more previously coded picture from the video sequence that were designated as &#x201c;reference pictures.&#x201d; In this manner, the coding engine (<b>632</b>) codes differences (or residue) in the color channels between pixel blocks of an input picture and pixel blocks of reference picture(s) that may be selected as prediction reference(s) to the input picture.</p><p id="p-0078" num="0077">The local video decoder (<b>633</b>) may decode coded video data of pictures that may be designated as reference pictures, based on symbols created by the source coder (<b>630</b>). Operations of the coding engine (<b>632</b>) may advantageously be lossy processes. When the coded video data may be decoded at a video decoder (not shown in <figref idref="DRAWINGS">FIG. <b>6</b></figref>), the reconstructed video sequence typically may be a replica of the source video sequence with some errors. The local video decoder (<b>633</b>) replicates decoding processes that may be performed by the video decoder on reference pictures and may cause reconstructed reference pictures to be stored in the reference picture cache (<b>634</b>). In this manner, the video encoder (<b>603</b>) may store copies of reconstructed reference pictures locally that have common content as the reconstructed reference pictures that will be obtained by a far-end (remote) video decoder (absent transmission errors).</p><p id="p-0079" num="0078">The predictor (<b>635</b>) may perform prediction searches for the coding engine (<b>632</b>). That is, for a new picture to be coded, the predictor (<b>635</b>) may search the reference picture memory (<b>634</b>) for sample data (as candidate reference pixel blocks) or certain metadata such as reference picture motion vectors, block shapes, and so on, that may serve as an appropriate prediction reference for the new pictures. The predictor (<b>635</b>) may operate on a sample block-by-pixel block basis to find appropriate prediction references. In some cases, as determined by search results obtained by the predictor (<b>635</b>), an input picture may have prediction references drawn from multiple reference pictures stored in the reference picture memory (<b>634</b>).</p><p id="p-0080" num="0079">The controller (<b>650</b>) may manage coding operations of the source coder (<b>630</b>), including, for example, setting of parameters and subgroup parameters used for encoding the video data.</p><p id="p-0081" num="0080">Output of all aforementioned functional units may be subjected to entropy coding in the entropy coder (<b>645</b>). The entropy coder (<b>645</b>) translates the symbols as generated by the various functional units into a coded video sequence, by lossless compression of the symbols according to technologies such as Huffman coding, variable length coding, arithmetic coding, and so forth.</p><p id="p-0082" num="0081">The transmitter (<b>640</b>) may buffer the coded video sequence(s) as created by the entropy coder (<b>645</b>) to prepare for transmission via a communication channel (<b>660</b>), which may be a hardware/software link to a storage device which would store the encoded video data. The transmitter (<b>640</b>) may merge coded video data from the video coder (<b>603</b>) with other data to be transmitted, for example, coded audio data and/or ancillary data streams (sources not shown).</p><p id="p-0083" num="0082">The controller (<b>650</b>) may manage operation of the video encoder (<b>603</b>). During coding, the controller (<b>650</b>) may assign to each coded picture a certain coded picture type, which may affect the coding techniques that may be applied to the respective picture. For example, pictures often may be assigned as one of the following picture types:</p><p id="p-0084" num="0083">An Intra Picture (I picture) may be one that may be coded and decoded without using any other picture in the sequence as a source of prediction. Some video codecs allow for different types of intra pictures, including, for example Independent Decoder Refresh (&#x201c;IDR&#x201d;) Pictures. A person having ordinary skill in the art is aware of those variants of I pictures and their respective applications and features.</p><p id="p-0085" num="0084">A predictive picture (P picture) may be one that may be coded and decoded using intra prediction or inter prediction using at most one motion vector and reference index to predict the sample values of each block.</p><p id="p-0086" num="0085">A bi-directionally predictive picture (B Picture) may be one that may be coded and decoded using intra prediction or inter prediction using at most two motion vectors and reference indices to predict the sample values of each block. Similarly, multiple-predictive pictures can use more than two reference pictures and associated metadata for the reconstruction of a single block.</p><p id="p-0087" num="0086">Source pictures commonly may be subdivided spatially into a plurality of sample coding blocks (for example, blocks of 4&#xd7;4, 8&#xd7;8, 4&#xd7;8, or 16&#xd7;16 samples each) and coded on a block-by-block basis. Blocks may be coded predictively with reference to other (already coded) blocks as determined by the coding assignment applied to the blocks' respective pictures. For example, blocks of I pictures may be coded non-predictively or they may be coded predictively with reference to already coded blocks of the same picture (spatial prediction or intra prediction). Pixel blocks of P pictures may be coded predictively, via spatial prediction or via temporal prediction with reference to one previously coded reference picture. Blocks of B pictures may be coded predictively, via spatial prediction or via temporal prediction with reference to one or two previously coded reference pictures. The source pictures or the intermediate processed pictures may be subdivided into other types of blocks for other purposes. The division of coding blocks and the other types of blocks may or may not follow the same manner, as described in further detail below.</p><p id="p-0088" num="0087">The video encoder (<b>603</b>) may perform coding operations according to a predetermined video coding technology or standard, such as ITU-T Rec. H.265. In its operation, the video encoder (<b>603</b>) may perform various compression operations, including predictive coding operations that exploit temporal and spatial redundancies in the input video sequence. The coded video data may accordingly conform to a syntax specified by the video coding technology or standard being used.</p><p id="p-0089" num="0088">In some example embodiments, the transmitter (<b>640</b>) may transmit additional data with the encoded video. The source coder (<b>630</b>) may include such data as part of the coded video sequence. The additional data may comprise temporal/spatial/SNR enhancement layers, other forms of redundant data such as redundant pictures and slices, SEI messages, VUI parameter set fragments, and so on.</p><p id="p-0090" num="0089">A video may be captured as a plurality of source pictures (video pictures) in a temporal sequence. Intra-picture prediction (often abbreviated to intra prediction) utilizes spatial correlation in a given picture, and inter-picture prediction utilizes temporal or other correlation between the pictures. For example, a specific picture under encoding/decoding, which is referred to as a current picture, may be partitioned into blocks. A block in the current picture, when similar to a reference block in a previously coded and still buffered reference picture in the video, may be coded by a vector that is referred to as a motion vector. The motion vector points to the reference block in the reference picture, and can have a third dimension identifying the reference picture, in case multiple reference pictures are in use.</p><p id="p-0091" num="0090">In some example embodiments, a bi-prediction technique can be used for inter-picture prediction. According to such bi-prediction technique, two reference pictures, such as a first reference picture and a second reference picture that both proceed the current picture in the video in decoding order (but may be in the past or future, respectively, in display order) are used. A block in the current picture can be coded by a first motion vector that points to a first reference block in the first reference picture, and a second motion vector that points to a second reference block in the second reference picture. The block can be jointly predicted by a combination of the first reference block and the second reference block.</p><p id="p-0092" num="0091">Further, a merge mode technique may be used in the inter-picture prediction to improve coding efficiency.</p><p id="p-0093" num="0092">According to some example embodiments of the disclosure, predictions, such as inter-picture predictions and intra-picture predictions are performed in the unit of blocks. For example, a picture in a sequence of video pictures is partitioned into coding tree units (CTU) for compression, the CTUs in a picture may have the same size, such as 64&#xd7;64 pixels, 32&#xd7;32 pixels, or 16&#xd7;16 pixels. In general, a CTU may include three parallel coding tree blocks (CTBs): one luma CTB and two chroma CTBs. Each CTU can be recursively quadtree split into one or multiple coding units (CUs). For example, a CTU of 64&#xd7;64 pixels can be split into one CU of 64&#xd7;64 pixels, or 4 CUs of 32&#xd7;32 pixels. Each of the one or more of the 32&#xd7;32 block may be further split into 4 CUs of 16&#xd7;16 pixels. In some example embodiments, each CU may be analyzed during encoding to determine a prediction type for the CU among various prediction types such as an inter prediction type or an intra prediction type. The CU may be split into one or more prediction units (PUs) depending on the temporal and/or spatial predictability. Generally, each PU includes a luma prediction block (PB), and two chroma PBs. In an embodiment, a prediction operation in coding (encoding/decoding) is performed in the unit of a prediction block. The split of a CU into PU (or PBs of different color channels) may be performed in various spatial pattern. A luma or chroma PB, for example, may include a matrix of values (e.g., luma values) for samples, such as 8&#xd7;8 pixels, 16&#xd7;16 pixels, 8&#xd7;16 pixels, 16&#xd7;8 samples, and the like.</p><p id="p-0094" num="0093"><figref idref="DRAWINGS">FIG. <b>7</b></figref> shows a diagram of a video encoder (<b>703</b>) according to another example embodiment of the disclosure. The video encoder (<b>703</b>) is configured to receive a processing block (e.g., a prediction block) of sample values within a current video picture in a sequence of video pictures, and encode the processing block into a coded picture that is part of a coded video sequence. The example video encoder (<b>703</b>) may be used in place of the video encoder (<b>403</b>) in the <figref idref="DRAWINGS">FIG. <b>4</b></figref> example.</p><p id="p-0095" num="0094">For example, the video encoder (<b>703</b>) receives a matrix of sample values for a processing block, such as a prediction block of 8&#xd7;8 samples, and the like. The video encoder (<b>703</b>) then determines whether the processing block is best coded using intra mode, inter mode, or bi-prediction mode using, for example, rate-distortion optimization (RDO). When the processing block is determined to be coded in intra mode, the video encoder (<b>703</b>) may use an intra prediction technique to encode the processing block into the coded picture; and when the processing block is determined to be coded in inter mode or bi-prediction mode, the video encoder (<b>703</b>) may use an inter prediction or bi-prediction technique, respectively, to encode the processing block into the coded picture. In some example embodiments, a merge mode may be used as a submode of the inter picture prediction where the motion vector is derived from one or more motion vector predictors without the benefit of a coded motion vector component outside the predictors. In some other example embodiments, a motion vector component applicable to the subject block may be present. Accordingly, the video encoder (<b>703</b>) may include components not explicitly shown in <figref idref="DRAWINGS">FIG. <b>7</b></figref>, such as a mode decision module, to determine the perdition mode of the processing blocks.</p><p id="p-0096" num="0095">In the example of <figref idref="DRAWINGS">FIG. <b>7</b></figref>, the video encoder (<b>703</b>) includes an inter encoder (<b>730</b>), an intra encoder (<b>722</b>), a residue calculator (<b>723</b>), a switch (<b>726</b>), a residue encoder (<b>724</b>), a general controller (<b>721</b>), and an entropy encoder (<b>725</b>) coupled together as shown in the example arrangement in <figref idref="DRAWINGS">FIG. <b>7</b></figref>.</p><p id="p-0097" num="0096">The inter encoder (<b>730</b>) is configured to receive the samples of the current block (e.g., a processing block), compare the block to one or more reference blocks in reference pictures (e.g., blocks in previous pictures and later pictures in display order), generate inter prediction information (e.g., description of redundant information according to inter encoding technique, motion vectors, merge mode information), and calculate inter prediction results (e.g., predicted block) based on the inter prediction information using any suitable technique. In some examples, the reference pictures are decoded reference pictures that are decoded based on the encoded video information using the decoding unit <b>633</b> embedded in the example encoder <b>620</b> of <figref idref="DRAWINGS">FIG. <b>6</b></figref> (shown as residual decoder <b>728</b> of <figref idref="DRAWINGS">FIG. <b>7</b></figref>, as described in further detail below).</p><p id="p-0098" num="0097">The intra encoder (<b>722</b>) is configured to receive the samples of the current block (e.g., a processing block), compare the block to blocks already coded in the same picture, and generate quantized coefficients after transform, and in some cases also to generate intra prediction information (e.g., an intra prediction direction information according to one or more intra encoding techniques). The intra encoder (<b>722</b>) may calculates intra prediction results (e.g., predicted block) based on the intra prediction information and reference blocks in the same picture.</p><p id="p-0099" num="0098">The general controller (<b>721</b>) may be configured to determine general control data and control other components of the video encoder (<b>703</b>) based on the general control data. In an example, the general controller (<b>721</b>) determines the prediction mode of the block, and provides a control signal to the switch (<b>726</b>) based on the prediction mode. For example, when the prediction mode is the intra mode, the general controller (<b>721</b>) controls the switch (<b>726</b>) to select the intra mode result for use by the residue calculator (<b>723</b>), and controls the entropy encoder (<b>725</b>) to select the intra prediction information and include the intra prediction information in the bitstream; and when the predication mode for the block is the inter mode, the general controller (<b>721</b>) controls the switch (<b>726</b>) to select the inter prediction result for use by the residue calculator (<b>723</b>), and controls the entropy encoder (<b>725</b>) to select the inter prediction information and include the inter prediction information in the bitstream.</p><p id="p-0100" num="0099">The residue calculator (<b>723</b>) may be configured to calculate a difference (residue data) between the received block and prediction results for the block selected from the intra encoder (<b>722</b>) or the inter encoder (<b>730</b>). The residue encoder (<b>724</b>) may be configured to encode the residue data to generate transform coefficients. For example, the residue encoder (<b>724</b>) may be configured to convert the residue data from a spatial domain to a frequency domain to generate the transform coefficients. The transform coefficients are then subject to quantization processing to obtain quantized transform coefficients. In various example embodiments, the video encoder (<b>703</b>) also includes a residue decoder (<b>728</b>). The residue decoder (<b>728</b>) is configured to perform inverse-transform, and generate the decoded residue data. The decoded residue data can be suitably used by the intra encoder (<b>722</b>) and the inter encoder (<b>730</b>). For example, the inter encoder (<b>730</b>) can generate decoded blocks based on the decoded residue data and inter prediction information, and the intra encoder (<b>722</b>) can generate decoded blocks based on the decoded residue data and the intra prediction information. The decoded blocks are suitably processed to generate decoded pictures and the decoded pictures can be buffered in a memory circuit (not shown) and used as reference pictures.</p><p id="p-0101" num="0100">The entropy encoder (<b>725</b>) may be configured to format the bitstream to include the encoded block and perform entropy coding. The entropy encoder (<b>725</b>) is configured to include in the bitstream various information. For example, the entropy encoder (<b>725</b>) may be configured to include the general control data, the selected prediction information (e.g., intra prediction information or inter prediction information), the residue information, and other suitable information in the bitstream. When coding a block in the merge submode of either inter mode or bi-prediction mode, there may be no residue information.</p><p id="p-0102" num="0101"><figref idref="DRAWINGS">FIG. <b>8</b></figref> shows a diagram of an example video decoder (<b>810</b>) according to another embodiment of the disclosure. The video decoder (<b>810</b>) is configured to receive coded pictures that are part of a coded video sequence, and decode the coded pictures to generate reconstructed pictures. In an example, the video decoder (<b>810</b>) may be used in place of the video decoder (<b>410</b>) in the example of <figref idref="DRAWINGS">FIG. <b>4</b></figref>.</p><p id="p-0103" num="0102">In the example of <figref idref="DRAWINGS">FIG. <b>8</b></figref>, the video decoder (<b>810</b>) includes an entropy decoder (<b>871</b>), an inter decoder (<b>880</b>), a residue decoder (<b>873</b>), a reconstruction module (<b>874</b>), and an intra decoder (<b>872</b>) coupled together as shown in the example arrangement of <figref idref="DRAWINGS">FIG. <b>8</b></figref>.</p><p id="p-0104" num="0103">The entropy decoder (<b>871</b>) can be configured to reconstruct, from the coded picture, certain symbols that represent the syntax elements of which the coded picture is made up. Such symbols can include, for example, the mode in which a block is coded (e.g., intra mode, inter mode, bi-predicted mode, merge submode or another submode), prediction information (e.g., intra prediction information or inter prediction information) that can identify certain sample or metadata used for prediction by the intra decoder (<b>872</b>) or the inter decoder (<b>880</b>), residual information in the form of, for example, quantized transform coefficients, and the like. In an example, when the prediction mode is the inter or bi-predicted mode, the inter prediction information is provided to the inter decoder (<b>880</b>); and when the prediction type is the intra prediction type, the intra prediction information is provided to the intra decoder (<b>872</b>). The residual information can be subject to inverse quantization and is provided to the residue decoder (<b>873</b>).</p><p id="p-0105" num="0104">The inter decoder (<b>880</b>) may be configured to receive the inter prediction information, and generate inter prediction results based on the inter prediction information.</p><p id="p-0106" num="0105">The intra decoder (<b>872</b>) may be configured to receive the intra prediction information, and generate prediction results based on the intra prediction information.</p><p id="p-0107" num="0106">The residue decoder (<b>873</b>) may be configured to perform inverse quantization to extract de-quantized transform coefficients, and process the de-quantized transform coefficients to convert the residual from the frequency domain to the spatial domain. The residue decoder (<b>873</b>) may also utilize certain control information (to include the Quantizer Parameter (QP)) which may be provided by the entropy decoder (<b>871</b>) (data path not depicted as this may be low data volume control information only).</p><p id="p-0108" num="0107">The reconstruction module (<b>874</b>) may be configured to combine, in the spatial domain, the residual as output by the residue decoder (<b>873</b>) and the prediction results (as output by the inter or intra prediction modules as the case may be) to form a reconstructed block forming part of the reconstructed picture as part of the reconstructed video. It is noted that other suitable operations, such as a deblocking operation and the like, may also be performed to improve the visual quality.</p><p id="p-0109" num="0108">It is noted that the video encoders (<b>403</b>), (<b>603</b>), and (<b>703</b>), and the video decoders (<b>410</b>), (<b>510</b>), and (<b>810</b>) can be implemented using any suitable technique. In some example embodiments, the video encoders (<b>403</b>), (<b>603</b>), and (<b>703</b>), and the video decoders (<b>410</b>), (<b>510</b>), and (<b>810</b>) can be implemented using one or more integrated circuits. In another embodiment, the video encoders (<b>403</b>), (<b>603</b>), and (<b>603</b>), and the video decoders (<b>410</b>), (<b>510</b>), and (<b>810</b>) can be implemented using one or more processors that execute software instructions.</p><p id="p-0110" num="0109">Returning to the intra prediction process, in which samples in a block (e.g., a luma or chroma prediction block, or coding block if not further split into prediction blocks) is predicted by samples of neighboring, next neighboring, or other line or lines, or the combination thereof, to generate a prediction block. The residual between the actual block being coded and the prediction block may then be processed via transform followed by quantization. Various intra prediction modes may be made available and parameters related to intra mode selection and other parameters may be signaled in the bitstream. The various intra prediction modes, for example, may pertain to line position or positions for predicting samples, directions along which prediction samples are selected from predicting line or lines, and other special intra prediction modes.</p><p id="p-0111" num="0110">For example, a set of intra prediction modes (interchangeably referred to as &#x201c;intra modes&#x201d;) may include a predefined number of directional intra prediction modes. As described above in relation to the example implementation of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, these intra prediction modes may correspond to a predefined number of directions along which out-of-block samples are selected as prediction for samples being predicted in a particular block. In another particular example implementation, eight (8) main directional modes corresponding to angles from 45 to 207 degrees to the horizontal axis may be supported and predefined.</p><p id="p-0112" num="0111">In some other implementations of intra prediction, to further exploit more varieties of spatial redundancy in directional textures, directional intra modes may be further extended to an angle set with finer granularity. For example, the 8-angle implementation above may be configured to provide eight nominal angles, referred to as V_PRED, H_PRED, D45_PRED, D135_PRED, D113_PRED, D157_PRED, D203_PRED, and D67_PRED, as illustrated in <figref idref="DRAWINGS">FIG. <b>9</b></figref>, and for each nominal angle, a predefined number (e.g., 7) of finer angles may be added. With such an extension, a larger total number (e.g., 56 in this example) of directional angles may be available for intra prediction, corresponding to the same number of predefined directional intra modes. A prediction angle may be represented by a nominal intra angle plus an angle delta. For the particular example above with 7 finer angular directions for each nominal angle, the angle delta may be &#x2212;3&#x2dc;3 multiplies a step size of 3 degrees.</p><p id="p-0113" num="0112">The above directional intra prediction may also be referred as single directional intra prediction, which is different from bi-directional intra prediction (also referred as intra bi-prediction) described in later part of the present disclosure.</p><p id="p-0114" num="0113">In some implementations, alternative or in addition to the direction intra modes above, a predefined number of non-directional intra prediction modes may also be predefined and made available. For example, 5 non-direction intra modes referred to as smooth intra prediction modes may be specified. These non-directional intra mode prediction modes may be specifically referred to as DC, PAETH, SMOOTH, SMOOTH_V, and SMOOTH_H intra modes. Prediction of samples of a particular block under these example non-directional modes are illustrated in <figref idref="DRAWINGS">FIG. <b>10</b></figref>. As an example, <figref idref="DRAWINGS">FIG. <b>10</b></figref> shows a 4&#xd7;4 block <b>1002</b> being predicted by samples from a top neighboring line and/or left neighboring line. A particular sample <b>1010</b> in block <b>1002</b> may correspond to directly top sample <b>1004</b> of the sample <b>1010</b> in the top neighboring line of block <b>1002</b>, a top-left sample <b>1006</b> of the sample <b>1010</b> as the intersection of the top and left neighboring lines, and a directly left sample <b>1008</b> of the sample <b>1010</b> in the left neighboring line of block <b>1002</b>. For the example DC intra prediction mode, an average of the left and above neighboring samples <b>1008</b> and <b>1004</b> may be used as the predictor of the sample <b>1010</b>. For the example PAETH intra prediction mode, the top, left, and top-left reference samples <b>1004</b>, <b>1008</b>, and <b>1006</b> may be fetched, and then whichever value among these three reference samples that is the closest to (top+left&#x2014;topleft) may be set as the predictor for the sample <b>1010</b>. For the example SMOOTH_V intra prediction mode, the sample <b>1010</b> may be predicted by a quadratic interpolation in vertical direction of the top-left neighboring sample <b>1006</b> and the left neighboring sample <b>1008</b>. For the example SMOOTH_H intra prediction mode, the sample <b>1010</b> may be predicted by a quadratic interpolation in horizontal direction of the top-left neighboring sample <b>1006</b> and the top neighboring sample <b>1004</b>. For the example SMOOTH intra prediction mode, the sample <b>1010</b> may be predicted by an average of the quadratic interpolations in the vertical and the horizontal directions. The non-directional intra mode implementations above are merely illustrated as a non-limiting example. Other neighboring lines, and other non-directional selection of samples, and manners of combining predicting samples for predicting a particular sample in a prediction block are also contemplated.</p><p id="p-0115" num="0114">Selection of a particular intra prediction mode by the encoder from the directional or non-directional modes above at various coding levels (picture, slice, block, unit, etc.) may be signaled in the bitstream. In some example implementations, the exemplary 8 nominal directional modes together with 5 non-angular smooth modes (a total of 13 options) may be signaled first. Then if the signaled mode is one of the 8 nominal angular intra modes, an index is further signaled to indicate the selected angle delta to the corresponding signaled nominal angle. In some other example implementations, all intra prediction modes may be indexed all together (e.g., 56 directional modes plus 5 non-directional modes to yield 61 intra prediction modes) for signaling.</p><p id="p-0116" num="0115">In some example implementations, the example 56 or other number of directional intra prediction modes may be implemented with a unified directional predictor that projects each sample of a block to a reference sub-sample location and interpolates the reference sample by a 2-tap bilinear filter.</p><p id="p-0117" num="0116">In some implementations, to capture decaying spatial correlation with references on the edges, additional filter modes referred to as FILTER INTRA modes may be designed. For these modes, predicted samples within the block in addition to out-of-block samples may be used as intra prediction reference samples for some patches within the block. These modes, for example, may be predefined and made available to intra prediction for at least luma blocks (or only luma blocks). A predefined number (e.g., five) of filter intra modes may be pre-designed, each represented by a set of n-tap filters (e.g., 7-tap filters) reflecting correlation between samples in, for example, a 4&#xd7;2 patch and n neighbors adjacent to it. In other words, the weighting factors for an n-tap filter may be position dependent. Taking an 8&#xd7;8 block, 4&#xd7;2 patch, and 7-tap filtering as an example, as shown in <figref idref="DRAWINGS">FIG. <b>11</b></figref>, the 8&#xd7;8 block <b>1102</b> may be split into eight 4&#xd7;2 patches. These patches are indicated by B0, B1, B1, B3, B4, B5, B6, and B7 in <figref idref="DRAWINGS">FIG. <b>11</b></figref>. For each patch, its 7 neighbors, indicated by R0&#x2dc;R7 in <figref idref="DRAWINGS">FIG. <b>11</b></figref>, may be used to predict the samples in a current patch. For patch B0, all the neighbors may have been already reconstructed. But for other patches, some of the neighbors are in the current block and thus may not have been reconstructed, then the predicted values of immediate neighbors are used as the reference. For example, all the neighbors of patch B7 as indicated in <figref idref="DRAWINGS">FIG. <b>11</b></figref> are not reconstructed, so the prediction samples of neighbors, for example a portion of B4, B5, and/or B6, are used instead.</p><p id="p-0118" num="0117">In some implementation of intra prediction, one color component may be predicted using one or more other color components. A color component may be any one of components in YCrCb, RGB, XYZ color space and the like. For example, a prediction of chroma component (e.g., chroma block) from luma component (e.g., luma reference samples), referred to as Chroma from Luma, or CfL), may be implemented. In some example implementations, cross-color prediction many only be allowed from luma to chroma. For example, a chroma sample in a chroma block may be modeled as a linear function of coincident reconstructed luma samples. The CfL prediction may be implemented as follows:</p><p id="p-0119" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>CfL</i>(&#x3b1;)=&#x3b1;&#xd7;<i>L</i><sup>AC</sup><i>+DC</i>&#x2003;&#x2003;(1)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0120" num="0118">where L<sup>AC </sup>denotes an AC contribution of luma component, a denotes a parameter of the linear model, and DC denotes a DC contribution of the chroma component. The AC components, for example is obtained for each samples of the block whereas the DC component is obtained for the entire block. To be specific, the reconstructed luma samples may be subsampled into the chroma resolution, and then the average luma value (DC of luma) may be subtracted from each luma value to form the AC contribution in luma. The AC contribution of Luma is then used in the linear mode of Eq. (1) to predict the AC values of the chroma component. To approximate or predict chroma AC component from the luma AC contribution, instead of requiring the decoder to calculate the scaling parameters, an example CfL implementation may determine the parameter a based on the original chroma samples and signal them in the bitstream. This reduces decoder complexity and yields more precise predictions. As for the DC contribution of the chroma component, it may be computed using intra DC mode within the chroma component in some example implementations.</p><p id="p-0121" num="0119">Turning back to intra prediction, in some example implementations, prediction of samples in a coding block or prediction block may be based on one of a set of reference lines. In other words, rather than always using a nearest neighboring line (e.g., the immediate top neighboring line or the immediate left neighboring line of the prediction block as illustrated in <figref idref="DRAWINGS">FIG. <b>1</b></figref> above), multiple reference lines may be provided as options for selection for intra prediction. Such intra prediction implementations may be referred to as Multiple Reference Line Selection (MRLS). In these implementations, an encoder decides and signals which reference line of a plurality of reference lines is used to generate the intra predictor. At the decoder side, after parsing the reference line index, the intra prediction of current intra-prediction block can be generated by identifying the reconstructed reference samples by looking up the specified reference line according to the intra prediction mode (such the directional, non-directional, and other intra-prediction modes). In some implementations, a reference line index may be signaled in the coding block level and only one of the multiple reference lines may be selected and used for intra prediction of one coding block. In some examples, more than one reference lines may be selected together for intra-prediction. For example, the more than one reference lines may be combined, averaged, interpolated or in any other manner, with or without weight, to generate the prediction. In some example implementations, MRLS may only be applied to luma component and may not be applied to chroma component(s).</p><p id="p-0122" num="0120">In <figref idref="DRAWINGS">FIG. <b>12</b></figref>, an example of 4 reference-line MRLS is depicted. As shown in the example of <figref idref="DRAWINGS">FIG. <b>12</b></figref>, the intra-coding block <b>1202</b> may be predicted based on one of the 4 horizontal reference lines <b>1204</b>, <b>1206</b>, <b>1208</b>, and <b>1210</b> and <b>4</b> vertical reference lines <b>1212</b>, <b>1214</b>, <b>1216</b>, and <b>1218</b>. Among these reference lines, <b>1210</b> and <b>1218</b> are the immediate neighboring reference lines. The reference lines may be indexed according to their distance from the coding block. For example, reference lines <b>1210</b> and <b>1218</b> may be referred to as zero reference line whereas the other reference lines may be referred to as non-zero reference lines. Specifically, reference lines <b>1208</b> and <b>1216</b> may be reference as 1<sup>st </sup>reference lines; reference lines <b>1206</b> and <b>1214</b> may be reference as 2nd reference lines; and reference lines <b>1204</b> and <b>1212</b> may be reference as 3rd reference lines.</p><p id="p-0123" num="0121">In some embodiments, to improve video encoding/decoding performance, an offset-based refinement for intra prediction (ORIP) may be used after generating an intra prediction samples. When ORIP is applied, the prediction samples are refined by adding an offset value.</p><p id="p-0124" num="0122">As shown in <figref idref="DRAWINGS">FIG. <b>13</b></figref>, an intra prediction (<b>1330</b>) is performed based on reference samples. The reference samples may include samples from one or more left reference lines (<b>1312</b>) and/or one or more top reference lines (<b>1310</b>). The offset-based refinement for intra prediction (ORIP) (<b>1350</b>) may generate an offset value using neighboring reference samples. In some implementations, the neighboring reference samples for ORIP may be the same set as the reference samples for intra prediction. In some other implementations, the neighboring reference samples for ORIP may be different set as the reference samples for intra prediction.</p><p id="p-0125" num="0123">In some implementations referring to <figref idref="DRAWINGS">FIG. <b>14</b>A</figref> and <figref idref="DRAWINGS">FIG. <b>14</b>B</figref>, ORIP may be performed in 4&#xd7;4 sub-block level. For each 4&#xd7;4 sub-block (<b>1471</b>, <b>1472</b>, <b>1473</b>, and/or <b>1474</b>), the offsets are generated from its neighboring samples. For example, for a first sub-block (<b>1471</b>), the offsets are generated from its top neighboring samples (P1, P2, P3, and P4 in <b>1420</b>), left neighboring samples (P5, P6, P7, and P8 in <b>1410</b>), and/or a top-left neighboring sample (P0) (<b>1401</b>). In some implementations, top neighboring samples may include both the top neighboring samples (P1, P2, P3, and P4 in <b>1420</b>) and the top-left neighboring sample (P0) (<b>1401</b>). In some other implementations, left neighboring samples may include both the left neighboring samples (P5, P6, P7, and P8 in <b>1410</b>) and the top-left neighboring sample (P0) (<b>1401</b>).</p><p id="p-0126" num="0124">The first sub-block (<b>1471</b>) includes 4&#xd7;4 pixels, and each pixel of the 4&#xd7;4 pixels corresponds to predN being a N-th neighboring predicted samples before refinement. For example, pred0, pred1, pred2, pred16.</p><p id="p-0127" num="0125">In various embodiments, the offset value of each pixel of a given sub-block may be calculated based on the neighboring samples according to a formula. The formula may be a pre-defined formula, or a formula indicated by a parameter coded in a coded bitstream.</p><p id="p-0128" num="0126">In some implementation referring to <figref idref="DRAWINGS">FIG. <b>14</b>B</figref>, the offset value of k-th position (offset(k)) of a given sub-block may be generated as follows:</p><p id="p-0129" num="0000"><maths id="MATH-US-00001" num="00001"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mrow>      <mi>offset</mi>      <mo>&#x2062;</mo>      <mtext>   </mtext>      <mrow>       <mo>(</mo>       <mi>k</mi>       <mo>)</mo>      </mrow>     </mrow>     <mo>=</mo>     <mrow>      <mrow>       <mo>(</mo>       <mrow>        <mrow>         <mover>          <munder>           <mo>&#x2211;</mo>           <mrow>            <mtext> </mtext>            <mrow>             <mi>n</mi>             <mo>=</mo>             <mn>0</mn>            </mrow>           </mrow>          </munder>          <mn>8</mn>         </mover>         <mrow>          <msub>           <mi>W</mi>           <mi>kn</mi>          </msub>          <mo>*</mo>          <mrow>           <mo>{</mo>           <mrow>            <msub>             <mi>P</mi>             <mi>n</mi>            </msub>            <mo>-</mo>            <msub>             <mi>pred</mi>             <mi>k</mi>            </msub>           </mrow>           <mo>}</mo>          </mrow>         </mrow>        </mrow>        <mo>+</mo>        <mn>32</mn>       </mrow>       <mo>)</mo>      </mrow>      <mo>&#x226b;</mo>      <mn>6</mn>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mn>2</mn>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths><maths id="MATH-US-00001-2" num="00001.2"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <msub>      <mi>pred_refined</mi>      <mi>k</mi>     </msub>     <mo>=</mo>     <mrow>      <mi>clip</mi>      <mo>&#x2062;</mo>      <mn>3</mn>      <mo>&#x2062;</mo>      <mrow>       <mo>(</mo>       <mrow>        <msub>         <mi>pred</mi>         <mi>k</mi>        </msub>        <mo>+</mo>        <mrow>         <mi>offset</mi>         <mo>&#x2062;</mo>         <mtext>   </mtext>         <mrow>          <mo>(</mo>          <mi>k</mi>          <mo>)</mo>         </mrow>        </mrow>       </mrow>       <mo>)</mo>      </mrow>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mn>3</mn>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0130" num="0127">W<sub>kn </sub>is predefined weights for offset computation. P<sub>n </sub>are values of neighboring samples (e.g., P0, P1, P2, . . . , P8). pred<sub>k </sub>are predicated values for pixels after the application of an intra prediction or other prediction (e.g., inter predication). pred_refined<sub>k </sub>are refined values for pixels after the application of ORIP. clip3( ) is a clip3 mathematical function. n is an integer from 0 to 8, inclusive. k is an integer from 0 to 15, inclusive.</p><p id="p-0131" num="0128">In some implementations, W<sub>kn </sub>may be predefined and may be obtained according to Table 1.</p><p id="p-0132" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 1</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Predefined weights for offset computation</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="10"><colspec colname="1" colwidth="14pt" align="center"/><colspec colname="2" colwidth="21pt" align="center"/><colspec colname="3" colwidth="21pt" align="center"/><colspec colname="4" colwidth="21pt" align="center"/><colspec colname="5" colwidth="28pt" align="center"/><colspec colname="6" colwidth="14pt" align="center"/><colspec colname="7" colwidth="28pt" align="center"/><colspec colname="8" colwidth="21pt" align="center"/><colspec colname="9" colwidth="28pt" align="center"/><colspec colname="10" colwidth="21pt" align="center"/><tbody valign="top"><row><entry>k</entry><entry>W<sub>k0</sub></entry><entry>W<sub>k1</sub></entry><entry>W<sub>k2</sub></entry><entry>W<sub>k3</sub></entry><entry>w<sub>k4</sub></entry><entry>W<sub>k5</sub></entry><entry>W<sub>k6</sub></entry><entry>W<sub>k7</sub></entry><entry>W<sub>k8</sub></entry></row><row><entry namest="1" nameend="10" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="10"><colspec colname="1" colwidth="14pt" align="char" char="."/><colspec colname="2" colwidth="21pt" align="char" char="."/><colspec colname="3" colwidth="21pt" align="char" char="."/><colspec colname="4" colwidth="21pt" align="char" char="."/><colspec colname="5" colwidth="28pt" align="char" char="."/><colspec colname="6" colwidth="14pt" align="char" char="."/><colspec colname="7" colwidth="28pt" align="char" char="."/><colspec colname="8" colwidth="21pt" align="char" char="."/><colspec colname="9" colwidth="28pt" align="char" char="."/><colspec colname="10" colwidth="21pt" align="char" char="."/><tbody valign="top"><row><entry>0</entry><entry>4</entry><entry>16</entry><entry>4</entry><entry>0</entry><entry>0</entry><entry>16</entry><entry>4</entry><entry>0</entry><entry>0</entry></row><row><entry>1</entry><entry>2</entry><entry>4</entry><entry>16</entry><entry>4</entry><entry>0</entry><entry>8</entry><entry>2</entry><entry>0</entry><entry>0</entry></row><row><entry>2</entry><entry>1</entry><entry>0</entry><entry>4</entry><entry>16</entry><entry>4</entry><entry>4</entry><entry>1</entry><entry>0</entry><entry>0</entry></row><row><entry>3</entry><entry>0</entry><entry>0</entry><entry>2</entry><entry>4</entry><entry>16</entry><entry>2</entry><entry>0</entry><entry>0</entry><entry>0</entry></row><row><entry>4</entry><entry>2</entry><entry>8</entry><entry>2</entry><entry>0</entry><entry>0</entry><entry>4</entry><entry>16</entry><entry>4</entry><entry>0</entry></row><row><entry>5</entry><entry>0</entry><entry>2</entry><entry>8</entry><entry>2</entry><entry>0</entry><entry>2</entry><entry>8</entry><entry>2</entry><entry>0</entry></row><row><entry>6</entry><entry>0</entry><entry>0</entry><entry>2</entry><entry>8</entry><entry>2</entry><entry>1</entry><entry>4</entry><entry>1</entry><entry>0</entry></row><row><entry>7</entry><entry>0</entry><entry>0</entry><entry>0</entry><entry>2</entry><entry>8</entry><entry>1</entry><entry>2</entry><entry>0</entry><entry>0</entry></row><row><entry>8</entry><entry>0</entry><entry>4</entry><entry>0</entry><entry>0</entry><entry>0</entry><entry>0</entry><entry>4</entry><entry>16</entry><entry>4</entry></row><row><entry>9</entry><entry>0</entry><entry>0</entry><entry>4</entry><entry>0</entry><entry>0</entry><entry>0</entry><entry>2</entry><entry>8</entry><entry>2</entry></row><row><entry>10</entry><entry>0</entry><entry>0</entry><entry>1</entry><entry>4</entry><entry>1</entry><entry>0</entry><entry>1</entry><entry>4</entry><entry>1</entry></row><row><entry>11</entry><entry>0</entry><entry>0</entry><entry>0</entry><entry>2</entry><entry>4</entry><entry>0</entry><entry>0</entry><entry>4</entry><entry>0</entry></row><row><entry>12</entry><entry>0</entry><entry>0</entry><entry>1</entry><entry>0</entry><entry>0</entry><entry>0</entry><entry>2</entry><entry>4</entry><entry>16</entry></row><row><entry>13</entry><entry>0</entry><entry>0</entry><entry>0</entry><entry>1</entry><entry>0</entry><entry>0</entry><entry>1</entry><entry>2</entry><entry>8</entry></row><row><entry>14</entry><entry>0</entry><entry>0</entry><entry>1</entry><entry>2</entry><entry>1</entry><entry>0</entry><entry>0</entry><entry>1</entry><entry>4</entry></row><row><entry>15</entry><entry>0</entry><entry>0</entry><entry>0</entry><entry>1</entry><entry>2</entry><entry>0</entry><entry>0</entry><entry>1</entry><entry>2</entry></row><row><entry namest="1" nameend="10" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0133" num="0129">In some other implementations, the sub-block based ORIP may be applied only to a predefined set of intra-prediction modes and/or may be differently for luma and chroma depending on the intra-prediction mode. Table 2 shows one implementation of the sub-block based ORIP according to various intra-predication modes and either luma or chroma channels. Taking luma channel as an example: when the prediction mode is either DC or SMOOTH, the ORIP is always ON and no additional signaling is required; when the prediction mode is HOR/VER and angle_delta equals to 0, a block level signaling is required to enable/disable of the ORIP; and/or when the intra prediction mode is other mode, the ORIP is always OFF and no additional signaling is required.</p><p id="p-0134" num="0000"><tables id="TABLE-US-00002" num="00002"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 2</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Mode dependent ON/OFF of the proposed method</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="119pt" align="center"/><colspec colname="2" colwidth="98pt" align="center"/><tbody valign="top"><row><entry/><entry>ORIP</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="119pt" align="center"/><colspec colname="2" colwidth="56pt" align="center"/><colspec colname="3" colwidth="42pt" align="center"/><tbody valign="top"><row><entry>Intra-prediction modes</entry><entry>Luma</entry><entry>Chroma</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row><row><entry>DC</entry><entry>ON</entry><entry>OFF</entry></row><row><entry>SMOOTH</entry><entry>ON</entry><entry>ON</entry></row><row><entry>HOR/VER mode with angle delta == 0</entry><entry>ON/OFF (signal)</entry><entry>ON</entry></row><row><entry>Other modes</entry><entry>OFF</entry><entry>OFF</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0135" num="0130">Referring back to a second 4&#xd7;4 sub-block (<b>1473</b>), due to its relative position with the first 4&#xd7;4 sub-block (<b>1471</b>), the second sub-block's top neighboring samples may be some pixels of the first sub-block: the second sub-block's P1 may be the first block's pred12, the second sub-block's P2 may be the first sub-block's pred13, the second sub-block's P3 may be the first sub-block's pred14, and the second sub-block's P4 may be the first sub-block's pred15. The second sub-block's top-left neighboring sample (P0) may be the first sub-block's left neighboring sample (P8).</p><p id="p-0136" num="0131">There may be some issues/problems associated with some ORIP implementations. For example, when an intra prediction mode of a luma component of a block is either vertical or horizontal intra prediction mode, there may be three different options: 1) selecting an adjacent reference line, and applying ORIP to the block; 2) selecting an adjacent reference line, and not applying ORIP to the block; and/or 3) selecting a non-adjacent reference line, and not applying ORIP to the block. Since reference samples from adjacent and non-adjacent reference lines may be usually similar, there may be some redundancy between option <b>2</b>) and option <b>3</b>), which may reduce the performance of video encoding/decoding.</p><p id="p-0137" num="0132">The present disclosure describes various embodiment for offset refinement for intra prediction and multiple reference line intra prediction in video coding and/or decoding, addressing at least one of the issues/problems discussed above.</p><p id="p-0138" num="0133">In various embodiment, referring to <figref idref="DRAWINGS">FIG. <b>15</b></figref>, a method <b>1500</b> for offset refinement for intra prediction and multiple reference line intra prediction in video decoding, the method <b>1500</b> may include a portion or all of the following step: step <b>1510</b>, receiving, by a device comprising a memory storing instructions and a processor in communication with the memory, a coded video bitstream for a block; step <b>1520</b>, determining, by the device, whether offset refinement for intra prediction applies to the block, based on mode information of the block, the mode information of the block comprising at least one of the following: a reference line index of the block, an intra prediction mode of the block, and a size of the block; and/or step <b>1530</b>, in response to determining that the offset refinement for intra prediction applies to the block, performing, by the device, the offset refinement to generate an intra predictor for intra prediction of the block. In some implementations, step <b>1520</b> may include determining, by the device, whether offset refinement for intra prediction applies to the block, based on mode information of the block, the mode information of the block comprising at least one of the following: a reference line index of the block, an intra prediction mode of the block, or a size of the block.</p><p id="p-0139" num="0134">In various embodiments in the present disclosure, a size of a block (for example but not limited to, a coding block, a prediction block, or a transform block) may refer to a width or a height of the block. The width or the height of the block may be an integer in a unit of pixels.</p><p id="p-0140" num="0135">In various embodiments in the present disclosure, a size of a block (for example but not limited to, a coding block, a prediction block, or a transform block) may refer to an area size of the block. The area size of the block may be an integer calculated by the width of the block multiplied by the height of the bock in a unit of pixels.</p><p id="p-0141" num="0136">In some various embodiments in the present disclosure, a size of a block (for example but not limited to, a coding block, a prediction block, or a transform block) may refer to a maximum value of a width or a height of the block, a minimum value of a width or a height of the block, or an aspect ratio of the block. The aspect ratio of the block may be calculated as the width divided by the height of the block, or may be calculated as the height divided by the width of the block.</p><p id="p-0142" num="0137">In the present disclosure, a reference line index indicates a reference line among multiple reference lines. In various embodiments, the reference line index being 0 for a block may indicate the adjacent reference line to the block, which is also the nearest reference line to the block. For example, referring to a block (<b>1202</b>) in <figref idref="DRAWINGS">FIG. <b>12</b></figref>, a top reference line (<b>1210</b>) is a top adjacent reference line to the block (<b>1202</b>), which is also a top nearest reference line to the block; and a left reference line (<b>1218</b>) is a left adjacent reference line to the block (<b>1202</b>), which is also a left nearest reference line to the block. A reference line index being greater than 0 for a block indicates a non-adjacent reference line of the block, which is also the non-nearest reference line to the block. For example, referring to a block (<b>1202</b>) in <figref idref="DRAWINGS">FIG. <b>12</b></figref>, a reference line index being 1 may indicate a top reference line (<b>1208</b>) and/or a left reference line (<b>1216</b>); a reference line index being 2 may indicate a top reference line (<b>1206</b>) and/or a left reference line (<b>1214</b>); and/or a reference line index being 3 may indicate a top reference line (<b>1204</b>) and/or a left reference line (<b>1212</b>).</p><p id="p-0143" num="0138">In various embodiments for video coding and/or decoding, when a directional intra prediction mode is selected for a block (e.g, a coding block or a coded block), to generate the intra predictor from samples at the non-adjacent reference lines, it may determine whether offset refinement for intra prediction (ORIP) is applied to the block or not. This determination may depend on mode information of the block, and the mode information of the block may include but not limited to, a reference line index, one or more intra prediction angle, and/or a size of the block, (or) block sizes, when this determination is made based on the mode information of the block, no additional signaling is needed for indicating whether ORIP is applied or not, reducing overhead in video encoding/decoding and/or improving performance of the video encoding/decoding. In various embodiments, the offset refinement for intra prediction (ORIP) may refer to an offset-based refinement for intra prediction, and is a type of intra prediction whose prediction result is further refined (or modified) according to an offset value generated based on one or more neighboring reference samples.</p><p id="p-0144" num="0139">Referring to step <b>1510</b>, the device may be the electronic device (<b>530</b>) in <figref idref="DRAWINGS">FIG. <b>5</b></figref> or the video decoder (<b>810</b>) in <figref idref="DRAWINGS">FIG. <b>8</b></figref>. In some implementations, the device may be the decoder (<b>633</b>) in the encoder (<b>620</b>) in <figref idref="DRAWINGS">FIG. <b>6</b></figref>. In other implementations, the device may be a portion of the electronic device (<b>530</b>) in <figref idref="DRAWINGS">FIG. <b>5</b></figref>, a portion of the video decoder (<b>810</b>) in <figref idref="DRAWINGS">FIG. <b>8</b></figref>, or a portion of the decoder (<b>633</b>) in the encoder (<b>620</b>) in <figref idref="DRAWINGS">FIG. <b>6</b></figref>. The coded video bitstream may be the coded video sequence in <figref idref="DRAWINGS">FIG. <b>8</b></figref>, or an intermediate coded data in <figref idref="DRAWINGS">FIG. <b>6</b> or <b>7</b></figref>. The block may refer to a coding block or a coded block.</p><p id="p-0145" num="0140">Referring to step <b>1520</b>, the device may determine whether offset refinement for intra prediction applies to the block, based on mode information of the block, the mode information of the block may include at least one of the following: a reference line index of the block, an intra prediction mode of the block, or a size of the block.</p><p id="p-0146" num="0141">In various embodiments, step <b>1520</b> may include, response to the reference line index of the block being smaller than a predefined threshold and the intra prediction mode of the block belonging to directional intra prediction modes, determining that the offset refinement for intra prediction applies to the block; and/or in response to the reference line index of the block not being smaller than the predefined threshold or the intra prediction mode of the block belonging to the directional intra prediction modes, determining that the offset refinement for intra prediction does not apply to the block.</p><p id="p-0147" num="0142">In some implementations, for a set of directional intra prediction modes, when the value of reference line index is smaller than a predefined value, ORIP is always applied; and/or when the value of reference line index is greater than or equal to the predefined value, ORIP is never applied. In one example, this set of directional intra prediction modes includes vertical and horizontal modes. In another example, this set of directional intra prediction modes includes vertical, horizontal, 45 degrees, and 135 degrees directional modes. In another example, the predefined value is N and is set to 1. In another example, N is set to 2. In another example, N is set to 0 or 3.</p><p id="p-0148" num="0143">In various embodiments, step <b>1520</b> may include, in response to the reference line index of the block being an even number and the intra prediction mode of the block belonging to directional intra prediction modes, determining that the offset refinement for intra prediction applies to the block; and/or in response to the reference line index of the block being an odd number and the intra prediction mode of the block belonging to the directional intra prediction modes, determining that the offset refinement for intra prediction does not apply to the block.</p><p id="p-0149" num="0144">In some implementations, for one set of directional intra prediction modes, the determination on whether ORIP is applied or not, depends on whether the value of reference line index is even or odd. In one example, for one set of directional intra prediction modes, when the value of reference line index is even, ORIP is applied; when the value of reference line index is odd, ORIP is not applied. In another example, for one set of directional intra prediction modes, when the value of reference line index is odd, ORIP is applied; when the value of reference line index is even, ORIP is not applied. In another example, this set of directional intra prediction modes includes vertical and horizontal modes. In another example, this set of directional intra prediction modes includes vertical, horizontal, 45 degrees, and 135 degrees directional modes.</p><p id="p-0150" num="0145">In various embodiments, step <b>1520</b> may include, in response to the intra prediction mode of the block belonging to a first selected set of intra prediction modes, determining that the offset refinement for intra prediction applies to the block; in response to the intra prediction mode of the block belonging to a second selected set of intra prediction modes and the reference line index indicating an adjacent reference line, determining that the offset refinement for intra prediction applies to the block; and/or in response to the intra prediction mode of the block belonging to the second selected set of intra prediction modes and the reference line index indicating a non-adjacent reference line, determining that the offset refinement for intra prediction does not apply to the block. In some implementations, the first selected set of intra prediction modes does not overlap with the second selected set of intra prediction modes. In some other implementations, the first selected set of intra prediction modes may include a diagonal intra prediction mode.</p><p id="p-0151" num="0146">In some implementations, for a selected set of intra prediction modes, ORIP is applied for both adjacent and non-adjacent reference lines, while for the remaining set of intra prediction modes, ORIP is only applied for adjacent reference lines. In one example, when the intra prediction is applied by only using integer samples, e.g., diagonal (45/225 degree) intra prediction modes, ORIP may be applied for non-adjacent reference lines as well; and/or when the intra prediction does not use integer samples, ORIP is only applied for adjacent reference lines.</p><p id="p-0152" num="0147">In various embodiments, step <b>1520</b> may include, in response to the intra prediction mode of the block belonging to directional intra prediction modes and the reference line index of the block indicating a non-adjacent reference line, determining that the offset refinement for intra prediction applies to the block.</p><p id="p-0153" num="0148">In some implementations, step <b>1520</b> may further include, during entropy decoding, using the mode information of the block as context for a parameter for the offset refinement for intra prediction.</p><p id="p-0154" num="0149">In some other implementations, when directional intra prediction mode is selected for a block, to generate the intra predictor from samples at the non-adjacent reference lines, the ORIP may be still applicable, and/or the ORIP may still be signaled by a parameter (e.g., an ORIP flag or an ORIP index) in a coded bitstream regardless the value of mode information of the block.</p><p id="p-0155" num="0150">In some other implementations during video encoding, a context used for entropy coding of an ORIP parameter (e.g., flag/index) that indicates whether and how ORIP is applied depends on the mode information of the current block. In some implementations, the context for entropy coding of syntax value that indicates whether and how other modes of current block are applied depends on the ORIP flag/index that indicates whether and how ORIP is applied to the block. Examples of syntax of other modes of current block include, but not limited to, a reference line index, one or more intra prediction angles, and/or a size of the block.</p><p id="p-0156" num="0151">Referring to step <b>1530</b>, in response to determining that the offset refinement for intra prediction applies to the block, the device performs the offset refinement for intra prediction to the block. In some implementations, the block is a 4&#xd7;4 block or include a plurality of 4&#xd7;4 blocks, and the offset refinement for intra prediction is performed to the block according to a predefined method, for example, according to the method described above with Eq. (2) and Eq. (3).</p><p id="p-0157" num="0152">In various embodiments, step <b>1530</b> may include, determining a predictor from a non-adjacent reference line indicated by the reference line index of the block; determining a prediction value for the block according to intra prediction based on the predictor; and/or modifying the prediction value according to the offset refinement for intra prediction based on a sample from an adjacent reference line. In some implementations, the non-adjacent reference line and the adjacent reference line are from two sides; and the two sides comprise a top side and a left side.</p><p id="p-0158" num="0153">In some implementations, when ORIP is applied, to generate the intra predictor from samples at the non-adjacent reference lines, a predictor (e.g., predicator A) is generated from the samples at the non-adjacent reference line selected by MRLS, and then ORIP further modifies the prediction values from the predictor A by using samples from adjacent reference lines.</p><p id="p-0159" num="0154">In some other implementations, reference samples used for generating the predictor A and further modifying predictor values from (or based on) the predictor A are from different sides of neighboring reference samples. Example of the sides of neighboring reference samples includes but not limited to top reference samples and left reference samples. In one example, one or more top reference samples are used to generate the predictor A, and one or more left reference samples are used to modify predictor values from (or based on) the predictor A. In another example, one or more left reference samples are used to generate the predictor A, and one or more top reference samples are used to modify predictor values from (or based on) the predictor A.</p><p id="p-0160" num="0155">In various embodiments, step <b>1530</b> may include, determining a predictor from a non-adjacent reference line indicated by the reference line index of the block; determining a prediction value for the block according to intra prediction based on the predictor; and/or modifying the prediction value according to the offset refinement for intra prediction based on samples from multiple reference lines.</p><p id="p-0161" num="0156">In some implementations, step <b>1530</b> may further include, using a linear weighted average to obtain a sample based on the samples and corresponding weights, the corresponding weights being predefined according to relative positions of the samples.</p><p id="p-0162" num="0157">In some other implementations, when ORIP is applied, to generate the intra predictor from samples at the non-adjacent reference lines, prediction samples are refinement by ORIP with the samples from multiple (more than 1) reference lines. In one example, ORIP is generated using a linear weighted sum of samples from multiple reference lines. The weights may be predefined according to the relative positions of the samples.</p><p id="p-0163" num="0158">Embodiments in the disclosure may be used separately or combined in any order. Further, each of the methods (or embodiments), an encoder, and a decoder may be implemented by processing circuitry (e.g., one or more processors or one or more integrated circuits). In one example, the one or more processors execute a program that is stored in a non-transitory computer-readable medium. Embodiments in the disclosure may be applied to a luma block or a chroma block; and in the chroma block, the embodiments may be applied to more than one color components separately or may be applied to more than one color components together.</p><p id="p-0164" num="0159">The techniques described above, can be implemented as computer software using computer-readable instructions and physically stored in one or more computer-readable media. For example, <figref idref="DRAWINGS">FIG. <b>16</b></figref> shows a computer system (<b>2600</b>) suitable for implementing certain embodiments of the disclosed subject matter.</p><p id="p-0165" num="0160">The computer software can be coded using any suitable machine code or computer language, that may be subject to assembly, compilation, linking, or like mechanisms to create code comprising instructions that can be executed directly, or through interpretation, micro-code execution, and the like, by one or more computer central processing units (CPUs), Graphics Processing Units (GPUs), and the like.</p><p id="p-0166" num="0161">The instructions can be executed on various types of computers or components thereof, including, for example, personal computers, tablet computers, servers, smartphones, gaming devices, internet of things devices, and the like.</p><p id="p-0167" num="0162">The components shown in <figref idref="DRAWINGS">FIG. <b>16</b></figref> for computer system (<b>2600</b>) are exemplary in nature and are not intended to suggest any limitation as to the scope of use or functionality of the computer software implementing embodiments of the present disclosure. Neither should the configuration of components be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in the exemplary embodiment of a computer system (<b>2600</b>).</p><p id="p-0168" num="0163">Computer system (<b>2600</b>) may include certain human interface input devices. Such a human interface input device may be responsive to input by one or more human users through, for example, tactile input (such as: keystrokes, swipes, data glove movements), audio input (such as: voice, clapping), visual input (such as: gestures), olfactory input (not depicted). The human interface devices can also be used to capture certain media not necessarily directly related to conscious input by a human, such as audio (such as: speech, music, ambient sound), images (such as: scanned images, photographic images obtain from a still image camera), video (such as two-dimensional video, three-dimensional video including stereoscopic video).</p><p id="p-0169" num="0164">Input human interface devices may include one or more of (only one of each depicted): keyboard (<b>2601</b>), mouse (<b>2602</b>), trackpad (<b>2603</b>), touch screen (<b>2610</b>), data-glove (not shown), joystick (<b>2605</b>), microphone (<b>2606</b>), scanner (<b>2607</b>), camera (<b>2608</b>).</p><p id="p-0170" num="0165">Computer system (<b>2600</b>) may also include certain human interface output devices. Such human interface output devices may be stimulating the senses of one or more human users through, for example, tactile output, sound, light, and smell/taste. Such human interface output devices may include tactile output devices (for example tactile feedback by the touch-screen (<b>2610</b>), data-glove (not shown), or joystick (<b>2605</b>), but there can also be tactile feedback devices that do not serve as input devices), audio output devices (such as: speakers (<b>2609</b>), headphones (not depicted)), visual output devices (such as screens (<b>2610</b>) to include CRT screens, LCD screens, plasma screens, OLED screens, each with or without touch-screen input capability, each with or without tactile feedback capability&#x2014;some of which may be capable to output two dimensional visual output or more than three dimensional output through means such as stereographic output; virtual-reality glasses (not depicted), holographic displays and smoke tanks (not depicted)), and printers (not depicted).</p><p id="p-0171" num="0166">Computer system (<b>2600</b>) can also include human accessible storage devices and their associated media such as optical media including CD/DVD ROM/RW (<b>2620</b>) with CD/DVD or the like media (<b>2621</b>), thumb-drive (<b>2622</b>), removable hard drive or solid state drive (<b>2623</b>), legacy magnetic media such as tape and floppy disc (not depicted), specialized ROM/ASIC/PLD based devices such as security dongles (not depicted), and the like.</p><p id="p-0172" num="0167">Those skilled in the art should also understand that term &#x201c;computer readable media&#x201d; as used in connection with the presently disclosed subject matter does not encompass transmission media, carrier waves, or other transitory signals.</p><p id="p-0173" num="0168">Computer system (<b>2600</b>) can also include an interface (<b>2654</b>) to one or more communication networks (<b>2655</b>). Networks can for example be wireless, wireline, optical. Networks can further be local, wide-area, metropolitan, vehicular and industrial, real-time, delay-tolerant, and so on. Examples of networks include local area networks such as Ethernet, wireless LANs, cellular networks to include GSM, 3G, 4G, 5G, LTE and the like, TV wireline or wireless wide area digital networks to include cable TV, satellite TV, and terrestrial broadcast TV, vehicular and industrial to include CAN bus, and so forth. Certain networks commonly require external network interface adapters that attached to certain general-purpose data ports or peripheral buses (<b>2649</b>) (such as, for example USB ports of the computer system (<b>2600</b>)); others are commonly integrated into the core of the computer system (<b>2600</b>) by attachment to a system bus as described below (for example Ethernet interface into a PC computer system or cellular network interface into a smartphone computer system). Using any of these networks, computer system (<b>2600</b>) can communicate with other entities. Such communication can be uni-directional, receive only (for example, broadcast TV), uni-directional send-only (for example CANbus to certain CANbus devices), or bi-directional, for example to other computer systems using local or wide area digital networks. Certain protocols and protocol stacks can be used on each of those networks and network interfaces as described above.</p><p id="p-0174" num="0169">Aforementioned human interface devices, human-accessible storage devices, and network interfaces can be attached to a core (<b>2640</b>) of the computer system (<b>2600</b>).</p><p id="p-0175" num="0170">The core (<b>2640</b>) can include one or more Central Processing Units (CPU) (<b>2641</b>), Graphics Processing Units (GPU) (<b>2642</b>), specialized programmable processing units in the form of Field Programmable Gate Areas (FPGA) (<b>2643</b>), hardware accelerators for certain tasks (<b>2644</b>), graphics adapters (<b>2650</b>), and so forth. These devices, along with Read-only memory (ROM) (<b>2645</b>), Random-access memory (<b>2646</b>), internal mass storage such as internal non-user accessible hard drives, SSDs, and the like (<b>2647</b>), may be connected through a system bus (<b>2648</b>). In some computer systems, the system bus (<b>2648</b>) can be accessible in the form of one or more physical plugs to enable extensions by additional CPUs, GPU, and the like. The peripheral devices can be attached either directly to the core's system bus (<b>2648</b>), or through a peripheral bus (<b>2649</b>). In an example, the screen (<b>2610</b>) can be connected to the graphics adapter (<b>2650</b>). Architectures for a peripheral bus include PCI, USB, and the like.</p><p id="p-0176" num="0171">CPUs (<b>2641</b>), GPUs (<b>2642</b>), FPGAs (<b>2643</b>), and accelerators (<b>2644</b>) can execute certain instructions that, in combination, can make up the aforementioned computer code. That computer code can be stored in ROM (<b>2645</b>) or RAM (<b>2646</b>). Transitional data can also be stored in RAM (<b>2646</b>), whereas permanent data can be stored for example, in the internal mass storage (<b>2647</b>). Fast storage and retrieve to any of the memory devices can be enabled through the use of cache memory, that can be closely associated with one or more CPU (<b>2641</b>), GPU (<b>2642</b>), mass storage (<b>2647</b>), ROM (<b>2645</b>), RAM (<b>2646</b>), and the like.</p><p id="p-0177" num="0172">The computer readable media can have computer code thereon for performing various computer-implemented operations. The media and computer code can be those specially designed and constructed for the purposes of the present disclosure, or they can be of the kind well known and available to those having skill in the computer software arts.</p><p id="p-0178" num="0173">As a non-limiting example, the computer system having architecture (<b>2600</b>), and specifically the core (<b>2640</b>) can provide functionality as a result of processor(s) (including CPUs, GPUs, FPGA, accelerators, and the like) executing software embodied in one or more tangible, computer-readable media. Such computer-readable media can be media associated with user-accessible mass storage as introduced above, as well as certain storage of the core (<b>2640</b>) that are of non-transitory nature, such as core-internal mass storage (<b>2647</b>) or ROM (<b>2645</b>). The software implementing various embodiments of the present disclosure can be stored in such devices and executed by core (<b>2640</b>). A computer-readable medium can include one or more memory devices or chips, according to particular needs. The software can cause the core (<b>2640</b>) and specifically the processors therein (including CPU, GPU, FPGA, and the like) to execute particular processes or particular parts of particular processes described herein, including defining data structures stored in RAM (<b>2646</b>) and modifying such data structures according to the processes defined by the software. In addition or as an alternative, the computer system can provide functionality as a result of logic hardwired or otherwise embodied in a circuit (for example: accelerator (<b>2644</b>)), which can operate in place of or together with software to execute particular processes or particular parts of particular processes described herein. Reference to software can encompass logic, and vice versa, where appropriate. Reference to a computer-readable media can encompass a circuit (such as an integrated circuit (IC)) storing software for execution, a circuit embodying logic for execution, or both, where appropriate. The present disclosure encompasses any suitable combination of hardware and software.</p><p id="p-0179" num="0174">While the particular invention has been described with reference to illustrative embodiments, this description is not meant to be limiting. Various modifications of the illustrative embodiments and additional embodiments of the invention will be apparent to one of ordinary skill in the art from this description. Those skilled in the art will readily recognize that these and various other modifications can be made to the exemplary embodiments, illustrated and described herein, without departing from the spirit and scope of the present invention. It is therefore contemplated that the appended claims will cover any such modifications and alternate embodiments. Certain proportions within the illustrations may be exaggerated, while other proportions may be minimized. Accordingly, the disclosure and the figures are to be regarded as illustrative rather than restrictive.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-math idrefs="MATH-US-00001 MATH-US-00001-2" nb-file="US20230007299A1-20230105-M00001.NB"><img id="EMI-M00001" he="12.70mm" wi="76.20mm" file="US20230007299A1-20230105-M00001.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A method for offset refinement for intra prediction and multiple reference line intra prediction in video decoding, the method comprising:<claim-text>receiving, by a device comprising a memory storing instructions and a processor in communication with the memory, a coded video bitstream for a block;</claim-text><claim-text>determining, by the device, whether offset refinement for intra prediction applies to the block, based on mode information of the block, the mode information of the block comprising at least one of the following: a reference line index of the block, an intra prediction mode of the block, and a size of the block; and</claim-text><claim-text>in response to determining that the offset refinement for intra prediction applies to the block, performing, by the device, the offset refinement to generate an intra predictor for intra prediction of the block.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the determining whether the offset refinement for intra prediction applies to the block comprises:<claim-text>in response to the reference line index of the block being smaller than a predefined threshold and the intra prediction mode of the block belonging to directional intra prediction modes, determining that the offset refinement for intra prediction applies to the block; and</claim-text><claim-text>in response to the reference line index of the block not being smaller than the predefined threshold or the intra prediction mode of the block belonging to the directional intra prediction modes, determining that the offset refinement for intra prediction does not apply to the block.</claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The method according to <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein:<claim-text>the directional intra prediction modes comprises a vertical mode and a horizontal mode.</claim-text></claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The method according to <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein:<claim-text>the directional intra prediction modes comprises a vertical mode, a horizontal mode, a 45 degrees directional mode, and a 135 degrees directional mode.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The method according to <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein:<claim-text>the predefined threshold comprises one of the following: 1 or 2.</claim-text></claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the determining whether the offset refinement for intra prediction applies to the block comprises:<claim-text>in response to the reference line index of the block being an even number and the intra prediction mode of the block belonging to directional intra prediction modes, determining that the offset refinement for intra prediction applies to the block; and</claim-text><claim-text>in response to the reference line index of the block being an odd number and the intra prediction mode of the block belonging to the directional intra prediction modes, determining that the offset refinement for intra prediction does not apply to the block.</claim-text></claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the determining whether the offset refinement for intra prediction applies to the block comprises:<claim-text>in response to the intra prediction mode of the block belonging to a first selected set of intra prediction modes, determining that the offset refinement for intra prediction applies to the block;</claim-text><claim-text>in response to the intra prediction mode of the block belonging to a second selected set of intra prediction modes and the reference line index indicating an adjacent reference line, determining that the offset refinement for intra prediction applies to the block; and</claim-text><claim-text>in response to the intra prediction mode of the block belonging to the second selected set of intra prediction modes and the reference line index indicating a non-adjacent reference line, determining that the offset refinement for intra prediction does not apply to the block,</claim-text><claim-text>wherein the first selected set of intra prediction modes does not overlap with the second selected set of intra prediction modes.</claim-text></claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The method according to <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the first selected set of intra prediction modes comprises a diagonal intra prediction mode.</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the performing the offset refinement to generate the intra predictor for the intra prediction of the block comprises:<claim-text>determining a predictor from a non-adjacent reference line indicated by the reference line index of the block;</claim-text><claim-text>determining a prediction value for the block according to intra prediction based on the predictor; and</claim-text><claim-text>modifying the prediction value according to the offset refinement for intra prediction based on a sample from an adjacent reference line.</claim-text></claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The method according to <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein:<claim-text>the non-adjacent reference line and the adjacent reference line are from two sides; and</claim-text><claim-text>the two sides comprise a top side and a left side.</claim-text></claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the performing the offset refinement to generate the intra predictor for the intra prediction of the block comprises:<claim-text>determining a predictor from a non-adjacent reference line indicated by the reference line index of the block;</claim-text><claim-text>determining a prediction value for the block according to intra prediction based on the predictor; and</claim-text><claim-text>modifying the prediction value according to the offset refinement for intra prediction based on samples from multiple reference lines.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The method according to <claim-ref idref="CLM-00011">claim 11</claim-ref>, further comprising:<claim-text>using a linear weighted average to obtain a sample based on the samples and corresponding weights, the corresponding weights being predefined according to relative positions of the samples.</claim-text></claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the determining whether the offset refinement for intra prediction applies to the block comprises:<claim-text>in response to the intra prediction mode of the block belonging to directional intra prediction modes and the reference line index of the block indicating a non-adjacent reference line, determining that the offset refinement for intra prediction applies to the block.</claim-text></claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The method according to <claim-ref idref="CLM-00013">claim 13</claim-ref>, further comprising:<claim-text>during entropy decoding, using the mode information of the block as context for a parameter for the offset refinement for intra prediction.</claim-text></claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. An apparatus for offset refinement for intra prediction and multiple reference line intra prediction in video decoding, the apparatus comprising:<claim-text>a memory storing instructions; and</claim-text><claim-text>a processor in communication with the memory, wherein, when the processor executes the instructions, the processor is configured to cause the apparatus to:<claim-text>receive a coded video bitstream for a block;</claim-text><claim-text>determine whether offset refinement for intra prediction applies to the block, based on mode information of the block, the mode information of the block comprising at least one of the following: a reference line index of the block, an intra prediction mode of the block, and a size of the block; and</claim-text><claim-text>in response to determining that the offset refinement for intra prediction applies to the block, perform the offset refinement to generate an intra predictor for intra prediction of the block.</claim-text></claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The apparatus according to <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein, when the processor is configured to cause the apparatus to determine whether the offset refinement for intra prediction applies to the block, the processor is configured to cause the apparatus to:<claim-text>in response to the reference line index of the block being smaller than a predefined threshold and the intra prediction mode of the block belonging to directional intra prediction modes, determine that the offset refinement for intra prediction applies to the block; and</claim-text><claim-text>in response to the reference line index of the block not being smaller than the predefined threshold or the intra prediction mode of the block belonging to the directional intra prediction modes, determine that the offset refinement for intra prediction does not apply to the block.</claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The apparatus according to <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein, when the processor is configured to cause the apparatus to determine whether the offset refinement for intra prediction applies to the block, the processor is configured to cause the apparatus to:<claim-text>in response to the reference line index of the block being an even number and the intra prediction mode of the block belonging to directional intra prediction modes, determine that the offset refinement for intra prediction applies to the block; and</claim-text><claim-text>in response to the reference line index of the block being an odd number and the intra prediction mode of the block belonging to the directional intra prediction modes, determine that the offset refinement for intra prediction does not apply to the block.</claim-text></claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. A non-transitory computer readable storage medium storing instructions, wherein, when the instructions are executed by a processor, the instructions are configured to cause the processor to:<claim-text>receive a coded video bitstream for a block;</claim-text><claim-text>determine whether offset refinement for intra prediction applies to the block, based on mode information of the block, the mode information of the block comprising at least one of the following: a reference line index of the block, an intra prediction mode of the block, and a size of the block; and</claim-text><claim-text>in response to determining that the offset refinement for intra prediction applies to the block, perform the offset refinement to generate an intra predictor for intra prediction of the block.</claim-text></claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The non-transitory computer readable storage medium according to <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein, when the instructions are configured to cause the processor to determine whether the offset refinement for intra prediction applies to the block, the instructions are configured to cause the processor to:<claim-text>in response to the reference line index of the block being smaller than a predefined threshold and the intra prediction mode of the block belonging to directional intra prediction modes, determine that the offset refinement for intra prediction applies to the block; and</claim-text><claim-text>in response to the reference line index of the block not being smaller than the predefined threshold or the intra prediction mode of the block belonging to the directional intra prediction modes, determine that the offset refinement for intra prediction does not apply to the block.</claim-text></claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The non-transitory computer readable storage medium according to <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein, when the instructions are configured to cause the processor to determine whether the offset refinement for intra prediction applies to the block, the instructions are configured to cause the processor to:<claim-text>in response to the reference line index of the block being an even number and the intra prediction mode of the block belonging to directional intra prediction modes, determine that the offset refinement for intra prediction applies to the block; and</claim-text><claim-text>in response to the reference line index of the block being an odd number and the intra prediction mode of the block belonging to the directional intra prediction modes, determine that the offset refinement for intra prediction does not apply to the block.</claim-text></claim-text></claim></claims></us-patent-application>