<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230005096A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230005096</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17525636</doc-number><date>20211112</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>T</subclass><main-group>1</main-group><subgroup>60</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>54</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>T</subclass><main-group>15</main-group><subgroup>00</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>901</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>T</subclass><main-group>1</main-group><subgroup>60</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>545</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>T</subclass><main-group>15</main-group><subgroup>005</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>9024</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">MEMORY ALLOCATION USING GRAPHS</invention-title><us-related-documents><us-provisional-application><document-id><country>US</country><doc-number>63214205</doc-number><date>20210623</date></document-id></us-provisional-application></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>NVIDIA Corporation</orgname><address><city>Santa Clara</city><state>CA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Gurfinkel</last-name><first-name>Steven Arthur</first-name><address><city>San Francisco</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Jones</last-name><first-name>Stephen Anthony Bernard</first-name><address><city>San Francisco</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>Gaiser</last-name><first-name>Jason David</first-name><address><city>Campbell</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="03" designation="us-only"><addressbook><last-name>Vishnuswaroop Ramesh</last-name><first-name>Fnu</first-name><address><city>Sunnyvale</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="04" designation="us-only"><addressbook><last-name>Hoffman</last-name><first-name>Houston Thompson</first-name><address><city>San Jose</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="05" designation="us-only"><addressbook><last-name>Carilli</last-name><first-name>Michael Francis</first-name><address><city>Los Ranchos</city><state>NM</state><country>US</country></address></addressbook></inventor><inventor sequence="06" designation="us-only"><addressbook><last-name>Fontaine</last-name><first-name>David Anthony</first-name><address><city>Mountain View</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="07" designation="us-only"><addressbook><last-name>Zulfiqar</last-name><first-name>Arslan</first-name><address><city>Greenville</city><state>NC</state><country>US</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">Apparatuses, systems, and techniques to generate one or more graph code nodes to allocate memory. In at least one embodiment, one or more graph code nodes to allocate memory are generated, based on, for example, CUDA or other parallel computing platform code.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="197.02mm" wi="139.02mm" file="US20230005096A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="224.20mm" wi="141.05mm" file="US20230005096A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="239.44mm" wi="168.15mm" orientation="landscape" file="US20230005096A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="213.70mm" wi="168.15mm" orientation="landscape" file="US20230005096A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="238.51mm" wi="168.15mm" orientation="landscape" file="US20230005096A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="237.32mm" wi="166.29mm" orientation="landscape" file="US20230005096A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="215.22mm" wi="166.29mm" orientation="landscape" file="US20230005096A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="224.20mm" wi="146.22mm" orientation="landscape" file="US20230005096A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="212.09mm" wi="166.29mm" orientation="landscape" file="US20230005096A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="224.20mm" wi="124.63mm" file="US20230005096A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="224.20mm" wi="125.81mm" file="US20230005096A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="228.85mm" wi="128.86mm" file="US20230005096A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="230.12mm" wi="153.75mm" file="US20230005096A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="228.85mm" wi="152.06mm" file="US20230005096A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00014" num="00014"><img id="EMI-D00014" he="234.44mm" wi="162.90mm" orientation="landscape" file="US20230005096A1-20230105-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00015" num="00015"><img id="EMI-D00015" he="212.09mm" wi="149.52mm" file="US20230005096A1-20230105-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00016" num="00016"><img id="EMI-D00016" he="231.39mm" wi="159.09mm" file="US20230005096A1-20230105-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00017" num="00017"><img id="EMI-D00017" he="228.01mm" wi="167.22mm" orientation="landscape" file="US20230005096A1-20230105-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00018" num="00018"><img id="EMI-D00018" he="232.33mm" wi="169.67mm" orientation="landscape" file="US20230005096A1-20230105-D00018.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00019" num="00019"><img id="EMI-D00019" he="228.77mm" wi="161.46mm" file="US20230005096A1-20230105-D00019.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00020" num="00020"><img id="EMI-D00020" he="230.12mm" wi="146.30mm" file="US20230005096A1-20230105-D00020.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00021" num="00021"><img id="EMI-D00021" he="221.83mm" wi="145.63mm" file="US20230005096A1-20230105-D00021.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00022" num="00022"><img id="EMI-D00022" he="227.50mm" wi="167.98mm" file="US20230005096A1-20230105-D00022.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00023" num="00023"><img id="EMI-D00023" he="231.14mm" wi="164.34mm" orientation="landscape" file="US20230005096A1-20230105-D00023.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00024" num="00024"><img id="EMI-D00024" he="227.25mm" wi="159.60mm" file="US20230005096A1-20230105-D00024.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00025" num="00025"><img id="EMI-D00025" he="211.24mm" wi="154.77mm" file="US20230005096A1-20230105-D00025.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00026" num="00026"><img id="EMI-D00026" he="233.43mm" wi="144.02mm" file="US20230005096A1-20230105-D00026.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00027" num="00027"><img id="EMI-D00027" he="239.27mm" wi="159.00mm" orientation="landscape" file="US20230005096A1-20230105-D00027.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00028" num="00028"><img id="EMI-D00028" he="234.44mm" wi="169.33mm" file="US20230005096A1-20230105-D00028.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00029" num="00029"><img id="EMI-D00029" he="236.90mm" wi="151.55mm" orientation="landscape" file="US20230005096A1-20230105-D00029.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00030" num="00030"><img id="EMI-D00030" he="246.04mm" wi="171.53mm" orientation="landscape" file="US20230005096A1-20230105-D00030.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00031" num="00031"><img id="EMI-D00031" he="226.14mm" wi="154.94mm" file="US20230005096A1-20230105-D00031.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00032" num="00032"><img id="EMI-D00032" he="216.66mm" wi="154.43mm" file="US20230005096A1-20230105-D00032.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00033" num="00033"><img id="EMI-D00033" he="222.67mm" wi="142.16mm" file="US20230005096A1-20230105-D00033.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00034" num="00034"><img id="EMI-D00034" he="132.84mm" wi="133.43mm" file="US20230005096A1-20230105-D00034.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00035" num="00035"><img id="EMI-D00035" he="162.22mm" wi="133.18mm" file="US20230005096A1-20230105-D00035.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00036" num="00036"><img id="EMI-D00036" he="184.40mm" wi="133.35mm" file="US20230005096A1-20230105-D00036.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00037" num="00037"><img id="EMI-D00037" he="147.40mm" wi="156.80mm" file="US20230005096A1-20230105-D00037.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00038" num="00038"><img id="EMI-D00038" he="182.12mm" wi="157.99mm" file="US20230005096A1-20230105-D00038.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00039" num="00039"><img id="EMI-D00039" he="128.10mm" wi="107.44mm" file="US20230005096A1-20230105-D00039.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00040" num="00040"><img id="EMI-D00040" he="222.50mm" wi="146.56mm" file="US20230005096A1-20230105-D00040.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00041" num="00041"><img id="EMI-D00041" he="180.85mm" wi="107.87mm" file="US20230005096A1-20230105-D00041.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00042" num="00042"><img id="EMI-D00042" he="231.73mm" wi="148.17mm" file="US20230005096A1-20230105-D00042.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00043" num="00043"><img id="EMI-D00043" he="231.73mm" wi="146.90mm" file="US20230005096A1-20230105-D00043.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00044" num="00044"><img id="EMI-D00044" he="227.75mm" wi="146.73mm" file="US20230005096A1-20230105-D00044.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00045" num="00045"><img id="EMI-D00045" he="227.67mm" wi="144.70mm" file="US20230005096A1-20230105-D00045.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00046" num="00046"><img id="EMI-D00046" he="228.43mm" wi="159.26mm" file="US20230005096A1-20230105-D00046.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00047" num="00047"><img id="EMI-D00047" he="225.81mm" wi="144.36mm" file="US20230005096A1-20230105-D00047.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00048" num="00048"><img id="EMI-D00048" he="191.26mm" wi="133.35mm" orientation="landscape" file="US20230005096A1-20230105-D00048.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading><p id="p-0002" num="0001">This application claims the benefit of U.S. Provisional Patent Application No. 63/214,205, filed Jun. 23, 2021, entitled &#x201c;MEMORY ALLOCATION USING GRAPHS,&#x201d; the disclosure of which is herein incorporated by reference in its entirety. This application is also related to and incorporates by reference for all purposes the full disclosure of co-pending U.S. patent application Ser. No. ______, filed concurrently herewith, entitled &#x201c;MEMORY DEALLOCATION USING GRAPHS&#x201d; (Attorney Docket No. 0112912-380US0).</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">FIELD</heading><p id="p-0003" num="0002">At least one embodiment pertains to processing resources used to allocate memory using a data structure representing operations and dependencies among the operations. For example, at least one embodiment pertains to processors or computing systems used to allocate memory using a data structure representing operations and dependencies among the operations that implement various novel techniques described herein.</p><heading id="h-0003" level="1">BACKGROUND</heading><p id="p-0004" num="0003">Performing operations using a data structure representing the operations and dependencies among the operations can often require allocated memory. However, in various cases, memory must be allocated outside of a data structure representing operations and dependencies among the operations, which can require additional computing resources. Techniques to allocate memory using a data structure representing operations and dependencies among the operations may therefore be improved using CUDA or other parallel computing platform code.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0005" num="0004"><figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates an example of memory allocation in a graph, according to at least one embodiment;</p><p id="p-0006" num="0005"><figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates an example of launching a graph, according to at least one embodiment;</p><p id="p-0007" num="0006"><figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates an example of a graph and memory allocation, according to at least one embodiment;</p><p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. <b>4</b></figref> illustrates an example of a fork in a graph, according to at least one embodiment;</p><p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. <b>5</b></figref> illustrates an example of a block refcount array, according to at least one embodiment;</p><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. <b>6</b></figref> illustrates an example of virtual address reservation, according to at least one embodiment;</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. <b>7</b></figref> illustrates an example of address reuse, according to at least one embodiment;</p><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>8</b></figref> illustrates an example of physical memory sharing between graphs, according to at least one embodiment;</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. <b>9</b></figref> illustrates an example of a process of allocating memory using a graph, according to at least one embodiment;</p><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. <b>10</b></figref> illustrates an example of a process of deallocating memory using a graph, according to at least one embodiment;</p><p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. <b>11</b></figref> illustrates an exemplary data center, in accordance with at least one embodiment;</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. <b>12</b></figref> illustrates a processing system, in accordance with at least one embodiment;</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>13</b></figref> illustrates a computer system, in accordance with at least one embodiment;</p><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>14</b></figref> illustrates a system, in accordance with at least one embodiment;</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>15</b></figref> illustrates an exemplary integrated circuit, in accordance with at least one embodiment;</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>16</b></figref> illustrates a computing system, according to at least one embodiment;</p><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. <b>17</b></figref> illustrates an APU, in accordance with at least one embodiment;</p><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. <b>18</b></figref> illustrates a CPU, in accordance with at least one embodiment;</p><p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. <b>19</b></figref> illustrates an exemplary accelerator integration slice, in accordance with at least one embodiment;</p><p id="p-0024" num="0023"><figref idref="DRAWINGS">FIGS. <b>20</b>A and <b>20</b>B</figref> illustrate exemplary graphics processors, in accordance with at least one embodiment;</p><p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. <b>21</b>A</figref> illustrates a graphics core, in accordance with at least one embodiment;</p><p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. <b>21</b>B</figref> illustrates a GPGPU, in accordance with at least one embodiment;</p><p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. <b>22</b>A</figref> illustrates a parallel processor, in accordance with at least one embodiment;</p><p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. <b>22</b>B</figref> illustrates a processing cluster, in accordance with at least one embodiment;</p><p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. <b>22</b>C</figref> illustrates a graphics multiprocessor, in accordance with at least one embodiment;</p><p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. <b>23</b></figref> illustrates a graphics processor, in accordance with at least one embodiment;</p><p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. <b>24</b></figref> illustrates a processor, in accordance with at least one embodiment;</p><p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. <b>25</b></figref> illustrates a processor, in accordance with at least one embodiment;</p><p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. <b>26</b></figref> illustrates a graphics processor core, in accordance with at least one embodiment;</p><p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. <b>27</b></figref> illustrates a PPU, in accordance with at least one embodiment;</p><p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. <b>28</b></figref> illustrates a GPC, in accordance with at least one embodiment;</p><p id="p-0036" num="0035"><figref idref="DRAWINGS">FIG. <b>29</b></figref> illustrates a streaming multiprocessor, in accordance with at least one embodiment;</p><p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. <b>30</b></figref> illustrates a software stack of a programming platform, in accordance with at least one embodiment;</p><p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. <b>31</b></figref> illustrates a CUDA implementation of a software stack of <figref idref="DRAWINGS">FIG. <b>30</b></figref>, in accordance with at least one embodiment;</p><p id="p-0039" num="0038"><figref idref="DRAWINGS">FIG. <b>32</b></figref> illustrates a ROCm implementation of a software stack of <figref idref="DRAWINGS">FIG. <b>30</b></figref>, in accordance with at least one embodiment;</p><p id="p-0040" num="0039"><figref idref="DRAWINGS">FIG. <b>33</b></figref> illustrates an OpenCL implementation of a software stack of <figref idref="DRAWINGS">FIG. <b>30</b></figref>, in accordance with at least one embodiment;</p><p id="p-0041" num="0040"><figref idref="DRAWINGS">FIG. <b>34</b></figref> illustrates software that is supported by a programming platform, in accordance with at least one embodiment;</p><p id="p-0042" num="0041"><figref idref="DRAWINGS">FIG. <b>35</b></figref> illustrates compiling code to execute on programming platforms of <figref idref="DRAWINGS">FIGS. <b>30</b>-<b>33</b></figref>, in accordance with at least one embodiment;</p><p id="p-0043" num="0042"><figref idref="DRAWINGS">FIG. <b>36</b></figref> illustrates in greater detail compiling code to execute on programming platforms of <figref idref="DRAWINGS">FIGS. <b>30</b>-<b>33</b></figref>, in accordance with at least one embodiment;</p><p id="p-0044" num="0043"><figref idref="DRAWINGS">FIG. <b>37</b></figref> illustrates translating source code prior to compiling source code, in accordance with at least one embodiment;</p><p id="p-0045" num="0044"><figref idref="DRAWINGS">FIG. <b>38</b>A</figref> illustrates a system configured to compile and execute CUDA source code using different types of processing units, in accordance with at least one embodiment;</p><p id="p-0046" num="0045"><figref idref="DRAWINGS">FIG. <b>38</b>B</figref> illustrates a system configured to compile and execute CUDA source code of <figref idref="DRAWINGS">FIG. <b>38</b>A</figref> using a CPU and a CUDA-enabled GPU, in accordance with at least one embodiment;</p><p id="p-0047" num="0046"><figref idref="DRAWINGS">FIG. <b>38</b>C</figref> illustrates a system configured to compile and execute CUDA source code of <figref idref="DRAWINGS">FIG. <b>38</b>A</figref> using a CPU and a non-CUDA-enabled GPU, in accordance with at least one embodiment;</p><p id="p-0048" num="0047"><figref idref="DRAWINGS">FIG. <b>39</b></figref> illustrates an exemplary kernel translated by CUDA-to-HIP translation tool of <figref idref="DRAWINGS">FIG. <b>38</b>C</figref>, in accordance with at least one embodiment;</p><p id="p-0049" num="0048"><figref idref="DRAWINGS">FIG. <b>40</b></figref> illustrates non-CUDA-enabled GPU of <figref idref="DRAWINGS">FIG. <b>38</b>C</figref> in greater detail, in accordance with at least one embodiment;</p><p id="p-0050" num="0049"><figref idref="DRAWINGS">FIG. <b>41</b></figref> illustrates how threads of an exemplary CUDA grid are mapped to different compute units of <figref idref="DRAWINGS">FIG. <b>40</b></figref>, in accordance with at least one embodiment; and</p><p id="p-0051" num="0050"><figref idref="DRAWINGS">FIG. <b>42</b></figref> illustrates how to migrate existing CUDA code to Data Parallel C++ code, in accordance with at least one embodiment.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0005" level="1">DETAILED DESCRIPTION</heading><p id="p-0052" num="0051">In at least one embodiment, one or more programming models utilize one or more data structures representing operations and dependencies among said operations to perform said operations. In at least one embodiment, a graph is a data structure that represents operations and dependencies among said operations, and comprises at least a node, also referred to as a graph code node, which is a set of data or a data structure that encodes information regarding an operation. In at least one embodiment, while techniques described herein may relate to graphs, techniques described herein are applicable to any suitable data structure of any suitable programming model that represents, encodes, or otherwise stores operations and/or dependencies among said operations. In at least one embodiment, one or more programming models include models such as a Compute Unified Device Architecture (CUDA) model, Heterogeneous compute Interface for Portability (HIP) model, oneAPI model, various hardware accelerator programming models, and/or variations thereof.</p><p id="p-0053" num="0052">In at least one embodiment, said graph indicates a series of operations that are performed by one or more devices, such as a central processing unit (CPU), graphics processing unit (GPU), general-purpose GPU (GPGPU), parallel processing unit (PPU), and/or variations thereof. In at least one embodiment, said graph encodes a series of operations, such as kernel launches, connected by dependencies. In at least one embodiment, dependencies of said graph are defined separately from said graph's execution. In at least one embodiment, said graph is defined once and can be launched one or more times on one or more devices.</p><p id="p-0054" num="0053">In at least one embodiment, said graph indicates operations through nodes of said graph, in which each node of said graph corresponds to an operation and dependencies between operations form edges of said graph. In at least one embodiment, dependencies constrain execution sequences of operations. In at least one embodiment, an operation can be scheduled at any time once nodes on which it depends on have completed (e.g., operations indicated by nodes have been executed/performed). In at least one embodiment, operations indicated by nodes can include operations such as kernels, CPU function calls, memory management/manipulation operations, waiting on an event, recording an event, signaling an external semaphore, waiting on an external semaphore, as well as other graphs (e.g., child graphs). In at least one embodiment, graphs are created and modified by one or more systems through various programming model application programming interface (API) functions. In at least one embodiment, operations of said graph are executed by one or more systems through various programming model API functions.</p><p id="p-0055" num="0054">In at least one embodiment, one or more systems perform various operations and/or techniques described herein, and include systems such as drivers, programming model libraries, and/or variations thereof, which may be associated with one or more programming models such as CUDA, HIP, oneAPI, and/or variations thereof. In at least one embodiment, a driver, also referred to as a device driver, is a computer program that provides a software interface to one or more devices (e.g., a GPU). In at least one embodiment, one or more systems provide functionality to allocate memory, free allocated memory, manage/utilize allocated memory, and/or various other memory management/utilization operations using graphs. In at least one embodiment, one or more systems provide functionality to perform various memory management/utilization operations in connection with one or more GPUs (e.g., allocate memory on one or more GPUs, free allocated memory on one or more GPUs, manage/utilize allocated memory on one or more GPUs, and/or other suitable operations) using said graph, in which said one or more GPUs can be utilized to perform various operations of said graph. In at least one embodiment, one or more systems provide an API, which refers to a set of definitions, functions, and/or protocols, for utilizing various functionalities.</p><p id="p-0056" num="0055">In at least one embodiment, one or more systems associate memory with said graph through an explicit node creation interface (e.g., one or more APIs, such as those described herein). In at least one embodiment, a graph code node to allocate memory is referred to as a MemAlloc node, or any suitable notation, and a graph code node to deallocate memory is referred to as a MemFree node, or any suitable notation. In at least one embodiment, MemAlloc nodes perform one or more memory allocation operations that create an allocation, returning an allocation's address for use. In at least one embodiment, MemFree nodes perform one or more memory free operations that free an allocation. In at least one embodiment, to correctly access an allocation in said graph, a task must be ordered after MemAlloc node which created said allocation but before any MemFree node which frees it. In at least one embodiment, one or more systems provide one or more APIs to add MemAlloc node and/or MemFree node to said graph. In at least one embodiment, one or more systems associate memory with said graph through a stream capture interface, in which various stream-based API calls for allocating memory and freeing allocated memory are converted into MemAlloc and MemFree nodes, respectively.</p><p id="p-0057" num="0056">In at least one embodiment, one or more systems provide access to an allocation which isn't freed in an allocating graph after said graph is executed, until one or more users free said allocation by at least launching said graph which contains MemFree node for said allocation and/or passing said allocation to one or more API calls for freeing allocated memory (e.g., outside of a capture). In at least one embodiment, one or more systems track allocations such that various operations which reference allocated memory are correctly validated and allowed to access said allocation, said allocation maintains ownership of underlying physical memory it uses, and/or upon being freed, said physical memory can be reused.</p><p id="p-0058" num="0057">In at least one embodiment, when MemAlloc node is created, one or more systems attempt to reuse memory which was freed by any previous MemFree nodes. In at least one embodiment, one or more systems track a set of paths through said graph, in which each path is associated with a particular data structure. In at least one embodiment, MemAlloc node can reuse memory from its own path without restriction, but when attempting to reuse memory from other paths, it can allocate only a subset of said memory, based on when two paths last diverged.</p><p id="p-0059" num="0058">In at least one embodiment, one or more systems provide functionality for graphs to exclusively own virtual memory which they use for allocations, but share physical memory used to back said virtual memory. In at least one embodiment, one or more systems provide functionality such that a total amount of memory allocated by all graphs can exceed an amount of memory present on a GPU.</p><p id="p-0060" num="0059">In at least one embodiment, when said graph is instantiated (e.g., made runnable), one or more systems determine said graph's total memory footprint and represent said total memory footprint as a set of fixed-sized virtual memory blocks. In at least one embodiment, upon launch, one or more systems map physical memory to each of these virtual memory blocks. In at least one embodiment, if a subsequent graph is launched in a same stream, it can reuse these physical blocks, because graphs will execute sequentially. In at least one embodiment, one or more systems can remap same physical memory blocks to several virtual memory blocks, which can be referred to as virtual aliasing.</p><p id="p-0061" num="0060">In at least one embodiment, an allocation which is allocated in one graph but freed in another utilizes additional tracking because physical memory said allocation uses cannot be reused until said allocation is explicitly freed, whereas internally-contained allocations can be reused once said graph finishes. In at least one embodiment, available physical memory is associated by one or more systems with a set of events (e.g., graph completion and/or one or more API calls to free allocated memory). In at least one embodiment, when said graph launches, said graph must also wait for events such that said graph has exclusive access to physical memory. In at least one embodiment, to reduce an amount of synchronization required, one or more systems manage physical memory on a per-stream basis. In at least one embodiment, two graphs launching in a same stream may use a same memory, because those graphs can serialize. In at least one embodiment, two graphs launching in different streams will use different memory, as each stream maintains a separate cache of physical blocks, which enables said graphs to continue to execute concurrently.</p><p id="p-0062" num="0061">In at least one embodiment, one or more systems provide functionality for graph ordered memory allocation, also referred to as graph allocation. In at least one embodiment, one or more systems provide nodes for various graph memory allocation operations. In at least one embodiment, MemAlloc node, which allocates memory, and/or MemFree node, which frees memory allocated by MemAlloc nodes, are collectively referred to as memory nodes. In at least one embodiment, one or more systems provide functionality to create memory nodes using explicit API functions, stream capture, and/or variations thereof.</p><p id="p-0063" num="0062"><figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates an example <b>100</b> of memory allocation in a graph, according to at least one embodiment. In at least one embodiment, example <b>100</b> comprises a visual representation of said graph comprising nodes. In at least one embodiment, said graph indicates various operations to be performed on one or more devices. In at least one embodiment, said graph, which can be referred to in reference to a programming model (e.g., CUDA, HIP, oneAPI, and/or variations thereof), is a directed acyclic graph, or any suitable graph, whose nodes represent work and edges represent dependencies between respective pairs of work represented by nodes connected by edges.</p><p id="p-0064" num="0063">In at least one embodiment, said graph indicates operations that utilize various user specified data and/or user managed resources, also referred to as user objects, or more generally as objects. In at least one embodiment, objects include kernel arguments, host function arguments, workspace buffers, and/or other data that is utilized throughout execution of one or more operations of said graph. In at least one embodiment, graphs are created through one or more operations referred to as stream capture. In at least one embodiment, stream capture encodes workloads indicated by a stream into said graph. In at least one embodiment, a stream refers to a sequence of operations that execute on a processing unit, such as a GPU, PPU, CPU, and/or variations thereof. In at least one embodiment, a stream capture sequence refers to a sequence of operations that are utilized to generate said graph using stream capture. In at least one embodiment, a capturing stream refers to a stream of one or more operations associated with stream capture (e.g., one or more operations that are to be captured in said graph). In at least one embodiment, one or more systems issue or otherwise provide said stream to a processing unit, in which said processing unit performs one or more operations of said stream. In at least one embodiment, a program can have multiple streams. In at least one embodiment, streams can also wait on events, which can represent completion of work in another stream.</p><p id="p-0065" num="0064">In at least one embodiment, graphs are created and modified through various API functions, also referred to as APIs. In at least one embodiment, as an illustrative example, graphs are created through one or more API functions that create said graph, add nodes (e.g., child graph nodes, empty nodes, event record nodes, event wait nodes, external semaphore signal nodes, external semaphore wait nodes, host execution nodes, kernel execution nodes, memory copy nodes, memory set nodes, and/or variations thereof) to said graph, add dependencies to said graph, and/or variations thereof. In at least one embodiment, various operations are performed by one or more systems on graphs, such as adding nodes, removing nodes, modifying nodes, copying graphs, deleting graphs, and/or variations thereof, through any suitable API functions. In at least one embodiment, graphs are modified or otherwise managed by one or more systems in any suitable manner using any suitable API functions, software libraries, and/or variations thereof.</p><p id="p-0066" num="0065">In at least one embodiment, alloc <b>102</b>, alloc <b>108</b>, and alloc <b>118</b> represent memory allocation operations. In at least one embodiment, alloc <b>102</b>, alloc <b>108</b>, and alloc <b>118</b> are MemAlloc nodes. In at least one embodiment, one or more systems provide an API to generate one or more graph code nodes to allocate memory (e.g., alloc <b>102</b>, alloc <b>108</b>, and alloc <b>118</b>), as described in further detail herein. In at least one embodiment, kernel <b>104</b>, kernel <b>110</b>, kernel <b>114</b>, kernel <b>116</b>, and kernel <b>120</b> represent kernel operations. In at least one embodiment, a kernel is a function that is executed on one or more devices, such as a GPU. In at least one embodiment, kernel <b>104</b>, kernel <b>110</b>, kernel <b>114</b>, kernel <b>116</b>, and kernel <b>120</b> are nodes that represent execution of kernels. In at least one embodiment, free <b>106</b>, free <b>112</b>, and free <b>122</b> represent memory de-allocation operations, also referred to as memory freeing operations. In at least one embodiment, free <b>106</b>, free <b>112</b>, and free <b>122</b> are MemFree nodes. In at least one embodiment, one or more systems provide an API to generate one or more graph code nodes to deallocate memory (e.g., free <b>106</b>, free <b>112</b>, and free <b>122</b>), as described in further detail herein.</p><p id="p-0067" num="0066">In at least one embodiment, as an illustrative example, said graph depicted in <figref idref="DRAWINGS">FIG. <b>1</b></figref> is created using stream capture, in which one or more systems generate said graph by capturing one or more operations of said stream, in which one or more nodes of said graph correspond to said one or more operations. In at least one embodiment, as an illustrative example, said graph depicted in <figref idref="DRAWINGS">FIG. <b>1</b></figref> is created using various API functions, in which one or more systems generate said graph by utilizing one or more APIs to create said graph and add one or more nodes such as those depicted in <figref idref="DRAWINGS">FIG. <b>1</b></figref> to said graph.</p><p id="p-0068" num="0067">In at least one embodiment, one or more systems provide functionality to reuse memory within said graph. In at least one embodiment, when MemAlloc node is created, it attempts to reuse memory which was freed by MemFree nodes which it (e.g., potentially indirectly) depends upon. In at least one embodiment, graph allocations may or may not be made with any runtime ordering information. In at least one embodiment, one or more systems select addresses of allocations at node creation time based on at least a topology of said graph. In at least one embodiment, allocations, and how they can be reused, determine a graph's memory footprint, in which one or more systems allocate to said graph before execution.</p><p id="p-0069" num="0068">In at least one embodiment, one or more systems, before executing said graph, back said graph's memory footprint with physical memory. In at least one embodiment, physical memory utilized for backings is owned by a launching stream. In at least one embodiment, one or more systems provide functionality for several graphs which are launched in a same stream (e.g., that have only internally-accessible memory allocations) to use a same physical memory, as execution of items in said stream are serialized. In at least one embodiment, one or more systems support graph-ordered allocations whose lifetime extends beyond said graph in which said allocations were allocated.</p><p id="p-0070" num="0069">In at least one embodiment, one or more systems provide functionality to utilize memory nodes in graphs and capture stream ordered API calls. In at least one embodiment, there are two types of graph allocation, which can depend on how one or more users allocate/free memory. In at least one embodiment, intra-graph allocations refer to allocations in which MemAlloc and MemFree nodes exist in a same graph. In at least one embodiment, inter-graph allocations refer to allocations in which MemAlloc nodes do not have a corresponding MemFree node in a same graph. In at least one embodiment, a graph, such as those described herein, that comprises MemAlloc node is referred to as a graph which owns an allocation. In at least one embodiment, through instantiation, multiple graphs can own a same allocation. In at least one embodiment, referring to <figref idref="DRAWINGS">FIG. <b>1</b></figref>, example <b>100</b> illustrates intra-graph allocations.</p><p id="p-0071" num="0070">In at least one embodiment, graph allocations have at least three lifetimes, or any suitable number of lifetimes. In at least one embodiment, a first two lifetimes are associated with a construction of said graph and a final lifetime is associated with an execution of said graph. In at least one embodiment, an API lifetime, also referred to as a first lifetime, refers to period of time on a host when it is valid to pass an allocation to graph nodes. In at least one embodiment, a host refers to a CPU and its memory, and a device refers to a GPU and its memory. In at least one embodiment, API lifetime starts when MemAlloc node is created and ends when MemFree node is created in an allocating graph and/or, if that does not occur, when owning graphs are destroyed.</p><p id="p-0072" num="0071">In at least one embodiment, a topological lifetime, also referred to as a second lifetime, refers to a period of time in which a set of nodes in said graph can access allocations. In at least one embodiment, if said graph contains MemAlloc node, a topological lifetime includes only those nodes which are descendants of said MemAlloc node. In at least one embodiment, if said graph contains MemFree node, then a topological lifetime includes only those nodes which are ancestors of said MemFree node. In at least one embodiment, if said graph contains both MemAlloc and MemFree node, said MemFree node must be a descendant of said MemAlloc node.</p><p id="p-0073" num="0072">In at least one embodiment, an execution lifetime, also referred to as a final lifetime, is a period of time when an allocation is accessible to operations of one or more systems of one or more programming models (e.g., operations such as kernels, memory copies, and/or variations thereof). In at least one embodiment, for intra-graph allocations, an execution lifetime is completely contained within said graph, starting when graph execution reaches MemAlloc node and ending when it reaches MemFree node. In at least one embodiment, for inter-graph allocations, an execution lifetime begins when graph execution reaches MemAlloc node, but extends beyond said graph's execution, until said allocation is freed (e.g., by launching said graph with a corresponding MemFree node). In at least one embodiment, one or more systems provide functionality for inter-graph allocations to be accessed by various programming model APIs during their execution lifetimes. In at least one embodiment, allocations have externally visible execution lifetimes.</p><p id="p-0074" num="0073">In at least one embodiment, one or more systems launch said graph on one or more devices, such as a GPU, in which when said graph is launched, said one or more devices perform operations indicated by nodes of said graph in any suitable order, such as sequential, parallel, and/or variations thereof. In at least one embodiment, referring to <figref idref="DRAWINGS">FIG. <b>1</b></figref>, alloc <b>102</b> causes a device such as those described herein to allocate memory, in which said allocated memory has an address of &#x201c;0x1000,&#x201d; kernel <b>104</b> causes said device to perform one or more processes indicated by kernel <b>104</b>, free <b>106</b> causes said device to free memory allocated through alloc <b>102</b> (e.g., at address &#x201c;0x1000&#x201d;), alloc <b>108</b> causes said device to allocate memory, in which said allocated memory has an address of &#x201c;0x1000,&#x201d; as alloc <b>108</b> can reuse freed memory, kernel <b>110</b> causes said device to perform one or more processes indicated by kernel <b>110</b>, free <b>112</b> causes said device to free memory allocated through alloc <b>108</b> (e.g., at address &#x201c;0x1000&#x201d;), kernel <b>114</b> causes said device to perform one or more processes indicated by kernel <b>114</b>, kernel <b>116</b> causes said device to perform one or more processes indicated by kernel <b>116</b>, alloc <b>118</b> causes said device to allocate memory, in which said allocated memory has an address of &#x201c;0x2000,&#x201d; as alloc <b>118</b> can't reuse memory at address &#x201c;0x1000&#x201d; as it may have not been freed, kernel <b>120</b> causes said device to perform one or more processes indicated by kernel <b>120</b>, and free <b>122</b> causes said device to free memory allocated through alloc <b>118</b> (e.g., at address &#x201c;0x2000&#x201d;).</p><p id="p-0075" num="0074">In at least one embodiment, one or more systems define MemAlloc node parameters through following code, although any variations thereof can be utilized:</p><p id="p-0076" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="189pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;</entry><entry>&#x201c;typedef struct CUDA_MEM_ALLOC_NODE_PARAMS_st {</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;CUmemPoolProps poolProps;</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;const CUmemAccessDesc *accessDescs;</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;size_t accessDescCount;</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;size_t bytesize;</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;CUdeviceptr dptr;</entry></row><row><entry/><entry>} CUDA_MEM_ALLOC_NODE_PARAMS;&#x201d;</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>and API function to generate one or more graph code nodes to allocate memory (e.g., MemAlloc node) in said graph through following code, although any variations thereof can be utilized:</p><p id="p-0077" num="0000"><tables id="TABLE-US-00002" num="00002"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="21pt" align="left"/><colspec colname="2" colwidth="182pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2003;</entry><entry>&#x201c;CUresult cuGraphAddMemAllocNode(</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;&#x2003;CUgraphNode *phGraphNode,</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;&#x2003;CUgraph hGraph,</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;&#x2003;const CUgraphNode *dependencies,</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;&#x2003;size_t numDependencies,</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;&#x2003;CUDA_MEM_ALLOC_NODE_PARAMS *params);&#x201d;</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>in which cuGraphAddMemAllocNode creates MemAlloc node and an allocation, and returns an address of said allocation in params-&#x3e;dptr. In at least one embodiment, API function to generate one or more graph code nodes to allocate memory is denoted as cuGraphAddMemAllocNode, GraphAddMemAllocNode, and/or variations thereof. In at least one embodiment, API function to generate one or more graph code nodes to allocate memory causes one or more systems to generate or otherwise instantiate MemAlloc node in said graph. In at least one embodiment, it should be noted that an API function, such as those described herein, can be denoted in any suitable manner using any suitable terminology, which may or may not be related to one or more functionalities of said API function. In at least one embodiment, use of an API function such as those described herein is referred to as an API call.</p><p id="p-0078" num="0075">In at least one embodiment, one or more systems utilize parameters described in a following table, although any variations thereof can be utilized:</p><p id="p-0079" num="0000"><tables id="TABLE-US-00003" num="00003"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="84pt" align="left"/><colspec colname="2" colwidth="133pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>Parameter</entry><entry>Description</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>phGraphNode</entry><entry>Where a handle to a newly-created</entry></row><row><entry/><entry>MemAlloc node will be written.</entry></row><row><entry>hGraph</entry><entry>Said graph into which a node is being placed</entry></row><row><entry>dependencies</entry><entry>An array of nodes upon which a newly</entry></row><row><entry/><entry>created node will depend. This dependency</entry></row><row><entry/><entry>information is used when determining</entry></row><row><entry/><entry>memory availability at node creation time.</entry></row><row><entry>numDependencies</entry><entry>A number of nodes in dependencies.</entry></row><row><entry>params-&#x3e;poolProps</entry><entry>Properties of a pool from which memory</entry></row><row><entry/><entry>must be allocated. This allows a user to</entry></row><row><entry/><entry>specify a device upon which memory</entry></row><row><entry>params-&#x3e;accessDescs</entry><entry>An array of structures which specify an</entry></row><row><entry/><entry>allowed access type. These access type</entry></row><row><entry/><entry>structures can be used to specify that a</entry></row><row><entry/><entry>peer GPU be able to access an allocation.</entry></row><row><entry>params-&#x3e;accessDescCount</entry><entry>A number of mapping structures.</entry></row><row><entry>params-&#x3e;bytesize</entry><entry>A size of an allocation, in bytes.</entry></row><row><entry>params-&#x3e;dptr</entry><entry>Out. An address of said graph allocation.</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>In at least one embodiment, upon MemAlloc node's creation, an allocation's API lifetime begins. In at least one embodiment, at API lifetime, an allocation can be used by other nodes in a same or other graphs. In at least one embodiment, one or more users enforce a topological lifetime of an allocation.</p><p id="p-0080" num="0076">In at least one embodiment, graph allocations can be peer-accessible, which refers to allowing graphs with kernels from multiple devices to access a same graph ordered memory allocations. In at least one embodiment, when said graph allocation is created, params-&#x3e;accessDescs specifies peers onto which said allocation must also be mapped. In at least one embodiment, an allocation may be mapped on more GPUs than specified to accommodate sharing physical pages with another graph owned allocation. In at least one embodiment, accessDescs describes a minimum access required.</p><p id="p-0081" num="0077">In at least one embodiment, one or more systems define API function to generate one or more graph code nodes to deallocate memory (e.g., MemFree node) in said graph through following code, although any variations thereof can be utilized:</p><p id="p-0082" num="0000"><tables id="TABLE-US-00004" num="00004"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="21pt" align="left"/><colspec colname="1" colwidth="42pt" align="left"/><colspec colname="2" colwidth="154pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2003;</entry><entry>&#x201c;CUresult cuGraphAddMemFreeNode(</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;&#x2003;CUgraphNode *phGraphNode,</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;&#x2003;CUgraph hGraph,</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;&#x2003;const CUgraphNode *dependencies,</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;&#x2003;size_t numDependencies,</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;&#x2003;CUdeviceptr dptr)&#x201d;</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>in which cuGraphAddMemFreeNode creates MemFree node which frees an allocation from MemAlloc node. In at least one embodiment, API function to generate one or more graph code nodes to deallocate memory is denoted as cuGraphAddMemFreeNode, GraphAddMemFreeNode, and/or variations thereof. In at least one embodiment, API function to generate one or more graph code nodes to deallocate memory causes one or more systems to generate or otherwise instantiate MemFree node in said graph.</p><p id="p-0083" num="0078">In at least one embodiment, one or more systems utilize parameters described in a following table, although any variations thereof can be utilized:</p><p id="p-0084" num="0000"><tables id="TABLE-US-00005" num="00005"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="70pt" align="left"/><colspec colname="2" colwidth="133pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Parameter</entry><entry>Description</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>phGraphNode</entry><entry>Where a handle to a newly-created</entry></row><row><entry/><entry/><entry>MemFree node will be written.</entry></row><row><entry/><entry>hGraph</entry><entry>Said graph into which a node is being</entry></row><row><entry/><entry/><entry>placed.</entry></row><row><entry/><entry>dependencies</entry><entry>An array of nodes upon which a node will</entry></row><row><entry/><entry/><entry>depend.</entry></row><row><entry/><entry>numDependencies</entry><entry>A number of nodes in dependencies.</entry></row><row><entry/><entry>Dptr</entry><entry>An address of an allocation being freed.</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>In at least one embodiment, all MemFree nodes must be descendants of their allocation's MemAlloc node.</p><p id="p-0085" num="0079">In at least one embodiment, every allocation starts off inter-graph, as each allocation has no corresponding free. In at least one embodiment, if an allocation is freed in its owning graph, it becomes an intra-graph allocation, and said allocation cannot be freed in subsequent attempts. In at least one embodiment, an allocation with no free can become permanently inter-graph if said allocation is freed in said graph other than its owner and/or if an owning graph is instantiated. In at least one embodiment, once an allocation becomes permanently inter-graph, one or more systems prevent subsequent attempts to free said allocation in an owning graph, however, other graphs may free said allocation. In at least one embodiment, when graphs are launched, one or more systems perform checks to ensure that allocations aren't being double-allocated or double-freed.</p><p id="p-0086" num="0080">In at least one embodiment, when said graph is launched, and said graph's execution reaches a point of an inter-graph allocation's MemAlloc node, that allocation's execution lifetime begins, and during its execution lifetime, said allocation can be passed to other operations ordered after said graph's execution (e.g., such as other graphs which reference said allocation or stream work).</p><p id="p-0087" num="0081"><figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates an example <b>200</b> of launching a graph, according to at least one embodiment. In at least one embodiment, example <b>200</b> includes states of launching one or more graphs at a first time <b>202</b> (e.g., t=t<sub>0</sub>), a subsequent second time <b>204</b> (e.g., t=t<sub>1</sub>), and a subsequent third time <b>206</b> (e.g., t=t<sub>2</sub>). In at least one embodiment, one or more graphs depicted in <figref idref="DRAWINGS">FIG. <b>2</b></figref> are graphs such as those described in connection with <figref idref="DRAWINGS">FIG. <b>1</b></figref> and elsewhere herein. In at least one embodiment, one or more systems obtain code utilizing one or more APIs to perform at least execution of said graph comprising a memory allocation operation, a memory copy operation, which may or may not be associated with said graph, and execution of another graph comprising a memory free operation, compile said code into executable code, and execute said executable code on one or more devices.</p><p id="p-0088" num="0082">In at least one embodiment, at first time <b>202</b>, one or more systems launch said graph comprising a memory allocation operation on a device, such as a GPU. In at least one embodiment, at first time <b>202</b>, said graph causes memory to be allocated on said device. In at least one embodiment, at second time <b>204</b>, a memory copy operation can access memory allocated at first time <b>202</b>. In at least one embodiment, said memory copy operation refers to an operation that copies data between a device and another device. In at least one embodiment, said memory copy operation is executed in connection with said device through said graph, through one or more APIs, or any suitable manner, which may or may not involve use of graphs. In at least one embodiment, at third time <b>206</b>, one or more systems launch another graph comprising a memory free operation on said device. In at least one embodiment, at third time <b>206</b>, said other graph causes allocated memory to be freed, in which said allocation's execution lifetime ends. In at least one embodiment, at third time <b>206</b>, while <figref idref="DRAWINGS">FIG. <b>2</b></figref> depicts said memory free operation associated with said other graph, said memory free operation can be executed in any suitable manner, such as through said other graph, through one or more APIs, or any suitable manner, which may or may not involve use of graphs.</p><p id="p-0089" num="0083">In at least one embodiment, an allocation's execution lifetime can be ended by one or more API calls to free allocated memory outside of said graph, and/or by launching said graph which contains MemFree node for said allocation. In at least one embodiment, said allocation is freed in several graphs. In at least one embodiment, to free said allocation after each launch of an allocating graph, one or more graphs can be launched to free said allocation. In at least one embodiment, one or more systems prevent graph launch which attempts to allocate a still-allocated allocation, although in at least one embodiment, such operations are permitted. In at least one embodiment, one or more systems prevent a launch which attempts to free an already-freed allocation, although in at least one embodiment, such operations are permitted. In at least one embodiment, said allocation may or may not be accessed by various operations outside of its execution lifetime.</p><p id="p-0090" num="0084">In at least one embodiment, each allocation is matched with a free operation. In at least one embodiment, for intra-graph allocation, an owning graph contains both MemAlloc and MemFree nodes. In at least one embodiment, for inter-graph allocations, one or more free operations (e.g., MemFree) are executed after each execution of an allocating graph. In at least one embodiment, one or more systems define behavior of allocated memory freeing operations, also referred to as frees, in connection with a following table, although any variations thereof can be utilized:</p><p id="p-0091" num="0000"><tables id="TABLE-US-00006" num="00006"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="63pt" align="left"/><colspec colname="2" colwidth="49pt" align="left"/><colspec colname="3" colwidth="105pt" align="left"/><thead><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row><row><entry>Allocation Method</entry><entry>Free Method</entry><entry>Behavior</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>MemAlloc node</entry><entry>MemFree node</entry><entry>Intra-graph allocation. Cannot be</entry></row><row><entry/><entry>in a same graph</entry><entry>referenced outside of graph.</entry></row><row><entry>MemAlloc node</entry><entry>MemFree node</entry><entry>Inter-graph allocation. After</entry></row><row><entry/><entry>in a different</entry><entry>an owning graph is executed, an</entry></row><row><entry/><entry>graph</entry><entry>allocation is accessible everywhere</entry></row><row><entry>cudaMallocAsync</entry><entry>MemFree node</entry><entry>Not supported.</entry></row><row><entry>MemAlloc node</entry><entry>cudaFreeAsync</entry><entry>cudaFreeAsync frees a node as</entry></row><row><entry/><entry/><entry>though it were said graph with a</entry></row><row><entry/><entry/><entry>single MemFree node.</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>in which &#x201c;cudaMallocAsync&#x201d; denotes an API function to allocate memory and &#x201c;cudaFreeAsync&#x201d; denotes an API function to free allocated memory.</p><p id="p-0092" num="0085">In at least one embodiment, one or more systems define an API function to use stream memory through following code, although any variations thereof can be utilized:<ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0086">&#x201c;CUresult cuGraphUseStreamMem(CUgraphExec graphExec, CUstream stream)&#x201d;<br/>in which said API function indicates to one or more systems that a specified graph will be launched on a specified stream, said API function enables one or more systems to use memory owned by a stream to satisfy a memory requirements of said graph, and/or said API function is utilized to reduce latency of a subsequent launch of said graph into a stream. In at least one embodiment, one or more systems utilize parameters described in a following table, although any variations thereof can be utilized:</li>    </ul>    </li></ul></p><p id="p-0093" num="0000"><tables id="TABLE-US-00007" num="00007"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="21pt" align="left"/><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="140pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Parameter</entry><entry>Description</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>graphExec</entry><entry>Said graph whose memory requirements</entry></row><row><entry/><entry/><entry>may be considered.</entry></row><row><entry/><entry>stream</entry><entry>A stream upon which said graph is</entry></row><row><entry/><entry/><entry>expected to launch.</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0094" num="0087">In at least one embodiment, one or more systems define an API function to trim device memory through following code, although any variations thereof can be utilized:<ul id="ul0003" list-style="none">    <li id="ul0003-0001" num="0000">    <ul id="ul0004" list-style="none">        <li id="ul0004-0001" num="0088">&#x201c;CUresult cuDeviceGraphMemTrim(CUdevice device)&#x201d;<br/>in which free unused memory that was cached on a specified device can be utilized with graphs back to one or more operating systems (OS). In at least one embodiment, one or more systems utilize parameters described in a following table, although any variations thereof can be utilized:</li>    </ul>    </li></ul></p><p id="p-0095" num="0000"><tables id="TABLE-US-00008" num="00008"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="70pt" align="left"/><colspec colname="2" colwidth="112pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Parameter</entry><entry>Description</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>device</entry><entry>A device for which cached</entry></row><row><entry/><entry/><entry>memory should be freed.</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0096" num="0089">In at least one embodiment, one or more systems define attributes to query device memory status through following code, although any variations thereof can be utilized:</p><p id="p-0097" num="0000"><tables id="TABLE-US-00009" num="00009"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="21pt" align="left"/><colspec colname="1" colwidth="35pt" align="left"/><colspec colname="2" colwidth="161pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2003;</entry><entry>&#x201c;typedef enum CUdeviceGraphMem_</entry></row><row><entry/><entry/><entry>attribute_enum {</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;&#x2003;CU_DEVICE_GRAPH_MEM_ATTR_</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;&#x2003;USED_MEM_CURRENT,</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;&#x2003;CU_DEVICE_GRAPH_MEM_ATTR_</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;&#x2003;USED_MEM_HIGH,</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;&#x2003;CU_DEVICE_GRAPH_MEM_ATTR_</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;&#x2003;RESERVED_MEM_CURRENT,</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;&#x2003;CU_DEVICE_GRAPH_MEM_ATTR_</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;&#x2003;RESERVED_MEM_HIGH</entry></row><row><entry/><entry/><entry>} CUdeviceGraphMem_attribute;&#x201d;</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>in which said one or more systems utilize attributes described in a following table, although any variations thereof can be utilized:</p><p id="p-0098" num="0000"><tables id="TABLE-US-00010" num="00010"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="203pt" align="left"/><colspec colname="2" colwidth="84pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>Value</entry><entry>Description</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>CU_DEVICE_GRAPH_MEM_ATTR_USED_MEM_CURRENT</entry><entry>(value type = cuuint64_t)</entry></row><row><entry/><entry>An amount of memory, in</entry></row><row><entry/><entry>bytes, currently in use by</entry></row><row><entry/><entry>any graph.</entry></row><row><entry>CU_DEVICE_GRAPH_MEM_ATTR_USED_MEM_HIGH</entry><entry>(value type = cuuint64_t) A</entry></row><row><entry/><entry>maximum amount of</entry></row><row><entry/><entry>memory, in bytes, currently</entry></row><row><entry/><entry>in use by any graph since</entry></row><row><entry/><entry>this statistic was reset.</entry></row><row><entry>CU_DEVICE_GRAPH_MEM_ATTR_RESERVED_MEM_CURRENT</entry><entry>(value type = cuuint64_t) A</entry></row><row><entry/><entry>amount of memory</entry></row><row><entry/><entry>allocated to graphs, even if</entry></row><row><entry/><entry>it is not currently in use.</entry></row><row><entry>CU_DEVICE_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH</entry><entry>(value type = cuuint64_t) A</entry></row><row><entry/><entry>maximum amount of</entry></row><row><entry/><entry>memory allocated to graphs,</entry></row><row><entry/><entry>even if it is not currently in</entry></row><row><entry/><entry>use since this statistic was</entry></row><row><entry/><entry>reset.</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>in which said one or more systems define an API function to get attribute through following code, although any variations thereof can be utilized:<ul id="ul0005" list-style="none">    <li id="ul0005-0001" num="0000">    <ul id="ul0006" list-style="none">        <li id="ul0006-0001" num="0090">&#x201c;CUresult cuDeviceGraphMemoryGetAttribute(CUdevice device, CUdeviceGraphMem_attribute attr, void *value)&#x201d;<br/>in which said API function to get attribute is utilized to query memory usage statistics and returns information of specified memory attribute. In at least one embodiment, one or more systems define an API function to set attribute through following code, although any variations thereof can be utilized:</li>        <li id="ul0006-0002" num="0091">&#x201c;CUresult cuDeviceGraphMemorySetAttribute(CUdevice device, CUdeviceGraphMem_attribute attr, void *value)&#x201d;<br/>in which said one or more systems utilize parameters described in a following table, although any variations thereof can be utilized:</li>    </ul>    </li></ul></p><p id="p-0099" num="0000"><tables id="TABLE-US-00011" num="00011"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="42pt" align="left"/><colspec colname="2" colwidth="175pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>Parameter</entry><entry>Description</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>device</entry><entry>A device for which memory attributes are</entry></row><row><entry/><entry>being requested.</entry></row><row><entry>attr</entry><entry>An attribute being requested. Must be either</entry></row><row><entry/><entry>CU_DEVICE_GRAPH_MEM_ATTR_RE-</entry></row><row><entry/><entry>SERVED_MEM_HIGH or</entry></row><row><entry/><entry>CU_DEVICE_GRAPH_MEM_ATTR_USED_MEM_HIGH.</entry></row><row><entry>value</entry><entry>Pointer to storage for an attribute value.</entry></row><row><entry/><entry>Must point to a cuint64_t with a value of 0.</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0100" num="0092">In at least one embodiment, once said graph comprises either MemAlloc or MemFree node, one or more systems prevent a removal of edges or nodes, although in at least one embodiment, such operations are permitted. In at least one embodiment, one or more systems provide functionality to add new edges into said graph. In at least one embodiment, one or more systems prevent graphs with MemAlloc or MemFree nodes from being cloned or used as a child graph, although in at least one embodiment, such operations are permitted. In at least one embodiment, graph allocations can be accessed by nodes in child and clone-able graphs, and may or may not be allocated or freed. In at least one embodiment, one or more systems prevent operations such as edge removal, node deletion, cloning, use as a child graph, multiple simultaneous instantiations of said graph, and various other operations, although in at least one embodiment, said one or more systems permit one or more operations of said operations.</p><p id="p-0101" num="0093">In at least one embodiment, one or more systems provide functionality to convert various API functions in connection with streams to one or more API functions in connection with graphs, which are defined through a following table, although any variations thereof can be utilized:</p><p id="p-0102" num="0000"><tables id="TABLE-US-00012" num="00012"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="105pt" align="left"/><colspec colname="2" colwidth="98pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>Stream API</entry><entry>Graph API</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>cuMemAllocAsync</entry><entry>cuGraphAddMemAllocNode</entry></row><row><entry/><entry>cuMemAllocFromPoolAsync</entry><entry/></row><row><entry/><entry>cuMemFreeAsync</entry><entry>cuGraphAddMemFreeNode</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0103" num="0094">In at least one embodiment, an explicit graph API does not allow one or more callers (e.g. users) to pass a memory pool to graphs, although in at least one embodiment, such operations are permitted. In at least one embodiment, each graph internally maintains its own resources. In at least one embodiment, a stream API which is being captured supports explicit pools. In at least one embodiment, to support capture, one or more systems utilize properties of a captured pool for a poolProps field of node parameters. In at least one embodiment, one or more systems utilize an identity of said pool. In at least one embodiment, only a location of said pool is utilized for capture. In at least one embodiment, one or more systems utilize peer mappings of a stream API pool to set an accessDescs field of node creation parameters. In at least one embodiment, future changes to a captured pool may or may not be not reflected in a node's accessibility. In at least one embodiment, extra mappings can be utilized.</p><p id="p-0104" num="0095">In at least one embodiment, one or more systems prevent individual node update, although in at least one embodiment, individual node update is permitted. In at least one embodiment, one or more APIs for setting parameters for memory nodes are utilized by one or more systems for either instantiated or un-instantiated graphs. In at least one embodiment, changing an amount of memory an allocation uses may interfere with placement of other allocations made after said node is changed. In at least one embodiment, allocations can be utilized by other graph nodes, in which they may be updated.</p><p id="p-0105" num="0096">In at least one embodiment, one or more systems prevent multiple simultaneous instantiation, although in at least one embodiment, multiple simultaneous instantiation is permitted. In at least one embodiment, once said graph is instantiated, that instance must be destroyed before said graph can be instantiated again. In at least one embodiment, passing said graph to one or more API functions that update said graph can count as instantiating it. In at least one embodiment, an instantiated graph may be destroyed while it is still running.</p><p id="p-0106" num="0097">In at least one embodiment, one or more systems provide functionality to update whole instantiated graphs. In at least one embodiment, one or more systems provide functionality for whole graph update for graphs which contain memory nodes. In at least one embodiment, one or more systems utilize memory addresses from a new graph to replace existing addresses as a whole. In at least one embodiment, one or more systems generate a replacement graph in order, resulting in no dependent node placement issues.</p><p id="p-0107" num="0098">In at least one embodiment, one or more systems provide functionality to destroy graphs. In at least one embodiment, instantiated graphs can be destroyed while they are running. In at least one embodiment, memory used by said graph remains accessible through execution of said graph. In at least one embodiment, any inter-graph allocations remain accessible until their execution lifetimes are ended normally. In at least one embodiment, destroying a last graph which owns an allocation immediately ends that allocation's API lifetime.</p><p id="p-0108" num="0099">In at least one embodiment, one or more systems provide functionality to utilize a flag that can be passed to said graph upon instantiation which will change how said one or more systems handle inter-graph allocations owned by that graph. In at least one embodiment, after said graph is launched, inter-graph memory said graph allocated can be freed with various API functions to free allocated memory or with another graph. In at least one embodiment, one or more systems utilize a flag defined by following code, although any variations thereof can be utilized:</p><p id="p-0109" num="0000"><tables id="TABLE-US-00013" num="00013"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="21pt" align="left"/><colspec colname="1" colwidth="35pt" align="left"/><colspec colname="2" colwidth="161pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2003;</entry><entry>&#x201c;#define CUDA_GRAPH_INSTANTIATE_</entry></row><row><entry/><entry/><entry>FLAG_AUTO_FREE_ON_LAUNCH 1</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;&#x2003;CUresult cuGraphInstantiateWithFlags(</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;&#x2003;CUgraphExec *phGraphExec,</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;&#x2003;CUgraph hGraph,</entry></row><row><entry/><entry/><entry>&#x2003;&#x2003;&#x2003;NvU64 flags);&#x201d;</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>in which said flag, upon a second launch of said graph (e.g., and every launch thereafter) causes any un-freed inter-graph allocations made by said graph to be freed before said launch. In at least one embodiment, inter-graph allocations are used as output buffers across multiple launches. In at least one embodiment, a flag is utilized to insert frees before non-initial launches. In at least one embodiment, with a flag, one or more users can still free some or all of allocations manually.</p><p id="p-0110" num="0100">In at least one embodiment, a flag can be specified at instantiation which causes said graph to exclusively own its physical memory. In at least one embodiment, graphs executing on a same stream may reuse each other's memory, and trim operations can free memory back to an OS. In at least one embodiment, when a flag is utilized, said graph is allocated memory immediately by one or more systems upon instantiation and said memory cannot be reused by any other graph or returned to an OS by a trim call until after said graph has been destroyed, which said flag is denoted by following code, although any variations thereof can be utilized:<ul id="ul0007" list-style="none">    <li id="ul0007-0001" num="0000">    <ul id="ul0008" list-style="none">        <li id="ul0008-0001" num="0101">&#x201c;#define CUDA_GRAPH_INSTANTIATE_FLAG_EXCLUSIVE_MEMORY 2.&#x201d;</li>    </ul>    </li></ul></p><p id="p-0111" num="0102">In at least one embodiment, one or more systems provide functionality to track graph allocations. In at least one embodiment, once returned to one or more users, graph ordered allocations can be passed to nodes in graphs, but may or may not be passed to streams until their externally-visible execution lifetimes.</p><p id="p-0112" num="0103">In at least one embodiment, one or more systems track graph allocations globally in a heap separate from a unified virtual addressing (UVA) heap. In at least one embodiment, every inter-graph allocation has an entry in said heap. In at least one embodiment, if an allocation is freed in a same graph, a corresponding entry is removed, otherwise, it remains so that it can be found by inter-graph frees originating from separate graphs.</p><p id="p-0113" num="0104">In at least one embodiment, each graph owns a pool for each device upon which it owns allocations. In at least one embodiment, driver-internal pools manage virtual memory for all allocations owned by said graph. In at least one embodiment, if, during allocation, said graph doesn't have a pool for a device specified by an allocation, a new per-graph pool on that device is created by one or more systems for said graph. In at least one embodiment, one or more systems map an allocation pool onto peer devices on-demand, if required. In at least one embodiment, no additional internal pools are created, but can be in at least one embodiment. In at least one embodiment, internal pools managed by said graph own all resources associated with memory, but there are other resources tracked by said graph system. In at least one embodiment, one or more systems utilize various structures described in a following table, although any variations thereof can be utilized:</p><p id="p-0114" num="0000"><tables id="TABLE-US-00014" num="00014"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="91pt" align="left"/><colspec colname="3" colwidth="70pt" align="left"/><thead><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row><row><entry>Structure</entry><entry>Description</entry><entry>Cloning</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>Memory pool</entry><entry>Per device.</entry><entry>Shared with clones.</entry></row><row><entry/><entry>Internally backed by a</entry><entry>Reference counted by</entry></row><row><entry/><entry>CUImemblockPool.</entry><entry>each graph/graph</entry></row><row><entry/><entry>Includes</entry><entry>execution.</entry></row><row><entry/><entry>VA reservation</entry><entry/></row><row><entry/><entry>memory mappings, and</entry><entry/></row><row><entry/><entry>a heap for VA</entry><entry/></row><row><entry>block refcount</entry><entry>Per device.</entry><entry>An array is copied.</entry></row><row><entry>array</entry><entry>Has one element for each</entry><entry/></row><row><entry/><entry>block in a VA reservation.</entry><entry/></row><row><entry/><entry>Tracks a number of owned</entry><entry/></row><row><entry/><entry>inter-graph allocations in</entry><entry/></row><row><entry/><entry>each block.</entry><entry/></row><row><entry/><entry>Used for allocating physical</entry><entry/></row><row><entry/><entry>memory.</entry><entry/></row><row><entry>List of owned</entry><entry>Allocations that were created,</entry><entry>Instantiation: converted</entry></row><row><entry>inter-graph</entry><entry>but not freed, in this graph.</entry><entry>to array of memory</entry></row><row><entry>allocations</entry><entry/><entry>objects to be registered</entry></row><row><entry/><entry/><entry>at launch.</entry></row><row><entry/><entry/><entry>Non-instantiation: not</entry></row><row><entry/><entry/><entry>supported.</entry></row><row><entry>List of</entry><entry>List of virtual addresses that</entry><entry>Instantiation: array is</entry></row><row><entry>inter-graph</entry><entry>were allocated outside of this</entry><entry>copied.</entry></row><row><entry>frees</entry><entry>graph that have been freed</entry><entry>Non-instantiation: not</entry></row><row><entry/><entry>into this graph.</entry><entry>supported.</entry></row><row><entry>Subpools</entry><entry>Subpools contain virtual</entry><entry>Not copied. Virtual</entry></row><row><entry/><entry>memory freed at various</entry><entry>memory in subpools is</entry></row><row><entry/><entry>points in said graph and</entry><entry>inaccessible to a clone.</entry></row><row><entry/><entry>allow for dependency-based</entry><entry/></row><row><entry/><entry>reuse.</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0115" num="0105">In at least one embodiment, graph allocations can be passed as operands to nodes within said graph such as nodes performing memory copy operations, memory setting operations, memory freeing operations, and/or variations thereof. In at least one embodiment, when validating parameters, one or more systems (e.g., a driver) will check a global heap to see if it falls within said graph allocation; if so, said one or more systems can check said allocation against said graph's inter-graph free list, to ensure said graph hasn't already freed that allocation.</p><p id="p-0116" num="0106">In at least one embodiment, when validating operands, one or more systems utilize various processes described herein for locating graph memory. In at least one embodiment, graph allocations have one or more memory objects during their execution lifetimes, if they are inter-graph. In at least one embodiment, one or more systems obtain various memory blocking operations from various memory objects. In at least one embodiment, one or more systems backup memory based at least in part on virtual addresses.</p><p id="p-0117" num="0107">In at least one embodiment, one or more systems perform instantiation using one or more processes for cloning as described herein. In at least one embodiment, one or more systems retain memory pools. In at least one embodiment, said memory pool tracks whether each block is mapped, which can be a common state for all graphs that are created from an original. In at least one embodiment, one or more systems copy a block refcount array. In at least one embodiment, future allocations in an original graph don't increase a physical memory footprint of an instantiated graph. In at least one embodiment, one or more systems transform a list of owned, inter-graph allocations into a state which can be used to quickly create various memory objects on a launch path. In at least one embodiment, one or more systems copy frees into a form which can be used to remove various memory objects.</p><p id="p-0118" num="0108">In at least one embodiment, one or more systems release or otherwise destroy existing memory-related data in said graph and clone data from a new graph into an instantiated graph. In at least one embodiment, an instantiated graph shares ownership of its allocations with a new graph in addition to or instead of an original.</p><p id="p-0119" num="0109">In at least one embodiment, child graphs have per-graph data which is completely isolated from a parent graph. In at least one embodiment, a child graph's VA reservation is separate from a parent, and one or more systems prevent said child graph from having any inter-graph allocations, although in at least one embodiment, said one or more systems permit such operations, though said child graph may access intra-graph allocations of its parent. In at least one embodiment, when a parent graph is launched, it must also perform memory-related launch steps on all of its child graphs, which can appear, from a memory allocator's perspective, as several graph launches.</p><p id="p-0120" num="0110"><figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates an example <b>300</b> of a graph and memory allocation, according to at least one embodiment. In at least one embodiment, example <b>300</b> includes states of said graph at a first time <b>302</b> (e.g., t=t<sub>0</sub>), a subsequent second time <b>304</b> (e.g., t=t<sub>1</sub>), and a subsequent third time <b>306</b> (e.g., t=t<sub>2</sub>). In at least one embodiment, one or more graphs depicted in <figref idref="DRAWINGS">FIG. <b>3</b></figref> are graphs such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>2</b></figref> and elsewhere herein. In at least one embodiment, one or more systems obtain code utilizing one or more APIs to perform various graph operations, compile said code into executable code, and execute said executable code on one or more devices.</p><p id="p-0121" num="0111">In at least one embodiment, a pool refers to a collection or region of memory. In at least one embodiment, each graph pool has its own virtual address reservation which it uses a heap to manage; however, when an allocation is freed, said allocation may not get sent back to said heap. In at least one embodiment, said allocation is freed into a local heap, referred to as a subpool, which allows said allocation to be reused by descendants of MemFree node in said graph.</p><p id="p-0122" num="0112">In at least one embodiment, subpools are associated with a main pool (e.g., said graph pool). In at least one embodiment, memory freed into said subpool must have originally been allocated from said main pool. In at least one embodiment, said subpool supports allocating with a minimum age requirement, represented by an integer called a sequenceID. In at least one embodiment, upon every free into said subpool, said subpool's sequenceID is incremented and a new value is associated with freed memory. In at least one embodiment, one or more systems provide sequenceIDs to enable one fork of said graph to continue to allocate from said subpool, even after another fork has freed memory into said pool, by specifying an older (e.g., lower) sequenceID from before said fork.</p><p id="p-0123" num="0113">In at least one embodiment, each node in said graph contains a list of zero or more subpool snapshots. In at least one embodiment, each snapshot comprises at least a reference to said subpool, and/or a sequenceID of said subpool when said snapshot was taken. In at least one embodiment, when a node is created, said node copies snapshots of all of its dependencies into a new snapshot list, resolving duplicate entries by taking a highest (e.g., least-restrictive) sequenceID, which can be referred to as inheriting a snapshot. In at least one embodiment, when said snapshot contains a current sequenceID of said snapshot's subpool, that snapshot is considered current.</p><p id="p-0124" num="0114">In at least one embodiment, as well as inheriting snapshot lists, MemFree nodes also modify them when they look for a snapshot which is current, in which if none exist, said MemFree nodes create a new subpool and insert it into said snapshot list, and when they increment a sequenceID for a selected snapshot and use that sequenceID to free memory into subpool, which causes MemFree node to possess an only current snapshot for that subpool. In at least one embodiment, MemAlloc nodes do not modify snapshot lists they inherit. In at least one embodiment, MemAlloc nodes attempt to allocate from each snapshot list with said snapshot's sequenceID as a minimum age, in which if said snapshot is current, then allocation is an unrestricted allocation.</p><p id="p-0125" num="0115">In at least one embodiment, upon launch, a list of graph-owned inter-graph allocations are turned into one or more memory objects by one or more systems, as these allocation's external lifetimes are about to begin, so said allocations can be used in dependent operations. In at least one embodiment, said graph's list of not-owned, freed allocations is used to remove one or more memory objects. In at least one embodiment, as a part of an execution lifetime, a launch path checks that expected memory objects exist or don't exist. In at least one embodiment, if expectations are not met, said launch fails.</p><p id="p-0126" num="0116">In at least one embodiment, at first time <b>302</b>, a first MemAlloc node (e.g., alloc <b>308</b>) will always allocate from said pool, as there are no preceding MemFree nodes to have placed memory into said subpool. In at least one embodiment, at first time <b>302</b>, alloc <b>308</b> allocates directly from said main pool. In at least one embodiment, at second time <b>304</b>, once allocated memory is freed, MemFree node (e.g., free <b>310</b>) will create a new subpool into which it frees said allocation, and will track said subpool with a new single-element snapshot list (e.g., Sequence ID <b>312</b>). In at least one embodiment, at second time <b>304</b>, free <b>310</b> frees memory into said new subpool and tracks it as current in a new snapshot. In at least one embodiment, at this point, sequenceIDs in said snapshot and said subpool match and said snapshot is current. In at least one embodiment, at third time <b>306</b>, dependent MemAlloc nodes (e.g., alloc <b>314</b> or alloc <b>316</b>), even if they are sequential or not sequential, can attempt to allocate from said subpool. In at least one embodiment, at third time <b>306</b>, dependent MemAlloc nodes (e.g., alloc <b>314</b> or alloc <b>316</b>) can both attempt allocations from a same subpool. In at least one embodiment, if said subpool cannot satisfy a request, said main pool will be used. In at least one embodiment, if only allocation is happening, allocation nodes may or may not be unordered with respect to each other.</p><p id="p-0127" num="0117"><figref idref="DRAWINGS">FIG. <b>4</b></figref> illustrates an example <b>400</b> of a fork in a graph, according to at least one embodiment. In at least one embodiment, example <b>400</b> is a continuation of example <b>300</b> of <figref idref="DRAWINGS">FIG. <b>3</b></figref>. In at least one embodiment, one or more graphs depicted in <figref idref="DRAWINGS">FIG. <b>4</b></figref> are graphs such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>3</b></figref> and elsewhere herein. In at least one embodiment, example <b>400</b> includes states of said graph at a fourth time <b>402</b> (e.g., t=t<sub>3</sub>), a subsequent fifth time <b>404</b> (e.g., t=t<sub>4</sub>), and a subsequent sixth time <b>406</b> (e.g., t=t<sub>5</sub>).</p><p id="p-0128" num="0118">In at least one embodiment, at fourth time <b>402</b>, initially after a fork, inherited snapshots will be current on both sides of said fork, but as soon as a free happens on one side, that will increase said sequenceID of said subpool and other side of said fork will no longer be current. In at least one embodiment, at fourth time <b>402</b>, another MemFree node free <b>318</b> increments a sequenceID on a left fork. In at least one embodiment, MemAlloc nodes on a non-current side of said fork won't allocate other-side-freed memory because they use an older sequenceID; if they allocated memory, corruption may occur as they could be allocating memory before it was free. In at least one embodiment, at fifth time <b>404</b>, right-fork MemAlloc nodes alloc <b>316</b> and alloc <b>320</b> are restricted to a sequenceID less than or equal to 1.</p><p id="p-0129" num="0119">In at least one embodiment, an additional free <b>322</b> on a non-current side requires a creation of another subpool because frees can only be made into subpools from current snapshots. In at least one embodiment, at sixth time <b>406</b>, right-fork free <b>322</b> requires a current subpool and creates a new subpool (e.g., corresponding to Sequence ID <b>324</b>). In at least one embodiment, if a free was permitted, MemAlloc nodes on said current side could reallocate memory before it was freed, causing corruption. In at least one embodiment, forks in said graph can share pre-fork subpools without restriction until a free in one of said forks utilizes that subpool for a side.</p><p id="p-0130" num="0120">In at least one embodiment, one or more systems unify various aspects of intra-graph and inter-graph allocations. In at least one embodiment, one or more systems calculate and track of how many times said graph allocates or frees a given block of VA space. In at least one embodiment, when said graph runs, each block needs to be mapped by one or more systems to free physical memory (e.g., which has no outstanding allocations). In at least one embodiment, one or more systems perform remapping at launch time.</p><p id="p-0131" num="0121"><figref idref="DRAWINGS">FIG. <b>5</b></figref> illustrates an example <b>500</b> of a block refcount array, according to at least one embodiment. In at least one embodiment, example <b>500</b> includes states of a block refcount array at a first time <b>502</b> (e.g., t=t<sub>0</sub>), a subsequent second time <b>504</b> (e.g., t=t<sub>1</sub>), and a subsequent third time <b>506</b> (e.g., t=t<sub>2</sub>).</p><p id="p-0132" num="0122">In at least one embodiment, each graph is associated with a virtual address (VA) reservation that is divided into fixed-sized blocks. In at least one embodiment, VA reservation refers to a set of data indicating virtual addresses for allocating memory. In at least one embodiment, a block is a unit of physical allocation for both graph allocations. In at least one embodiment, as each graph has its own VA reservation, each VA block is unique to a live and/or not destroyed graph. In at least one embodiment, each graph also has an array of graph-local reference counts, also referred to as refcounts, with an element for each block of a region it owns, which is referred to as a block refcount array.</p><p id="p-0133" num="0123">In at least one embodiment, at first time <b>502</b>, said graph is initialized. In at least one embodiment, at first time <b>502</b>, blocks start off with a graph-local refcount of 0. In at least one embodiment, at second time <b>504</b>, when an allocation is made, each VA block which contains part of said allocation has its graph-local refcount increased. In at least one embodiment, at second time <b>504</b>, one or more systems iterate through said block refcount array and increment counts. In at least one embodiment, at third time <b>506</b>, creating said free node involves one or more systems decrementing graph-local refcounts. In at least one embodiment, for an intra-graph free, refcounts are contained within said block refcount array, which can be decremented directly by one or more systems. In at least one embodiment, for inter-graph frees, a graph-local refcount of an allocating graph is not modified, and one or more systems instead create a surrogate block refcount array. In at least one embodiment, said surrogate can be used by a freeing graph again, if another inter-graph free impacts same (e.g., foreign) VA blocks.</p><p id="p-0134" num="0124">In at least one embodiment, one or more systems, as part of instantiation, perform various mapping and physical memory allocation operations associated with pre-launch by utilizing a stream which was last used to launch said graph, which can reduce overhead associated with a first launch operation.</p><p id="p-0135" num="0125">In at least one embodiment, one or more systems, to support one or more graphs in a same stream reusing each other's physical memory, allocate memory for graphs from stream-owned pools. In at least one embodiment, pools may own memory from several devices and are completely internal. In at least one embodiment, memory contained within pools count toward totals which can be queried through pools through one or more API functions, such as a &#x201c;cuDeviceGetGraphMemPool( )&#x201d; function.</p><p id="p-0136" num="0126">In at least one embodiment, before launch, physical memory from a launching stream is used to back all allocations made by said graph in a pre-launch phase. In at least one embodiment, one or more systems use physical memory cached on a per-stream basis to ensure that no serialization is introduced between graphs launched on different stream. In at least one embodiment, one or more systems provide functionality to relaunch graphs in a same stream to reuse a same physical memory. In at least one embodiment, after launch, when a completion marker of said graph is known, one or more systems update tracking data so that lifetimes of allocations can be accurately tracked in a post-launch phase</p><p id="p-0137" num="0127">In at least one embodiment, during pre-launch, all VA blocks which ever backed an allocation owned by said graph are mapped by one or more systems to physical memory from a launching stream's physical page cache, which includes VA blocks which have a graph-local refcount of 0 (e.g., for VA blocks which contain only intra-graph allocations). In at least one embodiment, graphs reuse allocations from inter-graph frees, in which allocations within a graph's VA reservation are backed.</p><p id="p-0138" num="0128"><figref idref="DRAWINGS">FIG. <b>6</b></figref> illustrates an example <b>600</b> of virtual address reservation, according to at least one embodiment. In at least one embodiment, example <b>600</b> includes virtual address reservation at a first time <b>602</b> (e.g., t=t<sub>0</sub>) and at a subsequent second time <b>604</b> (e.g., t=t<sub>1</sub>).</p><p id="p-0139" num="0129">In at least one embodiment, each physical block comprises at least three main fields: a reference to an owning stream (e.g., &#x201c;streamID&#x201d; in <figref idref="DRAWINGS">FIG. <b>6</b></figref>), a stream's sequenceID from a last time said block reached a refcount of 0 (e.g., &#x201c;sequenceID&#x201d; in <figref idref="DRAWINGS">FIG. <b>6</b></figref>), and/or a refcount of how many allocations are using said block (e.g., &#x201c;refCount&#x201d; in <figref idref="DRAWINGS">FIG. <b>6</b></figref>). In at least one embodiment, if said refcount is 0, then said block can be used by another graph by ensuring that it has acquired an owning stream's sequenceID. In at least one embodiment, at first time <b>602</b>, VA blocks with a value of 0 contain only intra-graph allocations and VA blocks with a value of 1 contain at least one allocation not freed in said graph.</p><p id="p-0140" num="0130">In at least one embodiment, when launching said graph which has been mapped to physical blocks before, one or more blocks may not be available, such as when, in between launches, a block was used by an inter-graph allocation which hasn't been freed. In at least one embodiment, said launch process checks whether any of graph-owned VA blocks are mapped to physical memory with a non-zero refcount; if so, those blocks need to be remapped before launch. In at least one embodiment, as an illustrative example, if an existing physical block has a refcount of 1, remapping must be performed by one or more systems. In at least one embodiment, if physical memory has a zero refcount, said launch process acquires their sequenceIDs to ensure that a memory's free is properly acquired (e.g., is a no-op for memory freed in a same stream).</p><p id="p-0141" num="0131">In at least one embodiment, during pre-launch, blocks being used by said graph are retained such that any allocation occurring for a remap doesn't reuse a free block already mapped to this graph, and such that other launches don't reuse these blocks during said graph launch (e.g., when all memory related locks are dropped). In at least one embodiment, pageable memory copy operations may block said launch until their completion.</p><p id="p-0142" num="0132">In at least one embodiment, one or more systems, in a post launch phase, add graph-local counts to blocks, which includes decrements from surrogate refcount objects. In at least one embodiment, surrogates allow physical blocks to go from an allocated to a free state, as they drop refcounts. In at least one embodiment, at second time <b>604</b>, graph local counts (e.g., depicted in <figref idref="DRAWINGS">FIG. <b>6</b></figref> as &#x201c;VA Blocks&#x201d;) are applied to unallocated blocks (e.g., depicted in <figref idref="DRAWINGS">FIG. <b>6</b></figref> as &#x201c;Physical Blocks&#x201d;). In at least one embodiment, graph local counts are applied to refCount fields. In at least one embodiment, if said graph frees any blocks (e.g., causes a refcount of 0), then a stream's sequenceID is advanced and a new value is associated with those blocks. In at least one embodiment, while said sequenceID is determined pre-launch, a completion marker of said graph may not be, and checking completion of a current sequenceID may require reading said graph's marker. In at least one embodiment, when said marker has been updated, one or more systems release pre-launch artificial refcounts and assign said sequenceID.</p><p id="p-0143" num="0133">In at least one embodiment, said graph can be running when it is destroyed. In at least one embodiment, if said graph is running when it is destroyed, said graph's physical memory cannot be freed to an OS, nor can said graph's mappings be removed, until said graph has completed. In at least one embodiment, said graph's physical memory can be reused by a launch which acquires it (e.g., which can be a no-op as memory is reused in a same stream) but removing mappings must be done on a host.</p><p id="p-0144" num="0134">In at least one embodiment, one or more systems provide functionality, through graph memory nodes, to utilize graphs to allocate memory, utilize allocated memory, and free allocated memory. In at least one embodiment, graph memory nodes allow graphs to make and own memory allocations. In at least one embodiment, graph memory nodes have GPU ordered liveness semantics, which enable stream capture of various stream ordered allocation APIs, such as those for allocating and free allocating memory, and also enable driver managed memory reuse.</p><p id="p-0145" num="0135">In at least one embodiment, graph allocations (e.g., memory allocations) have fixed addresses over a lifetime of said graph and its instantiations, which allows memory to be directly referenced by other operations within said graph without a need of said graph update when new memory is assigned. In at least one embodiment, within said graph, allocations whose graph ordered lifetimes do not overlap can use a same fixed address and underlying physical memory resources.</p><p id="p-0146" num="0136">In at least one embodiment, GPU ordered liveness semantics enable one or more drivers to virtually alias same physical memory to allocations from multiple graphs. In at least one embodiment, as long as graphs are all launched in a same stream and free their own allocation, a driver can virtually alias same physical memory to satisfy needs of those graphs. In at least one embodiment, liveness is referred to as &#x201c;GPU ordered&#x201d; because allocations that are not freed in an allocating graph follow various graph ordered semantics inside said graph and stream ordered semantics between a launch of said allocating graph and a free operation (e.g., which may be done either with a node within said graph or with a free call such as one or API calls to free allocated memory).</p><p id="p-0147" num="0137"><figref idref="DRAWINGS">FIG. <b>7</b></figref> illustrates an example <b>700</b> of address reuse, according to at least one embodiment. In at least one embodiment, example <b>700</b> includes said graph at a first time <b>702</b> (e.g., t=t<sub>0</sub>) and at a subsequent second time <b>704</b> (e.g., t=t<sub>1</sub>). In at least one embodiment, one or more graphs depicted in <figref idref="DRAWINGS">FIG. <b>7</b></figref> are graphs such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>4</b></figref> and elsewhere herein. In at least one embodiment, alloc <b>706</b>, new alloc <b>710</b>, and new alloc <b>714</b> are nodes for memory allocation, such as those described herein. In at least one embodiment, free <b>708</b> and free <b>712</b> are nodes for freeing memory, such as those described herein.</p><p id="p-0148" num="0138">In at least one embodiment, said driver reuses memory by at least reusing memory within said graph based on virtual address assignment, reusing between graphs with virtual aliasing, in which different graphs can map same physical memory mapped to their virtual addresses, and/or variations thereof. In at least one embodiment, said driver assigns virtual addresses during allocation node creation, allowing them to be used in said graph. In at least one embodiment, addresses are fixed and remain unchanged across graph instantiation and launch operations. In at least one embodiment, if said graph allocation is freed in an allocating graph, subsequent graph allocation nodes in same graph may reuse a virtual address range as long as there are graph dependency edges ordering a new allocation node after a freeing allocation node.</p><p id="p-0149" num="0139">In at least one embodiment, at first time <b>702</b>, new allocation alloc <b>710</b> can reuse an address freed by dependent node free <b>708</b>. In at least one embodiment, at second time <b>704</b>, new allocation node alloc <b>714</b> doesn't have dependencies on free node free <b>712</b> so said new allocation node cannot use an address from associated allocation node alloc <b>710</b>. In at least one embodiment, at second time <b>704</b>, if allocation node alloc <b>710</b> used an address freed by free node free <b>708</b>, then new allocation node alloc <b>714</b> would need a new address.</p><p id="p-0150" num="0140"><figref idref="DRAWINGS">FIG. <b>8</b></figref> illustrates an example <b>800</b> of physical memory sharing between graphs, according to at least one embodiment. In at least one embodiment, a graph 1 <b>802</b>, a graph 2 <b>806</b>, a graph 3 <b>812</b>, and a graph 4 <b>814</b> are graphs such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>4</b></figref>, <figref idref="DRAWINGS">FIG. <b>7</b></figref>, and elsewhere herein. In at least one embodiment, graph 1 <b>802</b> utilizes physical memory 1 <b>804</b>, graph 2 <b>806</b> utilizes physical memory 2 <b>808</b>, and free (Graph 1 Memory) <b>810</b> is an operation that frees memory utilized by graph 1.</p><p id="p-0151" num="0141">In at least one embodiment, graphs in a same stream can share physical memory, as they don't run concurrently. In at least one embodiment, referring to <figref idref="DRAWINGS">FIG. <b>8</b></figref>, an unfreed allocation prevents graph 2 <b>806</b> from sharing physical memory from graph 1 <b>802</b>. In at least one embodiment, since memory will be free when graph 3 <b>812</b> launches, graph 3 <b>812</b> can use physical memory from either graph 1 <b>802</b> (e.g., physical memory 1 <b>804</b>) or graph 2 <b>806</b> (e.g., physical memory <b>808</b>). In at least one embodiment, graph 3 <b>812</b> utilizes physical memory 1 <b>804</b>. In at least one embodiment, referring to <figref idref="DRAWINGS">FIG. <b>8</b></figref>, graph 4 <b>814</b> is launched in a separate stream and cannot use same memory, unless other streams have completed their work before launch of graph 4 <b>814</b>.</p><p id="p-0152" num="0142">In at least one embodiment, said driver maps physical memory to a virtual address before an allocating node is reached in GPU order. In at least one embodiment, for multiple graphs to use a same physical memory, they cannot run simultaneously. In at least one embodiment, while said graph allocation remains un-freed, corresponding physical pages cannot be used by other graphs. In at least one embodiment, at graph launch time, said driver uses a stream ordering of already launched graphs and queued memory operations to determine physical memory that will be available for use by a launching graph. In at least one embodiment, said driver balances minimizing a need for remapping operations with minimizing a total physical memory footprint of various graph memory nodes. In at least one embodiment, said driver utilizes ordering information to map a same physical memory to multiple allocations.</p><p id="p-0153" num="0143">In at least one embodiment, one or more systems (e.g., said driver of one or more programming models) associate physical memory with streams and prioritize using physical memory associated with launch stream when creating new mappings during graph launch. In at least one embodiment, one or more systems map a same physical memory to multiple graphs launched on a same stream using virtual aliasing, as a stream orders execution of graphs.</p><p id="p-0154" num="0144">In at least one embodiment, launching a same graph into different streams may require remapping either for that graph or subsequent graphs launched in an original stream. In at least one embodiment, when same graph is launched into a different stream, said driver replaces physical memory (e.g., such that physical memory will continue to be reused without penalty by other graphs running in an original stream) and/or associates physical memory with new stream (e.g., avoiding remapping for a current graph and allowing future graphs launched in a new stream to prioritize sharing physical memory).</p><p id="p-0155" num="0145">In at least one embodiment, to prevent inactive streams holding onto cached memory, one or more systems reassign physical memory from other streams to a launch stream instead of allocating more memory. In at least one embodiment, said driver reassigns memory when it can safely do so without inserting a false dependency.</p><p id="p-0156" num="0146"><figref idref="DRAWINGS">FIG. <b>9</b></figref> illustrates an example of a process <b>900</b> of allocating memory using a graph, according to at least one embodiment. In at least one embodiment, some or all of process <b>900</b> (or any other processes described herein, or variations and/or combinations thereof) is performed under control of one or more computer systems configured with computer-executable instructions and is implemented as code (e.g., computer-executable instructions, one or more computer programs, or one or more applications) executing collectively on one or more processors, by hardware, software, or combinations thereof. In at least one embodiment, code is stored on a computer-readable storage medium in form of a computer program comprising a plurality of computer-readable instructions executable by one or more processors. In at least one embodiment, a computer-readable storage medium is a non-transitory computer-readable medium. In at least one embodiment, at least some computer-readable instructions usable to perform process <b>900</b> are not stored solely using transitory signals (e.g., a propagating transient electric or electromagnetic transmission). In at least one embodiment, a non-transitory computer-readable medium does not necessarily include non-transitory data storage circuitry (e.g., buffers, caches, and queues) within transceivers of transitory signals.</p><p id="p-0157" num="0147">In at least one embodiment, process <b>900</b> is performed by one or more systems such as those described in this present disclosure. In at least one embodiment, one or more systems include any suitable system with a collection of one or more hardware and/or software resources with instructions that, when executed, performs memory allocation and/or deallocation processes such as those described herein. In at least one embodiment, process <b>900</b> is performed by a system of one or more programming models. In at least one embodiment, one or more processes of process <b>900</b> are performed in any suitable order, including sequential, parallel, and/or variations thereof, and using any suitable processing unit, such as a CPU, GPU, PPU, and/or variations thereof.</p><p id="p-0158" num="0148">In at least one embodiment, said system performing at least a part of process <b>900</b> includes executable code to at least obtain <b>902</b> code indicating at least generation of one or more graph code nodes. In at least one embodiment, one or more graph code nodes include nodes corresponding to memory allocation operations, such as MemAlloc node. In at least one embodiment, MemAlloc node, also referred to as a graph code node corresponding to a memory allocation operation or a graph code node to allocate memory, encodes information regarding memory allocation such as properties of memory to be allocated, size of memory to be allocated, constraints on memory to be allocated, address of memory to be allocated, and/or any suitable information.</p><p id="p-0159" num="0149">In at least one embodiment, said code indicates at least generation of one or more graph code nodes such as MemAlloc nodes and/or launch of a graph comprising said one or more graph code nodes. In at least one embodiment, said code utilizes one or more APIs to indicate at least generation of one or more graph code nodes. In at least one embodiment, said code comprises one or more API calls for generation of one or more graph code nodes. In at least one embodiment, said system compiles and executes said code. In at least one embodiment, said system executes code by converting said code into executable code and executing said executable code. Further information regarding compiling and executing code can be found in description of <figref idref="DRAWINGS">FIGS. <b>30</b>-<b>39</b></figref>.</p><p id="p-0160" num="0150">In at least one embodiment, said system performing at least a part of process <b>900</b> includes executable code to at least perform <b>904</b> API to generate one or more graph code nodes to allocate memory. In at least one embodiment, as part of execution of obtained code utilizing one or more APIs, said system performs one or more APIs corresponding to said one or more APIs utilized in said code. In at least one embodiment, said system performs API to generate one or more graph code nodes to allocate memory by generating or otherwise instantiating one or more MemAlloc nodes.</p><p id="p-0161" num="0151">In at least one embodiment, said system performs an API, such as those described herein, based on parameter values of said API which may be indicated in code. In at least one embodiment, a parameter value refers to a value of a parameter of an API, such as those described herein, and includes any suitable data, such as numerical values, data structures, data objects, and/or variations thereof. In at least one embodiment, as an illustrative example, code utilizes API to generate one or more graph code nodes to allocate memory and includes a parameter value of a size of memory to be allocated, in which said system performs said API to generate one or more graph code nodes to allocate memory of said size of memory. In at least one embodiment, said system performs an API, such as those described herein, in which performance of said API results in data output to one or more data structures, data objects, locations, and/or variations thereof, indicated by parameter values of said API. In at least one embodiment, as an illustrative example, said system performs API to generate one or more graph code nodes to allocate memory in which data such as an address of allocated memory is output to one or more data structures, data objects, locations, and/or variations thereof (e.g., indicated by parameter values).</p><p id="p-0162" num="0152">In at least one embodiment, said system generates or otherwise obtains said graph, also referred to as a graph data structure. In at least one embodiment, said system generates one or more graph code nodes to allocate memory (e.g., MemAlloc node) as part of said graph data structure. In at least one embodiment, API to generate one or more graph code nodes to allocate memory is denoted using following notation, although any variations thereof such as those described herein can be utilized:</p><p id="p-0163" num="0000"><tables id="TABLE-US-00015" num="00015"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="42pt" align="left"/><colspec colname="2" colwidth="175pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;</entry><entry>&#x201c;result GraphAddMemAllocNode(</entry></row><row><entry/><entry>&#x2003;graphNode* GraphNode,</entry></row><row><entry/><entry>&#x2003;graph Graph,</entry></row><row><entry/><entry>&#x2003;const graphNode* dependencies,</entry></row><row><entry/><entry>&#x2003;size_t numDependencies,</entry></row><row><entry/><entry>&#x2003;MEM_ALLOC_NODE_PARAMS* params);&#x201d;</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>in which &#x201c;GraphNode&#x201d; returns a created node, &#x201c;Graph&#x201d; indicates said graph to which to add said node, &#x201c;dependencies&#x201d; indicates dependencies of said node, &#x201c;numDependencies&#x201d; indicates a number of dependencies of said node, and &#x201c;params&#x201d; indicates parameters for said node, and said API is denoted using any suitable notation, which may or may not be in reference to a programming model, and may include any suitable parameters in addition to or instead of those described above, which can be denoted using any suitable notation, which may or may not be in reference to a programming model. In at least one embodiment, said system generates an executable for said graph data structure, which refers to a file, program, code, data, and/or variations thereof that, when executed, causes a device to perform one or more operations indicated by said graph data structure.</p><p id="p-0164" num="0153">In at least one embodiment, said system performing at least a part of process <b>900</b> includes executable code to at least launch <b>906</b> graph to cause at least memory to be allocated. In at least one embodiment, said system provides said executable for said graph data structure to one or more devices. In at least one embodiment, one or more devices include any suitable device, such as a GPU, PPU, CPU, GPGPU, and/or variations thereof. In at least one embodiment, said system launches said graph on one or more devices, which refers to a process of causing said one or more devices to perform one or more operations of said graph (e.g., through said executable for said graph). In at least one embodiment, said system launches said graph on one or more devices by providing said executable for said graph to said one or more devices, in which said one or more devices execute said executable for said graph, and as part of said execution, perform one or more operations indicated by one or more nodes of said graph in any suitable manner, such as sequentially, in parallel, and/or variations thereof. In at least one embodiment, as part of execution of obtained code, said system launches said graph on one or more devices.</p><p id="p-0165" num="0154">In at least one embodiment, said system causes one or more devices to allocate memory, and use allocated memory to perform one or more operations by launching one or more graphs on said one or more devices that comprise at least one or more graph code nodes to allocate memory and one or more graph code nodes corresponding to said one or more operations. In at least one embodiment, said system causes one or more devices to perform a set of operations indicated by said graph data structure using allocated memory by launching said graph data structure on said one or more devices that comprises at least one or more graph code nodes indicating said set of operations and use of said allocated memory.</p><p id="p-0166" num="0155">In at least one embodiment, said system utilizes one or more graph code nodes to allocate memory. In at least one embodiment, said system causes one or more devices to allocate memory based on one or more graph code nodes to allocate memory by launching said graph comprising said one or more graph code nodes on said one or more devices. In at least one embodiment, said system causes one or more devices to allocate memory through one or more operating system functions. In at least one embodiment, said system allocates memory on one or more devices. In at least one embodiment, one or more devices use one or more graph code nodes to allocate memory to allocate memory by utilizing information encoded in said one or more graph code nodes to allocate memory. In at least one embodiment, as an illustrative example, said graph code node to allocate memory encodes information indicating a size of an allocation, in which a device allocates memory of said size. In at least one embodiment, one or more devices allocate memory by identifying a suitable region of memory (e.g., based on information encoded in said graph code node to allocate memory, or from information provided by one or more systems, such as a CPU), and indicating that said suitable region of memory, also referred to as allocated memory, is reserved and/or in use for one or more operations. In at least one embodiment, one or more systems, such as a CPU, identify a suitable memory region (e.g., based on one or more graph code nodes to allocate memory) and provide said identified memory region to one or more devices, in which said one or more devices utilize said identified memory region to allocate memory.</p><p id="p-0167" num="0156">In at least one embodiment, one or more devices utilize allocated memory to perform one or more operations. In at least one embodiment, said system performing at least a part of process <b>900</b> includes executable code to at least obtain a second graph data structure indicating one or more operations and launch said second graph data structure on one or more devices to cause said one or more devices to perform said one or more operations utilizing allocated memory. In at least one embodiment, memory allocated in connection with a first graph data structure can be used to perform operations indicated by said first graph data structure and/or a second graph data structure. In at least one embodiment, one or more devices deallocate allocated memory upon completion of one or more operations.</p><p id="p-0168" num="0157"><figref idref="DRAWINGS">FIG. <b>10</b></figref> illustrates an example of a process <b>1000</b> of deallocating memory using a graph, according to at least one embodiment. In at least one embodiment, some or all of process <b>1000</b> (or any other processes described herein, or variations and/or combinations thereof) is performed under control of one or more computer systems configured with computer-executable instructions and is implemented as code (e.g., computer-executable instructions, one or more computer programs, or one or more applications) executing collectively on one or more processors, by hardware, software, or combinations thereof. In at least one embodiment, code is stored on a computer-readable storage medium in form of a computer program comprising a plurality of computer-readable instructions executable by one or more processors. In at least one embodiment, a computer-readable storage medium is a non-transitory computer-readable medium. In at least one embodiment, at least some computer-readable instructions usable to perform process <b>1000</b> are not stored solely using transitory signals (e.g., a propagating transient electric or electromagnetic transmission). In at least one embodiment, a non-transitory computer-readable medium does not necessarily include non-transitory data storage circuitry (e.g., buffers, caches, and queues) within transceivers of transitory signals.</p><p id="p-0169" num="0158">In at least one embodiment, process <b>1000</b> is performed by one or more systems such as those described in this present disclosure. In at least one embodiment, one or more systems include any suitable system with a collection of one or more hardware and/or software resources with instructions that, when executed, performs memory allocation and/or deallocation processes such as those described herein. In at least one embodiment, process <b>1000</b> is performed by a system of one or more programming models. In at least one embodiment, one or more processes of process <b>1000</b> are performed in any suitable order, including sequential, parallel, and/or variations thereof, and using any suitable processing unit, such as a CPU, GPU, PPU, and/or variations thereof.</p><p id="p-0170" num="0159">In at least one embodiment, said system performing at least a part of process <b>1000</b> includes executable code to at least obtain <b>1002</b> code indicating at least generation of one or more graph code nodes. In at least one embodiment, one or more graph code nodes include nodes corresponding to memory deallocation operations, such as MemFree node. In at least one embodiment, MemFree node, also referred to as a graph code node corresponding to a memory deallocation operation or a graph code node to deallocate or free memory, encodes information regarding memory deallocation such as properties of memory to be deallocated, size of memory to be deallocated, constraints on memory to be deallocated, address of memory to be deallocated, and/or any suitable information. In at least one embodiment, said code indicates at least generation of one or more graph code nodes such as MemFree nodes and/or launch of a graph comprising said one or more graph code nodes. In at least one embodiment, said code utilizes one or more APIs to indicate at least generation of one or more graph code nodes. In at least one embodiment, said code comprises one or more API calls for generation of one or more graph nodes. In at least one embodiment, said system compiles and executes code. Further information regarding compiling and executing code can be found in description of <figref idref="DRAWINGS">FIGS. <b>30</b>-<b>39</b></figref>.</p><p id="p-0171" num="0160">In at least one embodiment, said system performing at least a part of process <b>1000</b> includes executable code to at least perform <b>1004</b> API to generate one or more graph code nodes to deallocate memory. In at least one embodiment, said system performs API to generate one or more graph code nodes to deallocate memory by generating or otherwise instantiating one or more MemFree nodes. In at least one embodiment, said system generates or otherwise obtains said graph data structure. In at least one embodiment, said system generates one or more graph code nodes to deallocate memory (e.g., MemFree node) as part of said graph data structure. In at least one embodiment, API to generate one or more graph code nodes to deallocate memory is denoted using following notation, although any variations thereof such as those described herein can be utilized:</p><p id="p-0172" num="0000"><tables id="TABLE-US-00016" num="00016"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="161pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;</entry><entry>&#x201c;result GraphAddMemFreeNode(</entry></row><row><entry/><entry>&#x2003;graphNode* GraphNode,</entry></row><row><entry/><entry>&#x2003;graph Graph,</entry></row><row><entry/><entry>&#x2003;const graphNode* dependencies,</entry></row><row><entry/><entry>&#x2003;size_t numDependencies,</entry></row><row><entry/><entry>&#x2003;deviceptr dptr);&#x201d;</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>in which &#x201c;GraphNode&#x201d; returns a created node, &#x201c;Graph&#x201d; indicates said graph to which to add said node, &#x201c;dependencies&#x201d; indicates dependencies of said node, &#x201c;numDependencies&#x201d; indicates a number of dependencies of said node, and &#x201c;dptr&#x201d; indicates an address of memory to free, and said API is denoted using any suitable notation, which may or may not be in reference to a programming model, and may include any suitable parameters in addition to or instead of those described above, which can be denoted using any suitable notation, which may or may not be in reference to a programming model. In at least one embodiment, said system generates said executable for said graph data structure.</p><p id="p-0173" num="0161">In at least one embodiment, said system performing at least a part of process <b>1000</b> includes executable code to at least launch <b>1006</b> graph to cause at least memory to be deallocated. In at least one embodiment, said system launches said graph on one or more devices by providing said executable for said graph to said one or more devices, in which said one or more devices execute said executable for said graph, and as part of said execution, perform one or more operations indicated by one or more nodes of said graph in any suitable manner, such as sequentially, in parallel, and/or variations thereof. In at least one embodiment, one or more devices use one or more graph code nodes to deallocate memory to deallocate memory by utilizing information encoded in said one or more graph code nodes to deallocate memory. In at least one embodiment, as an illustrative example, said graph code node to deallocate memory encodes information indicating an address of an allocation, in which a device deallocates memory located at said address.</p><p id="p-0174" num="0162">In at least one embodiment, said system causes one or more devices to allocate memory and deallocate allocated memory by launching said graph on said one or more devices that comprises at least one or more graph code nodes to allocate memory and one or more graph code nodes to deallocate memory. In at least one embodiment, said system causes one or more devices to allocate memory and deallocate allocated memory by launching a first graph on said one or more devices that comprises at least one or more graph code nodes to allocate memory and a second graph on said one or more devices that comprises one or more graph code nodes to deallocate memory. In at least one embodiment, said system causes one or more devices to perform one or more operations using allocating memory, and deallocate allocated memory by launching one or more graphs on said one or more devices that comprise at least one or more graph code nodes corresponding to said one or more operations and one or more graph code nodes to deallocate memory.</p><p id="p-0175" num="0163">In at least one embodiment, one or more devices deallocate memory based on information encoded in one or more graph code nodes to deallocate memory, in which said memory was allocated by said one or more devices based on one or more graph code nodes to allocate memory part of said graph that comprises said one or more graph code nodes to deallocate memory. In at least one embodiment, one or more devices deallocate memory based on information encoded in one or more graph code nodes to deallocate memory, in which said memory was allocated by said one or more devices based on one or more graph code nodes to allocate memory part of a different graph than graph that comprises said one or more graph code nodes to deallocate memory. In at least one embodiment, one or more devices deallocate memory based on information encoded in one or more graph code nodes to deallocate memory, in which said memory was allocated by said one or more devices based on one or more memory allocation processes, such as those that may or may not involve use of graphs.</p><p id="p-0176" num="0164">In at least one embodiment, said system utilizes one or more graph code nodes to deallocate memory. In at least one embodiment, said system causes one or more devices to deallocate memory through one or more operating system functions. In at least one embodiment, said system deallocates memory on one or more devices. In at least one embodiment, as an illustrative example, one or more devices deallocate memory by identifying a suitable region of allocated memory (e.g., based on information encoded in said graph code node to deallocate memory, or from information provided by one or more systems, such as a CPU), and indicating that said suitable region of allocated memory is not reserved and/or not in use for one or more operations. In at least one embodiment, one or more systems, such as a CPU, identify a suitable memory region (e.g., based on one or more graph code nodes to deallocate memory) and provide said identified memory region to one or more devices, in which said one or more devices utilize said identified memory region to deallocate memory.</p><p id="p-0177" num="0165">In at least one embodiment, one or more systems perform an API to generate one or more graph code nodes to allocate and deallocate memory. In at least one embodiment, API to generate one or more graph code nodes to allocate and deallocate memory is denoted using any suitable notation, which may or may not be in reference to a programming model, and may include any suitable parameters such as those described herein, which can be denoted using any suitable notation, which may or may not be in reference to a programming model, in which said parameters include an indication of one or more operations, one or more nodes, one or more graphs, properties of said one or more nodes, properties of dependencies, properties of memory to be allocated and/or deallocated, constraints of memory to be allocated and/or deallocated, and/or any suitable parameters.</p><p id="p-0178" num="0166">In at least one embodiment, one or more systems perform API to generate one or more graph code nodes to allocate and deallocate memory by generating a first graph code node to allocate memory and a second graph code node to deallocate memory, which may be part of one or more graphs (e.g., said first graph code node and said second graph code node may be part of a same graph, or different graphs). In at least one embodiment, one or more systems perform API to generate one or more graph code nodes to allocate and deallocate memory by generating a first graph code node to allocate memory for one or more operations (e.g., indicated through parameters of said API) and a second graph code node to deallocate said memory. In at least one embodiment, one or more systems launch one or more graphs comprising at least MemAlloc node and MemFree node on one or more devices to cause said one or more devices to at least allocate and deallocate memory.</p><p id="p-0179" num="0167">In at least one embodiment, an API, such as those described herein, is a driver API or a runtime API. In at least one embodiment, a driver API is a low-level API, which can be referred to in reference to a programming model (e.g., CUDA driver API). In at least one embodiment, a driver API interacts directly with one or more devices. In at least one embodiment, a runtime API is a high-level API, which can be referred to in reference to a programming model (e.g., CUDA runtime API). In at least one embodiment, a runtime API operates utilizing a driver API. Further information regarding a driver API and a runtime API can be found in description of <figref idref="DRAWINGS">FIG. <b>31</b></figref>.</p><p id="p-0180" num="0168">In at least one embodiment, graph memory nodes are graph nodes representing either memory allocation or free actions. In at least one embodiment, nodes that allocate memory are referred to as allocation nodes. In at least one embodiment, nodes that free memory are referred to as free nodes. In at least one embodiment, allocations created through graph memory nodes are referred to as graph allocations. In at least one embodiment, allocations are considered made anew every time said graph runs. In at least one embodiment, previous content of a buffer are not guaranteed to be there by one or more systems (e.g., due to reuse).</p><p id="p-0181" num="0169">In at least one embodiment, graph memory nodes are ordered by one or more systems within said graph by dependency edges. In at least one embodiment, one or more users, when utilizing said graph, must ensure that operations accessing graph memory must be ordered after an allocation node and/or must be ordered before an operation freeing memory. In at least one embodiment, GPU ordering refers to a stream and/or graph order that determines when work executes on a GPU. In at least one embodiment, said driver assigns virtual addresses for said graph allocation at node creation time. In at least one embodiment, one or more systems fix addresses for a lifetime of an allocation node, in which allocation contents are not persistent past a freeing operation.</p><p id="p-0182" num="0170">In at least one embodiment, graph memory nodes are explicitly created with various API functions, such as cudaGraphAddMemAllocNode, cudaGraphAddMemFreeNode, and/or variations thereof such as those described herein, which can be denoted in any suitable manner. In at least one embodiment, cudaGraphAddMemAllocNode fills in a dptr field of a passed CUDA_MEM_ALLOC_NODE_PARAMS structure with an allocation's virtual address. In at least one embodiment, all operations using graph allocations inside an allocating graph must be ordered after an allocating node. In at least one embodiment, any free nodes must be ordered after all uses of an allocation within said graph. In at least one embodiment, cudaGraphAddMemFreeNode creates free nodes.</p><p id="p-0183" num="0171">In at least one embodiment, one or more systems create said graph through following code, although any variations thereof can be utilized:</p><p id="p-0184" num="0000"><tables id="TABLE-US-00017" num="00017"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x201c;// Create graph - it starts out empty</entry></row><row><entry>cudaGraphCreate(&#x26;graph, 0);</entry></row><row><entry>// parameters for a basic allocation</entry></row><row><entry>cudaMemAllocNodeParams params = { };</entry></row><row><entry>params.poolProps.allocType = cudaMemAllocationTypePinned;</entry></row><row><entry>params.poolProps.location.type = cudaMemLocationTypeDevice;</entry></row><row><entry>// specify device 0 as resident device</entry></row><row><entry>params.poolProps.location.id = 0;</entry></row><row><entry>params.bytesize = size;</entry></row><row><entry>cudaGraphAddMemAllocNode(&#x26;allocNode, graph, NULL, 0, </entry></row><row><entry>&#x26;allocParams);</entry></row><row><entry>nodeParams-&#x3e;kernelParams[0] = allocParams.dptr;</entry></row><row><entry>cudaGraphAddKernelNode(&#x26;a, graph, &#x26;allocNode, 1, &#x26;nodeParams);</entry></row><row><entry>cudaGraphAddKernelNode(&#x26;b, graph, &#x26;a, 1, &#x26;nodeParams);</entry></row><row><entry>cudaGraphAddKernelNode(&#x26;c, graph, &#x26;a, 1, &#x26;nodeParams);</entry></row><row><entry>cudaGraphNode_t dependencies[2];</entry></row><row><entry>// kernel nodes b and c are using graph allocation, so a freeing node must </entry></row><row><entry>depend on them. Since dependency of node b on node a establishes an </entry></row><row><entry>indirect dependency, a free node does not need to explicitly depend on </entry></row><row><entry>node a.</entry></row><row><entry>dependencies[0] = b;</entry></row><row><entry>dependencies[1] = c;</entry></row><row><entry>cudaGraphAddMemFreeNode(&#x26;freeNode, graph, dependencies, 2, </entry></row><row><entry>allocParams.dptr);</entry></row><row><entry>// free node does not depend on kernel node d, so it must not access a </entry></row><row><entry>freed graph allocation.</entry></row><row><entry>cudaGraphAddKernelNode(&#x26;d, graph, &#x26;c, 1, &#x26;nodeParams);</entry></row><row><entry>// node e does not depend on an allocation node, so it must not access an </entry></row><row><entry>allocation. This would be true even if a freeNode depended on kernel </entry></row><row><entry>node e.</entry></row><row><entry>cudaGraphAddKernelNode(&#x26;e, graph, NULL, 0, &#x26;nodeParams);.&#x201d;</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0185" num="0172">In at least one embodiment, graph memory nodes can be created by capturing corresponding stream ordered allocation and free calls. In at least one embodiment, virtual addresses returned by a captured allocation API can be used by other operations inside said graph. In at least one embodiment, one or more systems capture stream ordered dependencies into said graph, in which ordering requirements of stream ordered allocation APIs guarantee that various graph memory nodes will be properly ordered with respect to captured stream operations.</p><p id="p-0186" num="0173">In at least one embodiment, one or more systems generate said graph using stream capture through following code, although any variations thereof can be utilized:</p><p id="p-0187" num="0000"><tables id="TABLE-US-00018" num="00018"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="14pt" align="left"/><colspec colname="2" colwidth="203pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;</entry><entry>&#x201c;// stream1 is an origin stream</entry></row><row><entry/><entry>cudaStreamBeginCapture(stream1);</entry></row><row><entry/><entry>cudaMallocAsync(&#x26;dptr, size, stream1);</entry></row><row><entry/><entry>kernel_A&#x3c;&#x3c;&#x3c; ..., stream1 &#x3e;&#x3e;&#x3e;(dptr, ...);</entry></row><row><entry/><entry>// Fork into stream2</entry></row><row><entry/><entry>cudaEventRecord(event1, stream1);</entry></row><row><entry/><entry>cudaStreamWaitEvent(stream2, event1);</entry></row><row><entry/><entry>kernel_B&#x3c;&#x3c;&#x3c; ..., stream1 &#x3e;&#x3e;&#x3e;(dptr, ...);</entry></row><row><entry/><entry>// event dependencies translated into graph dependencies, so a kernel</entry></row><row><entry/><entry>node created by a capture of kernel C will depend on an allocation</entry></row><row><entry/><entry>node created by capturing a cudaMallocAsync call.</entry></row><row><entry/><entry>kernel_C&#x3c;&#x3c;&#x3c; ..., stream2 &#x3e;&#x3e;&#x3e;(dptr, ...);</entry></row><row><entry/><entry>// Join stream2 back to origin stream (stream1)</entry></row><row><entry/><entry>cudaEventRecord(event2, stream2);</entry></row><row><entry/><entry>cudaStreamWaitEvent(stream1, event2);</entry></row><row><entry/><entry>//Free depends on all work accessing memory.</entry></row><row><entry/><entry>cudaFreeAsync(dptr, stream1);</entry></row><row><entry/><entry>// End capture in an origin stream</entry></row><row><entry/><entry>cudaStreamEndCapture(stream1, &#x26;graph);.&#x201d;</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0188" num="0174">In at least one embodiment, graph allocations do not have to be freed by an allocating graph. In at least one embodiment, when said graph does not free allocations it makes, said allocations persist beyond execution of said graph. In at least one embodiment, allocations may be freed by regular calls using various API functions to free allocated memory, a launch of another graph with a corresponding free node, and/or a subsequent launch of said graph (e.g., if it was instantiated with one or more flags such as those described herein). In at least one embodiment, free operation (e.g., MemFree node or other memory deallocating operation) must be ordered after all operations accessing memory through graph dependencies, various events, and/or other mechanisms (e.g., stream ordering mechanisms). In at least one embodiment, allocations may be accessed in another graph or directly in a stream operation as long as an accessing operation is ordered after an allocation through events and stream ordering mechanisms.</p><p id="p-0189" num="0175">In at least one embodiment, graph allocations share underlying physical memory with each other. In at least one embodiment, free operation must be ordered after a full device operation (e.g., compute kernel, memory copy operations, and/or variations thereof) completes. In at least one embodiment, out of band operations, such as writing to system memory as part of a compute kernel that writes to graph memory, may not be sufficient for providing an ordering guarantee between memory writes to graph memory and free operation of that graph memory.</p><p id="p-0190" num="0176">In at least one embodiment, one or more systems access and free graph allocated memory in a same stream through following code, although any variations thereof can be utilized:</p><p id="p-0191" num="0000"><tables id="TABLE-US-00019" num="00019"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="7pt" align="left"/><colspec colname="2" colwidth="210pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x201c;void *dptr;</entry></row><row><entry/><entry>cudaGraphAddMemAllocNode(&#x26;allocNode, allocGraph, NULL, 0, </entry></row><row><entry/><entry>&#x26;allocParams);</entry></row><row><entry/><entry>dptr = allocParams.dptr;</entry></row><row><entry/><entry>cudaGraphInstantiate(&#x26;allocGraphExec, allocGraph, NULL, NULL, 0);</entry></row><row><entry/><entry>cudaGraphLaunch(allocGraphExec, stream);</entry></row><row><entry/><entry>kernel&#x3c;&#x3c;&#x3c; ..., stream &#x3e;&#x3e;&#x3e;(dptr, ...);</entry></row><row><entry/><entry>cudaFreeAsync(dptr, stream);.&#x201d;</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0192" num="0177">In at least one embodiment, one or more systems access and free graph allocated memory from other streams and other graphs through following code, although any variations thereof can be utilized:</p><p id="p-0193" num="0000"><tables id="TABLE-US-00020" num="00020"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x201c;void *dptr;</entry></row><row><entry>// Contents of allocating graph</entry></row><row><entry>cudaGraphAddMemAllocNode(&#x26;allocNode, allocGraph, NULL, 0, </entry></row><row><entry>&#x26;allocParams);</entry></row><row><entry>dptr = allocParams.dptr;</entry></row><row><entry>// contents of consuming/freeing graph</entry></row><row><entry>nodeParams-&#x3e;kernelParams[0] = allocParams.dptr;</entry></row><row><entry>cudaGraphAddKernelNode(&#x26;a, graph, NULL, 0, &#x26;nodeParams);</entry></row><row><entry>cudaGraphAddMemFreeNode(&#x26;freeNode, freeGraph, &#x26;a, 1, dptr);</entry></row><row><entry>&#x2003;udaGraphInstantiate(&#x26;allocGraphExec, allocGraph, NULL, NULL, 0);</entry></row><row><entry>cudaGraphInstantiate(&#x26;freeGraphExec, freeGraph, NULL, NULL, 0);</entry></row><row><entry>cudaGraphLaunch(allocGraphExec, allocStream);</entry></row><row><entry>// establish dependency of stream2 on an allocation node</entry></row><row><entry>// note: dependency could also have been established with a stream </entry></row><row><entry>synchronize operation</entry></row><row><entry>cudaEventRecord(allocEvent, allocStream)</entry></row><row><entry>cudaStreamWaitEvent(stream2, allocEvent);</entry></row><row><entry>kernel&#x3c;&#x3c;&#x3c; ..., stream2 &#x3e;&#x3e;&#x3e; (dptr, ...);</entry></row><row><entry>// establish dependency between stream 3 and an allocation use</entry></row><row><entry>cudaStreamRecordEvent(streamUseDoneEvent, stream2);</entry></row><row><entry>cudaStreamWaitEvent(stream3, streamUseDoneEvent);</entry></row><row><entry>// it is now safe to launch a freeing graph, which may also access memory </entry></row><row><entry>cudaGraphLaunch(freeGraphExec, stream3);.&#x201d;</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0194" num="0178">In at least one embodiment, one or more systems establish dependencies for accessing memory from other streams using graph event nodes through following code, although any variations thereof can be utilized:</p><p id="p-0195" num="0000"><tables id="TABLE-US-00021" num="00021"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x201c;void *dptr;</entry></row><row><entry>cudaEvent_t allocEvent; // event indicating when an allocation will be ready for use.</entry></row><row><entry>cudaEvent_t streamUseDoneEvent; // event indicating when stream operations are done</entry></row><row><entry>with an allocation.</entry></row><row><entry>// Contents of allocating graph with event record node</entry></row><row><entry>cudaGraphAddMemAllocNode(&#x26;allocNode, allocGraph, NULL, 0, &#x26;allocParams); dptr</entry></row><row><entry>= allocParams.dptr;</entry></row><row><entry>// note: this event record node depends on an alloc node</entry></row><row><entry>cudaGraphAddEventRecordNode(&#x26;recordNode, allocGraph, &#x26;allocNode, 1,</entry></row><row><entry>allocEvent); cudaGraphInstantiate(&#x26;allocGraphExec, allocGraph, NULL, NULL, 0);</entry></row><row><entry>// contents of consuming/freeing graph with event wait nodes</entry></row><row><entry>cudaGraphAddEventWaitNode(&#x26; streamUseDoneEventNode, waitAndFreeGraph,</entry></row><row><entry>NULL, 0, streamUseDoneEvent);</entry></row><row><entry>cudaGraphAddEventWaitNode(&#x26;allocReadyEventNode, waitAndFreeGraph, NULL, 0,</entry></row><row><entry>allocEvent);</entry></row><row><entry>nodeParams-&#x3e;kernelParams[0] = allocParams.dptr;</entry></row><row><entry>// An allocReadyEventNode provides ordering with an alloc node for use in a consuming</entry></row><row><entry>graph.</entry></row><row><entry>cudaGraphAddKernelNode(&#x26;kernelNode, waitAndFreeGraph, &#x26;allocReadyEventNode,</entry></row><row><entry>1, &#x26;nodeParams);</entry></row><row><entry>// A free node has to be ordered after both external and internal users.</entry></row><row><entry>// Thus node must depend on both a kernelNode and a streamUseDoneEventNode.</entry></row><row><entry>dependencies[0] = kernelNode;</entry></row><row><entry>dependencies[l] = streamUseDoneEventNode;</entry></row><row><entry>cudaGraphAddMemFreeNode(&#x26;freeNode, waitAndFreeGraph, &#x26;dependencies, 2, dptr);</entry></row><row><entry>cudaGraphInstantiate(&#x26;waitAndFreeGraphExec, waitAndFreeGraph, NULL, NULL, 0);</entry></row><row><entry>cudaGraphLaunch(allocGraphExec, allocStream);</entry></row><row><entry>// establish dependency of stream2 on a event node satisfies an ordering requirement</entry></row><row><entry>cudaStreamWaitEvent(stream2, allocEvent);</entry></row><row><entry>kernel&#x3c;&#x3c;&#x3c; ..., stream2 &#x3e;&#x3e;&#x3e; (dptr, ...);</entry></row><row><entry>cudaStreamRecordEvent(streamUseDoneEvent, stream2);</entry></row><row><entry>// an event wait node in a waitAndFreeGraphExec establishes a dependency on a</entry></row><row><entry>&#x201c;readyForFreeEvent&#x2033; that is needed to prevent a kernel running in stream two from</entry></row><row><entry>accessing an allocation after a free node in execution order.</entry></row><row><entry>cudaGraphLaunch(waitAndFreeGraphExec, stream3);.&#x201d;</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0196" num="0179">In at least one embodiment, one or more systems provide functionality to share physical allocations between graphs. In at least one embodiment, applications can utilize multiple streams. In at least one embodiment, using a same graph with various graph memory nodes in multiple streams can cause said driver to thrash mappings. In at least one embodiment, applications that don't free memory within an allocating graph may impose serialization on other allocating graphs.</p><p id="p-0197" num="0180">In at least one embodiment, physical memory is not allocated or mapped during graph instantiation. In at least one embodiment, a first graph upload or launch results in an allocation and mapping cost. In at least one embodiment, one or more systems upload allocating graphs to streams that they will be used on, as one or more systems may perform remapping when said graph is launched on a different stream.</p><p id="p-0198" num="0181">In at least one embodiment, a cost of remapping can be incurred in said graph launch waiting for a stream ordered free of said graph's allocations, in a stream waiting for previous uses of physical memory to complete, and/or in an execution time of OS calls to allocate, map and un-map physical memory. In at least one embodiment, memory remapping cost paid when said graph switches streams is represented by one or more systems through following code, although any variations thereof can be utilized:</p><p id="p-0199" num="0000"><tables id="TABLE-US-00022" num="00022"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="7pt" align="left"/><colspec colname="2" colwidth="210pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x201c;cudaGraphLaunch(graph1, stream A);</entry></row><row><entry/><entry>cudaGraphLaunch(graph2, streamA);</entry></row><row><entry/><entry>// remapping cost paid when graph1 is launched on streamB as long as </entry></row><row><entry/><entry>graph2 has yet to complete.</entry></row><row><entry/><entry>cudaGraphLaunch(graph1, streamB);.&#x201d;</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0200" num="0182">In at least one embodiment, memory reassigned to alternate stream causing other graph launches in original stream to pay remapping cost is represented by one or more systems through following code, although any variations thereof can be utilized:</p><p id="p-0201" num="0000"><tables id="TABLE-US-00023" num="00023"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="7pt" align="left"/><colspec colname="2" colwidth="210pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x201c;cudaGraphLaunch(graph1, stream A);</entry></row><row><entry/><entry>cudaGraphLaunch(graph2, streamA);</entry></row><row><entry/><entry>cudaStreamSynchronize(streamA);</entry></row><row><entry/><entry>// graph1 &#x26; graph2 share underlying physical memory because they </entry></row><row><entry/><entry>were both launched on streamA</entry></row><row><entry/><entry>// graph2 launching on streamB pulls memory with it, as streamA is idle</entry></row><row><entry/><entry>cudaGraphLaunch(graph2, streamB);</entry></row><row><entry/><entry>// graph1 pays remapping cost because memory is now associated with </entry></row><row><entry/><entry>streamB(assuming graph2 is still running at a time of this launch).</entry></row><row><entry/><entry>cudaGraphLaunch(graph1, streamA);.&#x201d;</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0202" num="0183">In at least one embodiment, memory remapping due to unfreed allocation is represented by one or more systems through following code, although any variations thereof can be utilized:</p><p id="p-0203" num="0000"><tables id="TABLE-US-00024" num="00024"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="7pt" align="left"/><colspec colname="2" colwidth="210pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x201c;cudaGraphLaunch(graph1, stream A);</entry></row><row><entry/><entry>cudaGraphLaunch(graph2_noFree, stream A);</entry></row><row><entry/><entry>// graph1 &#x26; graph2_noFree share underlying physical memory because </entry></row><row><entry/><entry>they were both launched on streamA</entry></row><row><entry/><entry>// let dptr be memory allocated and not freed by graph2_noFree.</entry></row><row><entry/><entry>// because graph2_noFree did not free dptr, graph1 will have to wait for </entry></row><row><entry/><entry>itself to complete and then unmap corresponding physical memory</entry></row><row><entry/><entry>cudaGraphLaunch(graph1, streamA);.&#x201d;</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0204" num="0184">In at least one embodiment, memory serialization due to allocation freed in another stream is represented by one or more systems through following code, although any variations thereof can be utilized:</p><p id="p-0205" num="0000"><tables id="TABLE-US-00025" num="00025"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="7pt" align="left"/><colspec colname="2" colwidth="210pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x201c;cudaGraphLaunch(graph1, stream A);</entry></row><row><entry/><entry>cudaGraphLaunch(graph2_noFree, stream A);</entry></row><row><entry/><entry>// graph1 &#x26; graph2_noFree share underlying physical memory because </entry></row><row><entry/><entry>they were both launched on streamA</entry></row><row><entry/><entry>// let dptr be memory allocated and not freed by graph2_noFree.</entry></row><row><entry/><entry>cudaStreamWaitEvent(streamB, graph2_dptrAllocatedEvent);</entry></row><row><entry/><entry>kernel&#x3c;&#x3c;&#x3c; ... ,streamB&#x3e;&#x3e;&#x3e; (dptr, ...);</entry></row><row><entry/><entry>cudaFreeAsync(dptr, streamB);</entry></row><row><entry/><entry>// Since physical memory mapped to dptr is still associated with </entry></row><row><entry/><entry>// streamA, launching graph1 in streamA may use that memory, in </entry></row><row><entry/><entry>// which case a driver will insert a dependency in streamA on a dptr </entry></row><row><entry/><entry>free in streamB.</entry></row><row><entry/><entry>cudaGraphLaunch(graph1, streamA);.&#x201d;</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0206" num="0185">In at least one embodiment, destroying allocating graphs will not cause one or more systems to return allocated memory to OS for use by other processes. In at least one embodiment, to release memory back to OS, an application needs to use one or more API functions such as a cudaDeviceGraphMemTrim API function. In at least one embodiment, cudaDeviceGraphMemTrim un-maps and releases any graph memory node's reserved physical memory that is safe to un-map. In at least one embodiment, memory that is not actively in use (e.g., allocations that have not been freed and graphs that are scheduled or running are considered to be actively using physical memory) can be referred to as safe to un-map. In at least one embodiment, one or more API functions make physical memory available to other allocation API functions and other applications/processes, but can cause said driver to allocate and map memory when launching graphs that had mappings to released memory.</p><p id="p-0207" num="0186">In at least one embodiment, one or more systems provide functionality for applications to query their graph memory footprint through an API function denoted as cudaDeviceGetGraphMemAttribute. In at least one embodiment, querying an attribute denoted as cudaGraphMemAttrReservedMemCurrent returns an amount of physical memory reserved by one or more drivers for graph allocations in a current process. In at least one embodiment, querying an attribute denoted as cudaGraphMemAttrUsedMemCurrent returns an amount of physical memory currently mapped by at least one graph. In at least one embodiment, various attributes can be utilized to track when new physical memory is acquired by said driver in connection with an allocating graph. In at least one embodiment, various attributes can be utilized to determine how much memory is saved by a sharing mechanism.</p><p id="p-0208" num="0187">In at least one embodiment, one or more systems provide functionality to configure graph allocations for access from multiple GPUs. In at least one embodiment, said driver maps allocations into one or more GPUs as required. In at least one embodiment, said driver provides functionality for graph allocations requiring different mappings to reuse a same virtual address, in which, when this occurs, VA is mapped on a set of GPUs required by different allocations. In at least one embodiment, a set of GPUs that an allocation is mapped on can respond to changes in mappings of other allocations or changes in said driver's sub-allocation heuristics. In at least one embodiment, when applications request correct mappings on all multi-GPU allocations, all necessary mappings will be made by one or more systems.</p><p id="p-0209" num="0188">In at least one embodiment, cudaGraphAddMemAllocNode API function, or any suitable function, accepts mapping requests in an accessDescs array field of a node parameters structures. In at least one embodiment, poolProps.location embedded structure specifies a resident device for an allocation. In at least one embodiment, access from an allocating GPU is assumed to be needed, thus an application does not need to specify an entry for a resident device in an accessDescs array. In at least one embodiment, one or more systems perform peer access with graph node APIs through following code, although any variations thereof can be utilized:</p><p id="p-0210" num="0000"><tables id="TABLE-US-00026" num="00026"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x201c;cudaMemAllocNodeParams params = { };</entry></row><row><entry>params.poolProps.allocType = cudaMemAllocationTypePinned;</entry></row><row><entry>params.poolProps.location.type = cudaMemLocationTypeDevice;</entry></row><row><entry>// specify device 1 as a resident device</entry></row><row><entry>params.poolProps.location.id = 1;</entry></row><row><entry>params.bytesize = size;</entry></row><row><entry>// allocate an allocation resident on device 1 accessible from device 1</entry></row><row><entry>cudaGraphAddMemAllocNode(&#x26;allocNode, graph, NULL, 0, &#x26;params);</entry></row><row><entry>accessDescs[2];</entry></row><row><entry>// boilerplate for an access descs (only ReadWrite and Device access </entry></row><row><entry>supported by an add node API)</entry></row><row><entry>accessDescs[0].flags = cudaMemAccessFlagsProtReadWrite;</entry></row><row><entry>accessDescs[0].location.type = cudaMemLocationTypeDevice;</entry></row><row><entry>accessDescs[1].flags = cudaMemAccessFlagsProtReadWrite;</entry></row><row><entry>accessDescs[1].location.type = cudaMemLocationTypeDevice;</entry></row><row><entry>// access being requested for device 0 &#x26; 2. Device 1 access requirement </entry></row><row><entry>left implicit.</entry></row><row><entry>accessDescs[0].location.id = 0;</entry></row><row><entry>accessDescs[1].location.id = 2;</entry></row><row><entry>// access request array has 2 entries.</entry></row><row><entry>params.accessDescCount = 2;</entry></row><row><entry>params.accessDescs = accessDescs;</entry></row><row><entry>// allocate an allocation resident on device 1 accessible from devices 0, 1 </entry></row><row><entry>and 2. (0 &#x26; 2 from descriptors, 1 from it being a resident device).</entry></row><row><entry>cudaGraphAddMemAllocNode(&#x26;allocNode, graph, NULL, 0, </entry></row><row><entry>&#x26;params);.&#x201d;</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0211" num="0189">In at least one embodiment, for stream capture, an allocation node records peer accessibility of an allocating pool at a time of a capture. In at least one embodiment, altering a peer accessibility of a stream ordered allocation pool after an API call such as a cudaMallocFromPoolAsync call is captured does not affect mappings that said graph will make for an allocation. In at least one embodiment, one or more systems perform peer access with stream capture through following code, although any variations thereof can be utilized:</p><p id="p-0212" num="0000"><tables id="TABLE-US-00027" num="00027"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x201c;// boilerplate for an access descs (only ReadWrite and Device access </entry></row><row><entry>supported by an add node API)</entry></row><row><entry>accessDesc.flags = cudaMemAccessFlagsProtReadWrite;</entry></row><row><entry>accessDesc.location.type = cudaMemLocationTypeDevice;</entry></row><row><entry>accessDesc.location.id = 1;</entry></row><row><entry>// let memPool be resident and accessible on device 0</entry></row><row><entry>cudaStreamBeginCapture(stream);</entry></row><row><entry>cudaMallocAsync(&#x26;dptr1, size, memPool, stream);</entry></row><row><entry>cudaStreamEndCapture(stream, &#x26;graph1);</entry></row><row><entry>cudaMemPoolSetAccess(memPool, &#x26;accessDesc, 1);</entry></row><row><entry>cudaStreamBeginCapture(stream);</entry></row><row><entry>cudaMallocAsync(&#x26;dptr2, size, memPool, stream);</entry></row><row><entry>cudaStreamEndCapture(stream, &#x26;graph2);</entry></row><row><entry>//Said graph node allocating dptr1 would only have a device 0 accessibility </entry></row><row><entry>even though memPool now has device 1 accessibility.</entry></row><row><entry>//Said graph node allocating dptr2 will have device 0 and device 1 </entry></row><row><entry>accessibility, since that was a pool accessibility at a time of a </entry></row><row><entry>cudaMallocAsync call.&#x201d;</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0213" num="0190">In at least one embodiment, graph capture (e.g., generating said graph using stream capture) processes a region of execution, encoding various operations of one or more systems and virtual addresses utilized into said graph. In at least one embodiment, said graph may be utilized one or more times. In at least one embodiment, capture encodes memory addresses, and memory used during capture must be available for said graph to utilize during replay. In at least one embodiment, one or more systems assign and free memory dynamically. In at least one embodiment, said graph's memory can be utilized by various other operations. In at least one embodiment, to guarantee said graph's encoded addresses are safe to reuse in replay, one or more systems satisfy allocations from a graph-private memory pool during capture, and don't begin freeing those addresses until said graph is destroyed. In at least one embodiment, within a private pool, allocations are freed and reassigned by one or more systems during capture. In at least one embodiment, memory regions are used in a consistent order by one or more systems during replay. In at least one embodiment, a private pool reserves its high-water mark of used memory away from default pools as long as capture(s) it served survive, regardless whether those captures are idle or replaying. In at least one embodiment, said graph's requests for private pools are mediated by one or more systems, which can be denoted as a DeviceAllocator (e.g., DeviceAllocator::notifyCaptureBegin, notifyCaptureEnd, and/or notifyCaptureDestroy).</p><p id="p-0214" num="0191">In at least one embodiment, graphs can allocate and free memory through nodes indicating allocation and free operations. In at least one embodiment, when one or more systems allocate memory using said graph, a pointer is returned at node creation time, which can be passed as an argument to later nodes, in which dereferencing said pointer is only permitted downstream of allocation node (e.g., MemAlloc node) and upstream of a free node (e.g., MemFree node). In at least one embodiment, one or more systems provide each graph with a unique VA range. In at least one embodiment, virtual address ranges returned from in-graph allocation come only from that graph's address pool, and persist for a lifetime of said graph. In at least one embodiment, graphs can share physical allocations, in which contents are not preserved between launches even of a same graph. In at least one embodiment, allocation lifetime may extend outside said graph. In at least one embodiment, one or more systems permit allocating in one graph and freeing in another. In at least one embodiment, an allocating graph must not be launched again, however, until a freeing operation has occurred.</p><p id="p-0215" num="0192">In at least one embodiment, edges in graphs which have memory nodes may not be modified after creation. In at least one embodiment, altering edges may result in upstream freeing nodes no longer being upstream. In at least one embodiment, allocation nodes cause inter-graph serialization, in which one or more systems provide functionality to manage unique/shared backing memory, and when allocations are made. In at least one embodiment, inter-process communication (IPC)-shareability must be defined by one or more systems at allocation time in which, IPC-shareable allocations must persist beyond a lifetime of an allocating graph</p><p id="p-0216" num="0193">In at least one embodiment, allocations and freeing allocations can occur in a same graph. In at least one embodiment, allocations can occur in one graph and freeing allocations can occur in another graph. In at least one embodiment, allocations can occur in one graph and freeing allocations can occur via one or more API functions.</p><p id="p-0217" num="0194">In at least one embodiment, virtual address and physical address lifetimes are different for graphs. In at least one embodiment, each graph has a private virtual address range. In at least one embodiment, physical pages may be mapped by one or more systems at graph node creation, in which virtual addresses can be returned. In at least one embodiment, a virtual address remains valid for a lifetime (e.g., execution lifetime) of said graph. In at least one embodiment, per-graph virtual address ranges guarantee that pointer lifetimes have graph lifetime. In at least one embodiment, allocation and mapping can occur at graph instantiation, in which memory is held by one or more systems for a lifetime of said graph, at graph launch, in which launch latency can increase while memory is mapped, and/or variations thereof.</p><p id="p-0218" num="0195">In at least one embodiment, one or more systems perform shared physical page mappings to reduce computing resources for creating one or more graphs. In at least one embodiment, each graph has a private virtual address range, in which pointer lifetimes have said graph lifetime. In at least one embodiment, one or more systems reserve a set of physical pages equal to a largest memory requirement of any graph. In at least one embodiment, one or more systems map all graphs to a same page set, unless executing concurrently. In at least one embodiment, one or more systems perform pre-mapping of physical pages.</p><p id="p-0219" num="0196">In at least one embodiment, long-lived allocations refer to allocations that are not freed within a same graph. In at least one embodiment, virtual addresses returned by allocations remain fixed for said graph. In at least one embodiment, one or more systems configure said graph to pre-free allocations such that multiple launches can be permitted. In at least one embodiment, one or more systems track page lifetimes on a per-graph basis.</p><p id="p-0220" num="0197">In at least one embodiment, one or more systems perform allocation on instantiation of said graph, which can result in minimal delays between graphs (e.g., independent pages). In at least one embodiment, one or more systems perform allocation and/or mapping on launch of said graph, which can require allocations between graphs for allocation and/or remapping. In at least one embodiment, one or more systems perform shared allocation, which can result in minimal delays between graphs pre-mapped on instantiation.</p><p id="p-0221" num="0198">In at least one embodiment, one or more systems launch graphs concurrently, which can require per-concurrent-graph unique physical pages. In at least one embodiment, one or more systems create physical page pools per-stream, which allows sharing between graphs in a same stream, but concurrent execution between streams, which can result in increased latency to first launch in a new stream, but pre-allocation can be performed. In at least one embodiment, one or more systems control when to free stream allocations, in which repeated launches can retain physical allocations, and single launches can free allocations.</p><p id="p-0222" num="0199">In at least one embodiment, one or more systems provide functionality to update graphs through one or more stream capture operations. In at least one embodiment, stream capture creates a new graph with a new VA range. In at least one embodiment, graph update replaces an original graph's VA range with an updated graph's VA range. In at least one embodiment, one or more systems prevent single-memory-node parameter update, although in at least one embodiment such operations are permitted. In at least one embodiment, one or more systems return an original graph VA to said graph system for re-use.</p><p id="p-0223" num="0200">In at least one embodiment, one or more systems provide stream capture and explicit API for creating memory nodes in graph, in which memory nodes follow semantics of various API functions for allocation memory. In at least one embodiment, one or more systems provide per-graph VA for asynchronous allocations, established on graph create. In at least one embodiment, one or more systems maintain physical pages equal to size of largest instantiated graph. In at least one embodiment, one or more systems perform shared mapping for said graph VA to a physical page pool on instantiation. In at least one embodiment, one or more systems create one or more per-stream physical page pools on first launch into new stream. In at least one embodiment, one or more systems provide functionality to update said graph and resize a page pool, such as when a memory footprint grows. In at least one embodiment, a memory footprint refers to an amount of memory a program uses, references, or otherwise utilizes in various states, such as while running or otherwise executing.</p><p id="p-0224" num="0201">In at least one embodiment, one or more systems provide functionality to perform various memory allocation operations in said graph through allocation and/or free nodes (e.g., MemAlloc and MemFree nodes, respectively). In at least one embodiment, one or more systems utilize dependencies between nodes to track memory reuse within said graph. In at least one embodiment, each graph has a private virtual address range, allowing allocations to have a fixed address over a lifetime of said graph. In at least one embodiment, all graphs launched into a given stream have their virtual footprints aliased by one or more systems onto shared per-stream physical memory, enabling physical memory reuse between graphs. In at least one embodiment, when a launch stream of said graph changes and/or memory is freed outside of an allocating graph, one or more systems (e.g., a driver) tracks mappings to and usage of physical memory to enable reuse. In at least one embodiment, allocators are implemented in one or more drivers, which enables use of low-level memory operations to limit fragmentation, and use of various information about memory consumption, stream dependencies and/or work completion to detect opportunities for memory reuse.</p><p id="p-0225" num="0202">It should be noted that API functions and other related terminology, such as parameters, variable names, and/or variations thereof, can be denoted in any suitable manner using any suitable terminology, which may or may not be related to one or more functionalities of said API functions. Additionally, it should be noted that while example embodiments described herein may relate to a CUDA programming model, techniques described herein can be utilized with any suitable programming model and/or any suitable API of any suitable programming model, such as CUDA, HIP, oneAPI, and/or variations thereof.</p><p id="p-0226" num="0203">In the preceding and following description, numerous specific details are set forth to provide a more thorough understanding of at least one embodiment. However, it will be apparent to one skilled in the art that the inventive concepts may be practiced without one or more of these specific details.</p><heading id="h-0006" level="1">Data Center</heading><p id="p-0227" num="0204"><figref idref="DRAWINGS">FIG. <b>11</b></figref> illustrates an exemplary data center <b>1100</b>, in accordance with at least one embodiment. In at least one embodiment, data center <b>1100</b> includes, without limitation, a data center infrastructure layer <b>1110</b>, a framework layer <b>1120</b>, a software layer <b>1130</b> and an application layer <b>1140</b>.</p><p id="p-0228" num="0205">In at least one embodiment, as shown in <figref idref="DRAWINGS">FIG. <b>11</b></figref>, data center infrastructure layer <b>1110</b> may include a resource orchestrator <b>1112</b>, grouped computing resources <b>1114</b>, and node computing resources (&#x201c;node C.R.s&#x201d;) <b>1116</b>(1)-<b>1116</b>(N), where &#x201c;N&#x201d; represents any whole, positive integer. In at least one embodiment, node C.R.s <b>1116</b>(1)-<b>1116</b>(N) may include, but are not limited to, any number of central processing units (&#x201c;CPUs&#x201d;) or other processors (including accelerators, field programmable gate arrays (&#x201c;FPGAs&#x201d;), data processing units (&#x201c;DPUs&#x201d;) in network devices, graphics processors, etc.), memory devices (e.g., dynamic read-only memory), storage devices (e.g., solid state or disk drives), network input/output (&#x201c;NW I/O&#x201d;) devices, network switches, virtual machines (&#x201c;VMs&#x201d;), power modules, and cooling modules, etc. In at least one embodiment, one or more node C.R.s from among node C.R.s <b>1116</b>(1)-<b>1116</b>(N) may be a server having one or more of above-mentioned computing resources.</p><p id="p-0229" num="0206">In at least one embodiment, grouped computing resources <b>1114</b> may include separate groupings of node C.R.s housed within one or more racks (not shown), or many racks housed in data centers at various geographical locations (also not shown). Separate groupings of node C.R.s within grouped computing resources <b>1114</b> may include grouped compute, network, memory or storage resources that may be configured or allocated to support one or more workloads. In at least one embodiment, several node C.R.s including CPUs or processors may grouped within one or more racks to provide compute resources to support one or more workloads. In at least one embodiment, one or more racks may also include any number of power modules, cooling modules, and network switches, in any combination.</p><p id="p-0230" num="0207">In at least one embodiment, resource orchestrator <b>1112</b> may configure or otherwise control one or more node C.R.s <b>1116</b>(1)-<b>1116</b>(N) and/or grouped computing resources <b>1114</b>. In at least one embodiment, resource orchestrator <b>1112</b> may include a software design infrastructure (&#x201c;SDI&#x201d;) management entity for data center <b>1100</b>. In at least one embodiment, resource orchestrator <b>1112</b> may include hardware, software or some combination thereof.</p><p id="p-0231" num="0208">In at least one embodiment, as shown in <figref idref="DRAWINGS">FIG. <b>11</b></figref>, framework layer <b>1120</b> includes, without limitation, a job scheduler <b>1132</b>, a configuration manager <b>1134</b>, a resource manager <b>1136</b> and a distributed file system <b>1138</b>. In at least one embodiment, framework layer <b>1120</b> may include a framework to support software <b>1152</b> of software layer <b>1130</b> and/or one or more application(s) <b>1142</b> of application layer <b>1140</b>. In at least one embodiment, software <b>1152</b> or application(s) <b>1142</b> may respectively include web-based service software or applications, such as those provided by Amazon Web Services, Google Cloud and Microsoft Azure. In at least one embodiment, framework layer <b>1120</b> may be, but is not limited to, a type of free and open-source software web application framework such as Apache Spark&#x2122; (hereinafter &#x201c;Spark&#x201d;) that may utilize distributed file system <b>1138</b> for large-scale data processing (e.g., &#x201c;big data&#x201d;). In at least one embodiment, job scheduler <b>1132</b> may include a Spark driver to facilitate scheduling of workloads supported by various layers of data center <b>1100</b>. In at least one embodiment, configuration manager <b>1134</b> may be capable of configuring different layers such as software layer <b>1130</b> and framework layer <b>1120</b>, including Spark and distributed file system <b>1138</b> for supporting large-scale data processing. In at least one embodiment, resource manager <b>1136</b> may be capable of managing clustered or grouped computing resources mapped to or allocated for support of distributed file system <b>1138</b> and job scheduler <b>1132</b>. In at least one embodiment, clustered or grouped computing resources may include grouped computing resource <b>1114</b> at data center infrastructure layer <b>1110</b>. In at least one embodiment, resource manager <b>1136</b> may coordinate with resource orchestrator <b>1112</b> to manage these mapped or allocated computing resources.</p><p id="p-0232" num="0209">In at least one embodiment, software <b>1152</b> included in software layer <b>1130</b> may include software used by at least portions of node C.R.s <b>1116</b>(1)-<b>1116</b>(N), grouped computing resources <b>1114</b>, and/or distributed file system <b>1138</b> of framework layer <b>1120</b>. One or more types of software may include, but are not limited to, Internet web page search software, e-mail virus scan software, database software, and streaming video content software.</p><p id="p-0233" num="0210">In at least one embodiment, application(s) <b>1142</b> included in application layer <b>1140</b> may include one or more types of applications used by at least portions of node C.R.s <b>1116</b>(1)-<b>1116</b>(N), grouped computing resources <b>1114</b>, and/or distributed file system <b>1138</b> of framework layer <b>1120</b>. In at least one or more types of applications may include, without limitation, CUDA applications.</p><p id="p-0234" num="0211">In at least one embodiment, any of configuration manager <b>1134</b>, resource manager <b>1136</b>, and resource orchestrator <b>1112</b> may implement any number and type of self-modifying actions based on any amount and type of data acquired in any technically feasible fashion. In at least one embodiment, self-modifying actions may relieve a data center operator of data center <b>1100</b> from making possibly bad configuration decisions and possibly avoiding underutilized and/or poor performing portions of a data center.</p><p id="p-0235" num="0212">In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>11</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>11</b></figref> are utilized to perform API to generate one or more graph code nodes to deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>11</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate and deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>11</b></figref> are utilized to implement one or more systems and/or processes such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>10</b></figref>.</p><heading id="h-0007" level="1">Computer-Based Systems</heading><p id="p-0236" num="0213">The following figures set forth, without limitation, exemplary computer-based systems that can be used to implement at least one embodiment.</p><p id="p-0237" num="0214"><figref idref="DRAWINGS">FIG. <b>12</b></figref> illustrates a processing system <b>1200</b>, in accordance with at least one embodiment. In at least one embodiment, processing system <b>1200</b> includes one or more processors <b>1202</b> and one or more graphics processors <b>1208</b>, and may be a single processor desktop system, a multiprocessor workstation system, or a server system having a large number of processors <b>1202</b> or processor cores <b>1207</b>. In at least one embodiment, processing system <b>1200</b> is a processing platform incorporated within a system-on-a-chip (&#x201c;SoC&#x201d;) integrated circuit for use in mobile, handheld, or embedded devices.</p><p id="p-0238" num="0215">In at least one embodiment, processing system <b>1200</b> can include, or be incorporated within a server-based gaming platform, a game console, a media console, a mobile gaming console, a handheld game console, or an online game console. In at least one embodiment, processing system <b>1200</b> is a mobile phone, smart phone, tablet computing device or mobile Internet device. In at least one embodiment, processing system <b>1200</b> can also include, couple with, or be integrated within a wearable device, such as a smart watch wearable device, smart eyewear device, augmented reality device, or virtual reality device. In at least one embodiment, processing system <b>1200</b> is a television or set top box device having one or more processors <b>1202</b> and a graphical interface generated by one or more graphics processors <b>1208</b>.</p><p id="p-0239" num="0216">In at least one embodiment, one or more processors <b>1202</b> each include one or more processor cores <b>1207</b> to process instructions which, when executed, perform operations for system and user software. In at least one embodiment, each of one or more processor cores <b>1207</b> is configured to process a specific instruction set <b>1209</b>. In at least one embodiment, instruction set <b>1209</b> may facilitate Complex Instruction Set Computing (&#x201c;CISC&#x201d;), Reduced Instruction Set Computing (&#x201c;RISC&#x201d;), or computing via a Very Long Instruction Word (&#x201c;VLIW&#x201d;). In at least one embodiment, processor cores <b>1207</b> may each process a different instruction set <b>1209</b>, which may include instructions to facilitate emulation of other instruction sets. In at least one embodiment, processor core <b>1207</b> may also include other processing devices, such as a digital signal processor (&#x201c;DSP&#x201d;).</p><p id="p-0240" num="0217">In at least one embodiment, processor <b>1202</b> includes cache memory (&#x2018;cache&#x201d;) <b>1204</b>. In at least one embodiment, processor <b>1202</b> can have a single internal cache or multiple levels of internal cache. In at least one embodiment, cache memory is shared among various components of processor <b>1202</b>. In at least one embodiment, processor <b>1202</b> also uses an external cache (e.g., a Level 3 (&#x201c;L3&#x201d;) cache or Last Level Cache (&#x201c;LLC&#x201d;)) (not shown), which may be shared among processor cores <b>1207</b> using known cache coherency techniques. In at least one embodiment, register file <b>1206</b> is additionally included in processor <b>1202</b> which may include different types of registers for storing different types of data (e.g., integer registers, floating point registers, status registers, and an instruction pointer register). In at least one embodiment, register file <b>1206</b> may include general-purpose registers or other registers.</p><p id="p-0241" num="0218">In at least one embodiment, one or more processor(s) <b>1202</b> are coupled with one or more interface bus(es) <b>1210</b> to transmit communication signals such as address, data, or control signals between processor <b>1202</b> and other components in processing system <b>1200</b>. In at least one embodiment interface bus <b>1210</b>, in one embodiment, can be a processor bus, such as a version of a Direct Media Interface (&#x201c;DMI&#x201d;) bus. In at least one embodiment, interface bus <b>1210</b> is not limited to a DMI bus, and may include one or more Peripheral Component Interconnect buses (e.g., &#x201c;PCI,&#x201d; PCI Express (&#x201c;PCIe&#x201d;)), memory buses, or other types of interface buses. In at least one embodiment processor(s) <b>1202</b> include an integrated memory controller <b>1216</b> and a platform controller hub <b>1230</b>. In at least one embodiment, memory controller <b>1216</b> facilitates communication between a memory device and other components of processing system <b>1200</b>, while platform controller hub (&#x201c;PCH&#x201d;) <b>1230</b> provides connections to Input/Output (&#x201c;I/O&#x201d;) devices via a local I/O bus.</p><p id="p-0242" num="0219">In at least one embodiment, memory device <b>1220</b> can be a dynamic random access memory (&#x201c;DRAM&#x201d;) device, a static random access memory (&#x201c;SRAM&#x201d;) device, flash memory device, phase-change memory device, or some other memory device having suitable performance to serve as processor memory. In at least one embodiment memory device <b>1220</b> can operate as system memory for processing system <b>1200</b>, to store data <b>1222</b> and instructions <b>1221</b> for use when one or more processors <b>1202</b> executes an application or process. In at least one embodiment, memory controller <b>1216</b> also couples with an optional external graphics processor <b>1212</b>, which may communicate with one or more graphics processors <b>1208</b> in processors <b>1202</b> to perform graphics and media operations. In at least one embodiment, a display device <b>1211</b> can connect to processor(s) <b>1202</b>. In at least one embodiment display device <b>1211</b> can include one or more of an internal display device, as in a mobile electronic device or a laptop device or an external display device attached via a display interface (e.g., DisplayPort, etc.). In at least one embodiment, display device <b>1211</b> can include a head mounted display (&#x201c;HMD&#x201d;) such as a stereoscopic display device for use in virtual reality (&#x201c;VR&#x201d;) applications or augmented reality (&#x201c;AR&#x201d;) applications.</p><p id="p-0243" num="0220">In at least one embodiment, platform controller hub <b>1230</b> enables peripherals to connect to memory device <b>1220</b> and processor <b>1202</b> via a high-speed I/O bus. In at least one embodiment, I/O peripherals include, but are not limited to, an audio controller <b>1246</b>, a network controller <b>1234</b>, a firmware interface <b>1228</b>, a wireless transceiver <b>1226</b>, touch sensors <b>1225</b>, a data storage device <b>1224</b> (e.g., hard disk drive, flash memory, etc.). In at least one embodiment, data storage device <b>1224</b> can connect via a storage interface (e.g., SATA) or via a peripheral bus, such as PCI, or PCIe. In at least one embodiment, touch sensors <b>1225</b> can include touch screen sensors, pressure sensors, or fingerprint sensors. In at least one embodiment, wireless transceiver <b>1226</b> can be a Wi-Fi transceiver, a Bluetooth transceiver, or a mobile network transceiver such as a 3G, 4G, or Long Term Evolution (&#x201c;LTE&#x201d;) transceiver. In at least one embodiment, firmware interface <b>1228</b> enables communication with system firmware, and can be, for example, a unified extensible firmware interface (&#x201c;UEFI&#x201d;). In at least one embodiment, network controller <b>1234</b> can enable a network connection to a wired network. In at least one embodiment, a high-performance network controller (not shown) couples with interface bus <b>1210</b>. In at least one embodiment, audio controller <b>1246</b> is a multi-channel high definition audio controller. In at least one embodiment, processing system <b>1200</b> includes an optional legacy I/O controller <b>1240</b> for coupling legacy (e.g., Personal System 2 (&#x201c;PS/2&#x201d;)) devices to processing system <b>1200</b>. In at least one embodiment, platform controller hub <b>1230</b> can also connect to one or more Universal Serial Bus (&#x201c;USB&#x201d;) controllers <b>1242</b> connect input devices, such as keyboard and mouse <b>1243</b> combinations, a camera <b>1244</b>, or other USB input devices.</p><p id="p-0244" num="0221">In at least one embodiment, an instance of memory controller <b>1216</b> and platform controller hub <b>1230</b> may be integrated into a discreet external graphics processor, such as external graphics processor <b>1212</b>. In at least one embodiment, platform controller hub <b>1230</b> and/or memory controller <b>1216</b> may be external to one or more processor(s) <b>1202</b>. For example, in at least one embodiment, processing system <b>1200</b> can include an external memory controller <b>1216</b> and platform controller hub <b>1230</b>, which may be configured as a memory controller hub and peripheral controller hub within a system chipset that is in communication with processor(s) <b>1202</b>.</p><p id="p-0245" num="0222">In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>12</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>12</b></figref> are utilized to perform API to generate one or more graph code nodes to deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>12</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate and deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>12</b></figref> are utilized to implement one or more systems and/or processes such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>10</b></figref>.</p><p id="p-0246" num="0223"><figref idref="DRAWINGS">FIG. <b>13</b></figref> illustrates a computer system <b>1300</b>, in accordance with at least one embodiment. In at least one embodiment, computer system <b>1300</b> may be a system with interconnected devices and components, an SOC, or some combination. In at least on embodiment, computer system <b>1300</b> is formed with a processor <b>1302</b> that may include execution units to execute an instruction. In at least one embodiment, computer system <b>1300</b> may include, without limitation, a component, such as processor <b>1302</b> to employ execution units including logic to perform algorithms for processing data. In at least one embodiment, computer system <b>1300</b> may include processors, such as PENTIUM&#xae; Processor family, Xeon&#x2122;, Itanium&#xae;, XScale&#x2122; and/or StrongARM&#x2122;, Intel&#xae; Core&#x2122;, or Intel&#xae; Nervana&#x2122; microprocessors available from Intel Corporation of Santa Clara, Calif., although other systems (including PCs having other microprocessors, engineering workstations, set-top boxes and like) may also be used. In at least one embodiment, computer system <b>1300</b> may execute a version of WINDOWS' operating system available from Microsoft Corporation of Redmond, Wash., although other operating systems (UNIX and Linux for example), embedded software, and/or graphical user interfaces, may also be used.</p><p id="p-0247" num="0224">In at least one embodiment, computer system <b>1300</b> may be used in other devices such as handheld devices and embedded applications. Some examples of handheld devices include cellular phones, Internet Protocol devices, digital cameras, personal digital assistants (&#x201c;PDAs&#x201d;), and handheld PCs. In at least one embodiment, embedded applications may include a microcontroller, a digital signal processor (DSP), an SoC, network computers (&#x201c;NetPCs&#x201d;), set-top boxes, network hubs, wide area network (&#x201c;WAN&#x201d;) switches, or any other system that may perform one or more instructions.</p><p id="p-0248" num="0225">In at least one embodiment, computer system <b>1300</b> may include, without limitation, processor <b>1302</b> that may include, without limitation, one or more execution units <b>1308</b> that may be configured to execute a Compute Unified Device Architecture (&#x201c;CUDA&#x201d;) (CUDA&#xae; is developed by NVIDIA Corporation of Santa Clara, Calif.) program. In at least one embodiment, a CUDA program is at least a portion of a software application written in a CUDA programming language. In at least one embodiment, computer system <b>1300</b> is a single processor desktop or server system. In at least one embodiment, computer system <b>1300</b> may be a multiprocessor system. In at least one embodiment, processor <b>1302</b> may include, without limitation, a CISC microprocessor, a RISC microprocessor, a VLIW microprocessor, a processor implementing a combination of instruction sets, or any other processor device, such as a digital signal processor, for example. In at least one embodiment, processor <b>1302</b> may be coupled to a processor bus <b>1310</b> that may transmit data signals between processor <b>1302</b> and other components in computer system <b>1300</b>.</p><p id="p-0249" num="0226">In at least one embodiment, processor <b>1302</b> may include, without limitation, a Level 1 (&#x201c;L1&#x201d;) internal cache memory (&#x201c;cache&#x201d;) <b>1304</b>. In at least one embodiment, processor <b>1302</b> may have a single internal cache or multiple levels of internal cache. In at least one embodiment, cache memory may reside external to processor <b>1302</b>. In at least one embodiment, processor<b>1302</b> may also include a combination of both internal and external caches. In at least one embodiment, a register file <b>1306</b> may store different types of data in various registers including, without limitation, integer registers, floating point registers, status registers, and instruction pointer register.</p><p id="p-0250" num="0227">In at least one embodiment, execution unit <b>1308</b>, including, without limitation, logic to perform integer and floating point operations, also resides in processor <b>1302</b>. Processor <b>1302</b> may also include a microcode (&#x201c;ucode&#x201d;) read only memory (&#x201c;ROM&#x201d;) that stores microcode for certain macro instructions. In at least one embodiment, execution unit <b>1308</b> may include logic to handle a packed instruction set <b>1309</b>. In at least one embodiment, by including packed instruction set <b>1309</b> in an instruction set of a general-purpose processor <b>1302</b>, along with associated circuitry to execute instructions, operations used by many multimedia applications may be performed using packed data in a general-purpose processor <b>1302</b>. In at least one embodiment, many multimedia applications may be accelerated and executed more efficiently by using full width of a processor's data bus for performing operations on packed data, which may eliminate a need to transfer smaller units of data across a processor's data bus to perform one or more operations one data element at a time.</p><p id="p-0251" num="0228">In at least one embodiment, execution unit <b>1308</b> may also be used in microcontrollers, embedded processors, graphics devices, DSPs, and other types of logic circuits. In at least one embodiment, computer system <b>1300</b> may include, without limitation, a memory <b>1320</b>. In at least one embodiment, memory <b>1320</b> may be implemented as a DRAM device, an SRAM device, flash memory device, or other memory device. Memory <b>1320</b> may store instruction(s) <b>1319</b> and/or data <b>1321</b> represented by data signals that may be executed by processor <b>1302</b>.</p><p id="p-0252" num="0229">In at least one embodiment, a system logic chip may be coupled to processor bus <b>1310</b> and memory <b>1320</b>. In at least one embodiment, the system logic chip may include, without limitation, a memory controller hub (&#x201c;MCH&#x201d;) <b>1316</b>, and processor <b>1302</b> may communicate with MCH <b>1316</b> via processor bus <b>1310</b>. In at least one embodiment, MCH <b>1316</b> may provide a high bandwidth memory path <b>1318</b> to memory <b>1320</b> for instruction and data storage and for storage of graphics commands, data and textures. In at least one embodiment, MCH <b>1316</b> may direct data signals between processor <b>1302</b>, memory <b>1320</b>, and other components in computer system <b>1300</b> and to bridge data signals between processor bus <b>1310</b>, memory <b>1320</b>, and a system I/O <b>1322</b>. In at least one embodiment, system logic chip may provide a graphics port for coupling to a graphics controller. In at least one embodiment, MCH <b>1316</b> may be coupled to memory <b>1320</b> through high bandwidth memory path <b>1318</b> and graphics/video card <b>1312</b> may be coupled to MCH <b>1316</b> through an Accelerated Graphics Port (&#x201c;AGP&#x201d;) interconnect <b>1314</b>.</p><p id="p-0253" num="0230">In at least one embodiment, computer system <b>1300</b> may use system I/O <b>1322</b> that is a proprietary hub interface bus to couple MCH <b>1316</b> to I/O controller hub (&#x201c;ICH&#x201d;) <b>1330</b>. In at least one embodiment, ICH <b>1330</b> may provide direct connections to some I/O devices via a local I/O bus. In at least one embodiment, local I/O bus may include, without limitation, a high-speed I/O bus for connecting peripherals to memory <b>1320</b>, a chipset, and processor <b>1302</b>. Examples may include, without limitation, an audio controller <b>1329</b>, a firmware hub (&#x201c;flash BIOS&#x201d;) <b>1328</b>, a wireless transceiver <b>1326</b>, a data storage <b>1324</b>, a legacy I/O controller <b>1323</b> containing a user input interface <b>1325</b> and a keyboard interface, a serial expansion port <b>1327</b>, such as a USB, and a network controller <b>1334</b>. Data storage <b>1324</b> may comprise a hard disk drive, a floppy disk drive, a CD-ROM device, a flash memory device, or other mass storage device.</p><p id="p-0254" num="0231">In at least one embodiment, <figref idref="DRAWINGS">FIG. <b>13</b></figref> illustrates a system, which includes interconnected hardware devices or &#x201c;chips.&#x201d; In at least one embodiment, <figref idref="DRAWINGS">FIG. <b>13</b></figref> may illustrate an exemplary SoC. In at least one embodiment, devices illustrated in <figref idref="DRAWINGS">FIG. <b>13</b></figref> may be interconnected with proprietary interconnects, standardized interconnects (e.g., PCIe), or some combination thereof. In at least one embodiment, one or more components of system <b>1300</b> are interconnected using compute express link (&#x201c;CXL&#x201d;) interconnects.</p><p id="p-0255" num="0232">In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>13</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>13</b></figref> are utilized to perform API to generate one or more graph code nodes to deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>13</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate and deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>13</b></figref> are utilized to implement one or more systems and/or processes such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>10</b></figref>.</p><p id="p-0256" num="0233"><figref idref="DRAWINGS">FIG. <b>14</b></figref> illustrates a system <b>1400</b>, in accordance with at least one embodiment. In at least one embodiment, system <b>1400</b> is an electronic device that utilizes a processor <b>1410</b>. In at least one embodiment, system <b>1400</b> may be, for example and without limitation, a notebook, a tower server, a rack server, a blade server, an edge device communicatively coupled to one or more on-premise or cloud service providers, a laptop, a desktop, a tablet, a mobile device, a phone, an embedded computer, or any other suitable electronic device.</p><p id="p-0257" num="0234">In at least one embodiment, system <b>1400</b> may include, without limitation, processor <b>1410</b> communicatively coupled to any suitable number or kind of components, peripherals, modules, or devices. In at least one embodiment, processor <b>1410</b> is coupled using a bus or interface, such as an I<sup>2</sup>C bus, a System Management Bus (&#x201c;SMBus&#x201d;), a Low Pin Count (&#x201c;LPC&#x201d;) bus, a Serial Peripheral Interface (&#x201c;SPI&#x201d;), a High Definition Audio (&#x201c;HDA&#x201d;) bus, a Serial Advance Technology Attachment (&#x201c;SATA&#x201d;) bus, a USB (versions 1, 2, 3), or a Universal Asynchronous Receiver/Transmitter (&#x201c;UART&#x201d;) bus. In at least one embodiment, <figref idref="DRAWINGS">FIG. <b>14</b></figref> illustrates a system which includes interconnected hardware devices or &#x201c;chips.&#x201d; In at least one embodiment, <figref idref="DRAWINGS">FIG. <b>14</b></figref> may illustrate an exemplary SoC. In at least one embodiment, devices illustrated in <figref idref="DRAWINGS">FIG. <b>14</b></figref> may be interconnected with proprietary interconnects, standardized interconnects (e.g., PCIe) or some combination thereof. In at least one embodiment, one or more components of <figref idref="DRAWINGS">FIG. <b>14</b></figref> are interconnected using CXL interconnects.</p><p id="p-0258" num="0235">In at least one embodiment, <figref idref="DRAWINGS">FIG. <b>14</b></figref> may include a display <b>1424</b>, a touch screen <b>1425</b>, a touch pad <b>1430</b>, a Near Field Communications unit (&#x201c;NFC&#x201d;) <b>1445</b>, a sensor hub <b>1440</b>, a thermal sensor <b>1446</b>, an Express Chipset (&#x201c;EC&#x201d;) <b>1435</b>, a Trusted Platform Module (&#x201c;TPM&#x201d;) <b>1438</b>, BIOS/firmware/flash memory (&#x201c;BIOS, FW Flash&#x201d;) <b>1422</b>, a DSP <b>1460</b>, a Solid State Disk (&#x201c;SSD&#x201d;) or Hard Disk Drive (&#x201c;HDD&#x201d;) <b>1420</b>, a wireless local area network unit (&#x201c;WLAN&#x201d;) <b>1450</b>, a Bluetooth unit <b>1452</b>, a Wireless Wide Area Network unit (&#x201c;WWAN&#x201d;) <b>1456</b>, a Global Positioning System (&#x201c;GPS&#x201d;) <b>1455</b>, a camera (&#x201c;USB 3.0 camera&#x201d;) <b>1454</b> such as a USB 3.0 camera, or a Low Power Double Data Rate (&#x201c;LPDDR&#x201d;) memory unit (&#x201c;LPDDR3&#x201d;) <b>1415</b> implemented in, for example, LPDDR3 standard. These components may each be implemented in any suitable manner.</p><p id="p-0259" num="0236">In at least one embodiment, other components may be communicatively coupled to processor <b>1410</b> through components discussed above. In at least one embodiment, an accelerometer <b>1441</b>, an Ambient Light Sensor (&#x201c;ALS&#x201d;) <b>1442</b>, a compass <b>1443</b>, and a gyroscope <b>1444</b> may be communicatively coupled to sensor hub <b>1440</b>. In at least one embodiment, a thermal sensor <b>1439</b>, a fan <b>1437</b>, a keyboard <b>1436</b>, and a touch pad <b>1430</b> may be communicatively coupled to EC <b>1435</b>. In at least one embodiment, a speaker <b>1463</b>, a headphones <b>1464</b>, and a microphone (&#x201c;mic&#x201d;) <b>1465</b> may be communicatively coupled to an audio unit (&#x201c;audio codec and class d amp&#x201d;) <b>1462</b>, which may in turn be communicatively coupled to DSP <b>1460</b>. In at least one embodiment, audio unit <b>1462</b> may include, for example and without limitation, an audio coder/decoder (&#x201c;codec&#x201d;) and a class D amplifier. In at least one embodiment, a SIM card (&#x201c;SIM&#x201d;) <b>1457</b> may be communicatively coupled to WWAN unit <b>1456</b>. In at least one embodiment, components such as WLAN unit <b>1450</b> and Bluetooth unit <b>1452</b>, as well as WWAN unit <b>1456</b> may be implemented in a Next Generation Form Factor (&#x201c;NGFF&#x201d;).</p><p id="p-0260" num="0237">In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>14</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>14</b></figref> are utilized to perform API to generate one or more graph code nodes to deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>14</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate and deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>14</b></figref> are utilized to implement one or more systems and/or processes such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>10</b></figref>.</p><p id="p-0261" num="0238"><figref idref="DRAWINGS">FIG. <b>15</b></figref> illustrates an exemplary integrated circuit <b>1500</b>, in accordance with at least one embodiment. In at least one embodiment, exemplary integrated circuit <b>1500</b> is an SoC that may be fabricated using one or more IP cores. In at least one embodiment, integrated circuit <b>1500</b> includes one or more application processor(s) <b>1505</b> (e.g., CPUs, DPUs), at least one graphics processor <b>1510</b>, and may additionally include an image processor <b>1515</b> and/or a video processor <b>1520</b>, any of which may be a modular IP core. In at least one embodiment, integrated circuit <b>1500</b> includes peripheral or bus logic including a USB controller <b>1525</b>, a UART controller <b>1530</b>, an SPI/SDIO controller <b>1535</b>, and an I<sup>2</sup>S/I<sup>2</sup>C controller <b>1540</b>. In at least one embodiment, integrated circuit <b>1500</b> can include a display device <b>1545</b> coupled to one or more of a high-definition multimedia interface (&#x201c;HDMI&#x201d;) controller <b>1550</b> and a mobile industry processor interface (&#x201c;MIPI&#x201d;) display interface <b>1555</b>. In at least one embodiment, storage may be provided by a flash memory subsystem <b>1560</b> including flash memory and a flash memory controller. In at least one embodiment, a memory interface may be provided via a memory controller <b>1565</b> for access to SDRAM or SRAM memory devices. In at least one embodiment, some integrated circuits additionally include an embedded security engine <b>1570</b>.</p><p id="p-0262" num="0239">In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>15</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>15</b></figref> are utilized to perform API to generate one or more graph code nodes to deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>15</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate and deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>15</b></figref> are utilized to implement one or more systems and/or processes such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>10</b></figref>.</p><p id="p-0263" num="0240"><figref idref="DRAWINGS">FIG. <b>16</b></figref> illustrates a computing system <b>1600</b>, according to at least one embodiment; In at least one embodiment, computing system <b>1600</b> includes a processing subsystem <b>1601</b> having one or more processor(s) <b>1602</b> and a system memory <b>1604</b> communicating via an interconnection path that may include a memory hub <b>1605</b>. In at least one embodiment, memory hub <b>1605</b> may be a separate component within a chipset component or may be integrated within one or more processor(s) <b>1602</b>. In at least one embodiment, memory hub <b>1605</b> couples with an I/O subsystem <b>1611</b> via a communication link <b>1606</b>. In at least one embodiment, I/O subsystem <b>1611</b> includes an I/O hub <b>1607</b> that can enable computing system <b>1600</b> to receive input from one or more input device(s) <b>1608</b>. In at least one embodiment, I/O hub <b>1607</b> can enable a display controller, which may be included in one or more processor(s) <b>1602</b>, to provide outputs to one or more display device(s) <b>1610</b>A. In at least one embodiment, one or more display device(s) <b>1610</b>A coupled with I/O hub <b>1607</b> can include a local, internal, or embedded display device.</p><p id="p-0264" num="0241">In at least one embodiment, processing subsystem <b>1601</b> includes one or more parallel processor(s) <b>1612</b> coupled to memory hub <b>1605</b> via a bus or other communication link <b>1613</b>. In at least one embodiment, communication link <b>1613</b> may be one of any number of standards based communication link technologies or protocols, such as, but not limited to PCIe, or may be a vendor specific communications interface or communications fabric. In at least one embodiment, one or more parallel processor(s) <b>1612</b> form a computationally focused parallel or vector processing system that can include a large number of processing cores and/or processing clusters, such as a many integrated core processor. In at least one embodiment, one or more parallel processor(s) <b>1612</b> form a graphics processing subsystem that can output pixels to one of one or more display device(s) <b>1610</b>A coupled via I/O Hub <b>1607</b>. In at least one embodiment, one or more parallel processor(s) <b>1612</b> can also include a display controller and display interface (not shown) to enable a direct connection to one or more display device(s) <b>1610</b>B.</p><p id="p-0265" num="0242">In at least one embodiment, a system storage unit <b>1614</b> can connect to I/O hub <b>1607</b> to provide a storage mechanism for computing system <b>1600</b>. In at least one embodiment, an I/O switch <b>1616</b> can be used to provide an interface mechanism to enable connections between I/O hub <b>1607</b> and other components, such as a network adapter <b>1618</b> and/or wireless network adapter <b>1619</b> that may be integrated into a platform, and various other devices that can be added via one or more add-in device(s) <b>1620</b>. In at least one embodiment, network adapter <b>1618</b> can be an Ethernet adapter or another wired network adapter. In at least one embodiment, wireless network adapter <b>1619</b> can include one or more of a Wi-Fi, Bluetooth, NFC, or other network device that includes one or more wireless radios.</p><p id="p-0266" num="0243">In at least one embodiment, computing system <b>1600</b> can include other components not explicitly shown, including USB or other port connections, optical storage drives, video capture devices, and the like, that may also be connected to I/O hub <b>1607</b>. In at least one embodiment, communication paths interconnecting various components in <figref idref="DRAWINGS">FIG. <b>16</b></figref> may be implemented using any suitable protocols, such as PCI based protocols (e.g., PCIe), or other bus or point-to-point communication interfaces and/or protocol(s), such as NVLink high-speed interconnect, or interconnect protocols.</p><p id="p-0267" num="0244">In at least one embodiment, one or more parallel processor(s) <b>1612</b> incorporate circuitry optimized for graphics and video processing, including, for example, video output circuitry, and constitutes a graphics processing unit (&#x201c;GPU&#x201d;). In at least one embodiment, one or more parallel processor(s) <b>1612</b> incorporate circuitry optimized for general purpose processing. In at least embodiment, components of computing system <b>1600</b> may be integrated with one or more other system elements on a single integrated circuit. For example, in at least one embodiment, one or more parallel processor(s) <b>1612</b>, memory hub <b>1605</b>, processor(s) <b>1602</b>, and I/O hub <b>1607</b> can be integrated into an SoC integrated circuit. In at least one embodiment, components of computing system <b>1600</b> can be integrated into a single package to form a system in package (&#x201c;SIP&#x201d;) configuration. In at least one embodiment, at least a portion of the components of computing system <b>1600</b> can be integrated into a multi-chip module (&#x201c;MCM&#x201d;), which can be interconnected with other multi-chip modules into a modular computing system. In at least one embodiment, I/O subsystem <b>1611</b> and display devices <b>1610</b>B are omitted from computing system <b>1600</b>.</p><p id="p-0268" num="0245">In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>16</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>16</b></figref> are utilized to perform API to generate one or more graph code nodes to deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>16</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate and deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>16</b></figref> are utilized to implement one or more systems and/or processes such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>10</b></figref>.</p><heading id="h-0008" level="1">Processing Systems</heading><p id="p-0269" num="0246">The following figures set forth, without limitation, exemplary processing systems that can be used to implement at least one embodiment.</p><p id="p-0270" num="0247"><figref idref="DRAWINGS">FIG. <b>17</b></figref> illustrates an accelerated processing unit (&#x201c;APU&#x201d;) <b>1700</b>, in accordance with at least one embodiment. In at least one embodiment, APU <b>1700</b> is developed by AMD Corporation of Santa Clara, Calif. In at least one embodiment, APU <b>1700</b> can be configured to execute an application program, such as a CUDA program. In at least one embodiment, APU <b>1700</b> includes, without limitation, a core complex <b>1710</b>, a graphics complex <b>1740</b>, fabric <b>1760</b>, I/O interfaces <b>1770</b>, memory controllers <b>1780</b>, a display controller <b>1792</b>, and a multimedia engine <b>1794</b>. In at least one embodiment, APU <b>1700</b> may include, without limitation, any number of core complexes <b>1710</b>, any number of graphics complexes <b>1750</b>, any number of display controllers <b>1792</b>, and any number of multimedia engines <b>1794</b> in any combination. For explanatory purposes, multiple instances of like objects are denoted herein with reference numbers identifying the object and parenthetical numbers identifying the instance where needed.</p><p id="p-0271" num="0248">In at least one embodiment, core complex <b>1710</b> is a CPU, graphics complex <b>1740</b> is a GPU, and APU <b>1700</b> is a processing unit that integrates, without limitation, <b>1710</b> and <b>1740</b> onto a single chip. In at least one embodiment, some tasks may be assigned to core complex <b>1710</b> and other tasks may be assigned to graphics complex <b>1740</b>. In at least one embodiment, core complex <b>1710</b> is configured to execute main control software associated with APU <b>1700</b>, such as an operating system. In at least one embodiment, core complex <b>1710</b> is the master processor of APU <b>1700</b>, controlling and coordinating operations of other processors. In at least one embodiment, core complex <b>1710</b> issues commands that control the operation of graphics complex <b>1740</b>. In at least one embodiment, core complex <b>1710</b> can be configured to execute host executable code derived from CUDA source code, and graphics complex <b>1740</b> can be configured to execute device executable code derived from CUDA source code.</p><p id="p-0272" num="0249">In at least one embodiment, core complex <b>1710</b> includes, without limitation, cores <b>1720</b>(1)-<b>1720</b>(4) and an L3 cache <b>1730</b>. In at least one embodiment, core complex <b>1710</b> may include, without limitation, any number of cores <b>1720</b> and any number and type of caches in any combination. In at least one embodiment, cores <b>1720</b> are configured to execute instructions of a particular instruction set architecture (&#x201c;ISA&#x201d;). In at least one embodiment, each core <b>1720</b> is a CPU core.</p><p id="p-0273" num="0250">In at least one embodiment, each core <b>1720</b> includes, without limitation, a fetch/decode unit <b>1722</b>, an integer execution engine <b>1724</b>, a floating point execution engine <b>1726</b>, and an L2 cache <b>1728</b>. In at least one embodiment, fetch/decode unit <b>1722</b> fetches instructions, decodes such instructions, generates micro-operations, and dispatches separate micro-instructions to integer execution engine <b>1724</b> and floating point execution engine <b>1726</b>. In at least one embodiment, fetch/decode unit <b>1722</b> can concurrently dispatch one micro-instruction to integer execution engine <b>1724</b> and another micro-instruction to floating point execution engine <b>1726</b>. In at least one embodiment, integer execution engine <b>1724</b> executes, without limitation, integer and memory operations. In at least one embodiment, floating point engine <b>1726</b> executes, without limitation, floating point and vector operations. In at least one embodiment, fetch-decode unit <b>1722</b> dispatches micro-instructions to a single execution engine that replaces both integer execution engine <b>1724</b> and floating point execution engine <b>1726</b>.</p><p id="p-0274" num="0251">In at least one embodiment, each core <b>1720</b>(<i>i</i>), where i is an integer representing a particular instance of core <b>1720</b>, may access L2 cache <b>1728</b>(<i>i</i>) included in core <b>1720</b>(<i>i</i>). In at least one embodiment, each core <b>1720</b> included in core complex <b>1710</b>(<i>j</i>), where j is an integer representing a particular instance of core complex <b>1710</b>, is connected to other cores <b>1720</b> included in core complex <b>1710</b>(<i>j</i>) via L3 cache <b>1730</b>(<i>j</i>) included in core complex <b>1710</b>(<i>j</i>). In at least one embodiment, cores <b>1720</b> included in core complex <b>1710</b>(<i>j</i>), where j is an integer representing a particular instance of core complex <b>1710</b>, can access all of L3 cache <b>1730</b>(<i>j</i>) included in core complex <b>1710</b>(<i>j</i>). In at least one embodiment, L3 cache <b>1730</b> may include, without limitation, any number of slices.</p><p id="p-0275" num="0252">In at least one embodiment, graphics complex <b>1740</b> can be configured to perform compute operations in a highly-parallel fashion. In at least one embodiment, graphics complex <b>1740</b> is configured to execute graphics pipeline operations such as draw commands, pixel operations, geometric computations, and other operations associated with rendering an image to a display. In at least one embodiment, graphics complex <b>1740</b> is configured to execute operations unrelated to graphics. In at least one embodiment, graphics complex <b>1740</b> is configured to execute both operations related to graphics and operations unrelated to graphics.</p><p id="p-0276" num="0253">In at least one embodiment, graphics complex <b>1740</b> includes, without limitation, any number of compute units <b>1750</b> and an L2 cache <b>1742</b>. In at least one embodiment, compute units <b>1750</b> share L2 cache <b>1742</b>. In at least one embodiment, L2 cache <b>1742</b> is partitioned. In at least one embodiment, graphics complex <b>1740</b> includes, without limitation, any number of compute units <b>1750</b> and any number (including zero) and type of caches. In at least one embodiment, graphics complex <b>1740</b> includes, without limitation, any amount of dedicated graphics hardware.</p><p id="p-0277" num="0254">In at least one embodiment, each compute unit <b>1750</b> includes, without limitation, any number of SIMD units <b>1752</b> and a shared memory <b>1754</b>. In at least one embodiment, each SIMD unit <b>1752</b> implements a SIMD architecture and is configured to perform operations in parallel. In at least one embodiment, each compute unit <b>1750</b> may execute any number of thread blocks, but each thread block executes on a single compute unit <b>1750</b>. In at least one embodiment, a thread block includes, without limitation, any number of threads of execution. In at least one embodiment, a workgroup is a thread block. In at least one embodiment, each SIMD unit <b>1752</b> executes a different warp. In at least one embodiment, a warp is a group of threads (e.g., 16 threads), where each thread in the warp belongs to a single thread block and is configured to process a different set of data based on a single set of instructions. In at least one embodiment, predication can be used to disable one or more threads in a warp. In at least one embodiment, a lane is a thread. In at least one embodiment, a work item is a thread. In at least one embodiment, a wavefront is a warp. In at least one embodiment, different wavefronts in a thread block may synchronize together and communicate via shared memory <b>1754</b>.</p><p id="p-0278" num="0255">In at least one embodiment, fabric <b>1760</b> is a system interconnect that facilitates data and control transmissions across core complex <b>1710</b>, graphics complex <b>1740</b>, I/O interfaces <b>1770</b>, memory controllers <b>1780</b>, display controller <b>1792</b>, and multimedia engine <b>1794</b>. In at least one embodiment, APU <b>1700</b> may include, without limitation, any amount and type of system interconnect in addition to or instead of fabric <b>1760</b> that facilitates data and control transmissions across any number and type of directly or indirectly linked components that may be internal or external to APU <b>1700</b>. In at least one embodiment, I/O interfaces <b>1770</b> are representative of any number and type of I/O interfaces (e.g., PCI , PCI-Extended (&#x201c;PCI-X&#x201d;), PCIe, gigabit Ethernet (&#x201c;GBE&#x201d;), USB, etc.). In at least one embodiment, various types of peripheral devices are coupled to I/O interfaces <b>1770</b> In at least one embodiment, peripheral devices that are coupled to I/O interfaces <b>1770</b> may include, without limitation, keyboards, mice, printers, scanners, joysticks or other types of game controllers, media recording devices, external storage devices, network interface cards, and so forth.</p><p id="p-0279" num="0256">In at least one embodiment, display controller <b>1792</b> displays images on one or more display device(s), such as a liquid crystal display (&#x201c;LCD&#x201d;) device. In at least one embodiment, multimedia engine <b>1794</b> includes, without limitation, any amount and type of circuitry that is related to multimedia, such as a video decoder, a video encoder, an image signal processor, etc. In at least one embodiment, memory controllers <b>1780</b> facilitate data transfers between APU <b>1700</b> and a unified system memory <b>1790</b>. In at least one embodiment, core complex <b>1710</b> and graphics complex <b>1740</b> share unified system memory <b>1790</b>.</p><p id="p-0280" num="0257">In at least one embodiment, APU <b>1700</b> implements a memory subsystem that includes, without limitation, any amount and type of memory controllers <b>1780</b> and memory devices (e.g., shared memory <b>1754</b>) that may be dedicated to one component or shared among multiple components. In at least one embodiment, APU <b>1700</b> implements a cache subsystem that includes, without limitation, one or more cache memories (e.g., L2 caches <b>1828</b>, L3 cache <b>1730</b>, and L2 cache <b>1742</b>) that may each be private to or shared between any number of components (e.g., cores <b>1720</b>, core complex <b>1710</b>, SIMD units <b>1752</b>, compute units <b>1750</b>, and graphics complex <b>1740</b>).</p><p id="p-0281" num="0258">In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>17</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>17</b></figref> are utilized to perform API to generate one or more graph code nodes to deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>17</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate and deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>17</b></figref> are utilized to implement one or more systems and/or processes such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>10</b></figref>.</p><p id="p-0282" num="0259"><figref idref="DRAWINGS">FIG. <b>18</b></figref> illustrates a CPU <b>1800</b>, in accordance with at least one embodiment. In at least one embodiment, CPU <b>1800</b> is developed by AMD Corporation of Santa Clara, Calif. In at least one embodiment, CPU <b>1800</b> can be configured to execute an application program. In at least one embodiment, CPU <b>1800</b> is configured to execute main control software, such as an operating system. In at least one embodiment, CPU <b>1800</b> issues commands that control the operation of an external GPU (not shown). In at least one embodiment, CPU <b>1800</b> can be configured to execute host executable code derived from CUDA source code, and an external GPU can be configured to execute device executable code derived from such CUDA source code. In at least one embodiment, CPU <b>1800</b> includes, without limitation, any number of core complexes <b>1810</b>, fabric <b>1860</b>, I/O interfaces <b>1870</b>, and memory controllers <b>1880</b>.</p><p id="p-0283" num="0260">In at least one embodiment, core complex <b>1810</b> includes, without limitation, cores <b>1820</b>(1)-<b>1820</b>(4) and an L3 cache <b>1830</b>. In at least one embodiment, core complex <b>1810</b> may include, without limitation, any number of cores <b>1820</b> and any number and type of caches in any combination. In at least one embodiment, cores <b>1820</b> are configured to execute instructions of a particular ISA. In at least one embodiment, each core <b>1820</b> is a CPU core.</p><p id="p-0284" num="0261">In at least one embodiment, each core <b>1820</b> includes, without limitation, a fetch/decode unit <b>1822</b>, an integer execution engine <b>1824</b>, a floating point execution engine <b>1826</b>, and an L2 cache <b>1828</b>. In at least one embodiment, fetch/decode unit <b>1822</b> fetches instructions, decodes such instructions, generates micro-operations, and dispatches separate micro-instructions to integer execution engine <b>1824</b> and floating point execution engine <b>1826</b>. In at least one embodiment, fetch/decode unit <b>1822</b> can concurrently dispatch one micro-instruction to integer execution engine <b>1824</b> and another micro-instruction to floating point execution engine <b>1826</b>. In at least one embodiment, integer execution engine <b>1824</b> executes, without limitation, integer and memory operations. In at least one embodiment, floating point engine <b>1826</b> executes, without limitation, floating point and vector operations. In at least one embodiment, fetch-decode unit <b>1822</b> dispatches micro-instructions to a single execution engine that replaces both integer execution engine <b>1824</b> and floating point execution engine <b>1826</b>.</p><p id="p-0285" num="0262">In at least one embodiment, each core <b>1820</b>(<i>i</i>), where i is an integer representing a particular instance of core <b>1820</b>, may access L2 cache <b>1828</b>(<i>i</i>) included in core <b>1820</b>(<i>i</i>). In at least one embodiment, each core <b>1820</b> included in core complex <b>1810</b>(<i>j</i>), where j is an integer representing a particular instance of core complex <b>1810</b>, is connected to other cores <b>1820</b> in core complex <b>1810</b>(<i>j</i>) via L3 cache <b>1830</b>(<i>j</i>) included in core complex <b>1810</b>(<i>j</i>). In at least one embodiment, cores <b>1820</b> included in core complex <b>1810</b>(<i>j</i>), where j is an integer representing a particular instance of core complex <b>1810</b>, can access all of L3 cache <b>1830</b>(<i>j</i>) included in core complex <b>1810</b>(<i>j</i>). In at least one embodiment, L3 cache <b>1830</b> may include, without limitation, any number of slices.</p><p id="p-0286" num="0263">In at least one embodiment, fabric <b>1860</b> is a system interconnect that facilitates data and control transmissions across core complexes <b>1810</b>(1)-<b>1810</b>(N) (where N is an integer greater than zero), I/O interfaces <b>1870</b>, and memory controllers <b>1880</b>. In at least one embodiment, CPU <b>1800</b> may include, without limitation, any amount and type of system interconnect in addition to or instead of fabric <b>1860</b> that facilitates data and control transmissions across any number and type of directly or indirectly linked components that may be internal or external to CPU <b>1800</b>. In at least one embodiment, I/O interfaces <b>1870</b> are representative of any number and type of I/O interfaces (e.g., PCI , PCI-X, PCIe, GBE, USB, etc.). In at least one embodiment, various types of peripheral devices are coupled to I/O interfaces <b>1870</b> In at least one embodiment, peripheral devices that are coupled to I/O interfaces <b>1870</b> may include, without limitation, displays, keyboards, mice, printers, scanners, joysticks or other types of game controllers, media recording devices, external storage devices, network interface cards, and so forth.</p><p id="p-0287" num="0264">In at least one embodiment, memory controllers <b>1880</b> facilitate data transfers between CPU <b>1800</b> and a system memory <b>1890</b>. In at least one embodiment, core complex <b>1810</b> and graphics complex <b>1840</b> share system memory <b>1890</b>. In at least one embodiment, CPU <b>1800</b> implements a memory subsystem that includes, without limitation, any amount and type of memory controllers <b>1880</b> and memory devices that may be dedicated to one component or shared among multiple components. In at least one embodiment, CPU <b>1800</b> implements a cache subsystem that includes, without limitation, one or more cache memories (e.g., L2 caches <b>1828</b> and L3 caches <b>1830</b>) that may each be private to or shared between any number of components (e.g., cores <b>1820</b> and core complexes <b>1810</b>).</p><p id="p-0288" num="0265">In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>18</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>18</b></figref> are utilized to perform API to generate one or more graph code nodes to deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>18</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate and deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>18</b></figref> are utilized to implement one or more systems and/or processes such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>10</b></figref>.</p><p id="p-0289" num="0266"><figref idref="DRAWINGS">FIG. <b>19</b></figref> illustrates an exemplary accelerator integration slice <b>1990</b>, in accordance with at least one embodiment. As used herein, a &#x201c;slice&#x201d; comprises a specified portion of processing resources of an accelerator integration circuit. In at least one embodiment, the accelerator integration circuit provides cache management, memory access, context management, and interrupt management services on behalf of multiple graphics processing engines included in a graphics acceleration module. The graphics processing engines may each comprise a separate GPU. Alternatively, the graphics processing engines may comprise different types of graphics processing engines within a GPU such as graphics execution units, media processing engines (e.g., video encoders/decoders), samplers, and blit engines. In at least one embodiment, the graphics acceleration module may be a GPU with multiple graphics processing engines. In at least one embodiment, the graphics processing engines may be individual GPUs integrated on a common package, line card, or chip.</p><p id="p-0290" num="0267">An application effective address space <b>1982</b> within system memory <b>1914</b> stores process elements <b>1983</b>. In one embodiment, process elements <b>1983</b> are stored in response to GPU invocations <b>1981</b> from applications <b>1980</b> executed on processor <b>1907</b>. A process element <b>1983</b> contains process state for corresponding application <b>1980</b>. A work descriptor (&#x201c;WD&#x201d;) <b>1984</b> contained in process element <b>1983</b> can be a single job requested by an application or may contain a pointer to a queue of jobs. In at least one embodiment, WD <b>1984</b> is a pointer to a job request queue in application effective address space <b>1982</b>.</p><p id="p-0291" num="0268">Graphics acceleration module <b>1946</b> and/or individual graphics processing engines can be shared by all or a subset of processes in a system. In at least one embodiment, an infrastructure for setting up process state and sending WD <b>1984</b> to graphics acceleration module <b>1946</b> to start a job in a virtualized environment may be included.</p><p id="p-0292" num="0269">In at least one embodiment, a dedicated-process programming model is implementation-specific. In this model, a single process owns graphics acceleration module <b>1946</b> or an individual graphics processing engine. Because graphics acceleration module <b>1946</b> is owned by a single process, a hypervisor initializes an accelerator integration circuit for an owning partition and an operating system initializes accelerator integration circuit for an owning process when graphics acceleration module <b>1946</b> is assigned.</p><p id="p-0293" num="0270">In operation, a WD fetch unit <b>1991</b> in accelerator integration slice <b>1990</b> fetches next WD <b>1984</b> which includes an indication of work to be done by one or more graphics processing engines of graphics acceleration module <b>1946</b>. Data from WD <b>1984</b> may be stored in registers <b>1945</b> and used by a memory management unit (&#x201c;MMU&#x201d;) <b>1939</b>, interrupt management circuit <b>1947</b> and/or context management circuit <b>1948</b> as illustrated. For example, one embodiment of MMU <b>1939</b> includes segment/page walk circuitry for accessing segment/page tables <b>1986</b> within OS virtual address space <b>1985</b>. Interrupt management circuit <b>1947</b> may process interrupt events (&#x201c;INT&#x201d;) <b>1992</b> received from graphics acceleration module <b>1946</b>. When performing graphics operations, an effective address <b>1993</b> generated by a graphics processing engine is translated to a real address by MMU <b>1939</b>.</p><p id="p-0294" num="0271">In one embodiment, a same set of registers <b>1945</b> are duplicated for each graphics processing engine and/or graphics acceleration module <b>1946</b> and may be initialized by a hypervisor or operating system. Each of these duplicated registers may be included in accelerator integration slice <b>1990</b>. Exemplary registers that may be initialized by a hypervisor are shown in Table 1.</p><p id="p-0295" num="0000"><tables id="TABLE-US-00028" num="00028"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 1</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Hypervisor Initialized Registers</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="175pt" align="left"/><tbody valign="top"><row><entry/><entry>1</entry><entry>Slice Control Register</entry></row><row><entry/><entry>2</entry><entry>Real Address (RA) Scheduled Processes Area Pointer</entry></row><row><entry/><entry>3</entry><entry>Authority Mask Override Register</entry></row><row><entry/><entry>4</entry><entry>Interrupt Vector Table Entry Offset</entry></row><row><entry/><entry>5</entry><entry>Interrupt Vector Table Entry Limit</entry></row><row><entry/><entry>6</entry><entry>State Register</entry></row><row><entry/><entry>7</entry><entry>Logical Partition ID</entry></row><row><entry/><entry>8</entry><entry>Real address (RA) Hypervisor Accelerator</entry></row><row><entry/><entry/><entry>Utilization Record Pointer</entry></row><row><entry/><entry>9</entry><entry>Storage Description Register</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0296" num="0272">Exemplary registers that may be initialized by an operating system are shown in Table 2.</p><p id="p-0297" num="0000"><tables id="TABLE-US-00029" num="00029"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 2</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Operating System Initialized Registers</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="189pt" align="left"/><tbody valign="top"><row><entry>1</entry><entry>Process and Thread Identification</entry></row><row><entry>2</entry><entry>Effective Address (EA) Context Save/Restore Pointer</entry></row><row><entry>3</entry><entry>Virtual Address (VA) Accelerator Utilization Record Pointer</entry></row><row><entry>4</entry><entry>Virtual Address (VA) Storage Segment Table Pointer</entry></row><row><entry>5</entry><entry>Authority Mask</entry></row><row><entry>6</entry><entry>Work descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0298" num="0273">In one embodiment, each WD <b>1984</b> is specific to a particular graphics acceleration module <b>1946</b> and/or a particular graphics processing engine. It contains all information required by a graphics processing engine to do work or it can be a pointer to a memory location where an application has set up a command queue of work to be completed.</p><p id="p-0299" num="0274">In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>19</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>19</b></figref> are utilized to perform API to generate one or more graph code nodes to deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>19</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate and deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>19</b></figref> are utilized to implement one or more systems and/or processes such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>10</b></figref>.</p><p id="p-0300" num="0275"><figref idref="DRAWINGS">FIGS. <b>20</b>A-<b>20</b>B</figref> illustrate exemplary graphics processors, in accordance with at least one embodiment. In at least one embodiment, any of the exemplary graphics processors may be fabricated using one or more IP cores. In addition to what is illustrated, other logic and circuits may be included in at least one embodiment, including additional graphics processors/cores, peripheral interface controllers, or general-purpose processor cores. In at least one embodiment, the exemplary graphics processors are for use within an SoC.</p><p id="p-0301" num="0276"><figref idref="DRAWINGS">FIG. <b>20</b>A</figref> illustrates an exemplary graphics processor <b>2010</b> of an SoC integrated circuit that may be fabricated using one or more IP cores, in accordance with at least one embodiment. <figref idref="DRAWINGS">FIG. <b>20</b>B</figref> illustrates an additional exemplary graphics processor <b>2040</b> of an SoC integrated circuit that may be fabricated using one or more IP cores, in accordance with at least one embodiment. In at least one embodiment, graphics processor <b>2010</b> of <figref idref="DRAWINGS">FIG. <b>20</b>A</figref> is a low power graphics processor core. In at least one embodiment, graphics processor <b>2040</b> of <figref idref="DRAWINGS">FIG. <b>20</b>B</figref> is a higher performance graphics processor core. In at least one embodiment, each of graphics processors <b>2010</b>, <b>2040</b> can be variants of graphics processor <b>1510</b> of <figref idref="DRAWINGS">FIG. <b>15</b></figref>.</p><p id="p-0302" num="0277">In at least one embodiment, graphics processor <b>2010</b> includes a vertex processor <b>2005</b> and one or more fragment processor(s) <b>2015</b>A-<b>2015</b>N (e.g., <b>2015</b>A, <b>2015</b>B, <b>2015</b>C, <b>2015</b>D, through <b>2015</b>N&#x2212;1, and <b>2015</b>N). In at least one embodiment, graphics processor <b>2010</b> can execute different shader programs via separate logic, such that vertex processor <b>2005</b> is optimized to execute operations for vertex shader programs, while one or more fragment processor(s) <b>2015</b>A-<b>2015</b>N execute fragment (e.g., pixel) shading operations for fragment or pixel shader programs. In at least one embodiment, vertex processor <b>2005</b> performs a vertex processing stage of a 3D graphics pipeline and generates primitives and vertex data. In at least one embodiment, fragment processor(s) <b>2015</b>A-<b>2015</b>N use primitive and vertex data generated by vertex processor <b>2005</b> to produce a framebuffer that is displayed on a display device. In at least one embodiment, fragment processor(s) <b>2015</b>A-<b>2015</b>N are optimized to execute fragment shader programs as provided for in an OpenGL API, which may be used to perform similar operations as a pixel shader program as provided for in a Direct 3D API.</p><p id="p-0303" num="0278">In at least one embodiment, graphics processor <b>2010</b> additionally includes one or more MMU(s) <b>2020</b>A-<b>2020</b>B, cache(s) <b>2025</b>A-<b>2025</b>B, and circuit interconnect(s) <b>2030</b>A-<b>2030</b>B. In at least one embodiment, one or more MMU(s) <b>2020</b>A-<b>2020</b>B provide for virtual to physical address mapping for graphics processor <b>2010</b>, including for vertex processor <b>2005</b> and/or fragment processor(s) <b>2015</b>A-<b>2015</b>N, which may reference vertex or image/texture data stored in memory, in addition to vertex or image/texture data stored in one or more cache(s) <b>2025</b>A-<b>2025</b>B. In at least one embodiment, one or more MMU(s) <b>2020</b>A-<b>2020</b>B may be synchronized with other MMUs within a system, including one or more MMUs associated with one or more application processor(s) <b>1505</b>, image processors <b>1515</b>, and/or video processors <b>1520</b> of <figref idref="DRAWINGS">FIG. <b>15</b></figref>, such that each processor <b>1505</b>-<b>1520</b> can participate in a shared or unified virtual memory system. In at least one embodiment, one or more circuit interconnect(s) <b>2030</b>A-<b>2030</b>B enable graphics processor <b>2010</b> to interface with other IP cores within an SoC, either via an internal bus of the SoC or via a direct connection.</p><p id="p-0304" num="0279">In at least one embodiment, graphics processor <b>2040</b> includes one or more MMU(s) <b>2020</b>A-<b>2020</b>B, caches <b>2025</b>A-<b>2025</b>B, and circuit interconnects <b>2030</b>A-<b>2030</b>B of graphics processor <b>2010</b> of <figref idref="DRAWINGS">FIG. <b>20</b>A</figref>. In at least one embodiment, graphics processor <b>2040</b> includes one or more shader core(s) <b>2055</b>A-<b>2055</b>N (e.g., <b>2055</b>A, <b>2055</b>B, <b>2055</b>C, <b>2055</b>D, <b>2055</b>E, <b>2055</b>F, through <b>2055</b>N&#x2212;1, and <b>2055</b>N), which provides for a unified shader core architecture in which a single core or type or core can execute all types of programmable shader code, including shader program code to implement vertex shaders, fragment shaders, and/or compute shaders. In at least one embodiment, a number of shader cores can vary. In at least one embodiment, graphics processor <b>2040</b> includes an inter-core task manager <b>2045</b>, which acts as a thread dispatcher to dispatch execution threads to one or more shader cores <b>2055</b>A-<b>2055</b>N and a tiling unit <b>2058</b> to accelerate tiling operations for tile-based rendering, in which rendering operations for a scene are subdivided in image space, for example to exploit local spatial coherence within a scene or to optimize use of internal caches.</p><p id="p-0305" num="0280">In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIGS. <b>20</b>A-<b>20</b>B</figref> are utilized to perform API to generate one or more graph code nodes to allocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIGS. <b>20</b>A-<b>20</b>B</figref> are utilized to perform API to generate one or more graph code nodes to deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIGS. <b>20</b>A-<b>20</b>B</figref> are utilized to perform API to generate one or more graph code nodes to allocate and deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIGS. <b>20</b>A-<b>20</b>B</figref> are utilized to implement one or more systems and/or processes such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>10</b></figref>.</p><p id="p-0306" num="0281"><figref idref="DRAWINGS">FIG. <b>21</b>A</figref> illustrates a graphics core <b>2100</b>, in accordance with at least one embodiment. In at least one embodiment, graphics core <b>2100</b> may be included within graphics processor <b>1510</b> of <figref idref="DRAWINGS">FIG. <b>15</b></figref>. In at least one embodiment, graphics core <b>2100</b> may be a unified shader core <b>2055</b>A-<b>2055</b>N as in <figref idref="DRAWINGS">FIG. <b>20</b>B</figref>. In at least one embodiment, graphics core <b>2100</b> includes a shared instruction cache <b>2102</b>, a texture unit <b>2118</b>, and a cache/shared memory <b>2120</b> that are common to execution resources within graphics core <b>2100</b>. In at least one embodiment, graphics core <b>2100</b> can include multiple slices <b>2101</b>A-<b>2101</b>N or partition for each core, and a graphics processor can include multiple instances of graphics core <b>2100</b>. Slices <b>2101</b>A-<b>2101</b>N can include support logic including a local instruction cache <b>2104</b>A-<b>2104</b>N, a thread scheduler <b>2106</b>A-<b>2106</b>N, a thread dispatcher <b>2108</b>A-<b>2108</b>N, and a set of registers <b>2110</b>A-<b>2110</b>N. In at least one embodiment, slices <b>2101</b>A-<b>2101</b>N can include a set of additional function units (&#x201c;AFUs&#x201d;) <b>2112</b>A-<b>2112</b>N, floating-point units (&#x201c;FPUs&#x201d;) <b>2114</b>A-<b>2114</b>N, integer arithmetic logic units (&#x201c;ALUs&#x201d;) <b>2116</b>-<b>2116</b>N, address computational units (&#x201c;ACUs&#x201d;) <b>2113</b>A-<b>2113</b>N, double-precision floating-point units (&#x201c;DPFPUs&#x201d;) <b>2115</b>A-<b>2115</b>N, and matrix processing units (&#x201c;MPUs&#x201d;) <b>2117</b>A-<b>2117</b>N.</p><p id="p-0307" num="0282">In at least one embodiment, FPUs <b>2114</b>A-<b>2114</b>N can perform single-precision (32-bit) and half-precision (16-bit) floating point operations, while DPFPUs <b>2115</b>A-<b>2115</b>N perform double precision (64-bit) floating point operations. In at least one embodiment, ALUs <b>2116</b>A-<b>2116</b>N can perform variable precision integer operations at 8-bit, 16-bit, and 32-bit precision, and can be configured for mixed precision operations. In at least one embodiment, MPUs <b>2117</b>A-<b>2117</b>N can also be configured for mixed precision matrix operations, including half-precision floating point and 8-bit integer operations. In at least one embodiment, MPUs <b>2117</b>-<b>2117</b>N can perform a variety of matrix operations to accelerate CUDA programs, including enabling support for accelerated general matrix to matrix multiplication (&#x201c;GEMM&#x201d;). In at least one embodiment, AFUs <b>2112</b>A-<b>2112</b>N can perform additional logic operations not supported by floating-point or integer units, including trigonometric operations (e.g., Sine, Cosine, etc.).</p><p id="p-0308" num="0283"><figref idref="DRAWINGS">FIG. <b>21</b>B</figref> illustrates a general-purpose graphics processing unit (&#x201c;GPGPU&#x201d;) <b>2130</b>, in accordance with at least one embodiment. In at least one embodiment, GPGPU <b>2130</b> is highly-parallel and suitable for deployment on a multi-chip module. In at least one embodiment, GPGPU <b>2130</b> can be configured to enable highly-parallel compute operations to be performed by an array of GPUs. In at least one embodiment, GPGPU <b>2130</b> can be linked directly to other instances of GPGPU <b>2130</b> to create a multi-GPU cluster to improve execution time for CUDA programs. In at least one embodiment, GPGPU <b>2130</b> includes a host interface <b>2132</b> to enable a connection with a host processor. In at least one embodiment, host interface <b>2132</b> is a PCIe interface. In at least one embodiment, host interface <b>2132</b> can be a vendor specific communications interface or communications fabric. In at least one embodiment, GPGPU <b>2130</b> receives commands from a host processor and uses a global scheduler <b>2134</b> to distribute execution threads associated with those commands to a set of compute clusters <b>2136</b>A-<b>2136</b>H. In at least one embodiment, compute clusters <b>2136</b>A-<b>2136</b>H share a cache memory <b>2138</b>. In at least one embodiment, cache memory <b>2138</b> can serve as a higher-level cache for cache memories within compute clusters <b>2136</b>A-<b>2136</b>H.</p><p id="p-0309" num="0284">In at least one embodiment, GPGPU <b>2130</b> includes memory <b>2144</b>A-<b>2144</b>B coupled with compute clusters <b>2136</b>A-<b>2136</b>H via a set of memory controllers <b>2142</b>A-<b>2142</b>B. In at least one embodiment, memory <b>2144</b>A-<b>2144</b>B can include various types of memory devices including DRAM or graphics random access memory, such as synchronous graphics random access memory (&#x201c;SGRAM&#x201d;), including graphics double data rate (&#x201c;GDDR&#x201d;) memory.</p><p id="p-0310" num="0285">In at least one embodiment, compute clusters <b>2136</b>A-<b>2136</b>H each include a set of graphics cores, such as graphics core <b>2100</b> of <figref idref="DRAWINGS">FIG. <b>21</b>A</figref>, which can include multiple types of integer and floating point logic units that can perform computational operations at a range of precisions including suited for computations associated with CUDA programs. For example, in at least one embodiment, at least a subset of floating point units in each of compute clusters <b>2136</b>A-<b>2136</b>H can be configured to perform 16-bit or 32-bit floating point operations, while a different subset of floating point units can be configured to perform 64-bit floating point operations.</p><p id="p-0311" num="0286">In at least one embodiment, multiple instances of GPGPU <b>2130</b> can be configured to operate as a compute cluster. Compute clusters <b>2136</b>A-<b>2136</b>H may implement any technically feasible communication techniques for synchronization and data exchange. In at least one embodiment, multiple instances of GPGPU <b>2130</b> communicate over host interface <b>2132</b>. In at least one embodiment, GPGPU <b>2130</b> includes an I/O hub <b>2139</b> that couples GPGPU <b>2130</b> with a GPU link <b>2140</b> that enables a direct connection to other instances of GPGPU <b>2130</b>. In at least one embodiment, GPU link <b>2140</b> is coupled to a dedicated GPU-to-GPU bridge that enables communication and synchronization between multiple instances of GPGPU <b>2130</b>. In at least one embodiment GPU link <b>2140</b> couples with a high speed interconnect to transmit and receive data to other GPGPUs <b>2130</b> or parallel processors. In at least one embodiment, multiple instances of GPGPU <b>2130</b> are located in separate data processing systems and communicate via a network device that is accessible via host interface <b>2132</b>. In at least one embodiment GPU link <b>2140</b> can be configured to enable a connection to a host processor in addition to or as an alternative to host interface <b>2132</b>. In at least one embodiment, GPGPU <b>2130</b> can be configured to execute a CUDA program.</p><p id="p-0312" num="0287">In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIGS. <b>21</b>A-<b>21</b>B</figref> are utilized to perform API to generate one or more graph code nodes to allocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIGS. <b>21</b>A-<b>21</b>B</figref> are utilized to perform API to generate one or more graph code nodes to deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIGS. <b>21</b>A-<b>21</b>B</figref> are utilized to perform API to generate one or more graph code nodes to allocate and deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIGS. <b>21</b>A-<b>21</b>B</figref> are utilized to implement one or more systems and/or processes such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>10</b></figref>.</p><p id="p-0313" num="0288"><figref idref="DRAWINGS">FIG. <b>22</b>A</figref> illustrates a parallel processor <b>2200</b>, in accordance with at least one embodiment. In at least one embodiment, various components of parallel processor <b>2200</b> may be implemented using one or more integrated circuit devices, such as programmable processors, application specific integrated circuits (&#x201c;ASICs&#x201d;), or FPGAs.</p><p id="p-0314" num="0289">In at least one embodiment, parallel processor <b>2200</b> includes a parallel processing unit <b>2202</b>. In at least one embodiment, parallel processing unit <b>2202</b> includes an I/O unit <b>2204</b> that enables communication with other devices, including other instances of parallel processing unit <b>2202</b>. In at least one embodiment, I/O unit <b>2204</b> may be directly connected to other devices. In at least one embodiment, I/O unit <b>2204</b> connects with other devices via use of a hub or switch interface, such as memory hub <b>2205</b>. In at least one embodiment, connections between memory hub <b>2205</b> and I/O unit <b>2204</b> form a communication link. In at least one embodiment, I/O unit <b>2204</b> connects with a host interface <b>2206</b> and a memory crossbar <b>2216</b>, where host interface <b>2206</b> receives commands directed to performing processing operations and memory crossbar <b>2216</b> receives commands directed to performing memory operations.</p><p id="p-0315" num="0290">In at least one embodiment, when host interface <b>2206</b> receives a command buffer via I/O unit <b>2204</b>, host interface <b>2206</b> can direct work operations to perform those commands to a front end <b>2208</b>. In at least one embodiment, front end <b>2208</b> couples with a scheduler <b>2210</b>, which is configured to distribute commands or other work items to a processing array <b>2212</b>. In at least one embodiment, scheduler <b>2210</b> ensures that processing array <b>2212</b> is properly configured and in a valid state before tasks are distributed to processing array <b>2212</b>. In at least one embodiment, scheduler <b>2210</b> is implemented via firmware logic executing on a microcontroller. In at least one embodiment, microcontroller implemented scheduler <b>2210</b> is configurable to perform complex scheduling and work distribution operations at coarse and fine granularity, enabling rapid preemption and context switching of threads executing on processing array <b>2212</b>. In at least one embodiment, host software can prove workloads for scheduling on processing array <b>2212</b> via one of multiple graphics processing doorbells. In at least one embodiment, workloads can then be automatically distributed across processing array <b>2212</b> by scheduler <b>2210</b> logic within a microcontroller including scheduler <b>2210</b>.</p><p id="p-0316" num="0291">In at least one embodiment, processing array <b>2212</b> can include up to &#x201c;N&#x201d; clusters (e.g., cluster <b>2214</b>A, cluster <b>2214</b>B, through cluster <b>2214</b>N). In at least one embodiment, each cluster <b>2214</b>A-<b>2214</b>N of processing array <b>2212</b> can execute a large number of concurrent threads. In at least one embodiment, scheduler <b>2210</b> can allocate work to clusters <b>2214</b>A-<b>2214</b>N of processing array <b>2212</b> using various scheduling and/or work distribution algorithms, which may vary depending on the workload arising for each type of program or computation. In at least one embodiment, scheduling can be handled dynamically by scheduler <b>2210</b>, or can be assisted in part by compiler logic during compilation of program logic configured for execution by processing array <b>2212</b>. In at least one embodiment, different clusters <b>2214</b>A-<b>2214</b>N of processing array <b>2212</b> can be allocated for processing different types of programs or for performing different types of computations.</p><p id="p-0317" num="0292">In at least one embodiment, processing array <b>2212</b> can be configured to perform various types of parallel processing operations. In at least one embodiment, processing array <b>2212</b> is configured to perform general-purpose parallel compute operations. For example, in at least one embodiment, processing array <b>2212</b> can include logic to execute processing tasks including filtering of video and/or audio data, performing modeling operations, including physics operations, and performing data transformations.</p><p id="p-0318" num="0293">In at least one embodiment, processing array <b>2212</b> is configured to perform parallel graphics processing operations. In at least one embodiment, processing array <b>2212</b> can include additional logic to support execution of such graphics processing operations, including, but not limited to texture sampling logic to perform texture operations, as well as tessellation logic and other vertex processing logic. In at least one embodiment, processing array <b>2212</b> can be configured to execute graphics processing related shader programs such as, but not limited to vertex shaders, tessellation shaders, geometry shaders, and pixel shaders. In at least one embodiment, parallel processing unit <b>2202</b> can transfer data from system memory via I/O unit <b>2204</b> for processing. In at least one embodiment, during processing, transferred data can be stored to on-chip memory (e.g., a parallel processor memory <b>2222</b>) during processing, then written back to system memory.</p><p id="p-0319" num="0294">In at least one embodiment, when parallel processing unit <b>2202</b> is used to perform graphics processing, scheduler <b>2210</b> can be configured to divide a processing workload into approximately equal sized tasks, to better enable distribution of graphics processing operations to multiple clusters <b>2214</b>A-<b>2214</b>N of processing array <b>2212</b>. In at least one embodiment, portions of processing array <b>2212</b> can be configured to perform different types of processing. For example, in at least one embodiment, a first portion may be configured to perform vertex shading and topology generation, a second portion may be configured to perform tessellation and geometry shading, and a third portion may be configured to perform pixel shading or other screen space operations, to produce a rendered image for display. In at least one embodiment, intermediate data produced by one or more of clusters <b>2214</b>A-<b>2214</b>N may be stored in buffers to allow intermediate data to be transmitted between clusters <b>2214</b>A-<b>2214</b>N for further processing.</p><p id="p-0320" num="0295">In at least one embodiment, processing array <b>2212</b> can receive processing tasks to be executed via scheduler <b>2210</b>, which receives commands defining processing tasks from front end <b>2208</b>. In at least one embodiment, processing tasks can include indices of data to be processed, e.g., surface (patch) data, primitive data, vertex data, and/or pixel data, as well as state parameters and commands defining how data is to be processed (e.g., what program is to be executed). In at least one embodiment, scheduler <b>2210</b> may be configured to fetch indices corresponding to tasks or may receive indices from front end <b>2208</b>. In at least one embodiment, front end <b>2208</b> can be configured to ensure processing array <b>2212</b> is configured to a valid state before a workload specified by incoming command buffers (e.g., batch-buffers, push buffers, etc.) is initiated.</p><p id="p-0321" num="0296">In at least one embodiment, each of one or more instances of parallel processing unit <b>2202</b> can couple with parallel processor memory <b>2222</b>. In at least one embodiment, parallel processor memory <b>2222</b> can be accessed via memory crossbar <b>2216</b>, which can receive memory requests from processing array <b>2212</b> as well as I/O unit <b>2204</b>. In at least one embodiment, memory crossbar <b>2216</b> can access parallel processor memory <b>2222</b> via a memory interface <b>2218</b>. In at least one embodiment, memory interface <b>2218</b> can include multiple partition units (e.g., a partition unit <b>2220</b>A, partition unit <b>2220</b>B, through partition unit <b>2220</b>N) that can each couple to a portion (e.g., memory unit) of parallel processor memory <b>2222</b>. In at least one embodiment, a number of partition units <b>2220</b>A-<b>2220</b>N is configured to be equal to a number of memory units, such that a first partition unit <b>2220</b>A has a corresponding first memory unit <b>2224</b>A, a second partition unit <b>2220</b>B has a corresponding memory unit <b>2224</b>B, and an Nth partition unit <b>2220</b>N has a corresponding Nth memory unit <b>2224</b>N. In at least one embodiment, a number of partition units <b>2220</b>A-<b>2220</b>N may not be equal to a number of memory devices.</p><p id="p-0322" num="0297">In at least one embodiment, memory units <b>2224</b>A-<b>2224</b>N can include various types of memory devices, including DRAM or graphics random access memory, such as SGRAM, including GDDR memory. In at least one embodiment, memory units <b>2224</b>A-<b>2224</b>N may also include 3D stacked memory, including but not limited to high bandwidth memory (&#x201c;HBM&#x201d;). In at least one embodiment, render targets, such as frame buffers or texture maps may be stored across memory units <b>2224</b>A-<b>2224</b>N, allowing partition units <b>2220</b>A-<b>2220</b>N to write portions of each render target in parallel to efficiently use available bandwidth of parallel processor memory <b>2222</b>. In at least one embodiment, a local instance of parallel processor memory <b>2222</b> may be excluded in favor of a unified memory design that utilizes system memory in conjunction with local cache memory.</p><p id="p-0323" num="0298">In at least one embodiment, any one of clusters <b>2214</b>A-<b>2214</b>N of processing array <b>2212</b> can process data that will be written to any of memory units <b>2224</b>A-<b>2224</b>N within parallel processor memory <b>2222</b>. In at least one embodiment, memory crossbar <b>2216</b> can be configured to transfer an output of each cluster <b>2214</b>A-<b>2214</b>N to any partition unit <b>2220</b>A-<b>2220</b>N or to another cluster <b>2214</b>A-<b>2214</b>N, which can perform additional processing operations on an output. In at least one embodiment, each cluster <b>2214</b>A-<b>2214</b>N can communicate with memory interface <b>2218</b> through memory crossbar <b>2216</b> to read from or write to various external memory devices. In at least one embodiment, memory crossbar <b>2216</b> has a connection to memory interface <b>2218</b> to communicate with I/O unit <b>2204</b>, as well as a connection to a local instance of parallel processor memory <b>2222</b>, enabling processing units within different clusters <b>2214</b>A-<b>2214</b>N to communicate with system memory or other memory that is not local to parallel processing unit <b>2202</b>. In at least one embodiment, memory crossbar <b>2216</b> can use virtual channels to separate traffic streams between clusters <b>2214</b>A-<b>2214</b>N and partition units <b>2220</b>A-<b>2220</b>N.</p><p id="p-0324" num="0299">In at least one embodiment, multiple instances of parallel processing unit <b>2202</b> can be provided on a single add-in card, or multiple add-in cards can be interconnected. In at least one embodiment, different instances of parallel processing unit <b>2202</b> can be configured to inter-operate even if different instances have different numbers of processing cores, different amounts of local parallel processor memory, and/or other configuration differences. For example, in at least one embodiment, some instances of parallel processing unit <b>2202</b> can include higher precision floating point units relative to other instances. In at least one embodiment, systems incorporating one or more instances of parallel processing unit <b>2202</b> or parallel processor <b>2200</b> can be implemented in a variety of configurations and form factors, including but not limited to desktop, laptop, or handheld personal computers, servers, workstations, game consoles, and/or embedded systems.</p><p id="p-0325" num="0300"><figref idref="DRAWINGS">FIG. <b>22</b>B</figref> illustrates a processing cluster <b>2294</b>, in accordance with at least one embodiment. In at least one embodiment, processing cluster <b>2294</b> is included within a parallel processing unit. In at least one embodiment, processing cluster <b>2294</b> is one of processing clusters <b>2214</b>A-<b>2214</b>N of <figref idref="DRAWINGS">FIG. <b>22</b></figref>. In at least one embodiment, processing cluster <b>2294</b> can be configured to execute many threads in parallel, where the term &#x201c;thread&#x201d; refers to an instance of a particular program executing on a particular set of input data. In at least one embodiment, single instruction, multiple data (&#x201c;SIMD&#x201d;) instruction issue techniques are used to support parallel execution of a large number of threads without providing multiple independent instruction units. In at least one embodiment, single instruction, multiple thread (&#x201c;SIMT&#x201d;) techniques are used to support parallel execution of a large number of generally synchronized threads, using a common instruction unit configured to issue instructions to a set of processing engines within each processing cluster <b>2294</b>.</p><p id="p-0326" num="0301">In at least one embodiment, operation of processing cluster <b>2294</b> can be controlled via a pipeline manager <b>2232</b> that distributes processing tasks to SIMT parallel processors. In at least one embodiment, pipeline manager <b>2232</b> receives instructions from scheduler <b>2210</b> of <figref idref="DRAWINGS">FIG. <b>22</b></figref> and manages execution of those instructions via a graphics multiprocessor <b>2234</b> and/or a texture unit <b>2236</b>. In at least one embodiment, graphics multiprocessor <b>2234</b> is an exemplary instance of a SIMT parallel processor. However, in at least one embodiment, various types of SIMT parallel processors of differing architectures may be included within processing cluster <b>2294</b>. In at least one embodiment, one or more instances of graphics multiprocessor <b>2234</b> can be included within processing cluster <b>2294</b>. In at least one embodiment, graphics multiprocessor <b>2234</b> can process data and a data crossbar <b>2240</b> can be used to distribute processed data to one of multiple possible destinations, including other shader units. In at least one embodiment, pipeline manager <b>2232</b> can facilitate distribution of processed data by specifying destinations for processed data to be distributed via data crossbar <b>2240</b>.</p><p id="p-0327" num="0302">In at least one embodiment, each graphics multiprocessor <b>2234</b> within processing cluster <b>2294</b> can include an identical set of functional execution logic (e.g., arithmetic logic units, load/store units (&#x201c;LSUs&#x201d;), etc.). In at least one embodiment, functional execution logic can be configured in a pipelined manner in which new instructions can be issued before previous instructions are complete. In at least one embodiment, functional execution logic supports a variety of operations including integer and floating point arithmetic, comparison operations, Boolean operations, bit-shifting, and computation of various algebraic functions. In at least one embodiment, same functional-unit hardware can be leveraged to perform different operations and any combination of functional units may be present.</p><p id="p-0328" num="0303">In at least one embodiment, instructions transmitted to processing cluster <b>2294</b> constitute a thread. In at least one embodiment, a set of threads executing across a set of parallel processing engines is a thread group. In at least one embodiment, a thread group executes a program on different input data. In at least one embodiment, each thread within a thread group can be assigned to a different processing engine within graphics multiprocessor <b>2234</b>. In at least one embodiment, a thread group may include fewer threads than a number of processing engines within graphics multiprocessor <b>2234</b>. In at least one embodiment, when a thread group includes fewer threads than a number of processing engines, one or more of the processing engines may be idle during cycles in which that thread group is being processed. In at least one embodiment, a thread group may also include more threads than a number of processing engines within graphics multiprocessor <b>2234</b>. In at least one embodiment, when a thread group includes more threads than the number of processing engines within graphics multiprocessor <b>2234</b>, processing can be performed over consecutive clock cycles. In at least one embodiment, multiple thread groups can be executed concurrently on graphics multiprocessor <b>2234</b>.</p><p id="p-0329" num="0304">In at least one embodiment, graphics multiprocessor <b>2234</b> includes an internal cache memory to perform load and store operations. In at least one embodiment, graphics multiprocessor <b>2234</b> can forego an internal cache and use a cache memory (e.g., L1 cache <b>2248</b>) within processing cluster <b>2294</b>. In at least one embodiment, each graphics multiprocessor <b>2234</b> also has access to Level 2 (&#x201c;L2&#x201d;) caches within partition units (e.g., partition units <b>2220</b>A-<b>2220</b>N of <figref idref="DRAWINGS">FIG. <b>22</b>A</figref>) that are shared among all processing clusters <b>2294</b> and may be used to transfer data between threads. In at least one embodiment, graphics multiprocessor <b>2234</b> may also access off-chip global memory, which can include one or more of local parallel processor memory and/or system memory. In at least one embodiment, any memory external to parallel processing unit <b>2202</b> may be used as global memory. In at least one embodiment, processing cluster <b>2294</b> includes multiple instances of graphics multiprocessor <b>2234</b> that can share common instructions and data, which may be stored in L1 cache <b>2248</b>.</p><p id="p-0330" num="0305">In at least one embodiment, each processing cluster <b>2294</b> may include an MMU <b>2245</b> that is configured to map virtual addresses into physical addresses. In at least one embodiment, one or more instances of MMU <b>2245</b> may reside within memory interface <b>2218</b> of <figref idref="DRAWINGS">FIG. <b>22</b></figref>. In at least one embodiment, MMU <b>2245</b> includes a set of page table entries (&#x201c;PTEs&#x201d;) used to map a virtual address to a physical address of a tile and optionally a cache line index. In at least one embodiment, MMU <b>2245</b> may include address translation lookaside buffers (&#x201c;TLBs&#x201d;) or caches that may reside within graphics multiprocessor <b>2234</b> or L1 cache <b>2248</b> or processing cluster <b>2294</b>. In at least one embodiment, a physical address is processed to distribute surface data access locality to allow efficient request interleaving among partition units. In at least one embodiment, a cache line index may be used to determine whether a request for a cache line is a hit or miss.</p><p id="p-0331" num="0306">In at least one embodiment, processing cluster <b>2294</b> may be configured such that each graphics multiprocessor <b>2234</b> is coupled to a texture unit <b>2236</b> for performing texture mapping operations, e.g., determining texture sample positions, reading texture data, and filtering texture data. In at least one embodiment, texture data is read from an internal texture L1 cache (not shown) or from an L1 cache within graphics multiprocessor <b>2234</b> and is fetched from an L2 cache, local parallel processor memory, or system memory, as needed. In at least one embodiment, each graphics multiprocessor <b>2234</b> outputs a processed task to data crossbar <b>2240</b> to provide the processed task to another processing cluster <b>2294</b> for further processing or to store the processed task in an L2 cache, a local parallel processor memory, or a system memory via memory crossbar <b>2216</b>. In at least one embodiment, a pre-raster operations unit (&#x201c;preROP&#x201d;) <b>2242</b> is configured to receive data from graphics multiprocessor <b>2234</b>, direct data to ROP units, which may be located with partition units as described herein (e.g., partition units <b>2220</b>A-<b>2220</b>N of <figref idref="DRAWINGS">FIG. <b>22</b></figref>). In at least one embodiment, PreROP <b>2242</b> can perform optimizations for color blending, organize pixel color data, and perform address translations.</p><p id="p-0332" num="0307"><figref idref="DRAWINGS">FIG. <b>22</b>C</figref> illustrates a graphics multiprocessor <b>2296</b>, in accordance with at least one embodiment. In at least one embodiment, graphics multiprocessor <b>2296</b> is graphics multiprocessor <b>2234</b> of <figref idref="DRAWINGS">FIG. <b>22</b>B</figref>. In at least one embodiment, graphics multiprocessor <b>2296</b> couples with pipeline manager <b>2232</b> of processing cluster <b>2294</b>. In at least one embodiment, graphics multiprocessor <b>2296</b> has an execution pipeline including but not limited to an instruction cache <b>2252</b>, an instruction unit <b>2254</b>, an address mapping unit <b>2256</b>, a register file <b>2258</b>, one or more GPGPU cores <b>2262</b>, and one or more LSUs <b>2266</b>. GPGPU cores <b>2262</b> and LSUs <b>2266</b> are coupled with cache memory <b>2272</b> and shared memory <b>2270</b> via a memory and cache interconnect <b>2268</b>.</p><p id="p-0333" num="0308">In at least one embodiment, instruction cache <b>2252</b> receives a stream of instructions to execute from pipeline manager <b>2232</b>. In at least one embodiment, instructions are cached in instruction cache <b>2252</b> and dispatched for execution by instruction unit <b>2254</b>. In at least one embodiment, instruction unit <b>2254</b> can dispatch instructions as thread groups (e.g., warps), with each thread of a thread group assigned to a different execution unit within GPGPU core <b>2262</b>. In at least one embodiment, an instruction can access any of a local, shared, or global address space by specifying an address within a unified address space. In at least one embodiment, address mapping unit <b>2256</b> can be used to translate addresses in a unified address space into a distinct memory address that can be accessed by LSUs <b>2266</b>.</p><p id="p-0334" num="0309">In at least one embodiment, register file <b>2258</b> provides a set of registers for functional units of graphics multiprocessor <b>2296</b>. In at least one embodiment, register file <b>2258</b> provides temporary storage for operands connected to data paths of functional units (e.g., GPGPU cores <b>2262</b>, LSUs <b>2266</b>) of graphics multiprocessor <b>2296</b>. In at least one embodiment, register file <b>2258</b> is divided between each of functional units such that each functional unit is allocated a dedicated portion of register file <b>2258</b>. In at least one embodiment, register file <b>2258</b> is divided between different thread groups being executed by graphics multiprocessor <b>2296</b>.</p><p id="p-0335" num="0310">In at least one embodiment, GPGPU cores <b>2262</b> can each include FPUs and/or integer ALUs that are used to execute instructions of graphics multiprocessor <b>2296</b>. GPGPU cores <b>2262</b> can be similar in architecture or can differ in architecture. In at least one embodiment, a first portion of GPGPU cores <b>2262</b> include a single precision FPU and an integer ALU while a second portion of GPGPU cores <b>2262</b> include a double precision FPU. In at least one embodiment, FPUs can implement IEEE 754-2008 standard for floating point arithmetic or enable variable precision floating point arithmetic. In at least one embodiment, graphics multiprocessor <b>2296</b> can additionally include one or more fixed function or special function units to perform specific functions such as copy rectangle or pixel blending operations. In at least one embodiment one or more of GPGPU cores <b>2262</b> can also include fixed or special function logic.</p><p id="p-0336" num="0311">In at least one embodiment, GPGPU cores <b>2262</b> include SIMD logic capable of performing a single instruction on multiple sets of data. In at least one embodiment GPGPU cores <b>2262</b> can physically execute SIMD4, SIMD8, and SIMD16 instructions and logically execute SIMD1, SIMD2, and SIMD32 instructions. In at least one embodiment, SIMD instructions for GPGPU cores <b>2262</b> can be generated at compile time by a shader compiler or automatically generated when executing programs written and compiled for single program multiple data (&#x201c;SPMD&#x201d;) or SIMT architectures. In at least one embodiment, multiple threads of a program configured for an SIMT execution model can executed via a single SIMD instruction. For example, in at least one embodiment, eight SIMT threads that perform the same or similar operations can be executed in parallel via a single SIMD8 logic unit.</p><p id="p-0337" num="0312">In at least one embodiment, memory and cache interconnect <b>2268</b> is an interconnect network that connects each functional unit of graphics multiprocessor <b>2296</b> to register file <b>2258</b> and to shared memory <b>2270</b>. In at least one embodiment, memory and cache interconnect <b>2268</b> is a crossbar interconnect that allows LSU <b>2266</b> to implement load and store operations between shared memory <b>2270</b> and register file <b>2258</b>. In at least one embodiment, register file <b>2258</b> can operate at a same frequency as GPGPU cores <b>2262</b>, thus data transfer between GPGPU cores <b>2262</b> and register file <b>2258</b> is very low latency. In at least one embodiment, shared memory <b>2270</b> can be used to enable communication between threads that execute on functional units within graphics multiprocessor <b>2296</b>. In at least one embodiment, cache memory <b>2272</b> can be used as a data cache for example, to cache texture data communicated between functional units and texture unit <b>2236</b>. In at least one embodiment, shared memory <b>2270</b> can also be used as a program managed cached. In at least one embodiment, threads executing on GPGPU cores <b>2262</b> can programmatically store data within shared memory in addition to automatically cached data that is stored within cache memory <b>2272</b>.</p><p id="p-0338" num="0313">In at least one embodiment, a parallel processor or GPGPU as described herein is communicatively coupled to host/processor cores to accelerate graphics operations, machine-learning operations, pattern analysis operations, and various general purpose GPU (GPGPU) functions. In at least one embodiment, a GPU may be communicatively coupled to host processor/cores over a bus or other interconnect (e.g., a high speed interconnect such as PCIe or NVLink). In at least one embodiment, a GPU may be integrated on the same package or chip as cores and communicatively coupled to cores over a processor bus/interconnect that is internal to a package or a chip. In at least one embodiment, regardless of the manner in which a GPU is connected, processor cores may allocate work to the GPU in the form of sequences of commands/instructions contained in a WD. In at least one embodiment, the GPU then uses dedicated circuitry/logic for efficiently processing these commands/instructions.</p><p id="p-0339" num="0314">In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIGS. <b>22</b>A-<b>22</b>C</figref> are utilized to perform API to generate one or more graph code nodes to allocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIGS. <b>22</b>A-<b>22</b>C</figref> are utilized to perform API to generate one or more graph code nodes to deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIGS. <b>22</b>A-<b>22</b>C</figref> are utilized to perform API to generate one or more graph code nodes to allocate and deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIGS. <b>22</b>A-<b>22</b>C</figref> are utilized to implement one or more systems and/or processes such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>10</b></figref>.</p><p id="p-0340" num="0315"><figref idref="DRAWINGS">FIG. <b>23</b></figref> illustrates a graphics processor <b>2300</b>, in accordance with at least one embodiment. In at least one embodiment, graphics processor <b>2300</b> includes a ring interconnect <b>2302</b>, a pipeline front-end <b>2304</b>, a media engine <b>2337</b>, and graphics cores <b>2380</b>A-<b>2380</b>N. In at least one embodiment, ring interconnect <b>2302</b> couples graphics processor <b>2300</b> to other processing units, including other graphics processors or one or more general-purpose processor cores. In at least one embodiment, graphics processor <b>2300</b> is one of many processors integrated within a multi-core processing system.</p><p id="p-0341" num="0316">In at least one embodiment, graphics processor <b>2300</b> receives batches of commands via ring interconnect <b>2302</b>. In at least one embodiment, incoming commands are interpreted by a command streamer <b>2303</b> in pipeline front-end <b>2304</b>. In at least one embodiment, graphics processor <b>2300</b> includes scalable execution logic to perform 3D geometry processing and media processing via graphics core(s) <b>2380</b>A-<b>2380</b>N. In at least one embodiment, for 3D geometry processing commands, command streamer <b>2303</b> supplies commands to geometry pipeline <b>2336</b>. In at least one embodiment, for at least some media processing commands, command streamer <b>2303</b> supplies commands to a video front end <b>2334</b>, which couples with a media engine <b>2337</b>. In at least one embodiment, media engine <b>2337</b> includes a Video Quality Engine (&#x201c;VQE&#x201d;) <b>2330</b> for video and image post-processing and a multi-format encode/decode (&#x201c;MFX&#x201d;) engine <b>2333</b> to provide hardware-accelerated media data encode and decode. In at least one embodiment, geometry pipeline <b>2336</b> and media engine <b>2337</b> each generate execution threads for thread execution resources provided by at least one graphics core <b>2380</b>A.</p><p id="p-0342" num="0317">In at least one embodiment, graphics processor <b>2300</b> includes scalable thread execution resources featuring modular graphics cores <b>2380</b>A-<b>2380</b>N (sometimes referred to as core slices), each having multiple sub-cores <b>2350</b>A-<b>550</b>N, <b>2360</b>A-<b>2360</b>N (sometimes referred to as core sub-slices). In at least one embodiment, graphics processor <b>2300</b> can have any number of graphics cores <b>2380</b>A through <b>2380</b>N. In at least one embodiment, graphics processor <b>2300</b> includes a graphics core <b>2380</b>A having at least a first sub-core <b>2350</b>A and a second sub-core <b>2360</b>A. In at least one embodiment, graphics processor <b>2300</b> is a low power processor with a single sub-core (e.g., sub-core <b>2350</b>A). In at least one embodiment, graphics processor <b>2300</b> includes multiple graphics cores <b>2380</b>A-<b>2380</b>N, each including a set of first sub-cores <b>2350</b>A-<b>2350</b>N and a set of second sub-cores <b>2360</b>A-<b>2360</b>N. In at least one embodiment, each sub-core in first sub-cores <b>2350</b>A-<b>2350</b>N includes at least a first set of execution units (&#x201c;EUs&#x201d;) <b>2352</b>A-<b>2352</b>N and media/texture samplers <b>2354</b>A-<b>2354</b>N. In at least one embodiment, each sub-core in second sub-cores <b>2360</b>A-<b>2360</b>N includes at least a second set of execution units <b>2362</b>A-<b>2362</b>N and samplers <b>2364</b>A-<b>2364</b>N. In at least one embodiment, each sub-core <b>2350</b>A-<b>2350</b>N, <b>2360</b>A-<b>2360</b>N shares a set of shared resources <b>2370</b>A-<b>2370</b>N. In at least one embodiment, shared resources <b>2370</b> include shared cache memory and pixel operation logic.</p><p id="p-0343" num="0318">In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>23</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>23</b></figref> are utilized to perform API to generate one or more graph code nodes to deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>23</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate and deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>23</b></figref> are utilized to implement one or more systems and/or processes such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>10</b></figref>.</p><p id="p-0344" num="0319"><figref idref="DRAWINGS">FIG. <b>24</b></figref> illustrates a processor <b>2400</b>, in accordance with at least one embodiment. In at least one embodiment, processor <b>2400</b> may include, without limitation, logic circuits to perform instructions. In at least one embodiment, processor <b>2400</b> may perform instructions, including x86 instructions, ARM instructions, specialized instructions for ASICs, etc. In at least one embodiment, processor <b>2410</b> may include registers to store packed data, such as 64-bit wide MMX&#x2122; registers in microprocessors enabled with MMX technology from Intel Corporation of Santa Clara, Calif. In at least one embodiment, MMX registers, available in both integer and floating point forms, may operate with packed data elements that accompany SIMD and streaming SIMD extensions (&#x201c;SSE&#x201d;) instructions. In at least one embodiment, 128-bit wide XMM registers relating to SSE2, SSE3, SSE4, AVX, or beyond (referred to generically as &#x201c;SSEx&#x201d;) technology may hold such packed data operands. In at least one embodiment, processors <b>2410</b> may perform instructions to accelerate CUDA programs.</p><p id="p-0345" num="0320">In at least one embodiment, processor <b>2400</b> includes an in-order front end (&#x201c;front end&#x201d;) <b>2401</b> to fetch instructions to be executed and prepare instructions to be used later in processor pipeline. In at least one embodiment, front end <b>2401</b> may include several units. In at least one embodiment, an instruction prefetcher <b>2426</b> fetches instructions from memory and feeds instructions to an instruction decoder <b>2428</b> which in turn decodes or interprets instructions. For example, in at least one embodiment, instruction decoder <b>2428</b> decodes a received instruction into one or more operations called &#x201c;micro-instructions&#x201d; or &#x201c;micro-operations&#x201d; (also called &#x201c;micro ops&#x201d;or &#x201c;uops&#x201d;) for execution. In at least one embodiment, instruction decoder <b>2428</b> parses instruction into an opcode and corresponding data and control fields that may be used by micro-architecture to perform operations. In at least one embodiment, a trace cache <b>2430</b> may assemble decoded uops into program ordered sequences or traces in a uop queue <b>2434</b> for execution. In at least one embodiment, when trace cache <b>2430</b> encounters a complex instruction, a microcode ROM <b>2432</b> provides uops needed to complete an operation.</p><p id="p-0346" num="0321">In at least one embodiment, some instructions may be converted into a single micro-op, whereas others need several micro-ops to complete full operation. In at least one embodiment, if more than four micro-ops are needed to complete an instruction, instruction decoder <b>2428</b> may access microcode ROM <b>2432</b> to perform instruction. In at least one embodiment, an instruction may be decoded into a small number of micro-ops for processing at instruction decoder <b>2428</b>. In at least one embodiment, an instruction may be stored within microcode ROM <b>2432</b> should a number of micro-ops be needed to accomplish operation. In at least one embodiment, trace cache <b>2430</b> refers to an entry point programmable logic array (&#x201c;PLA&#x201d;) to determine a correct micro-instruction pointer for reading microcode sequences to complete one or more instructions from microcode ROM <b>2432</b>. In at least one embodiment, after microcode ROM <b>2432</b> finishes sequencing micro-ops for an instruction, front end <b>2401</b> of machine may resume fetching micro-ops from trace cache <b>2430</b>.</p><p id="p-0347" num="0322">In at least one embodiment, out-of-order execution engine (&#x201c;out of order engine&#x201d;) <b>2403</b> may prepare instructions for execution. In at least one embodiment, out-of-order execution logic has a number of buffers to smooth out and re-order the flow of instructions to optimize performance as they go down a pipeline and get scheduled for execution. Out-of-order execution engine <b>2403</b> includes, without limitation, an allocator/register renamer <b>2440</b>, a memory uop queue <b>2442</b>, an integer/floating point uop queue <b>2444</b>, a memory scheduler <b>2446</b>, a fast scheduler <b>2402</b>, a slow/general floating point scheduler (&#x201c;slow/general FP scheduler&#x201d;) <b>2404</b>, and a simple floating point scheduler (&#x201c;simple FP scheduler&#x201d;) <b>2406</b>. In at least one embodiment, fast schedule <b>2402</b>, slow/general floating point scheduler <b>2404</b>, and simple floating point scheduler <b>2406</b> are also collectively referred to herein as &#x201c;uop schedulers <b>2402</b>, <b>2404</b>, <b>2406</b>.&#x201d; Allocator/register renamer <b>2440</b> allocates machine buffers and resources that each uop needs in order to execute. In at least one embodiment, allocator/register renamer <b>2440</b> renames logic registers onto entries in a register file. In at least one embodiment, allocator/register renamer <b>2440</b> also allocates an entry for each uop in one of two uop queues, memory uop queue <b>2442</b> for memory operations and integer/floating point uop queue <b>2444</b> for non-memory operations, in front of memory scheduler <b>2446</b> and uop schedulers <b>2402</b>, <b>2404</b>, <b>2406</b>. In at least one embodiment, uop schedulers <b>2402</b>, <b>2404</b>, <b>2406</b>, determine when a uop is ready to execute based on readiness of their dependent input register operand sources and availability of execution resources uops need to complete their operation. In at least one embodiment, fast scheduler <b>2402</b> of at least one embodiment may schedule on each half of main clock cycle while slow/general floating point scheduler <b>2404</b> and simple floating point scheduler <b>2406</b> may schedule once per main processor clock cycle. In at least one embodiment, uop schedulers <b>2402</b>, <b>2404</b>, <b>2406</b> arbitrate for dispatch ports to schedule uops for execution.</p><p id="p-0348" num="0323">In at least one embodiment, execution block <b>2411</b> includes, without limitation, an integer register file/bypass network <b>2408</b>, a floating point register file/bypass network (&#x201c;FP register file/bypass network&#x201d;) <b>2410</b>, address generation units (&#x201c;AGUs&#x201d;) <b>2412</b> and <b>2414</b>, fast ALUs <b>2416</b> and <b>2418</b>, a slow ALU <b>2420</b>, a floating point ALU (&#x201c;FP&#x201d;) <b>2422</b>, and a floating point move unit (&#x201c;FP move&#x201d;) <b>2424</b>. In at least one embodiment, integer register file/bypass network <b>2408</b> and floating point register file/bypass network <b>2410</b> are also referred to herein as &#x201c;register files <b>2408</b>, <b>2410</b>.&#x201d; In at least one embodiment, AGUSs <b>2412</b> and <b>2414</b>, fast ALUs <b>2416</b> and <b>2418</b>, slow ALU <b>2420</b>, floating point ALU <b>2422</b>, and floating point move unit <b>2424</b> are also referred to herein as &#x201c;execution units <b>2412</b>, <b>2414</b>, <b>2416</b>, <b>2418</b>, <b>2420</b>, <b>2422</b>, and <b>2424</b>.&#x201d; In at least one embodiment, an execution block may include, without limitation, any number (including zero) and type of register files, bypass networks, address generation units, and execution units, in any combination.</p><p id="p-0349" num="0324">In at least one embodiment, register files <b>2408</b>, <b>2410</b> may be arranged between uop schedulers <b>2402</b>, <b>2404</b>, <b>2406</b>, and execution units <b>2412</b>, <b>2414</b>, <b>2416</b>, <b>2418</b>, <b>2420</b>, <b>2422</b>, and <b>2424</b>. In at least one embodiment, integer register file/bypass network <b>2408</b> performs integer operations. In at least one embodiment, floating point register file/bypass network <b>2410</b> performs floating point operations. In at least one embodiment, each of register files <b>2408</b>, <b>2410</b> may include, without limitation, a bypass network that may bypass or forward just completed results that have not yet been written into register file to new dependent uops. In at least one embodiment, register files <b>2408</b>, <b>2410</b> may communicate data with each other. In at least one embodiment, integer register file/bypass network <b>2408</b> may include, without limitation, two separate register files, one register file for low-order thirty-two bits of data and a second register file for high order thirty-two bits of data. In at least one embodiment, floating point register file/bypass network <b>2410</b> may include, without limitation, 128-bit wide entries because floating point instructions typically have operands from 64 to 128 bits in width.</p><p id="p-0350" num="0325">In at least one embodiment, execution units <b>2412</b>, <b>2414</b>, <b>2416</b>, <b>2418</b>, <b>2420</b>, <b>2422</b>, <b>2424</b> may execute instructions. In at least one embodiment, register files <b>2408</b>, <b>2410</b> store integer and floating point data operand values that micro-instructions need to execute. In at least one embodiment, processor <b>2400</b> may include, without limitation, any number and combination of execution units <b>2412</b>, <b>2414</b>, <b>2416</b>, <b>2418</b>, <b>2420</b>, <b>2422</b>, <b>2424</b>. In at least one embodiment, floating point ALU <b>2422</b> and floating point move unit <b>2424</b> may execute floating point, MMX, SIMD, AVX and SSE, or other operations. In at least one embodiment, floating point ALU <b>2422</b> may include, without limitation, a 64-bit by 64-bit floating point divider to execute divide, square root, and remainder micro ops. In at least one embodiment, instructions involving a floating point value may be handled with floating point hardware. In at least one embodiment, ALU operations may be passed to fast ALUs <b>2416</b>, <b>2418</b>. In at least one embodiment, fast ALUS <b>2416</b>, <b>2418</b> may execute fast operations with an effective latency of half a clock cycle. In at least one embodiment, most complex integer operations go to slow ALU <b>2420</b> as slow ALU <b>2420</b> may include, without limitation, integer execution hardware for long-latency type of operations, such as a multiplier, shifts, flag logic, and branch processing. In at least one embodiment, memory load/store operations may be executed by AGUs <b>2412</b>, <b>2414</b>. In at least one embodiment, fast ALU <b>2416</b>, fast ALU <b>2418</b>, and slow ALU <b>2420</b> may perform integer operations on 64-bit data operands. In at least one embodiment, fast ALU <b>2416</b>, fast ALU <b>2418</b>, and slow ALU <b>2420</b> may be implemented to support a variety of data bit sizes including sixteen, thirty-two, 128, 256, etc. In at least one embodiment, floating point ALU <b>2422</b> and floating point move unit <b>2424</b> may be implemented to support a range of operands having bits of various widths. In at least one embodiment, floating point ALU <b>2422</b> and floating point move unit <b>2424</b> may operate on 128-bit wide packed data operands in conjunction with SIMD and multimedia instructions.</p><p id="p-0351" num="0326">In at least one embodiment, uop schedulers <b>2402</b>, <b>2404</b>, <b>2406</b> dispatch dependent operations before parent load has finished executing. In at least one embodiment, as uops may be speculatively scheduled and executed in processor <b>2400</b>, processor <b>2400</b> may also include logic to handle memory misses. In at least one embodiment, if a data load misses in a data cache, there may be dependent operations in flight in pipeline that have left a scheduler with temporarily incorrect data. In at least one embodiment, a replay mechanism tracks and re-executes instructions that use incorrect data. In at least one embodiment, dependent operations might need to be replayed and independent ones may be allowed to complete. In at least one embodiment, schedulers and replay mechanisms of at least one embodiment of a processor may also be designed to catch instruction sequences for text string comparison operations.</p><p id="p-0352" num="0327">In at least one embodiment, the term &#x201c;registers&#x201d; may refer to on-board processor storage locations that may be used as part of instructions to identify operands. In at least one embodiment, registers may be those that may be usable from outside of a processor (from a programmer's perspective). In at least one embodiment, registers might not be limited to a particular type of circuit. Rather, in at least one embodiment, a register may store data, provide data, and perform functions described herein. In at least one embodiment, registers described herein may be implemented by circuitry within a processor using any number of different techniques, such as dedicated physical registers, dynamically allocated physical registers using register renaming, combinations of dedicated and dynamically allocated physical registers, etc. In at least one embodiment, integer registers store 32-bit integer data. A register file of at least one embodiment also contains eight multimedia SIMD registers for packed data.</p><p id="p-0353" num="0328">In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>24</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>24</b></figref> are utilized to perform API to generate one or more graph code nodes to deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>24</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate and deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>24</b></figref> are utilized to implement one or more systems and/or processes such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>10</b></figref>.</p><p id="p-0354" num="0329"><figref idref="DRAWINGS">FIG. <b>25</b></figref> illustrates a processor <b>2500</b>, in accordance with at least one embodiment. In at least one embodiment, processor <b>2500</b> includes, without limitation, one or more processor cores (&#x201c;cores&#x201d;) <b>2502</b>A-<b>2502</b>N, an integrated memory controller <b>2514</b>, and an integrated graphics processor <b>2508</b>. In at least one embodiment, processor <b>2500</b> can include additional cores up to and including additional processor core <b>2502</b>N represented by dashed lined boxes. In at least one embodiment, each of processor cores <b>2502</b>A-<b>2502</b>N includes one or more internal cache units <b>2504</b>A-<b>2504</b>N. In at least one embodiment, each processor core also has access to one or more shared cached units <b>2506</b>.</p><p id="p-0355" num="0330">In at least one embodiment, internal cache units <b>2504</b>A-<b>2504</b>N and shared cache units <b>2506</b> represent a cache memory hierarchy within processor <b>2500</b>. In at least one embodiment, cache memory units <b>2504</b>A-<b>2504</b>N may include at least one level of instruction and data cache within each processor core and one or more levels of shared mid-level cache, such as an L2, L3, Level 4 (&#x201c;L4&#x201d;), or other levels of cache, where a highest level of cache before external memory is classified as an LLC. In at least one embodiment, cache coherency logic maintains coherency between various cache units <b>2506</b> and <b>2504</b>A-<b>2504</b>N.</p><p id="p-0356" num="0331">In at least one embodiment, processor <b>2500</b> may also include a set of one or more bus controller units <b>2516</b> and a system agent core <b>2510</b>. In at least one embodiment, one or more bus controller units <b>2516</b> manage a set of peripheral buses, such as one or more PCI or PCI express buses. In at least one embodiment, system agent core <b>2510</b> provides management functionality for various processor components. In at least one embodiment, system agent core <b>2510</b> includes one or more integrated memory controllers <b>2514</b> to manage access to various external memory devices (not shown).</p><p id="p-0357" num="0332">In at least one embodiment, one or more of processor cores <b>2502</b>A-<b>2502</b>N include support for simultaneous multi-threading. In at least one embodiment, system agent core <b>2510</b> includes components for coordinating and operating processor cores <b>2502</b>A-<b>2502</b>N during multi-threaded processing. In at least one embodiment, system agent core <b>2510</b> may additionally include a power control unit (&#x201c;PCU&#x201d;), which includes logic and components to regulate one or more power states of processor cores <b>2502</b>A-<b>2502</b>N and graphics processor <b>2508</b>.</p><p id="p-0358" num="0333">In at least one embodiment, processor <b>2500</b> additionally includes graphics processor <b>2508</b> to execute graphics processing operations. In at least one embodiment, graphics processor <b>2508</b> couples with shared cache units <b>2506</b>, and system agent core <b>2510</b>, including one or more integrated memory controllers <b>2514</b>. In at least one embodiment, system agent core <b>2510</b> also includes a display controller <b>2511</b> to drive graphics processor output to one or more coupled displays. In at least one embodiment, display controller <b>2511</b> may also be a separate module coupled with graphics processor <b>2508</b> via at least one interconnect, or may be integrated within graphics processor <b>2508</b>.</p><p id="p-0359" num="0334">In at least one embodiment, a ring based interconnect unit <b>2512</b> is used to couple internal components of processor <b>2500</b>. In at least one embodiment, an alternative interconnect unit may be used, such as a point-to-point interconnect, a switched interconnect, or other techniques. In at least one embodiment, graphics processor <b>2508</b> couples with ring interconnect <b>2512</b> via an I/O link <b>2513</b>.</p><p id="p-0360" num="0335">In at least one embodiment, I/O link <b>2513</b> represents at least one of multiple varieties of I/O interconnects, including an on package I/O interconnect which facilitates communication between various processor components and a high-performance embedded memory module <b>2518</b>, such as an eDRAM module. In at least one embodiment, each of processor cores <b>2502</b>A-<b>2502</b>N and graphics processor <b>2508</b> use embedded memory modules <b>2518</b> as a shared LLC.</p><p id="p-0361" num="0336">In at least one embodiment, processor cores <b>2502</b>A-<b>2502</b>N are homogeneous cores executing a common instruction set architecture. In at least one embodiment, processor cores <b>2502</b>A-<b>2502</b>N are heterogeneous in terms of ISA, where one or more of processor cores <b>2502</b>A-<b>2502</b>N execute a common instruction set, while one or more other cores of processor cores <b>2502</b>A-<b>25</b>-<b>02</b>N executes a subset of a common instruction set or a different instruction set. In at least one embodiment, processor cores <b>2502</b>A-<b>2502</b>N are heterogeneous in terms of microarchitecture, where one or more cores having a relatively higher power consumption couple with one or more cores having a lower power consumption. In at least one embodiment, processor <b>2500</b> can be implemented on one or more chips or as an SoC integrated circuit.</p><p id="p-0362" num="0337">In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>25</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>25</b></figref> are utilized to perform API to generate one or more graph code nodes to deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>25</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate and deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>25</b></figref> are utilized to implement one or more systems and/or processes such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>10</b></figref>.</p><p id="p-0363" num="0338"><figref idref="DRAWINGS">FIG. <b>26</b></figref> illustrates a graphics processor core <b>2600</b>, in accordance with at least one embodiment described. In at least one embodiment, graphics processor core <b>2600</b> is included within a graphics core array. In at least one embodiment, graphics processor core <b>2600</b>, sometimes referred to as a core slice, can be one or multiple graphics cores within a modular graphics processor. In at least one embodiment, graphics processor core <b>2600</b> is exemplary of one graphics core slice, and a graphics processor as described herein may include multiple graphics core slices based on target power and performance envelopes. In at least one embodiment, each graphics core <b>2600</b> can include a fixed function block <b>2630</b> coupled with multiple sub-cores <b>2601</b>A-<b>2601</b>F, also referred to as sub-slices, that include modular blocks of general-purpose and fixed function logic.</p><p id="p-0364" num="0339">In at least one embodiment, fixed function block <b>2630</b> includes a geometry/fixed function pipeline <b>2636</b> that can be shared by all sub-cores in graphics processor <b>2600</b>, for example, in lower performance and/or lower power graphics processor implementations. In at least one embodiment, geometry/fixed function pipeline <b>2636</b> includes a 3D fixed function pipeline, a video front-end unit, a thread spawner and thread dispatcher, and a unified return buffer manager, which manages unified return buffers.</p><p id="p-0365" num="0340">In at least one embodiment, fixed function block <b>2630</b> also includes a graphics SoC interface <b>2637</b>, a graphics microcontroller <b>2638</b>, and a media pipeline <b>2639</b>. Graphics SoC interface <b>2637</b> provides an interface between graphics core <b>2600</b> and other processor cores within an SoC integrated circuit. In at least one embodiment, graphics microcontroller <b>2638</b> is a programmable sub-processor that is configurable to manage various functions of graphics processor <b>2600</b>, including thread dispatch, scheduling, and pre-emption. In at least one embodiment, media pipeline <b>2639</b> includes logic to facilitate decoding, encoding, pre-processing, and/or post-processing of multimedia data, including image and video data. In at least one embodiment, media pipeline <b>2639</b> implements media operations via requests to compute or sampling logic within sub-cores <b>2601</b>-<b>2601</b>F.</p><p id="p-0366" num="0341">In at least one embodiment, SoC interface <b>2637</b> enables graphics core <b>2600</b> to communicate with general-purpose application processor cores (e.g., CPUs) and/or other components within an SoC, including memory hierarchy elements such as a shared LLC memory, system RAM, and/or embedded on-chip or on-package DRAM. In at least one embodiment, SoC interface <b>2637</b> can also enable communication with fixed function devices within an SoC, such as camera imaging pipelines, and enables use of and/or implements global memory atomics that may be shared between graphics core <b>2600</b> and CPUs within an SoC. In at least one embodiment, SoC interface <b>2637</b> can also implement power management controls for graphics core <b>2600</b> and enable an interface between a clock domain of graphic core <b>2600</b> and other clock domains within an SoC. In at least one embodiment, SoC interface <b>2637</b> enables receipt of command buffers from a command streamer and global thread dispatcher that are configured to provide commands and instructions to each of one or more graphics cores within a graphics processor. In at least one embodiment, commands and instructions can be dispatched to media pipeline <b>2639</b>, when media operations are to be performed, or a geometry and fixed function pipeline (e.g., geometry and fixed function pipeline <b>2636</b>, geometry and fixed function pipeline <b>2614</b>) when graphics processing operations are to be performed.</p><p id="p-0367" num="0342">In at least one embodiment, graphics microcontroller <b>2638</b> can be configured to perform various scheduling and management tasks for graphics core <b>2600</b>. In at least one embodiment, graphics microcontroller <b>2638</b> can perform graphics and/or compute workload scheduling on various graphics parallel engines within execution unit (EU) arrays <b>2602</b>A-<b>2602</b>F, <b>2604</b>A-<b>2604</b>F within sub-cores <b>2601</b>A-<b>2601</b>F. In at least one embodiment, host software executing on a CPU core of an SoC including graphics core <b>2600</b> can submit workloads one of multiple graphic processor doorbells, which invokes a scheduling operation on an appropriate graphics engine. In at least one embodiment, scheduling operations include determining which workload to run next, submitting a workload to a command streamer, pre-empting existing workloads running on an engine, monitoring progress of a workload, and notifying host software when a workload is complete. In at least one embodiment, graphics microcontroller <b>2638</b> can also facilitate low-power or idle states for graphics core <b>2600</b>, providing graphics core <b>2600</b> with an ability to save and restore registers within graphics core <b>2600</b> across low-power state transitions independently from an operating system and/or graphics driver software on a system.</p><p id="p-0368" num="0343">In at least one embodiment, graphics core <b>2600</b> may have greater than or fewer than illustrated sub-cores <b>2601</b>A-<b>2601</b>F, up to N modular sub-cores. For each set of N sub-cores, in at least one embodiment, graphics core <b>2600</b> can also include shared function logic <b>2610</b>, shared and/or cache memory <b>2612</b>, a geometry/fixed function pipeline <b>2614</b>, as well as additional fixed function logic <b>2616</b> to accelerate various graphics and compute processing operations. In at least one embodiment, shared function logic <b>2610</b> can include logic units (e.g., sampler, math, and/or inter-thread communication logic) that can be shared by each N sub-cores within graphics core <b>2600</b>. Shared and/or cache memory <b>2612</b> can be an LLC for N sub-cores <b>2601</b>A-<b>2601</b>F within graphics core <b>2600</b> and can also serve as shared memory that is accessible by multiple sub-cores. In at least one embodiment, geometry/fixed function pipeline <b>2614</b> can be included instead of geometry/fixed function pipeline <b>2636</b> within fixed function block <b>2630</b> and can include same or similar logic units.</p><p id="p-0369" num="0344">In at least one embodiment, graphics core <b>2600</b> includes additional fixed function logic <b>2616</b> that can include various fixed function acceleration logic for use by graphics core <b>2600</b>. In at least one embodiment, additional fixed function logic <b>2616</b> includes an additional geometry pipeline for use in position only shading. In position-only shading, at least two geometry pipelines exist, whereas in a full geometry pipeline within geometry/fixed function pipeline <b>2616</b>, <b>2636</b>, and a cull pipeline, which is an additional geometry pipeline which may be included within additional fixed function logic <b>2616</b>. In at least one embodiment, cull pipeline is a trimmed down version of a full geometry pipeline. In at least one embodiment, a full pipeline and a cull pipeline can execute different instances of an application, each instance having a separate context. In at least one embodiment, position only shading can hide long cull runs of discarded triangles, enabling shading to be completed earlier in some instances. For example, in at least one embodiment, cull pipeline logic within additional fixed function logic <b>2616</b> can execute position shaders in parallel with a main application and generally generates critical results faster than a full pipeline, as a cull pipeline fetches and shades position attribute of vertices, without performing rasterization and rendering of pixels to a frame buffer. In at least one embodiment, a cull pipeline can use generated critical results to compute visibility information for all triangles without regard to whether those triangles are culled. In at least one embodiment, a full pipeline (which in this instance may be referred to as a replay pipeline) can consume visibility information to skip culled triangles to shade only visible triangles that are finally passed to a rasterization phase.</p><p id="p-0370" num="0345">In at least one embodiment, additional fixed function logic <b>2616</b> can also include general purpose processing acceleration logic, such as fixed function matrix multiplication logic, for accelerating CUDA programs.</p><p id="p-0371" num="0346">In at least one embodiment, each graphics sub-core <b>2601</b>A-<b>2601</b>F includes a set of execution resources that may be used to perform graphics, media, and compute operations in response to requests by graphics pipeline, media pipeline, or shader programs. In at least one embodiment, graphics sub-cores <b>2601</b>A-<b>2601</b>F include multiple EU arrays <b>2602</b>A-<b>2602</b>F, <b>2604</b>A-<b>2604</b>F, thread dispatch and inter-thread communication (&#x201c;TD/IC&#x201d;) logic <b>2603</b>A-<b>2603</b>F, a 3D (e.g., texture) sampler <b>2605</b>A-<b>2605</b>F, a media sampler <b>2606</b>A-<b>2606</b>F, a shader processor <b>2607</b>A-<b>2607</b>F, and shared local memory (&#x201c;SLM&#x201d;) <b>2608</b>A-<b>2608</b>F. EU arrays <b>2602</b>A-<b>2602</b>F, <b>2604</b>A-<b>2604</b>F each include multiple execution units, which are GPGPUs capable of performing floating-point and integer/fixed-point logic operations in service of a graphics, media, or compute operation, including graphics, media, or compute shader programs. In at least one embodiment, TD/IC logic <b>2603</b>A-<b>2603</b>F performs local thread dispatch and thread control operations for execution units within a sub-core and facilitate communication between threads executing on execution units of a sub-core. In at least one embodiment, 3D sampler <b>2605</b>A-<b>2605</b>F can read texture or other 3D graphics related data into memory. In at least one embodiment, 3D sampler can read texture data differently based on a configured sample state and texture format associated with a given texture. In at least one embodiment, media sampler <b>2606</b>A-<b>2606</b>F can perform similar read operations based on a type and format associated with media data. In at least one embodiment, each graphics sub-core <b>2601</b>A-<b>2601</b>F can alternately include a unified 3D and media sampler. In at least one embodiment, threads executing on execution units within each of sub-cores <b>2601</b>A-<b>2601</b>F can make use of shared local memory <b>2608</b>A-<b>2608</b>F within each sub-core, to enable threads executing within a thread group to execute using a common pool of on-chip memory.</p><p id="p-0372" num="0347">In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>26</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>26</b></figref> are utilized to perform API to generate one or more graph code nodes to deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>26</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate and deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>26</b></figref> are utilized to implement one or more systems and/or processes such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>10</b></figref>.</p><p id="p-0373" num="0348"><figref idref="DRAWINGS">FIG. <b>27</b></figref> illustrates a parallel processing unit (&#x201c;PPU&#x201d;) <b>2700</b>, in accordance with at least one embodiment. In at least one embodiment, PPU <b>2700</b> is configured with machine-readable code that, if executed by PPU <b>2700</b>, causes PPU <b>2700</b> to perform some or all of processes and techniques described herein. In at least one embodiment, PPU <b>2700</b> is a multi-threaded processor that is implemented on one or more integrated circuit devices and that utilizes multithreading as a latency-hiding technique designed to process computer-readable instructions (also referred to as machine-readable instructions or simply instructions) on multiple threads in parallel. In at least one embodiment, a thread refers to a thread of execution and is an instantiation of a set of instructions configured to be executed by PPU <b>2700</b>. In at least one embodiment, PPU <b>2700</b> is a GPU configured to implement a graphics rendering pipeline for processing three-dimensional (&#x201c;3D&#x201d;) graphics data in order to generate two-dimensional (&#x201c;2D&#x201d;) image data for display on a display device such as an LCD device. In at least one embodiment, PPU <b>2700</b> is utilized to perform computations such as linear algebra operations and machine-learning operations. <figref idref="DRAWINGS">FIG. <b>27</b></figref> illustrates an example parallel processor for illustrative purposes only and should be construed as a non-limiting example of a processor architecture that may be implemented in at least one embodiment.</p><p id="p-0374" num="0349">In at least one embodiment, one or more PPUs <b>2700</b> are configured to accelerate High Performance Computing (&#x201c;HPC&#x201d;), data center, and machine learning applications. In at least one embodiment, one or more PPUs <b>2700</b> are configured to accelerate CUDA programs. In at least one embodiment, PPU <b>2700</b> includes, without limitation, an I/O unit <b>2706</b>, a front-end unit <b>2710</b>, a scheduler unit <b>2712</b>, a work distribution unit <b>2714</b>, a hub <b>2716</b>, a crossbar (&#x201c;Xbar&#x201d;) <b>2720</b>, one or more general processing clusters (&#x201c;GPCs&#x201d;) <b>2718</b>, and one or more partition units (&#x201c;memory partition units&#x201d;) <b>2722</b>. In at least one embodiment, PPU <b>2700</b> is connected to a host processor or other PPUs <b>2700</b> via one or more high-speed GPU interconnects (&#x201c;GPU interconnects&#x201d;) <b>2708</b>. In at least one embodiment, PPU <b>2700</b> is connected to a host processor or other peripheral devices via a system bus or interconnect <b>2702</b>. In at least one embodiment, PPU <b>2700</b> is connected to a local memory comprising one or more memory devices (&#x201c;memory&#x201d;) <b>2704</b>. In at least one embodiment, memory devices <b>2704</b> include, without limitation, one or more dynamic random access memory (DRAM) devices. In at least one embodiment, one or more DRAM devices are configured and/or configurable as high-bandwidth memory (&#x201c;HBM&#x201d;) subsystems, with multiple DRAM dies stacked within each device.</p><p id="p-0375" num="0350">In at least one embodiment, high-speed GPU interconnect <b>2708</b> may refer to a wire-based multi-lane communications link that is used by systems to scale and include one or more PPUs <b>2700</b> combined with one or more CPUs, supports cache coherence between PPUs <b>2700</b> and CPUs, and CPU mastering. In at least one embodiment, data and/or commands are transmitted by high-speed GPU interconnect <b>2708</b> through hub <b>2716</b> to/from other units of PPU <b>2700</b> such as one or more copy engines, video encoders, video decoders, power management units, and other components which may not be explicitly illustrated in <figref idref="DRAWINGS">FIG. <b>27</b></figref>.</p><p id="p-0376" num="0351">In at least one embodiment, I/O unit <b>2706</b> is configured to transmit and receive communications (e.g., commands, data) from a host processor (not illustrated in <figref idref="DRAWINGS">FIG. <b>27</b></figref>) over system bus <b>2702</b>. In at least one embodiment, I/O unit <b>2706</b> communicates with host processor directly via system bus <b>2702</b> or through one or more intermediate devices such as a memory bridge. In at least one embodiment, I/O unit <b>2706</b> may communicate with one or more other processors, such as one or more of PPUs <b>2700</b> via system bus <b>2702</b>. In at least one embodiment, I/O unit <b>2706</b> implements a PCIe interface for communications over a PCIe bus. In at least one embodiment, I/O unit <b>2706</b> implements interfaces for communicating with external devices.</p><p id="p-0377" num="0352">In at least one embodiment, I/O unit <b>2706</b> decodes packets received via system bus <b>2702</b>. In at least one embodiment, at least some packets represent commands configured to cause PPU <b>2700</b> to perform various operations. In at least one embodiment, I/O unit <b>2706</b> transmits decoded commands to various other units of PPU <b>2700</b> as specified by commands. In at least one embodiment, commands are transmitted to front-end unit <b>2710</b> and/or transmitted to hub <b>2716</b> or other units of PPU <b>2700</b> such as one or more copy engines, a video encoder, a video decoder, a power management unit, etc. (not explicitly illustrated in <figref idref="DRAWINGS">FIG. <b>27</b></figref>). In at least one embodiment, I/O unit <b>2706</b> is configured to route communications between and among various logical units of PPU <b>2700</b>.</p><p id="p-0378" num="0353">In at least one embodiment, a program executed by host processor encodes a command stream in a buffer that provides workloads to PPU <b>2700</b> for processing. In at least one embodiment, a workload comprises instructions and data to be processed by those instructions. In at least one embodiment, buffer is a region in a memory that is accessible (e.g., read/write) by both a host processor and PPU <b>2700</b>&#x2014;a host interface unit may be configured to access buffer in a system memory connected to system bus <b>2702</b> via memory requests transmitted over system bus <b>2702</b> by I/O unit <b>2706</b>. In at least one embodiment, a host processor writes a command stream to a buffer and then transmits a pointer to the start of the command stream to PPU <b>2700</b> such that front-end unit <b>2710</b> receives pointers to one or more command streams and manages one or more command streams, reading commands from command streams and forwarding commands to various units of PPU <b>2700</b>.</p><p id="p-0379" num="0354">In at least one embodiment, front-end unit <b>2710</b> is coupled to scheduler unit <b>2712</b> that configures various GPCs <b>2718</b> to process tasks defined by one or more command streams. In at least one embodiment, scheduler unit <b>2712</b> is configured to track state information related to various tasks managed by scheduler unit <b>2712</b> where state information may indicate which of GPCs <b>2718</b> a task is assigned to, whether task is active or inactive, a priority level associated with task, and so forth. In at least one embodiment, scheduler unit <b>2712</b> manages execution of a plurality of tasks on one or more of GPCs <b>2718</b>.</p><p id="p-0380" num="0355">In at least one embodiment, scheduler unit <b>2712</b> is coupled to work distribution unit <b>2714</b> that is configured to dispatch tasks for execution on GPCs <b>2718</b>. In at least one embodiment, work distribution unit <b>2714</b> tracks a number of scheduled tasks received from scheduler unit <b>2712</b> and work distribution unit <b>2714</b> manages a pending task pool and an active task pool for each of GPCs <b>2718</b>. In at least one embodiment, pending task pool comprises a number of slots (e.g., 32 slots) that contain tasks assigned to be processed by a particular GPC <b>2718</b>; active task pool may comprise a number of slots (e.g., 4 slots) for tasks that are actively being processed by GPCs <b>2718</b> such that as one of GPCs <b>2718</b> completes execution of a task, that task is evicted from active task pool for GPC <b>2718</b> and one of other tasks from pending task pool is selected and scheduled for execution on GPC <b>2718</b>. In at least one embodiment, if an active task is idle on GPC <b>2718</b>, such as while waiting for a data dependency to be resolved, then the active task is evicted from GPC <b>2718</b> and returned to a pending task pool while another task in the pending task pool is selected and scheduled for execution on GPC <b>2718</b>.</p><p id="p-0381" num="0356">In at least one embodiment, work distribution unit <b>2714</b> communicates with one or more GPCs <b>2718</b> via XBar <b>2720</b>. In at least one embodiment, XBar <b>2720</b> is an interconnect network that couples many units of PPU <b>2700</b> to other units of PPU <b>2700</b> and can be configured to couple work distribution unit <b>2714</b> to a particular GPC <b>2718</b>. In at least one embodiment, one or more other units of PPU <b>2700</b> may also be connected to XBar <b>2720</b> via hub <b>2716</b>.</p><p id="p-0382" num="0357">In at least one embodiment, tasks are managed by scheduler unit <b>2712</b> and dispatched to one of GPCs <b>2718</b> by work distribution unit <b>2714</b>. GPC <b>2718</b> is configured to process task and generate results. In at least one embodiment, results may be consumed by other tasks within GPC <b>2718</b>, routed to a different GPC <b>2718</b> via XBar <b>2720</b>, or stored in memory <b>2704</b>. In at least one embodiment, results can be written to memory <b>2704</b> via partition units <b>2722</b>, which implement a memory interface for reading and writing data to/from memory <b>2704</b>. In at least one embodiment, results can be transmitted to another PPU <b>2704</b> or CPU via high-speed GPU interconnect <b>2708</b>. In at least one embodiment, PPU <b>2700</b> includes, without limitation, a number U of partition units <b>2722</b> that is equal to number of separate and distinct memory devices <b>2704</b> coupled to PPU <b>2700</b>.</p><p id="p-0383" num="0358">In at least one embodiment, a host processor executes a driver kernel that implements an application programming interface (&#x201c;API&#x201d;) that enables one or more applications executing on host processor to schedule operations for execution on PPU <b>2700</b>. In at least one embodiment, multiple compute applications are simultaneously executed by PPU <b>2700</b> and PPU <b>2700</b> provides isolation, quality of service (&#x201c;QoS&#x201d;), and independent address spaces for multiple compute applications. In at least one embodiment, an application generates instructions (e.g., in the form of API calls) that cause a driver kernel to generate one or more tasks for execution by PPU <b>2700</b> and the driver kernel outputs tasks to one or more streams being processed by PPU <b>2700</b>. In at least one embodiment, each task comprises one or more groups of related threads, which may be referred to as a warp. In at least one embodiment, a warp comprises a plurality of related threads (e.g., 32 threads) that can be executed in parallel. In at least one embodiment, cooperating threads can refer to a plurality of threads including instructions to perform a task and that exchange data through shared memory.</p><p id="p-0384" num="0359">In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>27</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>27</b></figref> are utilized to perform API to generate one or more graph code nodes to deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>27</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate and deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>27</b></figref> are utilized to implement one or more systems and/or processes such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>10</b></figref>.</p><p id="p-0385" num="0360"><figref idref="DRAWINGS">FIG. <b>28</b></figref> illustrates a GPC <b>2800</b>, in accordance with at least one embodiment. In at least one embodiment, GPC <b>2800</b> is GPC <b>2718</b> of <figref idref="DRAWINGS">FIG. <b>27</b></figref>. In at least one embodiment, each GPC <b>2800</b> includes, without limitation, a number of hardware units for processing tasks and each GPC <b>2800</b> includes, without limitation, a pipeline manager <b>2802</b>, a pre-raster operations unit (&#x201c;PROP&#x201d;) <b>2804</b>, a raster engine <b>2808</b>, a work distribution crossbar (&#x201c;WDX&#x201d;) <b>2816</b>, an MMU <b>2818</b>, one or more Data Processing Clusters (&#x201c;DPCs&#x201d;) <b>2806</b>, and any suitable combination of parts.</p><p id="p-0386" num="0361">In at least one embodiment, operation of GPC <b>2800</b> is controlled by pipeline manager <b>2802</b>. In at least one embodiment, pipeline manager <b>2802</b> manages configuration of one or more DPCs <b>2806</b> for processing tasks allocated to GPC <b>2800</b>. In at least one embodiment, pipeline manager <b>2802</b> configures at least one of one or more DPCs <b>2806</b> to implement at least a portion of a graphics rendering pipeline. In at least one embodiment, DPC <b>2806</b> is configured to execute a vertex shader program on a programmable streaming multiprocessor (&#x201c;SM&#x201d;) <b>2814</b>. In at least one embodiment, pipeline manager <b>2802</b> is configured to route packets received from a work distribution unit to appropriate logical units within GPC <b>2800</b> and, in at least one embodiment, some packets may be routed to fixed function hardware units in PROP <b>2804</b> and/or raster engine <b>2808</b> while other packets may be routed to DPCs <b>2806</b> for processing by a primitive engine <b>2812</b> or SM <b>2814</b>. In at least one embodiment, pipeline manager <b>2802</b> configures at least one of DPCs <b>2806</b> to implement a computing pipeline. In at least one embodiment, pipeline manager <b>2802</b> configures at least one of DPCs <b>2806</b> to execute at least a portion of a CUDA program.</p><p id="p-0387" num="0362">In at least one embodiment, PROP unit <b>2804</b> is configured to route data generated by raster engine <b>2808</b> and DPCs <b>2806</b> to a Raster Operations (&#x201c;ROP&#x201d;) unit in a partition unit, such as memory partition unit <b>2722</b> described in more detail above in conjunction with <figref idref="DRAWINGS">FIG. <b>27</b></figref>. In at least one embodiment, PROP unit <b>2804</b> is configured to perform optimizations for color blending, organize pixel data, perform address translations, and more. In at least one embodiment, raster engine <b>2808</b> includes, without limitation, a number of fixed function hardware units configured to perform various raster operations and, in at least one embodiment, raster engine <b>2808</b> includes, without limitation, a setup engine, a coarse raster engine, a culling engine, a clipping engine, a fine raster engine, a tile coalescing engine, and any suitable combination thereof. In at least one embodiment, a setup engine receives transformed vertices and generates plane equations associated with geometric primitive defined by vertices; plane equations are transmitted to a coarse raster engine to generate coverage information (e.g., an x, y coverage mask for a tile) for a primitive; the output of the coarse raster engine is transmitted to a culling engine where fragments associated with a primitive that fail a z-test are culled, and transmitted to a clipping engine where fragments lying outside a viewing frustum are clipped. In at least one embodiment, fragments that survive clipping and culling are passed to a fine raster engine to generate attributes for pixel fragments based on plane equations generated by a setup engine. In at least one embodiment, the output of raster engine <b>2808</b> comprises fragments to be processed by any suitable entity such as by a fragment shader implemented within DPC <b>2806</b>.</p><p id="p-0388" num="0363">In at least one embodiment, each DPC <b>2806</b> included in GPC <b>2800</b> comprise, without limitation, an M-Pipe Controller (&#x201c;MPC&#x201d;) <b>2810</b>; primitive engine <b>2812</b>; one or more SMs <b>2814</b>; and any suitable combination thereof. In at least one embodiment, MPC <b>2810</b> controls operation of DPC <b>2806</b>, routing packets received from pipeline manager <b>2802</b> to appropriate units in DPC <b>2806</b>. In at least one embodiment, packets associated with a vertex are routed to primitive engine <b>2812</b>, which is configured to fetch vertex attributes associated with vertex from memory; in contrast, packets associated with a shader program may be transmitted to SM <b>2814</b>.</p><p id="p-0389" num="0364">In at least one embodiment, SM <b>2814</b> comprises, without limitation, a programmable streaming processor that is configured to process tasks represented by a number of threads. In at least one embodiment, SM <b>2814</b> is multi-threaded and configured to execute a plurality of threads (e.g., 32 threads) from a particular group of threads concurrently and implements a SIMD architecture where each thread in a group of threads (e.g., a warp) is configured to process a different set of data based on same set of instructions. In at least one embodiment, all threads in group of threads execute same instructions. In at least one embodiment, SM <b>2814</b> implements a SIMT architecture wherein each thread in a group of threads is configured to process a different set of data based on same set of instructions, but where individual threads in group of threads are allowed to diverge during execution. In at least one embodiment, a program counter, a call stack, and an execution state is maintained for each warp, enabling concurrency between warps and serial execution within warps when threads within a warp diverge. In another embodiment, a program counter, a call stack, and an execution state is maintained for each individual thread, enabling equal concurrency between all threads, within and between warps. In at least one embodiment, an execution state is maintained for each individual thread and threads executing the same instructions may be converged and executed in parallel for better efficiency. At least one embodiment of SM <b>2814</b> is described in more detail in conjunction with <figref idref="DRAWINGS">FIG. <b>29</b></figref>.</p><p id="p-0390" num="0365">In at least one embodiment, MMU <b>2818</b> provides an interface between GPC <b>2800</b> and a memory partition unit (e.g., partition unit <b>2722</b> of <figref idref="DRAWINGS">FIG. <b>27</b></figref>) and MMU <b>2818</b> provides translation of virtual addresses into physical addresses, memory protection, and arbitration of memory requests. In at least one embodiment, MMU <b>2818</b> provides one or more translation lookaside buffers (TLBs) for performing translation of virtual addresses into physical addresses in memory.</p><p id="p-0391" num="0366">In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>28</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>28</b></figref> are utilized to perform API to generate one or more graph code nodes to deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>28</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate and deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>28</b></figref> are utilized to implement one or more systems and/or processes such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>10</b></figref>.</p><p id="p-0392" num="0367"><figref idref="DRAWINGS">FIG. <b>29</b></figref> illustrates a streaming multiprocessor (&#x201c;SM&#x201d;) <b>2900</b>, in accordance with at least one embodiment. In at least one embodiment, SM <b>2900</b> is SM <b>2814</b> of <figref idref="DRAWINGS">FIG. <b>28</b></figref>. In at least one embodiment, SM <b>2900</b> includes, without limitation, an instruction cache <b>2902</b>; one or more scheduler units <b>2904</b>; a register file <b>2908</b>; one or more processing cores (&#x201c;cores&#x201d;) <b>2910</b>; one or more special function units (&#x201c;SFUs&#x201d;) <b>2912</b>; one or more LSUs <b>2914</b>; an interconnect network <b>2916</b>; a shared memory/L1 cache <b>2918</b>; and any suitable combination thereof. In at least one embodiment, a work distribution unit dispatches tasks for execution on GPCs of parallel processing units (PPUs) and each task is allocated to a particular Data Processing Cluster (DPC) within a GPC and, if a task is associated with a shader program, then the task is allocated to one of SMs <b>2900</b>. In at least one embodiment, scheduler unit <b>2904</b> receives tasks from a work distribution unit and manages instruction scheduling for one or more thread blocks assigned to SM <b>2900</b>. In at least one embodiment, scheduler unit <b>2904</b> schedules thread blocks for execution as warps of parallel threads, wherein each thread block is allocated at least one warp. In at least one embodiment, each warp executes threads. In at least one embodiment, scheduler unit <b>2904</b> manages a plurality of different thread blocks, allocating warps to different thread blocks and then dispatching instructions from a plurality of different cooperative groups to various functional units (e.g., processing cores <b>2910</b>, SFUs <b>2912</b>, and LSUs <b>2914</b>) during each clock cycle.</p><p id="p-0393" num="0368">In at least one embodiment, &#x201c;cooperative groups&#x201d; may refer to a programming model for organizing groups of communicating threads that allows developers to express granularity at which threads are communicating, enabling expression of richer, more efficient parallel decompositions. In at least one embodiment, cooperative launch APIs support synchronization amongst thread blocks for execution of parallel algorithms. In at least one embodiment, APIs of conventional programming models provide a single, simple construct for synchronizing cooperating threads: a barrier across all threads of a thread block (e.g., syncthreads( ) function). However, in at least one embodiment, programmers may define groups of threads at smaller than thread block granularities and synchronize within defined groups to enable greater performance, design flexibility, and software reuse in the form of collective group-wide function interfaces. In at least one embodiment, cooperative groups enable programmers to define groups of threads explicitly at sub-block and multi-block granularities, and to perform collective operations such as synchronization on threads in a cooperative group. In at least one embodiment, a sub-block granularity is as small as a single thread. In at least one embodiment, a programming model supports clean composition across software boundaries, so that libraries and utility functions can synchronize safely within their local context without having to make assumptions about convergence. In at least one embodiment, cooperative group primitives enable new patterns of cooperative parallelism, including, without limitation, producer-consumer parallelism, opportunistic parallelism, and global synchronization across an entire grid of thread blocks.</p><p id="p-0394" num="0369">In at least one embodiment, a dispatch unit <b>2906</b> is configured to transmit instructions to one or more of functional units and scheduler unit <b>2904</b> includes, without limitation, two dispatch units <b>2906</b> that enable two different instructions from same warp to be dispatched during each clock cycle. In at least one embodiment, each scheduler unit <b>2904</b> includes a single dispatch unit <b>2906</b> or additional dispatch units <b>2906</b>.</p><p id="p-0395" num="0370">In at least one embodiment, each SM <b>2900</b>, in at least one embodiment, includes, without limitation, register file <b>2908</b> that provides a set of registers for functional units of SM <b>2900</b>. In at least one embodiment, register file <b>2908</b> is divided between each of the functional units such that each functional unit is allocated a dedicated portion of register file <b>2908</b>. In at least one embodiment, register file <b>2908</b> is divided between different warps being executed by SM <b>2900</b> and register file <b>2908</b> provides temporary storage for operands connected to data paths of functional units. In at least one embodiment, each SM <b>2900</b> comprises, without limitation, a plurality of L processing cores <b>2910</b>. In at least one embodiment, SM <b>2900</b> includes, without limitation, a large number (e.g., 128 or more) of distinct processing cores <b>2910</b>. In at least one embodiment, each processing core <b>2910</b> includes, without limitation, a fully-pipelined, single-precision, double-precision, and/or mixed precision processing unit that includes, without limitation, a floating point arithmetic logic unit and an integer arithmetic logic unit. In at least one embodiment, floating point arithmetic logic units implement IEEE 754-2008 standard for floating point arithmetic. In at least one embodiment, processing cores <b>2910</b> include, without limitation, 64 single-precision (32-bit) floating point cores, 64 integer cores, 32 double-precision (64-bit) floating point cores, and 8 tensor cores.</p><p id="p-0396" num="0371">In at least one embodiment, tensor cores are configured to perform matrix operations. In at least one embodiment, one or more tensor cores are included in processing cores <b>2910</b>. In at least one embodiment, tensor cores are configured to perform deep learning matrix arithmetic, such as convolution operations for neural network training and inferencing. In at least one embodiment, each tensor core operates on a 4&#xd7;4 matrix and performs a matrix multiply and accumulate operation D=A&#xd7;B+C, where A, B, C, and D are 4&#xd7;4 matrices.</p><p id="p-0397" num="0372">In at least one embodiment, matrix multiply inputs A and B are 16-bit floating point matrices and accumulation matrices C and D are16-bit floating point or 32-bit floating point matrices. In at least one embodiment, tensor cores operate on 16-bit floating point input data with 32-bit floating point accumulation. In at least one embodiment, 16-bit floating point multiply uses 64 operations and results in a full precision product that is then accumulated using 32-bit floating point addition with other intermediate products for a 4&#xd7;4&#xd7;4 matrix multiply. Tensor cores are used to perform much larger two-dimensional or higher dimensional matrix operations, built up from these smaller elements, in at least one embodiment. In at least one embodiment, an API, such as a CUDA-C++ API, exposes specialized matrix load, matrix multiply and accumulate, and matrix store operations to efficiently use tensor cores from a CUDA-C++ program. In at least one embodiment, at the CUDA level, a warp-level interface assumes 16&#xd7;16 size matrices spanning all 32 threads of a warp.</p><p id="p-0398" num="0373">In at least one embodiment, each SM <b>2900</b> comprises, without limitation, M SFU <b>2912</b> that perform special functions (e.g., attribute evaluation, reciprocal square root, and like). In at least one embodiment, SFUs <b>2912</b> include, without limitation, a tree traversal unit configured to traverse a hierarchical tree data structure. In at least one embodiment, SFUs <b>2912</b> include, without limitation, a texture unit configured to perform texture map filtering operations. In at least one embodiment, texture units are configured to load texture maps (e.g., a 2D array of texels) from memory and sample texture maps to produce sampled texture values for use in shader programs executed by SM <b>2900</b>. In at least one embodiment, texture maps are stored in shared memory/L1 cache <b>2918</b>. In at least one embodiment, texture units implement texture operations such as filtering operations using mip-maps (e.g., texture maps of varying levels of detail). In at least one embodiment, each SM <b>2900</b> includes, without limitation, two texture units.</p><p id="p-0399" num="0374">In at least one embodiment, each SM <b>2900</b> comprises, without limitation, N LSUs <b>2914</b> that implement load and store operations between shared memory/L1 cache <b>2918</b> and register file <b>2908</b>. In at least one embodiment, each SM <b>2900</b> includes, without limitation, interconnect network <b>2916</b> that connects each of the functional units to register file <b>2908</b> and LSU <b>2914</b> to register file <b>2908</b> and shared memory/L1 cache <b>2918</b>. In at least one embodiment, interconnect network <b>2916</b> is a crossbar that can be configured to connect any of the functional units to any of the registers in register file <b>2908</b> and connect LSUs <b>2914</b> to register file <b>2908</b> and memory locations in shared memory/L1 cache <b>2918</b>.</p><p id="p-0400" num="0375">In at least one embodiment, shared memory/L1 cache <b>2918</b> is an array of on-chip memory that allows for data storage and communication between SM <b>2900</b> and a primitive engine and between threads in SM <b>2900</b>. In at least one embodiment, shared memory/L1 cache <b>2918</b> comprises, without limitation, 128 KB of storage capacity and is in a path from SM <b>2900</b> to a partition unit. In at least one embodiment, shared memory/L1 cache <b>2918</b> is used to cache reads and writes. In at least one embodiment, one or more of shared memory/L1 cache <b>2918</b>, L2 cache, and memory are backing stores.</p><p id="p-0401" num="0376">In at least one embodiment, combining data cache and shared memory functionality into a single memory block provides improved performance for both types of memory accesses. In at least one embodiment, capacity is used or is usable as a cache by programs that do not use shared memory, such as if shared memory is configured to use half of capacity, texture and load/store operations can use remaining capacity. In at least one embodiment, integration within shared memory/L1 cache <b>2918</b> enables shared memory/L1 cache <b>2918</b> to function as a high-throughput conduit for streaming data while simultaneously providing high-bandwidth and low-latency access to frequently reused data. In at least one embodiment, when configured for general purpose parallel computation, a simpler configuration can be used compared with graphics processing. In at least one embodiment, fixed function GPUs are bypassed, creating a much simpler programming model. In at least one embodiment and in a general purpose parallel computation configuration, a work distribution unit assigns and distributes blocks of threads directly to DPCs. In at least one embodiment, threads in a block execute the same program, using a unique thread ID in a calculation to ensure each thread generates unique results, using SM <b>2900</b> to execute a program and perform calculations, shared memory/L1 cache <b>2918</b> to communicate between threads, and LSU <b>2914</b> to read and write global memory through shared memory/L1 cache <b>2918</b> and a memory partition unit. In at least one embodiment, when configured for general purpose parallel computation, SM <b>2900</b> writes commands that scheduler unit <b>2904</b> can use to launch new work on DPCs.</p><p id="p-0402" num="0377">In at least one embodiment, PPU is included in or coupled to a desktop computer, a laptop computer, a tablet computer, servers, supercomputers, a smart-phone (e.g., a wireless, hand-held device), a PDA, a digital camera, a vehicle, a head mounted display, a hand-held electronic device, and more. In at least one embodiment, PPU is embodied on a single semiconductor substrate. In at least one embodiment, PPU is included in an SoC along with one or more other devices such as additional PPUs, memory, a RISC CPU, an MMU, a digital-to-analog converter (&#x201c;DAC&#x201d;), and like.</p><p id="p-0403" num="0378">In at least one embodiment, PPU may be included on a graphics card that includes one or more memory devices. In at least one embodiment, a graphics card may be configured to interface with a PCIe slot on a motherboard of a desktop computer. In at least one embodiment, PPU may be an integrated GPU (&#x201c;iGPU&#x201d;) included in chipset of motherboard.</p><p id="p-0404" num="0379">In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>29</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>29</b></figref> are utilized to perform API to generate one or more graph code nodes to deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>29</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate and deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>29</b></figref> are utilized to implement one or more systems and/or processes such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>10</b></figref>.</p><heading id="h-0009" level="1">Software Constructions for General-Purpose Computing</heading><p id="p-0405" num="0380">The following figures set forth, without limitation, exemplary software constructs for implementing at least one embodiment.</p><p id="p-0406" num="0381"><figref idref="DRAWINGS">FIG. <b>30</b></figref> illustrates a software stack of a programming platform, in accordance with at least one embodiment. In at least one embodiment, a programming platform is a platform for leveraging hardware on a computing system to accelerate computational tasks. A programming platform may be accessible to software developers through libraries, compiler directives, and/or extensions to programming languages, in at least one embodiment. In at least one embodiment, a programming platform may be, but is not limited to, CUDA, Radeon Open Compute Platform (&#x201c;ROCm&#x201d;), OpenCL (OpenCL&#x2122; is developed by Khronos group), SYCL, or Intel One API.</p><p id="p-0407" num="0382">In at least one embodiment, a software stack <b>3000</b> of a programming platform provides an execution environment for an application <b>3001</b>. In at least one embodiment, application <b>3001</b> may include any computer software capable of being launched on software stack <b>3000</b>. In at least one embodiment, application <b>3001</b> may include, but is not limited to, an artificial intelligence (&#x201c;AI&#x201d;)/machine learning (&#x201c;ML&#x201d;) application, a high performance computing (&#x201c;HPC&#x201d;) application, a virtual desktop infrastructure (&#x201c;VDI&#x201d;), or a data center workload.</p><p id="p-0408" num="0383">In at least one embodiment, application <b>3001</b> and software stack <b>3000</b> run on hardware <b>3007</b>. Hardware <b>3007</b> may include one or more GPUs, CPUs, FPGAs, AI engines, and/or other types of compute devices that support a programming platform, in at least one embodiment. In at least one embodiment, such as with CUDA, software stack <b>3000</b> may be vendor specific and compatible with only devices from particular vendor(s). In at least one embodiment, such as in with OpenCL, software stack <b>3000</b> may be used with devices from different vendors. In at least one embodiment, hardware <b>3007</b> includes a host connected to one more devices that can be accessed to perform computational tasks via application programming interface (&#x201c;API&#x201d;) calls. A device within hardware <b>3007</b> may include, but is not limited to, a GPU, FPGA, AI engine, or other compute device (but may also include a CPU) and its memory, as opposed to a host within hardware <b>3007</b> that may include, but is not limited to, a CPU (but may also include a compute device) and its memory, in at least one embodiment.</p><p id="p-0409" num="0384">In at least one embodiment, software stack <b>3000</b> of a programming platform includes, without limitation, a number of libraries <b>3003</b>, a runtime <b>3005</b>, and a device kernel driver <b>3006</b>. Each of libraries <b>3003</b> may include data and programming code that can be used by computer programs and leveraged during software development, in at least one embodiment. In at least one embodiment, libraries <b>3003</b> may include, but are not limited to, pre-written code and subroutines, classes, values, type specifications, configuration data, documentation, help data, and/or message templates. In at least one embodiment, libraries <b>3003</b> include functions that are optimized for execution on one or more types of devices. In at least one embodiment, libraries <b>3003</b> may include, but are not limited to, functions for performing mathematical, deep learning, and/or other types of operations on devices. In at least one embodiment, libraries <b>3003</b> are associated with corresponding APIs <b>3002</b>, which may include one or more APIs, that expose functions implemented in libraries <b>3003</b>.</p><p id="p-0410" num="0385">In at least one embodiment, application <b>3001</b> is written as source code that is compiled into executable code, as discussed in greater detail below in conjunction with <figref idref="DRAWINGS">FIGS. <b>35</b>-<b>37</b></figref>. Executable code of application <b>3001</b> may run, at least in part, on an execution environment provided by software stack <b>3000</b>, in at least one embodiment. In at least one embodiment, during execution of application <b>3001</b>, code may be reached that needs to run on a device, as opposed to a host. In such a case, runtime <b>3005</b> may be called to load and launch requisite code on the device, in at least one embodiment. In at least one embodiment, runtime <b>3005</b> may include any technically feasible runtime system that is able to support execution of application S01.</p><p id="p-0411" num="0386">In at least one embodiment, runtime <b>3005</b> is implemented as one or more runtime libraries associated with corresponding APIs, which are shown as API(s) <b>3004</b>. One or more of such runtime libraries may include, without limitation, functions for memory management, execution control, device management, error handling, and/or synchronization, among other things, in at least one embodiment. In at least one embodiment, memory management functions may include, but are not limited to, functions to allocate, deallocate, and copy device memory, as well as transfer data between host memory and device memory. In at least one embodiment, execution control functions may include, but are not limited to, functions to launch a function (sometimes referred to as a &#x201c;kernel&#x201d; when a function is a global function callable from a host) on a device and set attribute values in a buffer maintained by a runtime library for a given function to be executed on a device.</p><p id="p-0412" num="0387">Runtime libraries and corresponding API(s) <b>3004</b> may be implemented in any technically feasible manner, in at least one embodiment. In at least one embodiment, one (or any number of) API may expose a low-level set of functions for fine-grained control of a device, while another (or any number of) API may expose a higher-level set of such functions. In at least one embodiment, a high-level runtime API may be built on top of a low-level API. In at least one embodiment, one or more of runtime APIs may be language-specific APIs that are layered on top of a language-independent runtime API.</p><p id="p-0413" num="0388">In at least one embodiment, device kernel driver <b>3006</b> is configured to facilitate communication with an underlying device. In at least one embodiment, device kernel driver <b>3006</b> may provide low-level functionalities upon which APIs, such as API(s) <b>3004</b>, and/or other software relies. In at least one embodiment, device kernel driver <b>3006</b> may be configured to compile intermediate representation (&#x201c;IR&#x201d;) code into binary code at runtime. For CUDA, device kernel driver <b>3006</b> may compile Parallel Thread Execution (&#x201c;PTX&#x201d;) IR code that is not hardware specific into binary code for a specific target device at runtime (with caching of compiled binary code), which is also sometimes referred to as &#x201c;finalizing&#x201d; code, in at least one embodiment. Doing so may permit finalized code to run on a target device, which may not have existed when source code was originally compiled into PTX code, in at least one embodiment. Alternatively, in at least one embodiment, device source code may be compiled into binary code offline, without requiring device kernel driver <b>3006</b> to compile IR code at runtime.</p><p id="p-0414" num="0389">In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>30</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>30</b></figref> are utilized to perform API to generate one or more graph code nodes to deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>30</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate and deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>30</b></figref> are utilized to implement one or more systems and/or processes such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>10</b></figref>.</p><p id="p-0415" num="0390"><figref idref="DRAWINGS">FIG. <b>31</b></figref> illustrates a CUDA implementation of software stack <b>3000</b> of <figref idref="DRAWINGS">FIG. <b>30</b></figref>, in accordance with at least one embodiment. In at least one embodiment, a CUDA software stack <b>3100</b>, on which an application <b>3101</b> may be launched, includes CUDA libraries <b>3103</b>, a CUDA runtime <b>3105</b>, a CUDA driver <b>3107</b>, and a device kernel driver <b>3108</b>. In at least one embodiment, CUDA software stack <b>3100</b> executes on hardware <b>3109</b>, which may include a GPU that supports CUDA and is developed by NVIDIA Corporation of Santa Clara, Calif.</p><p id="p-0416" num="0391">In at least one embodiment, application <b>3101</b>, CUDA runtime <b>3105</b>, and device kernel driver <b>3108</b> may perform similar functionalities as application <b>3001</b>, runtime <b>3005</b>, and device kernel driver <b>3006</b>, respectively, which are described above in conjunction with <figref idref="DRAWINGS">FIG. <b>30</b></figref>. In at least one embodiment, CUDA driver <b>3107</b> includes a library (libcuda.so) that implements a CUDA driver API <b>3106</b>. Similar to a CUDA runtime API <b>3104</b> implemented by a CUDA runtime library (cudart), CUDA driver API <b>3106</b> may, without limitation, expose functions for memory management, execution control, device management, error handling, synchronization, and/or graphics interoperability, among other things, in at least one embodiment. In at least one embodiment, CUDA driver API <b>3106</b> differs from CUDA runtime API <b>3104</b> in that CUDA runtime API <b>3104</b> simplifies device code management by providing implicit initialization, context (analogous to a process) management, and module (analogous to dynamically loaded libraries) management. In contrast to high-level CUDA runtime API <b>3104</b>, CUDA driver API <b>3106</b> is a low-level API providing more fine-grained control of the device, particularly with respect to contexts and module loading, in at least one embodiment. In at least one embodiment, CUDA driver API <b>3106</b> may expose functions for context management that are not exposed by CUDA runtime API <b>3104</b>. In at least one embodiment, CUDA driver API <b>3106</b> is also language-independent and supports, e.g., OpenCL in addition to CUDA runtime API <b>3104</b>. Further, in at least one embodiment, development libraries, including CUDA runtime <b>3105</b>, may be considered as separate from driver components, including user-mode CUDA driver <b>3107</b> and kernel-mode device driver <b>3108</b> (also sometimes referred to as a &#x201c;display&#x201d; driver).</p><p id="p-0417" num="0392">In at least one embodiment, CUDA libraries <b>3103</b> may include, but are not limited to, mathematical libraries, deep learning libraries, parallel algorithm libraries, and/or signal/image/video processing libraries, which parallel computing applications such as application <b>3101</b> may utilize. In at least one embodiment, CUDA libraries <b>3103</b> may include mathematical libraries such as a cuBLAS library that is an implementation of Basic Linear Algebra Subprograms (&#x201c;BLAS&#x201d;) for performing linear algebra operations, a cuFFT library for computing fast Fourier transforms (&#x201c;FFTs&#x201d;), and a cuRAND library for generating random numbers, among others. In at least one embodiment, CUDA libraries <b>3103</b> may include deep learning libraries such as a cuDNN library of primitives for deep neural networks and a TensorRT platform for high-performance deep learning inference, among others.</p><p id="p-0418" num="0393">In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>31</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>31</b></figref> are utilized to perform API to generate one or more graph code nodes to deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>31</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate and deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>31</b></figref> are utilized to implement one or more systems and/or processes such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>10</b></figref>.</p><p id="p-0419" num="0394"><figref idref="DRAWINGS">FIG. <b>32</b></figref> illustrates a ROCm implementation of software stack <b>3000</b> of <figref idref="DRAWINGS">FIG. <b>30</b></figref>, in accordance with at least one embodiment. In at least one embodiment, a ROCm software stack <b>3200</b>, on which an application <b>3201</b> may be launched, includes a language runtime <b>3203</b>, a system runtime <b>3205</b>, a thunk <b>3207</b>, and a ROCm kernel driver <b>3208</b>. In at least one embodiment, ROCm software stack <b>3200</b> executes on hardware <b>3209</b>, which may include a GPU that supports ROCm and is developed by AMD Corporation of Santa Clara, Calif.</p><p id="p-0420" num="0395">In at least one embodiment, application <b>3201</b> may perform similar functionalities as application <b>3001</b> discussed above in conjunction with <figref idref="DRAWINGS">FIG. <b>30</b></figref>. In addition, language runtime <b>3203</b> and system runtime <b>3205</b> may perform similar functionalities as runtime <b>3005</b> discussed above in conjunction with <figref idref="DRAWINGS">FIG. <b>30</b></figref>, in at least one embodiment. In at least one embodiment, language runtime <b>3203</b> and system runtime <b>3205</b> differ in that system runtime <b>3205</b> is a language-independent runtime that implements a ROCr system runtime API <b>3204</b> and makes use of a Heterogeneous System Architecture (&#x201c;HSA&#x201d;) Runtime API. HSA runtime API is a thin, user-mode API that exposes interfaces to access and interact with an AMD GPU, including functions for memory management, execution control via architected dispatch of kernels, error handling, system and agent information, and runtime initialization and shutdown, among other things, in at least one embodiment. In contrast to system runtime <b>3205</b>, language runtime <b>3203</b> is an implementation of a language-specific runtime API <b>3202</b> layered on top of ROCr system runtime API <b>3204</b>, in at least one embodiment. In at least one embodiment, language runtime API may include, but is not limited to, a Heterogeneous compute Interface for Portability (&#x201c;HIP&#x201d;) language runtime API, a Heterogeneous Compute Compiler (&#x201c;HCC&#x201d;) language runtime API, or an OpenCL API, among others. HIP language in particular is an extension of C++ programming language with functionally similar versions of CUDA mechanisms, and, in at least one embodiment, a HIP language runtime API includes functions that are similar to those of CUDA runtime API <b>3104</b> discussed above in conjunction with <figref idref="DRAWINGS">FIG. <b>31</b></figref>, such as functions for memory management, execution control, device management, error handling, and synchronization, among other things.</p><p id="p-0421" num="0396">In at least one embodiment, thunk (ROCt) <b>3207</b> is an interface <b>3206</b> that can be used to interact with underlying ROCm driver <b>3208</b>. In at least one embodiment, ROCm driver <b>3208</b> is a ROCk driver, which is a combination of an AMDGPU driver and a HSA kernel driver (amdkfd). In at least one embodiment, AMDGPU driver is a device kernel driver for GPUs developed by AMD that performs similar functionalities as device kernel driver <b>3006</b> discussed above in conjunction with <figref idref="DRAWINGS">FIG. <b>30</b></figref>. In at least one embodiment, HSA kernel driver is a driver permitting different types of processors to share system resources more effectively via hardware features.</p><p id="p-0422" num="0397">In at least one embodiment, various libraries (not shown) may be included in ROCm software stack <b>3200</b> above language runtime <b>3203</b> and provide functionality similarity to CUDA libraries <b>3103</b>, discussed above in conjunction with <figref idref="DRAWINGS">FIG. <b>31</b></figref>. In at least one embodiment, various libraries may include, but are not limited to, mathematical, deep learning, and/or other libraries such as a hipBLAS library that implements functions similar to those of CUDA cuBLAS, a rocFFT library for computing FFTs that is similar to CUDA cuFFT, among others.</p><p id="p-0423" num="0398">In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>32</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>32</b></figref> are utilized to perform API to generate one or more graph code nodes to deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>32</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate and deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>32</b></figref> are utilized to implement one or more systems and/or processes such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>10</b></figref>.</p><p id="p-0424" num="0399"><figref idref="DRAWINGS">FIG. <b>33</b></figref> illustrates an OpenCL implementation of software stack <b>3000</b> of <figref idref="DRAWINGS">FIG. <b>30</b></figref>, in accordance with at least one embodiment. In at least one embodiment, an OpenCL software stack <b>3300</b>, on which an application <b>3301</b> may be launched, includes an OpenCL framework <b>3310</b>, an OpenCL runtime <b>3306</b>, and a driver <b>3307</b>. In at least one embodiment, OpenCL software stack <b>3300</b> executes on hardware <b>3109</b> that is not vendor-specific. As OpenCL is supported by devices developed by different vendors, specific OpenCL drivers may be required to interoperate with hardware from such vendors, in at least one embodiment.</p><p id="p-0425" num="0400">In at least one embodiment, application <b>3301</b>, OpenCL runtime <b>3306</b>, device kernel driver <b>3307</b>, and hardware <b>3308</b> may perform similar functionalities as application <b>3001</b>, runtime <b>3005</b>, device kernel driver <b>3006</b>, and hardware <b>3007</b>, respectively, that are discussed above in conjunction with <figref idref="DRAWINGS">FIG. <b>30</b></figref>. In at least one embodiment, application <b>3301</b> further includes an OpenCL kernel <b>3302</b> with code that is to be executed on a device.</p><p id="p-0426" num="0401">In at least one embodiment, OpenCL defines a &#x201c;platform&#x201d; that allows a host to control devices connected to the host. In at least one embodiment, an OpenCL framework provides a platform layer API and a runtime API, shown as platform API <b>3303</b> and runtime API <b>3305</b>. In at least one embodiment, runtime API <b>3305</b> uses contexts to manage execution of kernels on devices. In at least one embodiment, each identified device may be associated with a respective context, which runtime API <b>3305</b> may use to manage command queues, program objects, and kernel objects, share memory objects, among other things, for that device. In at least one embodiment, platform API <b>3303</b> exposes functions that permit device contexts to be used to select and initialize devices, submit work to devices via command queues, and enable data transfer to and from devices, among other things. In addition, OpenCL framework provides various built-in functions (not shown), including math functions, relational functions, and image processing functions, among others, in at least one embodiment.</p><p id="p-0427" num="0402">In at least one embodiment, a compiler <b>3304</b> is also included in OpenCL frame-work <b>3310</b>. Source code may be compiled offline prior to executing an application or online during execution of an application, in at least one embodiment. In contrast to CUDA and ROCm, OpenCL applications in at least one embodiment may be compiled online by compiler <b>3304</b>, which is included to be representative of any number of compilers that may be used to compile source code and/or IR code, such as Standard Portable Intermediate Representation (&#x201c;SPIR-V&#x201d;) code, into binary code. Alternatively, in at least one embodiment, OpenCL ap-plications may be compiled offline, prior to execution of such applications.</p><p id="p-0428" num="0403">In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>33</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>33</b></figref> are utilized to perform API to generate one or more graph code nodes to deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>33</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate and deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>33</b></figref> are utilized to implement one or more systems and/or processes such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>10</b></figref>.</p><p id="p-0429" num="0404"><figref idref="DRAWINGS">FIG. <b>34</b></figref> illustrates software that is supported by a programming platform, in accordance with at least one embodiment. In at least one embodiment, a programming platform <b>3404</b> is configured to support various programming models <b>3403</b>, middlewares and/or libraries <b>3402</b>, and frameworks <b>3401</b> that an application <b>3400</b> may rely upon. In at least one embodiment, application <b>3400</b> may be an AI/ML application implemented using, for example, a deep learning framework such as MXNet, PyTorch, or TensorFlow, which may rely on libraries such as cuDNN, NVIDIA Collective Communications Library (&#x201c;NCCL&#x201d;), and/or NVIDA Developer Data Loading Library (&#x201c;DALI&#x201d;) CUDA libraries to provide accelerated computing on underlying hardware.</p><p id="p-0430" num="0405">In at least one embodiment, programming platform <b>3404</b> may be one of a CUDA, ROCm, or OpenCL platform described above in conjunction with <figref idref="DRAWINGS">FIG. <b>31</b></figref>, <figref idref="DRAWINGS">FIG. <b>32</b></figref>, and <figref idref="DRAWINGS">FIG. <b>33</b></figref>, respectively. In at least one embodiment, programming platform <b>3404</b> supports multiple programming models <b>3403</b>, which are abstractions of an underlying computing system permitting expressions of algorithms and data structures. Programming models <b>3403</b> may expose features of underlying hardware in order to improve performance, in at least one embodiment. In at least one embodiment, programming models <b>3403</b> may include, but are not limited to, CUDA, HIP, OpenCL, C++ Accelerated Massive Parallelism (&#x201c;C++ AMP&#x201d;), Open Multi-Processing (&#x201c;OpenMP&#x201d;), Open Accelerators (&#x201c;OpenACC&#x201d;), and/or Vulcan Compute.</p><p id="p-0431" num="0406">In at least one embodiment, libraries and/or middlewares <b>3402</b> provide implementations of abstractions of programming models <b>3404</b>. In at least one embodiment, such libraries include data and programming code that may be used by computer programs and leveraged during software development. In at least one embodiment, such middlewares include software that provides services to applications beyond those available from programming platform <b>3404</b>. In at least one embodiment, libraries and/or middlewares <b>3402</b> may include, but are not limited to, cuBLAS, cuFFT, cuRAND, and other CUDA libraries, or rocBLAS, rocFFT, rocRAND, and other ROCm libraries. In addition, in at least one embodiment, libraries and/or middlewares <b>3402</b> may include NCCL and ROCm Communication Collectives Library (&#x201c;RCCL&#x201d;) libraries providing communication routines for GPUs, a MIOpen library for deep learning acceleration, and/or an Eigen library for linear algebra, matrix and vector operations, geometrical transformations, numerical solvers, and related algorithms.</p><p id="p-0432" num="0407">In at least one embodiment, application frameworks <b>3401</b> depend on libraries and/or middlewares <b>3402</b>. In at least one embodiment, each of application frameworks <b>3401</b> is a software framework used to implement a standard structure of application software. Returning to the AI/ML example discussed above, an AI/ML application may be implemented using a framework such as Caffe, Caffe2, TensorFlow, Keras, PyTorch, or M&#xd7;Net deep learning frameworks, in at least one embodiment.</p><p id="p-0433" num="0408">In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>34</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>34</b></figref> are utilized to perform API to generate one or more graph code nodes to deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>34</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate and deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>34</b></figref> are utilized to implement one or more systems and/or processes such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>10</b></figref>.</p><p id="p-0434" num="0409"><figref idref="DRAWINGS">FIG. <b>35</b></figref> illustrates compiling code to execute on one of programming platforms of <figref idref="DRAWINGS">FIGS. <b>30</b>-<b>33</b></figref>, in accordance with at least one embodiment. In at least one embodiment, a compiler <b>3501</b> receives source code <b>3500</b> that includes both host code as well as device code. In at least one embodiment, complier <b>3501</b> is configured to convert source code <b>3500</b> into host executable code <b>3502</b> for execution on a host and device executable code <b>3503</b> for execution on a device. In at least one embodiment, source code <b>3500</b> may either be compiled offline prior to execution of an application, or online during execution of an application.</p><p id="p-0435" num="0410">In at least one embodiment, source code <b>3500</b> may include code in any programming language supported by compiler <b>3501</b>, such as C++, C, Fortran, etc. In at least one embodiment, source code <b>3500</b> may be included in a single-source file having a mixture of host code and device code, with locations of device code being indicated therein. In at least one embodiment, a single-source file may be a .cu file that includes CUDA code or a .hip.cpp file that includes HIP code. Alternatively, in at least one embodiment, source code <b>3500</b> may include multiple source code files, rather than a single-source file, into which host code and device code are separated.</p><p id="p-0436" num="0411">In at least one embodiment, compiler <b>3501</b> is configured to compile source code <b>3500</b> into host executable code <b>3502</b> for execution on a host and device executable code <b>3503</b> for execution on a device. In at least one embodiment, compiler <b>3501</b> performs operations including parsing source code <b>3500</b> into an abstract system tree (AST), performing optimizations, and generating executable code. In at least one embodiment in which source code <b>3500</b> includes a single-source file, compiler <b>3501</b> may separate device code from host code in such a single-source file, compile device code and host code into device executable code <b>3503</b> and host executable code <b>3502</b>, respectively, and link device executable code <b>3503</b> and host executable code <b>3502</b> together in a single file, as discussed in greater detail below with respect to <figref idref="DRAWINGS">FIG. <b>36</b></figref>.</p><p id="p-0437" num="0412">In at least one embodiment, host executable code <b>3502</b> and device executable code <b>3503</b> may be in any suitable format, such as binary code and/or IR code. In the case of CUDA, host executable code <b>3502</b> may include native object code and device executable code <b>3503</b> may include code in PTX intermediate representation, in at least one embodiment. In the case of ROCm, both host executable code <b>3502</b> and device executable code <b>3503</b> may include target binary code, in at least one embodiment.</p><p id="p-0438" num="0413">In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>35</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>35</b></figref> are utilized to perform API to generate one or more graph code nodes to deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>35</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate and deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>35</b></figref> are utilized to implement one or more systems and/or processes such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>10</b></figref>.</p><p id="p-0439" num="0414"><figref idref="DRAWINGS">FIG. <b>36</b></figref> is a more detailed illustration of compiling code to execute on one of programming platforms of <figref idref="DRAWINGS">FIGS. <b>30</b>-<b>33</b></figref>, in accordance with at least one embodiment. In at least one embodiment, a compiler <b>3601</b> is configured to receive source code <b>3600</b>, compile source code <b>3600</b>, and output an executable file <b>3610</b>. In at least one embodiment, source code <b>3600</b> is a single-source file, such as a .cu file, a .hip.cpp file, or a file in another format, that includes both host and device code. In at least one embodiment, compiler <b>3601</b> may be, but is not limited to, an NVIDIA CUDA compiler (&#x201c;NVCC&#x201d;) for compiling CUDA code in .cu files, or a HCC compiler for compiling HIP code in .hip.cpp files.</p><p id="p-0440" num="0415">In at least one embodiment, compiler <b>3601</b> includes a compiler front end <b>3602</b>, a host compiler <b>3605</b>, a device compiler <b>3606</b>, and a linker <b>3609</b>. In at least one embodiment, compiler front end <b>3602</b> is configured to separate device code <b>3604</b> from host code <b>3603</b> in source code <b>3600</b>. Device code <b>3604</b> is compiled by device compiler <b>3606</b> into device executable code <b>3608</b>, which as described may include binary code or IR code, in at least one embodiment. Separately, host code <b>3603</b> is compiled by host compiler <b>3605</b> into host executable code <b>3607</b>, in at least one embodiment. For NVCC, host compiler <b>3605</b> may be, but is not limited to, a general purpose C/C++ compiler that outputs native object code, while device compiler <b>3606</b> may be, but is not limited to, a Low Level Virtual Machine (&#x201c;LLVM&#x201d;)-based compiler that forks a LLVM compiler infrastructure and outputs PTX code or binary code, in at least one embodiment. For HCC, both host compiler <b>3605</b> and device compiler <b>3606</b> may be, but are not limited to, LLVM-based compilers that output target binary code, in at least one embodiment.</p><p id="p-0441" num="0416">Subsequent to compiling source code <b>3600</b> into host executable code <b>3607</b> and device executable code <b>3608</b>, linker <b>3609</b> links host and device executable code <b>3607</b> and <b>3608</b> together in executable file <b>3610</b>, in at least one embodiment. In at least one embodiment, native object code for a host and PTX or binary code for a device may be linked together in an Executable and Linkable Format (&#x201c;ELF&#x201d;) file, which is a container format used to store object code.</p><p id="p-0442" num="0417">In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>36</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>36</b></figref> are utilized to perform API to generate one or more graph code nodes to deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>36</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate and deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>36</b></figref> are utilized to implement one or more systems and/or processes such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>10</b></figref>.</p><p id="p-0443" num="0418"><figref idref="DRAWINGS">FIG. <b>37</b></figref> illustrates translating source code prior to compiling source code, in accordance with at least one embodiment. In at least one embodiment, source code <b>3700</b> is passed through a translation tool <b>3701</b>, which translates source code <b>3700</b> into translated source code <b>3702</b>. In at least one embodiment, a compiler <b>3703</b> is used to compile translated source code <b>3702</b> into host executable code <b>3704</b> and device executable code <b>3705</b> in a process that is similar to compilation of source code <b>3500</b> by compiler <b>3501</b> into host executable code <b>3502</b> and device executable <b>3503</b>, as discussed above in conjunction with <figref idref="DRAWINGS">FIG. <b>35</b></figref>.</p><p id="p-0444" num="0419">In at least one embodiment, a translation performed by translation tool <b>3701</b> is used to port source <b>3700</b> for execution in a different environment than that in which it was originally intended to run. In at least one embodiment, translation tool <b>3701</b> may include, but is not limited to, a HIP translator that is used to &#x201c;hipify&#x201d; CUDA code intended for a CUDA platform into HIP code that can be compiled and executed on a ROCm platform. In at least one embodiment, translation of source code <b>3700</b> may include parsing source code <b>3700</b> and converting calls to API(s) provided by one programming model (e.g., CUDA) into corresponding calls to API(s) provided by another programming model (e.g., HIP), as discussed in greater detail below in conjunction with <figref idref="DRAWINGS">FIGS. <b>38</b>A-<b>39</b></figref>. Returning to the example of hipifying CUDA code, calls to CUDA runtime API, CUDA driver API, and/or CUDA libraries may be converted to corresponding HIP API calls, in at least one embodiment. In at least one embodiment, automated translations performed by translation tool <b>3701</b> may sometimes be incomplete, requiring additional, manual effort to fully port source code <b>3700</b>.</p><p id="p-0445" num="0420">In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>37</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>37</b></figref> are utilized to perform API to generate one or more graph code nodes to deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>37</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate and deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>37</b></figref> are utilized to implement one or more systems and/or processes such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>10</b></figref>.</p><heading id="h-0010" level="1">Configuring GPUS for General-Purpose Computing</heading><p id="p-0446" num="0421">The following figures set forth, without limitation, exemplary architectures for compiling and executing compute source code, in accordance with at least one embodiment.</p><p id="p-0447" num="0422"><figref idref="DRAWINGS">FIG. <b>38</b>A</figref> illustrates a system <b>38</b>A<b>00</b> configured to compile and execute CUDA source code <b>3810</b> using different types of processing units, in accordance with at least one embodiment. In at least one embodiment, system <b>38</b>A<b>00</b> includes, without limitation, CUDA source code <b>3810</b>, a CUDA compiler <b>3850</b>, host executable code <b>3870</b>(1), host executable code <b>3870</b>(2), CUDA device executable code <b>3884</b>, a CPU <b>3890</b>, a CUDA-enabled GPU <b>3894</b>, a GPU <b>3892</b>, a CUDA to HIP translation tool <b>3820</b>, HIP source code <b>3830</b>, a HIP compiler driver <b>3840</b>, an HCC <b>3860</b>, and HCC device executable code <b>3882</b>.</p><p id="p-0448" num="0423">In at least one embodiment, CUDA source code <b>3810</b> is a collection of human-readable code in a CUDA programming language. In at least one embodiment, CUDA code is human-readable code in a CUDA programming language. In at least one embodiment, a CUDA programming language is an extension of the C++ programming language that includes, without limitation, mechanisms to define device code and distinguish between device code and host code. In at least one embodiment, device code is source code that, after compilation, is executable in parallel on a device. In at least one embodiment, a device may be a processor that is optimized for parallel instruction processing, such as CUDA-enabled GPU <b>3890</b>, GPU <b>38192</b>, or another GPGPU, etc. In at least one embodiment, host code is source code that, after compilation, is executable on a host. In at least one embodiment, a host is a processor that is optimized for sequential instruction processing, such as CPU <b>3890</b>.</p><p id="p-0449" num="0424">In at least one embodiment, CUDA source code <b>3810</b> includes, without limitation, any number (including zero) of global functions <b>3812</b>, any number (including zero) of device functions <b>3814</b>, any number (including zero) of host functions <b>3816</b>, and any number (including zero) of host/device functions <b>3818</b>. In at least one embodiment, global functions <b>3812</b>, device functions <b>3814</b>, host functions <b>3816</b>, and host/device functions <b>3818</b> may be mixed in CUDA source code <b>3810</b>. In at least one embodiment, each of global functions <b>3812</b> is executable on a device and callable from a host. In at least one embodiment, one or more of global functions <b>3812</b> may therefore act as entry points to a device. In at least one embodiment, each of global functions <b>3812</b> is a kernel. In at least one embodiment and in a technique known as dynamic parallelism, one or more of global functions <b>3812</b> defines a kernel that is executable on a device and callable from such a device. In at least one embodiment, a kernel is executed N (where N is any positive integer) times in parallel by N different threads on a device during execution.</p><p id="p-0450" num="0425">In at least one embodiment, each of device functions <b>3814</b> is executed on a device and callable from such a device only. In at least one embodiment, each of host functions <b>3816</b> is executed on a host and callable from such a host only. In at least one embodiment, each of host/device functions <b>3816</b> defines both a host version of a function that is executable on a host and callable from such a host only and a device version of the function that is executable on a device and callable from such a device only.</p><p id="p-0451" num="0426">In at least one embodiment, CUDA source code <b>3810</b> may also include, without limitation, any number of calls to any number of functions that are defined via a CUDA runtime API <b>3802</b>. In at least one embodiment, CUDA runtime API <b>3802</b> may include, without limitation, any number of functions that execute on a host to allocate and deallocate device memory, transfer data between host memory and device memory, manage systems with multiple devices, etc. In at least one embodiment, CUDA source code <b>3810</b> may also include any number of calls to any number of functions that are specified in any number of other CUDA APIs. In at least one embodiment, a CUDA API may be any API that is designed for use by CUDA code. In at least one embodiment, CUDA APIs include, without limitation, CUDA runtime API <b>3802</b>, a CUDA driver API, APIs for any number of CUDA libraries, etc. In at least one embodiment and relative to CUDA runtime API <b>3802</b>, a CUDA driver API is a lower-level API but provides finer-grained control of a device. In at least one embodiment, examples of CUDA libraries include, without limitation, cuBLAS, cuFFT, cuRAND, cuDNN, etc.</p><p id="p-0452" num="0427">In at least one embodiment, CUDA compiler <b>3850</b> compiles input CUDA code (e.g., CUDA source code <b>3810</b>) to generate host executable code <b>3870</b>(1) and CUDA device executable code <b>3884</b>. In at least one embodiment, CUDA compiler <b>3850</b> is NVCC. In at least one embodiment, host executable code <b>3870</b>(1) is a compiled version of host code included in input source code that is executable on CPU <b>3890</b>. In at least one embodiment, CPU <b>3890</b> may be any processor that is optimized for sequential instruction processing.</p><p id="p-0453" num="0428">In at least one embodiment, CUDA device executable code <b>3884</b> is a compiled version of device code included in input source code that is executable on CUDA-enabled GPU <b>3894</b>. In at least one embodiment, CUDA device executable code <b>3884</b> includes, without limitation, binary code. In at least one embodiment, CUDA device executable code <b>3884</b> includes, without limitation, IR code, such as PTX code, that is further compiled at runtime into binary code for a specific target device (e.g., CUDA-enabled GPU <b>3894</b>) by a device driver. In at least one embodiment, CUDA-enabled GPU <b>3894</b> may be any processor that is optimized for parallel instruction processing and that supports CUDA. In at least one embodiment, CUDA-enabled GPU <b>3894</b> is developed by NVIDIA Corporation of Santa Clara, Calif.</p><p id="p-0454" num="0429">In at least one embodiment, CUDA to HIP translation tool <b>3820</b> is configured to translate CUDA source code <b>3810</b> to functionally similar HIP source code <b>3830</b>. In a least one embodiment, HIP source code <b>3830</b> is a collection of human-readable code in a HIP programming language. In at least one embodiment, HIP code is human-readable code in a HIP programming language. In at least one embodiment, a HIP programming language is an extension of the C++ programming language that includes, without limitation, functionally similar versions of CUDA mechanisms to define device code and distinguish between device code and host code. In at least one embodiment, a HIP programming language may include a subset of functionality of a CUDA programming language. In at least one embodiment, for example, a HIP programming language includes, without limitation, mechanism(s) to define global functions <b>3812</b>, but such a HIP programming language may lack support for dynamic parallelism and therefore global functions <b>3812</b> defined in HIP code may be callable from a host only.</p><p id="p-0455" num="0430">In at least one embodiment, HIP source code <b>3830</b> includes, without limitation, any number (including zero) of global functions <b>3812</b>, any number (including zero) of device functions <b>3814</b>, any number (including zero) of host functions <b>3816</b>, and any number (including zero) of host/device functions <b>3818</b>. In at least one embodiment, HIP source code <b>3830</b> may also include any number of calls to any number of functions that are specified in a HIP runtime API <b>3832</b>. In at least one embodiment, HIP runtime API <b>3832</b> includes, without limitation, functionally similar versions of a subset of functions included in CUDA runtime API <b>3802</b>. In at least one embodiment, HIP source code <b>3830</b> may also include any number of calls to any number of functions that are specified in any number of other HIP APIs. In at least one embodiment, a HIP API may be any API that is designed for use by HIP code and/or ROCm. In at least one embodiment, HIP APIs include, without limitation, HIP runtime API <b>3832</b>, a HIP driver API, APIs for any number of HIP libraries, APIs for any number of ROCm libraries, etc.</p><p id="p-0456" num="0431">In at least one embodiment, CUDA to HIP translation tool <b>3820</b> converts each kernel call in CUDA code from a CUDA syntax to a HIP syntax and converts any number of other CUDA calls in CUDA code to any number of other functionally similar HIP calls. In at least one embodiment, a CUDA call is a call to a function specified in a CUDA API, and a HIP call is a call to a function specified in a HIP API. In at least one embodiment, CUDA to HIP translation tool <b>3820</b> converts any number of calls to functions specified in CUDA runtime API <b>3802</b> to any number of calls to functions specified in HIP runtime API <b>3832</b>.</p><p id="p-0457" num="0432">In at least one embodiment, CUDA to HIP translation tool <b>3820</b> is a tool known as hipify-perl that executes a text-based translation process. In at least one embodiment, CUDA to HIP translation tool <b>3820</b> is a tool known as hipify-clang that, relative to hipify-perl, executes a more complex and more robust translation process that involves parsing CUDA code using clang (a compiler front-end) and then translating resulting symbols. In at least one embodiment, properly converting CUDA code to HIP code may require modifications (e.g., manual edits) in addition to those performed by CUDA to HIP translation tool <b>3820</b>.</p><p id="p-0458" num="0433">In at least one embodiment, HIP compiler driver <b>3840</b> is a front end that determines a target device <b>3846</b> and then configures a compiler that is compatible with target device <b>3846</b> to compile HIP source code <b>3830</b>. In at least one embodiment, target device <b>3846</b> is a processor that is optimized for parallel instruction processing. In at least one embodiment, HIP compiler driver <b>3840</b> may determine target device <b>3846</b> in any technically feasible fashion.</p><p id="p-0459" num="0434">In at least one embodiment, if target device <b>3846</b> is compatible with CUDA (e.g., CUDA-enabled GPU <b>3894</b>), then HIP compiler driver <b>3840</b> generates a HIP/NVCC compilation command <b>3842</b>. In at least one embodiment and as described in greater detail in conjunction with <figref idref="DRAWINGS">FIG. <b>38</b>B</figref>, HIP/NVCC compilation command <b>3842</b> configures CUDA compiler <b>3850</b> to compile HIP source code <b>3830</b> using, without limitation, a HIP to CUDA translation header and a CUDA runtime library. In at least one embodiment and in response to HIP/NVCC compilation command <b>3842</b>, CUDA compiler <b>3850</b> generates host executable code <b>3870</b>(1) and CUDA device executable code <b>3884</b>.</p><p id="p-0460" num="0435">In at least one embodiment, if target device <b>3846</b> is not compatible with CUDA, then HIP compiler driver <b>3840</b> generates a HIP/HCC compilation command <b>3844</b>. In at least one embodiment and as described in greater detail in conjunction with <figref idref="DRAWINGS">FIG. <b>38</b>C</figref>, HIP/HCC compilation command <b>3844</b> configures HCC <b>3860</b> to compile HIP source code <b>3830</b> using, without limitation, an HCC header and a HIP/HCC runtime library. In at least one embodiment and in response to HIP/HCC compilation command <b>3844</b>, HCC <b>3860</b> generates host executable code <b>3870</b>(2) and HCC device executable code <b>3882</b>. In at least one embodiment, HCC device executable code <b>3882</b> is a compiled version of device code included in HIP source code <b>3830</b> that is executable on GPU <b>3892</b>. In at least one embodiment, GPU <b>3892</b> may be any processor that is optimized for parallel instruction processing, is not compatible with CUDA, and is compatible with HCC. In at least one embodiment, GPU <b>3892</b> is developed by AMD Corporation of Santa Clara, Calif. In at least one embodiment GPU, <b>3892</b> is a non-CUDA-enabled GPU <b>3892</b>.</p><p id="p-0461" num="0436">For explanatory purposes only, three different flows that may be implemented in at least one embodiment to compile CUDA source code <b>3810</b> for execution on CPU <b>3890</b> and different devices are depicted in <figref idref="DRAWINGS">FIG. <b>38</b>A</figref>. In at least one embodiment, a direct CUDA flow compiles CUDA source code <b>3810</b> for execution on CPU <b>3890</b> and CUDA-enabled GPU <b>3894</b> without translating CUDA source code <b>3810</b> to HIP source code <b>3830</b>. In at least one embodiment, an indirect CUDA flow translates CUDA source code <b>3810</b> to HIP source code <b>3830</b> and then compiles HIP source code <b>3830</b> for execution on CPU <b>3890</b> and CUDA-enabled GPU <b>3894</b>. In at least one embodiment, a CUDA/HCC flow translates CUDA source code <b>3810</b> to HIP source code <b>3830</b> and then compiles HIP source code <b>3830</b> for execution on CPU <b>3890</b> and GPU <b>3892</b>.</p><p id="p-0462" num="0437">A direct CUDA flow that may be implemented in at least one embodiment is depicted via dashed lines and a series of bubbles annotated A1-A3. In at least one embodiment and as depicted with bubble annotated A1, CUDA compiler <b>3850</b> receives CUDA source code <b>3810</b> and a CUDA compile command <b>3848</b> that configures CUDA compiler <b>3850</b> to compile CUDA source code <b>3810</b>. In at least one embodiment, CUDA source code <b>3810</b> used in a direct CUDA flow is written in a CUDA programming language that is based on a programming language other than C++ (e.g., C, Fortran, Python, Java, etc.). In at least one embodiment and in response to CUDA compile command <b>3848</b>, CUDA compiler <b>3850</b> generates host executable code <b>3870</b>(1) and CUDA device executable code <b>3884</b> (depicted with bubble annotated A2). In at least one embodiment and as depicted with bubble annotated A3, host executable code <b>3870</b>(1) and CUDA device executable code <b>3884</b> may be executed on, respectively, CPU <b>3890</b> and CUDA-enabled GPU <b>3894</b>. In at least one embodiment, CUDA device executable code <b>3884</b> includes, without limitation, binary code. In at least one embodiment, CUDA device executable code <b>3884</b> includes, without limitation, PTX code and is further compiled into binary code for a specific target device at runtime.</p><p id="p-0463" num="0438">An indirect CUDA flow that may be implemented in at least one embodiment is depicted via dotted lines and a series of bubbles annotated B1-B6. In at least one embodiment and as depicted with bubble annotated B1, CUDA to HIP translation tool <b>3820</b> receives CUDA source code <b>3810</b>. In at least one embodiment and as depicted with bubble annotated B2, CUDA to HIP translation tool <b>3820</b> translates CUDA source code <b>3810</b> to HIP source code <b>3830</b>. In at least one embodiment and as depicted with bubble annotated B3, HIP compiler driver <b>3840</b> receives HIP source code <b>3830</b> and determines that target device <b>3846</b> is CUDA-enabled.</p><p id="p-0464" num="0439">In at least one embodiment and as depicted with bubble annotated B4, HIP compiler driver <b>3840</b> generates HIP/NVCC compilation command <b>3842</b> and transmits both HIP/NVCC compilation command <b>3842</b> and HIP source code <b>3830</b> to CUDA compiler <b>3850</b>. In at least one embodiment and as described in greater detail in conjunction with <figref idref="DRAWINGS">FIG. <b>38</b>B</figref>, HIP/NVCC compilation command <b>3842</b> configures CUDA compiler <b>3850</b> to compile HIP source code <b>3830</b> using, without limitation, a HIP to CUDA translation header and a CUDA runtime library. In at least one embodiment and in response to HIP/NVCC compilation command <b>3842</b>, CUDA compiler <b>3850</b> generates host executable code <b>3870</b>(1) and CUDA device executable code <b>3884</b> (depicted with bubble annotated B5). In at least one embodiment and as depicted with bubble annotated B6, host executable code <b>3870</b>(1) and CUDA device executable code <b>3884</b> may be executed on, respectively, CPU <b>3890</b> and CUDA-enabled GPU <b>3894</b>. In at least one embodiment, CUDA device executable code <b>3884</b> includes, without limitation, binary code. In at least one embodiment, CUDA device executable code <b>3884</b> includes, without limitation, PTX code and is further compiled into binary code for a specific target device at runtime.</p><p id="p-0465" num="0440">A CUDA/HCC flow that may be implemented in at least one embodiment is depicted via solid lines and a series of bubbles annotated C1-C6. In at least one embodiment and as depicted with bubble annotated C1, CUDA to HIP translation tool <b>3820</b> receives CUDA source code <b>3810</b>. In at least one embodiment and as depicted with bubble annotated C2, CUDA to HIP translation tool <b>3820</b> translates CUDA source code <b>3810</b> to HIP source code <b>3830</b>. In at least one embodiment and as depicted with bubble annotated C3, HIP compiler driver <b>3840</b> receives HIP source code <b>3830</b> and determines that target device <b>3846</b> is not CUDA-enabled.</p><p id="p-0466" num="0441">In at least one embodiment, HIP compiler driver <b>3840</b> generates HIP/HCC compilation command <b>3844</b> and transmits both HIP/HCC compilation command <b>3844</b> and HIP source code <b>3830</b> to HCC <b>3860</b> (depicted with bubble annotated C4). In at least one embodiment and as described in greater detail in conjunction with <figref idref="DRAWINGS">FIG. <b>38</b>C</figref>, HIP/HCC compilation command <b>3844</b> configures HCC <b>3860</b> to compile HIP source code <b>3830</b> using, without limitation, an HCC header and a HIP/HCC runtime library. In at least one embodiment and in response to HIP/HCC compilation command <b>3844</b>, HCC <b>3860</b> generates host executable code <b>3870</b>(2) and HCC device executable code <b>3882</b> (depicted with bubble annotated C5). In at least one embodiment and as depicted with bubble annotated C6, host executable code <b>3870</b>(2) and HCC device executable code <b>3882</b> may be executed on, respectively, CPU <b>3890</b> and GPU <b>3892</b>.</p><p id="p-0467" num="0442">In at least one embodiment, after CUDA source code <b>3810</b> is translated to HIP source code <b>3830</b>, HIP compiler driver <b>3840</b> may subsequently be used to generate executable code for either CUDA-enabled GPU <b>3894</b> or GPU <b>3892</b> without re-executing CUDA to HIP translation tool <b>3820</b>. In at least one embodiment, CUDA to HIP translation tool <b>3820</b> translates CUDA source code <b>3810</b> to HIP source code <b>3830</b> that is then stored in memory. In at least one embodiment, HIP compiler driver <b>3840</b> then configures HCC <b>3860</b> to generate host executable code <b>3870</b>(2) and HCC device executable code <b>3882</b> based on HIP source code <b>3830</b>. In at least one embodiment, HIP compiler driver <b>3840</b> subsequently configures CUDA compiler <b>3850</b> to generate host executable code <b>3870</b>(1) and CUDA device executable code <b>3884</b> based on stored HIP source code <b>3830</b>.</p><p id="p-0468" num="0443"><figref idref="DRAWINGS">FIG. <b>38</b>B</figref> illustrates a system <b>3804</b> configured to compile and execute CUDA source code <b>3810</b> of <figref idref="DRAWINGS">FIG. <b>38</b>A</figref> using CPU <b>3890</b> and CUDA-enabled GPU <b>3894</b>, in accordance with at least one embodiment. In at least one embodiment, system <b>3804</b> includes, without limitation, CUDA source code <b>3810</b>, CUDA to HIP translation tool <b>3820</b>, HIP source code <b>3830</b>, HIP compiler driver <b>3840</b>, CUDA compiler <b>3850</b>, host executable code <b>3870</b>(1), CUDA device executable code <b>3884</b>, CPU <b>3890</b>, and CUDA-enabled GPU <b>3894</b>.</p><p id="p-0469" num="0444">In at least one embodiment and as described previously herein in conjunction with <figref idref="DRAWINGS">FIG. <b>38</b>A</figref>, CUDA source code <b>3810</b> includes, without limitation, any number (including zero) of global functions <b>3812</b>, any number (including zero) of device functions <b>3814</b>, any number (including zero) of host functions <b>3816</b>, and any number (including zero) of host/device functions <b>3818</b>. In at least one embodiment, CUDA source code <b>3810</b> also includes, without limitation, any number of calls to any number of functions that are specified in any number of CUDA APIs.</p><p id="p-0470" num="0445">In at least one embodiment, CUDA to HIP translation tool <b>3820</b> translates CUDA source code <b>3810</b> to HIP source code <b>3830</b>. In at least one embodiment, CUDA to HIP translation tool <b>3820</b> converts each kernel call in CUDA source code <b>3810</b> from a CUDA syntax to a HIP syntax and converts any number of other CUDA calls in CUDA source code <b>3810</b> to any number of other functionally similar HIP calls.</p><p id="p-0471" num="0446">In at least one embodiment, HIP compiler driver <b>3840</b> determines that target device <b>3846</b> is CUDA-enabled and generates HIP/NVCC compilation command <b>3842</b>. In at least one embodiment, HIP compiler driver <b>3840</b> then configures CUDA compiler <b>3850</b> via HIP/NVCC compilation command <b>3842</b> to compile HIP source code <b>3830</b>. In at least one embodiment, HIP compiler driver <b>3840</b> provides access to a HIP to CUDA translation header <b>3852</b> as part of configuring CUDA compiler <b>3850</b>. In at least one embodiment, HIP to CUDA translation header <b>3852</b> translates any number of mechanisms (e.g., functions) specified in any number of HIP APIs to any number of mechanisms specified in any number of CUDA APIs. In at least one embodiment, CUDA compiler <b>3850</b> uses HIP to CUDA translation header <b>3852</b> in conjunction with a CUDA runtime library <b>3854</b> corresponding to CUDA runtime API <b>3802</b> to generate host executable code <b>3870</b>(1) and CUDA device executable code <b>3884</b>. In at least one embodiment, host executable code <b>3870</b>(1) and CUDA device executable code <b>3884</b> may then be executed on, respectively, CPU <b>3890</b> and CUDA-enabled GPU <b>3894</b>. In at least one embodiment, CUDA device executable code <b>3884</b> includes, without limitation, binary code. In at least one embodiment, CUDA device executable code <b>3884</b> includes, without limitation, PTX code and is further compiled into binary code for a specific target device at runtime.</p><p id="p-0472" num="0447"><figref idref="DRAWINGS">FIG. <b>38</b>C</figref> illustrates a system <b>3806</b> configured to compile and execute CUDA source code <b>3810</b> of <figref idref="DRAWINGS">FIG. <b>38</b>A</figref> using CPU <b>3890</b> and non-CUDA-enabled GPU <b>3892</b>, in accordance with at least one embodiment. In at least one embodiment, system <b>3806</b> includes, without limitation, CUDA source code <b>3810</b>, CUDA to HIP translation tool <b>3820</b>, HIP source code <b>3830</b>, HIP compiler driver <b>3840</b>, HCC <b>3860</b>, host executable code <b>3870</b>(2), HCC device executable code <b>3882</b>, CPU <b>3890</b>, and GPU <b>3892</b>.</p><p id="p-0473" num="0448">In at least one embodiment and as described previously herein in conjunction with <figref idref="DRAWINGS">FIG. <b>38</b>A</figref>, CUDA source code <b>3810</b> includes, without limitation, any number (including zero) of global functions <b>3812</b>, any number (including zero) of device functions <b>3814</b>, any number (including zero) of host functions <b>3816</b>, and any number (including zero) of host/device functions <b>3818</b>. In at least one embodiment, CUDA source code <b>3810</b> also includes, without limitation, any number of calls to any number of functions that are specified in any number of CUDA APIs.</p><p id="p-0474" num="0449">In at least one embodiment, CUDA to HIP translation tool <b>3820</b> translates CUDA source code <b>3810</b> to HIP source code <b>3830</b>. In at least one embodiment, CUDA to HIP translation tool <b>3820</b> converts each kernel call in CUDA source code <b>3810</b> from a CUDA syntax to a HIP syntax and converts any number of other CUDA calls in source code <b>3810</b> to any number of other functionally similar HIP calls.</p><p id="p-0475" num="0450">In at least one embodiment, HIP compiler driver <b>3840</b> subsequently determines that target device <b>3846</b> is not CUDA-enabled and generates HIP/HCC compilation command <b>3844</b>. In at least one embodiment, HIP compiler driver <b>3840</b> then configures HCC <b>3860</b> to execute HIP/HCC compilation command <b>3844</b> to compile HIP source code <b>3830</b>. In at least one embodiment, HIP/HCC compilation command <b>3844</b> configures HCC <b>3860</b> to use, without limitation, a HIP/HCC runtime library <b>3858</b> and an HCC header <b>3856</b> to generate host executable code <b>3870</b>(2) and HCC device executable code <b>3882</b>. In at least one embodiment, HIP/HCC runtime library <b>3858</b> corresponds to HIP runtime API <b>3832</b>. In at least one embodiment, HCC header <b>3856</b> includes, without limitation, any number and type of interoperability mechanisms for HIP and HCC. In at least one embodiment, host executable code <b>3870</b>(2) and HCC device executable code <b>3882</b> may be executed on, respectively, CPU <b>3890</b> and GPU <b>3892</b>.</p><p id="p-0476" num="0451">In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIGS. <b>38</b>A-<b>38</b>C</figref> are utilized to perform API to generate one or more graph code nodes to allocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIGS. <b>38</b>A-<b>38</b>C</figref> are utilized to perform API to generate one or more graph code nodes to deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIGS. <b>38</b>A-<b>38</b>C</figref> are utilized to perform API to generate one or more graph code nodes to allocate and deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIGS. <b>38</b>A-<b>38</b>C</figref> are utilized to implement one or more systems and/or processes such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>10</b></figref>.</p><p id="p-0477" num="0452"><figref idref="DRAWINGS">FIG. <b>39</b></figref> illustrates an exemplary kernel translated by CUDA-to-HIP translation tool <b>3820</b> of <figref idref="DRAWINGS">FIG. <b>38</b>C</figref>, in accordance with at least one embodiment. In at least one embodiment, CUDA source code <b>3810</b> partitions an overall problem that a given kernel is designed to solve into relatively coarse sub-problems that can independently be solved using thread blocks. In at least one embodiment, each thread block includes, without limitation, any number of threads. In at least one embodiment, each sub-problem is partitioned into relatively fine pieces that can be solved cooperatively in parallel by threads within a thread block. In at least one embodiment, threads within a thread block can cooperate by sharing data through shared memory and by synchronizing execution to coordinate memory accesses.</p><p id="p-0478" num="0453">In at least one embodiment, CUDA source code <b>3810</b> organizes thread blocks associated with a given kernel into a one-dimensional, a two-dimensional, or a three-dimensional grid of thread blocks. In at least one embodiment, each thread block includes, without limitation, any number of threads, and a grid includes, without limitation, any number of thread blocks.</p><p id="p-0479" num="0454">In at least one embodiment, a kernel is a function in device code that is defined using a &#x201c;_global_&#x201d; declaration specifier. In at least one embodiment, the dimension of a grid that executes a kernel for a given kernel call and associated streams are specified using a CUDA kernel launch syntax <b>3910</b>. In at least one embodiment, CUDA kernel launch syntax <b>3910</b> is specified as &#x201c;KernelName&#x3c;&#x3c;&#x3c;GridSize, BlockSize, SharedMemorySize, Stream&#x3e;&#x3e;&#x3e;(KernelArguments);&#x201d;. In at least one embodiment, an execution configuration syntax is a &#x201c;&#x3c;&#x3c;&#x3c; . . . &#x3e;&#x3e;&#x3e;&#x201d; construct that is inserted between a kernel name (&#x201c;KernelName&#x201d;) and a parenthesized list of kernel arguments (&#x201c;KernelArguments&#x201d;). In at least one embodiment, CUDA kernel launch syntax <b>3910</b> includes, without limitation, a CUDA launch function syntax instead of an execution configuration syntax.</p><p id="p-0480" num="0455">In at least one embodiment, &#x201c;GridSize&#x201d; is of a type dim3 and specifies the dimension and size of a grid. In at least one embodiment, type dim3 is a CUDA-defined structure that includes, without limitation, unsigned integers x, y, and z. In at least one embodiment, if z is not specified, then z defaults to one. In at least one embodiment, if y is not specified, then y defaults to one. In at least one embodiment, the number of thread blocks in a grid is equal to the product of GridSize.x, GridSize.y, and GridSize.z. In at least one embodiment, &#x201c;BlockSize&#x201d; is of type dim3 and specifies the dimension and size of each thread block. In at least one embodiment, the number of threads per thread block is equal to the product of BlockSize.x, BlockSize.y, and BlockSize.z. In at least one embodiment, each thread that executes a kernel is given a unique thread ID that is accessible within the kernel through a built-in variable (e.g., &#x201c;threadIdx&#x201d;).</p><p id="p-0481" num="0456">In at least one embodiment and with respect to CUDA kernel launch syntax <b>3910</b>, &#x201c;SharedMemorySize&#x201d; is an optional argument that specifies a number of bytes in a shared memory that is dynamically allocated per thread block for a given kernel call in addition to statically allocated memory. In at least one embodiment and with respect to CUDA kernel launch syntax <b>3910</b>, SharedMemorySize defaults to zero. In at least one embodiment and with respect to CUDA kernel launch syntax <b>3910</b>, &#x201c;Stream&#x201d; is an optional argument that specifies an associated stream and defaults to zero to specify a default stream. In at least one embodiment, a stream is a sequence of commands (possibly issued by different host threads) that execute in order. In at least one embodiment, different streams may execute commands out of order with respect to one another or concurrently.</p><p id="p-0482" num="0457">In at least one embodiment, CUDA source code <b>3810</b> includes, without limitation, a kernel definition for an exemplary kernel &#x201c;MatAdd&#x201d; and a main function. In at least one embodiment, main function is host code that executes on a host and includes, without limitation, a kernel call that causes kernel MatAdd to execute on a device. In at least one embodiment and as shown, kernel MatAdd adds two matrices A and B of size N&#xd7;N, where N is a positive integer, and stores the result in a matrix C. In at least one embodiment, main function defines a threadsPerBlock variable as 16 by 16 and a numBlocks variable as N/16 by N/16. In at least one embodiment, main function then specifies kernel call &#x201c;MatAdd&#x3c;&#x3c;&#x3c;numBlocks, threadsPerBlock&#x3e;&#x3e;&#x3e;(A, B, C);&#x201d;. In at least one embodiment and as per CUDA kernel launch syntax <b>3910</b>, kernel MatAdd is executed using a grid of thread blocks having a dimension N/16 by N/16, where each thread block has a dimension of 16 by 16. In at least one embodiment, each thread block includes 256 threads, a grid is created with enough blocks to have one thread per matrix element, and each thread in such a grid executes kernel MatAdd to perform one pair-wise addition.</p><p id="p-0483" num="0458">In at least one embodiment, while translating CUDA source code <b>3810</b> to HIP source code <b>3830</b>, CUDA to HIP translation tool <b>3820</b> translates each kernel call in CUDA source code <b>3810</b> from CUDA kernel launch syntax <b>3910</b> to a HIP kernel launch syntax <b>3920</b> and converts any number of other CUDA calls in source code <b>3810</b> to any number of other functionally similar HIP calls. In at least one embodiment, HIP kernel launch syntax <b>3920</b> is specified as &#x201c;hipLaunchKernelGGL(KernelName,GridSize, BlockSize, SharedMemorySize, Stream, KernelArguments);&#x201d;. In at least one embodiment, each of KernelName, GridSize, BlockSize, ShareMemorySize, Stream, and KernelArguments has the same meaning in HIP kernel launch syntax <b>3920</b> as in CUDA kernel launch syntax <b>3910</b> (described previously herein). In at least one embodiment, arguments SharedMemorySize and Stream are required in HIP kernel launch syntax <b>3920</b> and are optional in CUDA kernel launch syntax <b>3910</b>.</p><p id="p-0484" num="0459">In at least one embodiment, a portion of HIP source code <b>3830</b> depicted in <figref idref="DRAWINGS">FIG. <b>39</b></figref> is identical to a portion of CUDA source code <b>3810</b> depicted in <figref idref="DRAWINGS">FIG. <b>39</b></figref> except for a kernel call that causes kernel MatAdd to execute on a device. In at least one embodiment, kernel MatAdd is defined in HIP source code <b>3830</b> with the same &#x201c;_global_&#x201d; declaration specifier with which kernel MatAdd is defined in CUDA source code <b>3810</b>. In at least one embodiment, a kernel call in HIP source code <b>3830</b> is &#x201c;hipLaunchKernelGGL(MatAdd, numBlocks, threadsPerBlock, 0, 0, A, B, C);&#x201d;, while a corresponding kernel call in CUDA source code <b>3810</b> is &#x201c;MatAdd&#x3c;&#x3c;&#x3c;numBlocks, threadsPerBlock&#x3e;&#x3e;&#x3e;(A, B, C);&#x201d;.</p><p id="p-0485" num="0460">In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>39</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>39</b></figref> are utilized to perform API to generate one or more graph code nodes to deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>39</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate and deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>39</b></figref> are utilized to implement one or more systems and/or processes such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>10</b></figref>.</p><p id="p-0486" num="0461"><figref idref="DRAWINGS">FIG. <b>40</b></figref> illustrates non-CUDA-enabled GPU <b>3892</b> of <figref idref="DRAWINGS">FIG. <b>38</b>C</figref> in greater detail, in accordance with at least one embodiment. In at least one embodiment, GPU <b>3892</b> is developed by AMD corporation of Santa Clara. In at least one embodiment, GPU <b>3892</b> can be configured to perform compute operations in a highly-parallel fashion. In at least one embodiment, GPU <b>3892</b> is configured to execute graphics pipeline operations such as draw commands, pixel operations, geometric computations, and other operations associated with rendering an image to a display. In at least one embodiment, GPU <b>3892</b> is configured to execute operations unrelated to graphics. In at least one embodiment, GPU <b>3892</b> is configured to execute both operations related to graphics and operations unrelated to graphics. In at least one embodiment, GPU <b>3892</b> can be configured to execute device code included in HIP source code <b>3830</b>.</p><p id="p-0487" num="0462">In at least one embodiment, GPU <b>3892</b> includes, without limitation, any number of programmable processing units <b>4020</b>, a command processor <b>4010</b>, an L2 cache <b>4022</b>, memory controllers <b>4070</b>, DMA engines <b>4080</b>(1), system memory controllers <b>4082</b>, DMA engines <b>4080</b>(2), and GPU controllers <b>4084</b>. In at least one embodiment, each programmable processing unit <b>4020</b> includes, without limitation, a workload manager <b>4030</b> and any number of compute units <b>4040</b>. In at least one embodiment, command processor <b>4010</b> reads commands from one or more command queues (not shown) and distributes commands to workload managers <b>4030</b>. In at least one embodiment, for each programmable processing unit <b>4020</b>, associated workload manager <b>4030</b> distributes work to compute units <b>4040</b> included in programmable processing unit <b>4020</b>. In at least one embodiment, each compute unit <b>4040</b> may execute any number of thread blocks, but each thread block executes on a single compute unit <b>4040</b>. In at least one embodiment, a workgroup is a thread block.</p><p id="p-0488" num="0463">In at least one embodiment, each compute unit <b>4040</b> includes, without limitation, any number of SIMD units <b>4050</b> and a shared memory <b>4060</b>. In at least one embodiment, each SIMD unit <b>4050</b> implements a SIMD architecture and is configured to perform operations in parallel. In at least one embodiment, each SIMD unit <b>4050</b> includes, without limitation, a vector ALU <b>4052</b> and a vector register file <b>4054</b>. In at least one embodiment, each SIMD unit <b>4050</b> executes a different warp. In at least one embodiment, a warp is a group of threads (e.g., 16 threads), where each thread in the warp belongs to a single thread block and is configured to process a different set of data based on a single set of instructions. In at least one embodiment, predication can be used to disable one or more threads in a warp. In at least one embodiment, a lane is a thread. In at least one embodiment, a work item is a thread. In at least one embodiment, a wavefront is a warp. In at least one embodiment, different wavefronts in a thread block may synchronize together and communicate via shared memory <b>4060</b>.</p><p id="p-0489" num="0464">In at least one embodiment, programmable processing units <b>4020</b> are referred to as &#x201c;shader engines.&#x201d; In at least one embodiment, each programmable processing unit <b>4020</b> includes, without limitation, any amount of dedicated graphics hardware in addition to compute units <b>4040</b>. In at least one embodiment, each programmable processing unit <b>4020</b> includes, without limitation, any number (including zero) of geometry processors, any number (including zero) of rasterizers, any number (including zero) of render back ends, workload manager <b>4030</b>, and any number of compute units <b>4040</b>.</p><p id="p-0490" num="0465">In at least one embodiment, compute units <b>4040</b> share L2 cache <b>4022</b>. In at least one embodiment, L2 cache <b>4022</b> is partitioned. In at least one embodiment, a GPU memory <b>4090</b> is accessible by all compute units <b>4040</b> in GPU <b>3892</b>. In at least one embodiment, memory controllers <b>4070</b> and system memory controllers <b>4082</b> facilitate data transfers between GPU <b>3892</b> and a host, and DMA engines <b>4080</b>(1) enable asynchronous memory transfers between GPU <b>3892</b> and such a host. In at least one embodiment, memory controllers <b>4070</b> and GPU controllers <b>4084</b> facilitate data transfers between GPU <b>3892</b> and other GPUs <b>3892</b>, and DMA engines <b>4080</b>(2) enable asynchronous memory transfers between GPU <b>3892</b> and other GPUs <b>3892</b>.</p><p id="p-0491" num="0466">In at least one embodiment, GPU <b>3892</b> includes, without limitation, any amount and type of system interconnect that facilitates data and control transmissions across any number and type of directly or indirectly linked components that may be internal or external to GPU <b>3892</b>. In at least one embodiment, GPU <b>3892</b> includes, without limitation, any number and type of I/O interfaces (e.g., PCIe) that are coupled to any number and type of peripheral devices. In at least one embodiment, GPU <b>3892</b> may include, without limitation, any number (including zero) of display engines and any number (including zero) of multimedia engines. In at least one embodiment, GPU <b>3892</b> implements a memory subsystem that includes, without limitation, any amount and type of memory controllers (e.g., memory controllers <b>4070</b> and system memory controllers <b>4082</b>) and memory devices (e.g., shared memories <b>4060</b>) that may be dedicated to one component or shared among multiple components. In at least one embodiment, GPU <b>3892</b> implements a cache subsystem that includes, without limitation, one or more cache memories (e.g., L2 cache <b>4022</b>) that may each be private to or shared between any number of components (e.g., SIMD units <b>4050</b>, compute units <b>4040</b>, and programmable processing units <b>4020</b>).</p><p id="p-0492" num="0467">In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>40</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>40</b></figref> are utilized to perform API to generate one or more graph code nodes to deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>40</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate and deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>40</b></figref> are utilized to implement one or more systems and/or processes such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>10</b></figref>.</p><p id="p-0493" num="0468"><figref idref="DRAWINGS">FIG. <b>41</b></figref> illustrates how threads of an exemplary CUDA grid <b>4120</b> are mapped to different compute units <b>4040</b> of <figref idref="DRAWINGS">FIG. <b>40</b></figref>, in accordance with at least one embodiment. In at least one embodiment and for explanatory purposes only, grid <b>4120</b> has a GridSize of BX by BY by 1 and a BlockSize of TX by TY by 1. In at least one embodiment, grid <b>4120</b> therefore includes, without limitation, (BX * BY) thread blocks <b>4130</b> and each thread block <b>4130</b> includes, without limitation, (TX*TY) threads <b>4140</b>. Threads <b>4140</b> are depicted in <figref idref="DRAWINGS">FIG. <b>41</b></figref> as squiggly arrows.</p><p id="p-0494" num="0469">In at least one embodiment, grid <b>4120</b> is mapped to programmable processing unit <b>4020</b>(1) that includes, without limitation, compute units <b>4040</b>(1)-<b>4040</b>(C). In at least one embodiment and as shown, (BJ*BY) thread blocks <b>4130</b> are mapped to compute unit <b>4040</b>(1), and the remaining thread blocks <b>4130</b> are mapped to compute unit <b>4040</b>(2). In at least one embodiment, each thread block <b>4130</b> may include, without limitation, any number of warps, and each warp is mapped to a different SIMD unit <b>4050</b> of <figref idref="DRAWINGS">FIG. <b>40</b></figref>.</p><p id="p-0495" num="0470">In at least one embodiment, warps in a given thread block <b>4130</b> may synchronize together and communicate through shared memory <b>4060</b> included in associated compute unit <b>4040</b>. For example and in at least one embodiment, warps in thread block <b>4130</b>(BJ,1) can synchronize together and communicate through shared memory <b>4060</b>(1). For example and in at least one embodiment, warps in thread block <b>4130</b>(BJ+1,1) can synchronize together and communicate through shared memory <b>4060</b>(2).</p><p id="p-0496" num="0471">In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>41</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>41</b></figref> are utilized to perform API to generate one or more graph code nodes to deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>41</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate and deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>41</b></figref> are utilized to implement one or more systems and/or processes such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>10</b></figref>.</p><p id="p-0497" num="0472"><figref idref="DRAWINGS">FIG. <b>42</b></figref> illustrates how to migrate existing CUDA code to Data Parallel C++ code, in accordance with at least one embodiment. Data Parallel C++ (DPC++) may refer to an open, standards-based alternative to single-architecture proprietary languages that allows developers to reuse code across hardware targets (CPUs and accelerators such as GPUs and FPGAs) and also perform custom tuning for a specific accelerator. DPC++ use similar and/or identical C and C++ constructs in accordance with ISO C++ which developers may be familiar with. DPC++ incorporates standard SYCL from The Khronos Group to support data parallelism and heterogeneous programming. SYCL refers to a cross-platform abstraction layer that builds on underlying concepts, portability and efficiency of OpenCL that enables code for heterogeneous processors to be written in a &#x201c;single-source&#x201d; style using standard C++. SYCL may enable single source development where C++ template functions can contain both host and device code to construct complex algorithms that use OpenCL acceleration, and then re-use them throughout their source code on different types of data.</p><p id="p-0498" num="0473">In at least one embodiment, a DPC++ compiler is used to compile DPC++ source code which can be deployed across diverse hardware targets. In at least one embodiment, a DPC++ compiler is used to generate DPC++ applications that can be deployed across diverse hardware targets and a DPC++ compatibility tool can be used to migrate CUDA applications to a multiplatform program in DPC++. In at least one embodiment, a DPC++ base tool kit includes a DPC++ compiler to deploy applications across diverse hardware targets; a DPC++ library to increase productivity and performance across CPUs, GPUs, and FPGAs; a DPC++ compatibility tool to migrate CUDA applications to multi-platform applications; and any suitable combination thereof.</p><p id="p-0499" num="0474">In at least one embodiment, a DPC++ programming model is utilized to simply one or more aspects relating to programming CPUs and accelerators by using modern C++ features to express parallelism with a programming language called Data Parallel C++. DPC++ programming language may be utilized to code reuse for hosts (e.g., a CPU) and accelerators (e.g., a GPU or FPGA) using a single source language, with execution and memory dependencies being clearly communicated. Mappings within DPC++ code can be used to transition an application to run on a hardware or set of hardware devices that best accelerates a workload. A host may be available to simplify development and debugging of device code, even on platforms that do not have an accelerator available.</p><p id="p-0500" num="0475">In at least one embodiment, CUDA source code <b>4200</b> is provided as an input to a DPC++ compatibility tool <b>4202</b> to generate human readable DPC++ <b>4204</b>. In at least one embodiment, human readable DPC++ <b>4204</b> includes inline comments generated by DPC++ compatibility tool <b>4202</b> that guides a developer on how and/or where to modify DPC++ code to complete coding and tuning to desired performance <b>4206</b>, thereby generating DPC++ source code <b>4208</b>.</p><p id="p-0501" num="0476">In at least one embodiment, CUDA source code <b>4200</b> is or includes a collection of human-readable source code in a CUDA programming language. In at least one embodiment, CUDA source code <b>4200</b> is human-readable source code in a CUDA programming language. In at least one embodiment, a CUDA programming language is an extension of the C++ programming language that includes, without limitation, mechanisms to define device code and distinguish between device code and host code. In at least one embodiment, device code is source code that, after compilation, is executable on a device (e.g., GPU or FPGA) and may include or more parallelizable workflows that can be executed on one or more processor cores of a device. In at least one embodiment, a device may be a processor that is optimized for parallel instruction processing, such as CUDA-enabled GPU, GPU, or another GPGPU, etc. In at least one embodiment, host code is source code that, after compilation, is executable on a host. In least one embodiment, some or all of host code and device code can be executed in parallel across a CPU and GPU/FPGA. In at least one embodiment, a host is a processor that is optimized for sequential instruction processing, such as CPU. CUDA source code <b>4200</b> described in connection with <figref idref="DRAWINGS">FIG. <b>42</b></figref> may be in accordance with those discussed elsewhere in this document.</p><p id="p-0502" num="0477">In at least one embodiment, DPC++ compatibility tool <b>4202</b> refers to an executable tool, program, application, or any other suitable type of tool that is used to facilitate migration of CUDA source code <b>4200</b> to DPC++ source code <b>4208</b>. In at least one embodiment, DPC++ compatibility tool <b>4202</b> is a command-line-based code migration tool available as part of a DPC++ tool kit that is used to port existing CUDA sources to DPC++. In at least one embodiment, DPC++ compatibility tool <b>4202</b> converts some or all source code of a CUDA application from CUDA to DPC++ and generates a resulting file that is written at least partially in DPC++, referred to as human readable DPC++ <b>4204</b>. In at least one embodiment, human readable DPC++ <b>4204</b> includes comments that are generated by DPC++ compatibility tool <b>4202</b> to indicate where user intervention may be necessary. In at least one embodiment, user intervention is necessary when CUDA source code <b>4200</b> calls a CUDA API that has no analogous DPC++ API; other examples where user intervention is required are discussed later in greater detail.</p><p id="p-0503" num="0478">In at least one embodiment, a workflow for migrating CUDA source code <b>4200</b> (e.g., application or portion thereof) includes creating one or more compilation database files; migrating CUDA to DPC++ using a DPC++ compatibility too<b>14202</b> ; completing migration and verifying correctness, thereby generating DPC++ source code <b>4208</b>; and compiling DPC++ source code <b>4208</b> with a DPC++ compiler to generate a DPC++ application. In at least one embodiment, a compatibility tool provides a utility that intercepts commands used when Makefile executes and stores them in a compilation database file. In at least one embodiment, a file is stored in JSON format. In at least one embodiment, an intercept-built command converts Makefile command to a DPC compatibility command.</p><p id="p-0504" num="0479">In at least one embodiment, intercept-build is a utility script that intercepts a build process to capture compilation options, macro defs, and include paths, and writes this data to a compilation database file. In at least one embodiment, a compilation database file is a JSON file. In at least one embodiment, DPC++ compatibility tool <b>4202</b> parses a compilation database and applies options when migrating input sources. In at least one embodiment, use of intercept-build is optional, but highly recommended for Make or CMake based environments. In at least one embodiment, a migration database includes commands, directories, and files: command may include necessary compilation flags; directory may include paths to header files; file may include paths to CUDA files.</p><p id="p-0505" num="0480">In at least one embodiment, DPC++ compatibility tool <b>4202</b> migrates CUDA code (e.g., applications) written in CUDA to DPC++ by generating DPC++ wherever possible. In at least one embodiment, DPC++ compatibility tool <b>4202</b> is available as part of a tool kit. In at least one embodiment, a DPC++ tool kit includes an intercept-build tool. In at least one embodiment, an intercept-built tool creates a compilation database that captures compilation commands to migrate CUDA files. In at least one embodiment, a compilation database generated by an intercept-built tool is used by DPC++ compatibility tool <b>4202</b> to migrate CUDA code to DPC++. In at least one embodiment, non-CUDA C++ code and files are migrated as is. In at least one embodiment, DPC++ compatibility tool <b>4202</b> generates human readable DPC++ <b>4204</b> which may be DPC++ code that, as generated by DPC++ compatibility tool <b>4202</b>, cannot be compiled by DPC++ compiler and requires additional plumbing for verifying portions of code that were not migrated correctly, and may involve manual intervention, such as by a developer. In at least one embodiment, DPC++ compatibility tool <b>4202</b> provides hints or tools embedded in code to help developers manually migrate additional code that could not be migrated automatically. In at least one embodiment, migration is a one-time activity for a source file, project, or application.</p><p id="p-0506" num="0481">In at least one embodiment, DPC++ compatibility tool <b>42002</b> is able to successfully migrate all portions of CUDA code to DPC++ and there may simply be an optional step for manually verifying and tuning performance of DPC++ source code that was generated. In at least one embodiment, DPC++ compatibility tool <b>4202</b> directly generates DPC++ source code <b>4208</b> which is compiled by a DPC++ compiler without requiring or utilizing human intervention to modify DPC++ code generated by DPC++ compatibility tool <b>4202</b>. In at least one embodiment, DPC++ compatibility tool generates compile-able DPC++ code which can be optionally tuned by a developer for performance, readability, maintainability, other various considerations; or any combination thereof.</p><p id="p-0507" num="0482">In at least one embodiment, one or more CUDA source files are migrated to DPC++ source files at least partially using DPC++ compatibility tool <b>4202</b>. In at least one embodiment, CUDA source code includes one or more header files which may include CUDA header files. In at least one embodiment, a CUDA source file includes a &#x3c;cuda.h&#x3e; header file and a &#x3c;stdio.h&#x3e; header file which can be used to print text. In at least one embodiment, a portion of a vector addition kernel CUDA source file may be written as or related to:</p><p id="p-0508" num="0000"><tables id="TABLE-US-00030" num="00030"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="21pt" align="left"/><colspec colname="2" colwidth="196pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;</entry><entry>#include &#x3c;cuda.h&#x3e;</entry></row><row><entry/><entry>#include &#x3c;stdio.h&#x3e;</entry></row><row><entry/><entry>#define VECTOR_SIZE 256</entry></row><row><entry/><entry>[ ] global_void VectorAddKernel(float* A, float* B, float* C)</entry></row><row><entry/><entry>{</entry></row><row><entry/><entry>&#x2003;A[threadIdx.x] = threadIdx.x + l.0f;</entry></row><row><entry/><entry>&#x2003;B[threadIdx.x] = threadIdx.x + l.0f;</entry></row><row><entry/><entry>&#x2003;C[threadIdx.x] = A[threadIdx.x] + B[threadIdx.x];</entry></row><row><entry/><entry>{</entry></row><row><entry/><entry>int main( )</entry></row><row><entry/><entry>{</entry></row><row><entry/><entry>&#x2003;float *d_A, *d_B, *d_C;</entry></row><row><entry/><entry>&#x2003;cudaMalloc(&#x26;d_A, VECTOR_SIZE*sizeof(float));</entry></row><row><entry/><entry>&#x2003;cudaMalloc(&#x26;d_B, VECTOR_SIZE*sizeof(float));</entry></row><row><entry/><entry>&#x2003;cudaMalloc(&#x26;d_C, VECTOR_SIZE*sizeof(float));</entry></row><row><entry/><entry>&#x2003;VectorAddKernel&#x3c;&#x3c;&#x3c;1, VECTOR_SIZE&#x3e;&#x3e;&#x3e;(d_A, d_B, d_C);</entry></row><row><entry/><entry>&#x2003;float Result[VECTOR_SIZE] = { };</entry></row><row><entry/><entry>&#x2003;cudaMemcpy(Result, d_C, VECTOR_SIZE*sizeof(float),</entry></row><row><entry/><entry>cudaMemcpyDeviceToHost);</entry></row><row><entry/><entry>&#x2003;cudaFree(d_A);</entry></row><row><entry/><entry>&#x2003;cudaFree(d_B);</entry></row><row><entry/><entry>&#x2003;cudaFree(d_C);</entry></row><row><entry/><entry>&#x2003;for (int i=0; i&#x3c;VECTOR_SIZE; i++ {</entry></row><row><entry/><entry>&#x2003;&#x2003;if (i % 16 == 0) {</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;printf(&#x2033;\n&#x2033;);</entry></row><row><entry/><entry>&#x2003;&#x2003;}</entry></row><row><entry/><entry>&#x2003;&#x2003;printf(&#x2033;%f &#x2033;, Result[i]);</entry></row><row><entry/><entry>&#x2003;}</entry></row><row><entry/><entry>&#x2003;return 0;</entry></row><row><entry/><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0509" num="0483">In at least one embodiment and in connection with CUDA source file presented above, DPC++ compatibility tool <b>4202</b> parses a CUDA source code and replaces header files with appropriate DPC++ and SYCL header files. In at least one embodiment, DPC++ header files includes helper declarations. In CUDA, there is a concept of a thread ID and correspondingly, in DPC++ or SYCL, for each element there is a local identifier.</p><p id="p-0510" num="0484">In at least one embodiment and in connection with CUDA source file presented above, there are two vectors A and B which are initialized and a vector addition result is put into vector C as part of VectorAddKernel( ). In at least one embodiment, DPC++ compatibility tool <b>4202</b> converts CUDA thread IDs used to index work elements to SYCL standard addressing for work elements via a local ID as part of migrating CUDA code to DPC++ code. In at least one embodiment, DPC++ code generated by DPC++ compatibility tool <b>4202</b> can be optimized&#x2014;for example, by reducing dimensionality of an nd_item, thereby increasing memory and/or processor utilization.</p><p id="p-0511" num="0485">In at least one embodiment and in connection with CUDA source file presented above, memory allocation is migrated. In at least one embodiment, cudaMalloc( ) is migrated to a unified shared memory SYCL call malloc _device( ) to which a device and context is passed, relying on SYCL concepts such as platform, device, context, and queue. In at least one embodiment, a SYCL platform can have multiple devices (e.g., host and GPU devices); a device may have multiple queues to which jobs can be submitted; each device may have a context; and a context may have multiple devices and manage shared memory objects.</p><p id="p-0512" num="0486">In at least one embodiment and in connection with CUDA source file presented above, a main( ) function invokes or calls VectorAddKernel( ) to add two vectors A and B together and store result in vector C. In at least one embodiment, CUDA code to invoke VectorAddKernel( ) is replaced by DPC++ code to submit a kernel to a command queue for execution. In at least one embodiment, a command group handler cgh passes data, synchronization, and computation that is submitted to the queue, parallel_for is called for a number of global elements and a number of work items in that work group where VectorAddKernel( ) is called.</p><p id="p-0513" num="0487">In at least one embodiment and in connection with CUDA source file presented above, CUDA calls to copy device memory and then free memory for vectors A, B, and C are migrated to corresponding DPC++ calls. In at least one embodiment, C++ code (e.g., standard ISO C++ code for printing a vector of floating point variables) is migrated as is, without being modified by DPC++ compatibility tool <b>4202</b>. In at least one embodiment, DPC++ compatibility tool <b>4202</b> modify CUDA APIs for memory setup and/or host calls to execute kernel on the acceleration device. In at least one embodiment and in connection with CUDA source file presented above, a corresponding human readable DPC++ <b>4204</b> (e.g., which can be compiled) is written as or related to:</p><p id="p-0514" num="0000"><tables id="TABLE-US-00031" num="00031"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="7pt" align="left"/><colspec colname="2" colwidth="210pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>#include &#x3c;CL/sycl.hpp&#x3e;</entry></row><row><entry/><entry>#include &#x3c;dpct/dpct.hpp&#x3e;</entry></row><row><entry/><entry>#define VECTOR_SIZE 256</entry></row><row><entry/><entry>void VectorAddKernel(float* A, float* B, float* C,</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;sycl::nd_item&#x3c;3&#x3e; item_ct1)</entry></row><row><entry/><entry>{</entry></row><row><entry/><entry>&#x2003;A[item_ct1.get_local_id(2)] = item_ct1.get_local_id(2) + l.0f;</entry></row><row><entry/><entry>&#x2003;B[item_ct1.get_local_id(2)] = item_ct1.get_local_id(2) + l.0f;</entry></row><row><entry/><entry>&#x2003;C[item_ct1.get_local_id(2)] =</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;A[item_ct1.get_local_id(2)] + B[item_ct1.get_local_id(2)];</entry></row><row><entry/><entry>}</entry></row><row><entry/><entry>int main( )</entry></row><row><entry/><entry>{</entry></row><row><entry/><entry>&#x2003;float *d_A, *d_B, *d_C;</entry></row><row><entry/><entry>&#x2003;d_A = (float *)sycl::malloc_device(VECTOR_SIZE * sizeof(float),</entry></row><row><entry/><entry>&#x2003;&#x2003;dpct::get_current_device( ),</entry></row><row><entry/><entry>&#x2003;&#x2003;dpct::get_default_context( ));</entry></row><row><entry/><entry>&#x2003;d_B = (float *)sycl::malloc_device(VECTOR_SIZE * sizeof(float),</entry></row><row><entry/><entry>&#x2003;&#x2003;dpct::get_current_device( ),</entry></row><row><entry/><entry>&#x2003;&#x2003;dpct::get_default_context( ));</entry></row><row><entry/><entry>&#x2003;d_C = (float *)sycl::malloc_device(VECTOR_SIZE * sizeof(float),</entry></row><row><entry/><entry>&#x2003;&#x2003;dpct::get_current_device( ),</entry></row><row><entry/><entry>&#x2003;&#x2003;dpct::get_default_context( ));</entry></row><row><entry/><entry>&#x2003;dpct::get_default_queue_wait( ).submit([&#x26;](sycl::handler &#x26;cgh) {</entry></row><row><entry/><entry>&#x2003;&#x2003;cgh.parallel_for(</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;sycl::nd_range&#x3c;3&#x3e;(sycl::range&#x3c;3&#x3e;(l, 1, 1) *</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;sycl::range&#x3c;3&#x3e;(l, 1, VECTOR SIZE) *</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;sycl::range&#x3c;3&#x3e;(l, 1, VECTOR SIZE)),</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;[=](sycl::nd_items&#x3c;3&#x3e; item_ctl) {</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;VectorAddKernel(d_A, d_B, d_C, item ct1);</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;});</entry></row><row><entry/><entry>&#x2003;});</entry></row><row><entry/><entry>&#x2003;float Result[VECTOR_SIZE] = { };</entry></row><row><entry/><entry>&#x2003;dpct::get_default_queue_wait( )</entry></row><row><entry/><entry>&#x2003;&#x2003;.memcpy(Result, d_C, VECTOR SIZE * sizeof(float))</entry></row><row><entry/><entry>&#x2003;&#x2003;.wait( );</entry></row><row><entry/><entry>&#x2003;sycl::free(d_A, dpct::get_default_context( ));</entry></row><row><entry/><entry>&#x2003;sycl::free(d_B, dpct::get_default_context( ));</entry></row><row><entry/><entry>&#x2003;sycl::free(d_C, dpct::get_default_context( ));</entry></row><row><entry/><entry>&#x2003;for (int i=0; i&#x3c;VECTOR_SIZE; i++ {</entry></row><row><entry/><entry>&#x2003;&#x2003;if (i % 16 == 0) {</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;printf(&#x2033;\n&#x2033;);</entry></row><row><entry/><entry>&#x2003;&#x2003;}</entry></row><row><entry/><entry>&#x2003;&#x2003;printf(&#x2033;%f&#x2033;, Result[i]);</entry></row><row><entry/><entry>&#x2003;}</entry></row><row><entry/><entry>&#x2003;return 0;</entry></row><row><entry/><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0515" num="0488">In at least one embodiment, human readable DPC++ <b>4204</b> refers to output generated by DPC++ compatibility tool <b>4202</b> and may be optimized in one manner or another. In at least one embodiment, human readable DPC++ <b>4204</b> generated by DPC++ compatibility tool <b>4202</b> can be manually edited by a developer after migration to make it more maintainable, performance, or other considerations. In at least one embodiment, DPC++ code generated by DPC++ compatibility tool <b>42002</b> such as DPC++ disclosed can be optimized by removing repeat calls to get_current_device( ) and/or get_default_context( ) for each malloc_device( ) call. In at least one embodiment, DPC++ code generated above uses a 3 dimensional nd_range which can be refactored to use only a single dimension, thereby reducing memory usage. In at least one embodiment, a developer can manually edit DPC++ code generated by DPC++ compatibility tool <b>4202</b> replace uses of unified shared memory with accessors. In at least one embodiment, DPC++ compatibility tool <b>4202</b> has an option to change how it migrates CUDA code to DPC++ code. In at least one embodiment, DPC++ compatibility tool <b>4202</b> is verbose because it is using a general template to migrate CUDA code to DPC++ code that works for a large number of cases.</p><p id="p-0516" num="0489">In at least one embodiment, a CUDA to DPC++ migration workflow includes steps to: prepare for migration using intercept-build script; perform migration of CUDA projects to DPC++ using DPC++ compatibility tool <b>4202</b>; review and edit migrated source files manually for completion and correctness; and compile final DPC++ code to generate a DPC++ application. In at least one embodiment, manual review of DPC++ source code may be required in one or more scenarios including but not limited to: migrated API does not return error code (CUDA code can return an error code which can then be consumed by the application but SYCL uses exceptions to report errors, and therefore does not use error codes to surface errors); CUDA compute capability dependent logic is not supported by DPC++; statement could not be removed. In at least one embodiment, scenarios in which DPC++ code requires manual intervention may include, without limitation: error code logic replaced with (*,0) code or commented out; equivalent DPC++ API not available; CUDA compute capability-dependent logic; hardware-dependent API (clock( )); missing features unsupported API; execution time measurement logic; handling built-in vector type conflicts; migration of cuBLAS API; and more.</p><p id="p-0517" num="0490">In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>42</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>42</b></figref> are utilized to perform API to generate one or more graph code nodes to deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>42</b></figref> are utilized to perform API to generate one or more graph code nodes to allocate and deallocate memory. In at least one embodiment, one or more systems depicted in <figref idref="DRAWINGS">FIG. <b>42</b></figref> are utilized to implement one or more systems and/or processes such as those described in connection with <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>10</b></figref>.</p><p id="p-0518" num="0491">In at least one embodiment, one or more techniques described herein utilize a oneAPI programming model. In at least one embodiment, a oneAPI programming model refers to a programming model for interacting with various compute accelerator architectures. In at least one embodiment, oneAPI refers to an application programming interface (API) designed to interact with various compute accelerator architectures. In at least one embodiment, a oneAPI programming model utilizes a DPC++ programming language. In at least one embodiment, a DPC++ programming language refers to a high-level language for data parallel programming productivity. In at least one embodiment, a DPC++ programming language is based at least in part on C and/or C++ programming languages. In at least one embodiment, a oneAPI programming model is a programming model such as those developed by Intel Corporation of Santa Clara, Calif.</p><p id="p-0519" num="0492">In at least one embodiment, oneAPI and/or oneAPI programming model is utilized to interact with various accelerator, GPU, processor, and/or variations thereof, architectures. In at least one embodiment, oneAPI includes a set of libraries that implement various functionalities. In at least one embodiment, oneAPI includes at least a oneAPI DPC++ library, a oneAPI math kernel library, a oneAPI data analytics library, a oneAPI deep neural network library, a oneAPI collective communications library, a oneAPI threading building blocks library, a oneAPI video processing library, and/or variations thereof.</p><p id="p-0520" num="0493">In at least one embodiment, a oneAPI DPC++ library, also referred to as oneDPL, is a library that implements algorithms and functions to accelerate DPC++ kernel programming. In at least one embodiment, oneDPL implements one or more standard template library (STL) functions. In at least one embodiment, oneDPL implements one or more parallel STL functions. In at least one embodiment, oneDPL provides a set of library classes and functions such as parallel algorithms, iterators, function object classes, range-based API, and/or variations thereof. In at least one embodiment, oneDPL implements one or more classes and/or functions of a C++ standard library. In at least one embodiment, oneDPL implements one or more random number generator functions.</p><p id="p-0521" num="0494">In at least one embodiment, a oneAPI math kernel library, also referred to as oneMKL, is a library that implements various optimized and parallelized routines for various mathematical functions and/or operations. In at least one embodiment, oneMKL implements one or more basic linear algebra subprograms (BLAS) and/or linear algebra package (LAPACK) dense linear algebra routines. In at least one embodiment, oneMKL implements one or more sparse BLAS linear algebra routines. In at least one embodiment, oneMKL implements one or more random number generators (RNGs). In at least one embodiment, oneMKL implements one or more vector mathematics (VM) routines for mathematical operations on vectors. In at least one embodiment, oneMKL implements one or more Fast Fourier Transform (FFT) functions.</p><p id="p-0522" num="0495">In at least one embodiment, a oneAPI data analytics library, also referred to as oneDAL, is a library that implements various data analysis applications and distributed computations. In at least one embodiment, oneDAL implements various algorithms for preprocessing, transformation, analysis, modeling, validation, and decision making for data analytics, in batch, online, and distributed processing modes of computation. In at least one embodiment, oneDAL implements various C++ and/or Java APIs and various connectors to one or more data sources. In at least one embodiment, oneDAL implements DPC++ API extensions to a traditional C++ interface and enables GPU usage for various algorithms.</p><p id="p-0523" num="0496">In at least one embodiment, a oneAPI deep neural network library, also referred to as oneDNN, is a library that implements various deep learning functions. In at least one embodiment, oneDNN implements various neural network, machine learning, and deep learning functions, algorithms, and/or variations thereof.</p><p id="p-0524" num="0497">In at least one embodiment, a oneAPI collective communications library, also referred to as oneCCL, is a library that implements various applications for deep learning and machine learning workloads. In at least one embodiment, oneCCL is built upon lower-level communication middleware, such as message passing interface (MPI) and libfabrics. In at least one embodiment, oneCCL enables a set of deep learning specific optimizations, such as prioritization, persistent operations, out of order executions, and/or variations thereof. In at least one embodiment, oneCCL implements various CPU and GPU functions.</p><p id="p-0525" num="0498">In at least one embodiment, a oneAPI threading building blocks library, also referred to as oneTBB, is a library that implements various parallelized processes for various applications. In at least one embodiment, oneTBB is utilized for task-based, shared parallel programming on a host. In at least one embodiment, oneTBB implements generic parallel algorithms. In at least one embodiment, oneTBB implements concurrent containers. In at least one embodiment, oneTBB implements a scalable memory allocator. In at least one embodiment, oneTBB implements a work-stealing task scheduler. In at least one embodiment, oneTBB implements low-level synchronization primitives. In at least one embodiment, oneTBB is compiler-independent and usable on various processors, such as GPUs, PPUs, CPUs, and/or variations thereof.</p><p id="p-0526" num="0499">In at least one embodiment, a oneAPI video processing library, also referred to as oneVPL, is a library that is utilized for accelerating video processing in one or more applications. In at least one embodiment, oneVPL implements various video decoding, encoding, and processing functions. In at least one embodiment, oneVPL implements various functions for media pipelines on CPUs, GPUs, and other accelerators. In at least one embodiment, oneVPL implements device discovery and selection in media centric and video analytics workloads. In at least one embodiment, oneVPL implements API primitives for zero-copy buffer sharing.</p><p id="p-0527" num="0500">In at least one embodiment, a oneAPI programming model utilizes a DPC++ programming language. In at least one embodiment, a DPC++ programming language is a programming language that includes, without limitation, functionally similar versions of CUDA mechanisms to define device code and distinguish between device code and host code. In at least one embodiment, a DPC++ programming language may include a subset of functionality of a CUDA programming language. In at least one embodiment, one or more CUDA programming model operations are performed using a oneAPI programming model using a DPC++ programming language.</p><p id="p-0528" num="0501">It should be noted that, while example embodiments described herein may relate to a CUDA programming model, techniques described herein can be utilized with any suitable programming model, such HIP, oneAPI, and/or variations thereof.</p><p id="p-0529" num="0502">At least one embodiment of the disclosure can be described in view of the following clauses:</p><p id="p-0530" num="0503">Clause 1. A processor, comprising:</p><p id="p-0531" num="0504">one or more circuits to perform an application programming interface (API) to generate one or more graph code nodes to allocate memory.</p><p id="p-0532" num="0505">Clause 2. The processor of clause 1, wherein the one or more circuits are further to:</p><p id="p-0533" num="0506">obtain code indicating at least the API; and</p><p id="p-0534" num="0507">perform the API by at least executing the code.</p><p id="p-0535" num="0508">Clause 3. The processor of any of clauses 1-2, wherein the one or more circuits are further to:</p><p id="p-0536" num="0509">generate a graph data structure; and</p><p id="p-0537" num="0510">generate the one or more graph code nodes as part of the graph data structure.</p><p id="p-0538" num="0511">Clause 4. The processor of any of clauses 1-3, wherein the one or more circuits are further to perform the API based at least in part on one or more parameter values indicating at least properties of the memory to be allocated.</p><p id="p-0539" num="0512">Clause 5. The processor of any of clauses 1-4, wherein the one or more graph code nodes to allocate the memory correspond to a set of graph code nodes to deallocate the memory.</p><p id="p-0540" num="0513">Clause 6. The processor of any of clauses 1-5, wherein the one or more circuits are further to cause a graphics processing unit (GPU) to allocate the memory based at least in part on the one or more graph code nodes.</p><p id="p-0541" num="0514">Clause 7. The processor of any of clauses 1-6, wherein the one or more circuits are further to cause one or more devices to perform one or more operations using the memory.</p><p id="p-0542" num="0515">Clause 8. A system, comprising:</p><p id="p-0543" num="0516">one or more computers having one or more processors to perform an application programming interface (API) to generate one or more graph code nodes to allocate memory.</p><p id="p-0544" num="0517">Clause 9. The system of clause 8, wherein the one or more processors are further to perform the API based at least in part on a set of parameter values indicating at least a size of the memory to be allocated.</p><p id="p-0545" num="0518">Clause 10. The system of any of clauses 8-9, wherein the one or more processors are further to cause a parallel processing unit (PPU) to allocate the memory using the one or more graph code nodes.</p><p id="p-0546" num="0519">Clause 11. The system of any of clauses 8-10, wherein the one or more graph code nodes encode properties of the allocated memory.</p><p id="p-0547" num="0520">Clause 12. The system of any of clauses 8-11, wherein the one or more processors are further to:</p><p id="p-0548" num="0521">obtain a graph data structure indicating one or more operations; and</p><p id="p-0549" num="0522">cause one or more devices to use the graph data structure to perform the one or more operations using the allocated memory.</p><p id="p-0550" num="0523">Clause 13. The system of any of clauses 8-12, wherein the API is a runtime API.</p><p id="p-0551" num="0524">Clause 14. A machine-readable medium having stored thereon a set of instructions, which if performed by one or more processors, cause the one or more processors to at least:</p><p id="p-0552" num="0525">perform an application programming interface (API) to generate one or more graph code nodes to allocate memory.</p><p id="p-0553" num="0526">Clause 15. The machine-readable medium of clause 14, wherein the set of instructions further include instructions, which if performed by the one or more processors, cause the one or more processors to generate the one or more graph code nodes as part of a graph data structure.</p><p id="p-0554" num="0527">Clause 16. The machine-readable medium of any of clauses 14-15, wherein the set of instructions further include instructions, which if performed by the one or more processors, cause the one or more processors to obtain code comprising parameter values for the API.</p><p id="p-0555" num="0528">Clause 17. The machine-readable medium of any of clauses 14-16, wherein the one or more graph code nodes are data objects that encode information regarding memory allocation, and further wherein the information is calculated based at least in part on one or more parameter values.</p><p id="p-0556" num="0529">Clause 18. The machine-readable medium of any of clauses 14-17, wherein the API is a driver API.</p><p id="p-0557" num="0530">Clause 19. The machine-readable medium of any of clauses 14-18, wherein the set of instructions further include instructions, which if performed by the one or more processors, cause the one or more processors to:</p><p id="p-0558" num="0531">generate the one or more graph code nodes as part of a first graph data structure;</p><p id="p-0559" num="0532">cause the memory to be allocated based at least in part on the one or more graph code nodes;</p><p id="p-0560" num="0533">obtain a second graph data structure indicating one or more operations; and</p><p id="p-0561" num="0534">cause one or more devices to perform the one or more operations utilizing the allocated memory.</p><p id="p-0562" num="0535">Clause 20. The machine-readable medium of any of clauses 14-19, wherein the set of instructions further include instructions, which if performed by the one or more processors, cause the one or more processors to cause a general-purpose graphics processing unit (GPGPU) to allocate the memory using the one or more graph code nodes.</p><p id="p-0563" num="0536">Clause 21. A processor, comprising:</p><p id="p-0564" num="0537">one or more circuits to perform an application programming interface (API) to generate one or more graph code nodes to allocate and deallocate memory.</p><p id="p-0565" num="0538">Clause 22. The processor of clause 21, wherein the one or more circuits are further to:</p><p id="p-0566" num="0539">generate a first graph code node to allocate the memory; and</p><p id="p-0567" num="0540">generate a second graph code node to deallocate the memory.</p><p id="p-0568" num="0541">Clause 23. The processor of any of clauses 21-22, wherein the one or more graph code nodes are part of a first graph data structure.</p><p id="p-0569" num="0542">Clause 24. The processor any of clauses 21-23, wherein the one or more circuits are further to cause a device to allocate the memory based at least in part on an identified memory region.</p><p id="p-0570" num="0543">Clause 25. The processor of any of clauses 21-24, wherein the one or more circuits are further to perform the API based at least in part on parameter values indicating constraints for allocating and deallocating the memory.</p><p id="p-0571" num="0544">Clause 26. The processor of any of clauses 21-25, wherein the one or more circuits are further to cause one or more devices to use the memory to perform a set of operations.</p><p id="p-0572" num="0545">Clause 27. A machine-readable medium having stored thereon a set of instructions, which if performed by one or more processors, cause the one or more processors to at least:</p><p id="p-0573" num="0546">perform an application programming interface (API) to generate one or more graph code nodes to allocate and deallocate memory.</p><p id="p-0574" num="0547">Clause 28. The machine-readable medium of clause 27, wherein the set of instructions further include instructions, which if performed by the one or more processors, cause the one or more processors to:</p><p id="p-0575" num="0548">obtain code indicating at least the API to generate the one or more graph code nodes to allocate and deallocate the memory; and</p><p id="p-0576" num="0549">execute the code to perform the API to generate the one or more graph code nodes to allocate and deallocate the memory, wherein the one or more graph code nodes comprise a first node for allocating memory and a second node for deallocating memory.</p><p id="p-0577" num="0550">Clause 29. The machine-readable medium of any of clauses 27-28, wherein a first node of the one or more graph code nodes is part of a first graph data structure and a second node of the one or more graph code nodes is part of a second graph data structure.</p><p id="p-0578" num="0551">Clause 30. The machine-readable medium of any of clauses 27-29, wherein the set of instructions further include instructions, which if performed by the one or more processors, cause the one or more processors to cause a central processing unit (CPU) to use the one or more graph code nodes to allocate and deallocate the memory.</p><p id="p-0579" num="0552">Clause 31. The machine-readable medium of any of clauses 27-30, wherein the set of instructions further include instructions, which if performed by the one or more processors, cause the one or more processors to:</p><p id="p-0580" num="0553">calculate a first set of operations; and</p><p id="p-0581" num="0554">cause one or more devices to use the memory to perform the first set of operations.</p><p id="p-0582" num="0555">Clause 32. The machine-readable medium of any of clauses 27-31, wherein the set of instructions further include instructions, which if performed by the one or more processors, cause the one or more processors to cause one or more devices to perform one or more operations indicated by a graph data structure comprising at least one of the one or more graph code nodes.</p><p id="p-0583" num="0556">At least one embodiment of the disclosure can be described in view of the following clauses:</p><p id="p-0584" num="0557">Clause 1. A processor, comprising:</p><p id="p-0585" num="0558">one or more circuits to perform an application programming interface (API) to generate one or more graph code nodes to deallocate memory.</p><p id="p-0586" num="0559">Clause 2. The processor of clause 1, wherein the one or more circuits are further to perform the API as part of execution of code indicating at least generation of the one or more graph code nodes to deallocate the memory.</p><p id="p-0587" num="0560">Clause 3. The processor of any of clauses 1-2, wherein the one or more circuits are further to generate the one or more graph code nodes as part of a graph data structure.</p><p id="p-0588" num="0561">Clause 4. The processor of any of clauses 1-3, wherein the one or more circuits are further to cause a device to perform a set of operations indicated by one or more graph data structures using the memory.</p><p id="p-0589" num="0562">Clause 5. The processor of any of clauses 1-4, wherein the one or more circuits are further to cause a graphics processing unit (GPU) to deallocate the memory using the one or more graph code nodes.</p><p id="p-0590" num="0563">Clause 6. The processor of any of clauses 1-5, wherein the one or more graph code nodes encode properties of the memory to be deallocated.</p><p id="p-0591" num="0564">Clause 7. The processor of any of clauses 1-6, wherein one or more circuits are further to perform the API based at least in part on one or more parameter values indicating at least an address for the memory to be deallocated.</p><p id="p-0592" num="0565">Clause 8. A system, comprising:</p><p id="p-0593" num="0566">one or more computers having one or more processors to perform an application programming interface (API) to generate one or more graph code nodes to deallocate memory.</p><p id="p-0594" num="0567">Clause 9. The system of clause 8, wherein the one or more processors are further to cause one or more devices to perform one or more operations using the memory.</p><p id="p-0595" num="0568">Clause 10. The system of any of clauses 8-9, wherein the one or more processors are further to cause a parallel processing unit (PPU) to deallocate the memory using the one or more graph code nodes.</p><p id="p-0596" num="0569">Clause 11. The system of any of clauses 8-10, wherein the one or more processors are further to perform the API based on at least in part on a set of parameter values indicating at least a graph data structure to generate the one or more graph code nodes for.</p><p id="p-0597" num="0570">Clause 12. The system of any of clauses 8-11, wherein the API is a runtime API.</p><p id="p-0598" num="0571">Clause 13. The system of any of clauses 8-12, wherein the one or more processors are further to cause one or more devices to allocate the memory based at least in part on one or more other graph code nodes part of a graph data structure.</p><p id="p-0599" num="0572">Clause 14. A machine-readable medium having stored thereon a set of instructions, which if performed by one or more processors, cause the one or more processors to at least:</p><p id="p-0600" num="0573">perform an application programming interface (API) to generate one or more graph code nodes to deallocate memory.</p><p id="p-0601" num="0574">Clause 15. The machine-readable medium of clause 14, wherein the set of instructions further include instructions, which if performed by the one or more processors, cause the one or more processors to perform the API based at least in part on parameter values for the API indicated in code.</p><p id="p-0602" num="0575">Clause 16. The machine-readable medium of any of clauses 14-15, wherein the one or more graph code nodes encode data associated with memory deallocation, and further wherein the data is calculated based at least in part on one or more parameter values.</p><p id="p-0603" num="0576">Clause 17. The machine-readable medium of any of clauses 14-16, wherein the set of instructions further include instructions, which if performed by the one or more processors, cause the one or more processors to:</p><p id="p-0604" num="0577">obtain a graph data structure; and</p><p id="p-0605" num="0578">generate the one or more graph code nodes as part of the graph data structure.</p><p id="p-0606" num="0579">Clause 18. The machine-readable medium of any of clauses 14-17, wherein the API is a driver API.</p><p id="p-0607" num="0580">Clause 19. The machine-readable medium of any of clauses 14-18, wherein the set of instructions further include instructions, which if performed by the one or more processors, cause the one or more processors to:</p><p id="p-0608" num="0581">obtain a first graph data structure indicating one or more operations;</p><p id="p-0609" num="0582">cause one or more devices to perform the one or more operations utilizing the memory;</p><p id="p-0610" num="0583">cause the one or more devices to deallocate the memory using the one or more graph code nodes.</p><p id="p-0611" num="0584">Clause 20. The machine-readable medium of any of clauses 14-19, wherein the set of instructions further include instructions, which if performed by the one or more processors, cause the one or more processors to cause a general-purpose graphics processing unit (GPGPU) to deallocate the memory based at least in part on a graph data structure comprising the one or more graph code nodes.</p><p id="p-0612" num="0585">Clause 21. A processor, comprising:</p><p id="p-0613" num="0586">one or more circuits to perform an application programming interface (API) to generate one or more graph code nodes to allocate and deallocate memory.</p><p id="p-0614" num="0587">Clause 22. The processor of clause 21, wherein the one or more circuits are further to:</p><p id="p-0615" num="0588">generate a first graph code node as part of a graph data structure; and</p><p id="p-0616" num="0589">generate a second graph code node as part of the graph data structure.</p><p id="p-0617" num="0590">Clause 23. The processor of any of clauses 21-22, wherein the one or more circuits are further to:</p><p id="p-0618" num="0591">cause one or more devices to use a first graph code node of the one or more graph code nodes to allocate the memory; and</p><p id="p-0619" num="0592">cause the one or more devices to use a second graph code node of the one or more graph code nodes to deallocate the memory.</p><p id="p-0620" num="0593">Clause 24. The processor of any of clauses 21-23, wherein the one or more circuits are further to perform the API based at least in part on parameter values indicated in code.</p><p id="p-0621" num="0594">Clause 25. The processor of any of clauses 21-24, wherein parameter values for the API comprise properties of the memory to be allocated and deallocated.</p><p id="p-0622" num="0595">Clause 26. The processor of any of clauses 21-25, wherein the one or more circuits are further to cause a device to deallocate the memory based at least in part on an identified memory location.</p><p id="p-0623" num="0596">Clause 27. A machine-readable medium having stored thereon a set of instructions, which if performed by one or more processors, cause the one or more processors to at least:</p><p id="p-0624" num="0597">perform an application programming interface (API) to generate one or more graph code nodes to allocate and deallocate memory.</p><p id="p-0625" num="0598">Clause 28. The machine-readable medium of clause 27, wherein the set of instructions further include instructions, which if performed by the one or more processors, cause the one or more processors to execute code to perform the API to generate the one or more graph code nodes to allocate and deallocate the memory, wherein a first node of the one or more graph code nodes is part of a first graph data structure and a second node of the one or more graph code nodes is part of a second graph data structure.</p><p id="p-0626" num="0599">Clause 29. The machine-readable medium of any of clauses 27-28, wherein the set of instructions further include instructions, which if performed by the one or more processors, cause the one or more processors to:</p><p id="p-0627" num="0600">cause one or more devices to allocate the memory using a first graph data structure; and</p><p id="p-0628" num="0601">cause the one or more devices to deallocate the memory using a second graph data structure.</p><p id="p-0629" num="0602">Clause 30. The machine-readable medium of any of clauses 27-29, wherein the set of instructions further include instructions, which if performed by the one or more processors, cause the one or more processors to cause a central processing unit (CPU) to use the one or more graph code nodes to allocate and deallocate the memory.</p><p id="p-0630" num="0603">Clause 31. The machine-readable medium of any of clauses 27-30, wherein the set of instructions further include instructions, which if performed by the one or more processors, cause the one or more processors to perform another API to cause one or more devices to use the memory to perform one or more operations.</p><p id="p-0631" num="0604">Clause 32. The machine-readable medium of any of clauses 27-31, wherein the set of instructions further include instructions, which if performed by the one or more processors, cause the one or more processors to generate the one or more graph code nodes by at least generating one or more data objects encoding information regarding allocating and deallocating the memory.</p><p id="p-0632" num="0605">Other variations are within spirit of present disclosure. Thus, while disclosed techniques are susceptible to various modifications and alternative constructions, certain illustrated embodiments thereof are shown in drawings and have been described above in detail. It should be understood, however, that there is no intention to limit disclosure to specific form or forms disclosed, but on contrary, intention is to cover all modifications, alternative constructions, and equivalents falling within spirit and scope of disclosure, as defined in appended claims.</p><p id="p-0633" num="0606">Use of terms &#x201c;a&#x201d; and &#x201c;an&#x201d; and &#x201c;the&#x201d; and similar referents in context of describing disclosed embodiments (especially in context of following claims) are to be construed to cover both singular and plural, unless otherwise indicated herein or clearly contradicted by context, and not as a definition of a term. Terms &#x201c;comprising,&#x201d; &#x201c;having,&#x201d; &#x201c;including,&#x201d; and &#x201c;containing&#x201d; are to be construed as open-ended terms (meaning &#x201c;including, but not limited to,&#x201d;) unless otherwise noted. term &#x201c;connected,&#x201d; when unmodified and referring to physical connections, is to be construed as partly or wholly contained within, attached to, or joined together, even if there is something intervening. Recitation of ranges of values herein are merely intended to serve as a shorthand method of referring individually to each separate value falling within range, unless otherwise indicated herein and each separate value is incorporated into specification as if it were individually recited herein. Use of term &#x201c;set&#x201d; (e.g., &#x201c;a set of items&#x201d;) or &#x201c;subset&#x201d; unless otherwise noted or contradicted by context, is to be construed as a nonempty collection comprising one or more members. Further, unless otherwise noted or contradicted by context, term &#x201c;subset&#x201d; of a corresponding set does not necessarily denote a proper subset of corresponding set, but subset and corresponding set may be equal.</p><p id="p-0634" num="0607">Conjunctive language, such as phrases of form &#x201c;at least one of A, B, and C,&#x201d; or &#x201c;at least one of A, B and C,&#x201d; unless specifically stated otherwise or otherwise clearly contradicted by context, is otherwise understood with context as used in general to present that an item, term, etc., may be either A or B or C, or any nonempty subset of set of A and B and C. For instance, in illustrative example of a set having three members, conjunctive phrases &#x201c;at least one of A, B, and C&#x201d; and &#x201c;at least one of A, B and C&#x201d; refer to any of following sets: {A}, {B}, {C}, {A, B}, {A, C}, {B, C}, {A, B, C}. Thus, such conjunctive language is not generally intended to imply that certain embodiments require at least one of A, at least one of B and at least one of C each to be present. In addition, unless otherwise noted or contradicted by context, term &#x201c;plurality&#x201d; indicates a state of being plural (e.g., &#x201c;a plurality of items&#x201d; indicates multiple items). A number of items in a plurality is at least two, but can be more when so indicated either explicitly or by context. Further, unless stated otherwise or otherwise clear from context, phrase &#x201c;based on&#x201d; means &#x201c;based at least in part on&#x201d; and not &#x201c;based solely on.&#x201d;</p><p id="p-0635" num="0608">Operations of processes described herein can be performed in any suitable order unless otherwise indicated herein or otherwise clearly contradicted by context. In at least one embodiment, a process such as those processes described herein (or variations and/or combinations thereof) is performed under control of one or more computer systems configured with executable instructions and is implemented as code (e.g., executable instructions, one or more computer programs or one or more applications) executing collectively on one or more processors, by hardware or combinations thereof. In at least one embodiment, code is stored on a computer-readable storage medium, for example, in form of a computer program comprising a plurality of instructions executable by one or more processors. In at least one embodiment, a computer-readable storage medium is a non-transitory computer-readable storage medium that excludes transitory signals (e.g., a propagating transient electric or electromagnetic transmission) but includes non-transitory data storage circuitry (e.g., buffers, cache, and queues) within transceivers of transitory signals. In at least one embodiment, code (e.g., executable code or source code) is stored on a set of one or more non-transitory computer-readable storage media having stored thereon executable instructions (or other memory to store executable instructions) that, when executed (e.g., as a result of being executed) by one or more processors of a computer system, cause computer system to perform operations described herein. A set of non-transitory computer-readable storage media, in at least one embodiment, comprises multiple non-transitory computer-readable storage media and one or more of individual non-transitory storage media of multiple non-transitory computer-readable storage media lack all of code while multiple non-transitory computer-readable storage media collectively store all of code. In at least one embodiment, executable instructions are executed such that different instructions are executed by different processors&#x2014;for example, a non-transitory computer-readable storage medium store instructions and a main central processing unit (&#x201c;CPU&#x201d;) executes some of instructions while a graphics processing unit (&#x201c;GPU&#x201d;) executes other instructions. In at least one embodiment, different components of a computer system have separate processors and different processors execute different subsets of instructions.</p><p id="p-0636" num="0609">Accordingly, in at least one embodiment, computer systems are configured to implement one or more services that singly or collectively perform operations of processes described herein and such computer systems are configured with applicable hardware and/or software that enable performance of operations. Further, a computer system that implements at least one embodiment of present disclosure is a single device and, in another embodiment, is a distributed computer system comprising multiple devices that operate differently such that distributed computer system performs operations described herein and such that a single device does not perform all operations.</p><p id="p-0637" num="0610">Use of any and all examples, or exemplary language (e.g., &#x201c;such as&#x201d;) provided herein, is intended merely to better illuminate embodiments of disclosure and does not pose a limitation on scope of disclosure unless otherwise claimed. No language in specification should be construed as indicating any non-claimed element as essential to practice of disclosure.</p><p id="p-0638" num="0611">All references, including publications, patent applications, and patents, cited herein are hereby incorporated by reference to same extent as if each reference were individually and specifically indicated to be incorporated by reference and were set forth in its entirety herein.</p><p id="p-0639" num="0612">In description and claims, terms &#x201c;coupled&#x201d; and &#x201c;connected,&#x201d; along with their derivatives, may be used. It should be understood that these terms may be not intended as synonyms for each other. Rather, in particular examples, &#x201c;connected&#x201d; or &#x201c;coupled&#x201d; may be used to indicate that two or more elements are in direct or indirect physical or electrical contact with each other. &#x201c;Coupled&#x201d; may also mean that two or more elements are not in direct contact with each other, but yet still co-operate or interact with each other.</p><p id="p-0640" num="0613">Unless specifically stated otherwise, it may be appreciated that throughout specification terms such as &#x201c;processing,&#x201d; &#x201c;computing,&#x201d; &#x201c;calculating,&#x201d; &#x201c;determining,&#x201d; or like, refer to action and/or processes of a computer or computing system, or similar electronic computing device, that manipulate and/or transform data represented as physical, such as electronic, quantities within computing system's registers and/or memories into other data similarly represented as physical quantities within computing system's memories, registers or other such information storage, transmission or display devices.</p><p id="p-0641" num="0614">In a similar manner, term &#x201c;processor&#x201d; may refer to any device or portion of a device that processes electronic data from registers and/or memory and transform that electronic data into other electronic data that may be stored in registers and/or memory. As non-limiting examples, &#x201c;processor&#x201d; may be a CPU or a GPU. A &#x201c;computing platform&#x201d; may comprise one or more processors. As used herein, &#x201c;software&#x201d; processes may include, for example, software and/or hardware entities that perform work over time, such as tasks, threads, and intelligent agents. Also, each process may refer to multiple processes, for carrying out instructions in sequence or in parallel, continuously or intermittently. Terms &#x201c;system&#x201d; and &#x201c;method&#x201d; are used herein interchangeably insofar as system may embody one or more methods and methods may be considered a system.</p><p id="p-0642" num="0615">In at least one embodiment, an arithmetic logic unit is a set of combinational logic circuitry that takes one or more inputs to produce a result. In at least one embodiment, an arithmetic logic unit is used by a processor to implement mathematical operation such as addition, subtraction, or multiplication. In at least one embodiment, an arithmetic logic unit is used to implement logical operations such as logical AND/OR or XOR. In at least one embodiment, an arithmetic logic unit is stateless, and made from physical switching components such as semiconductor transistors arranged to form logical gates. In at least one embodiment, an arithmetic logic unit may operate internally as a stateful logic circuit with an associated clock. In at least one embodiment, an arithmetic logic unit may be constructed as an asynchronous logic circuit with an internal state not maintained in an associated register set. In at least one embodiment, an arithmetic logic unit is used by a processor to combine operands stored in one or more registers of the processor and produce an output that can be stored by the processor in another register or a memory location.</p><p id="p-0643" num="0616">In at least one embodiment, as a result of processing an instruction retrieved by the processor, the processor presents one or more inputs or operands to an arithmetic logic unit, causing the arithmetic logic unit to produce a result based at least in part on an instruction code provided to inputs of the arithmetic logic unit. In at least one embodiment, the instruction codes provided by the processor to the ALU are based at least in part on the instruction executed by the processor. In at least one embodiment combinational logic in the ALU processes the inputs and produces an output which is placed on a bus within the processor. In at least one embodiment, the processor selects a destination register, memory location, output device, or output storage location on the output bus so that clocking the processor causes the results produced by the ALU to be sent to the desired location.</p><p id="p-0644" num="0617">In present document, references may be made to obtaining, acquiring, receiving, or inputting analog or digital data into a subsystem, computer system, or computer-implemented machine. Process of obtaining, acquiring, receiving, or inputting analog and digital data can be accomplished in a variety of ways such as by receiving data as a parameter of a function call or a call to an application programming interface. In some implementations, process of obtaining, acquiring, receiving, or inputting analog or digital data can be accomplished by transferring data via a serial or parallel interface. In another implementation, process of obtaining, acquiring, receiving, or inputting analog or digital data can be accomplished by transferring data via a computer network from providing entity to acquiring entity. References may also be made to providing, outputting, transmitting, sending, or presenting analog or digital data. In various examples, process of providing, outputting, transmitting, sending, or presenting analog or digital data can be accomplished by transferring data as an input or output parameter of a function call, a parameter of an application programming interface or interprocess communication mechanism.</p><p id="p-0645" num="0618">Although discussion above sets forth example implementations of described techniques, other architectures may be used to implement described functionality, and are intended to be within scope of this disclosure. Furthermore, although specific distributions of responsibilities are defined above for purposes of discussion, various functions and responsibilities might be distributed and divided in different ways, depending on circumstances.</p><p id="p-0646" num="0619">Furthermore, although subject matter has been described in language specific to structural features and/or methodological acts, it is to be understood that subject matter claimed in appended claims is not necessarily limited to specific features or acts described. Rather, specific features and acts are disclosed as exemplary forms of implementing the claims.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A processor, comprising:<claim-text>one or more circuits to perform an application programming interface (API) to generate one or more graph code nodes to allocate memory.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The processor of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the one or more circuits are further to:<claim-text>obtain code indicating at least the API; and</claim-text><claim-text>perform the API by at least executing the code.</claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The processor of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the one or more circuits are further to:<claim-text>generate a graph data structure; and</claim-text><claim-text>generate the one or more graph code nodes as part of the graph data structure.</claim-text></claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The processor of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the one or more circuits are further to perform the API based at least in part on one or more parameter values indicating at least properties of the memory to be allocated.</claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The processor of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the one or more graph code nodes to allocate the memory correspond to a set of graph code nodes to deallocate the memory.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The processor of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the one or more circuits are further to cause a graphics processing unit (GPU) to allocate the memory based at least in part on the one or more graph code nodes.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The processor of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the one or more circuits are further to cause one or more devices to perform one or more operations using the memory.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. A system, comprising:<claim-text>one or more computers having one or more processors to perform an application programming interface (API) to generate one or more graph code nodes to allocate memory.</claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The system of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the one or more processors are further to perform the API based at least in part on a set of parameter values indicating at least a size of the memory to be allocated.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The system of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the one or more processors are further to cause a parallel processing unit (PPU) to allocate the memory using the one or more graph code nodes.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The system of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the one or more graph code nodes encode properties of the allocated memory.</claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The system of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the one or more processors are further to:<claim-text>obtain a graph data structure indicating one or more operations; and</claim-text><claim-text>cause one or more devices to use the graph data structure to perform the one or more operations using the allocated memory.</claim-text></claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The system of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the API is a runtime API.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. A machine-readable medium having stored thereon a set of instructions, which if performed by one or more processors, cause the one or more processors to at least:<claim-text>perform an application programming interface (API) to generate one or more graph code nodes to allocate memory.</claim-text></claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The machine-readable medium of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the set of instructions further include instructions, which if performed by the one or more processors, cause the one or more processors to generate the one or more graph code nodes as part of a graph data structure.</claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The machine-readable medium of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the set of instructions further include instructions, which if performed by the one or more processors, cause the one or more processors to obtain code comprising parameter values for the API.</claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The machine-readable medium of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the one or more graph code nodes are data objects that encode information regarding memory allocation, and further wherein the information is calculated based at least in part on one or more parameter values.</claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The machine-readable medium of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the API is a driver API.</claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The machine-readable medium of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the set of instructions further include instructions, which if performed by the one or more processors, cause the one or more processors to:<claim-text>generate the one or more graph code nodes as part of a first graph data structure;</claim-text><claim-text>cause the memory to be allocated based at least in part on the one or more graph code nodes;</claim-text><claim-text>obtain a second graph data structure indicating one or more operations; and</claim-text><claim-text>cause one or more devices to perform the one or more operations utilizing the allocated memory.</claim-text></claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The machine-readable medium of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the set of instructions further include instructions, which if performed by the one or more processors, cause the one or more processors to cause a general-purpose graphics processing unit (GPGPU) to allocate the memory using the one or more graph code nodes.</claim-text></claim><claim id="CLM-00021" num="00021"><claim-text><b>21</b>. A processor, comprising:<claim-text>one or more circuits to perform an application programming interface (API) to generate one or more graph code nodes to allocate and deallocate memory.</claim-text></claim-text></claim><claim id="CLM-00022" num="00022"><claim-text><b>22</b>. The processor of <claim-ref idref="CLM-00021">claim 21</claim-ref>, wherein the one or more circuits are further to:<claim-text>generate a first graph code node to allocate the memory; and</claim-text><claim-text>generate a second graph code node to deallocate the memory.</claim-text></claim-text></claim><claim id="CLM-00023" num="00023"><claim-text><b>23</b>. The processor of <claim-ref idref="CLM-00021">claim 21</claim-ref>, wherein the one or more graph code nodes are part of a first graph data structure.</claim-text></claim><claim id="CLM-00024" num="00024"><claim-text><b>24</b>. The processor of <claim-ref idref="CLM-00021">claim 21</claim-ref>, wherein the one or more circuits are further to cause a device to allocate the memory based at least in part on an identified memory region.</claim-text></claim><claim id="CLM-00025" num="00025"><claim-text><b>25</b>. The processor of <claim-ref idref="CLM-00021">claim 21</claim-ref>, wherein the one or more circuits are further to perform the API based at least in part on parameter values indicating constraints for allocating and deallocating the memory.</claim-text></claim><claim id="CLM-00026" num="00026"><claim-text><b>26</b>. The processor of <claim-ref idref="CLM-00021">claim 21</claim-ref>, wherein the one or more circuits are further to cause one or more devices to use the memory to perform a set of operations.</claim-text></claim><claim id="CLM-00027" num="00027"><claim-text><b>27</b>. A machine-readable medium having stored thereon a set of instructions, which if performed by one or more processors, cause the one or more processors to at least:<claim-text>perform an application programming interface (API) to generate one or more graph code nodes to allocate and deallocate memory.</claim-text></claim-text></claim><claim id="CLM-00028" num="00028"><claim-text><b>28</b>. The machine-readable medium of <claim-ref idref="CLM-00027">claim 27</claim-ref>, wherein the set of instructions further include instructions, which if performed by the one or more processors, cause the one or more processors to:<claim-text>obtain code indicating at least the API to generate the one or more graph code nodes to allocate and deallocate the memory; and</claim-text><claim-text>execute the code to perform the API to generate the one or more graph code nodes to allocate and deallocate the memory, wherein the one or more graph code nodes comprise a first node for allocating memory and a second node for deallocating memory.</claim-text></claim-text></claim><claim id="CLM-00029" num="00029"><claim-text><b>29</b>. The machine-readable medium of <claim-ref idref="CLM-00027">claim 27</claim-ref>, wherein a first node of the one or more graph code nodes is part of a first graph data structure and a second node of the one or more graph code nodes is part of a second graph data structure.</claim-text></claim><claim id="CLM-00030" num="00030"><claim-text><b>30</b>. The machine-readable medium of <claim-ref idref="CLM-00027">claim 27</claim-ref>, wherein the set of instructions further include instructions, which if performed by the one or more processors, cause the one or more processors to cause a central processing unit (CPU) to use the one or more graph code nodes to allocate and deallocate the memory.</claim-text></claim><claim id="CLM-00031" num="00031"><claim-text><b>31</b>. The machine-readable medium of <claim-ref idref="CLM-00027">claim 27</claim-ref>, wherein the set of instructions further include instructions, which if performed by the one or more processors, cause the one or more processors to:<claim-text>calculate a first set of operations; and</claim-text><claim-text>cause one or more devices to use the memory to perform the first set of operations.</claim-text></claim-text></claim><claim id="CLM-00032" num="00032"><claim-text><b>32</b>. The machine-readable medium of <claim-ref idref="CLM-00027">claim 27</claim-ref>, wherein the set of instructions further include instructions, which if performed by the one or more processors, cause the one or more processors to cause one or more devices to perform one or more operations indicated by a graph data structure comprising at least one of the one or more graph code nodes.</claim-text></claim></claims></us-patent-application>