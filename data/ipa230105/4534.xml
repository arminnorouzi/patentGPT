<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004535A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004535</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17903378</doc-number><date>20220906</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20190101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>182</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20190101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>16</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20190101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>178</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>183</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>16</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>178</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">Network accessible file server</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>16787104</doc-number><date>20200211</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11436201</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17903378</doc-number></document-id></child-doc></relation></continuation><continuation><relation><parent-doc><document-id><country>US</country><doc-number>15591720</doc-number><date>20170510</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>10558622</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>16787104</doc-number></document-id></child-doc></relation></continuation><us-provisional-application><document-id><country>US</country><doc-number>62333978</doc-number><date>20160510</date></document-id></us-provisional-application></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Nasuni Corporation</orgname><address><city>Boston</city><state>MA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Shaw</last-name><first-name>David M.</first-name><address><city>Newton</city><state>MA</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>McDonald</last-name><first-name>Matthew M.</first-name><address><city>Wrentham</city><state>MA</state><country>US</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>Neufeld</last-name><first-name>Russell A.</first-name><address><city>Newton</city><state>MA</state><country>US</country></address></addressbook></inventor><inventor sequence="03" designation="us-only"><addressbook><last-name>Lacasse</last-name><first-name>Christopher S.</first-name><address><city>Grafton</city><state>MA</state><country>US</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A cloud-based write-once object store is configured to store inode-based data exported to the store from an enterprise file system. For each version of data (e.g., a file) exported to the store, there is a version of the inode corresponding to that data. As versions of the data are exported to the cloud, the system creates multiple versions of the inode. The set of inode versions corresponding to the versions of the file have a pointer associated therewith that specifies the latest version of the data associated with the inode. The inode versions in the set share the same pointer. The inode versions represent a revision history for the inode. For each inode version corresponding to a version of the data, information is received and stored in a new portion of the object store. The inode version for a file version comprises a list of data chunks for the file.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="81.36mm" wi="151.55mm" file="US20230004535A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="185.17mm" wi="153.67mm" file="US20230004535A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="192.62mm" wi="119.55mm" file="US20230004535A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="169.50mm" wi="158.07mm" file="US20230004535A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="159.09mm" wi="153.08mm" file="US20230004535A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="210.90mm" wi="159.26mm" file="US20230004535A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="210.90mm" wi="158.92mm" file="US20230004535A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="216.75mm" wi="162.81mm" file="US20230004535A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="226.82mm" wi="152.48mm" file="US20230004535A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="216.15mm" wi="161.97mm" file="US20230004535A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="213.78mm" wi="106.93mm" file="US20230004535A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="218.69mm" wi="168.40mm" file="US20230004535A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="195.58mm" wi="136.06mm" file="US20230004535A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="209.38mm" wi="131.32mm" file="US20230004535A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00014" num="00014"><img id="EMI-D00014" he="197.87mm" wi="138.43mm" file="US20230004535A1-20230105-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00015" num="00015"><img id="EMI-D00015" he="117.01mm" wi="172.97mm" file="US20230004535A1-20230105-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">TECHNICAL FIELD</heading><p id="p-0002" num="0001">The present application relates generally to data storage, and more particularly to synchronizing, updating and maintaining a versioned data store in a cloud based network-attached file system.</p><heading id="h-0002" level="1">BACKGROUND</heading><p id="p-0003" num="0002">It is known to provide an interface between an existing local file system and a data store (e.g., a &#x201c;write-once&#x201d; store) to provide a &#x201c;versioned&#x201d; file system. The versioned file system comprises a set of structured data representations, such as XML. In a representative embodiment, at a first time, the interface creates and exports to a data store a first structured data representation corresponding to a first version of the local file system. The first structured data representation is an XML tree having a root element, a single directory (the &#x201c;root directory&#x201d;) under the root element, zero or more directory elements associated with the root directory, and zero or more elements (such as files) associated with a given directory element. Each directory in turn can contain zero or more directories and zero or more files. Upon a change within the file system (e.g., file creation, file deletion, file modification, directory creation, directory deletion and directory modification), the interface creates and exports a second structured data representation corresponding to a second version of the file system. The second structured data representation differs from the first structured data representation up to and including the root element of the second structured data representation. Thus, the second structured data representation differs from the first structured data representation in one or more (but not necessarily all) parent elements with respect to the structured data element in which the change within the file system occurred. The interface continues to generate and export structured data representations to the data store, preferably at given &#x201c;snapshot&#x201d; times when changes within the file system have occurred. The data store comprises any type of back-end storage device, system or architecture. In one embodiment, the data store comprises one or more cloud storage service providers. As necessary, a given structured data representation is then used to retrieve an associated version of the file system. In this manner, the versioned file system only requires write-once behavior from the data store to preserve its complete state at any point-in-time.</p><p id="p-0004" num="0003">A problem with the above system is that a change to any file or directory in the file system causes a new version of each parent directory all the way up to the root. This causes additional processing time and resources to create each new &#x201c;version&#x201d; of the file system. Also, to determine what file or directory has changed between versions of the file system, the entire directory structure needs to be &#x201c;walked.&#x201d; In a large file system with a large user base, the processing overhead required to maintain this directory structure is significant. It would be desirable to create versions of a more granular portion of a file system without having to create a snapshot of the entire file system.</p><heading id="h-0003" level="1">SUMMARY</heading><p id="p-0005" num="0004">A cloud-based write-once object store is configured to store inode-based data exported to the object store from the enterprise file system. Conventionally, an inode-based approach to data storage requires rewriting data in-place, but rewriting in this manner is not possible in a write-once object store. Accordingly, an improvement to a write-once object store is provided by the technique of this disclosure whereby, for each version of data (e.g., a file) exported to the object store, there is a version of the inode corresponding to that data. As versions of a file are exported to the cloud, the system creates multiple versions of the inode, each of which remains immutable. The set of inode versions corresponding to the versions of the file that have been sent to the object store have a special pointer (or de-referencing point) associated therewith. This pointer specifies the latest version of the file that is associated with the inode. All of the inode versions in the set of inode versions for an inode share the same pointer. In effect, the inode versions, when taken together, represent a revision history for the inode. For each inode version corresponding to a version of the data, information (e.g., metadata, directory/file contents) is received and stored in a new portion of the write-once object store. Typically, the inode version for a version of the file comprises a list of data chunks that comprise the file, as well as information identifying where those chunks are located. Thus, as versions of a file in the enterprise file system are generated, multiple inode versions sharing the inode number but representing the multiple versions of the file are instantiated and tracked in the cloud object store. In this manner, the inode-based write-once object store acts as a network-accessible file server.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">IN THE DRAWINGS</heading><p id="p-0006" num="0005">For a more complete understanding of the disclosed subject matter and the advantages thereof, reference is now made to the following descriptions taken in conjunction with the accompanying drawings, in which:</p><p id="p-0007" num="0006"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram illustrating how a shared versioned file system interfaces a local version of the shared versioned file system to an object-based data store;</p><p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a block diagram of a representation implementation of a portion of the interface shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>;</p><p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a more detailed implementation of the interface where there are a number of local versions of the shared versioned file system of different types;</p><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. <b>4</b></figref> illustrates a filer server implemented as an appliance within a local processing environment;</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a block diagram of the architecture of a shared versioned file system according to an embodiment;</p><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>6</b></figref> illustrates the portion of the tree (as shown in <figref idref="DRAWINGS">FIG. <b>5</b></figref>) after a change to the contents of a file has occurred in the local version of the shared versioned file system;</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a block diagram of a system for running a shared versioned file system according to an embodiment;</p><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a flow chart of a method for sending updated data to cloud storage according to an embodiment;</p><p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. <b>9</b></figref> illustrates a table of updates to a shared versioned file system maintained by the filer server;</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a flow chart of a method for synchronizing updates from a local version of a shared versioned file system to a cloud data store according to an embodiment;</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>11</b></figref> is a flow chart of a method for synchronizing updates from a cloud-based a shared versioned file system to a local version of same according to an embodiment</p><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>12</b></figref> is a simplified illustration of a representative shard according to an embodiment;</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>13</b></figref> is a simplified illustration of the representative shard from <figref idref="DRAWINGS">FIG. <b>12</b></figref> after an update according to an embodiment;</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>14</b></figref> is a simplified illustration of a representative directory entry in the representative shard of <figref idref="DRAWINGS">FIG. <b>13</b></figref>; and</p><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. <b>15</b></figref> depicts a representative cloud layout for an inode-based write once object store according to this disclosure.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0005" level="1">DETAILED DESCRIPTION</heading><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates a simplified system <b>10</b> for providing a shared versioned file system. The system <b>10</b> includes local versions <b>100</b>, <b>101</b> of the shared versioned file system and an object-based data store <b>120</b>. Although not meant to be limiting, the object-based store <b>120</b> can be a &#x201c;write-once&#x201d; store and may comprise a &#x201c;cloud&#x201d; of one or more storage service providers. Each interface or filer server <b>110</b>, <b>111</b> exposes a respective local version <b>100</b>, <b>101</b> of a &#x201c;shared versioned file system&#x201d; that only requires write-once behavior from the object-based data store <b>120</b> to preserve substantially its &#x201c;complete&#x201d; state at any point-in-time. As used herein, the phrase &#x201c;point-in-time&#x201d; should be broadly construed, and it typically refers to periodic &#x201c;snapshots&#x201d; of the local version of the shared versioned file system or periodic snapshots of any updates to the local version of the shared versioned file system (e.g., once every &#x201c;n&#x201d; minutes). The value of &#x201c;n&#x201d; and the time unit may be varied as desired. Each filer server <b>100</b>, <b>101</b> provides for a local version <b>100</b>, <b>101</b> of the shared versioned file system that has complete data integrity to the cloud. In particular, this solution circumvents the problem of a lack of reliable atomic object replacement in cloud-based object repositories. The filer servers <b>100</b>, <b>101</b> are not limited for use with a particular type of back-end data store. When the filer servers <b>100</b>, <b>101</b> are positioned in &#x201c;front&#x201d; of data store <b>120</b>, the filer servers <b>100</b>, <b>101</b> have the effect of turning whatever is behind it into respective local versions of a &#x201c;shared versioned file system&#x201d; (&#x201c;SVFS&#x201d;). The SVFS is a construct that is distinct from the filer server itself, and the SVFS continues to exist irrespective of the state or status of the filer server (from which it may have been generated). Moreover, the SVFS is self-describing, and it can be accessed and managed separately from the back-end data store, or as a component of that data store. Thus, the SVFS (comprising a set of structured data representations) is location-independent. In one embodiment, the SVFS resides within a single storage service provider (SSP) although, as noted above, this is not a limitation. In another embodiment, a first portion of the SVFS resides in a first SSP, which a second portion resides in a second SSP. Generalizing, any given SVFS portion may reside in any given data store (regardless of type), and multiple VFS portions may reside across multiple data store(s). The SVFS may reside in an &#x201c;internal&#x201d; storage cloud (i.e. a storage system internal to an enterprise), an external storage cloud, or some combination thereof.</p><p id="p-0023" num="0022">The interface or filer server <b>104</b> can be implemented as a machine. A representative implementation is the NASUNI&#xae; Filer, available from Nasuni Corporation of Massachusetts. Thus, for example, typically the filer server <b>104</b> is a rack-mounted server appliance comprising of hardware and software. The hardware typically includes one or more processors that execute software in the form of program instructions that are otherwise stored in computer memory to comprise a &#x201c;special purpose&#x201d; machine for carrying out the functionality described herein. Alternatively, the filer server <b>104</b> is implemented as a virtual machine or appliance (e.g., via VMware&#xae;, or the like), as software executing on a server, or as software executing on the native hardware resources of the local version of the SVFS. The filer server <b>104</b> serves to transform the data representing the local version of the SVFS (a physical construct) into another form, namely, a shared versioned file system comprising a series of structured data representations that are useful to reconstruct the shared versioned file system to any point-in-time.</p><p id="p-0024" num="0023">Although not meant to be limiting, preferably each structured data representation is an XML document (or document fragment). As is well-known, extensible markup language (XML) facilitates the exchange of information in a tree structure. An XML document typically contains a single root element (or a root element that points to one or more other root elements). Each element has a name, a set of attributes, and a value consisting of character data, and a set of child elements. The interpretation of the information conveyed in an element is derived by evaluating its name, attributes, value, and position in the document.</p><p id="p-0025" num="0024">The filer server <b>104</b> generates and exports to the write-once data store a series of structured data representations (e.g., XML documents) and data objects that together comprise the shared versioned file system. The structured data representations are stored in the data store <b>120</b>. Preferably, the XML representations are encrypted before export to the data store. The transport may be performed using known techniques. In particular, REST (Representational State Transfer) is a protocol commonly used for exchanging structured data and type information on the Web. Another such protocol is Simple Object Access Protocol (SOAP). Using REST, SOAP, or some combination thereof, XML-based messages are exchanged over a computer network, normally using HTTP (Hypertext Transfer Protocol) or the like. Transport layer security mechanisms, such as HTTP over TLS (Transport Layer Security), may be used to secure messages between two adjacent nodes. An XML document and/or a given element or object therein is addressable via a Uniform Resource Identifier (URI). Familiarity with these technologies and standards is presumed.</p><p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a block diagram of a representative implementation of how the interface or filer server <b>110</b>/<b>111</b> captures all (or given) read/write events from a local version of shared versioned file system <b>200</b>. In this example implementation, the interface comprises a file system agent (FSA) <b>202</b> that is positioned within a data path between a local version of shared versioned file system <b>200</b> and its local storage <b>206</b>. The file system agent <b>202</b> has the capability of &#x201c;seeing&#x201d; all (or some configurable set of) read/write events output from the local file system. The interface/filer server also comprises a content control service (CCS) <b>204</b> as will be described in more detail below. The content control service is used to control the behavior of the file system agent. The object-based data store is represented by the arrows directed to &#x201c;storage&#x201d; which, as noted above, typically comprises any back-end data store including, without limitation, one or more storage service providers. The local version of the shared versioned file system stores local user files (the data) in their native form in cache <b>208</b>. Reference numeral <b>210</b> represents that portion of the cache that stores pieces of metadata (the structured data representations, as will be described) that are exported to the back-end data store (e.g., the cloud).</p><p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a block diagram illustrating how the interface may be used with different types of local file system architectures. In particular, <figref idref="DRAWINGS">FIG. <b>3</b></figref> shows the CCS (in this drawing a Web-based portal) controlling three (3) FSA instances. Once again, these examples are merely representative and they should not be taken to limit the invention. In this example, the file system agent <b>306</b> is used with three (3) different local versions of the shared versioned file system: NTFS <b>300</b> executing on a Windows operating system platform <b>308</b>, MacFS (also referred to as &#x201c;HFS+&#x201d; (HFSPlus)) <b>302</b> executing on an OS X operating system platform <b>310</b>, and EXT3 or XFS <b>304</b> executing on a Linux operating system platform <b>312</b>. These local versions of the shared versioned file system may be exported (e.g., via CIFS, AFP, NFS or the like) to create a NAS system based on VFS. Conventional hardware, or a virtual machine approach, may be used in these implementations, although this is not a limitation. As indicated in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, each platform may be controlled from a single CCS instance <b>314</b>, and one or more external storage service providers may be used as an external object repository <b>316</b>. As noted above, there is no requirement that multiple SSPs be used, or that the data store be provided using an SSP.</p><p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. <b>4</b></figref> illustrates the interface/filer server implemented as an appliance within a local processing environment. In this embodiment, the version of <b>400</b> for the local version of the shared versioned file system is received over Ethernet and represented by the arrow identified as &#x201c;NAS traffic.&#x201d; That traffic is provided to smbd layer <b>402</b>, which is a SAMBA file server daemon that provides CIFS (Window-based) file sharing services to clients. The layer <b>402</b> is managed by the operating system kernel <b>404</b> is the usual manner. In this embodiment, the local version of the shared versioned file system is represented (in this example) by the FUSE kernel module <b>406</b> (which is part of the Linux kernel distribution). Components <b>400</b>, <b>402</b> and <b>404</b> are not required to be part of the appliance. The file transfer agent <b>408</b> of the interface is associated with the FUSE module <b>406</b> as shown to intercept the read/write events as described above. The CCS (as described above) is implemented by a pair of modules (which may be a single module), namely, a cache manager <b>410</b>, and a volume manager <b>412</b>. Although not shown in detail, preferably there is one file transfer agent instance <b>408</b> for each volume of the local file system. The cache manager <b>410</b> is responsible for management of &#x201c;chunks&#x201d; with respect to a local disk cache <b>414</b>. This enables the interface or filer server described herein to maintain a local cache of the data structures (the structured data representations) that comprise the shared versioned file system. The volume manager <b>412</b> maps the root of the FSA data to the cloud (as will be described below), and it further understands the one or more policies of the cloud storage service providers. The volume manager also provides the application programming interface (API) to these one or more providers and communicates the structured data representations (that comprise the shared versioned file system) through a transport mechanism <b>416</b> such as cURL. cURL is a library and command line tool for transferring files with URL syntax that supports various protocols such as FTP, FTPS, HTTP, HTTPS, SCP, SFTP, TFTP, TELNET, DICT, LDAP, LDAPS and FILE. cURL also supports SSL certificates, HTTP POST, HTTP PUT, FTP uploading, HTTP form based upload, proxies, cookies, user+password authentication, file transfer resume, proxy tunneling, and the like. The structured data representations preferably are encrypted and compressed prior to transport by the transformation module <b>418</b>. The module <b>418</b> may provide one or more other data transformation services, such as duplicate elimination. The encryption, compression, duplicate elimination and the like, or any one of such functions, are optional. A messaging layer <b>420</b> (e.g., local socket-based IPC) may be used to pass messages between the file system agent instances, the cache manager and the volume manager. Any other type of message transport may be used as well.</p><p id="p-0029" num="0028">The interface/filer server shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref> may be implemented as a standalone system, or as a managed service. In the latter case, the system executes in an end user (local file system) environment. A managed service provider provides the system (and the versioned file system service), preferably on a fee or subscription basis, and the data store (the cloud) typically is provided by one or more third party service providers. The shared versioned file system may have its own associated object-based data store, but this is not a requirement, as its main operation is to generate and manage the structured data representations that comprise the shared versioned file system. The cloud preferably is used just to store the structured data representations, preferably in a write-once manner, although the &#x201c;shared versioned file system&#x201d; as described herein may be used with any back-end data store and can be a write-many data store.</p><p id="p-0030" num="0029">As described above, the file system agent <b>408</b> is capable of completely recovering from the cloud (or other store) the state of the local version of the shared versioned file system and providing immediate file system access (once FSA metadata is recovered). The FSA can also recover to any point-in-time for the whole shared versioned file system, a directory and all its contents, a portion of a directory (e.g., a shard) and it contents, a single file, or a piece of a file. These and other advantages are provided by the &#x201c;shared versioned file system&#x201d; of this disclosure, as it now described in more detail below.</p><p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a block diagram of the architecture of a shared versioned file system <b>50</b> according to an embodiment. The architecture <b>50</b> includes a root-level directory <b>500</b> and first-level directories <b>500</b>-<b>1</b>, <b>500</b>-<b>2</b>. First level directory <b>500</b>-<b>2</b> includes sub-directory <b>2</b>-<b>1</b> <b>502</b>, which is divided into shards <b>1</b>, <b>2</b>, and <b>3</b> (corresponding to reference numbers <b>503</b>-<b>1</b>, <b>503</b>-<b>2</b>, <b>503</b>-<b>3</b>) (in general, shard <b>503</b>). Each shard <b>503</b> is a portion of sub-directory <b>2</b>-<b>1</b> <b>502</b>. As an example, files <b>1</b>, <b>2</b>, and <b>3</b> (corresponding to reference numbers <b>504</b>-<b>1</b>, <b>504</b>-<b>2</b>, and <b>504</b>-<b>3</b>) in sub-directory <b>2</b>-<b>1</b> <b>502</b> are assigned to shard <b>1</b> <b>503</b>-<b>1</b>. Shard <b>2</b> <b>503</b>-<b>2</b> and shard <b>3</b> <b>503</b>-<b>3</b> can also include files and/or metadata that belong to sub-directory <b>2</b>-<b>1</b> <b>502</b>.</p><p id="p-0032" num="0031">Each file <b>504</b> is divided into one more chunks, such as chunks <b>1</b>, <b>2</b>, <b>3</b> (corresponding to reference numbers <b>504</b>-<b>1</b>, <b>504</b>-<b>2</b>, <b>504</b>-<b>3</b>) (in general, chunk <b>504</b>) of file <b>2</b> <b>504</b>-<b>2</b>. An example of dividing files into chunks can be found in U.S. Pat. No. 8,566,362, entitled &#x201c;Method and System for Versioned File System Using Structured Data Representations,&#x201d; assigned to the present Applicant, which is incorporated herein by reference. Each directory/sub-directory, file, and chunk of shared versioned file system <b>50</b> can be represented by an inode. Example inode numbers for the following components of shared versioned file system <b>50</b> are illustrated in parentheticals: sub-directory <b>2</b>-<b>1</b> <b>502</b> (<b>10</b>), file <b>1</b> <b>504</b>-<b>1</b> (<b>101</b>), file <b>2</b> <b>504</b>-<b>2</b> (<b>102</b>), file <b>3</b> <b>504</b>-<b>3</b> (<b>103</b>), and chunk <b>1</b> <b>505</b>-<b>1</b> (<b>1001</b>). Additional inode numbers are illustrated in <figref idref="DRAWINGS">FIG. <b>5</b></figref>.</p><p id="p-0033" num="0032">Shard <b>503</b> can have an arbitrary number of files and/or metadata from sub-directory <b>2</b>-<b>1</b> <b>502</b>. In addition, or in the alternative, shard <b>503</b> can have a maximum number of files and/or metadata, for example to provide an increased size (horizontally and/or vertically) of the shared versioned file system.</p><p id="p-0034" num="0033">Each shard <b>503</b> has a manifest that identifies the files (by inode number) assigned to that shard. For example, manifest <b>540</b> of shard <b>1</b> <b>503</b>-<b>1</b> identifies inodes <b>101</b>, <b>102</b>, and <b>103</b>. The manifest <b>540</b> also includes metadata about each inode, such as the version of the shard in which the inode (file) was created and the version of the shard in which the inode (file) was last modified. The manifest can also include a flag or bit to indicate whether any component of the shard has been modified, including the manifest itself.</p><p id="p-0035" num="0034">In addition, each file <b>504</b> has a manifest that identifies the chunks (by inode number) that make up the data of the file. For example, manifest <b>550</b> of file <b>2</b> <b>504</b>-<b>2</b> identifies inodes <b>1001</b>, <b>1002</b>, and <b>1003</b>. The manifest also includes metadata about each inode, such as the relationship or offset between each inode. The manifest can also include a flag or bit to indicate whether any component of the file has been modified, including the manifest itself.</p><p id="p-0036" num="0035"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a block diagram of the architecture of the shared versioned file system <b>50</b> after a change to chunk <b>1</b> <b>505</b>-<b>1</b> in file <b>2</b> <b>504</b>-<b>2</b>. As illustrated by the asterisks in <figref idref="DRAWINGS">FIG. <b>6</b></figref>, the change to chunk <b>1</b>* <b>505</b>-<b>1</b> propagates to file <b>2</b>* <b>504</b>-<b>2</b>. In other words, the modification to chunk <b>1</b>* <b>505</b>-<b>1</b> causes file <b>2</b>* <b>504</b>-<b>2</b> to appear as modified or &#x201c;dirty.&#x201d; The modified or dirty file <b>2</b>* <b>504</b>-<b>2</b> causes shard <b>1</b>* <b>503</b>-<b>1</b> to appear as modified, which in turn causes sub-directory <b>2</b>-<b>1</b>* <b>502</b> to appear as modified. The modification to chunk <b>1</b>* <b>505</b>-<b>1</b> does not propagate past sub-directory <b>2</b>-<b>1</b>* <b>502</b>, such as to directory <b>2</b> <b>501</b>-<b>2</b> or root <b>500</b>. Thus directory <b>2</b> <b>501</b>-<b>2</b> and root <b>500</b> appear as unmodified even if sub-directory <b>2</b>-<b>1</b>* <b>502</b> appears as modified. In general, a change to any portion of the shared versioned file system <b>50</b> only propagates to the closest directory or sub-directory level. For example, a change to shard <b>2</b> <b>503</b>-<b>2</b> propagates to sub-directory <b>2</b>-<b>1</b> <b>502</b> but not to directory <b>2</b> <b>501</b>-<b>2</b> or root <b>500</b>. Similarly, a change to sub-directory <b>2</b>-<b>1</b> propagates to directory <b>2</b> <b>501</b>-<b>2</b> but not to root <b>500</b>.</p><p id="p-0037" num="0036">By limiting the propagation of change events to the closest directory or sub-directory, shared versioned file system <b>50</b> can be synchronized more efficiently across local interfaces running respective local versions of the shared versioned file system.</p><p id="p-0038" num="0037">As discussed above, a modification to a file or shard causes an update flag in the respective manifest to turn on, which makes the corresponding file or shard appear as modified. Using the example of <figref idref="DRAWINGS">FIG. <b>6</b></figref>, the modification to chunk <b>1</b>* <b>505</b>-<b>1</b> automatically causes the update flag in manifest* <b>550</b> to turn on, which in turn causes file <b>2</b>* <b>504</b>-<b>2</b> to appear as modified. The modification to file <b>2</b>* <b>504</b>-<b>2</b> causes the update flag in manifest* <b>540</b> to turn on, which in turn causes shard <b>1</b>* <b>503</b>-<b>1</b> to appear as modified. When shard <b>1</b>* <b>503</b>-<b>1</b> appears as modified, sub-directory <b>2</b>-<b>1</b>* <b>502</b> also appears as modified since shard <b>1</b>* <b>503</b>-<b>1</b> is a portion of sub-directory <b>2</b>-<b>1</b>* <b>502</b>.</p><p id="p-0039" num="0038"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a block diagram of a system <b>70</b> for running a shared versioned file system according to an embodiment. The system <b>70</b> includes operations server <b>700</b>, filer servers <b>710</b>, <b>720</b>, and user computers <b>712</b>, <b>714</b>, <b>722</b>, <b>724</b>. Filer servers <b>710</b>, <b>720</b> can be the same as FSA <b>202</b> or FSA <b>306</b> described above. Each filer server provides a respective local version of the shared versioned file system to its respective user computers. For example, Filer server <b>710</b> exposes local version A <b>730</b> of the shared versioned file system to local computers <b>712</b>, <b>714</b>. Likewise, Filer server <b>720</b> exposes local version B <b>740</b> of the shared versioned file system to local computers <b>722</b>, <b>724</b>. Local version A <b>730</b> and local version B <b>740</b> can represent the same or different versions of the shared versioned file system based on how recently the respective filer server <b>710</b>, <b>720</b> have retrieved updates to the shared versioned file system from operations server <b>700</b> and cloud storage <b>750</b>. If filer servers <b>710</b>, <b>720</b> have retrieved updates to the shared versioned file system up to the same change event (as discussed below), local versions <b>730</b>, <b>740</b> of the shared versioned file system are identical. The filer servers <b>710</b>, <b>720</b> can communicate with respective user computers over a network protocol such as Network File System (NFS), Server Message Block (SMB), or Common Internet File System (CIFS). In some embodiments, the operations server <b>700</b> is a NASUNI&#xae; Operations Center, available from Nasuni Corporation of Massachusetts.</p><p id="p-0040" num="0039">In an example of the operation of system <b>70</b>, a user on user computer <b>712</b> makes a modification to a document that corresponds to file <b>2</b> <b>504</b>-<b>2</b> (using the example of <figref idref="DRAWINGS">FIGS. <b>5</b> and <b>6</b></figref>, discussed above). The modification occurs in the portion of file <b>2</b> <b>504</b>-<b>2</b> corresponding to chunk <b>1</b> <b>505</b>-<b>1</b>. Filer server <b>710</b> saves a new version of File <b>2</b> <b>504</b>-<b>2</b> locally. The new version of file <b>2</b> <b>504</b>-<b>2</b> includes modified manifest <b>540</b>* that contains modified chunk <b>1</b>* <b>505</b>-<b>1</b> and pointers to unmodified chunk <b>2</b> <b>505</b>-<b>2</b> and unmodified chunk n <b>505</b>-<i>n</i>. Filer server <b>710</b> also saves a new version of shard <b>1</b> <b>503</b>-<b>1</b> locally. The new version (e.g., version <b>2</b>) of shard <b>1</b> <b>503</b>-<b>1</b> (i.e., modified shard <b>1</b>* <b>503</b>-<b>1</b>) includes a new manifest <b>550</b>* that includes the inode numbers of each file in modified shard <b>1</b>* <b>503</b>-<b>1</b>.</p><p id="p-0041" num="0040">Continuing with the example of <figref idref="DRAWINGS">FIGS. <b>5</b> and <b>6</b></figref>, manifest <b>550</b>* includes inodes <b>101</b> (unmodified file <b>1</b> <b>504</b>-<b>1</b>), <b>102</b> (modified file <b>2</b>* <b>504</b>-<b>2</b>), and <b>103</b> (unmodified file <b>3</b> <b>504</b>-<b>3</b>). In addition, manifest <b>550</b>* indicates that inode <b>102</b> was last modified in version <b>2</b> of shard <b>1</b> (i.e., modified shard <b>1</b>* <b>503</b>-<b>1</b>). Manifest <b>550</b>* also indicates that inodes <b>101</b> and <b>103</b> were last modified in version <b>1</b> of shard <b>1</b>. Manifest <b>550</b>* also turn the update flag on to indicate that modified shard <b>1</b>* <b>503</b>-<b>1</b> contains at least one update. By comparing the present version of shard <b>1</b> (version <b>2</b>) with the version number in which each inode was last modified (inode <b>101</b> (last modified in version <b>1</b>), <b>102</b> (last modified in version <b>2</b>), and <b>103</b> (last modified in version <b>1</b>)), the filer server <b>710</b> can determine that inode <b>102</b> includes modified data while inodes <b>101</b> and <b>103</b> do not include modified data.</p><p id="p-0042" num="0041">In another example, a user on computer <b>724</b> creates a new file called file <b>4</b> (inode <b>104</b>) in shard <b>1</b> in the local version B of the shared versioned file system managed by filer server <b>720</b>. The new manifest of shard <b>1</b> in local version B includes inodes <b>101</b> (unmodified file <b>1</b> <b>504</b>-<b>1</b>), <b>102</b> (unmodified file <b>2</b> <b>504</b>-<b>2</b>), <b>103</b> (unmodified file <b>3</b> <b>504</b>-<b>3</b>), and <b>104</b> (new file <b>4</b>). The new manifest indicates that inodes <b>101</b>-<b>103</b> were each created in version <b>1</b> of shard <b>1</b> while inode <b>104</b> was created in version <b>2</b> of shard <b>1</b>. The new manifest also includes a flag in the &#x201c;on&#x201d; state to indicate that version <b>2</b> of shard <b>1</b> contains at least one update. By comparing the present version of shard <b>1</b> (version <b>2</b>) with the version number in which each inode was created (inode <b>101</b> (created in version <b>1</b>), <b>102</b> (created in version <b>2</b>), <b>103</b> (created in version <b>1</b>), and <b>104</b> (created in version <b>2</b>), the filer server <b>720</b> can determine that inode <b>104</b> is new in version <b>2</b> of shard <b>1</b> while inodes <b>101</b>-<b>103</b> are not new.</p><p id="p-0043" num="0042"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a flow chart <b>80</b> of a method for sending updated data to cloud storage according to an embodiment. Using the above example of creating a modified file <b>2</b>* <b>504</b>-<b>2</b> in shard <b>1</b>, in step <b>810</b> filer server <b>710</b> determines which directories or sub-directories have the updated flag flipped to the &#x201c;on&#x201d; state in local version A of the shared versioned file system <b>730</b>. In the example of <figref idref="DRAWINGS">FIGS. <b>5</b> and <b>6</b></figref>, sub-directory <b>2</b>-<b>1</b> <b>502</b> is the only directory or sub-directory in which the updated flag is flipped on. In step <b>820</b>, filer server <b>710</b> determines which shards within the updated directories/sub-directories identified in step <b>810</b> have the updated flag flipped to the on state. In the above example, shard <b>1</b> <b>503</b>-<b>1</b> is the only shard in sub-directory <b>2</b>-<b>1</b> <b>503</b>-<b>1</b> in which the updated flag is on. Since filer server <b>710</b> has at least one updated shard, the flow chart <b>80</b> proceeds to step <b>830</b>. In the circumstance when there are no updated shards, the filer server would return to step <b>810</b>. The filer server can wait for a short time period (e.g., 30 seconds to 1 minute) before returning to step <b>810</b>.</p><p id="p-0044" num="0043">In step <b>830</b>, filer server <b>710</b> sends a request to operations server <b>700</b> for a global lock on shard <b>1</b> <b>503</b>-<b>1</b>. If a global lock is available and not in use by another interface or filer server, operations server <b>700</b> returns the global lock to Filer A <b>710</b>. If the global lock is not available, operations server <b>700</b> returns a message to the filer server to indicate that the global lock is unavailable. In that case, the filer server <b>710</b> can request a global lock for another updated shard and request the global lock on shard <b>1</b> <b>503</b>-<b>1</b> later. Alternatively, the filer server <b>710</b> can continue to request the global lock on shard <b>1</b> <b>503</b>-<b>1</b> until the operations server <b>700</b> is able to provide it.</p><p id="p-0045" num="0044">After filer server <b>710</b> receives the global lock, the flow chart <b>80</b> proceeds to step <b>840</b> in which case the filer server <b>710</b> identifies the portions of shard <b>1</b> <b>503</b>-<b>1</b> that have updated information. This can be a query for the state of each shard directory entry in the cache of filer server <b>710</b> as described below. The available states are cache entry dirty (i.e., the shard directory entry contains updated information since the last shard version), cache entry clean (i.e., the shard directory entry does not contain updated information since the last shard version), or cache entry created (i.e., the shard directory entry did not exist in the last shard version; it was created in the present shard version). The shard directory entries of dirty and created contain new information and need to be sent to the cloud/data store. The shard directory entries of clean already exist in that form in the cloud/data store so the filer server does not need to send the clean entries to the cloud/data store. For each dirty entry, the filer server determines the portions of the directory entry (e.g., a chunk and/or a manifest of a file) that have been updated. In the example of <figref idref="DRAWINGS">FIGS. <b>5</b> and <b>6</b></figref>, the filer server <b>710</b> determines from the updated flags of files <b>1</b>-<b>3</b> (<b>504</b>-<b>1</b> to <b>504</b>-<b>3</b>) that file <b>2</b> <b>504</b>-<b>2</b> is updated while file <b>1</b> <b>504</b>-<b>1</b> and file <b>3</b> <b>504</b>-<b>3</b> have not been updated. The filer server <b>710</b> then evaluates the manifest <b>550</b> of file <b>2</b> version <b>2</b> and determines the file version <b>2</b> includes chunk <b>1</b>* <b>505</b>-<b>1</b> and pointers to chunk <b>2</b> <b>505</b>-<b>2</b> and chunk <b>3</b> <b>505</b>-<b>3</b>. Based on this information, the filer server <b>710</b> determines that chunk <b>1</b>* <b>505</b>-<b>1</b> is new/updated and chunks <b>2</b> <b>505</b>-<b>2</b> and <b>3</b> <b>505</b>-<b>3</b> are not new.</p><p id="p-0046" num="0045">Data is stored in cloud storage <b>750</b> by inode number and version number. For example, the contents of shard <b>1</b> <b>503</b>-<b>1</b> in sub-directory <b>2</b>-<b>1</b> <b>502</b> can be stored in the cloud at inodes/10/S1/now where &#x201c;10&#x201d; corresponds to the inode number for sub-directory <b>2</b>-<b>1</b> <b>502</b>, &#x201c;S1&#x201d; corresponds to shard <b>1</b> in inode <b>10</b> (sub-directory <b>2</b>-<b>1</b> <b>502</b>), and &#x201c;now&#x201d; is a pointer to the most recent version of shard <b>1</b>. For example, if the most recent version of shard <b>1</b> is version <b>1</b> (i.e., now=1), the pointer is to inodes/10/S1/v1. The directory inodes/10/S1/v1 includes pointers to the contents of shard <b>1</b> (i.e., inode <b>101</b> (file <b>1</b> <b>504</b>-<b>1</b>), inode <b>102</b> (file <b>2</b> <b>504</b>-<b>2</b>), and inode <b>1</b>** (file n <b>504</b>-<i>n</i>)). The pointer to each inode (file) is to the latest version of the inode (file). For example, inode <b>102</b> (file <b>2</b> <b>504</b>-<b>2</b>) includes a pointer to inodes/102/now. As before, &#x201c;now&#x201d; is a pointer to the most recent version, which in this case is the most recent version of inode <b>102</b>. For example, if the most recent version of file <b>2</b> is version <b>3</b> (i.e., now=3), the pointer is to inodes/102/3. Continuing with the illustration of <figref idref="DRAWINGS">FIG. <b>5</b></figref>, the most recent version of file <b>2</b> includes a manifest <b>510</b> that identifies inode <b>1001</b> (chunk <b>1</b> <b>505</b>-<b>1</b>), inode <b>1002</b> (chunk <b>2</b> <b>505</b>-<b>2</b>), and inode <b>10</b>** (chunk n <b>505</b><i>n</i>) and the relationship between the chunks (e.g., offset) as the components that form file <b>2</b>.</p><p id="p-0047" num="0046">Returning to the example above, in step <b>850</b> the filer server <b>710</b> sends the update portions of updated shard <b>1</b> to the cloud/data store. Filer server <b>710</b> can place a local lock on shard <b>1</b> during this step. First, filer server <b>710</b> creates a new version (version <b>2</b>) on cloud storage for shard <b>1</b> <b>503</b>-<b>1</b> at inodes/10/S1/v2. Version <b>2</b> of shard <b>1</b> includes a new manifest that identifies that the shard includes inodes <b>101</b>-<b>103</b> (corresponding to files <b>1</b>-<b>3</b>). Since no files have been added or deleted from shard <b>1</b>, the inodes identified in the manifest are the same in versions <b>1</b> and <b>2</b> of shard <b>1</b>. However, the metadata for inode <b>102</b> indicates that inode <b>102</b> was created in version <b>1</b> of shard <b>1</b> and last updated in version <b>2</b> of shard <b>1</b>. In contrast, the metadata for inodes <b>101</b> and <b>103</b> indicate that they were created in version <b>1</b> of shard <b>1</b> but have not been updated. Filer server <b>710</b> also updates the metadata for inodes/10/S1/now to reference version <b>2</b> of shard <b>1</b> as the latest version (i.e., now=2).</p><p id="p-0048" num="0047">To update the contents of inode <b>102</b> (file <b>2</b> <b>504</b>-<b>2</b>), filer server <b>710</b> creates a new version (version <b>2</b>) at inodes/102/2. The most recent version of file <b>2</b> includes a new manifest <b>550</b> that identifies modified inode <b>1001</b> (chunk <b>1</b>* <b>505</b>-<b>1</b>) and pointers to unmodified inode <b>1002</b> (chunk <b>2</b> <b>505</b>-<b>2</b>) and unmodified inode <b>1003</b> (chunk <b>3</b> <b>505</b>-<b>3</b>) and the relationship between the chunks (e.g., offset) as the components that form version <b>2</b> of file <b>2</b> <b>504</b>-<b>2</b>. Filer A also updates the metadata for inodes/102/now to reference version <b>2</b> of file <b>2</b> as the latest version (i.e., now=2). In addition, filer server <b>710</b> sends modified inode <b>1001</b> (chunk <b>1</b>* <b>505</b>-<b>1</b>) to the cloud/data store. When the update is complete, filer server <b>710</b> releases the global lock <b>860</b> on shard <b>1</b> <b>503</b>-<b>1</b> back to operations server <b>700</b>. Filer server <b>710</b> also releases the local lock on shard <b>1</b> <b>503</b>-<b>1</b> if such a lock was placed on shard <b>1</b> <b>503</b>-<b>1</b>. In step <b>870</b>, the filer server <b>710</b> determines if there are any additional updated shards that need to be sent to the cloud/data store. If so, the flow chart <b>80</b> returns to step <b>830</b> where the filer server <b>710</b> requests a global lock on the next updated shard. If there are no additional updated shards to send to the cloud/data store, the flow chart <b>80</b> returns to step <b>810</b> to re-start the cloud update process. The filer server <b>710</b> can wait for a predetermined time period (e.g., 1 to 5 minutes) before re-starting the flow chart <b>80</b>.</p><p id="p-0049" num="0048">As filer servers <b>710</b>, <b>720</b> make updates to files and directories in the shared versioned file system, operations server <b>700</b> maintains a table 90 of such updates as illustrated in <figref idref="DRAWINGS">FIG. <b>9</b></figref>. Table 90 includes the updated inode and the updated shard within the updated inode for each update. Table 90 also includes an event number that operations server <b>700</b> assigns to each update. Table 90 illustrates that the event number increases by one integer value for each update, though the event number can increase by a different amount in some embodiments. For example, the event number can increase by multiple integers, a decimal (e.g., <b>100</b>.<b>1</b>, <b>100</b>.<b>2</b>, etc.), or other unit. The update to shard <b>1</b> of inode <b>10</b> (sub-directory <b>2</b>-<b>1</b> <b>502</b>) described above is included as event number <b>102</b> in table 90.</p><p id="p-0050" num="0049">Filer servers <b>710</b>, <b>720</b> query the operations server <b>700</b> periodically to determine whether there are any recent updates to the shared versioned file system as indicated by the event number. For example, filer server <b>720</b> last synchronized updates to the shared versioned file system at event number <b>100</b> as illustrated in <figref idref="DRAWINGS">FIG. <b>8</b></figref>. Since that time, there have been <b>5</b> updates to the shared versioned file system, as represented by event numbers <b>101</b>-<b>105</b>. In order for filer server <b>720</b> to update its local version <b>740</b> of the global file system with the latest changes, filer server <b>720</b> retrieves and merges the updates represented by event numbers <b>101</b>-<b>105</b> into its local version <b>740</b> of the global file system.</p><p id="p-0051" num="0050">Likewise, filer server <b>710</b> last synchronized updates to the shared versioned file system at event number <b>102</b>, the same event that filer sever <b>710</b> updated shard <b>1</b> of inode <b>10</b> (sub-directory <b>2</b>-<b>1</b> <b>502</b>), as described above. To update its local version <b>730</b> of the global file system with the latest changes, filer server <b>710</b> retrieves and merges the updates represented by event numbers <b>103</b>-<b>105</b> into its local version <b>730</b> of the global file system.</p><p id="p-0052" num="0051"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a flow chart <b>1000</b> of a method for synchronizing updates from a local version of a shared versioned file system to a cloud data store according to an embodiment. In step <b>1010</b>, the operations server receives a request for a global lock on a shard, such as shard <b>1</b> of inode <b>10</b>. At step <b>1020</b>, the operations server determines if the global lock is available for the requested shard. If the global lock is available and not in use by another filer server, the operations server sends the global lock to the requesting filer server in step <b>1030</b>. If the global lock is not available, the operations server can continue to check if for the global lock in an available state. In addition or in the alternative, the operations server can respond to the filer server that the global lock is not available. The filer server can optionally repeat the request for the global lock on the requested shard.</p><p id="p-0053" num="0052">After sending the global lock to the requesting filer server in step <b>1030</b>, the operations server adds a new event to the update table in step <b>1040</b>. The update table can be the same or substantially the same as the table illustrated in <figref idref="DRAWINGS">FIG. <b>9</b></figref>. In general, the update table is a list of each update to a shard in the cloud-based data store. Each update is assigned an event number. The update table can be used by the filer servers to synchronize updates from the cloud-based data store to their respective local versions of the shared versioned operating system. After the requesting filer server has pushed the update directory entries of the requested shard to the cloud-based data store, the operations server receives <b>1050</b> the global lock back from the requesting filer server.</p><p id="p-0054" num="0053"><figref idref="DRAWINGS">FIG. <b>11</b></figref> is a flow chart <b>1100</b> of a method for synchronizing updates from a cloud-based a shared versioned file system to a local version of same according to an embodiment. In step <b>1110</b>, the filer server queries the operating sever for a list of updates to the global file system that have occurred since the last event number updated to the file server. As an example with respect to <figref idref="DRAWINGS">FIG. <b>9</b></figref>, Filer <b>720</b> queries the operating server for a list of updates that have occurred since event <b>100</b>, the last event number updated to file server <b>720</b>. In the query, the file server can include the last event number updated to the file server in which case the operating server determines if the file server has the most recent updates by comparing the last event number updated to the file server with the most recent event number on the operations center. Alternatively, the file server can request the operations server for the most recent event number and the file server r can compare the last event number updated to the file server with the most recent event number on the operations server.</p><p id="p-0055" num="0054">In step <b>1120</b>, the file server or operations server determines if there are any new (unsynchronized) event numbers on the operations server. If the query in step <b>1010</b> includes the last event number updated to the file server, the operations center compares the last event number and the most recent event number to determine if there are any new events.</p><p id="p-0056" num="0055">Alternatively, if the file server requested the operations server for the most recent event number (and did not send the last event number in the query), the file server determines if there are any updates by comparing the most recent event on the operations server with the last event number updated to the file server, as discussed above. If there are new events, the file server requests the operations center to provide the inode number and shard number associated with each new event number.</p><p id="p-0057" num="0056">If the result of step <b>1120</b> is that there are no new events since the last event number, the flow chart <b>1100</b> returns to step <b>1110</b>. In some embodiments, the file server briefly pauses (e.g., for 30 seconds to 1 minute) before returning to step <b>1110</b>.</p><p id="p-0058" num="0057">If the result of step <b>1120</b> is that there are new events since the last event number, the flow chart <b>80</b> proceeds to step <b>1130</b>. In step <b>1130</b>, the file server receives, for each new event, the inode number and shard number associated with the new event. Using the example of <figref idref="DRAWINGS">FIGS. <b>6</b> and <b>7</b></figref> above, the new event includes inode <b>10</b> (sub-directory <b>2</b>-<b>1</b> <b>502</b>) and shard <b>1</b> (e.g., in the form of/inode/10/s1).</p><p id="p-0059" num="0058">In step <b>1140</b>, the file server retrieves the latest version of each shard received from the operations server in step <b>1130</b>. As discussed above, each shard includes a manifest of its shard directory entries (e.g., inodes corresponding to files) and metadata about each shard directory entry, such as the version of the shard in which it a file (inode) was created and the version of the shard in which the file (inode) was last updated. The file server uses this metadata in steps <b>1150</b> and <b>1160</b> to determine the state of each directory entry in the latest cloud version of the shard (step <b>1150</b>) and the state of each directory entry in the cache version of the shard (step <b>1160</b>). In step <b>1170</b>, the file server performs the appropriate operation on each cache directory entry according to the table below. In step <b>1180</b>, the file server determines if there are any additional updated shards received from the operations center that have not been processed. If so, the file server returns to step <b>1150</b> to determine the state of each directory entry in the next unprocessed shard. This loop continues until all updated shards received from the operations center have been processed. After all updated shards received from the operations center have been processed, the filer server in step <b>1180</b> returns to step <b>1110</b> to query the operation server for updates since the last event number. In this case, the last event number updated to the filer server would be the last event number from step <b>1130</b> in the last iteration through flow chart <b>1100</b>.</p><p id="p-0060" num="0059">The state of a given entry in a cloud shard version can be determined as follows.</p><p id="p-0061" num="0060">If the version number in which a directory entry (e.g., File <b>1</b>) in cloud shard <b>1</b> (a representative shard number) was last modified is the same as the latest version number of cloud shard <b>1</b>, this indicates that File <b>1</b> was updated or modified (in general, &#x201c;dirtied&#x201d;) in the latest version of cloud shard <b>1</b>. In other words, the new event for shard <b>1</b> was due, at least in part, to an update or modification to File <b>1</b>. As a shorthand, this state is referred to as &#x201c;cloud entry dirty.&#x201d;</p><p id="p-0062" num="0061">If the version number in which File <b>1</b> in cloud shard <b>1</b> was last modified is the less than the latest version number of cloud shard <b>1</b>, this indicates that File <b>1</b> was not updated or modified in the latest version of cloud shard <b>1</b>. In other words, the new event for shard <b>1</b> was not due to File <b>1</b>. As a shorthand, this state is referred to as &#x201c;cloud entry clean.&#x201d;</p><p id="p-0063" num="0062">If the version number in which File <b>1</b> in cloud shard <b>1</b> was created is the same as the latest version number of cloud shard <b>1</b>, this indicates that File <b>1</b> was created in the latest version of cloud shard <b>1</b>. In other words, the new event for shard <b>1</b> was due, at least in part, to the creation of File <b>1</b>. As a shorthand, this state is referred to as &#x201c;cloud entry created.&#x201d;</p><p id="p-0064" num="0063">If File <b>1</b> is not found in the latest version of cloud shard <b>1</b>, this indicates that File <b>1</b> does not exist in that version. For example, this would occur if a user deleted File <b>1</b> and the filer server pushed cache shard <b>1</b> with the deleted file to the cloud. As a shorthand, this state is referred to as &#x201c;cloud entry not found.&#x201d;</p><p id="p-0065" num="0064">The state of a given entry in a cache shard version can be determined as follows.</p><p id="p-0066" num="0065">If the version number in which File <b>1</b> in cache shard <b>1</b> was last modified is different than the latest version number of cache shard <b>1</b>, this indicates that File <b>1</b> has been updated or modified (in general, &#x201c;dirtied&#x201d;) since the filer server retrieved the latest cloud shard version from the cloud and merged it into local cache. In other words, cache shard <b>1</b> includes at least one modified directory entry that needs to be pushed to the cloud, at which point a new event number will be created at the operations center. As a shorthand, this state is referred to as &#x201c;cache entry dirty.&#x201d;</p><p id="p-0067" num="0066">If the version number in which File <b>1</b> in cache shard <b>1</b> was last modified is the same as the latest version number of cache shard <b>1</b>, this indicates that File <b>1</b> has been not been updated or modified since the filer server retrieved the latest cloud shard version from the cloud and merged it into local cache. As a shorthand, this state is referred to as &#x201c;cache entry clean.&#x201d;</p><p id="p-0068" num="0067">If the version number in which File <b>1</b> in cache shard <b>1</b> was created is different than the latest version number of cache shard <b>1</b>, this indicates that File <b>1</b> was created since the filer server retrieved the latest cloud shard version from the cloud and merged it into local cache. As a shorthand, this state is referred to as &#x201c;cache entry created.&#x201d;</p><p id="p-0069" num="0068">If File <b>1</b> is not found in the latest version of cache shard <b>1</b>, this indicates that File <b>1</b> does not exist in that version. For example, this would occur if a user deleted File <b>1</b> after the filer server retrieved the latest cloud shard version from the cloud and merged it into local cache. As a shorthand, this state is referred to as &#x201c;cache entry not found.&#x201d;</p><p id="p-0070" num="0069">The filer server performs different operations depending on the state of a directory entry (e.g., File <b>1</b>) in the cloud shard and in the cache shard. These operations are summarized in Table 1 and described below. The description below continues to use File <b>1</b> and shard <b>1</b> as a representative directory entry and shard for discussion purposes.</p><p id="p-0071" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="77pt" align="left"/><colspec colname="2" colwidth="70pt" align="left"/><colspec colname="3" colwidth="70pt" align="left"/><thead><row><entry namest="1" nameend="3" rowsep="1">TABLE 1</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row><row><entry>Cloud Entry State</entry><entry>Cache Entry State</entry><entry>Operation</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>Created</entry><entry>Clean</entry><entry>N/A</entry></row><row><entry>Created</entry><entry>Dirty</entry><entry>Conflict</entry></row><row><entry>Created</entry><entry>Not Found</entry><entry>Create cache entry</entry></row><row><entry>Created</entry><entry>Created</entry><entry>Conflict</entry></row><row><entry>Dirty</entry><entry>Clean</entry><entry>Update cache entry</entry></row><row><entry>Dirty</entry><entry>Dirty</entry><entry>Conflict</entry></row><row><entry>Dirty</entry><entry>Not Found</entry><entry>N/A</entry></row><row><entry>Dirty</entry><entry>Created</entry><entry>Conflict</entry></row><row><entry>Clean</entry><entry>Clean</entry><entry>Keep cache entry</entry></row><row><entry>Clean</entry><entry>Dirty</entry><entry>Keep cache entry</entry></row><row><entry>Clean</entry><entry>Not Found</entry><entry>N/A</entry></row><row><entry>Clean</entry><entry>Created</entry><entry>Keep cache entry</entry></row><row><entry>Not Found</entry><entry>Clean</entry><entry>Delete cache entry</entry></row><row><entry>Not Found</entry><entry>Dirty</entry><entry>Keep cache entry</entry></row><row><entry>Not Found</entry><entry>Created</entry><entry>Keep cache entry</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0072" num="0070">If the state of File <b>1</b> is created in cloud shard <b>1</b> and it is clean in cache shard <b>1</b>, the filer server determines it is not an applicable state and returns an error. This is indicative of a coding error as such a combination is not possible.</p><p id="p-0073" num="0071">If the state of File <b>1</b> is created in cloud shard <b>1</b> and it is dirty in cache shard <b>1</b>, the filer server determines that there is a conflict. When a conflict occurs, the filer server saves the conflicted File <b>1</b> in cache shard <b>1</b> to the cloud and changes the file name to indicate that it is a conflicted file (e.g., File <b>1</b>_conflicted).</p><p id="p-0074" num="0072">If the state of File <b>1</b> is created in cloud shard <b>1</b> and it is not found in cache shard <b>1</b>, the filer server creates a copy of File <b>1</b> in a new version of cache shard <b>1</b>.</p><p id="p-0075" num="0073">If the state of File <b>1</b> is created in cloud shard <b>1</b> and it is also created in cache shard <b>1</b>, the filer server determines that there is a conflict. This scenario could occur if users associated with different filer server create a file with the same name in the same directory (shard). In a conflict state, the filer server saves conflicted version of File <b>1</b> from cache shard <b>1</b> to the cloud and changes its file name to indicate that it is a conflicted file, as described above.</p><p id="p-0076" num="0074">If the state of File <b>1</b> is dirty in cloud shard <b>1</b> and it is clean in cache shard <b>1</b>, the filer server merges the updates from the cloud version of File <b>1</b> into the cache version of File <b>1</b>, as discussed herein. This scenario could occur if a user associated with filer server A makes an update to File <b>1</b> and sends that update to the cloud while filer server B has a clean copy in cache of the prior version of File <b>1</b>. Thus filer server B has an old version of File <b>1</b> and needs to synchronize with the cloud to obtain the updates to File <b>1</b>.</p><p id="p-0077" num="0075">If the state of File <b>1</b> is dirty in cloud shard <b>1</b> and it is dirty in cache shard <b>1</b>, the filer server determines that there is a conflict and proceeds as described above. This scenario could occur if two users make an update to the same version of File <b>1</b> close in time to one another. For example, a user associated with filer server A makes an update to File <b>1</b> and sends that update to the cloud while a second user associated with filer server B also makes an update to the same version of File <b>1</b>, but has not yet pushed that update to the cloud.</p><p id="p-0078" num="0076">If the state of File <b>1</b> is dirty in cloud shard <b>1</b> and it is not found in cache shard <b>1</b>, the filer server determines it is not an applicable state and returns an error. This is indicative of a coding error as such a combination is not possible.</p><p id="p-0079" num="0077">If the state of File <b>1</b> is dirty in cloud shard <b>1</b> and it is created in cache shard <b>1</b>, the filer server determines that there is a conflict. This scenario could occur if a user associated with filer server A makes an update to File <b>1</b>, which already exists in the cloud while a user associated with filer server B deletes File <b>1</b> and then creates a new File <b>1</b>. The filer server saves conflicted cache version of File <b>1</b> in shard <b>1</b> to the cloud and changes its file name to indicate that it is a conflicted file, as described above.</p><p id="p-0080" num="0078">If the state of File <b>1</b> is clean in cloud shard <b>1</b> and it is clean in cache shard <b>1</b>, the filer server keeps the cache version of File <b>1</b> since there have been no changes to the file.</p><p id="p-0081" num="0079">If the state of File <b>1</b> is clean in cloud shard <b>1</b> and it is dirty in cache shard <b>1</b>, the filer server keeps the cache version of File <b>1</b>. The filer server will merge the updates to File <b>1</b> the next time that the filer server pushes its updates or snapshot to the cloud. This scenario could occur if the filer server has a modified version of File <b>1</b> in cache but has not yet pushed the new version of File <b>1</b> to the cloud.</p><p id="p-0082" num="0080">If the state of File <b>1</b> is clean in cloud shard <b>1</b> and it is not found in cache shard <b>1</b>, the filer server determines it is not an applicable state and returns an error. This is indicative of a coding error as such a combination is not possible.</p><p id="p-0083" num="0081">If the state of File <b>1</b> is clean in cloud shard <b>1</b> and it is created in cache shard <b>1</b>, the filer server keeps the cache version of File <b>1</b>. The filer server will merge the updates to File <b>1</b> the next time that the filer server pushes its updates or snapshot to the cloud.</p><p id="p-0084" num="0082">If the state of File <b>1</b> is not found in cloud shard <b>1</b> and it is clean in cache shard <b>1</b>, the filer server deletes the cache version of File <b>1</b>. This scenario could occur if a user has deleted File <b>1</b> and pushed that deletion to the cloud, but another user (associated with another filer server) has a prior version of shard <b>1</b> in which File <b>1</b> is clean.</p><p id="p-0085" num="0083">If the state of File <b>1</b> is not found in cloud shard <b>1</b> and it is dirty in cache shard <b>1</b>, the filer server keeps the cache version of File <b>1</b>. This scenario could occur if a user associated with filer server A deletes File <b>1</b> and pushes that update to the cloud while a user associated with filer server B updates File <b>1</b>. The updated version of File <b>1</b> will be sent to the cloud the next time filer server B pushes its updates/snapshot to the cloud.</p><p id="p-0086" num="0084">If the state of File <b>1</b> is not found in cloud shard <b>1</b> and it is created in cache shard <b>1</b>, the filer server keeps the cache version of File <b>1</b>. This scenario could occur if a user creates a file that does not yet exist in the cloud. File <b>1</b> will be sent to the cloud the next time the filer server pushes its updates/snapshot to the cloud.</p><p id="p-0087" num="0085"><figref idref="DRAWINGS">FIG. <b>12</b></figref> is a simplified illustration of a representative shard according to an embodiment. The representative shard in <figref idref="DRAWINGS">FIG. <b>12</b></figref> is shard <b>1</b> (i.e., S1) of inode <b>1</b>, which is illustrated in the format of /inodes/[inode number]/[shard number]/[shard version number]. Using this format, version <b>1</b> of shard <b>1</b> in inode <b>1</b> is represented as /inodes/1/S1/1. As described above, the latest version number of a shard or inode can be located in cloud storage by the version number &#x201c;now.&#x201d; The &#x201c;now&#x201d; version subdirectory includes a pointer to the latest version, which in this case is version <b>1</b> (i.e., &#x201c;latest&#x201d;=&#x201c;1&#x201d;). <figref idref="DRAWINGS">FIG. <b>12</b></figref> illustrates the manifest <b>1200</b> of shard <b>1</b> version <b>1</b>, which is written in XML (though other hierarchical coding languages can be used). The manifest identifies its inode and shard number using respective &#x3c;inode&#x3e; and &#x3c;shard&#x3e; tags. The manifest also includes a list of directory entries in shard <b>1</b> version <b>1</b>. In this example, the only directory entry is for inode <b>100</b>, which has the name of file1.txt. The manifest also indicates that inode <b>100</b> has a size of 1,024 bytes.</p><p id="p-0088" num="0086"><figref idref="DRAWINGS">FIG. <b>13</b></figref> is a simplified illustration of the representative shard from <figref idref="DRAWINGS">FIG. <b>12</b></figref> after an update according to an embodiment. As illustrated in <figref idref="DRAWINGS">FIG. <b>13</b></figref>, the &#x201c;latest&#x201d; metadata has been updated with a pointer to version <b>2</b> of shard <b>1</b> of inode <b>1</b> (i.e., &#x201c;latest&#x201d;=&#x201c;2&#x201d;). In manifest <b>1300</b> of shard <b>1</b> version <b>2</b>, it is apparent that inode <b>101</b> (file <b>2</b>.<i>txt</i>) has been added to shard <b>1</b>. Inode <b>101</b> has a size of 2,048 bytes. Thus, manifest <b>1300</b> includes the directory entries of inode <b>100</b> (file1.txt) and inode <b>101</b> (file2.txt).</p><p id="p-0089" num="0087"><figref idref="DRAWINGS">FIG. <b>14</b></figref> is a simplified illustration of a representative directory entry in the representative shard of <figref idref="DRAWINGS">FIG. <b>13</b></figref>. The representative directory entry in <figref idref="DRAWINGS">FIG. <b>14</b></figref> is inode <b>101</b>, which corresponds to file2.txt as discussed above. The directory entry is illustrated in the format of /inodes/[inode number/[inode version number]. Using this format, version <b>1</b> of inode <b>101</b> is represented as /inodes/101/1. As described above, the latest version number of a shard or inode can be located in cloud storage by the version number &#x201c;now.&#x201d; The &#x201c;now&#x201d; version subdirectory includes a pointer to the latest version, which in this case is version <b>1</b> (i.e., &#x201c;latest&#x201d;=&#x201c;1&#x201d;). The manifest <b>1400</b> identifies its inode number and the chunks that form the inode. In this case, the manifest <b>1400</b> indicates that inode <b>101</b> is formed of chunks having a handle (or name) of c1 and c2. The manifest <b>1400</b> also includes metadata on the relationship between the chunks. In this case, manifest <b>1400</b> indicates that chunk c1 has an offset of 0 and a length of 1,024 bytes. Manifest <b>1400</b> also indicates that chunk c2 has an offset of 1,024 and a length of 1024 bytes. In other words, inode <b>101</b> has a total length of 2,048 bytes where chunk c1 precedes chunk c2.</p><p id="p-0090" num="0088">Chunks c1 and c2 each refer to an object in the cloud object store. In particular, chunk c1 refers to the directory /chunks/c1/data which includes a pointer to the latest version of chunk c1, which in this case is version <b>1</b>. Thus, version <b>1</b> of chunk <b>1</b> can be found at /chunks/c1/refs/100/1. Likewise chunk c2 refers to the directory /chunks/c2/data which includes a pointer to the latest version of chunk c2, which in this case is version <b>1</b>. Thus, version <b>1</b> of chunk <b>2</b> can be found at /chunks/c2/refs/100/1.</p><p id="p-0091" num="0089">In the approach described above, the inode-based approach enables file versioning to the cloud. In this approach, and when a file is changed, it is not necessary to create a new version of the entire local file system let alone at a snapshot period; indeed, upon a given occurrence in the local file system with respect to the file, a new version of just the file is created for export to the cloud, and there is no longer any requirement for the system to wait on a &#x201c;snapshot&#x201d; to do so. To this end, and as has been described, the system is structured as an inode-based file system. File system objects are indexed, stored and retrieved in cloud storage by a globally-unique inode. With an inode-based approach, the hierarchy of the file system need not be maintained.</p><p id="p-0092" num="0090">According to this technique, all versions, directories and files are referenced by inode. The following provides a description of a representative cloud storage layout.</p><p id="p-0093" num="0091">Preferably, a file manifest for a given inode is stored by (inode, version) at a cloud path: /inodes/INODENUMBER/VERSION. A directory manifest for a given inode is stored by (inode, shard, version) at a cloud path: inodes/INODENUMBER/SHARDNUMBER/VERSION. A cloud metadata tag &#x201c;latestversion&#x201d; at/inodes/INODENUMBER/now (or . . . /SHARDNUMBER/now) points to a latest manifest. In the event of cloud metadata loss, a new version is re-built given a cloud LIST of /inodes/INODENUMBER (or . . . /SHARDNUMBER). A special &#x201c;manifest version 0&#x201d; file (a version index) is stored at /inodes/INODENUMBER/index.</p><p id="p-0094" num="0092">Preferably, file chunks are encrypted sections of a file, and they can be shared by any number of file manifest versions in the cloud filesystem. File chunk data for &#x201c;chunkN&#x201d; is stored at cloud path: /chunks/chunkN/data. File chunk reference by (inode, version) are stored at cloud path: /chunks/chunkN/inode/version.</p><p id="p-0095" num="0093">For each file, a file manifest is created. Preferably, it is an XML document that describes the file inode, version and cloud chunks references (offset, length, handle).</p><p id="p-0096" num="0094">For directories, a directory may comprise a set of directory shards, each representing a smaller independent piece of the directory. The latest shard version for a given inode number preferably is stored as a &#x201c;latest&#x201d; metadata tag on path: /inode/INODENUMBER/SHARDNUMBER/now. A directory shard manifest is an XML document that describes each directory entry in the shard, inode number, stbuf, and xattrs. Preferably, stbuf, size, and attrs are stored inside a direntry for a given directory entry, other approaches may be used, e.g., large xattrs may be overflowed to a file manifest object.</p><p id="p-0097" num="0095"><figref idref="DRAWINGS">FIG. <b>15</b></figref> depicts a cloud storage layout example using the above-described data structures. This example depicts a portion of a directory manifest <b>1500</b>, a portion of a file manifest <b>1502</b>, and several inode lookup tables, namely, a directory inode table 1504, a file inode table 1506, and a chunk inode table 1508. More generally, the tables are data structures in the system. In this example scenario, and on initial format, the cloud contains &#x201c;/inodes/1/now&#x201d;, &#x201c;/inodes/1/&#x201d; and &#x201c;inodes/1/S1.&#x201d; The cloud metadata on &#x201c;/inodes/1/now&#x201d; points to 1. Now, assume two (2) files are created locally as follows: Initial format/(1); Create file /file1.text (<b>100</b>) size <b>2048</b>; Create file /file2.text (<b>101</b>) size <b>2048</b>. The numbers <b>100</b> and <b>101</b> represent inodes. The files are exported to the cloud (as part of shard S1), which then updates the cloud storage layout as depicted. Because shard S1 in the directory has been updated, the topmost entry in a directory inode table 1504 now reads as /inodes/1/S1/now (&#x201c;latest&#x201d;=&#x201c;2&#x201d;). As shown, directory manifest <b>1500</b> includes shard S1 with two directory entries for the inodes <b>100</b> and <b>101</b>. Each directory entry includes the information for the file that has been created (updated or otherwise modified) locally. The inode in the directory manifest (e.g., inode <b>100</b>) points to the file inode table 1506, which in this example has been updated to include the topmost entry: /inodes/100/now (&#x201c;latest&#x201d;=&#x201c;1&#x201d;), now the latest version of the file with that inode number. The file manifest <b>1502</b> includes the data identifying, for the particular, inode <b>100</b> (corresponding to the inode tag), the identity of the one or more chunks corresponding to the file. The chunks each having a corresponding handle. Chunk inode table 1508 then references each chunk, pointing to the inode and the version number. This de-referencing approach obviates any requirement to propagate changes to a root of a file system version, as files are each independently versioned (as opposed to a file system itself being versioned). The approach also enables support for files irrespective of their size, and it enables the cloud storage to send and receive changes even at a sub-file level. File version storage in this manner also provides for quicker response times, more efficient use of bandwidth, and improved file synchronization.</p><p id="p-0098" num="0096">The techniques improve an operation of a write-once object store, which previously could not support an inode-based storage system that conventionally requires rewrite-in-place functionality. By associating a set of inode versions of an inode with the special de-referencing pointer (and managing those inode versions) as has been described), the techniques herein enable the write-once object store to be transformed into a network-accessible file server. File changes that occur locally are then saved to the cloud using the cloud storage that is uniquely configured to support inode-based storage in the manner described.</p><p id="p-0099" num="0097">It is not required that every inode version point to a unique copy of every chunk. If a particular chunk of a file has not changed from version <b>1</b> to version <b>2</b>, that same single chunk is used by the inode at both version <b>1</b> and version <b>2</b>.</p><p id="p-0100" num="0098">While the disclosed subject matter has been described in the context of a method or process, the subject matter also relates to apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes, or it may comprise a computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium, such as, but is not limited to, any type of disk including an optical disk, a CD-ROM, and a magnetic-optical disk, a read-only memory (ROM), a random access memory (RAM), a magnetic or optical card, or any type of media suitable for storing electronic instructions, and each coupled to a computer system bus. A computer-readable medium having instructions stored thereon to perform the interface functions is tangible.</p><p id="p-0101" num="0099">A given implementation of the disclosed subject matter is software written in a given programming language that runs on a server on a hardware platform running an operating system such as Linux. As noted above, the interface may be implemented as well as a virtual machine or appliance, or in any other tangible manner.</p><p id="p-0102" num="0100">While given components of the system have been described separately, one of ordinary skill will appreciate that some of the functions may be combined or shared in given instructions, program sequences, code portions, and the like.</p><p id="p-0103" num="0101">It is appreciated that certain features of the disclosed subject matter, which are, for clarity, described in the context of separate embodiments, may also be provided in combination in a single embodiment. Conversely, various features of the disclosed subject matter that are, for brevity, described in the context of a single embodiment, may also be provided separately or in any suitable sub-combination.</p><p id="p-0104" num="0102">Unless otherwise defined, all technical and scientific terms used herein have the same meanings as are commonly understood by one of ordinary skill in the art to which this invention belongs. Although methods similar or equivalent to those described herein can be used in the practice or testing of the present invention, suitable methods are described herein. The present materials, methods, and examples are illustrative only and not intended to be limiting.</p><p id="p-0105" num="0103">It will be appreciated by persons skilled in the art that the subject matter herein is not limited to what has been particularly shown and described hereinabove. Rather the scope of the subject matter is defined by the appended claims and includes both combinations and sub-combinations of the various features described hereinabove as well as variations and modifications thereof, which would occur to persons skilled in the art upon reading the foregoing description.</p><?detailed-description description="Detailed Description" end="tail"?></description><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A method associated with an enterprise file system, comprising:<claim-text>as versions of a file in the enterprise file system are generated, instantiating in a cloud-based write-once object store multiple inode versions, the multiple inode versions sharing an inode number and representing multiple versions of the file, the multiple inode versions, taken together, representing a revision history for an inode associated with the inode number; and</claim-text><claim-text>tracking the multiple inode versions, wherein an inode version for a version of the file comprises a list of data chunks that comprise the file, together with information identifying where the data chunks are located in the cloud-based write-once object store.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. Apparatus associated with an enterprise file system, comprising:<claim-text>a processor;</claim-text><claim-text>computer memory holding computer program instructions executed by the processor, the computer program instructions configured:<claim-text>as versions of a file in the enterprise file system are generated, to instantiate in a cloud-based write-once object store multiple inode versions, the multiple inode versions sharing an inode number and representing multiple versions of the file, the multiple inode versions, taken together, representing a revision history for an inode associated with the inode number; and</claim-text><claim-text>to track the multiple inode versions, wherein an inode version for a version of the file comprises a list of data chunks that comprise the file, together with information identifying where the data chunks are located in the cloud-based write-once object store.</claim-text></claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. A computer system, comprising:<claim-text>a write-once object store, the write-once object store being configured to store inode-based data exported to the write-once object store from a file system;</claim-text><claim-text>a processor; and</claim-text><claim-text>computer memory holding computer program instructions configured:<claim-text>as versions of a file in the enterprise file system are generated, to instantiate in the cloud-based write-once object store multiple inode versions, the multiple inode versions sharing an inode number and representing multiple versions of the file, the multiple inode versions, taken together, representing a revision history for an inode associated with the inode number; and</claim-text><claim-text>to track the multiple inode versions, wherein an inode version for a version of the file comprises a list of data chunks that comprise the file, together with information identifying where the data chunks are located in the cloud-based write-once object store.</claim-text></claim-text></claim-text></claim></claims></us-patent-application>