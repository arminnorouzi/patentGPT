<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004778A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004778</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17857731</doc-number><date>20220705</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><priority-claims><priority-claim sequence="01" kind="national"><country>IN</country><doc-number>202141030178</doc-number><date>20210705</date></priority-claim><priority-claim sequence="02" kind="national"><country>IN</country><doc-number>202141030178</doc-number><date>20220627</date></priority-claim></priority-claims><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>N</subclass><main-group>3</main-group><subgroup>04</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>K</subclass><main-group>9</main-group><subgroup>62</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>7</main-group><subgroup>76</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>N</subclass><main-group>3</main-group><subgroup>04</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>K</subclass><main-group>9</main-group><subgroup>6296</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>7</main-group><subgroup>76</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e79">METHOD AND SYSTEM FOR ON-DEVICE INFERENCE IN A DEEP NEURAL NETWORK (DNN)</invention-title><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>SAMSUNG ELECTRONICS CO., LTD.</orgname><address><city>Suwon-si</city><country>KR</country></address></addressbook><residence><country>KR</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>PENTAPATI</last-name><first-name>Sai Karthikey</first-name><address><city>Bengaluru</city><country>IN</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>SHUKLA</last-name><first-name>Amit</first-name><address><city>Bengaluru</city><country>IN</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>DAS</last-name><first-name>Kinsuk</first-name><address><city>Bengaluru</city><country>IN</country></address></addressbook></inventor><inventor sequence="03" designation="us-only"><addressbook><last-name>GADDE</last-name><first-name>Raj Narayana</first-name><address><city>Bengaluru</city><country>IN</country></address></addressbook></inventor><inventor sequence="04" designation="us-only"><addressbook><last-name>MISHRA</last-name><first-name>Sandeep</first-name><address><city>Bengaluru</city><country>IN</country></address></addressbook></inventor><inventor sequence="05" designation="us-only"><addressbook><last-name>Sarvesh</last-name><address><city>Bengaluru</city><country>IN</country></address></addressbook></inventor><inventor sequence="06" designation="us-only"><addressbook><last-name>PALAKKAL</last-name><first-name>Sandeep</first-name><address><city>Bengaluru</city><country>IN</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">The disclosure relates to method and system for on-device inference in a deep neural network (DNN). The method comprises: determining whether one or more layers of the DNN satisfy one of a first, a second and a third condition, the one or more layers including one or more convolution layers and one or more resampling layers; performing the on-device inference based on the determination, wherein performing the on-device inference comprises at least one of: optimizing the one or more convolution layers in the one or more parallel branches based on the one or more layers of the DNN satisfying the first condition, optimizing the at least one of the resampling layers based on the one or more layers of the DNN satisfying the second condition, and modifying operation of the at least one of the resampling layers based on the one or more layers of the DNN satisfying the third condition.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="77.64mm" wi="128.69mm" file="US20230004778A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="105.24mm" wi="130.73mm" file="US20230004778A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="139.45mm" wi="148.67mm" file="US20230004778A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="209.47mm" wi="134.79mm" orientation="landscape" file="US20230004778A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="132.42mm" wi="155.02mm" file="US20230004778A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="137.24mm" wi="100.67mm" file="US20230004778A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="202.35mm" wi="143.85mm" orientation="landscape" file="US20230004778A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="76.96mm" wi="70.27mm" file="US20230004778A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading><p id="p-0002" num="0001">This application is based on and claims priority under 35 U.S.C. &#xa7; 119 to Indian Provisional Patent Application No. 202141030178, filed on Jul. 5, 2021, in the Indian Patent Office, and to Indian Complete Patent Application No. 202141030178, filed on Jun. 27, 2022, in the Indian Patent Office, the disclosures of all of which are incorporated by reference herein in their entireties.</p><heading id="h-0002" level="1">BACKGROUND</heading><heading id="h-0003" level="1">Field</heading><p id="p-0003" num="0002">The disclosure relates to method and system for optimizing neural networks (NN) for on-device deployment in an electronic device.</p><heading id="h-0004" level="1">Description of Related Art</heading><p id="p-0004" num="0003">On device inference is a key component of realizing solutions based on machine learning, such as video quality enhancement solutions (d-blur, d-noise etc.), on to a resource constraint compute medium, such as a mobile device. A solution can't be put into device if the architecture is not device friendly e.g., inference time is higher and takes lot of power. For example, video based and low latency application where either inference engine can run from minutes to hours, performance, power, and latency become important criterion determining the feasibility of the deployment. Modern compute elements leverage their design capabilities to run operations optimally. For example, processing time of a neural processing unit (NPU) in a deep neural network (DNN) is agnostic to number of filters in a convolution layer when maximum number of filters is below a threshold. For example, a 1 filter convolution, 2 filter convolution and 32 filter convolution takes same time on device due to agnostic behavior of the NPU. Similarly, some of the compute elements are optimized to perform optimally, when dimension is low, and channel is high. For instance, the NPU runs optimally when width and height is lower irrespective of number of channels up to a threshold, such as 32, 64. In addition, there are many operations which run optimally only for specific configurations. For example, depth to space layers work well for smaller configurations like (2*2). However, when the degree of the configuration increases, for example, to (4*4), then the performance of the DNN drops drastically.</p><p id="p-0005" num="0004">Hence, there is a need to provide techniques which address the above discussed problems.</p><heading id="h-0005" level="1">SUMMARY</heading><p id="p-0006" num="0005">In an example embodiment, the present disclosure provides to a method for on-device inference in a deep neural network (DNN). The method comprises: determining whether one or more layers of the DNN satisfy one of a first, a second and a third condition, the one or more layers including one or more convolution layers and one or more resampling layers, wherein: the first condition includes whether the one or more convolutional layers are placed in one or more parallel branches of the DNN, the second condition includes whether at least one of the resampling layers has a specified first resampling ratio, and the third condition includes whether at least one of the resampling layers is followed by a convolution layer; performing the on-device inference based on the determination, wherein performing the on-device inference comprises at least one of: optimizing the one or more convolution layers in the one or more parallel branches based on the one or more layers of the DNN satisfying the first condition, optimizing the at least one of the resampling layers based on the one or more layers of the DNN satisfying the second condition, and modifying operation of the at least one of the resampling layers based on the one or more layers of the DNN satisfying the third condition.</p><p id="p-0007" num="0006">In an example embodiment of the disclosure, a system for on-device inference in a deep neural network (DNN) is provided. The system comprises: a memory and a processor coupled to the memory. The processor is configured to: determine whether one or more layers of the DNN satisfy one of a first, a second and a third condition, the one or more layers including one or more convolution layers and one or more resampling layers, wherein:</p><p id="p-0008" num="0000">the first condition includes whether the one or more convolutional layers are placed in one or more parallel branches of the DNN, the second condition includes whether at least one of the resampling layers has a specified first resampling ratio, and the third condition includes whether at least one of the resampling layers is followed by a convolution layer; the processor is further configured to: perform the on-device inference based on the determination, wherein performing the on-device inference comprises at least one of: optimizing the one or more convolution layers in the one or more parallel branches based on the one or more layers of the DNN satisfying the first condition, optimizing the at least one of the resampling layers based on the one or more layers of the DNN satisfying the second condition, and modifying operation of the at least one of the resampling layers based on the one or more layers of the DNN satisfying the third condition</p><p id="p-0009" num="0007">To further clarify the advantages and features of the present disclosure, a detailed description will be provided with reference to specific embodiments thereof, which is illustrated in the appended drawings. It is appreciated that these drawings depict only example embodiments and are therefore not to be considered limiting its scope. The disclosure will be described and explained with additional specificity and detail with the accompanying drawings.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0006" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0010" num="0008">These and other features, aspects, and advantages of certain embodiments of the present disclosure will be more apparent from the following detailed description, taken in conjunction with the accompanying drawings, in which:</p><p id="p-0011" num="0009"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a flowchart illustrating an example method for on-device inference in a deep neural network (DNN), according to various embodiments;</p><p id="p-0012" num="0010"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a diagram illustrating an inference graph including parallel branches of convolution layers, in accordance with existing art;</p><p id="p-0013" num="0011"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a diagram illustrating example on-device inference in a deep neural network (DNN), according to various embodiments;</p><p id="p-0014" num="0012"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a diagram illustrating example on-device inference in a deep neural network (DNN), according to various embodiments;</p><p id="p-0015" num="0013"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a diagram illustrating example on-device inference in a deep neural network (DNN), according to various embodiments;</p><p id="p-0016" num="0014"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a diagram illustrating an example modifying operation of resampling layer, according to various embodiments; and</p><p id="p-0017" num="0015"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a block diagram illustrating an example configuration of a system for on-device inference in a deep neural network (DNN), according to various embodiments.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><p id="p-0018" num="0016">Further, skilled artisans will appreciate that elements in the drawings are illustrated for simplicity and may not have been necessarily drawn to scale. For example, the flowcharts illustrate the method in terms of operations involved to help to improve understanding of aspects of the present disclosure. Furthermore, in terms of the construction of the device, one or more components of the device may have been represented in the drawings by conventional symbols, and the drawings may illustrate specific details that are pertinent to understanding the embodiments of the present disclosure so as not to obscure the drawings with details that will be readily apparent to those of ordinary skill in the art having the benefit of the description herein.</p><heading id="h-0007" level="1">DETAILED DESCRIPTION</heading><p id="p-0019" num="0017">For the purpose of promoting an understanding of the principles of the disclosure, reference will now be made to example embodiments illustrated in the drawings and specific language will be used to describe the same. It will nevertheless be understood that no limitation of the scope of the disclosure is thereby intended, such alterations and further modifications in the illustrated system, and such further applications of the principles of the disclosure as illustrated therein being contemplated as would occur to one skilled in the art to which the disclosure relates.</p><p id="p-0020" num="0018">It will be understood by those skilled in the art that the foregoing general description and the following detailed description are explanatory of the disclosed embodiments and are not intended to be restrictive thereof.</p><p id="p-0021" num="0019">Reference throughout this disclosure to &#x201c;an aspect&#x201d;, &#x201c;another aspect&#x201d; or similar language may refer, for example, to a particular feature, structure, or characteristic described in connection with an embodiment being included in at least one embodiment of the present disclosure. Thus, appearances of the phrase &#x201c;in an embodiment&#x201d;, &#x201c;in another embodiment&#x201d; and similar language throughout this disclosure may, but do not necessarily, all refer to the same embodiment.</p><p id="p-0022" num="0020">The terms &#x201c;comprises&#x201d;, &#x201c;comprising&#x201d;, or any other variations thereof, are intended to cover a non-exclusive inclusion, such that a process or method that comprises a list of steps does not include only those steps but may include other steps not expressly listed or inherent to such process or method. Similarly, one or more devices or sub-systems or elements or structures or components proceeded by &#x201c;comprises . . . a&#x201d; does not, without more constraints, preclude the existence of other devices or other sub-systems or other elements or other structures or other components or additional devices or additional sub-systems or additional elements or additional structures or additional components.</p><p id="p-0023" num="0021">DNNs are trained to make predictions against previously unseen data using deep learning inference. An inference graph contains a sequence of processing steps of the DNN. In an embodiment, the inference graph may be modified to optimize the performance of the DNN, as described in greater detail below with reference to the accompanying drawings.</p><p id="p-0024" num="0022"><figref idref="DRAWINGS">FIG. <b>1</b></figref> flowchart illustrating an example method <b>100</b> for on-device inference in a deep neural network (DNN), according to various embodiments. In an embodiment, the DNN may comprise of plurality of layers. The plurality of layers may include convolution layers and resampling layers such as depth-to-space layers, space-to-depth layers, transpose convolution layers etc.</p><p id="p-0025" num="0023">As shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, at operation <b>101</b>, the method <b>100</b> may comprise determining whether one or more layers of the DNN satisfy one of a first, a second and a third condition. In an embodiment, the one or more layers may include one or more convolution layers and one or more resampling layers.</p><p id="p-0026" num="0024">At operation <b>103</b>, the method <b>100</b> may comprise performing the on-device inference based on the determination.</p><p id="p-0027" num="0025">In an embodiment, the first condition corresponds to whether the one or more convolutional layers are placed in one or more parallel branches of the DNN. For example, as shown in <figref idref="DRAWINGS">FIG. <b>2</b></figref>, the inference graph may comprise of plurality of convolution layers arranged in three parallel branches (<b>201</b>, <b>203</b>, <b>205</b>). Total time taken during inference depends on time (T1) taken for inference of convolution layer, number of convolution layers, number of branches, and time (T2) taken for inference of concatenation layer. In particular, total time taken during inference=T1(convolution)*number of convolution layer per branch*number of branches+T2(concatenation).</p><p id="p-0028" num="0026">Hence, the greater the number of convolution layers and branches, is the greater the total time taken during inference. Hence, there is a need to optimize the total inference time.</p><p id="p-0029" num="0027">Accordingly, if the first condition is satisfied, then, at operation <b>103</b>, the one or more convolution layers in the one or more parallel branches may be optimized. In an embodiment, to optimize the one or more convolution layers, the one or more parallel branches may be combined in the inference graph.</p><p id="p-0030" num="0028"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a diagram illustrating example on-device inference in a deep neural network (DNN), according to various embodiments. As shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, as per existing art (depicted as <b>301</b>), let us assume that an output from a previous convolution layer <b>301</b><i>a </i>is received with configuration of (h*w*8) and then fed to an inference graph having two parallel branches. Each branch has a single convolution layer <b>301</b><i>b</i>, <b>301</b><i>c </i>of different configuration, such as (3*1*8) and (1*3*8) on which inference is performed. After performing the inference on the individual convolution layers, output of inference is combined is fed to a concatenation layer of configuration of (h*w*16). Hence, inference has to be performed two times on the convolution layers as there are two parallel branches.</p><p id="p-0031" num="0029">This results in increase in inference time.</p><p id="p-0032" num="0030">On the other hand, in an embodiment of the disclosure (as depicted as <b>303</b>), if the parallel branches are combined, then the inference has to be performed only once on a combined convolution layer, thereby reducing inference time. The inference can be performed in following manner:</p><p id="p-0033" num="0031">First, the inference graph is received, and a number of channels required for a preceding convolution layer <b>303</b><i>a </i>is computed based on the received graph, for example, 16 channels are required in preceding convolution layer, as clear from <b>303</b>. As actual number of channels in the preceding convolution layer <b>303</b><i>a </i>is 8, then, a number of filters are added in the preceding convolution layer <b>303</b><i>a </i>by adding a plurality of dummy weights. For example, 8 dummy weights (depicted as 0, 0, 0, 0, 0, 0, 0) are added in the preceding convolution layer <b>303</b><i>a</i>. Then, the one or more convolution layers (<b>301</b><i>b</i>, <b>301</b><i>c</i>) placed in the one or more parallel branches are combined into one convolution layer <b>303</b><i>b </i>based on the added number of filters in the preceding convolution layer. For example, convolution layers <b>301</b><i>b</i>, <b>301</b><i>c </i>of different configuration of (3*1*8) and (1*3*8) are combined into a convolution layer <b>303</b><i>b </i>of a configuration of (3*3*16). Further, a common kernel size may be selected for the combined convolution layer <b>303</b><i>b</i>, wherein the kernel size is bigger than or equal to kernel size of each convolution layer <b>301</b><i>b</i>, <b>301</b><i>c </i>of the one or more convolutional layers. Filters and kernels are parameters of convolution layers. Filter size can be 3*3, 5*5, 7*7 etc. Then, a number of first filters required in each convolution layer <b>301</b><i>b</i>, <b>301</b><i>c </i>of each of the one or more parallel branches may be computed. A number of second filters required in the combined convolution layer <b>303</b><i>b </i>may be computed, wherein the number of second filters is equal to multiplication of the number of first filters in each convolution layer and number of the one or more parallel branches. For example, as shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, there are 2 parallel branches and the number of first filters required in each convolution layer <b>301</b><i>b</i>, <b>301</b><i>c </i>is 8. Hence, number of second filters required in the combined convolution layer <b>303</b><i>b </i>is 2*8=16. A plurality of weights is adjusted for the first filters in the one or more parallel branches based on the number of extra filters added (such as 8) in the preceding convolution layer <b>303</b><i>a </i>and the number of second filters required (such as 16) in the combined convolution layer. In an embodiment, to adjust the plurality of weights, the number of extra filters in the preceding convolution layer <b>303</b><i>a </i>are modified such that the number of extra filters is equal to a number of channels of the one or more convolution layers after concatenation and a number of other filters are modified in the one or more convolution layers based on the modified number of extra filters in the preceding convolution layer. For example: 1*3*8, 3*1*8 is the first layer in 2 parallel branch, the combined filters is 16. For preceding layers, the filters should be increased from 8 to 16. The plurality of adjusted weights for filters in the combined convolution layer <b>303</b><i>b </i>are re-arranged and modifying the inference graph based on the re-arrangement. For example, as shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, the modified inference graph <b>303</b><i>c </i>shows an output with 16 filters (e.g., c1, c2 - - - c16).</p><p id="p-0034" num="0032">In an embodiment, the second condition corresponds to whether at least one of the resampling layers has a predefined (e.g., specified) first resampling ratio. In an embodiment, the predefined first resampling ratio is greater than or equal to 5. It should be noted that the predefined first resampling ratio is configurable and may be different for different DNN.</p><p id="p-0035" num="0033">Referring back to <figref idref="DRAWINGS">FIG. <b>1</b></figref>, if the second condition is satisfied, then, at operation <b>103</b>, at least one of the resampling layers may be optimized. <figref idref="DRAWINGS">FIG. <b>4</b></figref> is a diagram illustrating example on-device inference in a deep neural network (DNN), according to various embodiments. In an example embodiment, the resampling layer is a depth-to-space layer. As shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref>, to optimize the least one of the resampling layers, the resampling layer may be cascaded into a plurality of cascaded resampling layers of predefined second resampling ratio. The predefined second resampling ratio is smaller than the predefined first resampling ratio. For example, in <figref idref="DRAWINGS">FIG. <b>4</b></figref>, the at least one resampling layer <b>401</b><i>a </i>of the predefined first ratio (6*6) is cascaded into two cascaded resampling layers <b>403</b><i>a</i>, <b>403</b><i>c </i>of predefined second resampling ratio of 2*2 and 3*3, respectively. A convolution layer <b>403</b><i>b </i>is added between two cascaded resampling layers <b>403</b><i>a</i>, <b>403</b><i>c </i>among the plurality of cascaded resampling layers of the predefined second resampling ratio. An inference graph comprising of the resampling layers is modified based on the plurality of cascaded resampling layers <b>403</b><i>a</i>, <b>403</b><i>c </i>and the added convolution layer <b>403</b><i>b</i>. As can be seen from <figref idref="DRAWINGS">FIG. <b>4</b></figref>, that the configuration of resampling layer of the modified inference graph <b>403</b><i>d </i>is same as or similar to the inference graph <b>401</b><i>b </i>before optimization of resampling layer (also referred as resampling layer approximation). As the inference is performed on a resampling layer with smaller sampling ratio (e.g., ratio of 2 as compared to 6), the inference time is reduced.</p><p id="p-0036" num="0034">Referring back to <figref idref="DRAWINGS">FIG. <b>1</b></figref>, in an embodiment, the third condition corresponds to whether at least one of the resampling layers is followed by a convolution layer. If the third condition is satisfied, then, at operation <b>103</b>, operation of the at least one of the resampling layers may be modified. In this example, inference may be performed on a convolution layer before performing dimension scaling operation an inference graph, as opposed to performing dimension scaling operation on the inference graph before performing inference on the convolution layer, as shown in <figref idref="DRAWINGS">FIG. <b>5</b></figref>. This way computations are performed in lower dimension (e.g., convolution layer) and higher channel, thereby reducing computational complexity. In this embodiment, weights for the convolution layer are modified and interleaved a plurality of dummy weights. The interleaved weights in filters of the convolutional layer are respaced and dimension scaling operation is performed on the inference graph. For example, as shown in <figref idref="DRAWINGS">FIG. <b>6</b></figref>, weight of 3*3*1 convolution to be applied on w*h*1 memory is adjusted to be applied on memory of size (w/4)*(h/4)*16 through weights rearrangement and dummy weight interleaving. Resampling layer is applied after this to get the data in expected dimension (w*h*1).</p><p id="p-0037" num="0035"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a block diagram illustrating an example configuration of a system <b>700</b> for on-device inference in a deep neural network (DNN), according to various embodiments. It should be noted that the system <b>700</b> may be a part of a device such as, but not limited to, mobile device, laptop, desktop, personal digital assistant (PDA) etc. For example, the system <b>700</b> may be a part of a camera system of a mobile device. The system <b>700</b> may include, but is not limited to, a processor (e.g., including processing circuitry) <b>702</b>, memory <b>704</b>, units (e.g., including various data, circuitry and/or executable instructions) <b>706</b>, and data unit <b>708</b>. The units <b>706</b> and the memory <b>704</b> may be coupled to the processor <b>702</b>. The system <b>700</b> may be configured to perform methods as discussed in reference to <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>6</b></figref>.</p><p id="p-0038" num="0036">The processor <b>702</b> may include various processing circuitry and can be a single processing unit or several units, all of which could include multiple computing units. The processors <b>702</b> may be implemented as one or more microprocessors, microcomputers, microcontrollers, digital signal processors, central processing units, state machines, logic circuitries, and/or any devices that manipulate signals based on operational instructions. Among other capabilities, the processors <b>702</b> are configured to fetch and execute computer-readable instructions and data stored in the memory <b>704</b>.</p><p id="p-0039" num="0037">The memory <b>704</b> may include any non-transitory computer-readable medium known in the art including, for example, volatile memory, such as static random access memory (SRAM) and dynamic random access memory (DRAM), and/or non-volatile memory, such as read-only memory (ROM), erasable programmable ROM, flash memories, hard disks, optical disks, and magnetic tapes.</p><p id="p-0040" num="0038">The units <b>706</b> amongst other things, include routines, programs, objects, components, data structures, etc., which perform particular tasks or implement data types. The units <b>706</b> may also be implemented as, signal processor(s), state machine(s), logic circuitries, and/or any other device or component that manipulate signals based on operational instructions.</p><p id="p-0041" num="0039">Further, the units <b>706</b> can be implemented in hardware, instructions executed by a processing unit, or by a combination thereof. The processing unit can comprise a computer, a processor, such as the processor <b>702</b> a state machine, a logic array, or any other suitable devices capable of processing instructions. The processing unit can be a general-purpose processor which executes instructions to cause the general-purpose processor to perform the required tasks or, the processing unit can be dedicated to performing the required functions. In another embodiment of the present disclosure, the units <b>706</b> may be machine-readable instructions (software) which, when executed by a processor/processing unit, perform any of the described functionalities.</p><p id="p-0042" num="0040">The data units <b>708</b> serve, amongst other things, as a repository for storing data processed, received, and generated by one or more of the units <b>706</b> respectively.</p><p id="p-0043" num="0041">Thus, the present disclosure provides following advantages:<ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0042">Reduced Inference time such as reduced to 8 ms from 80 ms</li>        <li id="ul0002-0002" num="0043">Low power consumption by the device such as reduced to 50 ma from 200 ma</li>        <li id="ul0002-0003" num="0044">Reduced computational complexity</li>    </ul>    </li></ul></p><p id="p-0044" num="0045">While specific language has been used to describe the disclosure, any limitations arising on account of the same are not intended. As would be apparent to a person in the art, various working modifications may be made to the method in order to implement the disclosure as taught herein.</p><p id="p-0045" num="0046">The drawings and the forgoing description give examples of embodiments. Those skilled in the art will appreciate that one or more of the described elements may well be combined into a single functional element. Alternatively, certain elements may be split into multiple functional elements. Elements from one embodiment may be added to another embodiment. For example, orders of processes described herein may be changed and are not limited to the manner described herein.</p><p id="p-0046" num="0047">Moreover, the actions of any flow diagram need not be implemented in the order shown; nor do all of the acts necessarily need to be performed. Also, those acts that are not dependent on other acts may be performed in parallel with the other acts. The scope of embodiments is by no means limited by these specific examples. Numerous variations, whether explicitly given in the disclosure or not, such as differences in structure, dimension, and use of material, are possible. The scope of embodiments is at least as broad as given by the following claims.</p><p id="p-0047" num="0048">Benefits, other advantages, and solutions to problems have been described above with regard to example embodiments. However, the benefits, advantages, solutions to problems, and any component(s) that may cause any benefit, advantage, or solution to occur or become more pronounced are not to be construed as a critical, required, or essential feature or component of any or all the claims.</p><p id="p-0048" num="0049">While the disclosure has been illustrated and described with reference to various example embodiments, it will be understood that the various example embodiments are intended to be illustrative, not limiting. It will be further understood by those skilled in the art that various changes in form and detail may be made without departing from the true spirit and full scope of the disclosure, including the appended claims and their equivalents. It will also be understood that any of the embodiment(s) described herein may be used in conjunction with any other embodiment(s) described herein.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A method for on-device inference in a deep neural network (DNN), the method comprising:<claim-text>determining whether one or more layers of the DNN satisfy one of a first, a second and a third condition, the one or more layers including one or more convolution layers and one or more resampling layers, wherein:<claim-text>the first condition includes whether the one or more convolutional layers are placed in one or more parallel branches of the DNN;</claim-text><claim-text>the second condition includes whether at least one of the resampling layers has a specified first resampling ratio; and</claim-text><claim-text>the third condition includes whether at least one of the resampling layers is followed by a convolution layer; and</claim-text></claim-text><claim-text>performing the on-device inference based on the determination, wherein performing the on-device inference comprises at least one of:<claim-text>optimizing the one or more convolution layers in the one or more parallel branches, based on the one or more layers of the DNN satisfying the first condition;</claim-text><claim-text>optimizing the at least one of the resampling layers, based on the one or more layers of the DNN satisfying the second condition; and</claim-text><claim-text>modifying operation of the at least one of the resampling layers, based on the one or more layers of the DNN satisfying the third condition.</claim-text></claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The method as claimed in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein optimizing the one or more convolution layers comprises:<claim-text>receiving an inference graph;</claim-text><claim-text>computing a number of channels required for a preceding convolution layer based on the received graph, wherein the preceding convolution layer is preceding to the one or more convolution layers;</claim-text><claim-text>adding a number of filters in the preceding convolution layer by adding a plurality of dummy weights; and</claim-text><claim-text>combining the one or more convolution layers placed in the one or more parallel branches into one convolution layer based on the added number of filters in the preceding convolution layer.</claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The method as claimed in <claim-ref idref="CLM-00002">claim 2</claim-ref>, further comprising:<claim-text>selecting a common kernel size for the combined convolution layer, wherein the kernel size is greater than or equal to kernel size of each convolution layer of the one or more convolutional layers;</claim-text><claim-text>computing a number of first filters required in each convolution layer of each of the one or more parallel branches;</claim-text><claim-text>computing a number of second filters required in the combined convolution layer, wherein the number of second filters is equal to a product of the number of first filters in each convolution layer and a number of the one or more parallel branches;</claim-text><claim-text>adjusting a plurality of weights for the first filters in the one or more parallel branches based on the number of extra filters added in the preceding convolution layer and the number of second filters required in the combined convolution layer;</claim-text><claim-text>re-arranging the plurality of adjusted weights for filters in the combined convolution layer; and</claim-text><claim-text>modifying the inference graph based on the re-arranging.</claim-text></claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The method as claimed in <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein adjusting the plurality of weights comprises:<claim-text>modifying the number of extra filters in the preceding convolution layer such that the number of extra filters is equal to a number of channels of the one or more convolution layers after concatenation, wherein the preceding convolution layer is preceding to the one or more convolution layers; and</claim-text><claim-text>modifying a number of other filters in the one or more convolution layers based on the modified number of extra filters in the preceding convolution layer.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The method as claimed in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein optimizing the at least one of the resampling layers comprises:<claim-text>cascading the at least one of the resampling layers of the specified first resampling ratio into a plurality of cascaded resampling layers of a specified second resampling ratio, wherein the specified second resampling ratio is less than the specified first resampling ratio;</claim-text><claim-text>adding a convolution layer between two cascaded resampling layers among the plurality of cascaded resampling layers of the specified second resampling ratio; and</claim-text><claim-text>modifying an inference graph based on the plurality of cascaded resampling layers and the added convolution layer.</claim-text></claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The method as claimed in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein, based on the at least one of the resampling layers being followed by the convolution layer, performing the inference comprises:<claim-text>modifying weights for the convolution layer;</claim-text><claim-text>interleaving a plurality of dummy weights with the modified weights in filters of the convolutional layer;</claim-text><claim-text>respacing the interleaved weights in filters of the convolutional layer; and</claim-text><claim-text>performing a dimension scaling operation on an inference graph.</claim-text></claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The method as claimed in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the one or more resampling layers includes one or more depth to space layers or one or more transpose convolution layers.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The method as claimed in <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the specified first resampling ratio is greater than or equal to 5.</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. A system for on-device inference in a deep neural network (DNN), the system comprising:<claim-text>a memory; and</claim-text><claim-text>a processor coupled to the memory and configured to:<claim-text>determine whether one or more layers of the DNN satisfy one of a first, a second and a third condition, the one or more layers including one or more convolution layers and one or more resampling layers, wherein:<claim-text>the first condition includes whether the one or more convolutional layers are placed in one or more parallel branches of the DNN;</claim-text><claim-text>the second condition includes whether at least one of the resampling layers has a specified first resampling ratio; and</claim-text><claim-text>the third condition includes whether at least one of the resampling layers is followed by a convolution layer; and</claim-text></claim-text><claim-text>perform the on-device inference based on the determination, wherein performing the on-device inference comprises at least one of:<claim-text>optimizing the one or more convolution layers in the one or more parallel branches, based on the one or more layers of the DNN satisfying the first condition;</claim-text><claim-text>optimizing the at least one of the resampling layers, based on the one or more layers of the DNN satisfying the second condition; and</claim-text><claim-text>modifying operation of the at least one of the resampling layers, based on the one or more layers of the DNN satisfying the third condition.</claim-text></claim-text></claim-text></claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The system as claimed in <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein for optimizing the one or more convolution layers, the processor is configured to:<claim-text>receive an inference graph;</claim-text><claim-text>compute a number of channels required for a preceding convolution layer based on the received graph, wherein the preceding convolution layer is preceding to the one or more convolution layers;</claim-text><claim-text>add a number of filters in the preceding convolution layer by adding a plurality of dummy weights; and</claim-text><claim-text>combine the one or more convolution layers placed in the one or more parallel branches into one convolution layer based on the added number of filters in the preceding convolution layer.</claim-text></claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The system as claimed in <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the processor is further configured to:<claim-text>select a common kernel size for the combined convolution layer, wherein the kernel size is greater than or equal to kernel size of each convolution layer of the one or more convolutional layers;</claim-text><claim-text>compute a number of first filters required in each convolution layer of each of the one or more parallel branches;</claim-text><claim-text>compute a number of second filters required in the combined convolution layer, wherein the number of second filters is equal to a product of the number of first filters in each convolution layer and a number of the one or more parallel branches;</claim-text><claim-text>adjust a plurality of weights for the first filters in the one or more parallel branches based on the number of extra filters added in the preceding convolution layer and the number of second filters required in the combined convolution layer;</claim-text><claim-text>re-arrange the plurality of adjusted weights for filters in the combined convolution layer; and</claim-text><claim-text>modify the inference graph based on the re-arranging.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The system as claimed in <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein for adjusting the plurality of weights, the processor is configured to:<claim-text>modify the number of extra filters in the preceding convolution layer such that the number of extra filters is equal to a number of channels of the one or more convolution layers after concatenation, wherein the preceding convolution layer is preceding to the one or more convolution layers; and</claim-text><claim-text>modify a number of other filters in the one or more convolution layers based on the modified number of extra filters in the preceding convolution layer.</claim-text></claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The system as claimed in <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein for optimizing the at least one of the resampling layers, the processor is configured to:<claim-text>cascade the at least one of the resampling layers of the specified first resampling ratio into a plurality of cascaded resampling layers of a specified second resampling ratio, wherein the specified second resampling ratio is less than the specified first resampling ratio;</claim-text><claim-text>add a convolution layer between two cascaded resampling layers among the plurality of cascaded resampling layers of the specified second resampling ratio; and</claim-text><claim-text>modify an inference graph based on the plurality of cascaded resampling layers and the added convolution layer.</claim-text></claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The system as claimed in <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein, based on the at least one of the resampling layers being followed by the convolution layer, for performing the inference, the processor is configured to:<claim-text>modify weights for the convolution layer;</claim-text><claim-text>interleave a plurality of dummy weights with the modified weights in filters of the convolutional layer;</claim-text><claim-text>respace the interleaved weights in filters of the convolutional layer; and</claim-text><claim-text>perform dimension scaling operation on an inference graph.</claim-text></claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The system as claimed in <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the one or more resampling layers includes one or more depth to space layers or one or more transpose convolution layers.</claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The system as claimed in <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the specified first resampling ratio is greater than or equal to 5.</claim-text></claim></claims></us-patent-application>