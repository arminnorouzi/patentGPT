<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230007264A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230007264</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17775682</doc-number><date>20201109</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>132</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>18</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>186</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>176</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>46</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>132</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>18</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>186</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>176</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>46</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">IMAGE CODING METHOD BASED ON TRANSFORM, AND DEVICE THEREFOR</invention-title><us-related-documents><us-provisional-application><document-id><country>US</country><doc-number>62933972</doc-number><date>20191111</date></document-id></us-provisional-application><us-provisional-application><document-id><country>US</country><doc-number>62933951</doc-number><date>20191111</date></document-id></us-provisional-application></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>LG Electronics Inc.</orgname><address><city>Seoul</city><country>KR</country></address></addressbook><residence><country>KR</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>KOO</last-name><first-name>Moonmo</first-name><address><city>Seoul</city><country>KR</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>KIM</last-name><first-name>Seunghwan</first-name><address><city>Seoul</city><country>KR</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>SALEHIFAR</last-name><first-name>Mehdi</first-name><address><city>Seoul</city><country>KR</country></address></addressbook></inventor><inventor sequence="03" designation="us-only"><addressbook><last-name>LIM</last-name><first-name>Jaehyun</first-name><address><city>Seoul</city><country>KR</country></address></addressbook></inventor></inventors></us-parties><pct-or-regional-filing-data><document-id><country>WO</country><doc-number>PCT/KR2020/015587</doc-number><date>20201109</date></document-id><us-371c12-date><date>20220510</date></us-371c12-date></pct-or-regional-filing-data></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">An image decoding method according to the present document comprises a step of applying an inverse primary transform to a transform coefficient so as to derive residual samples for a current block, wherein: the inverse primary transform is performed on the basis of an MTS index received from a bitstream; the MTS index is parsed on the basis of an effective coefficient not existing in a second area that excludes the left top first area of the current block; and the first area is a left top 16&#xd7;16 area of the current block.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="75.01mm" wi="95.50mm" file="US20230007264A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="124.38mm" wi="97.54mm" file="US20230007264A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="197.61mm" wi="136.23mm" orientation="landscape" file="US20230007264A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="192.79mm" wi="130.81mm" orientation="landscape" file="US20230007264A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="173.48mm" wi="130.13mm" orientation="landscape" file="US20230007264A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="163.32mm" wi="125.22mm" file="US20230007264A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="140.80mm" wi="92.03mm" file="US20230007264A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="193.72mm" wi="102.70mm" file="US20230007264A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="88.82mm" wi="83.48mm" file="US20230007264A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="154.52mm" wi="120.06mm" file="US20230007264A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="215.14mm" wi="121.92mm" file="US20230007264A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="215.14mm" wi="121.92mm" file="US20230007264A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="136.99mm" wi="116.92mm" file="US20230007264A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="208.03mm" wi="84.75mm" file="US20230007264A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00014" num="00014"><img id="EMI-D00014" he="124.12mm" wi="121.24mm" file="US20230007264A1-20230105-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00015" num="00015"><img id="EMI-D00015" he="142.07mm" wi="86.53mm" file="US20230007264A1-20230105-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00016" num="00016"><img id="EMI-D00016" he="130.22mm" wi="127.68mm" file="US20230007264A1-20230105-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00017" num="00017"><img id="EMI-D00017" he="154.43mm" wi="127.68mm" file="US20230007264A1-20230105-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00018" num="00018"><img id="EMI-D00018" he="173.91mm" wi="151.55mm" orientation="landscape" file="US20230007264A1-20230105-D00018.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">TECHNICAL FIELD</heading><p id="p-0002" num="0001">The present disclosure relates to an image coding technique and, more particularly, to a method and an apparatus for coding an image based on transform in an image coding system.</p><heading id="h-0002" level="1">RELATED ART</heading><p id="p-0003" num="0002">Nowadays, the demand for high-resolution and high-quality images/videos such as 4K, 8K or more ultra high definition (UHD) images/videos has been increasing in various fields. As the image/video data becomes higher resolution and higher quality, the transmitted information amount or bit amount increases as compared to the conventional image data. Therefore, when image data is transmitted using a medium such as a conventional wired/wireless broadband line or image/video data is stored using an existing storage medium, the transmission cost and the storage cost thereof are increased.</p><p id="p-0004" num="0003">Further, nowadays, the interest and demand for immersive media such as virtual reality (VR), artificial reality (AR) content or hologram, or the like is increasing, and broadcasting for images/videos having image features different from those of real images, such as a game image is increasing.</p><p id="p-0005" num="0004">Accordingly, there is a need for a highly efficient image/video compression technique for effectively compressing and transmitting or storing, and reproducing information of high resolution and high quality images/videos having various features as described above.</p><heading id="h-0003" level="1">SUMMARY</heading><p id="p-0006" num="0005">A technical aspect of the present disclosure is to provide a method and an apparatus for increasing image coding efficiency.</p><p id="p-0007" num="0006">Another technical aspect of the present disclosure is to provide a method and an apparatus for increasing efficiency in coding a transform index.</p><p id="p-0008" num="0007">Still another technical aspect of the present disclosure is to provide an image coding method and an image coding apparatus using an MTS.</p><p id="p-0009" num="0008">Yet another technical aspect of the present disclosure is to provide an image coding method and an image coding apparatus for signaling of an MTS index.</p><p id="p-0010" num="0009">According to an embodiment of the present disclosure, there is provided an image decoding method performed by a decoding apparatus. The method may include deriving residual samples for the current block by applying an inverse primary transform to the transform coefficients, wherein the inverse primary transform is performed based on an MTS index received from the bitstream, wherein the MTS index is parsed based on a significant coefficient not being in a second region other than a top-left first region of the current block, and wherein the first region is a top-left 16&#xd7;16 region of the current block.</p><p id="p-0011" num="0010">The MTS index is parsed based on flag information indicating whether the significant coefficient exists in the second region, and wherein the flag information is derived by determining whether the significant coefficient exists in the second region by a unit of a scan subblock of scanning the significant coefficient.</p><p id="p-0012" num="0011">When a value of a flag indicating whether the significant coefficient exists in the scan subblock is 1 and the significant coefficient existing in the scan subblock is positioned in the second region, the flag information indicates that the significant coefficient exists in the second region.</p><p id="p-0013" num="0012">When a value of a flag indicating whether the significant coefficient exists in the scan subblock is 1 and the scan subblock is positioned in the second region, the flag information indicates that the significant coefficient exists in the second region.</p><p id="p-0014" num="0013">The flag information is initially set to 1, and when the significant coefficient is positioned in the second region, the flag information is changed to 0.</p><p id="p-0015" num="0014">The scan subblock is a 4&#xd7;4 block, and the scan subblock is scanned according to a reverse diagonal scan direction from the position of the last significant coefficient in the current block.</p><p id="p-0016" num="0015">According to another embodiment of the present disclosure, there is provided an image encoding method performed by an encoding apparatus. The method may include deriving transform coefficients for the current block by applying an MTS to the residual samples; zeroing out a second region other than a top-left first region of the current block; deriving residual information based on the transform coefficient of the first region; and constructing image information to parse an MTS index indicating an MTS transform kernel based on a significant coefficient exists in the second region; wherein the first region is a top-left 16&#xd7;16 region of the current block.</p><p id="p-0017" num="0016">According to still another embodiment of the present disclosure, there may be provided a digital storage medium that stores image data including encoded image information and a bitstream generated according to an image encoding method performed by an encoding apparatus.</p><p id="p-0018" num="0017">According to yet another embodiment of the present disclosure, there may be provided a digital storage medium that stores image data including encoded image information and a bitstream to cause a decoding apparatus to perform the image decoding method.</p><p id="p-0019" num="0018">According to the present disclosure, it is possible to increase overall image/video compression efficiency.</p><p id="p-0020" num="0019">According to the present disclosure, it is possible to increase efficiency in coding an MTS index.</p><p id="p-0021" num="0020">According to the present disclosure, it is possible to increase efficiency of an image coding method using an MTS.</p><p id="p-0022" num="0021">The effects that can be obtained through specific examples of the present disclosure are not limited to the effects listed above. For example, there may be various technical effects that a person having ordinary skill in the related art can understand or derive from the present disclosure. Accordingly, specific effects of the present disclosure are not limited to those explicitly described in the present disclosure and may include various effects that can be understood or derived from the technical features of the present disclosure.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. <b>1</b></figref> schematically illustrates an example of a video/image coding system to which the present disclosure is applicable.</p><p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a diagram schematically illustrating a configuration of a video/image encoding apparatus to which the present disclosure is applicable.</p><p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a diagram schematically illustrating a configuration of a video/image decoding apparatus to which the present disclosure is applicable.</p><p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is schematically illustrates a multiple transform scheme according to an embodiment of the present document.</p><p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. <b>5</b></figref> exemplarily shows intra directional modes of 65 prediction directions.</p><p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a diagram for explaining RST according to an embodiment of the present.</p><p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a diagram illustrating a sequence of arranging output data of a forward primary transformation into a one-dimensional vector according to an example.</p><p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a diagram illustrating a sequence of arranging output data of a forward secondary transform into a two-dimensional block according to an example.</p><p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a diagram illustrating wide-angle intra prediction modes according to an embodiment of the present document.</p><p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a diagram illustrating a block shape to which LFNST is applied.</p><p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. <b>11</b></figref> is a diagram illustrating an arrangement of output data of a forward LFNST according to an example.</p><p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. <b>12</b></figref> is a diagram illustrating that the number of output data for a forward LFNST is limited to a maximum of 16 according to an example.</p><p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. <b>13</b></figref> is a diagram illustrating zero-out in a block to which 4&#xd7;4 LFNST is applied according to an example.</p><p id="p-0036" num="0035"><figref idref="DRAWINGS">FIG. <b>14</b></figref> is a diagram illustrating zero-out in a block to which 8&#xd7;8 LFNST is applied according to an example.</p><p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. <b>15</b></figref> illustrates a scan of a 32&#xd7;32 transform block according to an embodiment of the present disclosure.</p><p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. <b>16</b></figref> is a flowchart for explaining an image decoding method according to an example.</p><p id="p-0039" num="0038"><figref idref="DRAWINGS">FIG. <b>17</b></figref> is a flowchart for explaining an image encoding method according to an example.</p><p id="p-0040" num="0039"><figref idref="DRAWINGS">FIG. <b>18</b></figref> illustrates the structure of a content streaming system to which the present disclosure is applied.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0005" level="1">DESCRIPTION OF EXEMPLARY EMBODIMENTS</heading><p id="p-0041" num="0040">While the present disclosure may be susceptible to various modifications and include various embodiments, specific embodiments thereof have been shown in the drawings by way of example and will now be described in detail. However, this is not intended to limit the present disclosure to the specific embodiments disclosed herein. The terminology used herein is for the purpose of describing specific embodiments only, and is not intended to limit technical idea of the present disclosure. The singular forms may include the plural forms unless the context clearly indicates otherwise. The terms such as &#x201c;include&#x201d; and &#x201c;have&#x201d; are intended to indicate that features, numbers, steps, operations, elements, components, or combinations thereof used in the following description exist, and thus should not be understood as that the possibility of existence or addition of one or more different features, numbers, steps, operations, elements, components, or combinations thereof is excluded in advance.</p><p id="p-0042" num="0041">Meanwhile, each component on the drawings described herein is illustrated independently for convenience of description as to characteristic functions different from each other, and however, it is not meant that each component is realized by a separate hardware or software. For example, any two or more of these components may be combined to form a single component, and any single component may be divided into plural components. The embodiments in which components are combined and/or divided will belong to the scope of the patent right of the present disclosure as long as they do not depart from the essence of the present disclosure.</p><p id="p-0043" num="0042">Hereinafter, preferred embodiments of the present disclosure will be explained in more detail while referring to the attached drawings. In addition, the same reference signs are used for the same components on the drawings, and repeated descriptions for the same components will be omitted.</p><p id="p-0044" num="0043">This document relates to video/image coding. For example, the method/example disclosed in this document may relate to a VVC (Versatile Video Coding) standard (ITU-T Rec. H.266), a next-generation video/image coding standard after VVC, or other video coding related standards (e.g., HEVC (High Efficiency Video Coding) standard (ITU-T Rec. H.265), EVC (essential video coding) standard, AVS2 standard, etc.).</p><p id="p-0045" num="0044">In this document, a variety of embodiments relating to video/image coding may be provided, and, unless specified to the contrary, the embodiments may be combined to each other and be performed.</p><p id="p-0046" num="0045">In this document, a video may mean a set of a series of images over time. Generally a picture means a unit representing an image at a specific time zone, and a slice/tile is a unit constituting a part of the picture. The slice/tile may include one or more coding tree units (CTUs). One picture may be constituted by one or more slices/tiles. One picture may be constituted by one or more tile groups. One tile group may include one or more tiles.</p><p id="p-0047" num="0046">A pixel or a pel may mean a smallest unit constituting one picture (or image). Also, &#x2018;sample&#x2019; may be used as a term corresponding to a pixel. A sample may generally represent a pixel or a value of a pixel, and may represent only a pixel/pixel value of a luma component or only a pixel/pixel value of a chroma component. Alternatively, the sample may refer to a pixel value in the spatial domain, or when this pixel value is converted to the frequency domain, it may refer to a transform coefficient in the frequency domain.</p><p id="p-0048" num="0047">A unit may represent the basic unit of image processing. The unit may include at least one of a specific region and information related to the region. One unit may include one luma block and two chroma (e.g., cb, cr) blocks. The unit and a term such as a block, an area, or the like may be used in place of each other according to circumstances. In a general case, an M&#xd7;N block may include a set (or an array) of samples (or sample arrays) or transform coefficients consisting of M columns and N rows.</p><p id="p-0049" num="0048">In this document, the term &#x201c;/&#x201d; and &#x201c;,&#x201d; should be interpreted to indicate &#x201c;and/or.&#x201d; For instance, the expression &#x201c;A/B&#x201d; may mean &#x201c;A and/or B.&#x201d; Further, &#x201c;A, B&#x201d; may mean &#x201c;A and/or B.&#x201d; Further, &#x201c;A/B/C&#x201d; may mean &#x201c;at least one of A, B, and/or C.&#x201d; Also, &#x201c;A/B/C&#x201d; may mean &#x201c;at least one of A, B, and/or C.&#x201d;</p><p id="p-0050" num="0049">Further, in the document, the term &#x201c;or&#x201d; should be interpreted to indicate &#x201c;and/or.&#x201d; For instance, the expression &#x201c;A or B&#x201d; may include 1) only A, 2) only B, and/or 3) both A and B. In other words, the term &#x201c;or&#x201d; in this document should be interpreted to indicate &#x201c;additionally or alternatively.&#x201d;</p><p id="p-0051" num="0050">In the present disclosure, &#x201c;at least one of A and B&#x201d; may mean &#x201c;only A&#x201d;, &#x201c;only B&#x201d;, or &#x201c;both A and B&#x201d;. In addition, in the present disclosure, the expression &#x201c;at least one of A or B&#x201d; or &#x201c;at least one of A and/or B&#x201d; may be interpreted as &#x201c;at least one of A and B&#x201d;.</p><p id="p-0052" num="0051">In addition, in the present disclosure, &#x201c;at least one of A, B, and C&#x201d; may mean &#x201c;only A&#x201d;, &#x201c;only B&#x201d;, &#x201c;only C&#x201d;, or &#x201c;any combination of A, B, and C&#x201d;. In addition, &#x201c;at least one of A, B, or C&#x201d; or &#x201c;at least one of A, B, and/or C&#x201d; may mean &#x201c;at least one of A, B, and C&#x201d;.</p><p id="p-0053" num="0052">In addition, a parenthesis used in the present disclosure may mean &#x201c;for example&#x201d;. Specifically, when indicated as &#x201c;prediction (intra prediction)&#x201d;, it may mean that &#x201c;intra prediction&#x201d; is proposed as an example of &#x201c;prediction&#x201d;. In other words, the &#x201c;prediction&#x201d; of the present disclosure is not limited to &#x201c;intra prediction&#x201d;, and &#x201c;intra prediction&#x201d; may be proposed as an example of &#x201c;prediction&#x201d;. In addition, when indicated as &#x201c;prediction (i.e., intra prediction)&#x201d;, it may also mean that &#x201c;intra prediction&#x201d; is proposed as an example of &#x201c;prediction&#x201d;.</p><p id="p-0054" num="0053">Technical features individually described in one figure in the present disclosure may be individually implemented or may be simultaneously implemented.</p><p id="p-0055" num="0054"><figref idref="DRAWINGS">FIG. <b>1</b></figref> schematically illustrates an example of a video/image coding system to which the present disclosure is applicable.</p><p id="p-0056" num="0055">Referring to <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the video/image coding system may include a first device (source device) and a second device (receive device). The source device may deliver encoded video/image information or data in the form of a file or streaming to the receive device via a digital storage medium or network.</p><p id="p-0057" num="0056">The source device may include a video source, an encoding apparatus, and a transmitter. The receive device may include a receiver, a decoding apparatus, and a renderer. The encoding apparatus may be called a video/image encoding apparatus, and the decoding apparatus may be called a video/image decoding apparatus. The transmitter may be included in the encoding apparatus. The receiver may be included in the decoding apparatus. The renderer may include a display, and the display may be configured as a separate device or an external component.</p><p id="p-0058" num="0057">The video source may obtain a video/image through a process of capturing, synthesizing, or generating a video/image. The video source may include a video/image capture device and/or a video/image generating device. The video/image capture device may include, for example, one or more cameras, video/image archives including previously captured video/images, or the like. The video/image generating device may include, for example, a computer, a tablet and a smartphone, and may (electronically) generate a video/image. For example, a virtual video/image may be generated through a computer or the like. In this case, the video/image capturing process may be replaced by a process of generating related data.</p><p id="p-0059" num="0058">The encoding apparatus may encode an input video/image. The encoding apparatus may perform a series of procedures such as prediction, transform, and quantization for compression and coding efficiency. The encoded data (encoded video/image information) may be output in the form of a bitstream.</p><p id="p-0060" num="0059">The transmitter may transmit the encoded video/image information or data output in the form of a bitstream to the receiver of the receive device through a digital storage medium or a network in the form of a file or streaming. The digital storage medium may include various storage mediums such as USB, SD, CD, DVD, Blu-ray, HDD, SSD, and the like. The transmitter may include an element for generating a media file through a predetermined file format, and may include an element for transmission through a broadcast/communication network. The receiver may receive/extract the bitstream and transmit the received/extracted bitstream to the decoding apparatus.</p><p id="p-0061" num="0060">The decoding apparatus may decode a video/image by performing a series of procedures such as dequantization, inverse transform, prediction, and the like corresponding to the operation of the encoding apparatus.</p><p id="p-0062" num="0061">The renderer may render the decoded video/image. The rendered video/image may be displayed through the display.</p><p id="p-0063" num="0062"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a diagram schematically illustrating a configuration of a video/image encoding apparatus to which the present disclosure is applicable. Hereinafter, what is referred to as the video encoding apparatus may include an image encoding apparatus.</p><p id="p-0064" num="0063">Referring to <figref idref="DRAWINGS">FIG. <b>2</b></figref>, the encoding apparatus <b>200</b> may include an image partitioner <b>210</b>, a predictor <b>220</b>, a residual processor <b>230</b>, an entropy encoder <b>240</b>, an adder <b>250</b>, a filter <b>260</b>, and a memory <b>270</b>. The predictor <b>220</b> may include an inter predictor <b>221</b> and an intra predictor <b>222</b>. The residual processor <b>230</b> may include a transformer <b>232</b>, a quantizer <b>233</b>, a dequantizer <b>234</b>, an inverse transformer <b>235</b>. The residual processor <b>230</b> may further include a subtractor <b>231</b>. The adder <b>250</b> may be called a reconstructor or reconstructed block generator. The image partitioner <b>210</b>, the predictor <b>220</b>, the residual processor <b>230</b>, the entropy encoder <b>240</b>, the adder <b>250</b>, and the filter <b>260</b>, which have been described above, may be constituted by one or more hardware components (e.g., encoder chipsets or processors) according to an embodiment. Further, the memory <b>270</b> may include a decoded picture buffer (DPB), and may be constituted by a digital storage medium. The hardware component may further include the memory <b>270</b> as an internal/external component.</p><p id="p-0065" num="0064">The image partitioner <b>210</b> may partition an input image (or a picture or a frame) input to the encoding apparatus <b>200</b> into one or more processing units. As one example, the processing unit may be called a coding unit (CU). In this case, starting with a coding tree unit (CTU) or the largest coding unit (LCU), the coding unit may be recursively partitioned according to the Quad-tree binary-tree ternary-tree (QTBTTT) structure. For example, one coding unit may be divided into a plurality of coding units of a deeper depth based on the quad-tree structure, the binary-tree structure, and/or the ternary structure. In this case, for example, the quad-tree structure may be applied first and the binary-tree structure and/or the ternary structure may be applied later. Alternatively, the binary-tree structure may be applied first. The coding procedure according to the present disclosure may be performed based on the final coding unit which is not further partitioned. In this case, the maximum coding unit may be used directly as a final coding unit based on coding efficiency according to the image characteristic. Alternatively, the coding unit may be recursively partitioned into coding units of a further deeper depth as needed, so that the coding unit of an optimal size may be used as a final coding unit. Here, the coding procedure may include procedures such as prediction, transform, and reconstruction, which will be described later. As another example, the processing unit may further include a prediction unit (PU) or a transform unit (TU). In this case, the prediction unit and the transform unit may be split or partitioned from the above-described final coding unit. The prediction unit may be a unit of sample prediction, and the transform unit may be a unit for deriving a transform coefficient and/or a unit for deriving a residual signal from a transform coefficient.</p><p id="p-0066" num="0065">The unit and a term such as a block, an area, or the like may be used in place of each other according to circumstances. In a general case, an M&#xd7;N block may represent a set of samples or transform coefficients consisting of M columns and N rows. The sample may generally represent a pixel or a value of a pixel, and may represent only a pixel/pixel value of a luma component, or only a pixel/pixel value of a chroma component. The sample may be used as a term corresponding to a pixel or a pel of one picture (or image).</p><p id="p-0067" num="0066">The subtractor <b>231</b> subtracts a prediction signal (predicted block, prediction sample array) output from the predictor <b>220</b> from an input image signal (original block, original sample array) to generate a residual signal (residual block, residual sample array), and the generated residual signal is transmitted to the transformer <b>232</b>. The predictor <b>220</b> may perform prediction on a processing target block (hereinafter, referred to as &#x2018;current block&#x2019;), and may generate a predicted block including prediction samples for the current block. The predictor <b>220</b> may determine whether intra prediction or inter prediction is applied on a current block or CU basis. As discussed later in the description of each prediction mode, the predictor may generate various information relating to prediction, such as prediction mode information, and transmit the generated information to the entropy encoder <b>240</b>. The information on the prediction may be encoded in the entropy encoder <b>240</b> and output in the form of a bitstream.</p><p id="p-0068" num="0067">The intra predictor <b>222</b> may predict the current block by referring to samples in the current picture. The referred samples may be located in the neighbor of or apart from the current block according to the prediction mode. In the intra prediction, prediction modes may include a plurality of non-directional modes and a plurality of directional modes. The non-directional modes may include, for example, a DC mode and a planar mode. The directional mode may include, for example, 33 directional prediction modes or 65 directional prediction modes according to the degree of detail of the prediction direction. However, this is merely an example, and more or less directional prediction modes may be used depending on a setting. The intra predictor <b>222</b> may determine the prediction mode applied to the current block by using the prediction mode applied to the neighboring block.</p><p id="p-0069" num="0068">The inter predictor <b>221</b> may derive a predicted block for the current block based on a reference block (reference sample array) specified by a motion vector on a reference picture. At this time, in order to reduce the amount of motion information transmitted in the inter prediction mode, the motion information may be predicted on a block, subblock, or sample basis based on correlation of motion information between the neighboring block and the current block. The motion information may include a motion vector and a reference picture index. The motion information may further include inter prediction direction (L0 prediction, L1 prediction, Bi prediction, etc.) information. In the case of inter prediction, the neighboring block may include a spatial neighboring block existing in the current picture and a temporal neighboring block existing in the reference picture. The reference picture including the reference block and the reference picture including the temporal neighboring block may be same to each other or different from each other. The temporal neighboring block may be called a collocated reference block, a collocated CU (colCU), and the like, and the reference picture including the temporal neighboring block may be called a collocated picture (colPic). For example, the inter predictor <b>221</b> may configure a motion information candidate list based on neighboring blocks and generate information indicating which candidate is used to derive a motion vector and/or a reference picture index of the current block. Inter prediction may be performed based on various prediction modes. For example, in the case of a skip mode and a merge mode, the inter predictor <b>221</b> may use motion information of the neighboring block as motion information of the current block. In the skip mode, unlike the merge mode, the residual signal may not be transmitted. In the case of the motion information prediction (motion vector prediction, MVP) mode, the motion vector of the neighboring block may be used as a motion vector predictor and the motion vector of the current block may be indicated by signaling a motion vector difference.</p><p id="p-0070" num="0069">The predictor <b>220</b> may generate a prediction signal based on various prediction methods. For example, the predictor may apply intra prediction or inter prediction for prediction on one block, and, as well, may apply intra prediction and inter prediction at the same time. This may be called combined inter and intra prediction (CIIP). Further, the predictor may be based on an intra block copy (IBC) prediction mode, or a palette mode in order to perform prediction on a block. The IBC prediction mode or palette mode may be used for content image/video coding of a game or the like, such as screen content coding (SCC). Although the IBC basically performs prediction in a current block, it can be performed similarly to inter prediction in that it derives a reference block in a current block. That is, the IBC may use at least one of inter prediction techniques described in the present disclosure.</p><p id="p-0071" num="0070">The prediction signal generated through the inter predictor <b>221</b> and/or the intra predictor <b>222</b> may be used to generate a reconstructed signal or to generate a residual signal. The transformer <b>232</b> may generate transform coefficients by applying a transform technique to the residual signal. For example, the transform technique may include at least one of a discrete cosine transform (DCT), a discrete sine transform (DST), a Karhunen-Lo&#xe8;ve transform (KLT), a graph-based transform (GBT), or a conditionally non-linear transform (CNT). Here, the GBT means transform obtained from a graph when relationship information between pixels is represented by the graph. The CNT refers to transform obtained based on a prediction signal generated using all previously reconstructed pixels. In addition, the transform process may be applied to square pixel blocks having the same size or may be applied to blocks having a variable size rather than the square one.</p><p id="p-0072" num="0071">The quantizer <b>233</b> may quantize the transform coefficients and transmit them to the entropy encoder <b>240</b>, and the entropy encoder <b>240</b> may encode the quantized signal (information on the quantized transform coefficients) and output the encoded signal in a bitstream. The information on the quantized transform coefficients may be referred to as residual information. The quantizer <b>233</b> may rearrange block type quantized transform coefficients into a one-dimensional vector form based on a coefficient scan order, and generate information on the quantized transform coefficients based on the quantized transform coefficients of the one-dimensional vector form. The entropy encoder <b>240</b> may perform various encoding methods such as, for example, exponential Golomb, context-adaptive variable length coding (CAVLC), context-adaptive binary arithmetic coding (CABAC), and the like. The entropy encoder <b>240</b> may encode information necessary for video/image reconstruction other than quantized transform coefficients (e.g. values of syntax elements, etc.) together or separately. Encoded information (e.g., encoded video/image information) may be transmitted or stored on a unit basis of a network abstraction layer (NAL) in the form of a bitstream. The video/image information may further include information on various parameter sets such as an adaptation parameter set (APS), a picture parameter set (PPS), a sequence parameter set (SPS), a video parameter set (VPS) or the like. Further, the video/image information may further include general constraint information. In the present disclosure, information and/or syntax elements which are transmitted/signaled to the decoding apparatus from the encoding apparatus may be included in video/image information. The video/image information may be encoded through the above-described encoding procedure and included in the bitstream. The bitstream may be transmitted through a network, or stored in a digital storage medium. Here, the network may include a broadcast network, a communication network and/or the like, and the digital storage medium may include various storage media such as USB, SD, CD, DVD, Blu-ray, HDD, SSD, and the like. A transmitter (not shown) which transmits a signal output from the entropy encoder <b>240</b> and/or a storage (not shown) which stores it may be configured as an internal/external element of the encoding apparatus <b>200</b>, or the transmitter may be included in the entropy encoder <b>240</b>.</p><p id="p-0073" num="0072">Quantized transform coefficients output from the quantizer <b>233</b> may be used to generate a prediction signal. For example, by applying dequantization and inverse transform to quantized transform coefficients through the dequantizer <b>234</b> and the inverse transformer <b>235</b>, the residual signal (residual block or residual samples) may be reconstructed. The adder <b>155</b> adds the reconstructed residual signal to a prediction signal output from the inter predictor <b>221</b> or the intra predictor <b>222</b>, so that a reconstructed signal (reconstructed picture, reconstructed block, reconstructed sample array) may be generated. When there is no residual for a processing target block as in a case where the skip mode is applied, the predicted block may be used as a reconstructed block. The adder <b>250</b> may be called a reconstructor or a reconstructed block generator. The generated reconstructed signal may be used for intra prediction of a next processing target block in the current block, and as described later, may be used for inter prediction of a next picture through filtering.</p><p id="p-0074" num="0073">Meanwhile, in the picture encoding and/or reconstructing process, luma mapping with chroma scaling (LMCS) may be applied.</p><p id="p-0075" num="0074">The filter <b>260</b> may improve subjective/objective video quality by applying the filtering to the reconstructed signal. For example, the filter <b>260</b> may generate a modified reconstructed picture by applying various filtering methods to the reconstructed picture, and may store the modified reconstructed picture in the memory <b>270</b>, specifically in the DPB of the memory <b>270</b>. The various filtering methods may include, for example, deblocking filtering, sample adaptive offset, an adaptive loop filter, a bilateral filter or the like. As discussed later in the description of each filtering method, the filter <b>260</b> may generate various information relating to filtering, and transmit the generated information to the entropy encoder <b>240</b>. The information on the filtering may be encoded in the entropy encoder <b>240</b> and output in the form of a bitstream.</p><p id="p-0076" num="0075">The modified reconstructed picture which has been transmitted to the memory <b>270</b> may be used as a reference picture in the inter predictor <b>221</b>. Through this, the encoding apparatus can avoid prediction mismatch in the encoding apparatus <b>100</b> and a decoding apparatus when the inter prediction is applied, and can also improve coding efficiency.</p><p id="p-0077" num="0076">The memory <b>270</b> DPB may store the modified reconstructed picture in order to use it as a reference picture in the inter predictor <b>221</b>. The memory <b>270</b> may store motion information of a block in the current picture, from which motion information has been derived (or encoded) and/or motion information of blocks in an already reconstructed picture. The stored motion information may be transmitted to the inter predictor <b>221</b> to be utilized as motion information of a neighboring block or motion information of a temporal neighboring block. The memory <b>270</b> may store reconstructed samples of reconstructed blocks in the current picture, and transmit them to the intra predictor <b>222</b>.</p><p id="p-0078" num="0077"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a diagram schematically illustrating a configuration of a video/image decoding apparatus to which the present disclosure is applicable.</p><p id="p-0079" num="0078">Referring to <figref idref="DRAWINGS">FIG. <b>3</b></figref>, the video decoding apparatus <b>300</b> may include an entropy decoder <b>310</b>, a residual processor <b>320</b>, a predictor <b>330</b>, an adder <b>340</b>, a filter <b>350</b> and a memory <b>360</b>. The predictor <b>330</b> may include an inter predictor <b>331</b> and an intra predictor <b>332</b>. The residual processor <b>320</b> may include a dequantizer <b>321</b> and an inverse transformer <b>321</b>. The entropy decoder <b>310</b>, the residual processor <b>320</b>, the predictor <b>330</b>, the adder <b>340</b>, and the filter <b>350</b>, which have been described above, may be constituted by one or more hardware components (e.g., decoder chipsets or processors) according to an embodiment. Further, the memory <b>360</b> may include a decoded picture buffer (DPB), and may be constituted by a digital storage medium. The hardware component may further include the memory <b>360</b> as an internal/external component.</p><p id="p-0080" num="0079">When a bitstream including video/image information is input, the decoding apparatus <b>300</b> may reconstruct an image correspondingly to a process by which video/image information has been processed in the encoding apparatus of <figref idref="DRAWINGS">FIG. <b>2</b></figref>. For example, the decoding apparatus <b>300</b> may derive units/blocks based on information relating to block partition obtained from the bitstream. The decoding apparatus <b>300</b> may perform decoding by using a processing unit applied in the encoding apparatus. Therefore, the processing unit of decoding may be, for example, a coding unit, which may be partitioned along the quad-tree structure, the binary-tree structure, and/or the ternary-tree structure from a coding tree unit or a largest coding unit. One or more transform units may be derived from the coding unit. And, the reconstructed image signal decoded and output through the decoding apparatus <b>300</b> may be reproduced through a reproducer.</p><p id="p-0081" num="0080">The decoding apparatus <b>300</b> may receive a signal output from the encoding apparatus of <figref idref="DRAWINGS">FIG. <b>2</b></figref> in the form of a bitstream, and the received signal may be decoded through the entropy decoder <b>310</b>. For example, the entropy decoder <b>310</b> may parse the bitstream to derive information (e.g., video/image information) required for image reconstruction (or picture reconstruction). The video/image information may further include information on various parameter sets such as an adaptation parameter set (APS), a picture parameter set (PPS), a sequence parameter set (SPS), a video parameter set (VPS) or the like. Further, the video/image information may further include general constraint information. The decoding apparatus may decode a picture further based on information on the parameter set and/or the general constraint information. In the present disclosure, signaled/received information and/or syntax elements, which will be described later, may be decoded through the decoding procedure and be obtained from the bitstream. For example, the entropy decoder <b>310</b> may decode information in the bitstream based on a coding method such as exponential Golomb encoding, CAVLC, CABAC, or the like, and may output a value of a syntax element necessary for image reconstruction and quantized values of a transform coefficient regarding a residual. More specifically, a CABAC entropy decoding method may receive a bin corresponding to each syntax element in a bitstream, determine a context model using decoding target syntax element information and decoding information of neighboring and decoding target blocks, or information of symbol/bin decoded in a previous step, predict bin generation probability according to the determined context model and perform arithmetic decoding of the bin to generate a symbol corresponding to each syntax element value. Here, the CABAC entropy decoding method may update the context model using information of a symbol/bin decoded for a context model of the next symbol/bin after determination of the context model. Information on prediction among information decoded in the entropy decoder <b>310</b> may be provided to the predictor (inter predictor <b>332</b> and intra predictor <b>331</b>), and residual values, that is, quantized transform coefficients, on which entropy decoding has been performed in the entropy decoder <b>310</b>, and associated parameter information may be input to the residual processor <b>320</b>. The residual processor <b>320</b> may derive a residual signal (residual block, residual samples, residual sample array). Further, information on filtering among information decoded in the entropy decoder <b>310</b> may be provided to the filter <b>350</b>. Meanwhile, a receiver (not shown) which receives a signal output from the encoding apparatus may further constitute the decoding apparatus <b>300</b> as an internal/external element, and the receiver may be a component of the entropy decoder <b>310</b>. Meanwhile, the decoding apparatus according to the present disclosure may be called a video/image/picture coding apparatus, and the decoding apparatus may be classified into an information decoder (video/image/picture information decoder) and a sample decoder (video/image/picture sample decoder). The information decoder may include the entropy decoder <b>310</b>, and the sample decoder may include at least one of the dequantizer <b>321</b>, the inverse transformer <b>322</b>, the adder <b>340</b>, the filter <b>350</b>, the memory <b>360</b>, the inter predictor <b>332</b>, and the intra predictor <b>331</b>.</p><p id="p-0082" num="0081">The dequantizer <b>321</b> may output transform coefficients by dequantizing the quantized transform coefficients. The dequantizer <b>321</b> may rearrange the quantized transform coefficients in the form of a two-dimensional block. In this case, the rearrangement may perform rearrangement based on an order of coefficient scanning which has been performed in the encoding apparatus. The dequantizer <b>321</b> may perform dequantization on the quantized transform coefficients using quantization parameter (e.g., quantization step size information), and obtain transform coefficients.</p><p id="p-0083" num="0082">The deqauntizer <b>322</b> obtains a residual signal (residual block, residual sample array) by inverse transforming transform coefficients.</p><p id="p-0084" num="0083">The predictor may perform prediction on the current block, and generate a predicted block including prediction samples for the current block. The predictor may determine whether intra prediction or inter prediction is applied to the current block based on the information on prediction output from the entropy decoder <b>310</b>, and specifically may determine an intra/inter prediction mode.</p><p id="p-0085" num="0084">The predictor may generate a prediction signal based on various prediction methods. For example, the predictor may apply intra prediction or inter prediction for prediction on one block, and, as well, may apply intra prediction and inter prediction at the same time. This may be called combined inter and intra prediction (CIIP). In addition, the predictor may perform intra block copy (IBC) for prediction on a block. The intra block copy may be used for content image/video coding of a game or the like, such as screen content coding (SCC). Although the IBC basically performs prediction in a current block, it can be performed similarly to inter prediction in that it derives a reference block in a current block. That is, the IBC may use at least one of inter prediction techniques described in the present disclosure.</p><p id="p-0086" num="0085">The intra predictor <b>331</b> may predict the current block by referring to the samples in the current picture. The referred samples may be located in the neighbor of or apart from the current block according to the prediction mode. In the intra prediction, prediction modes may include a plurality of non-directional modes and a plurality of directional modes. The intra predictor <b>331</b> may determine the prediction mode applied to the current block by using the prediction mode applied to the neighboring block.</p><p id="p-0087" num="0086">The inter predictor <b>332</b> may derive a predicted block for the current block based on a reference block (reference sample array) specified by a motion vector on a reference picture. At this time, in order to reduce the amount of motion information transmitted in the inter prediction mode, the motion information may be predicted on a block, subblock, or sample basis based on correlation of motion information between the neighboring block and the current block. The motion information may include a motion vector and a reference picture index. The motion information may further include inter prediction direction (L0 prediction, L1 prediction, Bi prediction, etc.) information. In the case of inter prediction, the neighboring block may include a spatial neighboring block existing in the current picture and a temporal neighboring block existing in the reference picture. For example, the inter predictor <b>332</b> may configure a motion information candidate list based on neighboring blocks, and derive a motion vector and/or a reference picture index of the current block based on received candidate selection information. Inter prediction may be performed based on various prediction modes, and the information on prediction may include information indicating a mode of inter prediction for the current block.</p><p id="p-0088" num="0087">The adder <b>340</b> may generate a reconstructed signal (reconstructed picture, reconstructed block, reconstructed sample array) by adding the obtained residual signal to the prediction signal (predicted block, prediction sample array) output from the predictor <b>330</b>. When there is no residual for a processing target block as in a case where the skip mode is applied, the predicted block may be used as a reconstructed block.</p><p id="p-0089" num="0088">The adder <b>340</b> may be called a reconstructor or a reconstructed block generator. The generated reconstructed signal may be used for intra prediction of a next processing target block in the current block, and as described later, may be output through filtering or be used for inter prediction of a next picture.</p><p id="p-0090" num="0089">Meanwhile, in the picture decoding process, luma mapping with chroma scaling (LMCS) may be applied.</p><p id="p-0091" num="0090">The filter <b>350</b> may improve subjective/objective video quality by applying the filtering to the reconstructed signal. For example, the filter <b>350</b> may generate a modified reconstructed picture by applying various filtering methods to the reconstructed picture, and may transmit the modified reconstructed picture in the memory <b>360</b>, specifically in the DPB of the memory <b>360</b>. The various filtering methods may include, for example, deblocking filtering, sample adaptive offset, an adaptive loop filter, a bilateral filter or the like.</p><p id="p-0092" num="0091">The (modified) reconstructed picture which has been stored in the DPB of the memory <b>360</b> may be used as a reference picture in the inter predictor <b>332</b>. The memory <b>360</b> may store motion information of a block in the current picture, from which motion information has been derived (or decoded) and/or motion information of blocks in an already reconstructed picture. The stored motion information may be transmitted to the inter predictor <b>260</b> to be utilized as motion information of a neighboring block or motion information of a temporal neighboring block. The memory <b>360</b> may store reconstructed samples of reconstructed blocks in the current picture, and transmit them to the intra predictor <b>331</b>.</p><p id="p-0093" num="0092">In this specification, the examples described in the predictor <b>330</b>, the dequantizer <b>321</b>, the inverse transformer <b>322</b>, and the filter <b>350</b> of the decoding apparatus <b>300</b> may be similarly or correspondingly applied to the predictor <b>220</b>, the dequantizer <b>234</b>, the inverse transformer <b>235</b>, and the filter <b>260</b> of the encoding apparatus <b>200</b>, respectively.</p><p id="p-0094" num="0093">As described above, prediction is performed in order to increase compression efficiency in performing video coding. Through this, a predicted block including prediction samples for a current block, which is a coding target block, may be generated. Here, the predicted block includes prediction samples in a space domain (or pixel domain). The predicted block may be indentically derived in the encoding apparatus and the decoding apparatus, and the encoding apparatus may increase image coding efficiency by signaling to the decoding apparatus not original sample value of an original block itself but information on residual (residual information) between the original block and the predicted block. The decoding apparatus may derive a residual block including residual samples based on the residual information, generate a reconstructed block including reconstructed samples by adding the residual block to the predicted block, and generate a reconstructed picture including reconstructed blocks.</p><p id="p-0095" num="0094">The residual information may be generated through transform and quantization procedures. For example, the encoding apparatus may derive a residual block between the original block and the predicted block, derive transform coefficients by performing a transform procedure on residual samples (residual sample array) included in the residual block, and derive quantized transform coefficients by performing a quantization procedure on the transform coefficients, so that it may signal associated residual information to the decoding apparatus (through a bitstream). Here, the residual information may include value information, position information, a transform technique, transform kernel, a quantization parameter or the like of the quantized transform coefficients. The decoding apparatus may perform a quantization/dequantization procedure and derive the residual samples (or residual sample block), based on residual information. The decoding apparatus may generate a reconstructed block based on a predicted block and the residual block. The encoding apparatus may derive a residual block by dequantizing/inverse transforming quantized transform coefficients for reference for inter prediction of a next picture, and may generate a reconstructed picture based on this.</p><p id="p-0096" num="0095"><figref idref="DRAWINGS">FIG. <b>4</b></figref> schematically illustrates a multiple transform technique according to an embodiment of the present disclosure.</p><p id="p-0097" num="0096">Referring to <figref idref="DRAWINGS">FIG. <b>4</b></figref>, a transformer may correspond to the transformer in the encoding apparatus of foregoing <figref idref="DRAWINGS">FIG. <b>2</b></figref>, and an inverse transformer may correspond to the inverse transformer in the encoding apparatus of foregoing <figref idref="DRAWINGS">FIG. <b>2</b></figref>, or to the inverse transformer in the decoding apparatus of <figref idref="DRAWINGS">FIG. <b>3</b></figref>.</p><p id="p-0098" num="0097">The transformer may derive (primary) transform coefficients by performing a primary transform based on residual samples (residual sample array) in a residual block (S<b>410</b>). This primary transform may be referred to as a core transform. Herein, the primary transform may be based on multiple transform selection (MTS), and when a multiple transform is applied as the primary transform, it may be referred to as a multiple core transform.</p><p id="p-0099" num="0098">The multiple core transform may represent a method of transforming additionally using discrete cosine transform (DCT) type 2 and discrete sine transform (DST) type 7, DCT type 8, and/or DST type 1. That is, the multiple core transform may represent a transform method of transforming a residual signal (or residual block) of a space domain into transform coefficients (or primary transform coefficients) of a frequency domain based on a plurality of transform kernels selected from among the DCT type 2, the DST type 7, the DCT type 8 and the DST type 1. Herein, the primary transform coefficients may be called temporary transform coefficients from the viewpoint of the transformer.</p><p id="p-0100" num="0099">In other words, when the conventional transform method is applied, transform coefficients might be generated by applying transform from a space domain to a frequency domain for a residual signal (or residual block) based on the DCT type 2. Unlike to this, when the multiple core transform is applied, transform coefficients (or primary transform coefficients) may be generated by applying transform from a space domain to a frequency domain for a residual signal (or residual block) based on the DCT type 2, the DST type 7, the DCT type 8, and/or DST type 1. Herein, the DCT type 2, the DST type 7, the DCT type 8, and the DST type 1 may be called a transform type, transform kernel or transform core. These DCT/DST transform types can be defined based on basis functions.</p><p id="p-0101" num="0100">When the multiple core transform is performed, a vertical transform kernel and a horizontal transform kernel for a target block may be selected from among the transform kernels, a vertical transform may be performed on the target block based on the vertical transform kernel, and a horizontal transform may be performed on the target block based on the horizontal transform kernel. Here, the horizontal transform may indicate a transform on horizontal components of the target block, and the vertical transform may indicate a transform on vertical components of the target block. The vertical transform kernel/horizontal transform kernel may be adaptively determined based on a prediction mode and/or a transform index for the target block (CU or subblock) including a residual block.</p><p id="p-0102" num="0101">Further, according to an example, if the primary transform is performed by applying the MTS, a mapping relationship for transform kernels may be set by setting specific basis functions to predetermined values and combining basis functions to be applied in the vertical transform or the horizontal transform. For example, when the horizontal transform kernel is expressed as trTypeHor and the vertical direction transform kernel is expressed as trTypeVer, a trTypeHor or trTypeVer value of 0 may be set to DCT2, a trTypeHor or trTypeVer value of 1 may be set to DST7, and a trTypeHor or trTypeVer value of 2 may be set to DCT8.</p><p id="p-0103" num="0102">In this case, MTS index information may be encoded and signaled to the decoding apparatus to indicate any one of a plurality of transform kernel sets. For example, an MTS index of 0 may indicate that both trTypeHor and trTypeVer values are 0, an MTS index of 1 may indicate that both trTypeHor and trTypeVer values are 1, an MTS index of 2 may indicate that the trTypeHor value is 2 and the trTypeVer value. Is 1, an MTS index of 3 may indicate that the trTypeHor value is 1 and the trTypeVer value is 2, and an MTS index of 4 may indicate that both both trTypeHor and trTypeVer values are 2.</p><p id="p-0104" num="0103">In one example, transform kernel sets according to MTS index information are illustrated in the following table.</p><p id="p-0105" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="7"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="70pt" align="left"/><colspec colname="2" colwidth="35pt" align="center"/><colspec colname="3" colwidth="14pt" align="center"/><colspec colname="4" colwidth="35pt" align="center"/><colspec colname="5" colwidth="14pt" align="center"/><colspec colname="6" colwidth="35pt" align="center"/><thead><row><entry/><entry namest="offset" nameend="6" rowsep="1">TABLE 1</entry></row><row><entry/><entry namest="offset" nameend="6" align="center" rowsep="1"/></row><row><entry/><entry>tu_mts_idx[ x0 ][ y0 ]</entry><entry>0</entry><entry>1</entry><entry>2</entry><entry>3</entry><entry>4</entry></row><row><entry/><entry namest="offset" nameend="6" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="7"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="70pt" align="left"/><colspec colname="2" colwidth="35pt" align="char" char="."/><colspec colname="3" colwidth="14pt" align="char" char="."/><colspec colname="4" colwidth="35pt" align="char" char="."/><colspec colname="5" colwidth="14pt" align="char" char="."/><colspec colname="6" colwidth="35pt" align="char" char="."/><tbody valign="top"><row><entry/><entry>trTypeHor</entry><entry>0</entry><entry>1</entry><entry>2</entry><entry>1</entry><entry>2</entry></row><row><entry/><entry>trTypeVer</entry><entry>0</entry><entry>1</entry><entry>1</entry><entry>2</entry><entry>2</entry></row><row><entry/><entry namest="offset" nameend="6" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0106" num="0104">The transformer may derive modified (secondary) transform coefficients by performing the secondary transform based on the (primary) transform coefficients (S<b>420</b>). The primary transform is a transform from a spatial domain to a frequency domain, and the secondary transform refers to transforming into a more compressive expression by using a correlation existing between (primary) transform coefficients. The secondary transform may include a non-separable transform. In this case, the secondary transform may be called a non-separable secondary transform (NSST), or a mode-dependent non-separable secondary transform (MDNSST). The non-separable secondary transform may represent a transform which generates modified transform coefficients (or secondary transform coefficients) for a residual signal by secondary-transforming, based on a non-separable transform matrix, (primary) transform coefficients derived through the primary transform. At this time, the vertical transform and the horizontal transform may not be applied separately (or horizontal and vertical transforms may not be applied independently) to the (primary) transform coefficients, but the transforms may be applied at once based on the non-separable transform matrix. In other words, the non-separable secondary transform may represent a transform method in which is not separately applied in the vertical direction and the horizontal direction for the (primary) transform coefficients, and for example, two-dimensional signals (transform coefficients) are re-arranged to a one-dimensional signal through a certain determined direction (e.g., row-first direction or column-first direction), and then modified transform coefficients (or secondary transform coefficients) are generated based on the non-separable transform matrix. For example, according to a row-first order, M&#xd7;N blocks are disposed in a line in an order of a first row, a second row, . . . , and an Nth row. According to a column-first order, M&#xd7;N blocks are disposed in a line in an order of a first column, a second column, . . . , and an Nth column. The non-separable secondary transform may be applied to a top-left region of a block configured with (primary) transform coefficients (hereinafter, may be referred to as a transform coefficient block). For example, if the width (W) and the height (H) of the transform coefficient block are all equal to or greater than 8, an 8&#xd7;8 non-separable secondary transform may be applied to a top-left 8&#xd7;8 region of the transform coefficient block. Further, if the width (W) and the height (H) of the transform coefficient block are all equal to or greater than 4, and the width (W) or the height (H) of the transform coefficient block is less than 8, then a 4&#xd7;4 non-separable secondary transform may be applied to a top-left min(8,W)&#xd7;min(8,H) region of the transform coefficient block. However, the embodiment is not limited to this, and for example, even if only the condition that the width (W) or height (H) of the transform coefficient block is equal to or greater than 4 is satisfied, the 4&#xd7;4 non-separable secondary transform may be applied to the top-left min(8,W)&#xd7;min(8,H) region of the transform coefficient block.</p><p id="p-0107" num="0105">Specifically, for example, if a 4&#xd7;4 input block is used, the non-separable secondary transform may be performed as follows.</p><p id="p-0108" num="0106">The 4&#xd7;4 input block X may be represented as follows.</p><p id="p-0109" num="0000"><maths id="MATH-US-00001" num="00001"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mi>X</mi>     <mo>=</mo>     <mrow>      <mo>[</mo>      <mtable>       <mtr>        <mtd>         <msub>          <mi>X</mi>          <mrow>           <mn>0</mn>           <mo>&#x2062;</mo>           <mn>0</mn>          </mrow>         </msub>        </mtd>        <mtd>         <msub>          <mi>X</mi>          <mrow>           <mn>0</mn>           <mo>&#x2062;</mo>           <mn>1</mn>          </mrow>         </msub>        </mtd>        <mtd>         <msub>          <mi>X</mi>          <mrow>           <mn>0</mn>           <mo>&#x2062;</mo>           <mn>2</mn>          </mrow>         </msub>        </mtd>        <mtd>         <msub>          <mi>X</mi>          <mrow>           <mn>0</mn>           <mo>&#x2062;</mo>           <mn>3</mn>          </mrow>         </msub>        </mtd>       </mtr>       <mtr>        <mtd>         <msub>          <mi>X</mi>          <mrow>           <mn>1</mn>           <mo>&#x2062;</mo>           <mn>0</mn>          </mrow>         </msub>        </mtd>        <mtd>         <msub>          <mi>X</mi>          <mrow>           <mn>1</mn>           <mo>&#x2062;</mo>           <mn>1</mn>          </mrow>         </msub>        </mtd>        <mtd>         <msub>          <mi>X</mi>          <mrow>           <mn>1</mn>           <mo>&#x2062;</mo>           <mn>2</mn>          </mrow>         </msub>        </mtd>        <mtd>         <msub>          <mi>X</mi>          <mrow>           <mn>1</mn>           <mo>&#x2062;</mo>           <mn>3</mn>          </mrow>         </msub>        </mtd>       </mtr>       <mtr>        <mtd>         <msub>          <mi>X</mi>          <mrow>           <mn>2</mn>           <mo>&#x2062;</mo>           <mn>0</mn>          </mrow>         </msub>        </mtd>        <mtd>         <msub>          <mi>X</mi>          <mrow>           <mn>2</mn>           <mo>&#x2062;</mo>           <mn>1</mn>          </mrow>         </msub>        </mtd>        <mtd>         <msub>          <mi>X</mi>          <mrow>           <mn>2</mn>           <mo>&#x2062;</mo>           <mn>2</mn>          </mrow>         </msub>        </mtd>        <mtd>         <msub>          <mi>X</mi>          <mrow>           <mn>2</mn>           <mo>&#x2062;</mo>           <mn>3</mn>          </mrow>         </msub>        </mtd>       </mtr>       <mtr>        <mtd>         <msub>          <mi>X</mi>          <mrow>           <mn>3</mn>           <mo>&#x2062;</mo>           <mn>0</mn>          </mrow>         </msub>        </mtd>        <mtd>         <msub>          <mi>X</mi>          <mrow>           <mn>3</mn>           <mo>&#x2062;</mo>           <mn>1</mn>          </mrow>         </msub>        </mtd>        <mtd>         <msub>          <mi>X</mi>          <mrow>           <mn>3</mn>           <mo>&#x2062;</mo>           <mn>2</mn>          </mrow>         </msub>        </mtd>        <mtd>         <msub>          <mi>X</mi>          <mrow>           <mn>3</mn>           <mo>&#x2062;</mo>           <mn>3</mn>          </mrow>         </msub>        </mtd>       </mtr>      </mtable>      <mo>]</mo>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>[</mo>     <mrow>      <mi>Equation</mi>      <mo>&#x2062;</mo>      <mtext>   </mtext>      <mn>1</mn>     </mrow>     <mo>]</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0110" num="0107">If the X is represented in the form of a vector, the vector <img id="CUSTOM-CHARACTER-00001" he="2.79mm" wi="1.78mm" file="US20230007264A1-20230105-P00001.TIF" alt="custom-character" img-content="character" img-format="tif"/> may be represented as below.</p><p id="p-0111" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><img id="CUSTOM-CHARACTER-00002" he="2.79mm" wi="1.78mm" file="US20230007264A1-20230105-P00002.TIF" alt="custom-character" img-content="character" img-format="tif"/>=[<i>X</i><sub>00 </sub><i>X</i><sub>01 </sub><i>X</i><sub>02 </sub><i>X</i><sub>03 </sub><i>X</i><sub>10 </sub><i>X</i><sub>11 </sub><i>X</i><sub>12 </sub><i>X</i><sub>13 </sub><i>X</i><sub>20 </sub><i>X</i><sub>21 </sub><i>X</i><sub>22 </sub><i>X</i><sub>23 </sub><i>X</i><sub>30 </sub><i>X</i><sub>31 </sub><i>X</i><sub>32 </sub><i>X</i><sub>33</sub>]<sup>T</sup>&#x2003;&#x2003;[Equation 2]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0112" num="0108">In Equation 2, the vector <img id="CUSTOM-CHARACTER-00003" he="2.79mm" wi="1.78mm" file="US20230007264A1-20230105-P00003.TIF" alt="custom-character" img-content="character" img-format="tif"/> is a one-dimensional vector obtained by rearranging the two-dimensional block X of Equation 1 according to the row-first order.</p><p id="p-0113" num="0109">In this case, the secondary non-separable transform may be calculated as below.</p><p id="p-0114" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><img id="CUSTOM-CHARACTER-00004" he="2.46mm" wi="1.78mm" file="US20230007264A1-20230105-P00004.TIF" alt="custom-character" img-content="character" img-format="tif"/>=<i>T&#xb7;</i><img id="CUSTOM-CHARACTER-00005" he="2.79mm" wi="1.78mm" file="US20230007264A1-20230105-P00005.TIF" alt="custom-character" img-content="character" img-format="tif"/><i/>&#x2003;&#x2003;[Equation 3]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0115" num="0110">In this equation, <img id="CUSTOM-CHARACTER-00006" he="2.46mm" wi="1.78mm" file="US20230007264A1-20230105-P00006.TIF" alt="custom-character" img-content="character" img-format="tif"/> represents a transform coefficient vector, and T represents a 16&#xd7;16 (non-separable) transform matrix.</p><p id="p-0116" num="0111">Through foregoing Equation 3, a 16&#xd7;1 transform coefficient vector <img id="CUSTOM-CHARACTER-00007" he="2.46mm" wi="1.78mm" file="US20230007264A1-20230105-P00007.TIF" alt="custom-character" img-content="character" img-format="tif"/> may be derived, and the <img id="CUSTOM-CHARACTER-00008" he="2.46mm" wi="1.78mm" file="US20230007264A1-20230105-P00008.TIF" alt="custom-character" img-content="character" img-format="tif"/> may be re-organized into a 4&#xd7;4 block through a scan order (horizontal, vertical, diagonal and the like). However, the above-described calculation is an example, and hypercube-Givens transform (HyGT) or the like may be used for the calculation of the non-separable secondary transform in order to reduce the computational complexity of the non-separable secondary transform.</p><p id="p-0117" num="0112">Meanwhile, in the non-separable secondary transform, a transform kernel (or transform core, transform type) may be selected to be mode dependent. In this case, the mode may include the intra prediction mode and/or the inter prediction mode.</p><p id="p-0118" num="0113">As described above, the non-separable secondary transform may be performed based on an 8&#xd7;8 transform or a 4&#xd7;4 transform determined based on the width (W) and the height (H) of the transform coefficient block. The 8&#xd7;8 transform refers to a transform that is applicable to an 8&#xd7;8 region included in the transform coefficient block when both W and H are equal to or greater than 8, and the 8&#xd7;8 region may be a top-left 8&#xd7;8 region in the transform coefficient block. Similarly, the 4&#xd7;4 transform refers to a transform that is applicable to a 4&#xd7;4 region included in the transform coefficient block when both W and H are equal to or greater than 4, and the 4&#xd7;4 region may be a top-left 4&#xd7;4 region in the transform coefficient block. For example, an 8&#xd7;8 transform kernel matrix may be a 64&#xd7;64/16&#xd7;64 matrix, and a 4&#xd7;4 transform kernel matrix may be a 16&#xd7;16/8&#xd7;16 matrix.</p><p id="p-0119" num="0114">Here, to select a mode-dependent transform kernel, two non-separable secondary transform kernels per transform set for a non-separable secondary transform may be configured for both the 8&#xd7;8 transform and the 4&#xd7;4 transform, and there may be four transform sets. That is, four transform sets may be configured for the 8&#xd7;8 transform, and four transform sets may be configured for the 4&#xd7;4 transform. In this case, each of the four transform sets for the 8&#xd7;8 transform may include two 8&#xd7;8 transform kernels, and each of the four transform sets for the 4&#xd7;4 transform may include two 4&#xd7;4 transform kernels.</p><p id="p-0120" num="0115">However, as the size of the transform, that is, the size of a region to which the transform is applied, may be, for example, a size other than 8&#xd7;8 or 4&#xd7;4, the number of sets may be n, and the number of transform kernels in each set may be k.</p><p id="p-0121" num="0116">The transform set may be referred to as an NSST set or an LFNST set. A specific set among the transform sets may be selected, for example, based on the intra prediction mode of the current block (CU or subblock). A low-frequency non-separable transform (LFNST) may be an example of a reduced non-separable transform, which will be described later, and represents a non-separable transform for a low frequency component.</p><p id="p-0122" num="0117">For reference, for example, the intra prediction mode may include two non-directional (or non-angular) intra prediction modes and 65 directional (or angular) intra prediction modes. The non-directional intra prediction modes may include a planar intra prediction mode of No. 0 and a DC intra prediction mode of No. 1, and the directional intra prediction modes may include 65 intra prediction modes of Nos. 2 to 66. However, this is an example, and this document may be applied even when the number of intra prediction modes is different. Meanwhile, in some cases, intra prediction mode No. 67 may be further used, and the intra prediction mode No. 67 may represent a linear model (LM) mode.</p><p id="p-0123" num="0118"><figref idref="DRAWINGS">FIG. <b>5</b></figref> exemplarily shows intra directional modes of 65 prediction directions.</p><p id="p-0124" num="0119">Referring to <figref idref="DRAWINGS">FIG. <b>5</b></figref>, on the basis of intra prediction mode 34 having a left upward diagonal prediction direction, the intra prediction modes may be divided into intra prediction modes having horizontal directionality and intra prediction modes having vertical directionality. In <figref idref="DRAWINGS">FIG. <b>5</b></figref>, H and V denote horizontal directionality and vertical directionality, respectively, and numerals &#x2212;32 to 32 indicate displacements in 1/32 units on a sample grid position. These numerals may represent an offset for a mode index value. Intra prediction modes 2 to 33 have the horizontal directionality, and intra prediction modes 34 to 66 have the vertical directionality. Strictly speaking, intra prediction mode 34 may be considered as being neither horizontal nor vertical, but may be classified as belonging to the horizontal directionality in determining a transform set of a secondary transform. This is because input data is transposed to be used for a vertical direction mode symmetrical on the basis of intra prediction mode 34, and an input data alignment method for a horizontal mode is used for intra prediction mode 34. Transposing input data means that rows and columns of two-dimensional M&#xd7;N block data are switched into N&#xd7;M data. Intra prediction mode 18 and intra prediction mode 50 may represent a horizontal intra prediction mode and a vertical intra prediction mode, respectively, and intra prediction mode 2 may be referred to as a right upward diagonal intra prediction mode because intra prediction mode 2 has a left reference pixel and performs prediction in a right upward direction. Likewise, intra prediction mode 34 may be referred to as a right downward diagonal intra prediction mode, and intra prediction mode 66 may be referred to as a left downward diagonal intra prediction mode.</p><p id="p-0125" num="0120">According to an example, the four transform sets according to the intra prediction mode may be mapped, for example, as shown in the following table.</p><p id="p-0126" num="0000"><tables id="TABLE-US-00002" num="00002"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="105pt" align="center"/><colspec colname="2" colwidth="98pt" align="center"/><thead><row><entry/><entry namest="offset" nameend="2" rowsep="1">TABLE 2</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>predModeIntra</entry><entry>lfnstTrSetIdx</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="105pt" align="center"/><colspec colname="2" colwidth="98pt" align="char" char="."/><tbody valign="top"><row><entry/><entry>&#x2003;&#x2002;&#x2009;predModeIntra &#x3c; 0</entry><entry>1</entry></row><row><entry/><entry>0 &#x3c;= predModeIntra &#x3c;= 1</entry><entry>0</entry></row><row><entry/><entry>&#x2002;2 &#x3c;= predModeIntra &#x3c;= 12</entry><entry>1</entry></row><row><entry/><entry>13 &#x3c;= predModeIntra &#x3c;= 23</entry><entry>2</entry></row><row><entry/><entry>24 &#x3c;= predModeIntra &#x3c;= 44</entry><entry>3</entry></row><row><entry/><entry>45 &#x3c;= predModeIntra &#x3c;= 55</entry><entry>2</entry></row><row><entry/><entry>56 &#x3c;= predModeIntra &#x3c;= 80</entry><entry>1</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0127" num="0121">As shown in Table 2, any one of the four transform sets, that is, lfnstTrSetIdx, may be mapped to any one of four indexes, that is, 0 to 3, according to the intra prediction mode.</p><p id="p-0128" num="0122">When it is determined that a specific set is used for the non-separable transform, one of k transform kernels in the specific set may be selected through a non-separable secondary transform index. An encoding apparatus may derive a non-separable secondary transform index indicating a specific transform kernel based on a rate-distortion (RD) check and may signal the non-separable secondary transform index to a decoding apparatus. The decoding apparatus may select one of the k transform kernels in the specific set based on the non-separable secondary transform index. For example, lfnst index value 0 may refer to a first non-separable secondary transform kernel, lfnst index value 1 may refer to a second non-separable secondary transform kernel, and lfnst index value 2 may refer to a third non-separable secondary transform kernel. Alternatively, lfnst index value 0 may indicate that the first non-separable secondary transform is not applied to the target block, and lfnst index values 1 to 3 may indicate the three transform kernels.</p><p id="p-0129" num="0123">The transformer may perform the non-separable secondary transform based on the selected transform kernels, and may obtain modified (secondary) transform coefficients. As described above, the modified transform coefficients may be derived as transform coefficients quantized through the quantizer, and may be encoded and signaled to the decoding apparatus and transferred to the dequantizer/inverse transformer in the encoding apparatus.</p><p id="p-0130" num="0124">Meanwhile, as described above, if the secondary transform is omitted, (primary) transform coefficients, which are an output of the primary (separable) transform, may be derived as transform coefficients quantized through the quantizer as described above, and may be encoded and signaled to the decoding apparatus and transferred to the dequantizer/inverse transformer in the encoding apparatus.</p><p id="p-0131" num="0125">The inverse transformer may perform a series of procedures in the inverse order to that in which they have been performed in the above-described transformer. The inverse transformer may receive (dequantized) transformer coefficients, and derive (primary) transform coefficients by performing a secondary (inverse) transform (S<b>450</b>), and may obtain a residual block (residual samples) by performing a primary (inverse) transform on the (primary) transform coefficients (S<b>460</b>). In this connection, the primary transform coefficients may be called modified transform coefficients from the viewpoint of the inverse transformer. As described above, the encoding apparatus and the decoding apparatus may generate the reconstructed block based on the residual block and the predicted block, and may generate the reconstructed picture based on the reconstructed block.</p><p id="p-0132" num="0126">The decoding apparatus may further include a secondary inverse transform application determinator (or an element to determine whether to apply a secondary inverse transform) and a secondary inverse transform determinator (or an element to determine a secondary inverse transform). The secondary inverse transform application determinator may determine whether to apply a secondary inverse transform. For example, the secondary inverse transform may be an NSST, an RST, or an LFNST and the secondary inverse transform application determinator may determine whether to apply the secondary inverse transform based on a secondary transform flag obtained by parsing the bitstream. In another example, the secondary inverse transform application determinator may determine whether to apply the secondary inverse transform based on a transform coefficient of a residual block.</p><p id="p-0133" num="0127">The secondary inverse transform determinator may determine a secondary inverse transform. In this case, the secondary inverse transform determinator may determine the secondary inverse transform applied to the current block based on an LFNST (NSST or RST) transform set specified according to an intra prediction mode. In an embodiment, a secondary transform determination method may be determined depending on a primary transform determination method. Various combinations of primary transforms and secondary transforms may be determined according to the intra prediction mode. Further, in an example, the secondary inverse transform determinator may determine a region to which a secondary inverse transform is applied based on the size of the current block.</p><p id="p-0134" num="0128">Meanwhile, as described above, if the secondary (inverse) transform is omitted, (dequantized) transform coefficients may be received, the primary (separable) inverse transform may be performed, and the residual block (residual samples) may be obtained. As described above, the encoding apparatus and the decoding apparatus may generate the reconstructed block based on the residual block and the predicted block, and may generate the reconstructed picture based on the reconstructed block.</p><p id="p-0135" num="0129">Meanwhile, in the present disclosure, a reduced secondary transform (RST) in which the size of a transform matrix (kernel) is reduced may be applied in the concept of NSST in order to reduce the amount of computation and memory required for the non-separable secondary transform.</p><p id="p-0136" num="0130">Meanwhile, the transform kernel, the transform matrix, and the coefficient constituting the transform kernel matrix, that is, the kernel coefficient or the matrix coefficient, described in the present disclosure may be expressed in 8 bits. This may be a condition for implementation in the decoding apparatus and the encoding apparatus, and may reduce the amount of memory required to store the transform kernel with a performance degradation that can be reasonably accommodated compared to the existing 9 bits or 10 bits. In addition, the expressing of the kernel matrix in 8 bits may allow a small multiplier to be used, and may be more suitable for single instruction multiple data (SIMD) instructions used for optimal software implementation.</p><p id="p-0137" num="0131">In the present specification, the term &#x201c;RST&#x201d; may mean a transform which is performed on residual samples for a target block based on a transform matrix whose size is reduced according to a reduced factor. In the case of performing the reduced transform, the amount of computation required for transform may be reduced due to a reduction in the size of the transform matrix. That is, the RST may be used to address the computational complexity issue occurring at the non-separable transform or the transform of a block of a great size.</p><p id="p-0138" num="0132">RST may be referred to as various terms, such as reduced transform, reduced secondary transform, reduction transform, simplified transform, simple transform, and the like, and the name which RST may be referred to as is not limited to the listed examples. Alternatively, since the RST is mainly performed in a low frequency region including a non-zero coefficient in a transform block, it may be referred to as a Low-Frequency Non-Separable Transform (LFNST). The transform index may be referred to as an LFNST index.</p><p id="p-0139" num="0133">Meanwhile, when the secondary inverse transform is performed based on RST, the inverse transformer <b>235</b> of the encoding apparatus <b>200</b> and the inverse transformer <b>322</b> of the decoding apparatus <b>300</b> may include an inverse reduced secondary transformer which derives modified transform coefficients based on the inverse RST of the transform coefficients, and an inverse primary transformer which derives residual samples for the target block based on the inverse primary transform for the modified transform coefficients. The inverse primary transform refers to the inverse transform of the primary transform applied to the residual. In the present disclosure, deriving a transform coefficient based on a transform may refer to deriving a transform coefficient by applying the transform.</p><p id="p-0140" num="0134"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a diagram illustrating an RST according to an embodiment of the present disclosure.</p><p id="p-0141" num="0135">In the present disclosure, a &#x201c;target block&#x201d; may refer to a current block to be coded, a residual block, or a transform block.</p><p id="p-0142" num="0136">In the RST according to an example, an N-dimensional vector may be mapped to an R-dimensional vector located in another space, so that the reduced transform matrix may be determined, where R is less than N. N may mean the square of the length of a side of a block to which the transform is applied, or the total number of transform coefficients corresponding to a block to which the transform is applied, and the reduced factor may mean an R/N value. The reduced factor may be referred to as a reduced factor, reduction factor, simplified factor, simple factor or other various terms. Meanwhile, R may be referred to as a reduced coefficient, but according to circumstances, the reduced factor may mean R. Further, according to circumstances, the reduced factor may mean the N/R value.</p><p id="p-0143" num="0137">In an example, the reduced factor or the reduced coefficient may be signaled through a bitstream, but the example is not limited to this. For example, a predefined value for the reduced factor or the reduced coefficient may be stored in each of the encoding apparatus <b>200</b> and the decoding apparatus <b>300</b>, and in this case, the reduced factor or the reduced coefficient may not be signaled separately.</p><p id="p-0144" num="0138">The size of the reduced transform matrix according to an example may be R&#xd7;N less than N&#xd7;N, the size of a conventional transform matrix, and may be defined as in Equation 4 below.</p><p id="p-0145" num="0000"><maths id="MATH-US-00002" num="00002"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <msub>      <mi>T</mi>      <mrow>       <mi>R</mi>       <mo>&#xd7;</mo>       <mi>N</mi>      </mrow>     </msub>     <mo>=</mo>     <mrow>      <mo>[</mo>      <mtable>       <mtr>        <mtd>         <msub>          <mi>t</mi>          <mn>11</mn>         </msub>        </mtd>        <mtd>         <msub>          <mi>t</mi>          <mn>12</mn>         </msub>        </mtd>        <mtd>         <msub>          <mi>t</mi>          <mn>13</mn>         </msub>        </mtd>        <mtd>         <mpadded width="0em" lspace="0em" depth="-0.9ex" height="0.9ex">          <mo>&#x2026;</mo>         </mpadded>        </mtd>        <mtd>         <msub>          <mi>t</mi>          <mrow>           <mn>1</mn>           <mo>&#x2062;</mo>           <mi>N</mi>          </mrow>         </msub>        </mtd>       </mtr>       <mtr>        <mtd>         <msub>          <mi>t</mi>          <mn>21</mn>         </msub>        </mtd>        <mtd>         <msub>          <mi>t</mi>          <mn>22</mn>         </msub>        </mtd>        <mtd>         <msub>          <mi>t</mi>          <mn>23</mn>         </msub>        </mtd>        <mtd>         <mtext> </mtext>        </mtd>        <mtd>         <msub>          <mi>t</mi>          <mrow>           <mn>2</mn>           <mo>&#x2062;</mo>           <mi>N</mi>          </mrow>         </msub>        </mtd>       </mtr>       <mtr>        <mtd>         <mtext> </mtext>        </mtd>        <mtd>         <mo>&#x22ee;</mo>        </mtd>        <mtd>         <mtext> </mtext>        </mtd>        <mtd>         <mo>&#x22f1;</mo>        </mtd>        <mtd>         <mo>&#x22ee;</mo>        </mtd>       </mtr>       <mtr>        <mtd>         <msub>          <mi>t</mi>          <mrow>           <mi>R</mi>           <mo>&#x2062;</mo>           <mn>1</mn>          </mrow>         </msub>        </mtd>        <mtd>         <msub>          <mi>t</mi>          <mrow>           <mi>R</mi>           <mo>&#x2062;</mo>           <mn>2</mn>          </mrow>         </msub>        </mtd>        <mtd>         <msub>          <mi>t</mi>          <mrow>           <mi>R</mi>           <mo>&#x2062;</mo>           <mn>3</mn>          </mrow>         </msub>        </mtd>        <mtd>         <mo>&#x2026;</mo>        </mtd>        <mtd>         <msub>          <mi>t</mi>          <mi>RN</mi>         </msub>        </mtd>       </mtr>      </mtable>      <mo>]</mo>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>[</mo>     <mrow>      <mi>Equation</mi>      <mo>&#x2062;</mo>      <mtext>   </mtext>      <mn>4</mn>     </mrow>     <mo>]</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0146" num="0139">The matrix Tin the Reduced Transform block shown in <figref idref="DRAWINGS">FIG. <b>6</b>(<i>a</i>)</figref> may mean the matrix TRxN of Equation 4. As shown in <figref idref="DRAWINGS">FIG. <b>6</b>(<i>a</i>)</figref>, when the reduced transform matrix TR&#xd7;N is multiplied to residual samples for the target block, transform coefficients for the target block may be derived.</p><p id="p-0147" num="0140">In an example, if the size of the block to which the transform is applied is 8&#xd7;8 and R=16 (i.e., R/N= 16/64=&#xbc;), then the RST according to <figref idref="DRAWINGS">FIG. <b>6</b>(<i>a</i>)</figref> may be expressed as a matrix operation as shown in Equation 5 below. In this case, memory and multiplication calculation can be reduced to approximately &#xbc; by the reduced factor.</p><p id="p-0148" num="0141">In the present disclosure, a matrix operation may be understood as an operation of multiplying a column vector by a matrix, disposed on the left of the column vector, to obtain a column vector.</p><p id="p-0149" num="0000"><maths id="MATH-US-00003" num="00003"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mrow>      <mo>[</mo>      <mtable>       <mtr>        <mtd>         <msub>          <mi>t</mi>          <mrow>           <mn>1</mn>           <mo>,</mo>           <mn>1</mn>          </mrow>         </msub>        </mtd>        <mtd>         <msub>          <mi>t</mi>          <mrow>           <mn>1</mn>           <mo>,</mo>           <mn>2</mn>          </mrow>         </msub>        </mtd>        <mtd>         <msub>          <mi>t</mi>          <mrow>           <mn>1</mn>           <mo>,</mo>           <mn>3</mn>          </mrow>         </msub>        </mtd>        <mtd>         <mrow>          <mpadded width="0em" lspace="0em" depth="-2.4ex" height="2.4ex">           <mtext> </mtext>          </mpadded>          <mpadded width="0em" lspace="0em" depth="-0.7ex" height="0.7ex">           <mo>&#x2026;</mo>          </mpadded>         </mrow>        </mtd>        <mtd>         <msub>          <mi>t</mi>          <mrow>           <mn>1</mn>           <mo>,</mo>           <mn>64</mn>          </mrow>         </msub>        </mtd>       </mtr>       <mtr>        <mtd>         <msub>          <mi>t</mi>          <mrow>           <mn>2</mn>           <mo>,</mo>           <mn>1</mn>          </mrow>         </msub>        </mtd>        <mtd>         <msub>          <mi>t</mi>          <mrow>           <mn>2</mn>           <mo>,</mo>           <mn>2</mn>          </mrow>         </msub>        </mtd>        <mtd>         <msub>          <mi>t</mi>          <mrow>           <mn>2</mn>           <mo>,</mo>           <mn>3</mn>          </mrow>         </msub>        </mtd>        <mtd>         <mtext> </mtext>        </mtd>        <mtd>         <msub>          <mi>t</mi>          <mrow>           <mn>2</mn>           <mo>,</mo>           <mn>64</mn>          </mrow>         </msub>        </mtd>       </mtr>       <mtr>        <mtd>         <mtext> </mtext>        </mtd>        <mtd>         <mo>&#x22ee;</mo>        </mtd>        <mtd>         <mtext> </mtext>        </mtd>        <mtd>         <mo>&#x22f1;</mo>        </mtd>        <mtd>         <mo>&#x22ee;</mo>        </mtd>       </mtr>       <mtr>        <mtd>         <msub>          <mi>t</mi>          <mrow>           <mn>16</mn>           <mo>,</mo>           <mtext> </mtext>           <mn>1</mn>          </mrow>         </msub>        </mtd>        <mtd>         <msub>          <mi>t</mi>          <mrow>           <mn>16</mn>           <mo>,</mo>           <mtext> </mtext>           <mn>2</mn>          </mrow>         </msub>        </mtd>        <mtd>         <msub>          <mi>t</mi>          <mrow>           <mn>16</mn>           <mo>,</mo>           <mtext> </mtext>           <mn>3</mn>          </mrow>         </msub>        </mtd>        <mtd>         <mo>&#x2026;</mo>        </mtd>        <mtd>         <msub>          <mi>t</mi>          <mrow>           <mn>16</mn>           <mo>,</mo>           <mn>64</mn>          </mrow>         </msub>        </mtd>       </mtr>      </mtable>      <mo>]</mo>     </mrow>     <mo>&#xd7;</mo>     <mrow>      <mo>[</mo>      <mtable>       <mtr>        <mtd>         <mtable>          <mtr>           <mtd>            <mtable>             <mtr>              <mtd>               <msub>                <mi>r</mi>                <mn>1</mn>               </msub>              </mtd>             </mtr>             <mtr>              <mtd>               <msub>                <mi>r</mi>                <mn>2</mn>               </msub>              </mtd>             </mtr>            </mtable>           </mtd>          </mtr>          <mtr>           <mtd>            <mo>&#x22ee;</mo>           </mtd>          </mtr>         </mtable>        </mtd>       </mtr>       <mtr>        <mtd>         <msub>          <mi>r</mi>          <mn>64</mn>         </msub>        </mtd>       </mtr>      </mtable>      <mo>]</mo>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>[</mo>     <mrow>      <mi>Equation</mi>      <mo>&#x2062;</mo>      <mtext>   </mtext>      <mn>5</mn>     </mrow>     <mo>]</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0150" num="0142">In Equation 5, r1 to r64 may represent residual samples for the target block and may be specifically transform coefficients generated by applying a primary transform. As a result of the calculation of Equation 5 transform coefficients ci for the target block may be derived, and a process of deriving ci may be as in Equation 6.</p><p id="p-0151" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>for <i>i </i>from to <i>R: </i><?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0152" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>c</i><sub>i</sub>=0<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0153" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>for <i>j </i>from 1 to <i>N </i><?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0154" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>c</i><sub>i</sub><i>+=t</i><sub>ij</sub><i>*r</i><sub>i</sub>&#x2003;&#x2003;[Equation 6]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0155" num="0143">As a result of the calculation of Equation 6, transform coefficients c1 to cR for the target block may be derived. That is, when R=16, transform coefficients c1 to c16 for the target block may be derived. If, instead of RST, a regular transform is applied and a transform matrix of 64&#xd7;64 (N&#xd7;N) size is multiplied to residual samples of 64&#xd7;1 (N&#xd7;1) size, then only 16 (R) transform coefficients are derived for the target block because RST was applied, although 64 (N) transform coefficients are derived for the target block. Since the total number of transform coefficients for the target block is reduced from N to R, the amount of data transmitted by the encoding apparatus <b>200</b> to the decoding apparatus <b>300</b> decreases, so efficiency of transmission between the encoding apparatus <b>200</b> and the decoding apparatus <b>300</b> can be improved.</p><p id="p-0156" num="0144">When considered from the viewpoint of the size of the transform matrix, the size of the regular transform matrix is 64&#xd7;64 (N&#xd7;N), but the size of the reduced transform matrix is reduced to 16&#xd7;64 (R&#xd7;N), so memory usage in a case of performing the RST can be reduced by an R/N ratio when compared with a case of performing the regular transform. In addition, when compared to the number of multiplication calculations N&#xd7;N in a case of using the regular transform matrix, the use of the reduced transform matrix can reduce the number of multiplication calculations by the R/N ratio (R&#xd7;N).</p><p id="p-0157" num="0145">In an example, the transformer <b>232</b> of the encoding apparatus <b>200</b> may derive transform coefficients for the target block by performing the primary transform and the RST-based secondary transform on residual samples for the target block. These transform coefficients may be transferred to the inverse transformer of the decoding apparatus <b>300</b>, and the inverse transformer <b>322</b> of the decoding apparatus <b>300</b> may derive the modified transform coefficients based on the inverse reduced secondary transform (RST) for the transform coefficients, and may derive residual samples for the target block based on the inverse primary transform for the modified transform coefficients.</p><p id="p-0158" num="0146">The size of the inverse RST matrix TN&#xd7;R according to an example is N&#xd7;R less than the size N&#xd7;N of the regular inverse transform matrix, and is in a transpose relationship with the reduced transform matrix TR&#xd7;N shown in Equation 4.</p><p id="p-0159" num="0147">The matrix Tt in the Reduced Inv. Transform block shown in <figref idref="DRAWINGS">FIG. <b>6</b>(<i>b</i>)</figref> may mean the inverse RST matrix TR&#xd7;NT (the superscript T means transpose). When the inverse RST matrix TR&#xd7;NT is multiplied to the transform coefficients for the target block as shown in <figref idref="DRAWINGS">FIG. <b>6</b>(<i>b</i>)</figref>, the modified transform coefficients for the target block or the residual samples for the current block may be derived. The inverse RST matrix TR&#xd7;NT may be expressed as (TR&#xd7;NT)N&#xd7;R.</p><p id="p-0160" num="0148">More specifically, when the inverse RST is applied as the secondary inverse transform, the modified transform coefficients for the target block may be derived when the inverse RST matrix TR&#xd7;NT is multiplied to the transform coefficients for the target block. Meanwhile, the inverse RST may be applied as the inverse primary transform, and in this case, the residual samples for the target block may be derived when the inverse RST matrix TR&#xd7;NT is multiplied to the transform coefficients for the target block.</p><p id="p-0161" num="0149">In an example, if the size of the block to which the inverse transform is applied is 8&#xd7;8 and R=16 (i.e., R/N= 16/64=&#xbc;), then the RST according to <figref idref="DRAWINGS">FIG. <b>6</b>(<i>b</i>)</figref> may be expressed as a matrix operation as shown in Equation 7 below.</p><p id="p-0162" num="0000"><maths id="MATH-US-00004" num="00004"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mrow>      <mo>[</mo>      <mtable>       <mtr>        <mtd>         <msub>          <mi>t</mi>          <mrow>           <mn>1</mn>           <mo>,</mo>           <mn>1</mn>          </mrow>         </msub>        </mtd>        <mtd>         <msub>          <mi>t</mi>          <mrow>           <mn>2</mn>           <mo>,</mo>           <mn>1</mn>          </mrow>         </msub>        </mtd>        <mtd>         <mtext> </mtext>        </mtd>        <mtd>         <msub>          <mi>t</mi>          <mrow>           <mn>16</mn>           <mo>,</mo>           <mn>1</mn>          </mrow>         </msub>        </mtd>       </mtr>       <mtr>        <mtd>         <msub>          <mi>t</mi>          <mrow>           <mn>1</mn>           <mo>,</mo>           <mn>2</mn>          </mrow>         </msub>        </mtd>        <mtd>         <msub>          <mi>t</mi>          <mrow>           <mn>2</mn>           <mo>,</mo>           <mn>2</mn>          </mrow>         </msub>        </mtd>        <mtd>         <mrow>          <mpadded width="0em" lspace="0em" depth="-0.85ex" height="0.85ex">           <mo>&#x2026;</mo>          </mpadded>          <mtext> </mtext>         </mrow>        </mtd>        <mtd>         <msub>          <mi>t</mi>          <mrow>           <mn>16</mn>           <mo>,</mo>           <mn>2</mn>          </mrow>         </msub>        </mtd>       </mtr>       <mtr>        <mtd>         <msub>          <mi>t</mi>          <mrow>           <mn>1</mn>           <mo>,</mo>           <mn>3</mn>          </mrow>         </msub>        </mtd>        <mtd>         <msub>          <mi>t</mi>          <mrow>           <mn>2</mn>           <mo>,</mo>           <mn>3</mn>          </mrow>         </msub>        </mtd>        <mtd>         <mtext> </mtext>        </mtd>        <mtd>         <msub>          <mi>t</mi>          <mrow>           <mn>16</mn>           <mo>,</mo>           <mn>3</mn>          </mrow>         </msub>        </mtd>       </mtr>       <mtr>        <mtd>         <mo>&#x22ee;</mo>        </mtd>        <mtd>         <mo>&#x22ee;</mo>        </mtd>        <mtd>         <mtext> </mtext>        </mtd>        <mtd>         <mo>&#x22ee;</mo>        </mtd>       </mtr>       <mtr>        <mtd>         <mtext> </mtext>        </mtd>        <mtd>         <mpadded width="1.30435em" lspace="-1.30435em" depth="0ex" height="0ex">          <mo>&#x22ee;</mo>         </mpadded>        </mtd>        <mtd>         <mo>&#x22f1;</mo>        </mtd>        <mtd>         <mo>&#x22ee;</mo>        </mtd>       </mtr>       <mtr>        <mtd>         <msub>          <mi>t</mi>          <mrow>           <mn>1</mn>           <mo>,</mo>           <mn>64</mn>          </mrow>         </msub>        </mtd>        <mtd>         <msub>          <mi>t</mi>          <mrow>           <mn>2</mn>           <mo>,</mo>           <mn>64</mn>          </mrow>         </msub>        </mtd>        <mtd>         <mo>&#x2026;</mo>        </mtd>        <mtd>         <msub>          <mi>t</mi>          <mrow>           <mn>16</mn>           <mo>,</mo>           <mn>64</mn>          </mrow>         </msub>        </mtd>       </mtr>      </mtable>      <mo>]</mo>     </mrow>     <mo>&#xd7;</mo>     <mrow>      <mo>[</mo>      <mtable>       <mtr>        <mtd>         <mtable>          <mtr>           <mtd>            <mtable>             <mtr>              <mtd>               <msub>                <mi>c</mi>                <mn>1</mn>               </msub>              </mtd>             </mtr>             <mtr>              <mtd>               <msub>                <mi>c</mi>                <mn>2</mn>               </msub>              </mtd>             </mtr>            </mtable>           </mtd>          </mtr>          <mtr>           <mtd>            <mo>&#x22ee;</mo>           </mtd>          </mtr>         </mtable>        </mtd>       </mtr>       <mtr>        <mtd>         <msub>          <mi>c</mi>          <mn>16</mn>         </msub>        </mtd>       </mtr>      </mtable>      <mo>]</mo>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>[</mo>     <mrow>      <mi>Equation</mi>      <mo>&#x2062;</mo>      <mtext>   </mtext>      <mn>7</mn>     </mrow>     <mo>]</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0163" num="0150">In Equation 7, c1 to c16 may represent the transform coefficients for the target block. As a result of the calculation of Equation 7, ri representing the modified transform coefficients for the target block or the residual samples for the target block may be derived, and the process of deriving ri may be as in Equation 8.</p><p id="p-0164" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>For <i>i </i>from to <i>N </i><?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0165" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>r</i><sub>i</sub>=0<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0166" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>for <i>j </i>from 1 to <i>R </i><?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0167" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>r</i><sub>i</sub><i>=t</i><sub>ji</sub><i>*c</i><sub>j</sub>&#x2003;&#x2003;[Equation 8]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0168" num="0151">As a result of the calculation of Equation 8, r1 to rN representing the modified transform coefficients for the target block or the residual samples for the target block may be derived. When considered from the viewpoint of the size of the inverse transform matrix, the size of the regular inverse transform matrix is 64&#xd7;64 (N&#xd7;N), but the size of the reduced inverse transform matrix is reduced to 64&#xd7;16 (R&#xd7;N), so memory usage in a case of performing the inverse RST can be reduced by an R/N ratio when compared with a case of performing the regular inverse transform. In addition, when compared to the number of multiplication calculations N&#xd7;N in a case of using the regular inverse transform matrix, the use of the reduced inverse transform matrix can reduce the number of multiplication calculations by the R/N ratio (N&#xd7;R).</p><p id="p-0169" num="0152">A transform set configuration shown in Table 2 may also be applied to an 8&#xd7;8 RST. That is, the 8&#xd7;8 RST may be applied according to a transform set in Table 2. Since one transform set includes two or three transforms (kernels) according to an intra prediction mode, it may be configured to select one of up to four transforms including that in a case where no secondary transform is applied. In a transform where no secondary transform is applied, it may be considered to apply an identity matrix. Assuming that indexes 0, 1, 2, and 3 are respectively assigned to the four transforms (e.g., index 0 may be allocated to a case where an identity matrix is applied, that is, a case where no secondary transform is applied), a transform index or an lfnst index as a syntax element may be signaled for each transform coefficient block, thereby designating a transform to be applied. That is, for a top-left 8&#xd7;8 block, through the transform index, it is possible to designate an 8&#xd7;8 RST in an RST configuration, or to designate an 8&#xd7;8 lfnst when the LFNST is applied. The 8&#xd7;8 lfnst and the 8&#xd7;8 RST refer to transforms applicable to an 8&#xd7;8 region included in the transform coefficient block when both W and H of the target block to be transformed are equal to or greater than 8, and the 8&#xd7;8 region may be a top-left 8&#xd7;8 region in the transform coefficient block. Similarly, a 4&#xd7;4 lfnst and a 4&#xd7;4 RST refer to transforms applicable to a 4&#xd7;4 region included in the transform coefficient block when both W and H of the target block to are equal to or greater than 4, and the 4&#xd7;4 region may be a top-left 4&#xd7;4 region in the transform coefficient block.</p><p id="p-0170" num="0153">According to an embodiment of the present disclosure, for a transform in an encoding process, only 48 pieces of data may be selected and a maximum 16&#xd7;48 transform kernel matrix may be applied thereto, rather than applying a 16&#xd7;64 transform kernel matrix to 64 pieces of data forming an 8&#xd7;8 region. Here, &#x201c;maximum&#x201d; means that m has a maximum value of 16 in an m&#xd7;48 transform kernel matrix for generating m coefficients. That is, when an RST is performed by applying an m&#xd7;48 transform kernel matrix (m&#x2264;16) to an 8&#xd7;8 region, 48 pieces of data are input and m coefficients are generated. When m is 16, 48 pieces of data are input and 16 coefficients are generated. That is, assuming that 48 pieces of data form a 48&#xd7;1 vector, a 16&#xd7;48 matrix and a 48&#xd7;1 vector are sequentially multiplied, thereby generating a 16&#xd7;1 vector. Here, the 48 pieces of data forming the 8&#xd7;8 region may be properly arranged, thereby forming the 48&#xd7;1 vector. For example, a 48&#xd7;1 vector may be constructed based on 48 pieces of data constituting a region excluding the bottom right 4&#xd7;4 region among the 8&#xd7;8 regions. Here, when a matrix operation is performed by applying a maximum 16&#xd7;48 transform kernel matrix, 16 modified transform coefficients are generated, and the 16 modified transform coefficients may be arranged in a top-left 4&#xd7;4 region according to a scanning order, and a top-right 4&#xd7;4 region and a bottom-left 4&#xd7;4 region may be filled with zeros.</p><p id="p-0171" num="0154">For an inverse transform in a decoding process, the transposed matrix of the foregoing transform kernel matrix may be used. That is, when an inverse RST or LFNST is performed in the inverse transform process performed by the decoding apparatus, input coefficient data to which the inverse RST is applied is configured in a one-dimensional vector according to a predetermined arrangement order, and a modified coefficient vector obtained by multiplying the one-dimensional vector and a corresponding inverse RST matrix on the left of the one-dimensional vector may be arranged in a two-dimensional block according to a predetermined arrangement order.</p><p id="p-0172" num="0155">In summary, in the transform process, when an RST or LFNST is applied to an 8&#xd7;8 region, a matrix operation of 48 transform coefficients in top-left, top-right, and bottom-left regions of the 8&#xd7;8 region excluding the bottom-right region among transform coefficients in the 8&#xd7;8 region and a 16&#xd7;48 transform kernel matrix. For the matrix operation, the 48 transform coefficients are input in a one-dimensional array. When the matrix operation is performed, 16 modified transform coefficients are derived, and the modified transform coefficients may be arranged in the top-left region of the 8&#xd7;8 region.</p><p id="p-0173" num="0156">On the contrary, in the inverse transform process, when an inverse RST or LFNST is applied to an 8&#xd7;8 region, 16 transform coefficients corresponding to a top-left region of the 8&#xd7;8 region among transform coefficients in the 8&#xd7;8 region may be input in a one-dimensional array according to a scanning order and may be subjected to a matrix operation with a 48&#xd7;16 transform kernel matrix. That is, the matrix operation may be expressed as (48&#xd7;16 matrix)*(16&#xd7;1 transform coefficient vector)=(48&#xd7;1 modified transform coefficient vector). Here, an n&#xd7;1 vector may be interpreted to have the same meaning as an n&#xd7;1 matrix and may thus be expressed as an n&#xd7;1 column vector. Further, * denotes matrix multiplication. When the matrix operation is performed, 48 modified transform coefficients may be derived, and the 48 modified transform coefficients may be arranged in top-left, top-right, and bottom-left regions of the 8&#xd7;8 region excluding a bottom-right region.</p><p id="p-0174" num="0157">When a secondary inverse transform is based on an RST, the inverse transformer <b>235</b> of the encoding apparatus <b>200</b> and the inverse transformer <b>322</b> of the decoding apparatus <b>300</b> may include an inverse reduced secondary transformer to derive modified transform coefficients based on an inverse RST on transform coefficients and an inverse primary transformer to derive residual samples for the target block based on an inverse primary transform on the modified transform coefficients. The inverse primary transform refers to the inverse transform of a primary transform applied to a residual. In the present disclosure, deriving a transform coefficient based on a transform may refer to deriving the transform coefficient by applying the transform.</p><p id="p-0175" num="0158">The above-described non-separable transform, the LFNST, will be described in detail as follows. The LFNST may include a forward transform by the encoding apparatus and an inverse transform by the decoding apparatus.</p><p id="p-0176" num="0159">The encoding apparatus receives a result (or a part of a result) derived after applying a primary (core) transform as an input, and applies a forward secondary transform (secondary transform).</p><p id="p-0177" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>y=G</i><sup>T</sup>&#x2003;&#x2003;[Equation 9]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0178" num="0160">In Equation 9, x and y are inputs and outputs of the secondary transform, respectively, and G is a matrix representing the secondary transform, and transform basis vectors are composed of column vectors. In the case of an inverse LFNST, when the dimension of the transformation matrix G is expressed as [number of rows&#xd7;number of columns], in the case of an forward LFNST, the transposition of matrix G becomes the dimension of GT.</p><p id="p-0179" num="0161">For the inverse LFNST, the dimensions of matrix G are [48&#xd7;16], [48&#xd7;8], [16&#xd7;16], [16&#xd7;8], and the [48&#xd7;8] matrix and the [16&#xd7;8] matrix are partial matrices that sampled 8 transform basis vectors from the left of the [48&#xd7;16] matrix and the [16&#xd7;16] matrix, respectively.</p><p id="p-0180" num="0162">On the other hand, for the forward LFNST, the dimensions of matrix GT are [16&#xd7;48], [8&#xd7;48], [16&#xd7;16], [8&#xd7;16], and the [8&#xd7;48] matrix and the [8&#xd7;16] matrix are partial matrices obtained by sampling 8 transform basis vectors from the top of the [16&#xd7;48] matrix and the [16&#xd7;16] matrix, respectively.</p><p id="p-0181" num="0163">Therefore, in the case of the forward LFNST, a [48&#xd7;1] vector or [16&#xd7;1] vector is possible as an input x, and a [16&#xd7;1] vector or a [8&#xd7;1] vector is possible as an output y. In video coding and decoding, the output of the forward primary transform is two-dimensional (2D) data, so to construct the [48&#xd7;1] vector or the [16&#xd7;1] vector as the input x, a one-dimensional vector must be constructed by properly arranging the 2D data that is the output of the forward transformation.</p><p id="p-0182" num="0164"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a diagram illustrating a sequence of arranging output data of a forward primary transformation into a one-dimensional vector according to an example. The left diagrams of (a) and (b) of <figref idref="DRAWINGS">FIG. <b>7</b></figref> show the sequence for constructing a [48&#xd7;1] vector, and the right diagrams of (a) and (b) of <figref idref="DRAWINGS">FIG. <b>7</b></figref> shows the sequence for constructing a [16&#xd7;1] vector. In the case of the LFNST, a one-dimensional vector x can be obtained by sequentially arranging 2D data in the same order as in (a) and (b) of <figref idref="DRAWINGS">FIG. <b>7</b></figref>.</p><p id="p-0183" num="0165">The arrangement direction of the output data of the forward primary transform may be determined according to an intra prediction mode of the current block. For example, when the intra prediction mode of the current block is in the horizontal direction with respect to the diagonal direction, the output data of the forward primary transform may be arranged in the order of (a) of <figref idref="DRAWINGS">FIG. <b>7</b></figref>, and when the intra prediction mode of the current block is in the vertical direction with respect to the diagonal direction, the output data of the forward primary transform may be arranged in the order of (b) of <figref idref="DRAWINGS">FIG. <b>7</b></figref>.</p><p id="p-0184" num="0166">According to an example, an arrangement order different from the arrangement orders of (a) and (b) <figref idref="DRAWINGS">FIG. <b>7</b></figref> may be applied, and in order to derive the same result (y vector) as when the arrangement orders of (a) and (b) <figref idref="DRAWINGS">FIG. <b>7</b></figref> is applied, the column vectors of the matrix G may be rearranged according to the arrangement order. That is, it is possible to rearrange the column vectors of G so that each element constituting the x vector is always multiplied by the same transform basis vector.</p><p id="p-0185" num="0167">Since the output y derived through Equation 9 is a one-dimensional vector, when two-dimensional data is required as input data in the process of using the result of the forward secondary transformation as an input, for example, in the process of performing quantization or residual coding, the output y vector of Equation 9 must be properly arranged as 2D data again.</p><p id="p-0186" num="0168"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a diagram illustrating a sequence of arranging output data of a forward secondary transform into a two-dimensional block according to an example.</p><p id="p-0187" num="0169">In the case of the LFNST, output values may be arranged in a 2D block according to a predetermined scan order. (a) of <figref idref="DRAWINGS">FIG. <b>8</b></figref> shows that when the output y is a [16&#xd7;1] vector, the output values are arranged at 16 positions of the 2D block according to a diagonal scan order. (b) of <figref idref="DRAWINGS">FIG. <b>8</b></figref> shows that when the output y is a [8&#xd7;1] vector, the output values are arranged at 8 positions of the 2D block according to the diagonal scan order, and the remaining 8 positions are filled with zeros. X in (b) of <figref idref="DRAWINGS">FIG. <b>8</b></figref> indicates that it is filled with zero.</p><p id="p-0188" num="0170">According to another example, since the order in which the output vector y is processed in performing quantization or residual coding may be preset, the output vector y may not be arranged in the 2D block as shown in <figref idref="DRAWINGS">FIG. <b>8</b></figref>. However, in the case of the residual coding, data coding may be performed in 2D block (eg, 4&#xd7;4) units such as CG (Coefficient Group), and in this case, the data are arranged according to a specific order as in the diagonal scan order of <figref idref="DRAWINGS">FIG. <b>8</b></figref>.</p><p id="p-0189" num="0171">Meanwhile, the decoding apparatus may configure the one-dimensional input vector y by arranging two-dimensional data output through a dequantization process or the like according to a preset scan order for the inverse transformation. The input vector y may be output as the output vector x by the following equation.</p><p id="p-0190" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>x=Gy</i>&#x2003;&#x2003;[Equation 10]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0191" num="0172">In the case of the inverse LFNST, an output vector x can be derived by multiplying an input vector y, which is a [16&#xd7;1] vector or a [8&#xd7;1] vector, by a G matrix. For the inverse LFNST, the output vector x can be either a [48&#xd7;1] vector or a [16&#xd7;1] vector.</p><p id="p-0192" num="0173">The output vector x is arranged in a two-dimensional block according to the order shown in <figref idref="DRAWINGS">FIG. <b>7</b></figref> and is arranged as two-dimensional data, and this two-dimensional data becomes input data (or a part of input data) of the inverse primary transformation.</p><p id="p-0193" num="0174">Accordingly, the inverse secondary transformation is the opposite of the forward secondary transformation process as a whole, and in the case of the inverse transformation, unlike in the forward direction, the inverse secondary transformation is first applied, and then the inverse primary transformation is applied.</p><p id="p-0194" num="0175">In the inverse LFNST, one of 8 [48&#xd7;16] matrices and 8 [16&#xd7;16] matrices may be selected as the transformation matrix G. Whether to apply the [48&#xd7;16] matrix or the [16&#xd7;16] matrix depends on the size and shape of the block.</p><p id="p-0195" num="0176">In addition, 8 matrices may be derived from four transform sets as shown in Table 2 above, and each transform set may consist of two matrices. Which transform set to use among the 4 transform sets is determined according to the intra prediction mode, and more specifically, the transform set is determined based on the value of the intra prediction mode extended by considering the Wide Angle Intra Prediction (WAIP). Which matrix to select from among the two matrices constituting the selected transform set is derived through index signaling. More specifically, 0, 1, and 2 are possible as the transmitted index value, 0 may indicate that the LFNST is not applied, and 1 and 2 may indicate any one of two transform matrices constituting a transform set selected based on the intra prediction mode value.</p><p id="p-0196" num="0177"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a diagram illustrating wide-angle intra prediction modes according to an embodiment of the present document.</p><p id="p-0197" num="0178">The general intra prediction mode value may have values from 0 to 66 and 81 to 83, and the intra prediction mode value extended due to WAIP may have a value from &#x2212;14 to 83 as shown. Values from 81 to 83 indicate the CCLM (Cross Component Linear Model) mode, and values from &#x2212;14 to &#x2212;1 and values from 67 to 80 indicate the intra prediction mode extended due to the WAIP application.</p><p id="p-0198" num="0179">When the width of the prediction current block is greater than the height, the upper reference pixels are generally closer to positions inside the block to be predicted. Therefore, it may be more accurate to predict in the bottom-left direction than in the top-right direction. Conversely, when the height of the block is greater than the width, the left reference pixels are generally close to positions inside the block to be predicted. Therefore, it may be more accurate to predict in the top-right direction than in the bottom-left direction. Therefore, it may be advantageous to apply remapping, ie, mode index modification, to the index of the wide-angle intra prediction mode.</p><p id="p-0199" num="0180">When the wide-angle intra prediction is applied, information on the existing intra prediction may be signaled, and after the information is parsed, the information may be remapped to the index of the wide-angle intra prediction mode. Therefore, the total number of the intra prediction modes for a specific block (eg, a non-square block of a specific size) may not change, and that is, the total number of the intra prediction modes is 67, and intra prediction mode coding for the specific block may not be changed.</p><p id="p-0200" num="0181">Table 3 below shows a process of deriving a modified intra mode by remapping the intra prediction mode to the wide-angle intra prediction mode.</p><p id="p-0201" num="0000"><tables id="TABLE-US-00003" num="00003"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="308pt" align="left"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 3</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>Inputs to this process are:</entry></row><row><entry>a variable predModeIntra specifying the intra prediction mode,</entry></row><row><entry>a variable nTbW specifying the transform block width,</entry></row><row><entry>a variable nTbH specifying the transform block height,</entry></row><row><entry>a variable cIdx specifying the colour component of the current block.</entry></row><row><entry>Output of this process is the modified intra prediction mode predModeIntra.</entry></row><row><entry>The variables nW and nH are derived as follows:</entry></row><row><entry>If IntraSubPartitionsSplitType is equal to ISP_NO_SPLIT or cIdx is not equal to 0, the following applies:</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="273pt" align="left"/><colspec colname="2" colwidth="35pt" align="right"/><tbody valign="top"><row><entry>nW = nTbW</entry><entry>(8-97)</entry></row><row><entry>nH = nTbH</entry><entry>(8-98)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="308pt" align="left"/><tbody valign="top"><row><entry>Otherwise ( IntraSubPartitionsSplitType is not equal to ISP_NO_SPLIT and cIdx is equal to 0 ), the</entry></row><row><entry>following applies:</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="273pt" align="left"/><colspec colname="2" colwidth="35pt" align="right"/><tbody valign="top"><row><entry>nW = nCbW</entry><entry>(8-99)</entry></row><row><entry>nH = nCbH</entry><entry>(8-100)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="308pt" align="left"/><tbody valign="top"><row><entry>The variable whRatio is set equal to Abs( Log2( nW / nH ) ).</entry></row><row><entry>For non-square blocks (nW is not equal to nH), the intra prediction mode predModeIntra is modified as</entry></row><row><entry>follows:</entry></row><row><entry>If all of the following conditions are true, predModeIntra is set equal to ( predModeIntra + 65 ).</entry></row><row><entry>nW is greater than nH</entry></row><row><entry>predModeIntra is greater than or equal to 2</entry></row><row><entry>predModeIntra is less than ( whRatio &#x3e; 1 ) ? ( 8 + 2 * whRatio ) : 8</entry></row><row><entry>Otherwise, if all of the following conditions are true, predModeIntra is set equal to</entry></row><row><entry>( predModeIntra &#x2212; 67 ).</entry></row><row><entry>nH is greater than nW</entry></row><row><entry>predModeIntra is less than or equal to 66</entry></row><row><entry>predModeIntra is greater than ( whRatio &#x3e; 1 ) ? ( 60 &#x2212; 2 * whRatio ) : 60</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0202" num="0182">In Table 3, the extended intra prediction mode value is finally stored in the predModeIntra variable, and ISP_NO_SPLIT indicates that the CU block is not divided into sub-partitions by the Intra Sub Partitions (ISP) technique currently adopted in the VVC standard, and the cIdx variable Values of 0, 1, and 2 indicate the case of luma, Cb, and Cr components, respectively. Log 2 function shown in Table 3 returns a log value with a base of 2, and the Abs function returns an absolute value.</p><p id="p-0203" num="0183">Variable predModeIntra indicating the intra prediction mode and the height and width of the transform block, etc. are used as input values of the wide angle intra prediction mode mapping process, and the output value is the modified intra prediction mode predModeIntra. The height and width of the transform block or the coding block may be the height and width of the current block for remapping of the intra prediction mode. At this time, the variable whRatio reflecting the ratio of the width to the width may be set to Abs(Log 2(nW/nH)).</p><p id="p-0204" num="0184">For a non-square block, the intra prediction mode may be divided into two cases and modified.</p><p id="p-0205" num="0185">First, if all conditions (1)&#x2dc;(3) are satisfied, (1) the width of the current block is greater than the height, (2) the intra prediction mode before modifying is equal to or greater than 2, (3) the intra prediction mode is less than the value derived from (8+2*whRatio) when the variable whRatio is greater than 1, and is less than 8 when the variable whRatio is less than or equal to 1 [predModeIntra is less than (whRatio&#x3e;1)? (8+2*whRatio): 8], the intra prediction mode is set to a value 65 greater than the intra prediction mode [predModeIntra is set equal to (predModeIntra+65)].</p><p id="p-0206" num="0186">If different from the above, that is, follow conditions (1)&#x2dc;(3) are satisfied, (1) the height of the current block is greater than the width, (2) the intra prediction mode before modifying is less than or equal to 66, (3) the intra prediction mode is greater than the value derived from (60&#x2212;2*whRatio) when the variable whRatio is greater than 1, and is greater than 60 when the variable whRatio is less than or equal to 1 [predModeIntra is greater than (whRatio&#x3e;1)? (60&#x2212;2*whRatio): 60], the intra prediction mode is set to a value 67 smaller than the intra prediction mode [predModeIntra is set equal to (predModeIntra&#x2212;67)].</p><p id="p-0207" num="0187">Table 2 above shows how a transform set is selected based on the intra prediction mode value extended by the WAIP in the LFNST. As shown in <figref idref="DRAWINGS">FIG. <b>9</b></figref>, modes 14 to 33 and modes 35 to 80 are symmetric with respect to the prediction direction around mode 34. For example, mode 14 and mode 54 are symmetric with respect to the direction corresponding to mode 34. Therefore, the same transform set is applied to modes located in mutually symmetrical directions, and this symmetry is also reflected in Table 2.</p><p id="p-0208" num="0188">Meanwhile, it is assumed that forward LFNST input data for mode 54 is symmetrical with the forward LFNST input data for mode 14. For example, for mode 14 and mode 54, the two-dimensional data is rearranged into one-dimensional data according to the arrangement order shown in (a) of <figref idref="DRAWINGS">FIG. <b>7</b></figref> and (b) of <figref idref="DRAWINGS">FIG. <b>7</b></figref>, respectively. In addition, it can be seen that the patterns in the order shown in (a) of <figref idref="DRAWINGS">FIG. <b>7</b></figref> and (b) of <figref idref="DRAWINGS">FIG. <b>7</b></figref> are symmetrical with respect to the direction (diagonal direction) indicated by Mode 34.</p><p id="p-0209" num="0189">Meanwhile, as described above, which transform matrix of the [48&#xd7;16] matrix and the [16&#xd7;16] matrix is applied to the LFNST is determined by the size and shape of the transform target block.</p><p id="p-0210" num="0190"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a diagram illustrating a block shape to which the LFNST is applied. (a) of <figref idref="DRAWINGS">FIG. <b>10</b></figref> shows 4&#xd7;4 blocks, (b) shows 4&#xd7;8 and 8&#xd7;4 blocks, (c) shows 4&#xd7;N or N&#xd7;4 blocks in which N is 16 or more, (d) shows 8&#xd7;8 blocks, (e) shows M&#xd7;N blocks where M&#x2265;8, N&#x2265;8, and N&#x3e;8 or M&#x3e;8.</p><p id="p-0211" num="0191">In <figref idref="DRAWINGS">FIG. <b>10</b></figref>, blocks with thick borders indicate regions to which the LFNST is applied. For the blocks of <figref idref="DRAWINGS">FIGS. <b>10</b> (<i>a</i>) and (<i>b</i>)</figref>, the LFNST is applied to the top-left 4&#xd7;4 region, and for the block of <figref idref="DRAWINGS">FIG. <b>10</b> (<i>c</i>)</figref>, the LFNST is applied individually the two top-left 4&#xd7;4 regions are continuously arranged. In (a), (b), and (c) of <figref idref="DRAWINGS">FIG. <b>10</b></figref>, since the LFNST is applied in units of 4&#xd7;4 regions, this LFNST will be hereinafter referred to as &#x201c;4&#xd7;4 LFNST&#x201d;. As a corresponding transformation matrix, a [16&#xd7;16] or [16&#xd7;8] matrix may be applied based on the matrix dimension for G in Equations 9 and 10.</p><p id="p-0212" num="0192">More specifically, the [16&#xd7;8] matrix is applied to the 4&#xd7;4 block (4&#xd7;4 TU or 4&#xd7;4 CU) of <figref idref="DRAWINGS">FIG. <b>10</b> (<i>a</i>)</figref> and the [16&#xd7;16] matrix is applied to the blocks in (b) and (c) of <figref idref="DRAWINGS">FIG. <b>10</b></figref>. This is to adjust the computational complexity for the worst case to 8 multiplications per sample.</p><p id="p-0213" num="0193">With respect to (d) and (e) of <figref idref="DRAWINGS">FIG. <b>10</b></figref>, the LFNST is applied to the top-left 8&#xd7;8 region, and this LFNST is hereinafter referred to as &#x201c;8&#xd7;8 LFNST&#x201d;. As a corresponding transformation matrix, a [48&#xd7;16] matrix or [48&#xd7;8] matrix may be applied. In the case of the forward LFNST, since the [48&#xd7;1] vector (x vector in Equation 9) is input as input data, all sample values of the top-left 8&#xd7;8 region are not used as input values of the forward LFNST. That is, as can be seen in the left order of <figref idref="DRAWINGS">FIG. <b>7</b> (<i>a</i>)</figref> or the left order of <figref idref="DRAWINGS">FIG. <b>7</b> (<i>b</i>)</figref>, the [48&#xd7;1] vector may be constructed based on samples belonging to the remaining 3 4&#xd7;4 blocks while leaving the bottom-right 4&#xd7;4 block as it is.</p><p id="p-0214" num="0194">The [48&#xd7;8] matrix may be applied to an 8&#xd7;8 block (8&#xd7;8 TU or 8&#xd7;8 CU) in <figref idref="DRAWINGS">FIG. <b>10</b></figref> (<i>d</i>), and the [48&#xd7;16] matrix may be applied to the 8&#xd7;8 block in <figref idref="DRAWINGS">FIG. <b>10</b>(<i>e</i>)</figref>. This is also to adjust the computational complexity for the worst case to 8 multiplications per sample.</p><p id="p-0215" num="0195">Depending on the block shape, when the corresponding forward LFNST (4&#xd7;4 LFNST or 8&#xd7;8 LFNST) is applied, 8 or 16 output data (y vector in Equation 9, [8&#xd7;1] or [16&#xd7;1] vector) is generated. In the forward LFNST, the number of output data is equal to or less than the number of input data due to the characteristics of the matrix GT.</p><p id="p-0216" num="0196"><figref idref="DRAWINGS">FIG. <b>11</b></figref> is a diagram illustrating an arrangement of output data of a forward LFNST according to an example, and shows a block in which output data of the forward LFNST is arranged according to a block shape.</p><p id="p-0217" num="0197">The shaded area at the top-left of the block shown in <figref idref="DRAWINGS">FIG. <b>11</b></figref> corresponds to the area where the output data of the forward LFNST is located, the positions marked with 0 indicate samples filled with 0 values, and the remaining area represents regions that are not changed by the forward LFNST. In the area not changed by the LFNST, the output data of the forward primary transform remains unchanged.</p><p id="p-0218" num="0198">As described above, since the dimension of the transform matrix applied varies according to the shape of the block, the number of output data also varies. As <figref idref="DRAWINGS">FIG. <b>11</b></figref>, the output data of the forward LFNST may not completely fill the top-left 4&#xd7;4 block. In the case of (a) and (d) of <figref idref="DRAWINGS">FIG. <b>11</b></figref>, a [16&#xd7;8] matrix and a [48&#xd7;8] matrix are applied to the block indicated by a thick line or a partial region inside the block, respectively, and a [8&#xd7;1] vector as the output of the forward LFNST is generated. That is, according to the scan order shown in (b) of <figref idref="DRAWINGS">FIG. <b>8</b></figref>, only 8 output data may be filled as shown in (a) and (d) of <figref idref="DRAWINGS">FIG. <b>11</b></figref>, and 0 may be filled in the remaining 8 positions. In the case of the LFNST applied block of <figref idref="DRAWINGS">FIG. <b>10</b> (<i>d</i>)</figref>, as shown in <figref idref="DRAWINGS">FIG. <b>11</b>(<i>d</i>)</figref>, two 4&#xd7;4 blocks in the top-right and bottom-left adjacent to the top-left 4&#xd7;4 block are also filled with 0 values.</p><p id="p-0219" num="0199">As described above, basically, by signaling the LFNST index, whether to apply the LFNST and the transform matrix to be applied are specified. As shown <figref idref="DRAWINGS">FIG. <b>11</b></figref>, when the LFNST is applied, since the number of output data of the forward LFNST may be equal to or less than the number of input data, a region filled with a zero value occurs as follows.</p><p id="p-0220" num="0200">1) As shown in (a) of <figref idref="DRAWINGS">FIG. <b>11</b></figref>, samples from the 8th and later positions in the scan order in the top-left 4&#xd7;4 block, that is, samples from the 9th to the 16th.</p><p id="p-0221" num="0201">2) As shown in (d) and (e) of <figref idref="DRAWINGS">FIG. <b>11</b></figref>, when the [16&#xd7;48] matrix or the [8&#xd7;48] matrix is applied, two 4&#xd7;4 blocks adjacent to the top-left 4&#xd7;4 block or the second and third 4&#xd7;4 blocks in the scan order.</p><p id="p-0222" num="0202">Therefore, if non-zero data exists by checking the areas 1) and 2), it is certain that the LFNST is not applied, so that the signaling of the corresponding LFNST index can be omitted.</p><p id="p-0223" num="0203">According to an example, for example, in the case of LFNST adopted in the VVC standard, since signaling of the LFNST index is performed after the residual coding, the encoding apparatus may know whether there is the non-zero data (significant coefficients) for all positions within the TU or CU block through the residual coding. Accordingly, the encoding apparatus may determine whether to perform signaling on the LFNST index based on the existence of the non-zero data, and the decoding apparatus may determine whether the LFNST index is parsed. When the non-zero data does not exist in the area designated in 1) and 2) above, signaling of the LFNST index is performed.</p><p id="p-0224" num="0204">Since a truncated unary code is applied as a binarization method for the LFNST index, the LFNST index consists of up to two bins, and 0, 10, and 11 are assigned as binary codes for possible LFNST index values of 0, 1, and 2, respectively. According to an example, context-based CABAC coding may be applied to the first bin (regular coding), and context-based CABAC coding may be applied to the second bin as well. The coding of the LFNST index is shown in the table below.</p><p id="p-0225" num="0000"><tables id="TABLE-US-00004" num="00004"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="161pt" align="center"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 4</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>binIdx</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="7"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="63pt" align="left"/><colspec colname="3" colwidth="21pt" align="left"/><colspec colname="4" colwidth="21pt" align="left"/><colspec colname="5" colwidth="21pt" align="left"/><colspec colname="6" colwidth="14pt" align="left"/><colspec colname="7" colwidth="21pt" align="left"/><tbody valign="top"><row><entry>Syntax element</entry><entry>0</entry><entry>1</entry><entry>2</entry><entry>3</entry><entry>4</entry><entry>&#x3e;=5</entry></row><row><entry namest="1" nameend="7" align="center" rowsep="1"/></row><row><entry>. . .</entry><entry>. . .</entry><entry>. . .</entry><entry>. . .</entry><entry>. . .</entry><entry>. . .</entry><entry>. . .</entry></row><row><entry>lfnst_idx[ ][ ]</entry><entry>(treeType !=</entry><entry>2</entry><entry>na</entry><entry>na</entry><entry>na</entry><entry>na</entry></row><row><entry/><entry>SINGLE_TREE) ?</entry><entry/><entry/><entry/><entry/><entry/></row><row><entry/><entry>1:0</entry><entry/><entry/><entry/><entry/><entry/></row><row><entry>. . .</entry><entry>. . .</entry><entry>. . .</entry><entry>. . .</entry><entry>. . .</entry><entry>. . .</entry><entry>. . .</entry></row><row><entry namest="1" nameend="7" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0226" num="0205">As shown in Table 4, for the first bin (binIdx=0), context 0 is applied in the case of a single tree, and context 1 can be applied in the case of a non-single tree. Also, as shown in Table 4, context 2 can be applied to the second bin (binIdx=1). That is, two contexts may be allocated to the first bin, one context may be allocated to the second bin, and each context may be distinguished by a ctxInc value (0, 1, 2).</p><p id="p-0227" num="0206">Here, the single tree means that the luma component and the chroma component are coded with the same coding structure. When the coding unit is divided while having the same coding structure, and the size of the coding unit becomes less than or equal to a specific threshold, and the luma component and the chroma component are coded with a separate tree structure, the corresponding coding unit is regarded as a dual tree, and thus the context of the first bin can be determined. That is, as shown in Table 4, context 1 can be allocated.</p><p id="p-0228" num="0207">Alternatively, when the value of the variable treeType is assigned as SINGLE_TREE for the first bin, context 0 may be used, otherwise context 1 may be used.</p><p id="p-0229" num="0208">Meanwhile, for the adopted LFNST, the following simplification methods may be applied.</p><p id="p-0230" num="0209">(i) According to an example, the number of output data for the forward LFNST may be limited to a maximum of 16.</p><p id="p-0231" num="0210">In the case of (c) of <figref idref="DRAWINGS">FIG. <b>10</b></figref>, the 4&#xd7;4 LFNST may be applied to two 4&#xd7;4 regions adjacent to the top-left, respectively, and in this case, a maximum of 32 LFNST output data may be generated. when the number of output data for forward LFNST is limited to a maximum of 16, in the case of 4&#xd7;N/N&#xd7;4 (N&#x2265;16) blocks (TU or CU), the 4&#xd7;4 LFNST is only applied to one 4&#xd7;4 region in the top-left, the LFNST may be applied only once to all blocks of <figref idref="DRAWINGS">FIG. <b>10</b></figref>. Through this, the implementation of image coding may be simplified.</p><p id="p-0232" num="0211"><figref idref="DRAWINGS">FIG. <b>12</b></figref> shows that the number of output data for the forward LFNST is limited to a maximum of 16 according to an example. As <figref idref="DRAWINGS">FIG. <b>12</b></figref>, when the LFNST is applied to the most top-left 4&#xd7;4 region in a 4&#xd7;N or N&#xd7;4 block in which N is 16 or more, the output data of the forward LFNST becomes 16 pieces.</p><p id="p-0233" num="0212">(ii) According to an example, zero-out may be additionally applied to a region to which the LFNST is not applied. In this document, the zero-out may mean filling values of all positions belonging to a specific region with a value of 0. That is, the zero-out can be applied to a region that is not changed due to the LFNST and maintains the result of the forward primary transformation. As described above, since the LFNST is divided into the 4&#xd7;4 LFNST and the 8&#xd7;8 LFNST, the zero-out can be divided into two types ((ii)-(A) and (ii)-(B)) as follows.</p><p id="p-0234" num="0213">(ii)-(A) When the 4&#xd7;4 LFNST is applied, a region to which the 4&#xd7;4 LFNST is not applied may be zeroed out. <figref idref="DRAWINGS">FIG. <b>13</b></figref> is a diagram illustrating the zero-out in a block to which the 4&#xd7;4 LFNST is applied according to an example.</p><p id="p-0235" num="0214">As shown in <figref idref="DRAWINGS">FIG. <b>13</b></figref>, with respect to a block to which the 4&#xd7;4 LFNST is applied, that is, for all of the blocks in (a), (b) and (c) of <figref idref="DRAWINGS">FIG. <b>11</b></figref>, the whole region to which the LFNST is not applied may be filled with zeros.</p><p id="p-0236" num="0215">On the other hand, (d) of <figref idref="DRAWINGS">FIG. <b>13</b></figref> shows that when the maximum value of the number of the output data of the forward LFNST is limited to 16 as shown in <figref idref="DRAWINGS">FIG. <b>12</b></figref>, the zero-out is performed on the remaining blocks to which the 4&#xd7;4 LFNST is not applied.</p><p id="p-0237" num="0216">(ii)-(B) When the 8&#xd7;8 LFNST is applied, a region to which the 8&#xd7;8 LFNST is not applied may be zeroed out. <figref idref="DRAWINGS">FIG. <b>14</b></figref> is a diagram illustrating the zero-out in a block to which the 8&#xd7;8 LFNST is applied according to an example.</p><p id="p-0238" num="0217">As shown in <figref idref="DRAWINGS">FIG. <b>14</b></figref>, with respect to a block to which the 8&#xd7;8 LFNST is applied, that is, for all of the blocks in (d) and (e) of <figref idref="DRAWINGS">FIG. <b>11</b></figref>, the whole region to which the LFNST is not applied may be filled with zeros.</p><p id="p-0239" num="0218">(iii) Due to the zero-out presented in (ii) above, the area filled with zeros may be not same when the LFNST is applied. Accordingly, it is possible to check whether the non-zero data exists according to the zero-out proposed in (ii) over a wider area than the case of the LFNST of <figref idref="DRAWINGS">FIG. <b>11</b></figref>.</p><p id="p-0240" num="0219">For example, when (ii)-(B) is applied, after checking whether the non-zero data exists where the area filled with zero values in (d) and (e) of <figref idref="DRAWINGS">FIG. <b>11</b></figref> in addition to the area filled with 0 additionally in <figref idref="DRAWINGS">FIG. <b>14</b></figref>, signaling for the LFNST index can be performed only when the non-zero data does not exist.</p><p id="p-0241" num="0220">Of course, even if the zero-out proposed in (ii) is applied, it is possible to check whether the non-zero data exists in the same way as the existing LFNST index signaling. That is, after checking whether the non-zero data exists in the block filled with zeros in <figref idref="DRAWINGS">FIG. <b>11</b></figref>, the LFNST index signaling may be applied. In this case, the encoding apparatus only performs the zero out and the decoding apparatus does not assume the zero out, that is, checking only whether the non-zero data exists only in the area explicitly marked as 0 in <figref idref="DRAWINGS">FIG. <b>11</b></figref>, may perform the LFNST index parsing.</p><p id="p-0242" num="0221">Various embodiments in which combinations of the simplification methods ((i), (ii)-(A), (ii)-(B), (iii)) for the LFNST are applied may be derived. Of course, the combinations of the above simplification methods are not limited to the following embodiments, and any combination may be applied to the LFNST.</p><heading id="h-0006" level="1">Embodiment</heading><p id="p-0243" num="0000"><ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0222">Limit the number of output data for forward LFNST to a maximum of 16&#x2192;(i)</li>        <li id="ul0002-0002" num="0223">When the 4&#xd7;4 LFNST is applied, all areas to which the 4&#xd7;4 LFNST is not applied are zero-out&#x2192;(ii)-(A)</li>        <li id="ul0002-0003" num="0224">When the 8&#xd7;8 LFNST is applied, all areas to which the 8&#xd7;8 LFNST is not applied are zero-out&#x2192;(ii)-(B)</li>        <li id="ul0002-0004" num="0225">After checking whether the non-zero data exists also the existing area filled with zero value and the area filled with zeros due to additional zero outs ((ii)-(A), (ii)-(B)), the LFNST index is signaled only when the non-zero data does not exist&#x2192;(iii)</li>    </ul>    </li></ul></p><p id="p-0244" num="0226">In the case of Embodiment, when the LFNST is applied, an area in which the non-zero output data can exist is limited to the inside of the top-left 4&#xd7;4 area. In more detail, in the case of <figref idref="DRAWINGS">FIG. <b>13</b> (<i>a</i>)</figref> and <figref idref="DRAWINGS">FIG. <b>14</b> (<i>a</i>)</figref>, the 8th position in the scan order is the last position where non-zero data can exist. In the case of <figref idref="DRAWINGS">FIGS. <b>13</b> (<i>b</i>) and (<i>c</i>)</figref> and <figref idref="DRAWINGS">FIG. <b>14</b> (<i>b</i>)</figref>, the 16th position in the scan order (ie, the position of the bottom-right edge of the top-left 4&#xd7;4 block) is the last position where data other than 0 may exist.</p><p id="p-0245" num="0227">Therefore, when the LFNST is applied, after checking whether the non-zero data exists in a position where the residual coding process is not allowed (at a position beyond the last position), it can be determined whether the LFNST index is signaled.</p><p id="p-0246" num="0228">In the case of the zero-out method proposed in (ii), since the number of data finally generated when both the primary transform and the LFNST are applied, the amount of computation required to perform the entire transformation process can be reduced. That is, when the LFNST is applied, since zero-out is applied to the forward primary transform output data existing in a region to which the LFNST is not applied, there is no need to generate data for the region that become zero-out during performing the forward primary transform. Accordingly, it is possible to reduce the amount of computation required to generate the corresponding data. The additional effects of the zero-out method proposed in (ii) are summarized as follows.</p><p id="p-0247" num="0229">First, as described above, the amount of computation required to perform the entire transform process is reduced.</p><p id="p-0248" num="0230">In particular, when (ii)-(B) is applied, the amount of calculation for the worst case is reduced, so that the transform process can be lightened. In other words, in general, a large amount of computation is required to perform a large-size primary transformation. By applying (ii)-(B), the number of data derived as a result of performing the forward LFNST can be reduced to 16 or less. In addition, as the size of the entire block (TU or CU) increases, the effect of reducing the amount of transform operation is further increased.</p><p id="p-0249" num="0231">Second, the amount of computation required for the entire transform process can be reduced, thereby reducing the power consumption required to perform the transform.</p><p id="p-0250" num="0232">Third, the latency involved in the transform process is reduced.</p><p id="p-0251" num="0233">The secondary transformation such as the LFNST adds a computational amount to the existing primary transformation, thus increasing the overall delay time involved in performing the transformation. In particular, in the case of intra prediction, since reconstructed data of neighboring blocks is used in the prediction process, during encoding, an increase in latency due to a secondary transformation leads to an increase in latency until reconstruction. This can lead to an increase in overall latency of intra prediction encoding.</p><p id="p-0252" num="0234">However, if the zero-out suggested in (ii) is applied, the delay time of performing the primary transform can be greatly reduced when LFNST is applied, the delay time for the entire transform is maintained or reduced, so that the encoding apparatus can be implemented more simply.</p><p id="p-0253" num="0235">Meanwhile, in the conventional intra prediction, a coding target block is regarded as one coding unit, and coding is performed without partition thereof. However, the ISP (Intra Sub-Paritions) coding refers to performing the intra prediction coding with the coding target block being partitioned in a horizontal direction or a vertical direction. In this case, a reconstructed block may be generated by performing encoding/decoding in units of partitioned blocks, and the reconstructed block may be used as a reference block of the next partitioned block. According to an example, in the ISP coding, one coding block may be partitioned into two or four sub-blocks and be coded, and in the ISP, intra prediction is performed on one sub-block by referring to the reconstructed pixel value of a sub-block located adjacent to the left or top side thereof. Hereinafter, the term &#x201c;coding&#x201d; may be used as a concept including both coding performed by the encoding apparatus and decoding performed by the decoding apparatus.</p><p id="p-0254" num="0236">Hereinafter, signaling of an LFNST index and an MTS index is described.</p><p id="p-0255" num="0237">A coding unit syntax table, a transform unit syntax table, and a residual coding syntax table related to signaling of an LFNST index and an MTS index according to an example are shown as below. According to Table 5, the MTS index moves from a transform unit level syntax to a coding unit level syntax, and is signaled after the LFNST index is signaled. Further, a constraint of not allowing an LFNST when an ISP is applied to a coding unit is removed. Since the constraint of not allowing the LFNST when the ISP is applied to the coding unit is removed, the LFNST may be applied to all intra prediction blocks. In addition, both the MTS index and the LFNST index are conditionally signaled at the end in a coding unit level.</p><p id="p-0256" num="0000"><tables id="TABLE-US-00005" num="00005"><table frame="none" colsep="0" rowsep="0" tabstyle="monospace"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="21pt" align="left"/><colspec colname="2" colwidth="196pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE&#x2003;5</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>&#x2003;</entry><entry>coding_unit(&#x2003;x0,&#x2003;y0,&#x2003;cbWidth,&#x2003;cbHeight,&#x2003;</entry></row><row><entry/><entry>cqtDepth,&#x2003;treeType,&#x2003;modeType&#x2003;)&#x2003;{</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>...</entry></row><row><entry/><entry>&#x2003;LfnstDcOnly&#x2003;=&#x2003;1</entry></row><row><entry/><entry>&#x2003;LfnstZeroOutSigCoeffFlag&#x2003;=&#x2003;1</entry></row><row><entry/><entry>&#x2003;MtsZeroOutSigCoeffFlag&#x2003;=&#x2003;1</entry></row><row><entry/><entry>&#x2003;transform_tree(&#x2003;x0,&#x2003;y0,&#x2003;cbWidth,&#x2003;</entry></row><row><entry/><entry>&#x2003;cbHeight,&#x2003;treeType&#x2003;)</entry></row><row><entry/><entry>&#x2003;lfnstWidth&#x2003;=&#x2003;(&#x2003;treeType&#x2003;=&#x2003;=&#x2003;DUAL_</entry></row><row><entry/><entry>&#x2003;TREE_CHROMA&#x2003;)&#x2003;?&#x2003;</entry></row><row><entry/><entry>&#x2003;cbWidth&#x2003;/&#x2003;SubWidthC</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;:&#x2003;(&#x2003;IntraSubPartitions-</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;SplitType&#x2003;=&#x2003;=</entry></row><row><entry/><entry>ISP_VER_SPLIT)&#x2003;?&#x2003;cbWidth&#x2003;/&#x2003;</entry></row><row><entry/><entry>NumIntraSubPartitions&#x2003;:&#x2003;cbWidth</entry></row><row><entry/><entry>&#x2003;lfnstHeight&#x2003;=&#x2003;(&#x2003;treeType&#x2003;=&#x2003;=&#x2003;</entry></row><row><entry/><entry>&#x2003;DUAL_TREE_CHROMA&#x2003;)&#x2003;</entry></row><row><entry/><entry>&#x2003;?&#x2003;cbHeight&#x2003;/&#x2003;SubHeightC</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;:&#x2003;(&#x2003;IntraSubPartitions-</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;SplitType&#x2003;=&#x2003;=</entry></row><row><entry/><entry>ISP_HOR_SPLIT)&#x2003;?&#x2003;cbHeight&#x2003;/&#x2003;</entry></row><row><entry/><entry>NumIntraSubPartitions&#x2003;:&#x2003;cbHeight</entry></row><row><entry/><entry>&#x2003;if(&#x2003;Min(&#x2003;lfnstWidth,&#x2003;lfnstHeight&#x2003;)&#x2003;&#x3e;=&#x2003;</entry></row><row><entry/><entry>&#x2003;4&#x2003;&#x26;&#x26;&#x2003;sps_lfnst_enabled_flag&#x2003;=&#x2003;=&#x2003;1&#x2003;&#x26;&#x26;</entry></row><row><entry/><entry>&#x2003;&#x2003;CuPredMode[&#x2003;chType&#x2003;][&#x2003;x0&#x2003;]</entry></row><row><entry/><entry>&#x2003;&#x2003;[&#x2003;y0&#x2003;]&#x2003;=&#x2003;=&#x2003;MODE_INTRA&#x2003;&#x26;&#x26;</entry></row><row><entry/><entry>&#x2003;&#x2003;(&#x2003;!intra_mip_flag[&#x2003;x0&#x2003;][&#x2003;y0&#x2003;]&#x2003;|&#x2003;|&#x2003;</entry></row><row><entry/><entry>&#x2003;&#x2003;Min(&#x2003;lfnstWidth,&#x2003;</entry></row><row><entry/><entry>&#x2003;&#x2003;lfnstHeight&#x2003;)&#x2003;&#x3e;=&#x2003;16&#x2003;)&#x2003;&#x26;&#x26;</entry></row><row><entry/><entry>&#x2003;Max(&#x2003;cbWidth,&#x2003;cbHeight&#x2003;)&#x2003;&#x3c;=&#x2003;</entry></row><row><entry/><entry>&#x2003;MaxTbSizeY)&#x2003;{</entry></row><row><entry/><entry>&#x2003;&#x2003;if(&#x2003;(&#x2003;IntraSubPartitionsSplitType&#x2003;</entry></row><row><entry/><entry>&#x2003;&#x2003;!&#x2003;=&#x2003;ISP_NO_SPLIT&#x2003;|&#x2003;|&#x2003;</entry></row><row><entry/><entry>&#x2003;&#x2003;LfstDcOnly&#x2003;=&#x2003;=&#x2003;0&#x2003;)&#x2003;&#x26;&#x26;</entry></row><row><entry/><entry>LfnstZerOutSigCoeffFlag&#x2003;=&#x2003;=&#x2003;1&#x2003;)</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;lfnst_idx[&#x2003;x0&#x2003;][&#x2003;y0&#x2003;]</entry></row><row><entry/><entry>&#x2003;}</entry></row><row><entry/><entry>&#x2003;if(&#x2003;treeType&#x2003;!=&#x2003;DUAL_TREE_</entry></row><row><entry/><entry>&#x2003;CHROMA&#x2003;&#x26;&#x26;&#x2003;lfnst_idx</entry></row><row><entry/><entry>&#x2003;[&#x2003;x0&#x2003;][&#x2003;y0&#x2003;]&#x2003;=&#x2003;=&#x2003;0&#x2003;&#x26;&#x26;</entry></row><row><entry/><entry>&#x2003;&#x2003;transform_skip_flag[&#x2003;x0&#x2003;]</entry></row><row><entry/><entry>&#x2003;&#x2003;[&#x2003;y0&#x2003;]&#x2003;=&#x2003;=&#x2003;0&#x2003;&#x26;&#x26;&#x2003;Max</entry></row><row><entry/><entry>&#x2003;&#x2003;(&#x2003;cbWidth,&#x2003;cbHeight&#x2003;)&#x2003;&#x3c;=&#x2003;32&#x2003;&#x26;&#x26;</entry></row><row><entry/><entry>&#x2003;&#x2003;IntraSubPartitionsSplit[&#x2003;x0&#x2003;]</entry></row><row><entry/><entry>&#x2003;&#x2003;[&#x2003;y0&#x2003;]&#x2003;=&#x2003;=&#x2003;ISP_NO_SPLIT&#x2003;</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x26;&#x26;&#x2003;(&#x2003;!cu_sbt_flag&#x2003;)&#x2003;&#x26;&#x26;</entry></row><row><entry/><entry>&#x2003;&#x2003;MtsZerOutSigCoeffFlag&#x2003;=&#x2003;=&#x2003;1&#x2003;</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x26;&#x26;&#x2003;tu_cbf_luma[&#x2003;x0&#x2003;][&#x2003;y0&#x2003;]&#x2003;)&#x2003;{</entry></row><row><entry/><entry>&#x2003;&#x2003;if(&#x2003;(&#x2003;(&#x2003;CuPredMode[&#x2003;chType&#x2003;]</entry></row><row><entry/><entry>&#x2003;&#x2003;[&#x2003;x0&#x2003;][&#x2003;y0&#x2003;]&#x2003;=&#x2003;=&#x2003;MODE_INTER&#x2003;&#x26;&#x26;</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;sps_explicit_mts_inter_</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;enabled_flag&#x2003;)</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;|&#x2003;|&#x2003;(&#x2003;CuPredMode[&#x2003;chType&#x2003;]</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;[&#x2003;x0&#x2003;][&#x2003;y0&#x2003;]&#x2003;=&#x2003;=&#x2003;MODE_</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;INTRA&#x2003;&#x26;&#x26;</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;sps_explicit_mts_intra_</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;enabled_flag&#x2003;)&#x2003;)&#x2003;)</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;mts_idx[&#x2003;x0&#x2003;][&#x2003;y0&#x2003;]</entry></row><row><entry/><entry>&#x2003;}</entry></row><row><entry/><entry>...</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0257" num="0000"><tables id="TABLE-US-00006" num="00006"><table frame="none" colsep="0" rowsep="0" tabstyle="monospace"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="14pt" align="left"/><colspec colname="2" colwidth="203pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE&#x2003;6</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>&#x2003;</entry><entry>transform_unit(&#x2003;x0,&#x2003;y0,&#x2003;tbWidth,&#x2003;</entry></row><row><entry/><entry>tbHeight,&#x2003;treeType,&#x2003;subTuIndex,&#x2003;chType&#x2003;)&#x2003;{</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>...</entry></row><row><entry/><entry>&#x2003;if(&#x2003;tu_cbf_luma[&#x2003;x0&#x2003;][&#x2003;y0&#x2003;]&#x2003;&#x26;&#x26;&#x2003;</entry></row><row><entry/><entry>&#x2003;treeType&#x2003;!=&#x2003;DUAL_TREE_CHROMA</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x26;&#x26;&#x2003;(&#x2003;tbWidth&#x2003;&#x3c;=&#x2003;32&#x2003;)&#x2003;</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x26;&#x26;&#x2003;(&#x2003;tbHeight&#x2003;&#x3c;=&#x2003;32&#x2003;)</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x26;&#x26;&#x2003;(&#x2003;IntraSubPartitionsSplit</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;[&#x2003;x0&#x2003;][&#x2003;y0&#x2003;]&#x2003;=&#x2003;=&#x2003;ISP_NO_SPLIT&#x2003;)&#x2003;</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x26;&#x26;&#x2003;(&#x2003;!cu_sbt_flag&#x2003;)&#x2003;)&#x2003;{</entry></row><row><entry/><entry>&#x2003;&#x2003;if(&#x2003;sps_transform_skip_enabled_</entry></row><row><entry/><entry>&#x2003;&#x2003;flag&#x2003;&#x26;&#x26;&#x2003;!BdpcmFlag[&#x2003;x0&#x2003;][&#x2003;y0&#x2003;]&#x2003;&#x26;&#x26;</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;tbWidth&#x2003;&#x3c;=&#x2003;MaxTsSize&#x2003;&#x26;&#x26;&#x2003;</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;tbHeight&#x2003;&#x3c;=&#x2003;MaxTsSize&#x2003;)</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;transform_skip_flag[&#x2003;x0&#x2003;][&#x2003;y0&#x2003;]</entry></row><row><entry/><entry>&#x2003;}</entry></row><row><entry/><entry>...</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0258" num="0000"><tables id="TABLE-US-00007" num="00007"><table frame="none" colsep="0" rowsep="0" tabstyle="monospace"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="14pt" align="left"/><colspec colname="2" colwidth="203pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE&#x2003;7</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>&#x2003;</entry><entry>residual_coding(&#x2003;x0,&#x2003;y0,&#x2003;</entry></row><row><entry/><entry>log2TbWidth,&#x2003;log2TbHeight,&#x2003;cIdx&#x2003;)&#x2003;{</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>...</entry></row><row><entry/><entry>&#x2003;if&#x2003;(&#x2003;(&#x2003;cu_sbt_flag&#x2003;&#x26;&#x26;&#x2003;log2TbWidth&#x2003;&#x3c;&#x2003;</entry></row><row><entry/><entry>&#x2003;6&#x2003;&#x26;&#x26;&#x2003;log2TbHeight&#x2003;&#x3c;&#x2003;6&#x2003;)</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x26;&#x26;&#x2003;cIdx&#x2003;=&#x2003;=&#x2003;0&#x2003;&#x26;&#x26;&#x2003;</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;log2TbWidth&#x2003;&#x3e;&#x2003;4&#x2003;)</entry></row><row><entry/><entry>&#x2003;&#x2003;log2ZoTbWidth&#x2003;=&#x2003;4</entry></row><row><entry/><entry>&#x2003;else</entry></row><row><entry/><entry>&#x2003;&#x2003;log2ZoTbWidth&#x2003;=&#x2003;</entry></row><row><entry/><entry>&#x2003;&#x2003;Min(&#x2003;log2TbWidth,&#x2003;5&#x2003;)</entry></row><row><entry/><entry>&#x2003;MaxCcbs&#x2003;=&#x2003;2&#x2003;*&#x2003;(&#x2003;1&#x2003;&#x3c;&#x3c;&#x2003;log2TbWidth&#x2003;)&#x2003;*&#x2003;</entry></row><row><entry/><entry>&#x2003;(&#x2003;1&#x3c;&#x3c;&#x2003;log2TbHeight&#x2003;)</entry></row><row><entry/><entry>&#x2003;if&#x2003;(&#x2003;(&#x2003;cu_sbt_flag&#x2003;&#x26;&#x26;&#x2003;log2TbWidth&#x2003;&#x3c;&#x2003;</entry></row><row><entry/><entry>&#x2003;6&#x2003;&#x26;&#x26;&#x2003;log2TbHeight&#x2003;&#x3c;&#x2003;6&#x2003;)</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x26;&#x26;&#x2003;cIdx&#x2003;=&#x2003;=&#x2003;0&#x2003;&#x26;&#x26;&#x2003;</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;log2TbHeight&#x2003;&#x3e;&#x2003;4&#x2003;)</entry></row><row><entry/><entry>&#x2003;&#x2003;log2ZoTbHeight&#x2003;=&#x2003;4</entry></row><row><entry/><entry>&#x2003;else</entry></row><row><entry/><entry>&#x2003;&#x2003;log2ZoTbHeight&#x2003;=&#x2003;</entry></row><row><entry/><entry>&#x2003;&#x2003;Min(&#x2003;log2TbHeight,&#x2003;5&#x2003;)</entry></row><row><entry/><entry>...</entry></row><row><entry/><entry>&#x2003;if(&#x2003;(&#x2003;lastSubBlock&#x2003;&#x3e;&#x2003;0&#x2003;&#x26;&#x26;&#x2003;</entry></row><row><entry/><entry>&#x2003;log2TbWidth&#x2003;&#x3e;=&#x2003;2&#x2003;&#x26;&#x26;&#x2003;</entry></row><row><entry/><entry>&#x2003;log2TbHeight&#x2003;&#x3e;=&#x2003;2&#x2003;)&#x2003;|&#x2003;|</entry></row><row><entry/><entry>&#x2003;&#x2003;(&#x2003;lastScanPos&#x2003;&#x3e;&#x2003;7&#x2003;&#x26;&#x26;&#x2003;</entry></row><row><entry/><entry>&#x2003;&#x2003;(&#x2003;log2TbWidth&#x2003;=&#x2003;=&#x2003;2&#x2003;|&#x2003;|&#x2003;</entry></row><row><entry/><entry>&#x2003;&#x2003;log2TbWidth&#x2003;=&#x2003;=&#x2003;3&#x2003;)&#x2003;&#x26;&#x26;</entry></row><row><entry/><entry>&#x2003;&#x2003;log2TbWidth&#x2003;=&#x2003;=&#x2003;</entry></row><row><entry/><entry>&#x2003;&#x2003;log2TbHeight&#x2003;)&#x2003;)</entry></row><row><entry/><entry>&#x2003;&#x2003;LfnstZeroOutSigCoeffFlag&#x2003;=&#x2003;0</entry></row><row><entry/><entry>&#x2003;if(&#x2003;(&#x2003;LastSignificantCoeffX&#x2003;&#x3e;&#x2003;</entry></row><row><entry/><entry>&#x2003;15&#x2003;|&#x2003;|&#x2003;LastSignificantCoeffY&#x2003;&#x3e;&#x2003;</entry></row><row><entry/><entry>&#x2003;15&#x2003;)&#x2003;&#x26;&#x26;&#x2003;cIdx&#x2003;=&#x2003;=&#x2003;0&#x2003;)</entry></row><row><entry/><entry>&#x2003;&#x2003;MtsZeroOutSigCoeffFlag&#x2003;=&#x2003;0</entry></row><row><entry/><entry>...</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0259" num="0238">The meanings of the major variables shown in Table are as follows.</p><p id="p-0260" num="0239">1. cbWidth, cbHeight: the width and height of the current coding block</p><p id="p-0261" num="0240">2. log 2TbWidth, log 2TbHeight: the log value of base-2 for the width and height of the current transform block, it may be reduced, by reflecting the zero-out, to a top-left region in which a non-zero coefficient may exist.</p><p id="p-0262" num="0241">3. sps_lfnst_enabled_flag: a flag indicating whether or not the LFNST is enabled, if the flag value is 0, it indicates that the LFNST is not enabled, and if the flag value is 1, it indicates that the LFNST is enabled. It is defined in the sequence parameter set (SPS).</p><p id="p-0263" num="0242">4. CuPredMode[chType][x0][y0]: a prediction mode corresponding to the variable chType and the (x0, y0) position, chType may have values of 0 and 1, wherein 0 indicates a luma component and 1 indicates a chroma component. The (x0, y0) position indicates a position on the picture, and MODE INTRA (intra prediction) and MODE INTER (inter prediction) are possible as a value of CuPredMode[chType][x0][y0].</p><p id="p-0264" num="0243">5. IntraSubPartitionsSplit[x0][y0]: the contents of the (x0, y0) position are the same as in No. 4. It indicates which ISP partition at the (x0, y0) position is applied, ISP_NO_SPLIT indicates that the coding unit corresponding to the (x0, y0) position is not divided into partition blocks.</p><p id="p-0265" num="0244">6. intra_mip_flag[x0][y0]: the contents of the (x0, y0) position are the same as in No. 4 above. The intra_mip_flag is a flag indicating whether or not a matrix-based intra prediction (MIP) prediction mode is applied. If the flag value is 0, it indicates that MIP is not enabled, and if the flag value is 1, it indicates that MIP is enabled.</p><p id="p-0266" num="0245">7. cIdx: the value of 0 indicates luma, and the values of 1 and 2 indicate Cb and Cr which are respectively chroma components.</p><p id="p-0267" num="0246">8. treeType: indicates single-tree and dual-tree, etc. (SINGLE_TREE: single tree, DUAL_TREE_LUMA: dual tree for luma component, DUAL_TREE_CHROMA: dual tree for chroma component)</p><p id="p-0268" num="0247">9. tu_cbf_cb[x0][y0]: the contents of the (x0, y0) position are the same as in No. 4. It indicates the coded block flag (CBF) for the Cb component. If its value is 0, it means that no non-zero coefficients are present in the corresponding transform unit for the Cb component, and if its value is 1, it indicates that non-zero coefficients are present in the corresponding transform unit for the Cb component.</p><p id="p-0269" num="0248">10. lastSubBlock: It indicates a position in the scan order of a sub-block (Coefficient Group (CG)) in which the last non-zero coefficient is located. 0 indicates a sub-block in which the DC component is included, and in the case of being greater than 0, it is not a sub-block in which the DC component is included.</p><p id="p-0270" num="0249">11. lastScanPos: It indicates the position where the last significant coefficient is in the scan order within one sub-block. If one sub-block includes 16 positions, values from 0 to 15 are possible.</p><p id="p-0271" num="0250">12. lfnst_idx[x0][y0]: LFNST index syntax element to be parsed. If it is not parsed, it is inferred as a value of 0. That is, the default value is set to 0, indicating that LFNST is not applied.</p><p id="p-0272" num="0251">13. cu_sbt_flag: A flag indicating whether a subblock transform (SBT) included in the current VVC standard is applicable. A flag value equal to 0 indicates that the SBT is not applicable, and a flag value equal to 1 indicates that the SBT is applied.</p><p id="p-0273" num="0252">14. sps_explicit_mts_inter_enabled_flag, sps_explicit_mts_intra_enabled_flag: Flags indicating whether an explicit MTS is applied to an inter CU and an intra CU, respectively. A flag value equal to 0 indicates the MTS is not applicable to the inter CU or the intra CU, and a flag value equal to 1 indicates that the MTS is applicable.</p><p id="p-0274" num="0253">15. tu_mts_idx[x0][y0]: An MTS index syntax element to be parsed. When not parsed, this element is inferred as a value of 0. That is, the element is set to a default value of 0, which indicates that DCT-2 is applied both horizontally and vertically.</p><p id="p-0275" num="0254">As shown in Table 4, a plurality of conditions is checked when coding mts_idx[x0][y0], and to mts_idx[x0][y0] is signaled only when lfnst_idx[x0][y0] is equal to 0.</p><p id="p-0276" num="0255">tu_cbf_luma[x0][y0] is a flag indicating whether a significant coefficient exists for a luma component.</p><p id="p-0277" num="0256">According to Table 5, when both the width and height of a coding unit for the luma component are 32 or less, mts_idx[x0][y0] is signaled (Max(cbWidth, cbHeight)&#x3c;=32), that is, whether the MTS is applied is determined by the width and height of the coding unit for the luma component.</p><p id="p-0278" num="0257">Further, according to Table 5, it may be configured to signal lfnst_idx[x0][y0] even in the ISP mode (IntraSubPartitionsSplitType!=ISP_NO_SPLIT), and the same LFNST index value may be applied to all ISP partition blocks.</p><p id="p-0279" num="0258">However, mts_idx[x0][y0] may be signaled only in a case other than the ISP mode (IntraSubPartitionsSplit[x0][y0]==ISP_NO_SPLIT).</p><p id="p-0280" num="0259">As shown in Table 7, checking the value of mts_idx[x0][y0] may be omitted in a process of determining log 2ZoTbWidth and log 2ZoTbHeight (where log 2ZoTbWidth and log 2ZoTbHeight respectively denote the base-2 logarithm values of the width and height of a top-left region remaining after zero-out is performed).</p><p id="p-0281" num="0260">According to an example, a condition of checking sps_mts_enable_flag may be added when determining log 2ZoTbWidth and log 2ZoTbHeight in residual coding.</p><p id="p-0282" num="0261">A variable LfnstZeroOutSigCoeffFlag in Table 5 is 0 if there is a significant coefficient at a zero-out position when the LFNST is applied, and is 1 otherwise. The variable LfnstZeroOutSigCoeffFlag may be set according to a plurality of conditions shown in Table 7.</p><p id="p-0283" num="0262">According to an example, a variable LfnstDcOnly in Table 5 is 1 when all last significant coefficients for transform blocks for which a corresponding coded block flag (CBF, which is 1 when there is at least one significant coefficient in a corresponding block, and is 0 otherwise) is 1 are at DC positions (top-left positions), and is 0 otherwise. Specifically, the position of the last significant coefficient is checked with respect to one luma transform block in a dual-tree luma, and the position of the last significant coefficient is checked with respect to both a transform block for Cb and a transform block for Cr in a dual-tree chroma. In a single tree, the position of the last significant coefficient may be checked with respect to transform blocks for luma, Cb, and Cr.</p><p id="p-0284" num="0263">In Table 5, MtsZeroOutSigCoeffFlag is initially set to 1, and this value may be changed in the residual coding of Table 6. The variable MtsZeroOutSigCoeffFlag is changed from 1 to 0 when there is a significant coefficient in a region to be filled with 0s by a zero-out (LastSignificantCoeffX&#x3e;15&#x2225;LastSignificantCoeffY&#x3e;15), in which case the MTS index is not signaled as shown in Table 5.</p><p id="p-0285" num="0264">As shown in Table 5, when tu_cbf_luma[x0][y0] is 0, coding mts_idx[x0][y0] may be omitted. That is, when the CBF value of the luma component is 0, no transform is applied and thus the MTS index does not need signaling. Therefore, coding the MTS index may be omitted.</p><p id="p-0286" num="0265">According to an example, the above technical feature may be implemented in another conditional syntax. For example, after the MTS is performed, a variable indicating whether a significant coefficient exists in a region other than the DC region of the current block may be derived, and when the variable indicates that the significant coefficient exists in the region excluding the DC region, the MTS index can be signaled. That is, the existence of the significant coefficient in the region other than the DC region of the current block indicates that the value of tu_cbf_luma[x0][y0] is 1, and in this case, the MTS index can be signaled.</p><p id="p-0287" num="0266">The variable may be expressed as MtsDcOnly, and after the variable MtsDcOnly is initially set to 1 at the coding unit level, the value is changed to 0 when it is determined that the significant coefficient is present in the region except for the DC region of the current block in the residual coding level. When the variable MtsDcOnly is 0, image information may be configured such that the MTS index is signaled.</p><p id="p-0288" num="0267">When tu_cbf_luma[x0][y0] is 0, since the residual coding syntax is not called at the transform unit level of Table 6, the initial value of 1 of the variable MtsDcOnly is maintained. In this case, since the variable MtsDcOnly is not changed to 0, the image information may be configured so that the MTS index is not signaled. That is, the MTS index is not parsed and signaled.</p><p id="p-0289" num="0268">Meanwhile, the decoding apparatus may determine the color index cIdx of the transform coefficient to derive the variable MtsZeroOutSigCoeffFlag of Table 7. The color index cIdx of 0 means a luma component.</p><p id="p-0290" num="0269">According to an example, since the MTS can be applied only to the luma component of the current block, the decoding apparatus can determine whether the color index is luma when deriving the variable MtsZeroOutSigCoeffFlag for determining whether to parse the MTS index.</p><p id="p-0291" num="0270">The variable MtsZeroOutSigCoeffFlag is a variable indicating whether the zero-out is performed when the MTS is applied. It indicates whether the transform coefficient exists in the top-left region where the last significant coefficient may exist due to the zero-out after the MTS is performed, that is, in the region other than the top-left 16&#xd7;16 region. The variable MtsZeroOutSigCoeffFlag is initially set to 1 at the coding unit level as shown in Table 4 (MtsZeroOutSigCoeffFlag=1), and when the transform coefficient exists in the region other than the 16&#xd7;16 region, its value can be changed from 1 to 0 in the residual coding level as shown in Table 7 (MtsZeroOutSigCoeffFlag=0). When the value of the variable MtsZeroOutSigCoeffFlag is 0, the MTS index is not signaled.</p><p id="p-0292" num="0271">As shown in Table 7, at the residual coding level, a non-zero-out region in which a non-zero transform coefficient may exist may be set depending on whether or not the zero-out accompanying the MTS is performed, and even in this case, the color index (cIdx) is 0, the non-zero-out region may be set to the top-left 16&#xd7;16 region of the current block.</p><p id="p-0293" num="0272">As such, when deriving the variable that determines whether the MTS index is parsed, it is determined whether the color component is luma or chroma. However, since LFNST can be applied to both the luma component and the chroma component of the current block, the color component is not determined when deriving a variable for determining whether to parse the LFNST index.</p><p id="p-0294" num="0273">For example, Table 5 shows a variable LfnstZeroOutSigCoeffFlag that may indicate that zero-out is performed when LFNST is applied. The variable LfnstZeroOutSigCoeffFlag indicates whether a significant coefficient exists in the second region except for the first region at the top-left of the current block. This value is initially set to 1, and when the significant coefficient is present in the second region, the value can be changed to 0. The LFNST index can be parsed only when the value of the initially set variable LfnstZeroOutSigCoeffFlag is maintained at 1. When determining and deriving whether the variable LfnstZeroOutSigCoeffFlag value is 1, since the LFNST may be applied to both the luma component and the chroma component of the current block, the color index of the current block is not determined.</p><p id="p-0295" num="0274">As shown in Table 5, the MTS index is signaled for each coding unit, and mts_idx (MTS index) is signaled only when MtsZeroOutSigCoeffFlag is equal to 1.</p><p id="p-0296" num="0275">Further, as shown in Table 7, the value of MtsZeroOutCoeffFlag may be determined according to a specific condition (if((LastSignificantCoeffX&#x3e;15&#x2225;LastSignificantCoeffY&#x3e;15) &#x26;&#x26; cIdx==0)) in a residual coding level.</p><p id="p-0297" num="0276">The value of MtsZeroOutSigCoeffFlag is set to 0 when the x-coordinate (LastSignificantCoeffX) of the last non-zero coefficient is greater than 15 and the y-coordinate (LastSignificantCoeffY) of the last non-zero coefficient is greater than 15. Here, x-coordinates increase from left to right in the transform block, and y-coordinates increase from top to bottom in the transform block. The top-left position of the transform block is (0, 0).</p><p id="p-0298" num="0277">The value of MtsZeroOutSigCoeffFlag is initialized to 1 in Table 5, and is maintained as 1 if the condition present in Table 7 is not satisfied and thus the value of MtsZeroOutSigCoeffFlag is not set to 0.</p><p id="p-0299" num="0278">When a primary transform applied in a horizontal direction is A and a primary transform applied in a vertical direction is B, a primary transform may be represented by (A, B). In the current VVC standard, in a case of (DST-7, DST-7), (DST-7, DCT-8), (DCT-8, DST-7), and (DCT-8, DCT-8), a transform coefficient is limited to exist only in a top-left 16&#xd7;16 region of the transform block. Therefore, the condition of (LastSignificantCoeffX&#x3e;15&#x2225;LastSignificantCoeffY&#x3e;15) in Table 7 indicates that the last non-zero coefficient is positioned outside the top-left 16&#xd7;16 region. In Table 7, a variable cIdx denotes a color component, and a variable cIdx value of 0 indicates a luma component.</p><p id="p-0300" num="0279">In the current VVC standard, the MTS index (mts_idx) is parsed after parsing for residual coding. Specifically, Table 5 is a coding unit that is a syntax parsing function for a coding unit, the MTS index is parsed after a transform tree function, and a function of parsing residual coding in the transform tree function is invoked. Therefore, the MTS index is parsed after residual parsing (a residual parsing function illustrated in Table 6 is responsible for parsing the residual coding), and since MTS index information is not known from the perspective of decoding during residual coding, it may not be impossible to know which primary transform is applied. However, when the MTS is applicable and the SBT or ISP is applied or when the implicit MTS is applied, the MTS is implicitly applied, and thus it is possible to know about the primary transform before parsing for residual coding.</p><p id="p-0301" num="0280">The condition illustrated in Table 7 needs checking, because the current VVC standard sets a restriction of outputting only 16 transform coefficients when a forward transform is applied in 32-length DST-7 or 32-length DCT-8. For example, when the value of the MTS index is greater than 0 and thus indicates that an applied primary transform is one of (DST-7, DST-7), (DST-7, DCT-8), (DCT-8, DST-7), (DCT-8, DCT-8), a non-zero transform coefficient may exist only in the top-left 16&#xd7;16 region of the transform block.</p><p id="p-0302" num="0281">Accordingly, when the position of the last non-zero transform coefficient is outside the top-left 16&#xd7;16 region, which corresponds to a case where the MTS index value is 0, signaling of the MTS index may be omitted as shown in Table 5. However, even though the position of the last non-zero transform coefficient is within the top-left 16&#xd7;16 region, a non-zero coefficient may exist outside the top-left 16&#xd7;16 region. In this case, the MTS index may be signaled as 0 even though the MTS index value is 0, which is described in detail as follows.</p><p id="p-0303" num="0282">When the primary transform is (DCT-2, DCT-2), the position of the last non-zero coefficient exists in the top-left 16&#xd7;16 region and a non-zero transform coefficient may also exist outside the top-left 16&#xd7;16 region, because in the scan order within the transform block, a region outside the top-left 16&#xd7;16 region, that is, a region other than the top-left 16&#xd7;16 region, may be scanned and then the top-left 16&#xd7;16 region may be scanned, or the top-left 16&#xd7;16 region may be scanned and then the region outside the top-left 16&#xd7;16 region may be scanned.</p><p id="p-0304" num="0283"><figref idref="DRAWINGS">FIG. <b>15</b></figref> illustrates a scan of a 32&#xd7;32 transform block according to an embodiment of the present disclosure, which specifically shows that the 32&#xd7;32 transform block is divided into 4&#xd7;4 coefficient groups (CGs) and scanned. In the present disclosure, the CGs divided to be scanned are referred to as &#x201c;scan subblocks&#x201d;.</p><p id="p-0305" num="0284">A number indicated for each CG denotes a forward scan order, and the CGs may be scanned by the decoding apparatus according to a reverse scan order from the position where the last non-zero transform coefficient exists. In <figref idref="DRAWINGS">FIG. <b>15</b></figref>, it may be assumed that the last non-zero transform coefficient exists in CG 25, and CG 25 exists in the top-left 16&#xd7;16 region.</p><p id="p-0306" num="0285">As shown in <figref idref="DRAWINGS">FIG. <b>15</b></figref>, when the last non-zero transform coefficient exists in CG 25, since the decoding apparatus scans the CGs according to the reverse scan order from the CG in which the last non-zero transform coefficient exists, the decoding apparatus scans the CGs in an order of 25, 24, 23, . . . , 3, 2, 1 based on the numbers indicated in <figref idref="DRAWINGS">FIG. <b>15</b></figref>. Since CGs 24, 23, 22, 21, 20, 17, 16, 15, and 11 are positioned outside the top-left 16&#xd7;16 region, it is impossible to know whether a non-zero coefficient exists only in the top-left 16&#xd7;16 region only by checking whether LastSignificantCoeffX and LastSignificantCoeffY correspond to the top-left 16&#xd7;16 region as shown in Table 6.</p><p id="p-0307" num="0286">Therefore, when performing parsing for residual coding, if checking whether a corresponding 4&#xd7;4 coefficient group belongs to the top-left 16&#xd7;16 region whenever a non-zero transform coefficient is scanned, the value of MtsZeroOutSigCoeffFlag may be set to 0 only in a case where a non-zero coefficient exists outside the top-left 16&#xd7;16 region. In this case, a residual coding syntax is as shown in the following table.</p><p id="p-0308" num="0000"><tables id="TABLE-US-00008" num="00008"><table frame="none" colsep="0" rowsep="0" tabstyle="monospace"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="14pt" align="left"/><colspec colname="2" colwidth="161pt" align="left"/><colspec colname="3" colwidth="42pt" align="left"/><thead><row><entry namest="1" nameend="3" rowsep="1">TABLE&#x2003;8</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row><row><entry>&#x2003;</entry><entry>residual_coding(&#x2003;x0,&#x2003;y0,&#x2003;</entry><entry/></row><row><entry/><entry>log2TbWidth,&#x2003;</entry><entry/></row><row><entry/><entry>log2TbHeight,&#x2003;cIdx&#x2003;)&#x2003;{</entry><entry>Descriptor</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2003;if(&#x2003;(&#x2003;(&#x2003;sps_mts_enabled_flag&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x26;&#x26;&#x2003;cu_sbt_flag&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;log2TbWidth&#x2003;&#x3c;&#x2003;6&#x2003;&#x26;&#x26;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;log2TbHeight&#x2003;&#x3c;&#x2003;6&#x2003;)&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x26;&#x26;&#x2003;cIdx&#x2003;=&#x2003;=&#x2003;0&#x2003;&#x26;&#x26;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;log2TbWidth&#x2003;&#x3e;&#x2003;4&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;log2ZoTbWidth&#x2003;=&#x2003;4</entry><entry/></row><row><entry/><entry>&#x2003;else</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;log2ZoTbWidth&#x2003;=&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;Min(&#x2003;log2TbWidth,&#x2003;5&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;if(&#x2003;(&#x2003;sps_mts_enabled_flag&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x26;&#x26;&#x2003;cu_sbt_flag&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;log2TbWidth&#x2003;&#x3c;&#x2003;6&#x2003;&#x26;&#x26;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;log2TbHeight&#x2003;&#x3c;&#x2003;6&#x2003;)&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x26;&#x26;&#x2003;cIdx&#x2003;=&#x2003;=&#x2003;0&#x2003;&#x26;&#x26;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;log2TbHeight&#x2003;&#x3e;&#x2003;4&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;log2ZoTbHeight&#x2003;=&#x2003;4</entry><entry/></row><row><entry/><entry>&#x2003;else</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;log2ZoTbHeight&#x2003;=&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;Min(&#x2003;log2TbHeight,&#x2003;5&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;if(&#x2003;log2TbWidth&#x2003;&#x3e;&#x2003;0&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;last_sig_coeff_x_prefix</entry><entry>ae(v)</entry></row><row><entry/><entry>&#x2003;if(&#x2003;log2TbHeight&#x2003;&#x3e;&#x2003;0&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;last_sig_coeff_y_prefix</entry><entry>ae(v)</entry></row><row><entry/><entry>&#x2003;if(&#x2003;last_sig_coeff_</entry><entry/></row><row><entry/><entry>&#x2003;x_prefix&#x2003;&#x3e;&#x2003;3&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;last_sig_coeff_x_suffix</entry><entry>ae(v)</entry></row><row><entry/><entry>&#x2003;if(&#x2003;last_sig_coeff_</entry><entry/></row><row><entry/><entry>&#x2003;y_prefix&#x2003;&#x3e;&#x2003;3&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;last_sig_coeff_y&#x2003;suffix</entry><entry>ae(v)</entry></row><row><entry/><entry>&#x2003;log2TbWidth&#x2003;=&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;log2ZoTbWidth</entry><entry/></row><row><entry/><entry>&#x2003;log2TbHeight&#x2003;=&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;log2ZoTbHeight</entry><entry/></row><row><entry/><entry>&#x2003;remBinsPass1&#x2003;=&#x2003;(&#x2003;(&#x2003;1&#x2003;&#x3c;&#x3c;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;(&#x2003;log2TbWidth&#x2003;+&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;log2TbHeight&#x2003;)&#x2003;)&#x2003;*&#x2003;7&#x2003;)&#x2003;&#x3e;&#x3e;&#x2003;2</entry><entry/></row><row><entry/><entry>&#x2003;log2SbW&#x2003;=&#x2003;(&#x2003;Min</entry><entry/></row><row><entry/><entry>&#x2003;(&#x2003;log2TbWidth,&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;log2TbHeight&#x2003;)&#x2003;&#x3c;&#x2003;2&#x2003;?&#x2003;1&#x2003;:&#x2003;2&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;log2SbH&#x2003;=&#x2003;log2SbW</entry><entry/></row><row><entry/><entry>&#x2003;if(&#x2003;log2TbWidth&#x2003;+&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;log2TbHeight&#x2003;&#x3e;&#x2003;3&#x2003;)&#x2003;{</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;if(&#x2003;log2TbWidth&#x2003;&#x3c;&#x2003;2&#x2003;)&#x2003;{</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;log2SbW&#x2003;=&#x2003;log2TbWidth</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;log2SbH&#x2003;=&#x2003;4&#x2003;&#x2212;&#x2003;log2SbW</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;}&#x2003;else&#x2003;if(&#x2003;log2TbHeight&#x2003;&#x3c;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;2&#x2003;)&#x2003;{</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;log2SbH&#x2003;=&#x2003;log2TbHeight</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;log2SbW&#x2003;=&#x2003;4&#x2003;&#x2212;&#x2003;log2SbH</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry/><entry>&#x2003;}</entry><entry/></row><row><entry/><entry>&#x2003;numSbCoeff&#x2003;=&#x2003;1&#x2003;&#x3c;&#x3c;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;(&#x2003;log2SbW&#x2003;+&#x2003;log2SbH&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;lastScanPos&#x2003;=&#x2003;numSbCoeff</entry><entry/></row><row><entry/><entry>&#x2003;lastSubBlock&#x2003;=&#x2003;(&#x2003;1&#x2003;&#x3c;&#x3c;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;(&#x2003;log2TbWidth&#x2003;+&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;log2TbHeight&#x2003;&#x2212;&#x2003;(&#x2003;log2SbW&#x2003;+&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;log2SbH&#x2003;)&#x2003;)&#x2003;)&#x2003;&#x2212;&#x2003;1</entry><entry/></row><row><entry/><entry>&#x2003;do&#x2003;{</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;if(&#x2003;lastScanPos&#x2003;=&#x2003;=&#x2003;0&#x2003;)&#x2003;{</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;lastScanPos&#x2003;=&#x2003;numSbCoeff</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;lastSubBlock&#x2212;&#x2003;&#x2212;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;lastScanPos&#x2212;&#x2003;&#x2212;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;xS&#x2003;=&#x2003;DiagScanOrder</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;[&#x2003;log2TbWidth&#x2003;&#x2212;&#x2003;log2SbW&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;[&#x2003;log2TbHeight&#x2003;&#x2212;&#x2003;log2SbH&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;[&#x2003;lastSubBlock&#x2003;][&#x2003;0&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;yS&#x2003;=&#x2003;DiagScanOrder</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;[&#x2003;log2TbWidth&#x2003;&#x2212;&#x2003;log2SbW&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;[&#x2003;log2TbHeight&#x2003;&#x2212;&#x2003;log2SbH&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;[&#x2003;lastSubBlock&#x2003;][&#x2003;1&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;xC&#x2003;=&#x2003;(&#x2003;xS&#x2003;&#x3c;&#x3c;&#x2003;log2SbW&#x2003;)&#x2003;+&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;DiagScanOrder[&#x2003;log2SbW&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;[&#x2003;log2SbH&#x2003;][&#x2003;lastScanPos&#x2003;][&#x2003;0&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;yC&#x2003;=&#x2003;(&#x2003;yS&#x2003;&#x3c;&#x3c;&#x2003;log2SbH&#x2003;)&#x2003;+&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;DiagScanOrder[&#x2003;log2SbW&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;[&#x2003;log2SbH&#x2003;][&#x2003;lastScanPos&#x2003;][&#x2003;1&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;}&#x2003;while(&#x2003;(&#x2003;xC&#x2003;!=&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;LastSignificantCoeffX&#x2003;)&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;|&#x2003;|&#x2003;(&#x2003;yC&#x2003;!=&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;LastSignificantCoeffY&#x2003;)&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;if(&#x2003;lastSubBlock&#x2003;=&#x2003;=&#x2003;0&#x2003;&#x26;&#x26;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;log2TbWidth&#x2003;&#x3e;=&#x2003;2&#x2003;&#x26;&#x26;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;log2TbHeight&#x2003;&#x3e;=&#x2003;2</entry><entry/></row><row><entry/><entry>&#x26;&#x26;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;!transform_skip_flag[&#x2003;x0&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;[&#x2003;y0&#x2003;][&#x2003;cIdx&#x2003;]&#x2003;&#x26;&#x26;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;lastScanPos&#x2003;&#x3e;&#x2003;0&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;LfnstDcOnly&#x2003;=&#x2003;0</entry><entry/></row><row><entry/><entry>&#x2003;if(&#x2003;(&#x2003;lastSubBlock&#x2003;&#x3e;&#x2003;0&#x2003;&#x26;&#x26;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;log2TbWidth&#x2003;&#x3e;=&#x2003;2&#x2003;&#x26;&#x26;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;log2TbHeight&#x2003;&#x3e;=&#x2003;2&#x2003;)&#x2003;|&#x2003;|&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;(&#x2003;lastScanPos&#x2003;&#x3e;&#x2003;7&#x2003;&#x26;&#x26;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;(&#x2003;log2TbWidth&#x2003;=&#x2003;=&#x2003;2&#x2003;|&#x2003;|&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;log2TbWidth&#x2003;=&#x2003;=&#x2003;3&#x2003;)&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;log2TbWidth&#x2003;=&#x2003;=&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;log2TbHeight&#x2003;)&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;LfnstZeroOutSigCoeffFlag&#x2003;=&#x2003;0</entry><entry/></row><row><entry/><entry>&#x2003;if(&#x2003;(&#x2003;LastSignificantCoeffX&#x2003;&#x3e;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;15&#x2003;|&#x2003;|&#x2003;LastSignificantCoeffY&#x2003;&#x3e;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;15&#x2003;)&#x2003;&#x26;&#x26;&#x2003;cIdx&#x2003;=&#x2003;=&#x2003;0&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;MtsZeroOutSigCoeffFlag&#x2003;=&#x2003;0</entry><entry/></row><row><entry/><entry>&#x2003;QState&#x2003;=&#x2003;0</entry><entry/></row><row><entry/><entry>&#x2003;for(&#x2003;i&#x2003;=&#x2003;lastSubBlock;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;i&#x2003;&#x3e;=&#x2003;0;&#x2003;i&#x2212;&#x2003;&#x2212;&#x2003;)&#x2003;{</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;startQStateSb&#x2003;=&#x2003;QState</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;xS&#x2003;=&#x2003;DiagScanOrder</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;[&#x2003;log2TbWidth&#x2003;&#x2212;&#x2003;log2SbW&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;[&#x2003;log2TbHeight&#x2003;&#x2212;&#x2003;log2SbH&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;[&#x2003;i&#x2003;][&#x2003;0&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;yS&#x2003;=&#x2003;DiagScanOrder</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;[&#x2003;log2TbWidth&#x2003;&#x2212;&#x2003;log2SbW&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;[&#x2003;log2TbHeight&#x2003;&#x2212;&#x2003;log2SbH&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;[&#x2003;i&#x2003;][&#x2003;1&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;inferSbDcSigCoeffFlag&#x2003;=&#x2003;0</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;if(&#x2003;(&#x2003;i&#x2003;&#x3c;&#x2003;lastSubBlock&#x2003;)&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x26;&#x26;&#x2003;(&#x2003;i&#x2003;&#x3e;&#x2003;0&#x2003;)&#x2003;)&#x2003;{</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;coded_sub_block_</entry><entry>ae(v)</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;flag[&#x2003;xS&#x2003;][&#x2003;yS&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;inferSbDcSigCoeffFlag&#x2003;=&#x2003;1</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;firstSigScanPosSb&#x2003;=&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;numSbCoeff</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;lastSigScanPosSb&#x2003;=&#x2003;&#x2212;1</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;firstPosMode0&#x2003;=&#x2003;(&#x2003;i&#x2003;=&#x2003;=&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;lastSubBlock&#x2003;?&#x2003;lastScanPos&#x2003;:&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;numSbCoeff&#x2003;&#x2212;&#x2003;1&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;firstPosMode1&#x2003;=&#x2003;&#x2212;1</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;for(&#x2003;n&#x2003;=&#x2003;firstPosMode0;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;n&#x2003;&#x3e;=&#x2003;0&#x2003;&#x26;&#x26;&#x2003;remBinsPass1&#x2003;&#x3e;=&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;4;&#x2003;n&#x2212;&#x2003;&#x2212;&#x2003;)&#x2003;{</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;xC&#x2003;=&#x2003;(&#x2003;xS&#x2003;&#x3c;&#x3c;&#x2003;log2SbW&#x2003;)&#x2003;+&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;DiagScanOrder[&#x2003;log2SbW&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;[&#x2003;log2SbH&#x2003;][&#x2003;n&#x2003;][&#x2003;0&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;yC&#x2003;=&#x2003;(&#x2003;yS&#x2003;&#x3c;&#x3c;&#x2003;log2SbH&#x2003;)&#x2003;+&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;DiagScanOrder[&#x2003;log2SbW&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;[&#x2003;log2SbH&#x2003;][&#x2003;n&#x2003;][&#x2003;1&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;if(&#x2003;coded_sub_block_</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;flag[&#x2003;xS&#x2003;][&#x2003;yS&#x2003;]&#x2003;&#x26;&#x26;&#x2003;(&#x2003;n&#x2003;&#x3e;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;0&#x2003;|&#x2003;|&#x2003;!inferSbDcSigCoeffFlag&#x2003;)</entry><entry/></row><row><entry/><entry>&#x26;&#x26;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;(&#x2003;xC&#x2003;!=&#x2003;LastSignificant-</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;CoeffX&#x2003;|&#x2003;|&#x2003;yC&#x2003;!=&#x2003;Last&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;SignificantCoeffY&#x2003;)&#x2003;)&#x2003;{</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;sig_coeff_flag[&#x2003;xC&#x2003;][&#x2003;yC&#x2003;]</entry><entry>ae(v)</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;remBinsPass1&#x2212;&#x2003;&#x2212;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;if(&#x2003;sig_coeff_flag</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;[&#x2003;xC&#x2003;][&#x2003;yC&#x2003;]&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;inferSbDcSigCoeffFlag&#x2003;=&#x2003;0</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;if(&#x2003;sig_coeff_flag</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;[&#x2003;xC&#x2003;][&#x2003;yC&#x2003;]&#x2003;)&#x2003;{</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if(&#x2003;(&#x2003;xC&#x2003;&#x3e;&#x2003;15&#x2003;|&#x2003;|&#x2003;yC&#x2003;&#x3e;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;15&#x2003;)&#x2003;&#x26;&#x26;&#x2003;cIdx&#x2003;=&#x2003;=&#x2003;0&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;MtsZeroOutSig-</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;CoeffFlag&#x2003;=&#x2003;0</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;abs_level_gtx_</entry><entry>ae(v)</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;flag[&#x2003;n&#x2003;][&#x2003;0&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;remBinsPass1&#x2212;&#x2003;&#x2212;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;if(&#x2003;abs_level_gtx_</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;flag[&#x2003;n&#x2003;][&#x2003;0&#x2003;]&#x2003;)&#x2003;{</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;par_level_flag[&#x2003;n&#x2003;]</entry><entry>ae(v)</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;remBinsPass1&#x2212;&#x2003;&#x2212;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;abs_level_gtx_</entry><entry>ae(v)</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;flag[&#x2003;n&#x2003;][&#x2003;1&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;remBinsPass1&#x2212;&#x2003;&#x2212;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;if(&#x2003;lastSigScanPosSb&#x2003;=&#x2003;=&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2212;1&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;lastSigScanPosSb&#x2003;=&#x2003;n</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;firstSigScanPosSb&#x2003;=&#x2003;n</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;AbsLevelPass1[&#x2003;xC&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;[&#x2003;yC&#x2003;]&#x2003;=&#x2003;sig_coeff_flag</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;[&#x2003;xC&#x2003;][&#x2003;yC&#x2003;]&#x2003;+&#x2003;par_</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;level_flag[&#x2003;n&#x2003;]&#x2003;+</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;abs_level_gtx_flag</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;[&#x2003;n&#x2003;][&#x2003;0&#x2003;]&#x2003;+&#x2003;2&#x2003;*&#x2003;abs_</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;level_gtx_flag[&#x2003;n&#x2003;][&#x2003;1&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;if(&#x2003;pic_dep_quant_</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;enabled_flag&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;QState&#x2003;=&#x2003;QStateTransTable</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;[&#x2003;QState&#x2003;][&#x2003;AbsLevelPass1</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;[&#x2003;xC&#x2003;][&#x2003;yC&#x2003;]&#x2003;&#x26;&#x2003;1&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;if(&#x2003;remBinsPass1&#x2003;&#x3c;&#x2003;4&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;firstPosMode1&#x2003;=&#x2003;n&#x2003;&#x2212;&#x2003;1</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;...</entry><entry/></row><row><entry/><entry>&#x2003;}</entry><entry/></row><row><entry/><entry>}</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0309" num="0287">As shown in Table 8, whenever a non-zero transform coefficient is found, whether the non-zero transform coefficient is positioned in the top-left 16&#xd7;16 region (if((xC&#x3e;15&#x2225;yC&#x3e;15) &#x26;&#x26; cIdx==0)) may be checked, thereby setting the value MtsZeroOutSigCoeffFlag to 0. Here, this condition is checked when the value of sig_coeff_flag[xC][yC], which is flag information indicating whether the transform coefficient exists, is 1 (if(sig_coeff_flag[xC][yC])), where xC and yC respectively denote an x-coordinate and a y-coordinate in sample units within the transform block. The top-left position of the transform block is (0, 0).</p><p id="p-0310" num="0288">Table 8 includes the condition check presented in Table 7 and an update of MtsZeroOutSigCoeffFlag (if((LastSignificantCoeffX&#x3e;15 LastSignificantCoeffY&#x3e;15) &#x26;&#x26; cIdx==0) MtsZeroOutSigCoeffFlag=0). If the value of sig_coeff_flag[xC][yC] for the last non-zero transform coefficient is inferred to be 1, the condition check and the update of MtsZeroOutSigCoeffFlag may be removed from Table 8.</p><p id="p-0311" num="0289">In summary, when signaling the MTS index in Table 5 through the syntax configuration shown in Table 8, the MTS index is signaled only when a non-zero transform coefficient exists in a top-left 16&#xd7;16 region of a luma transform block regardless of which primary transform is applied. When the MTS index is not signaled, the value of the MTS index is inferred as 0, that is, (DCT-2, DCT-2) is applied.</p><p id="p-0312" num="0290">As described above, in the following three cases, an applied primary transform can be known before the MTS index is signaled.</p><p id="p-0313" num="0291">1) Where the subblock transform (SBT) is applied</p><p id="p-0314" num="0292">2) Where the intra sub-partition (ISP) is applied</p><p id="p-0315" num="0293">3) Where the implicit MTS is applied</p><p id="p-0316" num="0294">In case (1), since the MTS index is configured to be signaled only when the value of cu_sbt_flag indicating whether the SBT is applied in Table 5 is 0, that is, since the MTS index is signaled only when the SBT is not applied, the case where the SBT is applied is irrelevant to the modification of Table 7.</p><p id="p-0317" num="0295">In case (2), since the MTS index is signaled only when the ISP is not applied in Table 4 (a condition if IntraSubPartitionsSplit[x0][y0]==ISP_NO_SPLIT is checked when signaling the MTS index in Table 5), the case where the ISP is applied is also irrelevant to the modification of Table 8.</p><p id="p-0318" num="0296">In case (3), since the MTS index is signaled only when an explicit MTS is enabled in Table 5, the case where the implicit MTS is applied is also irrelevant to the modification of Table 7. That is, since the MTS index is signaled only when the value of sps_explicit_mts_intra_enabled_flag is 1 in an MTS (intra MTS) applied to a residual block generated by intra prediction and the value of sps_explicit_mts_inter_enabled_flag is 1 in an MTS (inter MTS) applied to a residual block generated by inter prediction, the modification of Table 8 does not affect the case where the implicit MTS is applied.</p><p id="p-0319" num="0297">According to another example, as shown in the following table, it may be checked whether a non-zero coefficient exists outside the top-left 16&#xd7;16 region by a unit of a CG.</p><p id="p-0320" num="0000"><tables id="TABLE-US-00009" num="00009"><table frame="none" colsep="0" rowsep="0" tabstyle="monospace"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="14pt" align="left"/><colspec colname="2" colwidth="161pt" align="left"/><colspec colname="3" colwidth="42pt" align="left"/><thead><row><entry namest="1" nameend="3" rowsep="1">TABLE&#x2003;9</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row><row><entry>&#x2003;</entry><entry>residual_coding(&#x2003;x0,&#x2003;y0,&#x2003;</entry><entry/></row><row><entry/><entry>log2TbWidth,&#x2003;</entry><entry/></row><row><entry/><entry>log2TbHeight,&#x2003;cIdx&#x2003;)&#x2003;{</entry><entry>Descriptor</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2003;if(&#x2003;(&#x2003;(&#x2003;sps_mts_enabled_</entry><entry/></row><row><entry/><entry>&#x2003;flag&#x2003;&#x26;&#x26;&#x2003;cu_sbt_flag&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;log2TbWidth&#x2003;&#x3c;&#x2003;6&#x2003;&#x26;&#x26;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;log2TbHeight&#x2003;&#x3c;&#x2003;6&#x2003;)&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x26;&#x26;&#x2003;cIdx&#x2003;=&#x2003;=&#x2003;0&#x2003;&#x26;&#x26;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;log2TbWidth&#x2003;&#x3e;&#x2003;4&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;log2ZoTbWidth&#x2003;=&#x2003;4</entry><entry/></row><row><entry/><entry>&#x2003;else</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;log2ZoTbWidth&#x2003;=&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;Min(&#x2003;log2TbWidth,&#x2003;5&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;if(&#x2003;(&#x2003;sps_mts_enabled_flag&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x26;&#x26;&#x2003;cu_sbt_flag&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;log2TbWidth&#x2003;&#x3c;&#x2003;6&#x2003;&#x26;&#x26;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;log2TbHeight&#x2003;&#x3c;&#x2003;6&#x2003;)&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x26;&#x26;&#x2003;cIdx&#x2003;=&#x2003;=&#x2003;0&#x2003;&#x26;&#x26;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;log2TbHeight&#x2003;&#x3e;&#x2003;4&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;log2ZoTbHeight&#x2003;=&#x2003;4</entry><entry/></row><row><entry/><entry>&#x2003;else</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;log2ZoTbHeight&#x2003;=&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;Min(&#x2003;log2TbHeight,&#x2003;5&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;if(&#x2003;log2TbWidth&#x2003;&#x3e;&#x2003;0&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;last_sig_coeff_x_prefix</entry><entry>ae(v)</entry></row><row><entry/><entry>&#x2003;if(&#x2003;log2TbHeight&#x2003;&#x3e;&#x2003;0&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;last_sig_coeff_y_prefix</entry><entry>ae(v)</entry></row><row><entry/><entry>&#x2003;if(&#x2003;last_sig_coeff_x_prefix&#x2003;&#x3e;&#x2003;3&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;last_sig_coeff_x_suffix</entry><entry>ae(v)</entry></row><row><entry/><entry>&#x2003;if(&#x2003;last_sig_coeff_y_prefix&#x2003;&#x3e;&#x2003;3&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;last_sig_coeff_y&#x2003;suffix</entry><entry>ae(v)</entry></row><row><entry/><entry>&#x2003;log2TbWidth&#x2003;=&#x2003;log2ZoTbWidth</entry><entry/></row><row><entry/><entry>&#x2003;log2TbHeight&#x2003;=&#x2003;log2ZoTbHeight</entry><entry/></row><row><entry/><entry>&#x2003;remBinsPass1&#x2003;=&#x2003;(&#x2003;(&#x2003;1&#x2003;&#x3c;&#x3c;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;(&#x2003;log2TbWidth&#x2003;+&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;log2TbHeight&#x2003;)&#x2003;)&#x2003;*&#x2003;7&#x2003;)&#x2003;&#x3e;&#x3e;&#x2003;2</entry><entry/></row><row><entry/><entry>&#x2003;log2SbW&#x2003;=&#x2003;(&#x2003;Min(&#x2003;log2TbWidth,&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;log2TbHeight&#x2003;)&#x2003;&#x3c;&#x2003;2&#x2003;?&#x2003;1&#x2003;:&#x2003;2&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;log2SbH&#x2003;=&#x2003;log2SbW</entry><entry/></row><row><entry/><entry>&#x2003;if(&#x2003;log2TbWidth&#x2003;+&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;log2TbHeight&#x2003;&#x3e;&#x2003;3&#x2003;)&#x2003;{</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;if(&#x2003;log2TbWidth&#x2003;&#x3c;&#x2003;2&#x2003;)&#x2003;{</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;log2SbW&#x2003;=&#x2003;log2TbWidth</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;log2SbH&#x2003;=&#x2003;4&#x2003;&#x2212;&#x2003;log2SbW</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;}&#x2003;else&#x2003;if(&#x2003;log2TbHeight&#x2003;&#x3c;&#x2003;2&#x2003;)&#x2003;{</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;log2SbH&#x2003;=&#x2003;log2TbHeight</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;log2SbW&#x2003;=&#x2003;4&#x2003;&#x2212;&#x2003;log2SbH</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry/><entry>&#x2003;}</entry><entry/></row><row><entry/><entry>&#x2003;numSbCoeff&#x2003;=&#x2003;1&#x2003;&#x3c;&#x3c;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;(&#x2003;log2SbW&#x2003;+&#x2003;log2SbH&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;lastScanPos&#x2003;=&#x2003;numSbCoeff</entry><entry/></row><row><entry/><entry>&#x2003;lastSubBlock&#x2003;=&#x2003;(&#x2003;1&#x2003;&#x3c;&#x3c;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;(&#x2003;log2TbWidth&#x2003;+&#x2003;log2TbHeight&#x2003;&#x2212;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;(&#x2003;log2SbW&#x2003;+&#x2003;log2SbH&#x2003;)&#x2003;)&#x2003;)&#x2003;&#x2212;&#x2003;1</entry><entry/></row><row><entry/><entry>&#x2003;do&#x2003;{</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;if(&#x2003;lastScanPos&#x2003;=&#x2003;=&#x2003;0&#x2003;)&#x2003;{</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;lastScanPos&#x2003;=&#x2003;numSbCoeff</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;lastSubBlock&#x2212;&#x2003;&#x2212;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;lastScanPos&#x2212;&#x2003;&#x2212;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;xS&#x2003;=&#x2003;DiagScanOrder</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;[&#x2003;log2TbWidth&#x2003;&#x2212;&#x2003;log2SbW&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;[&#x2003;log2TbHeight&#x2003;&#x2212;&#x2003;log2SbH&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;[&#x2003;lastSubBlock&#x2003;][&#x2003;0&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;yS&#x2003;=&#x2003;DiagScanOrder</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;[&#x2003;log2TbWidth&#x2003;&#x2212;&#x2003;log2SbW&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;[&#x2003;log2TbHeight&#x2003;&#x2212;&#x2003;log2SbH&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;[&#x2003;lastSubBlock&#x2003;][&#x2003;1&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;xC&#x2003;=&#x2003;(&#x2003;xS&#x2003;&#x3c;&#x3c;&#x2003;log2SbW&#x2003;)&#x2003;+&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;DiagScanOrder[&#x2003;log2SbW&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;[&#x2003;log2SbH&#x2003;][&#x2003;lastScanPos&#x2003;][&#x2003;0&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;yC&#x2003;=&#x2003;(&#x2003;yS&#x2003;&#x3c;&#x3c;&#x2003;log2SbH&#x2003;)&#x2003;+&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;DiagScanOrder[&#x2003;log2SbW&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;[&#x2003;log2SbH&#x2003;][&#x2003;lastScanPos&#x2003;][&#x2003;1&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;}&#x2003;while(&#x2003;(&#x2003;xC&#x2003;!=&#x2003;LastSignificant-</entry><entry/></row><row><entry/><entry>&#x2003;CoeffX&#x2003;)&#x2003;|&#x2003;|&#x2003;(&#x2003;yC&#x2003;!=&#x2003;Last-</entry><entry/></row><row><entry/><entry>&#x2003;SignificantCoeffY&#x2003;)&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;if(&#x2003;lastSubBlock&#x2003;=&#x2003;=&#x2003;0&#x2003;&#x26;&#x26;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;log2TbWidth&#x2003;&#x3e;=&#x2003;2&#x2003;&#x26;&#x26;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;log2TbHeight&#x2003;&#x3e;=&#x2003;2</entry><entry/></row><row><entry/><entry>&#x26;&#x26;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;!transform_skip_flag[&#x2003;x0&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;[&#x2003;y0&#x2003;][&#x2003;cIdx&#x2003;]&#x2003;&#x26;&#x26;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;lastScanPos&#x2003;&#x3e;&#x2003;0&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;LfnstDcOnly&#x2003;=&#x2003;0</entry><entry/></row><row><entry/><entry>&#x2003;if(&#x2003;(&#x2003;lastSubBlock&#x2003;&#x3e;&#x2003;0&#x2003;&#x26;&#x26;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;log2TbWidth&#x2003;&#x3e;=&#x2003;2&#x2003;&#x26;&#x26;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;log2TbHeight&#x2003;&#x3e;=&#x2003;2&#x2003;)&#x2003;|&#x2003;|&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;(&#x2003;lastScanPos&#x2003;&#x3e;&#x2003;7&#x2003;&#x26;&#x26;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;(&#x2003;log2TbWidth&#x2003;=&#x2003;=&#x2003;2&#x2003;|&#x2003;|&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;log2TbWidth&#x2003;=&#x2003;=&#x2003;3&#x2003;)&#x2003;&#x26;&#x26;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;log2TbWidth&#x2003;=&#x2003;=&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;log2TbHeight&#x2003;)&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;LfnstZeroOutSig-</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;CoeffFlag&#x2003;=&#x2003;0</entry><entry/></row><row><entry/><entry>&#x2003;if(&#x2003;(&#x2003;LastSignificantCoeffX&#x2003;&#x3e;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;15&#x2003;|&#x2003;|&#x2003;LastSignificantCoeffY&#x2003;&#x3e;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;15&#x2003;)&#x2003;&#x26;&#x26;&#x2003;cIdx&#x2003;=&#x2003;=&#x2003;0&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;MtsZeroOutSigCoeffFlag&#x2003;=&#x2003;0</entry><entry/></row><row><entry/><entry>&#x2003;QState&#x2003;=&#x2003;0</entry><entry/></row><row><entry/><entry>&#x2003;for(&#x2003;i&#x2003;=&#x2003;lastSubBlock;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;i&#x2003;&#x3e;=&#x2003;0;&#x2003;i&#x2212;&#x2003;&#x2212;&#x2003;)&#x2003;{</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;startQStateSb&#x2003;=&#x2003;QState</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;xS&#x2003;=&#x2003;DiagScanOrder</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;[&#x2003;log2TbWidth&#x2003;&#x2212;&#x2003;log2SbW&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;[&#x2003;log2TbHeight&#x2003;&#x2212;&#x2003;log2SbH&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;[&#x2003;i&#x2003;][&#x2003;0&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;yS&#x2003;=&#x2003;DiagScanOrder</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;[&#x2003;log2TbWidth&#x2003;&#x2212;&#x2003;log2SbW&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;[&#x2003;log2TbHeight&#x2003;&#x2212;&#x2003;log2SbH&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;[&#x2003;i&#x2003;][&#x2003;1&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;inferSbDcSigCoeffFlag&#x2003;=&#x2003;0</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;if(&#x2003;(&#x2003;i&#x2003;&#x3c;&#x2003;lastSubBlock&#x2003;)&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x26;&#x26;&#x2003;(&#x2003;i&#x2003;&#x3e;&#x2003;0&#x2003;)&#x2003;)&#x2003;{</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;coded_sub_block_</entry><entry>ae(v)</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;flag[&#x2003;xS&#x2003;][&#x2003;yS&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;inferSbDcSigCoeffFlag&#x2003;=&#x2003;1</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;if(&#x2003;coded_sub_block_</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;flag[&#x2003;xS&#x2003;][&#x2003;yS&#x2003;]&#x2003;&#x26;&#x26;&#x2003;(&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;(&#x2003;xS&#x2003;&#x3c;&#x3c;&#x2003;log2SbW&#x2003;)&#x2003;&#x3e;&#x2003;15&#x2003;|&#x2003;|</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;(&#x2003;yS&#x2003;&#x3c;&#x3c;&#x2003;log2SbH&#x2003;)&#x2003;&#x3e;&#x2003;15&#x2003;)&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x26;&#x26;&#x2003;cIdx&#x2003;==&#x2003;0&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;MtsZeroOutSig-</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;CoeffFlag&#x2003;=&#x2003;0</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;firstSigScanPosSb&#x2003;=&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;numSbCoeff</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;lastSigScanPosSb&#x2003;=&#x2003;&#x2212;1</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;firstPosMode0&#x2003;=&#x2003;(&#x2003;i&#x2003;=&#x2003;=&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;lastSubBlock&#x2003;?&#x2003;lastScanPos&#x2003;:&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;numSbCoeff&#x2003;&#x2212;&#x2003;1&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;firstPosMode1&#x2003;=&#x2003;&#x2212;1</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;for(&#x2003;n&#x2003;=&#x2003;firstPosMode0;&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;n&#x2003;&#x3e;=&#x2003;0&#x2003;&#x26;&#x26;&#x2003;remBinsPass1&#x2003;&#x3e;=&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;4;&#x2003;n&#x2212;&#x2003;&#x2212;&#x2003;)&#x2003;{</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;xC&#x2003;=&#x2003;(&#x2003;xS&#x2003;&#x3c;&#x3c;&#x2003;log2SbW&#x2003;)&#x2003;+&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;DiagScanOrder[&#x2003;log2SbW&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;[&#x2003;log2SbH&#x2003;][&#x2003;n&#x2003;][&#x2003;0&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;yC&#x2003;=&#x2003;(&#x2003;yS&#x2003;&#x3c;&#x3c;&#x2003;log2SbH&#x2003;)&#x2003;+&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;DiagScanOrder[&#x2003;log2SbW&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;[&#x2003;log2SbH&#x2003;][&#x2003;n&#x2003;][&#x2003;1&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;if(&#x2003;coded_sub_block_flag</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;[&#x2003;xS&#x2003;][&#x2003;yS&#x2003;]&#x2003;&#x26;&#x26;&#x2003;(&#x2003;n&#x2003;&#x3e;&#x2003;0&#x2003;|&#x2003;|&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;!inferSbDcSigCoeffFlag&#x2003;)</entry><entry/></row><row><entry/><entry>&#x26;&#x26;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;(&#x2003;xC&#x2003;!=&#x2003;LastSignificant-</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;CoeffX&#x2003;|&#x2003;|&#x2003;yC&#x2003;!=&#x2003;Last&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;SignificantCoeffY&#x2003;)&#x2003;)&#x2003;{</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;sig_coeff_flag[&#x2003;xC&#x2003;][&#x2003;yC&#x2003;]</entry><entry>ae(v)</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;remBinsPass1&#x2212;&#x2003;&#x2212;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;if(&#x2003;sig_coeff_flag</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;[&#x2003;xC&#x2003;][&#x2003;yC&#x2003;]&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;inferSbDcSig-</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;CoeffFlag&#x2003;=&#x2003;0</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;if(&#x2003;sig_coeff_flag</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;[&#x2003;xC&#x2003;][&#x2003;yC&#x2003;]&#x2003;)&#x2003;{</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;abs_level_gtx_flag[&#x2003;n&#x2003;][&#x2003;0&#x2003;]</entry><entry>ae(v)</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;remBinsPass1&#x2212;&#x2003;&#x2212;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;if(&#x2003;abs_level_gtx&#x2003;flag</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;[&#x2003;n&#x2003;][&#x2003;0&#x2003;]&#x2003;)&#x2003;{</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;par_level_flag[&#x2003;n&#x2003;]</entry><entry>ae(v)</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;remBinsPass1&#x2212;&#x2003;&#x2212;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;abs_level_gtx_</entry><entry>ae(v)</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;flag[&#x2003;n&#x2003;][&#x2003;1&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;remBinsPass1&#x2212;&#x2003;&#x2212;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;if(&#x2003;lastSigScanPosSb&#x2003;=&#x2003;=&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2212;1&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;lastSigScanPosSb&#x2003;=&#x2003;n</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;firstSigScanPosSb&#x2003;=&#x2003;n</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;AbsLevelPass1[&#x2003;xC&#x2003;][&#x2003;yC&#x2003;]&#x2003;=&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;sig_coeff_flag[&#x2003;xC&#x2003;][&#x2003;yC&#x2003;]&#x2003;+&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;par_level_flag[&#x2003;n&#x2003;]&#x2003;+</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;abs_level_gtx_</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;flag[&#x2003;n&#x2003;][&#x2003;0&#x2003;]&#x2003;+&#x2003;2&#x2003;*&#x2003;</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;abs_level_</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;gtx_flag[&#x2003;n&#x2003;][&#x2003;1&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;if(&#x2003;pic_dep_quant_</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;enabled_flag&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;QState&#x2003;=&#x2003;QStateTrans-</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;Table[&#x2003;QState&#x2003;][&#x2003;AbsLevel-</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;Pass1[&#x2003;xC&#x2003;][&#x2003;yC&#x2003;]&#x2003;&#x26;&#x2003;1&#x2003;]</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;if(&#x2003;remBinsPass1&#x2003;&#x3c;&#x2003;4&#x2003;)</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;firstPosModel&#x2003;=&#x2003;n&#x2003;&#x2212;&#x2003;1</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry/><entry>&#x2003;&#x2003;...</entry><entry/></row><row><entry/><entry>&#x2003;}</entry><entry/></row><row><entry/><entry>}</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0321" num="0298">In Table 9, xS and yS denote an x-coordinate position and a y-coordinate position in each CG unit inside the current transform block, and need to be converted into coordinates in sample units to check whether the transformation coefficient is positioned outside the top-left 16&#xd7;16 region. That is, xS and yS are converted to coordinates in sample units as in (xS&#x3c;&#x3c;log 2SbW) and (yS&#x3c;&#x3c;log 2SbH). Here, log 2SbW and log 2SbH respectively denote the base-2 logarithm values of the width and height of a corresponding CG, x-coordinates increase from left to right in the transform block, and y-coordinates increase from top to bottom. The coordinates of the top-left position of the transform block is (0, 0).</p><p id="p-0322" num="0299">As shown in Table 9, in scanning by a unit of a CG, when a non-zero transform coefficient exists inside each CG (when the value of coded_sub_block_flag[xS][yS] is 1) and the CG is identified to be positioned outside the top-left 16&#xd7;16 region of the transform block ((xS&#x3c;&#x3c;log 2SbW)&#x3e;15 yS&#x3c;&#x3c;log 2SbH)&#x3e;15)), the value of MtsZeroOutSigCoeffFlag is set to 0.</p><p id="p-0323" num="0300">As shown in Table 5, since the value of the variable MtsZeroOutSigCoeffFlag is initialized to 1, the value of MtsZeroOutSigCoeffFlag is maintained at 1 unless the value of MtsZeroOutSigCoeffFlag is set to 0. When the value of coded_sub_block_flag[xS][yS] for a CG to which the last non-zero transform coefficient belongs is inferred to be 1, the condition check part in Table 7 and the update of MtsZeroOutSigCoeffFlag (if ((LastSignificantCoeffX&#x3e;15&#x2225;LastSignificantCoeffY)&#x3e;15) &#x26;&#x26; cIdx==0) MtsZeroOutSigCoeffFlag=0) may be removed from Table 9.</p><p id="p-0324" num="0301">The following drawings are provided to describe specific examples of the present disclosure. Since specific terms for devices or specific terms for signals/messages/fields illustrated in the drawings are provided for illustration, technical features of the present disclosure are not limited to the specific terms used in the following drawings.</p><p id="p-0325" num="0302"><figref idref="DRAWINGS">FIG. <b>16</b></figref> is a flowchart illustrating an operation of a video decoding apparatus according to an embodiment of the present disclosure.</p><p id="p-0326" num="0303">Each process disclosed in <figref idref="DRAWINGS">FIG. <b>16</b></figref> is based on some of details described with reference to <figref idref="DRAWINGS">FIG. <b>4</b></figref> to <figref idref="DRAWINGS">FIG. <b>15</b></figref>. Therefore, a description of specific details overlapping those described with reference to <figref idref="DRAWINGS">FIG. <b>3</b></figref> to <figref idref="DRAWINGS">FIG. <b>15</b></figref> will be omitted or will be schematically made.</p><p id="p-0327" num="0304">The decoding apparatus <b>300</b> according to an embodiment may receive a bitstream including residual information and may derive residual information, for example, quantized transform coefficients, for a current block, that is, a transform block to be transformed, from the bistream (S<b>1610</b>).</p><p id="p-0328" num="0305">Specifically, the decoding apparatus <b>300</b> may decode information on quantized transform coefficients for a current block from the bitstream and may derive quantized transform coefficients for a target block based on the information on the quantized transform coefficients for the current block. Information on the quantized transform coefficients for the target block may be included in a sequence parameter set (SPS) or a slice header and may include at least one of information on whether an RST is applied, information on a reduced factor, information on a minimum transform size for applying an RST, information on a maximum transform size for applying an RST, an inverse RST size, and information on a transform index indicating any one of transform kernel matrices included in a transform set.</p><p id="p-0329" num="0306">The decoding apparatus <b>300</b> may derive the position of a last significant coefficient in the current block and transform coefficients for the current block based on the residual information (S<b>1620</b>). The decoding apparatus <b>300</b> may derive the transform coefficients by dequantizing the quantized transform coefficients the current block.</p><p id="p-0330" num="0307">The derived transform coefficients may be two-dimensionally arranged in the current block, and the decoding apparatus may derive information on non-zero data, that is, a non-zero significant coefficient, in the current block through this residual coding. That is, the decoding apparatus may identify last position information on the non-zero significant coefficient in the current block.</p><p id="p-0331" num="0308">The transform coefficients derived based on the residual information in S<b>1620</b> may be the dequantized transform coefficients as described above or may be the quantized transform coefficients. That is, the transform coefficients only need to be data for identifying the non-zero data in the current block and the position of the significant coefficient regardless of quantization.</p><p id="p-0332" num="0309">The decoding apparatus may derive modified transform coefficients by applying an LFNST to the transform coefficients or may not perform the LFNST.</p><p id="p-0333" num="0310">The decoding apparatus may derive residual samples by performing inverse primary transform of the transform coefficients or the modified transform coefficients. The decoding apparatus may use general DCT-2 as a transform kernel or may apply the foregoing MTS for the inverse primary transform.</p><p id="p-0334" num="0311">The MTS may be implicitly performed or may be performed based on explicit signaling of an MTS index.</p><p id="p-0335" num="0312">The decoding apparatus may check predetermined conditions to parse the MTS index. According to an example, the decoding apparatus may parse an MTS index based on the significant coefficient not being present in a second region other than a top-left first region of the current block (S<b>1630</b>).</p><p id="p-0336" num="0313">The MTS index may be parsed by deriving flag information indicating whether the significant coefficient exists in the second region, in which the flag information may be derived by determining whether the significant coefficient exists in the second region by a unit of a scan subblock of scanning a significant coefficient.</p><p id="p-0337" num="0314">The decoding apparatus may perform the inverse primary transform on transform coefficients in the top-left first region of the current block to be transformed. That is, the second region other than the top-left first region of the current block is zeroed out and thus includes no transform coefficient.</p><p id="p-0338" num="0315">According to an example, when the MTS is applied, the first region may be a top-left 16&#xd7;16 region of the current block, in which case the second region may be a region other than the top-left 16&#xd7;16 region.</p><p id="p-0339" num="0316">The scan subblock may be a 4&#xd7;4 block and may be scanned according to a reverse diagonal scan direction from the position of the last significant coefficient in the current block as shown in <figref idref="DRAWINGS">FIG. <b>15</b></figref>.</p><p id="p-0340" num="0317">To parse the MTS index after determining whether a significant coefficient exists in the zero-out region, the decoding apparatus may derive flag information indicating whether a significant coefficient exists in the second region and may parse the MTS index based on the flag information.</p><p id="p-0341" num="0318">The flag information may be a variable MtsZeroOutSigCoeffFlag, and whether a significant coefficient exists in the second region may be determined by the unit of the scan subblock of scanning the significant coefficient.</p><p id="p-0342" num="0319">When a flag indicating whether a significant coefficient exists in a scan subblock (coded_sub_block_flag or sb_coded_flag) illustrated in Table 9 is equal to a value of 1 and a significant coefficient existing in the scan subblock is positioned in the second region (((xS&#x3c;&#x3c;log 2SbW)&#x3e;15 (yS&#x3c;&#x3c;log 2SbH)&#x3e;15)), the variable MtsZeroOutSigCoeffFlag may indicate that the significant coefficient exists in the second region.</p><p id="p-0343" num="0320">Alternatively, the variable MtsZeroOutSigCoeffFlag may be derived by checking whether the 4&#xd7;4 scan subblock belongs to the first region whenever scanning the transform coefficients as in Table 8. That is, when a flag indicating whether a significant coefficient exists in a scan subblock (sig_coeff_flag) is equal to a value of 1 and a significant coefficient existing in the scan subblock is positioned in the second region (if((xC&#x3e;15&#x2225;yC&#x3e;15)), the variable MtsZeroOutSigCoeffFlag may indicate that the significant coefficient exists in the second region.</p><p id="p-0344" num="0321">Alternatively, when a flag indicating whether a significant coefficient exists in a scan subblock is equal to a value of 1 and the scan subblock is positioned in the second region, the variable MtsZeroOutSigCoeffFlag may indicate that a significant coefficient exists in the second region.</p><p id="p-0345" num="0322">The variable MtsZeroOutSigCoeffFlag may be initially set to 1, may be maintained as 1 when the significant coefficient is not positioned in the second region, and may be changed to 0 when the significant coefficient is positioned in the second region.</p><p id="p-0346" num="0323">In summary, the decoding apparatus may parse the MTS index based on the flag information indicating that no significant coefficient exists in the second region and when the value of the variable MtsZeroOutSigCoeffFlag, initially set to 1, is maintained, the MTS index may be parsed.</p><p id="p-0347" num="0324">The decoding apparatus may derive residual samples for the current block by applying a transform kernel derived based on the MTS index to transform coefficients in the first region (S<b>1640</b>).</p><p id="p-0348" num="0325">Subsequently, the decoding apparatus <b>300</b> may generate reconstructed samples based on the residual samples for the current block and predication samples for the current block.</p><p id="p-0349" num="0326">The following drawings are provided to describe specific examples of the present disclosure. Since specific terms for devices or specific terms for signals/messages/fields illustrated in the drawings are provided for illustration, technical features of the present disclosure are not limited to the specific terms used in the following drawings.</p><p id="p-0350" num="0327"><figref idref="DRAWINGS">FIG. <b>17</b></figref> is a flowchart illustrating an operation of a video encoding apparatus according to an embodiment of the present disclosure.</p><p id="p-0351" num="0328">Each process disclosed in <figref idref="DRAWINGS">FIG. <b>16</b></figref> is based on some of details described with reference to <figref idref="DRAWINGS">FIG. <b>4</b></figref> to <figref idref="DRAWINGS">FIG. <b>15</b></figref>. Therefore, a description of specific details overlapping those described with reference to <figref idref="DRAWINGS">FIG. <b>2</b></figref> and <figref idref="DRAWINGS">FIG. <b>4</b></figref> to <figref idref="DRAWINGS">FIG. <b>15</b></figref> will be omitted or will be schematically made.</p><p id="p-0352" num="0329">The encoding apparatus <b>100</b> according to an embodiment may derive prediction samples based on an intra prediction mode applied to a current block (S<b>1710</b>).</p><p id="p-0353" num="0330">The encoding apparatus <b>100</b> according to an embodiment may derive residual samples for the current block based on the prediction samples (S<b>1720</b>).</p><p id="p-0354" num="0331">The encoding apparatus <b>100</b> according to an embodiment may derive transform coefficients for the current block by applying an MIS to the residual samples (S<b>1730</b>).</p><p id="p-0355" num="0332">According to an example, the encoding apparatus may apply the foregoing MTS for the primary transform or may use general DCT-2 as a transform kernel.</p><p id="p-0356" num="0333">The MTS may be implicitly performed or may be performed based on explicit signaling of an MTS index.</p><p id="p-0357" num="0334">The encoding apparatus may determine whether to perform the MTS for the primary transform, and may derive the transform coefficients by applying DCT-8 or DST-7 to the residual samples when the MTS is determined to be performed.</p><p id="p-0358" num="0335">According to an example, when the MTS is applied for the primary transform, the encoding apparatus may zero out a second region other than a top-left first region of the current block (S<b>1740</b>).</p><p id="p-0359" num="0336">According to an example, the first region may be a top-left 16&#xd7;16 region of the current block, in which case the second region may be a region other than the top-left 16&#xd7;16 region.</p><p id="p-0360" num="0337">Due to this zero-out, it is possible to reduce the amount of computation required to perform the entire transform process and to reduce the amount of operation required for the entire transform process, thus reducing power consumption required to perform the transform. Further, latency entailed in the transform process may be reduced, thus increasing image coding efficiency.</p><p id="p-0361" num="0338">The encoding apparatus may derive modified transform coefficients by further applying an LFNST to the transform coefficients derived after the primary transform.</p><p id="p-0362" num="0339">The encoding apparatus may derive residual information based on the transform coefficients or the modified transform coefficients for the current block (S<b>1750</b>).</p><p id="p-0363" num="0340">That is, the encoding apparatus may generate the residual information including information on quantized transform coefficients. The residual information may include an information/syntax element related to the foregoing transform. The encoding apparatus may encode image/video information including the residual information and may output the encoded image/video information in the form of a bitstream.</p><p id="p-0364" num="0341">Specifically, the encoding apparatus <b>200</b> may generate the information on the quantized transform coefficients and may encode the generated information on the quantized transform coefficients.</p><p id="p-0365" num="0342">Also, the encoding apparatus may configure image information so that an MTS index indicating a transform kernel of the MTS is parsed based on whether the significant coefficient exists in the second region (S<b>1760</b>).</p><p id="p-0366" num="0343">Further, the encoding apparatus may construct image information to derive flag information indicating whether a significant coefficient exists in the second region by a unit of a scan subblock of scanning a significant coefficient.</p><p id="p-0367" num="0344">That is, the encoding apparatus may construct the image information so that the image information illustrated in Table 8 or Table 9 may be parsed in a decoding apparatus.</p><p id="p-0368" num="0345">According to an example, the scan subblock may be a 4&#xd7;4 block and may be scanned according to a reverse diagonal scan direction from the position of the last significant coefficient in the current block also in the decoding apparatus as shown in <figref idref="DRAWINGS">FIG. <b>15</b></figref>.</p><p id="p-0369" num="0346">The flag information may be a variable MtsZeroOutSigCoeffFlag, and whether a significant coefficient exists in the second region may be determined by the unit of the scan subblock of scanning the significant coefficient.</p><p id="p-0370" num="0347">When a flag indicating whether a significant coefficient exists in a scan subblock (coded_sub_block_flag) illustrated in Table 9 is equal to a value of 1 and a significant coefficient existing in the scan subblock is positioned in the second region (((xS&#x3c;&#x3c;log 2SbW)&#x3e;&#x3e;15&#x2225;(yS&#x3c;&#x3c;log 2SbH)&#x3e;15)), the variable MtsZeroOutSigCoeffFlag may indicate that the significant coefficient exists in the second region.</p><p id="p-0371" num="0348">Alternatively, the variable MtsZeroOutSigCoeffFlag may be derived by checking whether the 4&#xd7;4 scan subblock belongs to the first region whenever scanning the transform coefficients as in Table 8. That is, when a flag indicating whether a significant coefficient exists in a scan subblock (sig_coeff_flag) is equal to a value of 1 and a significant coefficient existing in the scan subblock is positioned in the second region (if((xC&#x3e;15&#x2225;yC&#x3e;15)), the variable MtsZeroOutSigCoeffFlag may indicate that the significant coefficient exists in the second region.</p><p id="p-0372" num="0349">Alternatively, when a flag indicating whether a significant coefficient exists in a scan subblock is equal to a value of 1 and the scan subblock is positioned in the second region, the variable MtsZeroOutSigCoeffFlag may indicate that a significant coefficient exists in the second region.</p><p id="p-0373" num="0350">The variable MtsZeroOutSigCoeffFlag may be initially set to 1, may be maintained as 1 when the significant coefficient is not positioned in the second region, and may be changed to 0 when the significant coefficient is positioned in the second region.</p><p id="p-0374" num="0351">The encoding apparatus may encode residual information derived based on the transform coefficients, and the MTS index based on flag information indicating that no significant coefficient exists in the second region and then may output them.</p><p id="p-0375" num="0352">In the present disclosure, at least one of quantization/dequantization and/or transform/inverse transform may be omitted. When quantization/dequantization is omitted, a quantized transform coefficient may be referred to as a transform coefficient. When transform/inverse transform is omitted, the transform coefficient may be referred to as a coefficient or a residual coefficient, or may still be referred to as a transform coefficient for consistency of expression.</p><p id="p-0376" num="0353">In addition, in the present disclosure, a quantized transform coefficient and a transform coefficient may be referred to as a transform coefficient and a scaled transform coefficient, respectively. In this case, residual information may include information on a transform coefficient(s), and the information on the transform coefficient(s) may be signaled through a residual coding syntax. Transform coefficients may be derived based on the residual information (or information on the transform coefficient(s)), and scaled transform coefficients may be derived through inverse transform (scaling) of the transform coefficients. Residual samples may be derived based on the inverse transform (transform) of the scaled transform coefficients. These details may also be applied/expressed in other parts of the present disclosure.</p><p id="p-0377" num="0354">In the above-described embodiments, the methods are explained on the basis of flowcharts by means of a series of steps or blocks, but the present disclosure is not limited to the order of steps, and a certain step may be performed in order or step different from that described above, or concurrently with another step. Further, it may be understood by a person having ordinary skill in the art that the steps shown in a flowchart are not exclusive, and that another step may be incorporated or one or more steps of the flowchart may be removed without affecting the scope of the present disclosure.</p><p id="p-0378" num="0355">The above-described methods according to the present disclosure may be implemented as a software form, and an encoding apparatus and/or decoding apparatus according to the disclosure may be included in a device for image processing, such as, a TV, a computer, a smartphone, a set-top box, a display device or the like.</p><p id="p-0379" num="0356">When embodiments in the present disclosure are embodied by software, the above-described methods may be embodied as modules (processes, functions or the like) to perform the above-described functions. The modules may be stored in a memory and may be executed by a processor. The memory may be inside or outside the processor and may be connected to the processor in various well-known manners. The processor may include an application-specific integrated circuit (ASIC), other chipset, logic circuit, and/or a data processing device. The memory may include a read-only memory (ROM), a random access memory (RAM), a flash memory, a memory card, a storage medium, and/or other storage device. That is, embodiments described in the present disclosure may be embodied and performed on a processor, a microprocessor, a controller or a chip. For example, function units shown in each drawing may be embodied and performed on a computer, a processor, a microprocessor, a controller or a chip.</p><p id="p-0380" num="0357">Further, the decoding apparatus and the encoding apparatus to which the present disclosure is applied, may be included in a multimedia broadcasting transceiver, a mobile communication terminal, a home cinema video device, a digital cinema video device, a surveillance camera, a video chat device, a real time communication device such as video communication, a mobile streaming device, a storage medium, a camcorder, a video on demand (VoD) service providing device, an over the top (OTT) video device, an Internet streaming service providing device, a three-dimensional (3D) video device, a video telephony video device, and a medical video device, and may be used to process a video signal or a data signal. For example, the over the top (OTT) video device may include a game console, a Blu-ray player, an Internet access TV, a Home theater system, a smartphone, a Tablet PC, a digital video recorder (DVR) and the like.</p><p id="p-0381" num="0358">In addition, the processing method to which the present disclosure is applied, may be produced in the form of a program executed by a computer, and be stored in a computer-readable recording medium. Multimedia data having a data structure according to the present disclosure may also be stored in a computer-readable recording medium. The computer-readable recording medium includes all kinds of storage devices and distributed storage devices in which computer-readable data are stored. The computer-readable recording medium may include, for example, a Blu-ray Disc (BD), a universal serial bus (USB), a ROM, a PROM, an EPROM, an EEPROM, a RAM, a CD-ROM, a magnetic tape, a floppy disk, and an optical data storage device. Further, the computer-readable recording medium includes media embodied in the form of a carrier wave (for example, transmission over the Internet). In addition, a bitstream generated by the encoding method may be stored in a computer-readable recording medium or transmitted through a wired or wireless communication network. Additionally, the embodiments of the present disclosure may be embodied as a computer program product by program codes, and the program codes may be executed on a computer by the embodiments of the present disclosure. The program codes may be stored on a computer-readable carrier.</p><p id="p-0382" num="0359"><figref idref="DRAWINGS">FIG. <b>18</b></figref> illustrates the structure of a content streaming system to which the present disclosure is applied.</p><p id="p-0383" num="0360">Further, the contents streaming system to which the present disclosure is applied may largely include an encoding server, a streaming server, a web server, a media storage, a user equipment, and a multimedia input device.</p><p id="p-0384" num="0361">The encoding server functions to compress to digital data the contents input from the multimedia input devices, such as the smart phone, the camera, the camcoder and the like, to generate a bitstream, and to transmit it to the streaming server. As another example, in a case where the multimedia input device, such as, the smart phone, the camera, the camcoder or the like, directly generates a bitstream, the encoding server may be omitted. The bitstream may be generated by an encoding method or a bitstream generation method to which the present disclosure is applied. And the streaming server may store the bitstream temporarily during a process to transmit or receive the bitstream.</p><p id="p-0385" num="0362">The streaming server transmits multimedia data to the user equipment on the basis of a user's request through the web server, which functions as an instrument that informs a user of what service there is. When the user requests a service which the user wants, the web server transfers the request to the streaming server, and the streaming server transmits multimedia data to the user. In this regard, the contents streaming system may include a separate control server, and in this case, the control server functions to control commands/responses between respective equipments in the content streaming system.</p><p id="p-0386" num="0363">The streaming server may receive contents from the media storage and/or the encoding server. For example, in a case the contents are received from the encoding server, the contents may be received in real time. In this case, the streaming server may store the bitstream for a predetermined period of time to provide the streaming service smoothly.</p><p id="p-0387" num="0364">For example, the user equipment may include a mobile phone, a smart phone, a laptop computer, a digital broadcasting terminal, a personal digital assistant (PDA), a portable multimedia player (PMP), a navigation, a slate PC, a tablet PC, an ultrabook, a wearable device (e.g., a watch-type terminal (smart watch), a glass-type terminal (smart glass), a head mounted display (HMD)), a digital TV, a desktop computer, a digital signage or the like. Each of servers in the contents streaming system may be operated as a distributed server, and in this case, data received by each server may be processed in distributed manner.</p><p id="p-0388" num="0365">Claims disclosed herein can be combined in a various way. For example, technical features of method claims of the present disclosure can be combined to be implemented or performed in an apparatus, and technical features of apparatus claims can be combined to be implemented or performed in a method. Further, technical features of method claims and apparatus claims can be combined to be implemented or performed in an apparatus, and technical features of method claims and apparatus claims can be combined to be implemented or performed in a method.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-math idrefs="MATH-US-00001" nb-file="US20230007264A1-20230105-M00001.NB"><img id="EMI-M00001" he="12.36mm" wi="76.20mm" file="US20230007264A1-20230105-M00001.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00002" nb-file="US20230007264A1-20230105-M00002.NB"><img id="EMI-M00002" he="12.36mm" wi="76.20mm" file="US20230007264A1-20230105-M00002.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00003" nb-file="US20230007264A1-20230105-M00003.NB"><img id="EMI-M00003" he="12.70mm" wi="76.20mm" file="US20230007264A1-20230105-M00003.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00004" nb-file="US20230007264A1-20230105-M00004.NB"><img id="EMI-M00004" he="19.73mm" wi="76.20mm" file="US20230007264A1-20230105-M00004.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. An image decoding method performed by a decoding apparatus, the method comprising:<claim-text>obtaining residual information from a bitstream;</claim-text><claim-text>deriving transform coefficients for a current block based on the residual information; and</claim-text><claim-text>deriving residual samples for the current block by applying an inverse primary transform to the transform coefficients based on a multiple transform selection (MTS) index;</claim-text><claim-text>wherein the deriving of the transform coefficient comprises:</claim-text><claim-text>deriving whether a significant coefficient is present in a scan subblock by scanning the scan subblock in a preset scan subblock unit according to an reverse diagonal scan order; and</claim-text><claim-text>deriving flag information indicating whether the significant coefficient is present in a second region based on (i) whether the significant coefficient is present the scan subblock, (ii) whether the scan subblock belongs to the second region other than a top-left 16&#xd7;16 region of the current block, and (iii) whether a color index of the current block is 0, and</claim-text><claim-text>the MTS index is parsed based on the flag information indicating that the significant coefficient is not present in the second region.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The image decoding method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the MTS index is inferred to 0 when the MTS index is not parsed.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The image decoding method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the deriving whether the significant coefficient is present in the scan subblock comprises parsing a flag indicating whether the significant coefficient is present in the scan subblock.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. (canceled)</claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The image decoding method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the flag information is initially set to 1, and<claim-text>wherein, when the significant coefficient is positioned in the second region, the flag information is changed to 0.</claim-text></claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The image decoding method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the scan subblock is a 4&#xd7;4 block, and<claim-text>wherein the scan subblock is scanned according to the reverse diagonal scan order from a last scan subblock including a last significant coefficient in the current block.</claim-text></claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. An image encoding method performed by an image encoding apparatus, the method comprising:<claim-text>deriving prediction samples for a current block;</claim-text><claim-text>deriving residual samples for the current block based on the prediction samples;</claim-text><claim-text>deriving transform coefficients for the current block by applying an primary transform to the residual samples;</claim-text><claim-text>deriving residual information based on the transform coefficient of a top-left 16&#xd7;16 region of the current block; and</claim-text><claim-text>constructing image information to parse a multiple transform selection (MTS) index indicating an primary transform kernel based on a significant coefficient being present in a second region other than the top-left 16&#xd7;16 region,</claim-text><claim-text>wherein the constructing of the image information comprise:</claim-text><claim-text>encoding a flag indicating whether the significant coefficient is present in a scan subblock by scanning the scan subblock in a preset scan subblock unit according to an reverse diagonal scan order; and</claim-text><claim-text>deriving flag information indicating whether the significant coefficient is present in a second region based on (i) whether the significant coefficient is present the scan subblock, (ii) whether the scan subblock belongs to the second region other than a top-left 16&#xd7;16 region of the current block, and (iii) whether a color index of the current block is 0, and</claim-text><claim-text>encoding the MTS index based on the flag information indicating that the significant coefficient is not present in the second region.</claim-text></claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The image encoding method of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the MTS index is inferred to 0 when the MTS index is not encoded.</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. (canceled)</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. (canceled)</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The image encoding method of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the flag information is initially set to 1, and<claim-text>wherein, when the significant coefficient is positioned in the second region, the flag information is changed to 0.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The image encoding method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the scan subblock is a 4&#xd7;4 block, and<claim-text>wherein the scan subblock is scanned according to the reverse diagonal scan order from a last scan subblock including a last significant coefficient in the current block.</claim-text></claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. A non-transitory computer-readable digital storage medium that stores a bitstream generated by a method, the method comprising:<claim-text>deriving prediction samples for a current block;</claim-text><claim-text>deriving residual samples for the current block based on the prediction samples;</claim-text><claim-text>deriving transform coefficients for the current block by applying an primary transform to the residual samples;</claim-text><claim-text>deriving residual information based on the transform coefficient of a top-left 16&#xd7;16 region of the current block; and</claim-text><claim-text>constructing image information to parse a multiple transform selection (MTS) index indicating an primary transform kernel based on a significant coefficient being present in a second region other than the top-left 16&#xd7;16 region,</claim-text><claim-text>wherein the constructing of the image information comprise:</claim-text><claim-text>encoding a flag indicating whether the significant coefficient is present in a scan subblock by scanning the scan subblock in a preset scan subblock unit according to an reverse diagonal scan order; and</claim-text><claim-text>deriving flag information indicating whether the significant coefficient is present in a second region based on (i) whether the significant coefficient is present the scan subblock, (ii) whether the scan subblock belongs to the second region other than a top-left 16&#xd7;16 region of the current block, and (iii) whether a color index of the current block is 0, and</claim-text><claim-text>encoding the MTS index based on the flag information indicating that the significant coefficient is not present in the second region.</claim-text></claim-text></claim></claims></us-patent-application>