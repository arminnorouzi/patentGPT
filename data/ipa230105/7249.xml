<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230007250A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230007250</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17931272</doc-number><date>20220912</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>119</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>597</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>119</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>597</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">POINT CLOUD CODING METHODS, ENCODER, AND DECODER</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>17702674</doc-number><date>20220323</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11483560</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17931272</doc-number></document-id></child-doc></relation></continuation><continuation><relation><parent-doc><document-id><country>US</country><doc-number>PCT/CN2019/109653</doc-number><date>20190930</date></document-id><parent-status>PENDING</parent-status></parent-doc><child-doc><document-id><country>US</country><doc-number>17702674</doc-number></document-id></child-doc></relation></continuation></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>GUANGDONG OPPO MOBILE TELECOMMUNICATIONS CORP., LTD.</orgname><address><city>Dongguan</city><country>CN</country></address></addressbook><residence><country>CN</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>ZHANG</last-name><first-name>WEI</first-name><address><city>Dongguan</city><country>CN</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>YANG</last-name><first-name>FUZHENG</first-name><address><city>Dongguan</city><country>CN</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>WAN</last-name><first-name>SHUAI</first-name><address><city>Dongguan</city><country>CN</country></address></addressbook></inventor><inventor sequence="03" designation="us-only"><addressbook><last-name>MA</last-name><first-name>YANZHUO</first-name><address><city>Dongguan</city><country>CN</country></address></addressbook></inventor><inventor sequence="04" designation="us-only"><addressbook><last-name>HUO</last-name><first-name>JUNYAN</first-name><address><city>Dongguan</city><country>CN</country></address></addressbook></inventor><inventor sequence="05" designation="us-only"><addressbook><last-name>SUN</last-name><first-name>ZEXING</first-name><address><city>Dongguan</city><country>CN</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">Point cloud coding methods, an encoder, and a decoder are provided. The method includes the following. Morton codes for a point cloud are obtained according to geometry information of the point cloud after geometry decoding is completed and the geometry information is reconstructed. The point cloud is determined as an input point cloud of an iteration. Morton codes for an input point cloud of an i-th iteration are right shifted by K bits according to a number of points in the input point cloud of the i-th iteration, where K is a positive integer. A point is selected from points with a same value of Morton codes after right shifted by K bits. An i-th level of detail (LOD) layer is formed with the point selected. Color information is decoded according to the LOD layer.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="170.01mm" wi="146.13mm" file="US20230007250A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="180.85mm" wi="148.17mm" file="US20230007250A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="138.68mm" wi="149.86mm" file="US20230007250A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="149.01mm" wi="151.21mm" file="US20230007250A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="203.12mm" wi="152.06mm" file="US20230007250A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="159.85mm" wi="81.70mm" file="US20230007250A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="159.85mm" wi="81.70mm" file="US20230007250A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="160.78mm" wi="78.06mm" file="US20230007250A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="169.84mm" wi="152.06mm" file="US20230007250A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="111.34mm" wi="98.47mm" file="US20230007250A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATION(S)</heading><p id="p-0002" num="0001">This application is a continuation of U.S. patent application Ser. No. 17/702,674, filed Mar. 23, 2022, which claims priority to International Application No. PCT/CN2019/109653, filed Sep. 30, 2019, the entire disclosures of which are hereby incorporated by reference.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">TECHNICAL FIELD</heading><p id="p-0003" num="0002">Implementations of this application relates to level of detail (LOD) partition technology in geometry-based point cloud compression (G-PCC) coding, and in particular to point cloud coding methods, an encoder, and a decoder.</p><heading id="h-0003" level="1">BACKGROUND</heading><p id="p-0004" num="0003">In an encoder framework of geometry-based point cloud compression (G-PCC), geometry information of a point cloud and attribute information corresponding to each point in the point cloud are encoded separately. Geometry encoding is first performed. After geometry encoding is completed, geometry information is reconstructed. Currently, attribute encoding is mainly for color information. In attribute encoding, the color information is first transformed from a RGB color space to a YUV color space. Thereafter, the reconstructed geometry information is used to recolor the point cloud, so that un-encoded attribute information can correspond to the reconstructed geometry information. During encoding of the color information, there are mainly two transform methods. One is level of detail (LOD) partition-based lifting transform. At present, the LOD partition mainly includes distance-based LOD partition and fixed sampling rate-based LOD partition. The other is regional adaptive hierarchical transform (RAHT) which is performed directly on the attribute information.</p><p id="p-0005" num="0004">Due to high computational complexity of the distance-based LOD partition for the point cloud, in order to reduce computational complexity, a method of searching within a range of Morton code corresponding to a current point is used on the basis of the distance-based LOD partition. However, in video coding, after the LOD partition is completed, a partition structure of LODs is required to predict an attribute of a neighbor node. LOD layers obtained by the existing LOD partition method may result in a low prediction accuracy for neighbor nodes.</p><heading id="h-0004" level="1">SUMMARY</heading><p id="p-0006" num="0005">Implementations of this application provide point cloud coding methods, an encoder and a decoder.</p><p id="p-0007" num="0006">In a first aspect, implementations of this application provide a point cloud decoding method which is applied for a decoder. The method includes the following.</p><p id="p-0008" num="0007">Morton codes for a point cloud are obtained according to geometry information of the point cloud after geometry decoding is completed and the geometry information is reconstructed. The point cloud is determined as an input point cloud of an iteration. Morton codes for an input point cloud of an i-th iteration are right shifted by K bits according to a number of points in the input point cloud of the i-th iteration, where K is a positive integer. A point is selected from points with a same value of Morton codes after right shifted by K bits. An i-th level of detail (LOD) layer is formed with the point selected. Color information is decoded according to the LOD layer.</p><p id="p-0009" num="0008">In a second aspect, implementations of this application provide a point cloud encoding method which is applied for an encoder. The method includes the following.</p><p id="p-0010" num="0009">Morton codes for a point cloud are obtained according to geometry information of the point cloud after geometry encoding is completed and the geometry information is reconstructed. The point cloud is determined as an input point cloud of an iteration. Morton codes for an input point cloud of an i-th iteration are right shifted by K bits according to a number of points in the input point cloud of the i-th iteration, where K is a positive integer. A point is selected from points with a same value of Morton codes after right shifted by K bits. An i-th level of detail (LOD) layer is formed with the point selected. Color information is encoded according to the LOD layer.</p><p id="p-0011" num="0010">In a third aspect, implementations of this application provide an encoder. The encoder includes a processor and a memory storing a computer program which, when executed by the processor, causes the processor to execute the point cloud decoding method of the first aspect.</p><p id="p-0012" num="0011">In a fourth aspect, implementations of this application provide a decoder. The decoder includes a processor and a memory storing a computer program which, when executed by the processor, causes the processor to execute the point cloud encoding method of the second aspect.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram of a process of geometry-based point cloud compression (G-PCC) encoding.</p><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a schematic diagram of a process of distance-based level of detail (LOD) partition.</p><p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a schematic diagram of a process of Morton order-based LOD partition.</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. <b>4</b>A</figref> is a schematic flowchart of an optional partition method provided in implementations of this application.</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>4</b>B</figref> is a schematic flowchart of a point cloud decoding method provided in implementations of this application.</p><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>4</b>C</figref> is a schematic flowchart of a point cloud encoding method provided in implementations of this application.</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a schematic flowchart of an example of an optional partition method provided in implementations of this application.</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a schematic structural diagram of an optional encoder provided in implementations of this application.</p><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a schematic structural diagram of an optional decoder provided in implementations of this application.</p><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a schematic structural diagram of another optional encoder provided in implementations of this application.</p><p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a schematic structural diagram of another optional decoder provided in implementations of this application.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0006" level="1">DETAILED DESCRIPTION</heading><p id="p-0024" num="0023">Technical solutions in implementations of this application will be clearly and completely described below with reference to accompanying drawings in the implementations of this application. It should be understood that the specific implementations described herein are only used to explain the related application, but not to limit the application. In addition, it should be noted that, for the convenience of description, only the parts related to the relevant application are illustrated in the drawings.</p><p id="p-0025" num="0024">In implementations of this application, in an encoder framework of geometry-based point cloud compression (G-PCC) of point cloud, after a point cloud of an input three-dimensional image model is partitioned into slices, each slice is encoded independently.</p><p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram of a process of G-PCC encoding. As illustrated in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the process is applied to a point cloud encoder. For point cloud data to-be-encoded, through slice partition, the point cloud data is first partitioned into multiple slices. In each slice, geometry information of the point cloud and attribute information corresponding to each point in the point cloud are encoded separately. In geometry encoding, coordinate transform is performed on the geometry information so that the whole point cloud is contained in a bounding box. Then quantification is performed, which mainly plays a role of scaling. Due to the rounding of quantification, the geometry information of part of the point cloud is the same. Then whether to remove duplicate points is decided based on parameters. The process of quantifying and removing the duplicate points is also called voxelization. Thereafter, octree partition is performed on the bounding box. During octree-based encoding of the geometry information, the bounding box is equally partitioned into eight sub-cubes, and non-empty (including points in the point cloud) sub-cubes continue to be partitioned into eight equal parts until leaf nodes obtained through partition are 1&#xd7;1&#xd7;1 unit cubes. Arithmetic coding is performed on points in the leaf nodes to generate a binary geometry bitstream, that is, geometry code stream. During encoding of the geometry information based on triangle soup (trisoup), octree partition is also performed first. Different from the octree-based encoding of the geometry information, the trisoup does not need to partition the point cloud step by step into unit cubes each with an edge length of 1&#xd7;1&#xd7;1, but stops partition when blocks each with an edge length of W are obtained. Based on a surface formed based on distribution of a point cloud in each block, at most twelve vertexes generated by both the surface and twelve edges of the block are obtained. Arithmetic coding is performed on the vertexes (surface fitting based on vertexes), to generate a binary geometry bitstream, that is, geometry code stream. The vertexes are also used in implementation of geometry reconstruction and reconstructed geometry information is used in attribute coding of the point cloud.</p><p id="p-0027" num="0026">During attribute coding, after the geometry coding is completed and the geometry information is reconstructed, color transform is performed, that is, color information (i.e., the attribute information) is transformed from a RGB color space to a YUV color space. Thereafter, the reconstructed geometry information is used to recolor the point cloud, so that un-encoded attribute information can correspond to the reconstructed geometry information. During encoding of the color information, there are mainly two transform methods. One is distance-based lifting transform which relies on level of detail (LOD) partition. The other is regional adaptive hierarchical transform (RAHT). Both methods transform the color information from a spatial domain to a frequency domain, obtain high-frequency coefficients and low-frequency coefficients through transform, and finally quantize the coefficients (i.e., quantized coefficients). At last, geometry encoded data after octree partition and surface fitting and attribute encoded data after quantized coefficient processing are slice-synthesized, and vertex coordinates of each block are encoded in turn (that is, arithmetic coding), to generate a binary attribute bitstream, that is, attribute code stream.</p><p id="p-0028" num="0027">In related art, a distance-based LOD partition method is proposed for Category3 point cloud in attribute transform. The distance-based LOD partition method is applied to a TMC3V0 encoder and used in TMC13 attribute lifting transform. The distance-based method for LOD partition is also added in TMC13 attribute predicting transform. That is, LOD partition is applied in both point cloud attribute predicting transform and lifting transform.</p><p id="p-0029" num="0028">Specifically, the distance-based LOD partition is implemented as follows.</p><p id="p-0030" num="0029">In the LOD partition, an input point cloud is partitioned into different refinement levels R<sub>l </sub>by a set of defined distance thresholds, where 1=0, . . . , L&#x2212;1. That is, points in the point cloud is partitioned into different sets R<sub>l</sub>. The distance thresholds di need to satisfy the following two conditions:</p><p id="p-0031" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>d</i><sub>l</sub><i>&#x3c;d</i><sub>l-1</sub>&#x2003;&#x2003;(1)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0032" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>d</i><sub>L-1</sub>&#x2003;&#x2003;(2)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0033" num="0030">Specifically, the process of LOD partition is after the geometry reconstruction of the point cloud. At this time, the geometry coordinate information of the point cloud is known. The process of LOD partition is applied at both the encoder side and the decoder side for the point cloud. The process proceeds as follows:</p><p id="p-0034" num="0031">1) First, all the points in the point cloud are placed in a &#x201c;non-visited&#x201d; point set and a &#x201c;visited&#x201d; point set V is initialized as empty.</p><p id="p-0035" num="0032">2) The algorithm partitions LOD layers by iteration. At an iteration 1, a corresponding refinement level R<sub>l </sub>is generated as follows:</p><p id="p-0036" num="0033">a. The algorithm traverses all the points by iteration.</p><p id="p-0037" num="0034">b. If the current point has been traversed, then it is ignored.</p><p id="p-0038" num="0035">c. Otherwise, a distance from the current point to each point in the set V is computed respectively, and a minimum distance is denoted as D, where at the first iteration, the first point in the point cloud is added in the set V.</p><p id="p-0039" num="0036">d. If the distance D is greater than or equal to the threshold di, then the point is added to the refinement level R<sub>l </sub>and the set V.</p><p id="p-0040" num="0037">e. c-d are repeated until all the points are traversed.</p><p id="p-0041" num="0038">3) The l-th LOD set, that is, LOD<sub>l </sub>is obtained by taking the union of points in the refinement levels R<sub>0</sub>, R<sub>1</sub>, . . . R<sub>l</sub>.</p><p id="p-0042" num="0039">4) This process is iterated until all the LOD layers are generated or until all the points have been traversed.</p><p id="p-0043" num="0040"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a schematic diagram of a process of distance-based LOD partition. As illustrated in <figref idref="DRAWINGS">FIG. <b>2</b></figref>, a current point cloud to-be-partitioned includes points P0, P1, P2, P3, P4, P5, P6, P7, P8, and P9, where an original point cloud order is: P0, P1, P2, P3, P4, P5, P6, P7, P8, and P9. LOD0 obtained by the distance-based method for LOD partition includes P4, P5, P0, and P1, LOD1 includes P4, P5, P0, P1, P3, P2, and P6, and LOD2 includes P4, P5, P0, P1, P3, P2, P6, P7, P8, and P9.</p><p id="p-0044" num="0041">In related art, a scheme for reducing computational complexity of LOD generation is also proposed, which mainly partitions LODs based on Morton order. Morton code realizes conversion of one-dimension and two-dimension (or multi-dimension), which produces a number by interleaving storage of the bits of two numbers. This scheme has a significantly reduced computational complexity compared to the original scheme which searching for all points to partition LODs. This scheme mainly includes the following steps.</p><p id="p-0045" num="0042">First, assume variable P<sub>i </sub>and M<sub>i</sub>, where P<sub>i </sub>represents a point in an input point cloud, i=1, . . . , N, and M<sub>i </sub>represents a Morton code associated with each point, i=1, . . . , N. Specifically, the Morton code is computed as follows. For each point, three-dimensional (3D) coordinate components x, y, z are expressed using a d-bits binary number as follows:</p><p id="p-0046" num="0000"><maths id="MATH-US-00001" num="00001"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mi>x</mi>     <mo>=</mo>     <mrow>      <munderover>       <mo>&#x2211;</mo>       <mrow>        <mi>l</mi>        <mo>=</mo>        <mn>1</mn>       </mrow>       <mi>d</mi>      </munderover>      <mrow>       <msup>        <mn>2</mn>        <mrow>         <mi>d</mi>         <mo>-</mo>         <mi>l</mi>        </mrow>       </msup>       <mo>&#xb7;</mo>       <msub>        <mi>x</mi>        <mi>l</mi>       </msub>      </mrow>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mn>3</mn>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths><maths id="MATH-US-00001-2" num="00001.2"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mi>y</mi>     <mo>=</mo>     <mrow>      <munderover>       <mo>&#x2211;</mo>       <mrow>        <mi>l</mi>        <mo>=</mo>        <mn>1</mn>       </mrow>       <mi>d</mi>      </munderover>      <mrow>       <msup>        <mn>2</mn>        <mrow>         <mi>d</mi>         <mo>-</mo>         <mi>l</mi>        </mrow>       </msup>       <mo>&#xb7;</mo>       <msub>        <mi>y</mi>        <mi>l</mi>       </msub>      </mrow>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mn>4</mn>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths><maths id="MATH-US-00001-3" num="00001.3"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mi>z</mi>     <mo>=</mo>     <mrow>      <munderover>       <mo>&#x2211;</mo>       <mrow>        <mi>l</mi>        <mo>=</mo>        <mn>1</mn>       </mrow>       <mi>d</mi>      </munderover>      <mrow>       <msup>        <mn>2</mn>        <mrow>         <mi>d</mi>         <mo>-</mo>         <mi>l</mi>        </mrow>       </msup>       <mo>&#xb7;</mo>       <msub>        <mi>z</mi>        <mi>l</mi>       </msub>      </mrow>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mn>5</mn>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0047" num="0000">Where x<sub>l</sub>, y<sub>l</sub>, z<sub>l </sub>&#x2208;{0,1}, and x<sub>l</sub>, y<sub>l</sub>, z<sub>l </sub>are corresponding binary values from the most significant bits (l=1) to the least significant bits (l=d) of x, y, z. The Morton code M is obtained by interleaving x<sub>l</sub>, y<sub>l</sub>, z<sub>l </sub>from the most significant bits to the least significant bits for x, y, z. M is computed using the following equation:</p><p id="p-0048" num="0000"><maths id="MATH-US-00002" num="00002"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mi>M</mi>     <mo>=</mo>     <mrow>      <mrow>       <munderover>        <mo>&#x2211;</mo>        <mrow>         <mi>l</mi>         <mo>=</mo>         <mn>1</mn>        </mrow>        <mi>d</mi>       </munderover>       <mrow>        <msup>         <mn>2</mn>         <mrow>          <mn>3</mn>          <mo>&#x2062;</mo>          <mrow>           <mo>(</mo>           <mrow>            <mi>d</mi>            <mo>-</mo>            <mi>l</mi>           </mrow>           <mo>)</mo>          </mrow>         </mrow>        </msup>        <mo>&#xb7;</mo>        <mrow>         <mo>(</mo>         <mrow>          <mrow>           <mn>4</mn>           <mo>&#x2062;</mo>           <msub>            <mi>x</mi>            <mi>l</mi>           </msub>          </mrow>          <mtext>&#x205f;</mtext>          <mo>+</mo>          <mrow>           <mn>2</mn>           <mo>&#x2062;</mo>           <msub>            <mi>y</mi>            <mi>l</mi>           </msub>          </mrow>          <mtext>&#x205f;</mtext>          <mo>+</mo>          <msub>           <mi>z</mi>           <mi>l</mi>          </msub>         </mrow>         <mo>)</mo>        </mrow>       </mrow>      </mrow>      <mo>=</mo>      <mrow>       <munderover>        <mo>&#x2211;</mo>        <mrow>         <msup>          <mi>l</mi>          <mo>'</mo>         </msup>         <mo>=</mo>         <mn>1</mn>        </mrow>        <mrow>         <mn>3</mn>         <mo>&#x2062;</mo>         <mi>d</mi>        </mrow>       </munderover>       <mrow>        <msup>         <mn>2</mn>         <mrow>          <mrow>           <mn>3</mn>           <mo>&#x2062;</mo>           <mi>d</mi>          </mrow>          <mo>-</mo>          <msup>           <mi>l</mi>           <mo>'</mo>          </msup>         </mrow>        </msup>        <mo>&#xb7;</mo>        <msub>         <mi>m</mi>         <msup>          <mi>l</mi>          <mo>'</mo>         </msup>        </msub>       </mrow>      </mrow>     </mrow>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mn>6</mn>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0049" num="0000">Where m<sub>{dot over (i)}</sub>&#x2208;{0,1} are the values from the most significant bit ({dot over (l)}&#x2032;=1) to the least significant bit ({dot over (l)}=3d) of M. After the Morton code M of each point in the point cloud is obtained, the points in the point cloud are ranked in an ascending order of Morton codes.</p><p id="p-0050" num="0043">D0 (representing a threshold of an initial distance) and p (representing a distance threshold ratio in partition of adjacent LOD layers) are user-defined initial parameters respectively, and &#x3c1;&#x3e;1. Let I be indexes of all points in the point cloud. At the k-th iteration, a closest neighbor of a point in LOD<sub>k</sub>, that is, a point closest to the point in LOD<sub>k</sub>, will be searched from LOD<sub>0 </sub>layer to LOD<sub>k-1 </sub>layer. Specifically, the algorithm proceeds as follows:</p><p id="p-0051" num="0044">1) First, initial a partition distance threshold D=D<sub>0</sub>;</p><p id="p-0052" num="0045">2) At the k-th iteration, where k=0,1 . . . N&#x2212;1 (N is the total number of layers in LOD partition), L(k) stores points belong to the k-th LOD layer, and O(k) stores a point set with higher refinement level than LOD<sub>k</sub>, where L(k) and O(k) are computed as follows:</p><p id="p-0053" num="0046">a. First, O(k) and L(k) are initialized as empty sets;</p><p id="p-0054" num="0047">b. At each iteration, points are traversed in order of point indexes stored in I. Geometric distances from a current point to all points within a certain range in the set O(k) are computed during each traversal. Based on a Morton code corresponding to the current point in I, search in the set O(k) for the first point with an index that is greater than the Morton code corresponding to the current point, and then search in a range SR1 of the index (SR1 represents a search range based on Morton code, which is generally 8, 16, or 64). If a point whose distance from the current point is smaller than the threshold di is searched out in the range, the current point is added to the set L(k). Otherwise, the current point is added to the set O(k);</p><p id="p-0055" num="0048">3) At each iteration, the sets L(k) and O(k) are computed respectively, and points in O(k) will be used for predicting points in L(k). Let R(k)=L(k)\L(k&#x2212;1), that is, R(k) represents a point set of differences between sets of LOD<sub>k-1 </sub>and LOD<sub>k</sub>. For a point in R(k), h nearest predicting neighbors (h is set to 3 currently) will be searched in O(k). The nearest neighbors are searched as follows:</p><p id="p-0056" num="0049">a. For point P<sub>i </sub>in R(k), let M<sub>i </sub>be the Morton code corresponding to the point;</p><p id="p-0057" num="0050">b. Search in O(k) for the first point index j which is greater than the Morton code M<sub>i </sub>of current point P<sub>i</sub>;</p><p id="p-0058" num="0051">c. Based on the index j, search nearest neighbor nodes of current point P<sub>i </sub>in a search range [j&#x2212;SR2, j+SR2] in O(k), where SR2 represents a search range which is generally 8/16/32/64.</p><p id="p-0059" num="0052">4) This process is iterated until all points in I are traversed.</p><p id="p-0060" num="0053"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a schematic diagram of a process of Morton order-based LOD partition. As illustrated in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, a point cloud to-be-partitioned includes points P0, P1, P2, P3, P4, P5, P6, P7, P8, and P9, where an original point cloud order is P0, P1, P2, P3, P4, P5, P6, P7, P8, and P9. The points listed in ascending Morton order are: P4, P1, P9, P5, P0, P6, P8, P2, P7, and P3. LOD0 obtained by the above Morton order-based LOD partition method includes P4, P5, P0, and P1, LOD1 includes P4, P5, P0, P1, P3, P2, and P6, and LOD2 includes P4, P5, P0, P1, P3, P2, P6, P7, P8, and P9.</p><p id="p-0061" num="0054">The distance-based LOD partition method searches within a range of the Morton code corresponding to the current point, calculates spatial geometric distances from points in the range to the current point, and comparing the distances with a threshold. Until the distances of all points are greater than the threshold, the current point is added to the current LOD layer. Otherwise, the current point is left to the next layer for partition. The test data obtained through testing shows that the time used by the distance-based LOD partition method occupies about 70%-80% of the total coding time. Obviously, the computational complexity is high.</p><p id="p-0062" num="0055">In addition, before the point cloud attribute predicting and lifting transform, the point cloud is partitioned into LODs based on distance. Since there is a great correlation between attributes of adjacent points in the space, the LOD-based structure can be used to predict the attributes of adjacent nodes, so as to remove attribute redundancy between adjacent points. However, since different point clouds have different spatial distributions, the densities of different point clouds are different. Therefore, in the LOD partition process based on distance in the related art, the neighbor points obtained by searching based on uniform distribution of the point cloud (equivalent to the distance thresholds for partition are the same) are not accurate enough, resulting in large prediction residuals and low coding efficiency.</p><p id="p-0063" num="0056">Duce to the high computational complexity of distance-based LOD partition of point clouds, in order to reduce the computational complexity, the method of searching within a range of Morton code corresponding to the current point is used on a basic of distance-based LOD partition. However, in video coding, after the LOD partition is completed, the LOD partition structure is required to predict attributes of neighbor nodes. Since different point clouds have different spatial distributions, the densities of different point clouds are different. Therefore, the LOD partition structure obtained through the partition method cannot accurately predict neighbor nodes, resulting in large prediction residuals and low coding efficiency. As can be seen, the LOD layers obtained through the current LOD partition method lead to a low prediction accuracy of neighbor nodes.</p><p id="p-0064" num="0057">In order to improve the coding efficiency, prediction accuracy of neighbor nodes needs to be improved. In order to improve the prediction accuracy of neighbor nodes, a partition method is provided in implementations of this application. <figref idref="DRAWINGS">FIG. <b>4</b>A</figref> is a schematic flowchart of an optional partition method provided in implementations of this application. As illustrated in <figref idref="DRAWINGS">FIG. <b>4</b>A</figref>, the method can be applied to an encoder or a decoder. The partition method includes the following.</p><p id="p-0065" num="0058">At S<b>401</b>, a point cloud to-be-partitioned is obtained and Morton codes for the point cloud to-be-partitioned is calculated.</p><p id="p-0066" num="0059">The partition method provided in implementations of this application improves the generation process of LODs in lifting and predicting attribute transform and applies to the encoder and the decoder. The method partitions the LOD structure using this improved technology before lifting or predicting transform. This method applies in the block of generating LOD in <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0067" num="0060">Here, after the point cloud to-be-partitioned is obtained, the Morton codes for the point cloud to-be-partitioned is first calculated. In subsequent iterative calculation, spatial position relationship between points can be known with the Morton codes, which facilitates to predict neighbor nodes after partition of LOD layers.</p><p id="p-0068" num="0061">At S<b>402</b>, the point cloud to-be-partitioned is determined as an input point cloud of a first iteration.</p><p id="p-0069" num="0062">Specifically, in order to partition the point cloud to-be-partitioned into LOD layers, iteration is applied herein for partition. First, the point cloud to-be-partitioned is obtained, which includes at least two points, such as 10 points. The point cloud to-be-partitioned is determined as the input point cloud of the first iteration.</p><p id="p-0070" num="0063">In case that there are a large number of points in the point cloud to-be-partitioned, in order to better and quickly perform LOD partition on the point cloud to-be-partitioned, in one optional implementation, the method may include the following before S<b>402</b>.</p><p id="p-0071" num="0064">The Morton codes for the point cloud to-be-partitioned are shifted right by N bits and points with a same value of Morton codes after right shifted by N bits are grouped into a point cloud group, where N is a positive integer. Each point cloud group is determined as the input point cloud of the first iteration respectively.</p><p id="p-0072" num="0065">That is, when the number of points in the point cloud to-be-partitioned is relatively large, the point cloud to-be-partitioned is not directly used as the input point cloud of the first iteration. Instead, the Morton codes for the point cloud to-be-partitioned is first calculated and then right shifted by N bits. In this way, the points with the same value of Morton codes after right shifted by N bits are adjacent spatially. Therefore, the points with the same value of Morton codes after right shifted by N bits are grouped into a point cloud group and each point cloud group is determined as the input point cloud of the first iteration respectively. As such, the point cloud to-be-partitioned is divided into groups and each point cloud group is used as the input point cloud of the first iteration respectively for iterative calculation. Finally, LOD layers after partition of each point cloud group are obtained, such that LOD layers after partition of the point cloud to-be-partitioned are obtained.</p><p id="p-0073" num="0066">At S, at an i-th iteration, whether a number of points in an input point cloud of the i-th iteration is equal to 0 is determined.</p><p id="p-0074" num="0067">In implementations of this application, iteration times are indexed with i, where i is a positive integer with an initial value equal to 1.</p><p id="p-0075" num="0068">At S<b>403</b>, at each iteration, whether the number of points in the input point cloud of each iteration is equal to 0 is first determined. That is, whether the point cloud to-be-partitioned is all traversed through iteration is determined. The iteration process ends if the traversals are completed. If the traversals are not completed, the iteration process proceeds to partition the point cloud to-be-partitioned into LOD layers.</p><p id="p-0076" num="0069">At S, Morton codes for the input point cloud of the i-th iteration are shifted right by K bits based on a determination that the number of points in the input point cloud of the i-th iteration is unequal to 0.</p><p id="p-0077" num="0070">With the determination at S<b>403</b>, when the number of points in the input point cloud of the i-th iteration is unequal to 0, which indicates that the previous iteration has not traversed all the points, the i-th iteration needs to proceed. Specifically, the points can be ranked in an ascending order of Morton codes so as to better obtain spatial relationships between the points through the Morton codes.</p><p id="p-0078" num="0071">K is a positive integer. The value of K herein may be a fixed value obtained through training, or may be a value obtained by any of the following methods, which is not specifically limited in implementations of the this application.</p><p id="p-0079" num="0072">In order to determine the value of K, in a possible implementation, the method may further include the following before S<b>404</b>.</p><p id="p-0080" num="0073">The value of K is determined according to a distribution of the point cloud to-be-partitioned.</p><p id="p-0081" num="0074">Specifically, the value of K is determined according to the distribution of the point cloud to-be-partitioned. As such, the Morton codes are right shifted by K bit at each iteration, so that the spatial distribution of the point cloud is considered in right-shifting of the Morton codes, which can achieve a better prediction effect.</p><p id="p-0082" num="0075">In order to determine the value of K, in a possible implementation, when i is greater than or equal to a first preset threshold, the method may further include the following before S<b>404</b>.</p><p id="p-0083" num="0076">The value of K is determined according to a number of points in the input point cloud of the i-th iteration and a distribution of the input point cloud of the i-th iteration.</p><p id="p-0084" num="0077">Since a part of point cloud will be partitioned into a corresponding LOD layer at each iteration, as the number of iterations increases, the number of remaining points decreases, and the distribution of the input point cloud of each iteration is changing. In order to achieve a better prediction effect, the value of K of each iteration can be determined according to the number of points in the input point cloud of each iteration and the distribution of the input point cloud of each iteration. In this way, for the number of bits of right-shifting of the Morton codes at each iteration, the number of points and the spatial distribution of the point cloud are considered, which can achieve a better prediction effect.</p><p id="p-0085" num="0078">At S<b>405</b>, a point is selected from points with a same value of Morton codes after right shifted by K bits.</p><p id="p-0086" num="0079">After the Morton codes are right shifted by K bits, in order to partition into LOD layers, the points with the same value of Morton codes after right shifted by K bits are found, such that at least one group of points with the same value of Morton codes after right shifted by K bits is obtained. Then a point is selected from points with the same value of Morton codes after right shifted by K bits. Any point or a specified point may be selected, which is not specifically limited in implementations of this application.</p><p id="p-0087" num="0080">In order to obtain partitioned LOD layers to improve prediction accuracy of neighbor nodes, in an optional implementation, S<b>405</b> may include the following.</p><p id="p-0088" num="0081">Points in the input point cloud of the i-th iteration are ranked in an ascending order of Morton codes for the input point cloud of the i-th iteration. A point ranked first is selected from the points with the same value of Morton codes after right shifted by K bits.</p><p id="p-0089" num="0082">The points are ranked in an ascending order of Morton codes and the points with the same value of Morton codes after right shifted by K bits are found, such that at least one group of points with the same value of Morton codes after right shifted by K bits is obtained. Thereafter, the first point is selected from each group, where the first point is the point ranked first in an original point cloud order among the points with the same value of Morton codes after right shifted by K bits.</p><p id="p-0090" num="0083">In order to obtain partitioned LOD layers to improve prediction accuracy of neighbor nodes, in an optional implementation, S<b>405</b> may include the following.</p><p id="p-0091" num="0084">A center of mass of the points with the same value of Morton codes after right shifted by K bits is determined. From the points with the same value of Morton codes after right shifted by K bits, a point closest to the center of mass is determined as the point selected.</p><p id="p-0092" num="0085">Specifically, the center of mass of the points with the same value of Morton codes after right shifted by K bits is first determined, where the center of mass is calculated according to 3D coordinates of each point in the input point cloud of this iteration. After the center of mass is obtained, the point closest to the center of mass is calculated from the points with the same value of Morton codes after right shifted by K bits, and the point is selected.</p><p id="p-0093" num="0086">In order to obtain partitioned LOD layers to improve prediction accuracy of neighbor nodes, in addition to selecting the point through S<b>405</b>, in an optional implementation, the method may further include the following after S<b>404</b> and before S<b>406</b>.</p><p id="p-0094" num="0087">A corresponding selection number is determined according to a number of points with the same value of Morton codes after right shifted by K bits. From the points with the same value of Morton codes after right shifted by K bits, the selection number of points are selected according to the corresponding selection number.</p><p id="p-0095" num="0088">Specifically, more than one point can be selected from the points with the same value of Morton codes after right shifted by K bits. The corresponding selection number can be first determined according to the number of points with the same value of Morton codes after right shifted by K bits. For example, the number of points with the same value of Morton codes after right shifted by K bits may be 10, 8, 6, 4, etc. The corresponding selection number can be determined according to the number of points with the same value of Morton codes. For instance, if the number of points with the same value of Morton codes after right shifted by K bits is 10, the corresponding selection number may be 5. If the number of points with the same value of Morton codes after right shifted by K bits is 8, the corresponding selection number may be 4. If the number of points with the same value of Morton codes after right shifted by K bits is 6, the corresponding selection number may be 3. If the number of points with the same value of Morton codes after right shifted by K bits is 4, the corresponding selection number may be 2. That is, the corresponding selection number can be determined according to a proportional relationship.</p><p id="p-0096" num="0089">Thereafter, the selection number of points are selected from the points with the same value of Morton codes after right shifted by K bits according to the selection number. The selection number of points may be selected arbitrarily or in a specified manner, which is not specifically limited in implementations of this application.</p><p id="p-0097" num="0090">In order to obtain partitioned LOD layers to improve prediction accuracy of neighbor nodes, in addition to selecting the point through S<b>405</b>, in an optional implementation, the method may further include the following after S<b>404</b> and before S<b>406</b>.</p><p id="p-0098" num="0091">Points in the input point cloud of the i-th iteration are ranked in an ascending order of Morton codes for the input point cloud of the i-th iteration. From the points with the same value of Morton codes after right shifted by K bits, a point is selected every second preset threshold according to a ranking result.</p><p id="p-0099" num="0092">Specifically, the points are first ranked in an ascending order of Morton codes to obtain the ranking result of the input point cloud of the i-th iteration. Then the points with the same value of Morton codes after right shifted by K bits are found. Since each group of points with the same value of Morton codes after right shifted by K bits are also listed according to the ranking result, one point is selected every second preset threshold to obtained selected points.</p><p id="p-0100" num="0093">The second preset threshold is a value set as need.</p><p id="p-0101" num="0094">At S<b>406</b>, an i-th LOD layer is formed with the point selected, remaining points other than the point selected in the input point cloud of the i-th iteration are determined as an input point cloud of an (i+1)-th iteration, i is updated to i+1, and return to S<b>403</b>.</p><p id="p-0102" num="0095">After the selected point is obtained, the LOD layer of this iteration (that is, the i-th LOD layer) is formed with the selected point. Therefore, after this iteration, some points in the input point cloud of this iteration are partitioned into the LOD layer, while the remaining points other than the point selected in the input point cloud of this iteration are determined as the input point cloud of the (i+1)-th iteration. Then i is updated to i+1, and S<b>403</b> is performed again.</p><p id="p-0103" num="0096">As can be seen, in implementations of this application, points adjacent in space can be found by calculating the Morton codes for the input point cloud of the i-th iteration and shifting the Morton codes right by certain bits. One or more points are selected from each group of adjacent points to form the LOD layer. As such, spatial distribution of the point cloud can be taken into consideration for the partitioned LOD layers, which facilitates to improve the prediction accuracy of neighbor nodes.</p><p id="p-0104" num="0097">At S<b>407</b>, a first to (i&#x2212;1)-th LOD layers are determined as LOD layers after partition of the point cloud to-be-partitioned based on a determination that the number of points in the input point cloud of the i-th iteration is equal to 0.</p><p id="p-0105" num="0098">In addition, when the number of points in the input point cloud of the i-th iteration is equal to 0, the point cloud to-be-partitioned have been traversed completely. Therefore, the iteration may end, and the first to (i&#x2212;1)-th LOD layers are determined as LOD layers after partition of the point cloud to-be-partitioned.</p><p id="p-0106" num="0099">In addition, in order to obtain partitioned LOD layers, in an optional implementation, when i is greater than or equal to a first preset threshold, after forming the i-th LOD layer with the point selected, determining remaining points other than the point selected in the input point cloud of the i-th iteration as the input point cloud of the (i+1)-th iteration, and updating i to i+1, the method may further include the following.</p><p id="p-0107" num="0100">A LOD layer is obtained by partitioning using a preset distance-based LOD partition algorithm according to the input point cloud of the i-th iteration. The LOD layer obtained by partition and the first to (i&#x2212;1)-th LOD layers are determined as LOD layers after partition of the point cloud to-be-partitioned.</p><p id="p-0108" num="0101">That is, with the iteration method in implementations of this application, when the number of iteration i is greater than or equal to the first preset threshold, for remaining points that have not been partitioned, the distance-based LOD partition algorithm or a fixed sampling rate-based LOD partition algorithm may be used for partition to obtain LOD layers, which is not specifically limited in implementations of this application.</p><p id="p-0109" num="0102">When the number of iteration i is greater than or equal to the first preset threshold, after partition of this iteration is completed and the number of iteration is updated to i+1, according to the input point cloud of the i-th iteration, the preset distance-based LOD partition algorithm or the fixed sampling rate-based LOD partition algorithm may be invoked to partition the input point cloud of the i-th iteration to obtain the LOD layer. Finally, the first to (i&#x2212;1)-th LOD layers previously obtained and the LOD layer obtained by partition are determined as the LOD layers after partition of the point cloud to-be-partitioned.</p><p id="p-0110" num="0103">Referring to <figref idref="DRAWINGS">FIG. <b>4</b>B</figref>, <figref idref="DRAWINGS">FIG. <b>4</b>B</figref> is a schematic flowchart of a point cloud decoding method provided in implementations of the disclosure. The method may be performed by a decoder. The method starts from operations at <b>4</b>B<b>01</b>.</p><p id="p-0111" num="0104">At <b>4</b>B<b>01</b>, Morton codes for a point cloud are obtained according to geometry information of the point cloud, after geometry decoding is completed and the geometry information is reconstructed.</p><p id="p-0112" num="0105">At <b>4</b>B<b>02</b>, the point cloud is determined as an input point cloud of an iteration.</p><p id="p-0113" num="0106">At <b>4</b>B<b>03</b>, Morton codes for an input point cloud of an i-th iteration are shifted right by K bits according to a number of points in the input point cloud of the i-th iteration, where K is a positive integer.</p><p id="p-0114" num="0107">At <b>4</b>B<b>04</b>, a point is selected from points with a same value of Morton codes after right shifted by K bits.</p><p id="p-0115" num="0108">At <b>4</b>B<b>05</b>, an i-th level of detail (LOD) layer is formed with the point selected.</p><p id="p-0116" num="0109">At <b>4</b>B<b>06</b>, color information is decoded according to the LOD layer.</p><p id="p-0117" num="0110">Referring to <figref idref="DRAWINGS">FIG. <b>4</b>C</figref>, <figref idref="DRAWINGS">FIG. <b>4</b>C</figref> is a schematic flowchart of a point cloud encoding method provided in implementations of the disclosure. The method may be performed by an encoder. The method starts from operations at <b>4</b>C<b>01</b>.</p><p id="p-0118" num="0111">At <b>4</b>C<b>01</b>, Morton codes for a point cloud are obtained according to geometry information of the point cloud, after geometry encoding is completed and the geometry information is reconstructed.</p><p id="p-0119" num="0112">At <b>4</b>C<b>02</b>, the point cloud is determined as an input point cloud of an iteration.</p><p id="p-0120" num="0113">At <b>4</b>C<b>03</b>, Morton codes for an input point cloud of an i-th iteration are shifted right by K bits according to a number of points in the input point cloud of the i-th iteration, where K is a positive integer.</p><p id="p-0121" num="0114">At <b>4</b>C<b>04</b>, a point is selected from points with a same value of Morton codes after right shifted by K bits.</p><p id="p-0122" num="0115">At <b>4</b>C<b>05</b>, an i-th level of detail (LOD) layer is formed with the point selected.</p><p id="p-0123" num="0116">At <b>4</b>C<b>06</b>, color information is encoded according to the LOD layer.</p><p id="p-0124" num="0117">An example is given below to illustrate the partition method described in one or more of the above implementations.</p><p id="p-0125" num="0118"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a schematic flowchart of an example of an optional partition method provided in implementations of this application. As illustrated in <figref idref="DRAWINGS">FIG. <b>5</b></figref>, the partition method may be applied to an encoder or a decoder. In this example, the partition method is applied to the encoder. The partition method may include the following.</p><p id="p-0126" num="0119">At S<b>501</b>, Morton codes are calculated for an obtained point cloud to-be-encoded.</p><p id="p-0127" num="0120">Specifically, assume that the point cloud to-be-encoded contains N points each denoted as P[i]. A Morton code M[i] of each point P[i] is calculated, where i=0,1, . . . , N&#x2212;1. The Morton codes for the point cloud to-be-encoded are ranked in an ascending order.</p><p id="p-0128" num="0121">At S<b>502</b>, the Morton codes are right shifted by K bits.</p><p id="p-0129" num="0122">Specifically, by shifting the Morton code of each point in the point cloud to-be-encoded right by K bits, the Morton codes corresponding to points in adjacent positions in space will be equal, because the points adjacent in terms of Morton codes are generally in adjacent positions in the geometric space. With this feature of Morton codes, the points adjacent in the space are clustered together by shifting the Morton codes of all points in the point cloud to-be-encoded in space right by K bits.</p><p id="p-0130" num="0123">At S<b>503</b>, a set of points with a same value of Morton codes are sampled.</p><p id="p-0131" num="0124">Specifically, the points with the same value of Morton code after right shifted by K bits at S<b>502</b> are sampled. A point is selected from the set of points clustered together at each iteration. Reconstructed attribute values of predicted points are obtained by using attributes of predicting points to perform weighted average on attributes of predicted points based on spatial distances. Next, attribute residuals of the predicted points are obtained using the reconstructed attribute values and original attribute values. Attributes of neighbor points are predicted using the reconstructed attribute values and predicting residuals. Prediction is perform after each sampling. Thereafter, a final prediction is obtained by combining each prediction, so as to predict attributes of neighbor points remained in the point cloud to-be-encoded.</p><p id="p-0132" num="0125">At S<b>504</b>, the sampling point is assigned as a point in a current LOD layer.</p><p id="p-0133" num="0126">Specifically, the sampling point obtained at S<b>503</b> is assigned as the point in the current LOD layer, and other remaining points are assigned as points in LOD layers higher than the current LOD layer. In practical, the first point in the points with the same value of Morton codes after right shifted by K bits can be assigned as the sampling point.</p><p id="p-0134" num="0127">At S<b>505</b>, whether the remaining points are all traversed or partitioned is determined. If the remaining points are all traversed or partitioned, the partition of LOD layers is ended. Otherwise, return to S<b>502</b> to proceed with partitioning.</p><p id="p-0135" num="0128">In subsequent partition, on a basic of Morton codes right shifted by K bits for the point cloud to-be-encoded, the Morton codes are right shifted by K bits again. S<b>502</b> to S<b>505</b> are repeated until all LOD layers are partitioned or all points are traversed.</p><p id="p-0136" num="0129">According to the above example, in LOD partition based on right shifting Morton codes, each time it only needs to shift the Morton codes corresponding to the original point cloud to the right by a certain number of bits and sample the points with equal Morton codes after right shifted. Partition of LODs using this method only takes about 20% of the coding time. Compared with the original distance-based LOD partition method, the LOD partition method based on right shifting Morton codes is much lower in time complexity, which is about &#xbc;&#x2dc;&#x2153; of the former.</p><p id="p-0137" num="0130">In implementations of this application, LODs are partitioned using spatial distribution and spatial distances of the point cloud by right shifting Morton codes. In this way, not only the distances in geometry space but also the distribution of the point cloud can be taken into account. In the partition process with the method of right shifting Morton codes, the number of sampling points will be reduced in a denser part of the point cloud, while the number of sampling points will be increased in a sparser part. In the sparse part, due to the long distance between points, the attribute residuals between adjacent points are generally large during prediction. If the sampling is still based on a fixed distance, the prediction residual obtained by the attribute prediction based on the neighbors will be very large, which will lead to a large attribute bit stream after compression, and will degrade the performance of the attribute after reconstruction. In the sparse part of the space, due to the long spatial geometric distance between points, the corresponding Morton code values of adjacent points are very different. Therefore, when the Morton codes are shifted to the right, there will be few points in this part clustered into one class, so that more sampling points will be obtained. In this way, in prediction based on neighbor attributes, a better prediction effect can be obtained compared to the original scheme that only considers geometric space distances.</p><p id="p-0138" num="0131">In implementations of this application, different numbers of point sets are obtained by right shifting the Morton codes by a certain number of bits, and then sampling points in each point set are used to predict the attributes of neighbor points. Through this scheme, the distribution of the point cloud and the spatial distances between points in the point cloud can be comprehensively considered, thereby improving the effect of predicting attributes based on neighbors.</p><p id="p-0139" num="0132">The implementations of this application can improve the reconstruction quality of the attribute part, and can reduce the coding time and computational complexity of the attribute without affecting the performance basically, as illustrated in below Table 1.</p><p id="p-0140" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="35pt" align="left"/><colspec colname="2" colwidth="42pt" align="center"/><colspec colname="3" colwidth="70pt" align="center"/><colspec colname="4" colwidth="70pt" align="center"/><thead><row><entry namest="1" nameend="4" rowsep="1">TABLE 1</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row><row><entry/><entry>Initial </entry><entry/><entry/></row><row><entry/><entry>number</entry><entry/><entry>Time</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="35pt" align="left"/><colspec colname="2" colwidth="42pt" align="center"/><colspec colname="3" colwidth="70pt" align="center"/><colspec colname="4" colwidth="35pt" align="center"/><colspec colname="5" colwidth="35pt" align="center"/><tbody valign="top"><row><entry>Point </entry><entry>of right </entry><entry>BD-rate</entry><entry/><entry>Decoding</entry></row><row><entry>cloud </entry><entry>shifted</entry><entry>(attribute)</entry><entry>Encoding</entry><entry>time </entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="35pt" align="left"/><colspec colname="2" colwidth="42pt" align="center"/><colspec colname="3" colwidth="28pt" align="center"/><colspec colname="4" colwidth="42pt" align="center"/><colspec colname="5" colwidth="35pt" align="center"/><colspec colname="6" colwidth="35pt" align="center"/><tbody valign="top"><row><entry>file</entry><entry>bits</entry><entry>U</entry><entry>V</entry><entry>time ratio</entry><entry>ration</entry></row><row><entry namest="1" nameend="6" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="35pt" align="left"/><colspec colname="2" colwidth="42pt" align="char" char="."/><colspec colname="3" colwidth="28pt" align="center"/><colspec colname="4" colwidth="42pt" align="center"/><colspec colname="5" colwidth="35pt" align="center"/><colspec colname="6" colwidth="35pt" align="center"/><tbody valign="top"><row><entry>frog_</entry><entry>6</entry><entry>&#x2212;7.4%</entry><entry>&#x2212;16.6%</entry><entry>95%</entry><entry>89%</entry></row><row><entry>00067_</entry><entry/><entry/><entry/><entry/><entry/></row><row><entry>vox12</entry><entry/><entry/><entry/><entry/><entry/></row><row><entry>facade_</entry><entry>6</entry><entry>13.3%</entry><entry>&#x2002;&#x2212;4.5%</entry><entry>96%</entry><entry>86%</entry></row><row><entry>00064_</entry><entry/><entry/><entry/><entry/><entry/></row><row><entry>vox11</entry><entry/><entry/><entry/><entry/><entry/></row><row><entry>house_</entry><entry>6</entry><entry>&#x2212;3.4%</entry><entry>&#x2002;&#x2212;3.3%</entry><entry>88%</entry><entry>78%</entry></row><row><entry>without_</entry><entry/><entry/><entry/><entry/><entry/></row><row><entry>roof_</entry><entry/><entry/><entry/><entry/><entry/></row><row><entry>vox12</entry><entry/><entry/><entry/><entry/><entry/></row><row><entry>Average</entry><entry>6</entry><entry>&#x2212;0.8%</entry><entry>&#x2002;&#x2212;8.1%</entry><entry>93%</entry><entry>84%</entry></row><row><entry>(average </entry><entry/><entry/><entry/><entry/><entry/></row><row><entry>gain)</entry></row><row><entry namest="1" nameend="6" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0141" num="0133">As can be seen from Table 1, the BD-rate of the reconstructed point cloud is also significantly improved. Peak signal to noise ratio (PSNR) is an objective standard for image evaluation. The larger the PSNR, the better the image quality. BD-rate is a parameter used to measure the quality of performance. When BD-rate is negative, it means that the performance becomes better. On this basis, the larger the absolute value of BD-rate, the greater the performance gain. In addition, the partition method provided in implementations of this application reduces the time required for partitioning LODs, thereby reducing the coding time.</p><p id="p-0142" num="0134">Implementations of this application provide a partition method. The method includes the following. A point cloud to-be-partitioned is obtained and Morton codes for the point cloud to-be-partitioned are calculated. The point cloud to-be-partitioned is determined as an input point cloud of a first iteration. At an i-th iteration, whether a number of points in an input point cloud of the i-th iteration is equal to 0 is determined, where i is a positive integer with an initial value equal to 1. Based on a determination that the number of points in the input point cloud of the i-th iteration is unequal to 0, Morton codes for the input point cloud of the i-th iteration are right shifted by K bits, where K is a positive integer. A point is selected from points with a same value of Morton codes after right shifted by K bits. An i-th LOD layer is formed with the point selected, remaining points other than the point selected in the input point cloud of the i-th iteration are determined as an input point cloud of an (i+1)-th iteration, i is updated to i+1, and return to determine whether the number of points in the input point cloud of the i-th iteration is equal to 0 at the i-th iteration. Based on a determination that the number of points in the input point cloud of the i-th iteration is equal to 0, a first to (i&#x2212;1)-th LOD layers are determined as LOD layers after partition of the point cloud to-be-partitioned. That is, in implementations of this application, through iteration, Morton codes for the input point cloud of each iteration are right shifted by K bits. Thereafter, a point is selected from the points with the same value of Morton codes after right shifted by K bits, and the selected point forms the LOD layer of the current iteration. With this partition method, since points adjacent in Morton codes are generally adjacent in geometric space, the distribution of the point cloud and the spatial distances between points in the point cloud can be comprehensively considered in the LOD partition process by right shifting the Morton codes and selecting the point(s) based on the right-shifted Morton codes. As such, the partition of LOD layers obtained is based on the distribution of the point cloud and the spatial distances between points in the point cloud. In this way, the prediction accuracy of neighbor nodes based on LOD layers can be improved, thereby improving the coding efficiency.</p><p id="p-0143" num="0135">Implementation 2</p><p id="p-0144" num="0136">Based on the same inventive concept, implementations of this application provide an encoder. <figref idref="DRAWINGS">FIG. <b>6</b></figref> is a schematic structural diagram of an optional encoder provided in implementations of this application. As illustrated in <figref idref="DRAWINGS">FIG. <b>6</b></figref>, the encoder includes a first calculating module <b>61</b>, a first determining module <b>62</b>, a first judging module <b>63</b>, a first right shifting module <b>64</b>, a first selecting module <b>65</b>, a first partitioning module <b>66</b>, and a second determining module <b>67</b>.</p><p id="p-0145" num="0137">The first calculating module <b>61</b> is configured to obtain a point cloud to-be-partitioned and calculate Morton codes for the point cloud to-be-partitioned.</p><p id="p-0146" num="0138">The first determining module <b>62</b> is configured to determine the point cloud to-be-partitioned as an input point cloud of a first iteration.</p><p id="p-0147" num="0139">The first judging module <b>63</b> is configured to determine whether a number of points in an input point cloud of an i-th iteration is equal to 0 at the i-th iteration, where i is a positive integer with an initial value equal to 1.</p><p id="p-0148" num="0140">The first right shifting module <b>64</b> is configured to shift Morton codes for the input point cloud of the i-th iteration right by K bits based on a determination that the number of points in the input point cloud of the i-th iteration is unequal to 0, where K is a positive integer.</p><p id="p-0149" num="0141">The first selecting module <b>65</b> is configured to select a point from points with a same value of Morton codes after right shifted by K bits.</p><p id="p-0150" num="0142">The first partitioning module <b>66</b> is configured to form an i-th LOD layer with the point selected, determine remaining points in the input point cloud of the i-th iteration other than the point selected as an input point cloud of an (i+1)-th iteration, update i to i+1, and return to the first judging module <b>63</b> to determine whether the number of points in the input point cloud of the i-th iteration is equal to 0 at the i-th iteration.</p><p id="p-0151" num="0143">The second determining module <b>67</b> is configured to determine a first to (i&#x2212;1)-th LOD layers as LOD layers after partition of the point cloud to-be-partitioned based on a determination that the number of points in the input point cloud of the i-th iteration is equal to 0.</p><p id="p-0152" num="0144">In an optional implementation, the first determining module <b>62</b> may be further configured to determine a value of K according to a distribution of the point cloud to-be-partitioned prior to shifting the Morton codes for the input point cloud of the i-th iteration right by K bits based on the determination that the number of points in the input point cloud of the i-th iteration is unequal to 0.</p><p id="p-0153" num="0145">In an optional implementation, when i is greater than or equal to a first preset threshold, the first determining module <b>62</b> may be further configured to determine a value of K according to a number of points in the input point cloud of the i-th iteration and a distribution of the input point cloud of the i-th iteration prior to shifting the Morton codes for the input point cloud of the i-th iteration right by K bits based on the determination that the number of points in the input point cloud of the i-th iteration is unequal to 0.</p><p id="p-0154" num="0146">In an optional implementation, when i is greater than or equal to the first preset threshold, after forming the i-th LOD layer with the point selected, determining remaining points other than the point selected in the input point cloud of the i-th iteration as the input point cloud of the (i+1)-th iteration, and updating i to i+1, the encoder may be further configured to obtain a LOD layer by partitioning using a preset distance-based LOD partition algorithm according to the input point cloud of the i-th iteration, and determine the LOD layer obtained by partition and the first to (i&#x2212;1)-th LOD layers as LOD layers after partition of the point cloud to-be-partitioned.</p><p id="p-0155" num="0147">In an optional implementation, the first selecting module <b>65</b> may be specifically configured to rank points in the input point cloud of the i-th iteration in an ascending order of Morton codes for the input point cloud of the i-th iteration, and select a point ranked first from the points with the same value of Morton codes after right shifted by K bits.</p><p id="p-0156" num="0148">In an optional implementation, the first selecting module <b>65</b> may be specifically configured to determine a center of mass of the points with the same value of Morton codes after right shifted by K bits, and determine, from the points with the same value of Morton codes after right shifted by K bits, a point closest to the center of mass as the point selected.</p><p id="p-0157" num="0149">In an optional implementation, the first selecting module <b>65</b> may be specifically configured to determine a corresponding selection number according to a number of points with the same value of Morton codes after right shifted by K bits, and select, from the points with the same value of Morton codes after right shifted by K bits, the selection number of points according to the corresponding selection number.</p><p id="p-0158" num="0150">In an optional implementation, the first selecting module <b>65</b> may be specifically configured to rank points in the input point cloud of the i-th iteration in an ascending order of Morton codes for the input point cloud of the i-th iteration, and select, from the points with the same value of Morton codes after right shifted by K bits, a point every second preset threshold according to a ranking result.</p><p id="p-0159" num="0151">In an optional implementation, the first determining module <b>62</b> may be further configured to shift the Morton codes for the point cloud to-be-partitioned right by N bits and group points with the same value of Morton codes after right shifted by N bits into a point cloud group, and determine each point cloud group as the input point cloud of the first iteration respectively, where N is a positive integer.</p><p id="p-0160" num="0152">Implementations of this application provide a decoder. <figref idref="DRAWINGS">FIG. <b>7</b></figref> is a schematic structural diagram of an optional decoder provided in implementations of this application. As illustrated in <figref idref="DRAWINGS">FIG. <b>7</b></figref>, the decoder includes a second calculating module <b>71</b>, a third determining module <b>72</b>, a second judging module <b>73</b>, a second right shifting module <b>74</b>, a second selecting module <b>75</b>, a second partitioning module <b>76</b>, and a fourth determining module <b>77</b>.</p><p id="p-0161" num="0153">The second calculating module <b>71</b> is configured to obtain a point cloud to-be-partitioned and calculate Morton codes for the point cloud to-be-partitioned.</p><p id="p-0162" num="0154">The third determining module <b>72</b> is configured to determine the point cloud to-be-partitioned as an input point cloud of a first iteration.</p><p id="p-0163" num="0155">The second judging module <b>73</b> is configured to determine whether a number of points in an input point cloud of an i-th iteration is equal to 0 at the i-th iteration, where i is a positive integer with an initial value equal to 1.</p><p id="p-0164" num="0156">The second right shifting module <b>74</b> is configured to shift Morton codes for the input point cloud of the i-th iteration right by K bits based on a determination that the number of points in the input point cloud of the i-th iteration is unequal to 0, where K is a positive integer.</p><p id="p-0165" num="0157">The second selecting module <b>75</b> is configured to select a point from points with a same value of Morton codes after right shifted by K bits.</p><p id="p-0166" num="0158">The second partitioning <b>76</b> module is configured to form an i-th LOD layer with the point selected, determine remaining points in the input point cloud of the i-th iteration other than the point selected as an input point cloud of an (i+1)-th iteration, update i to i+1, and return to the second judging module <b>73</b> to determine whether the number of points in the input point cloud of the i-th iteration is equal to 0 at the i-th iteration.</p><p id="p-0167" num="0159">The fourth determining module <b>77</b> is configured to determine a first to (i&#x2212;1)-th LOD layers as LOD layers after partition of the point cloud to-be-partitioned based on a determination that the number of points in the input point cloud of the i-th iteration is equal to 0.</p><p id="p-0168" num="0160">In an optional implementation, the third determining module <b>72</b> may be further configured to determine a value of K according to a distribution of the point cloud to-be-partitioned prior to shifting the Morton codes for the input point cloud of the i-th iteration right by K bits based on the determination that the number of points in the input point cloud of the i-th iteration is unequal to 0.</p><p id="p-0169" num="0161">In an optional implementation, when i is greater than or equal to a first preset threshold, the third determining module <b>72</b> may be further configured to determine a value of K according to a number of points in the input point cloud of the i-th iteration and a distribution of the input point cloud of the i-th iteration prior to shifting the Morton codes for the input point cloud of the i-th iteration right by K bits based on the determination that the number of points in the input point cloud of the i-th iteration is unequal to 0.</p><p id="p-0170" num="0162">In an optional implementation, when i is greater than or equal to a first preset threshold, after forming the i-th LOD layer with the point selected, determining remaining points other than the point selected in the input point cloud of the i-th iteration as the input point cloud of the (i+1)-th iteration, and updating i to i+1, the decoder may be further configured to obtain a LOD layer by partitioning using a preset distance-based LOD partition algorithm according to the input point cloud of the i-th iteration, and determine the LOD layer obtained by partition and the first to (i&#x2212;1)-th LOD layers as LOD layers after partition of the point cloud to-be-partitioned.</p><p id="p-0171" num="0163">In an optional implementation, the second selecting module <b>75</b> may be specifically configured to rank points in the input point cloud of the i-th iteration in an ascending order of Morton codes for the input point cloud of the i-th iteration, and select a point ranked first from the points with the same value of Morton codes after right shifted by K bits.</p><p id="p-0172" num="0164">In an optional implementation, the second selecting module <b>75</b> may be specifically configured to determine a center of mass of the points with the same value of Morton codes after right shifted by K bits, and determine, from the points with the same value of Morton codes after right shifted by K bits, a point closest to the center of mass as the point selected.</p><p id="p-0173" num="0165">In an optional implementation, the second selecting module <b>75</b> may be specifically configured to determine a corresponding selection number according to a number of points with the same value of Morton codes after right shifted by K bits, and select, from the points with the same value of Morton codes after right shifted by K bits, the selection number of points according to the corresponding selection number.</p><p id="p-0174" num="0166">In an optional implementation, the second selecting module <b>75</b> may be specifically configured to rank points in the input point cloud of the i-th iteration in an ascending order of Morton codes for the input point cloud of the i-th iteration, and select, from the points with the same value of Morton codes after right shifted by K bits, a point every second preset threshold according to a ranking result.</p><p id="p-0175" num="0167">In an optional implementation, the third determining module <b>72</b> may be further configured to shift the Morton codes for the point cloud to-be-partitioned right by N bits and group points with the same value of Morton codes after right shifted by N bits into a point cloud group, and determine each point cloud group as the input point cloud of the first iteration respectively, where N is a positive integer.</p><p id="p-0176" num="0168"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a schematic structural diagram of another optional encoder provided in implementations of this application. As illustrated in <figref idref="DRAWINGS">FIG. <b>8</b></figref>, the encoder <b>800</b> proposed in the implementations of this application may further include a processor <b>81</b> and a storage medium <b>82</b> storing instructions executable by the processor <b>81</b>. The storage medium <b>82</b> relies on the processor <b>81</b> to perform operations through the communication bus <b>83</b>. When the instructions are executed by the processor <b>81</b>, any of the methods described in one or more of the above implementations is executed.</p><p id="p-0177" num="0169">It should be noted that, in practical application, various components in the encoder <b>800</b> are coupled together through the communication bus <b>83</b>. It can be understood that the communication bus <b>83</b> is configured to realize connection and communication between these components. In addition to the data bus, the communication bus <b>83</b> also includes a power bus, a control bus, and a status signal bus. However, for the sake of clarity, the various buses are designated as communication bus <b>83</b> in <figref idref="DRAWINGS">FIG. <b>8</b></figref>.</p><p id="p-0178" num="0170"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a schematic structural diagram of an optional decoder provided in implementations of this application. As illustrated in <figref idref="DRAWINGS">FIG. <b>9</b></figref>, the decoder <b>900</b> proposed in the implementations of this application may further include a processor <b>91</b> and a storage medium <b>92</b> storing instructions executable by the processor <b>91</b>. The storage medium <b>92</b> relies on the processor <b>91</b> to perform operations through the communication bus <b>93</b>. When the instructions are executed by the processor <b>91</b>, any of the methods described in one or more of the above implementations is executed.</p><p id="p-0179" num="0171">It should be noted that, in practical application, various components in the decoder <b>900</b> are coupled together through the communication bus <b>93</b>. It can be understood that the communication bus <b>93</b> is configured to realize connection and communication between these components. In addition to the data bus, the communication bus <b>93</b> also includes a power bus, a control bus, and a status signal bus. However, for the sake of clarity, the various buses are designated as communication bus <b>93</b> in <figref idref="DRAWINGS">FIG. <b>9</b></figref>.</p><p id="p-0180" num="0172">Implementations of this application provide a computer storage medium storing executable instructions, and when the executable instructions are executed by one or more processors, the processors execute any of the methods described in one or more of the foregoing implementations.</p><p id="p-0181" num="0173">It can be understood that the memory in implementations of this application may be a volatile memory or a non-volatile memory, or may include both volatile and non-volatile memory. The non-volatile memory may be a read-only memory (ROM), a programmable read-only memory (PROM), an erasable programmable read-only memory (EPROM), an electrically erasable programmable read-only memory (Electrically EPROM, EEPROM), or a flash memory. The volatile memory may be a random access memory (RAM), which acts as an external cache. By way of example and not limitation, many forms of RAM are available, such as static RAM (SRAM), dynamic RAM (DRAM), synchronous DRAM (SDRAM), double data rate synchronous dynamic random access memory (Double Data Rate SDRAM, DDRSDRAM), enhanced synchronous dynamic random access memory (Enhanced SDRAM, ESDRAM), synchronous link dynamic random access memory (Synchlink DRAM, SLDRAM), and direct rambus RAM (DRRAM). The memory of the systems and methods described herein is intended to include, but not be limited to, these and any other suitable types of memory.</p><p id="p-0182" num="0174">The processor may be an integrated circuit chip with signal processing capabilities. In the implementation process, each step of the above-mentioned method can be completed by a hardware integrated logic circuit in a processor or an instruction in the form of software. The above-mentioned processor may be a general-purpose processor, a digital signal processor (DSP), an application specific integrated circuit (ASIC), a field programmable gate array (FPGA), or other programmable logic devices, discrete gate or transistor logic devices, discrete hardware components. The methods, steps, and logic block diagrams disclosed in the implementations of this application can be implemented or executed. The general purpose processor may be a microprocessor or the processor may be any conventional processor or the like. The steps of the method disclosed in conjunction with the implementations of this application may be directly embodied as executed by a hardware coding processor, or executed by a combination of hardware and software modules in the coding processor. The software modules may be located in random access memory, flash memory, read-only memory, programmable read-only memory or electrically erasable programmable memory, registers and other storage media mature in the art. The storage medium is located in the memory, and the processor reads the information in the memory, and completes the steps of the above method in combination with its hardware.</p><p id="p-0183" num="0175">It will be appreciated that the implementations described herein may be implemented in hardware, software, firmware, middleware, microcode, or a combination thereof. For hardware implementation, the processing unit can be implemented in one or more ASICs, DSPs, DSP devices (DSPDs), programmable logic devices (PLDs), FPGAs, general purpose processors, controllers, microcontrollers, microprocessors, other electronic units for performing the functions described in this application, or a combination thereof.</p><p id="p-0184" num="0176">For a software implementation, the techniques described herein may be implemented through modules (e.g., procedures, functions, etc.) that perform the functions described herein. Software codes may be stored in memory and executed by a processor. The memory can be implemented in the processor or external to the processor.</p><p id="p-0185" num="0177">It should be noted herein that the terms &#x201c;including&#x201d;, &#x201c;comprising&#x201d; or any other variation thereof are intended to encompass non-exclusive inclusion, such that a process, method, article or device comprising a series of elements includes not only those elements, but also other elements not explicitly listed or inherent to such a process, method, article or device. Without further limitation, an element qualified by the phrase &#x201c;comprising a . . . &#x201d; does not preclude the presence of additional identical elements in the process, method, article or device that includes the element.</p><p id="p-0186" num="0178">The above-mentioned serial numbers of the implementations of this application are only for description, and do not represent the advantages or disadvantages of the implementations.</p><p id="p-0187" num="0179">From the description of the above implementations, those skilled in the art can clearly understand that the methods of the above implementations can be implemented by means of software plus a necessary general hardware platform, and of course hardware can also be used, but in many cases the former is better implementation. Based on this understanding, the technical solutions of this application can be embodied in the form of software products in essence or the parts that make contributions to the prior art, and the computer software products are stored in a storage medium (such as ROM/RAM, magnetic disk, CD-ROM), including several instructions to enable a terminal (which may be a mobile phone, a computer, a server, or a network device, etc.) to execute the methods described in the various implementations of this application.</p><p id="p-0188" num="0180">The implementations of the present application have been described above in conjunction with the accompanying drawings, but this application is not limited to the above-mentioned specific implementations, which are merely illustrative rather than restrictive. Under the inspiration of this application, many forms can be made without departing from the scope of protection of the purpose of this application and the claims, which all fall within the protection of this application.</p><heading id="h-0007" level="1">INDUSTRIAL APPLICABILITY</heading><p id="p-0189" num="0181">Implementations of this application provide coding methods, an encoder, a decoder, and a computer storage medium. A point cloud to-be-partitioned is obtained and Morton codes for the point cloud to-be-partitioned are calculated. The point cloud to-be-partitioned is determined as an input point cloud of a first iteration. At an i-th iteration, whether a number of points in an input point cloud of the i-th iteration is equal to 0 is determined, where i is a positive integer with an initial value equal to 1. Based on a determination that the number of points in the input point cloud of the i-th iteration is unequal to 0, Morton codes for the input point cloud of the i-th iteration are right shifted by K bits, where K is a positive integer. A point is selected from points with a same value of Morton codes after right shifted by K bits. An i-th level of detail (LOD) layer is formed with the point selected, remaining points other than the point selected in the input point cloud of the i-th iteration are determined as an input point cloud of an (i+1)-th iteration, i is updated to i+1, and return to determine whether the number of points in the input point cloud of the i-th iteration is equal to 0 during the i-th iteration. Based on a determination that the number of points in the input point cloud of the i-th iteration is equal to 0, a first to (i&#x2212;1)-th LOD layers are determined as LOD layers after partition of the point cloud to-be-partitioned. As such, a prediction accuracy of neighbor nodes based on LOD layers can be improved, thereby improving coding efficiency.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-math idrefs="MATH-US-00001 MATH-US-00001-2 MATH-US-00001-3" nb-file="US20230007250A1-20230105-M00001.NB"><img id="EMI-M00001" he="27.18mm" wi="76.20mm" file="US20230007250A1-20230105-M00001.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00002" nb-file="US20230007250A1-20230105-M00002.NB"><img id="EMI-M00002" he="8.81mm" wi="76.20mm" file="US20230007250A1-20230105-M00002.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A point cloud decoding method, applied for a decoder, comprising:<claim-text>obtaining Morton codes for a point cloud according to geometry information of the point cloud after geometry decoding is completed and the geometry information is reconstructed;</claim-text><claim-text>determining the point cloud as an input point cloud of an iteration;</claim-text><claim-text>shifting Morton codes for an input point cloud of an i-th iteration right by K bits according to a number of points in the input point cloud of the i-th iteration, K being a positive integer;</claim-text><claim-text>selecting a point from points with a same value of Morton codes after right shifted by K bits;</claim-text><claim-text>forming an i-th level of detail (LOD) layer with the point selected; and</claim-text><claim-text>decoding color information according to the LOD layer.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>prior to shifting the Morton codes for the input point cloud of the i-th iteration right by K bits according to the number of points in the input point cloud of the i-th iteration:<claim-text>determining a value of K according to a distribution of the point cloud.</claim-text></claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>when i is greater than or equal to a first preset threshold, prior to shifting the Morton codes for the input point cloud of the i-th iteration right by K bits according to the number of points in the input point cloud of the i-th iteration:<claim-text>determining a value of K according to a number of points in the input point cloud of the i-th iteration and a distribution of the input point cloud of the i-th iteration.</claim-text></claim-text></claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>when i is greater than or equal to a first preset threshold, after forming the i-th LOD layer with the point selected:<claim-text>obtaining a LOD layer by partitioning using a preset distance-based LOD partition algorithm according to the input point cloud of the i-th iteration; and</claim-text><claim-text>determining the LOD layer obtained by partition and the first to (i&#x2212;1)-th LOD layers as LOD layers after partition of the point cloud.</claim-text></claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein selecting the point from points with the same value of Morton codes after right shifted by K bits comprises:<claim-text>ranking points in the input point cloud of the i-th iteration in an ascending order of Morton codes for the input point cloud of the i-th iteration; and</claim-text><claim-text>selecting a point ranked first from the points with the same value of Morton codes after right shifted by K bits.</claim-text></claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein selecting the point from points with the same value of Morton codes after right shifted by K bits comprises:<claim-text>determining a center of mass of the points with the same value of Morton codes after right shifted by K bits; and</claim-text><claim-text>determining, from the points with the same value of Morton codes after right shifted by K bits, a point closest to the center of mass as the point selected.</claim-text></claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>after shifting Morton codes for the input point cloud of the i-th iteration right by K bits according to the number of points in the input point cloud of the i-th iteration and prior to forming the i-th LOD layer with the point selected:<claim-text>determining a corresponding selection number according to a number of points with the same value of Morton codes after right shifted by K bits; and</claim-text><claim-text>selecting, from the points with the same value of Morton codes after right shifted by K bits, the selection number of points according to the corresponding selection number.</claim-text></claim-text></claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>after shifting Morton codes for the input point cloud of the i-th iteration right by K bits according to the number of points in the input point cloud of the i-th iteration and prior to forming the i-th LOD layer with the point selected:<claim-text>ranking points in the input point cloud of the i-th iteration in an ascending order of Morton codes for the input point cloud of the i-th iteration; and</claim-text><claim-text>selecting, from the points with the same value of Morton codes after right shifted by K bits, a point every second preset threshold according to a ranking result.</claim-text></claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>after obtaining the Morton codes for the point cloud and prior to shifting Morton codes for the input point cloud of the i-th iteration right by K bits according to the number of points in the input point cloud of the i-th iteration:<claim-text>shifting the Morton codes for the point cloud right by N bits and grouping points with a same value of Morton codes after right shifted by N bits into a point cloud group, N being a positive integer; and</claim-text><claim-text>determining each point cloud group as the input point cloud of the iteration respectively.</claim-text></claim-text></claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. A point cloud encoding method, applied for an encoder, comprising:<claim-text>obtaining Morton codes for a point cloud according to geometry information of the point cloud after geometry encoding is completed and the geometry information is reconstructed;</claim-text><claim-text>determining the point cloud as an input point cloud of an iteration;</claim-text><claim-text>shifting Morton codes for an input point cloud of an i-th iteration right by K bits according to a number of points in the input point cloud of the i-th iteration, K being a positive integer;</claim-text><claim-text>selecting a point from points with a same value of Morton codes after right shifted by K bits;</claim-text><claim-text>forming an i-th level of detail (LOD) layer with the point selected; and</claim-text><claim-text>encoding color information according to the LOD layer.</claim-text></claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, further comprising:<claim-text>prior to shifting the Morton codes for the input point cloud of the i-th iteration right by K bits according to the number of points in the input point cloud of the i-th iteration:<claim-text>determining a value of K according to a distribution of the point cloud.</claim-text></claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, further comprising:<claim-text>when i is greater than or equal to a first preset threshold, prior to shifting the Morton codes for the input point cloud of the i-th iteration right by K bits according to the number of points in the input point cloud of the i-th iteration:<claim-text>determining a value of K according to a number of points in the input point cloud of the i-th iteration and a distribution of the input point cloud of the i-th iteration.</claim-text></claim-text></claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, further comprising:<claim-text>when i is greater than or equal to a first preset threshold, after forming the i-th LOD layer with the point selected:<claim-text>obtaining a LOD layer by partitioning using a preset distance-based LOD partition algorithm according to the input point cloud of the i-th iteration; and</claim-text><claim-text>determining the LOD layer obtained by partition and the first to (i&#x2212;1)-th LOD layers as LOD layers after partition of the point cloud.</claim-text></claim-text></claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein selecting the point from points with the same value of Morton codes after right shifted by K bits comprises:<claim-text>ranking points in the input point cloud of the i-th iteration in an ascending order of Morton codes for the input point cloud of the i-th iteration; and</claim-text><claim-text>selecting a point ranked first from the points with the same value of Morton codes after right shifted by K bits.</claim-text></claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein selecting the point from points with the same value of Morton codes after right shifted by K bits comprises:<claim-text>determining a center of mass of the points with the same value of Morton codes after right shifted by K bits; and</claim-text><claim-text>determining, from the points with the same value of Morton codes after right shifted by K bits, a point closest to the center of mass as the point selected.</claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, further comprising:<claim-text>after shifting Morton codes for the input point cloud of the i-th iteration right by K bits according to the number of points in the input point cloud of the i-th iteration and prior to forming the i-th LOD layer with the point selected:<claim-text>determining a corresponding selection number according to a number of points with the same value of Morton codes after right shifted by K bits; and</claim-text><claim-text>selecting, from the points with the same value of Morton codes after right shifted by K bits, the selection number of points according to the corresponding selection number.</claim-text></claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. An encoder, comprising:<claim-text>a processor; and</claim-text><claim-text>a memory storing a computer program which, when executed by the processor, causes the processor to:<claim-text>obtain Morton codes for a point cloud according to geometry information of the point cloud after geometry encoding is completed and the geometry information is reconstructed;</claim-text><claim-text>determine the point cloud as an input point cloud of an iteration;</claim-text><claim-text>shift Morton codes for an input point cloud of an i-th iteration right by K bits according to a number of points in the input point cloud of the i-th iteration, K being a positive integer;</claim-text><claim-text>select a point from points with a same value of Morton codes after right shifted by K bits;</claim-text><claim-text>form an i-th level of detail (LOD) layer with the point selected; and</claim-text><claim-text>encode color information according to the LOD layer.</claim-text></claim-text></claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The encoder of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the computer program, when executed by the processor, further causes the processor to:<claim-text>determine a value of K according to a distribution of the point cloud.</claim-text></claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. A decoder, comprising:<claim-text>a processor; and</claim-text><claim-text>a memory storing a computer program which, when executed by the processor, causes the processor to:<claim-text>obtain Morton codes for a point cloud according to geometry information of the point cloud after geometry decoding is completed and the geometry information is reconstructed;</claim-text><claim-text>determine the point cloud as an input point cloud of an iteration;</claim-text><claim-text>shift Morton codes for an input point cloud of an i-th iteration right by K bits according to a number of points in the input point cloud of the i-th iteration, K being a positive integer;</claim-text><claim-text>select a point from points with a same value of Morton codes after right shifted by K bits;</claim-text><claim-text>form an i-th level of detail (LOD) layer with the point selected; and</claim-text><claim-text>decode color information according to the LOD layer.</claim-text></claim-text></claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The decoder of <claim-ref idref="CLM-00019">claim 19</claim-ref>, wherein the computer program, when executed by the processor, further causes the processor to:<claim-text>determine a value of K according to a distribution of the point cloud.</claim-text></claim-text></claim></claims></us-patent-application>