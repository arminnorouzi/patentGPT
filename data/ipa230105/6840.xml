<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230006841A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230006841</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17857656</doc-number><date>20220705</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>L</subclass><main-group>9</main-group><subgroup>32</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>L</subclass><main-group>9</main-group><subgroup>3268</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>L</subclass><main-group>9</main-group><subgroup>3297</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">MACHINE-TO-MACHINE CRYPTOGRAPHIC MATERIAL ROTATION</invention-title><us-related-documents><us-provisional-application><document-id><country>US</country><doc-number>63217812</doc-number><date>20210702</date></document-id></us-provisional-application></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Corsha Inc.</orgname><address><city>Vienna</city><state>VA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>IYER</last-name><first-name>Anusha R.</first-name><address><city>Vienna</city><state>VA</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Mazary</last-name><first-name>David</first-name><address><city>Sterling</city><state>VA</state><country>US</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>Bodine</last-name><first-name>Russell</first-name><address><city>Arlington</city><state>VA</state><country>US</country></address></addressbook></inventor><inventor sequence="03" designation="us-only"><addressbook><last-name>Simkins</last-name><first-name>Christopher</first-name><address><city>Herndon</city><state>VA</state><country>US</country></address></addressbook></inventor></inventors></us-parties><assignees><assignee><addressbook><orgname>Corsha Inc.</orgname><role>02</role><address><city>Vienna</city><state>VA</state><country>US</country></address></addressbook></assignee></assignees></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">Automatic rotation of materials such as cryptographic materials prevents downtime in computer systems through a method in which the business logic of a DLN, such as a smart contract, receives a request from a given machine to access a resource such as a stream of chained identifiers. The logic checks the stream for a status marker that says the materials need rotation. If so, the business logic replies that rotation is required. When the marker is not there, the logic retrieves the expiry information on the cryptographic material and calculates how long until expiration. If the remaining validity is not enough, the business logic forces a rotation of the cryptographic material by storing the status marker in the stream and notifying the machine. The machine responds by working with the business logic to do the rotation.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="180.26mm" wi="158.33mm" file="US20230006841A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="220.81mm" wi="160.36mm" file="US20230006841A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="198.04mm" wi="169.67mm" file="US20230006841A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="215.56mm" wi="164.93mm" file="US20230006841A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="163.75mm" wi="165.78mm" file="US20230006841A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="182.54mm" wi="161.04mm" file="US20230006841A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="155.02mm" wi="163.75mm" file="US20230006841A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="200.58mm" wi="165.78mm" file="US20230006841A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="143.34mm" wi="163.75mm" file="US20230006841A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="147.91mm" wi="163.75mm" file="US20230006841A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="151.05mm" wi="163.41mm" file="US20230006841A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="149.27mm" wi="162.81mm" file="US20230006841A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="156.46mm" wi="162.56mm" file="US20230006841A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="223.35mm" wi="154.18mm" file="US20230006841A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00014" num="00014"><img id="EMI-D00014" he="153.42mm" wi="163.07mm" file="US20230006841A1-20230105-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00015" num="00015"><img id="EMI-D00015" he="148.17mm" wi="163.83mm" file="US20230006841A1-20230105-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00016" num="00016"><img id="EMI-D00016" he="133.18mm" wi="162.81mm" file="US20230006841A1-20230105-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading><p id="p-0002" num="0001">This application claims the benefit of U.S. Provisional Patent Application No. 63/217,812 filed on Jul. 2, 2021, the disclosure of which is herein incorporated by reference, in its entirety.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">BACKGROUND</heading><p id="p-0003" num="0002">Cryptographic materials play a central role in how computer systems establish trust between each other. When cryptographic materials expire, however, they are invalid and other computer systems will not trust them. This leads to downtime. To remedy the situation, the expired cryptographic materials formerly in use must be swapped out for valid cryptographic materials, an action often referred to as &#x201c;rotating&#x201d; the cryptographic materials.</p><p id="p-0004" num="0003">The duty to rotate cryptographic materials has traditionally fallen to information technology (IT) support staff as a recurring, manual task. To be successful and avoid downtime, the people who manage cryptographic material rotation must rotate a given computer system's cryptographic materials before they expire. It gets harder to perform this duty successfully because the number of computer systems, and hence the number of computer-to-computer relationships that use cryptographic materials, increases with no end in sight.</p><p id="p-0005" num="0004">As authentication factors, cryptographic materials may be analogized, for the sake of explanation, in the context of how people establish trust with computer systems.</p><p id="p-0006" num="0005">In computer interactions that involve people (user interactions), a user needs to authenticate themself to the computer system. Sometimes users need to supply only one authentication credential or factor, such as a password. Some systems require multiple credentials (multi-factor authentication or &#x201c;MFA&#x201d;). One common MFA solution sends an identification number or PIN to a device or to an account known to be associated with the user. The user receives the PIN via an SMS message on the associated device or via an email on the associated account. The user then enters the PIN in response to an authentication challenge from the system. MFA solutions abound: fingerprint readers, facial recognition, secure USB keys, identity cards with smart chips, memorized PINS, and authenticator apps.</p><p id="p-0007" num="0006">Requiring the user to change their credentials from time to time, perhaps by routinely expiring the user's password or the like, helps reduce the risk that a bad actor might somehow get or guess the authorized person's password, and reduce the period of harm if a password is compromised without detection. Tying the password change to another authentication factor, however, further enhances trust by helping ensure that the person changing the password is the original user and not the bad actor. For example, the password change might proceed only after the user receives a PIN via their own smartphone and provides it to the system.</p><p id="p-0008" num="0007">Returning to the context of computer systems that interact with each other in trusted relationships, machines communicate by sending messages to one another. The messages (sometimes referred to sometimes as &#x201c;calls&#x201d;) may follow a predefined format intended to invoke certain predefined actions at endpoints exposed by a relevant applications programming interface (&#x201c;API&#x201d;). This kind of communication, where a user is less-directly involved or not involved at all, is what this discussion refers to as machine-to-machine &#x201c;M2M&#x201d; communication. Here, &#x201c;machine&#x201d; broadly encompasses not just physical computer systems but also virtual machines; it covers not just clients but also servers, pods in orchestration platforms, and application containers; it refers to not just traditional computer devices but also mobile devices, IoT devices, and the applications that run on them.</p><p id="p-0009" num="0008">Cryptographic materials enable a machine to authenticate itself to another computer system and thereby establish trust. One common example of cryptographic materials resides in a public key infrastructure (PKI) system where machines use private keys to encrypt data or to sign things and use public keys to decrypt data and check other machines' signatures on things. Digital certificates, another type of cryptographic material in a PKI, are like public keys but are signed with the private key of a certificate authority (CA) to enhance their trustworthiness.</p><p id="p-0010" num="0009">Public and private keys are usually generated by the machine that is going to use them, and this same machine may typically also be responsible to send a certificate signing request (CSR) to the CA so that it will create a digital certificate from the machine's public key. Here, the CA signs the digital certificate with its own private key. The machine can subsequently present the digital certificate to another machine which, in turn, can cryptographically confirm that the digital certificate has been approved by the CA with resort to the public key of the CA.</p><heading id="h-0003" level="1">SUMMARY</heading><p id="p-0011" num="0010">By way of overview, and not limitation, the discussion below explains a way to automatically manage and effect cryptographic material rotation in a M2M environment.</p><p id="p-0012" num="0011">In one embodiment, the M2M environment leverages the way it implements M2M MFA to automatically cause a machine to rotate its cryptographic materials, or any arbitrary materials, prior to when they would have expired.</p><p id="p-0013" num="0012">The discussion below features a method of automatic rotation of materials, intended for use in preventing downtime in computer systems. This method includes a number of steps including, in no particular order, receiving an access request message indicating at least an access operation, a given machine for which the access operation is to be performed, and a first resource to which the access operation pertains; checking for a status indicator, in the first resource, pertaining to a need for rotation of a first expirable item associated with the given machine; when the status indicator indicates the need for the rotation of the first expirable item, outputting a message indicating the given machine and the need for the rotation of the first expirable item.</p><p id="p-0014" num="0013">In this method, when the status indicator is absent from the first resource or does not indicate the need for the rotation of the first expirable item, there are further steps including, in no particular order, retrieving expiry information about the first expirable item; calculating a validity time until an expiration of the first expirable item, based on the expiry information; comparing the validity time with a threshold to make a rotation determination about the first expirable item; and when the rotation determination is to rotate the first expirable item, storing the status indicator in the first resource so that the status indicator indicates the need for the rotation of the first expirable item.</p><p id="p-0015" num="0014">In this method, a further step includes generating a rotation-needed reply to the access request message indicating the given machine and the need for the rotation of the first expirable item.</p><p id="p-0016" num="0015">In this method, more steps may include, in no particular order, receiving a rotate-request message indicating the given machine, the first resource, a second resource, and a second expirable item associated with the given machine; modifying the status indicator, in the first resource, to indicate a completion of the rotation of the first expirable item; and generating a rotation-complete message indicating the given machine, the completion of the rotation of the first expirable item, the second resource, modified to contain a connection to the first resource, and a modified version of the second expirable item.</p><p id="p-0017" num="0016">The discussion also covers an apparatus that performs this method, other related methods and apparatuses, and a system of apparatuses that cooperate to implement this method.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>1</b></figref> shows an example environment in which machines send stream blocks to a data store for later use by an authentication server as an authentication factor.</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>2</b></figref> shows an simplified, highly-schematic depiction of how different sets of machine codes can enable a processor of a computer system to perform various operations.</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates a distributed ledger use case in which cryptographic material rotation finds application.</p><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. <b>4</b></figref> depicts how machine streams can fork from an enterprise root stream.</p><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. <b>5</b></figref> illustrates a state machine according to an embodiment.</p><p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. <b>6</b></figref> shows an example algorithm for automatically marking a machine stream for subsequent rotation.</p><p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. <b>7</b></figref> shows an example algorithm for how a machine can discover its stream needs rotation and what steps can lead to a new machine stream.</p><p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. <b>8</b></figref> shows an example algorithm for how the business logic can respond to a message indicating that a given machine stream needs rotation, depending on the state of the stream.</p><p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. <b>9</b></figref> shows an example algorithm for how the business logic can respond to a message indicating that a given machine requests to extend its machine stream, depending on the state of the stream.</p><p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. <b>10</b></figref> shows an example algorithm for how the business logic can respond to a message requesting that a stream challenge requires processing, depending on the state of the stream.</p><p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. <b>11</b></figref> shows an example algorithm for how the business logic can respond to a message requesting that a stream rotation be effected for a given machine stream, depending on the state of the stream.</p><p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. <b>12</b></figref> shows an example algorithm for how the business logic can respond to a message requesting that a new machine stream be primed for a given machine, depending on the state of the stream.</p><p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. <b>13</b></figref> shows an example algorithm for manually marking a machine stream, of a given machine, for subsequent rotation.</p><p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. <b>14</b></figref> shows an example algorithm for how the business logic can respond to a message indicating that a given machine stream be halted, depending on the state of the stream.</p><p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. <b>15</b></figref> shows an example algorithm for how the business logic can respond to a message indicating that a given machine stream be resumed, depending on the state of the stream.</p><p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. <b>16</b></figref> provides a table of the different states of the state machine applicable to any given machine stream and lays out how various messages cause changes in state.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0005" level="1">DETAILED DESCRIPTION</heading><p id="p-0034" num="0033">This disclosure relates to a system and method for automatic cryptographic material rotation in a machine-to-machine (M2M) environment.</p><heading id="h-0006" level="1">Example Environment: Streaming Authentication Model</heading><p id="p-0035" num="0034">For the sake of providing a concrete example that teaches the reader how to implement the ideas below, this discussion is set in the context of an example environment. This is just a teaching device. The reader should assume that the benefits of applying the ideas below extend to other environments as well.</p><p id="p-0036" num="0035">The example environment is that already generally described in U.S. Pat. No. 10,992,651 (the '651 patent) issued Apr. 27, 2021 and further in U.S. Pat. No. 11,343,243 (the '243 patent) issued May 24, 2022. As to the '651 patent, the following specific material is incorporated herein by reference for its helpful explanation of a streaming authentication approach: drawing sheet <b>1</b> and its accompanying text from column <b>1</b>, line <b>63</b> through column <b>11</b>, line <b>60</b>; drawing sheets <b>3</b>-<b>8</b> and their accompanying text from column <b>13</b>, line <b>7</b> through column <b>21</b>, line <b>48</b>; and the sample API represented in tables <b>1</b>-<b>9</b>. As to the '243 patent, the following specific material is incorporated herein by reference for its useful description of streaming authentication focusing on M2M communications: drawing sheets <b>10</b> through <b>26</b> containing <figref idref="DRAWINGS">FIGS. <b>10</b> through <b>16</b></figref><i>b </i>and their accompanying text from column <b>31</b>, line <b>16</b> through column <b>45</b>, line <b>19</b>.</p><heading id="h-0007" level="1">Architecture of Example Environment</heading><p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates, in a high level, simplified, schematic style, a system <b>10</b> that performs authentication using stream blocks. <figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates a machine base <b>1000</b>, a stream block <b>2000</b>, a chained identifier store <b>3000</b>, and an authentication server <b>4000</b>.</p><p id="p-0038" num="0037">See the column &#x201c;enterprise&#x201d; depicted in <figref idref="DRAWINGS">FIG. <b>1</b></figref> and the entries for a given enterprise E<b>1</b>. Machine base <b>1000</b> includes enterprises E<b>1</b> and E<b>2</b>. The machine base optionally includes an arbitrarily large number of enterprises although it may have only one enterprise. One of the enterprises depicted in <figref idref="DRAWINGS">FIG. <b>1</b></figref> is a generically representative enterprise E(x).</p><p id="p-0039" num="0038">The one or more enterprises each have one or more respective machines. See the column &#x201c;machine&#x201d; in <figref idref="DRAWINGS">FIG. <b>1</b></figref>. For example, enterprise E<b>1</b> has five respective machines M<b>1</b> through M<b>5</b>. Enterprise E<b>2</b> has nine respective machines M<b>1</b> through M<b>9</b>. Enterprise E(x) has one or more respective machines including a generically representative machine M(x). Machine M(x) of enterprise E(x) represents any given machine of any given enterprise.</p><heading id="h-0008" level="1">Enterprise Streams and Machine Streams</heading><p id="p-0040" num="0039">Each enterprise has its own root stream of chained identifiers referred to herein as an enterprise stream. See the illustration in <figref idref="DRAWINGS">FIG. <b>4</b></figref>.</p><p id="p-0041" num="0040">In this example environment, each machine establishes an identity by creating its own stream of chained identifiers, referred to herein as a machine stream. The first block of each machine stream, however, is created as a fork from the enterprise stream. This is also illustrated in <figref idref="DRAWINGS">FIG. <b>4</b></figref>.</p><heading id="h-0009" level="1">Machines</heading><p id="p-0042" num="0041">In <figref idref="DRAWINGS">FIG. <b>1</b></figref>, a machine M(x) is a discrete machine. Here, &#x201c;machine&#x201d; broadly encompasses not just physical computer systems but also virtual machines, not just clients but also servers, pods in orchestration platforms, and application containers, not just traditional computer devices but also mobile devices, IoT devices, and the applications that run on them.</p><heading id="h-0010" level="1">Stream Blocks and Machine Streams</heading><p id="p-0043" num="0042">See the column &#x201c;stream blocks&#x201d; in <figref idref="DRAWINGS">FIG. <b>1</b></figref>. The first row includes the symbols E<b>1</b>:M<b>1</b>. Here, &#x201c;E<b>1</b>&#x201d; refers to enterprise E<b>1</b> and &#x201c;M<b>1</b>&#x201d; refers to machine M<b>1</b> of enterprise E<b>1</b>. Similarly, the final row in the column &#x201c;stream blocks&#x201d; includes the following symbols: &#x201c;E(x):M(x)&#x201d;. These symbols signify any given machine M(x) of any given enterprise E(x).</p><p id="p-0044" num="0043">These symbols may be thought of or referred to as &#x201c;stream identifiers&#x201d;. Each machine stream has a stream ID which might equally well be a string or a number assigned around the time the stream is started.</p><p id="p-0045" num="0044">Each of the stream identifiers may be understood to relate, on a one-to-one basis, to a corresponding stream of stream blocks (a machine stream) that begins with an original (or origin) stream block [<b>000</b>] and continues with a first stream block [<b>001</b>], a second stream block [<b>002</b>], and so on, up until a current stream block [n]. Here, the numbers in between square brackets are ordinal numbers that tell the order in which a given stream block was produced within a given stream of stream blocks.</p><p id="p-0046" num="0045">Return to the column &#x201c;stream blocks&#x201d; in <figref idref="DRAWINGS">FIG. <b>1</b></figref>. The first row pertains to stream identifier E<b>1</b>:M<b>1</b> (enterprise <b>1</b>, machine <b>1</b>). This stream includes the symbols &#x201c;[<b>175</b>][<b>176</b>][<b>177</b>]&#x201d; representing three individual stream blocks. The stream block [<b>177</b>] is the one hundred seventy-seventh stream block produced for the given stream after the origin stream block [<b>000</b>]. In <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the current stream block in stream identifier E<b>1</b>:M<b>1</b> is [<b>177</b>]. The first preceding stream block relative to [<b>177</b>] is [<b>176</b>]. The second preceding stream block relative to [<b>177</b>] is [<b>175</b>].</p><p id="p-0047" num="0046">In the example shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, machine M<b>1</b> of enterprise E<b>1</b> locally stores the three most recent stream blocks of machine stream E<b>1</b>:M<b>1</b>. In the state shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, all of the stream blocks from [<b>000</b>] to [<b>177</b>] have been previously output from machine M<b>1</b> of enterprise E<b>1</b> to the chained identifier store <b>3000</b> (to be discussed shortly). The stream blocks prior to [<b>175</b>] have also, in one example implementation, previously been discarded by the machine (but not the chained identifier store <b>3000</b>).</p><p id="p-0048" num="0047">The final row pertains to machine E(x):M(x). This machine locally stores the three most recent stream blocks of its machine stream, namely, the current stream block [n], the first preceding stream block [n&#x2212;1], and the second preceding stream block [n&#x2212;2]. The number of stream blocks stored locally is configurable. Other example implementations store a number of stream blocks other than three.</p><p id="p-0049" num="0048">The locally-stored stream blocks may be thought of as a moving window into a given machine stream. For example, in the first row in the column &#x201c;stream blocks&#x201d;, the locally-stored stream blocks include [<b>175</b>], [<b>176</b>], and [<b>177</b>]. At a future time, stream block [<b>178</b>] will be produced and communicated outside of machine M<b>1</b> of enterprise E<b>1</b> and will also be stored as one of the locally-stored stream blocks with the result that stream block [<b>175</b>] will no longer be considered part of the window. The window at that future time will include [<b>176</b>], [<b>177</b>], and [<b>178</b>]. Because the content of the three most recent stream blocks changes with each newly-generated stream block, it is fair to refer to the view of the three (or however many) most recent stream blocks as a &#x201c;moving window&#x201d; into the stream.</p><p id="p-0050" num="0049">Machine streams may be set up in the system with corresponding cryptographic materials such as a public/private key pair to support secure M2M communications.</p><heading id="h-0011" level="1">Authentication with Stream Blocks</heading><p id="p-0051" num="0050">The collection of blocks that each machine streams to the chained identifier store <b>3000</b> establish an identity that grows increasingly unique over time. Each machine secured by this streaming authentication has a corresponding stream of stream blocks. Each such stream begins with an origin stream block [<b>000</b>]. Each subsequent stream block that is produced extends the stream. Here, &#x201c;stream&#x201d; does not imply the nonstop generation and outputting of stream blocks. Instead, a &#x201c;stream&#x201d; is an ordered set of stream blocks for a given machine over time.</p><p id="p-0052" num="0051">The moving window of each stream of stream blocks depicted in <figref idref="DRAWINGS">FIG. <b>1</b></figref> is configured as three, namely, the current stream block, the first preceding stream block, and the second preceding stream block. The number of stream blocks in the moving window may be alternatively expressed as w=3 where w represents the size of the moving window and 3 indicates the number of stream blocks considered to be within the window.</p><p id="p-0053" num="0052">Although this discussion generally explains example implementations where the moving window size is w=3, this value is configurable: in other example implementations, the moving window is a size other than w=3.</p><p id="p-0054" num="0053">A more general expression for the set m of the stream blocks of a given stream within the moving window is given by a concatenation, from i&#x2212;0 to i=w&#x2212;1, of [n&#x2212;i] where [n&#x2212;i] represents the stream block in the stream having the ordinal position of the current stream block less i. Thus, for a moving window with a window size of w=10, the set m of stream blocks in the moving window includes [n][n&#x2212;1][n&#x2212;2] . . . [n&#x2212;9]. Here, [n] is the current stream block; [n&#x2212;1] is the immediate precedent of [n]; [n&#x2212;2] is the immediate precedent of [n&#x2212;1] and so on. The stream blocks are stored, in one implementation, in a secure local storage. The stream blocks are stored, in various implementations, in a ring data structure, a list data structure, a queue data structure, or the like.</p><heading id="h-0012" level="1">Stream Block Contents</heading><p id="p-0055" num="0054"><figref idref="DRAWINGS">FIG. <b>1</b></figref> shows a more detailed view of an example of a given stream block <b>2000</b> according to one example. The stream block <b>2000</b> includes one or more fields identified as field<b>1</b>, field<b>2</b>, etc., up to the final field field(x). The fields of stream block <b>2000</b> are shown stacked one on top of the other for the sake of explanation and understandability. The fields are shown as having an identical length, but this too is only for the sake of explanation and does not imply that the actual fields need to be the same length. The fields are shown in order from 1 to x, but this does not imply any particular importance unless stated otherwise below.</p><p id="p-0056" num="0055">In one example, the stream block <b>2000</b> may be thought of as a block of information that has a number of fields. The fields, according to one example implementation, contain (1) a version number that designates the format of the block; (2) a sequence number for the block; (3) a timestamp taken from when the block was created; (4) an identifier for the enterprise; (5) a numerical or textual name for the machine (that is, a stream identifier); (6) a hash of the immediately preceding block from the same stream identifier; and (7) a random number that changes with each block and adds cryptographic entropy to the block. The first through seventh fields are hashed to form another field: (8) a hash of the current block.</p><p id="p-0057" num="0056">In this example implementation, the block is signed with the private key, of the PKI pair set up for this machine stream, before sending. In other implementations, the transport network that carries the block is trusted at a level that obviates the need to sign the block.</p><p id="p-0058" num="0057">The fields, taken together, constitute a &#x201c;stream block&#x201d; (here, the term &#x201c;stream block&#x201d; is used to distinguish this type of block from other blocks such as the chain block discussed later).</p><heading id="h-0013" level="1">Streams of Chained Identifiers</heading><p id="p-0059" num="0058">Because each stream block includes the stream identifier in the appropriate field, each discretely represents an identifier for the given machine. Because each current stream block contains a hash of its first preceding stream block, the stream blocks are chained. Because the origin stream block contains a hash of a block of the enterprise stream, the machine stream is chained back to the enterprise stream. Given all of this connection between preceding and subsequent blocks, and given that each block in the stream contains the stream identifier field, it is appropriate to refer to each machine stream as a stream of chained identifiers.</p><p id="p-0060" num="0059">Each stream block [n] is affected by its first preceding stream block that, in turn, was previously affected by its respective first preceding stream block, and so forth. This is because the stream block [n] contains a hash of the first preceding stream block [n&#x2212;1]. The stream of chained identifiers evolves with each new stream block, and the unpredictability of each new stream block imbues the stream with a non-deterministic but emergent quality that reflects a totality of previous effects through the entire chain. The uniqueness of each machine stream enables its use in authentication.</p><heading id="h-0014" level="1">The Chained Identifier Store</heading><p id="p-0061" num="0060">Chained identifier store <b>3000</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref> stores the chained identifiers (i.e., the stream blocks). As before, the items appearing in the form E<b>1</b>:M<b>1</b> or the like are explanatory indicia provided so that the reader can more easily track the flow of stream blocks from device to chained identifier store <b>3000</b> and are not necessarily part of the actual data stored. In this example, the chained identifier store <b>3000</b> stores each stream block from each machine of each enterprise from the origin stream block [<b>000</b>] to the current stream block [n].</p><p id="p-0062" num="0061">Each machine in the machine base <b>1000</b> produces stream blocks in a respective machine stream. The stream blocks are communicated to and stored in the chained identifier store <b>3000</b>, generally as they are produced. In one example implementation, each machine generates one stream block [n] on a periodic basis, such as every few seconds or minutes. The production continues without cease on this periodic basis so long as the machine is running. The machine may try to communicate the stream block [n] for storage in the chained identifier store <b>3000</b> as soon as the stream block is produced. When a given machine cannot communicate the current stream block for storage in the chained identifier store <b>3000</b>, in one implementation the given machine maintains a backlog pool of stream blocks to be transmitted once communication is restored. In another example implementation, when the capacity for storing the backlog pool on the given machine is exhausted, the oldest uncommitted one or more stream blocks are deleted to make room for storing the new current stream block. One concrete implementation uses a ring buffer.</p><p id="p-0063" num="0062">In another example implementation, each machine generates stream blocks on the periodic basis already mentioned, and also in response to a predetermined event such as in response to detecting power-on, initial registration of the device on the network, or in response to an authentication event. For example, when the stream in chained identifier store <b>3000</b> is not sufficiently recent (i.e., is &#x201c;stale&#x201d;), the device is prompted to freshen the stream by generating and writing new stream blocks to the chained identifier store <b>3000</b>. Writing new stream blocks is also referred to as a machine extending its respective machine stream.</p><p id="p-0064" num="0063">In the foregoing example implementations, once the machine M(x) has been appropriately deployed, the production and communication of streams of stream blocks occur automatically.</p><p id="p-0065" num="0064">The continuing, periodic or semi-periodic flow of stream blocks from all the devices of the machine base <b>1000</b> to the chained identifier store <b>3000</b> is depicted in <figref idref="DRAWINGS">FIG. <b>1</b></figref> by the line labeled &#x201c;stream to storage.&#x201d;</p><p id="p-0066" num="0065">The chained identifier store <b>3000</b> is graphically depicted as a database. In one example, the chained identifier store <b>3000</b> is a relational database management system. In another example, the chained identifier store <b>3000</b> is implemented as a distributed relational database. In yet another example, to be described below in more detail, the chained identifier store <b>3000</b> is a distributed ledger network (DLN) or, in a specific implementation, a blockchain (see <figref idref="DRAWINGS">FIG. <b>3</b></figref>).</p><heading id="h-0015" level="1">Authentication Server</heading><p id="p-0067" num="0066">The authentication server <b>4000</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref> is responsible for handling an authentication event. For example, assume machine M(x) attempts to make an API call to an endpoint that enterprise E(x) exposes. Here, the enterprise wants to ensure that such API calls are answered only for machines that are authenticated.</p><p id="p-0068" num="0067">In one example implementation, authentication is performed using only the chained identifiers without the use of other authentication factors. In another example implementation, the machine must first successfully respond to an initial authentication challenge using a first authentication factor (such as a logonid and password), and subsequently provide one or more of its locally-stored chained identifiers as an additional authentication factor. In other example implementations, the chained identifiers are used in conjunction with any combination of one or more other authentication factors.</p><p id="p-0069" num="0068">Referring back to <figref idref="DRAWINGS">FIG. <b>1</b></figref>, with the machine base <b>1000</b> and chained identifier store <b>3000</b> in the state shown, machine M(x) attempts to interact with enterprise E(x) via some interface such as an API call. The attempt triggers action by the authentication server <b>4000</b>. Authentication server <b>4000</b> responds to the access attempt by issuing a streaming block authentication challenge (not illustrated) that requests the machine M(x) to respond using the stream blocks in its moving window.</p><heading id="h-0016" level="1">Authentication by Stream Proof</heading><p id="p-0070" num="0069">As shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the machine responds to the streaming block authentication challenge in this implementation by transmitting to the authentication server <b>4000</b> all of the contents of its moving window, namely, stream blocks [n], [n&#x2212;1], and [n&#x2212;2] (see the arrow labeled &#x201c;window&#x201d;). The contents of the moving window are depicted in <figref idref="DRAWINGS">FIG. <b>1</b></figref> between curly braces. Here, the curly braces signify only that the stream blocks are suitably formatted for transmission to the authentication server <b>4000</b>. For example, the contents of the moving window may be serialized according to a predetermined format acceptable to the authentication server <b>4000</b> and then packetized for network communication. Further, in an example, the packets are encrypted using the private key set up for the machine's stream.</p><p id="p-0071" num="0070">Unlike the chained identifier store <b>3000</b>, the authentication server <b>4000</b> does not normally receive copies of all of the stream blocks. Here, it has some blocks from the moving window of the particular machine being authenticated but nothing with which to compare them. The authentication server can therefore issue a query to the chained identifier store <b>3000</b> to request a set of the stream blocks, of the given machine stream E(x):M(x).</p><p id="p-0072" num="0071">The chained identifier store <b>3000</b> responds to the query by providing the requested set from its store of previously-received stream blocks. The requested set of stream blocks in one example implementation includes just the same number of stream blocks as are in the moving window. In an alternative example, the requested set of stream blocks includes more stream blocks than are in the moving window to account for the possibility of minor communication or processing delays. The query of the authentication server <b>4000</b> and the response of the chained identifier store <b>3000</b> are depicted in <figref idref="DRAWINGS">FIG. <b>1</b></figref> by arrows respectively labeled &#x201c;query&#x201d; and &#x201c;response.&#x201d;</p><p id="p-0073" num="0072">The authentication server in this example compares each stream block received directly from the machine M(x) with the corresponding stream blocks received from the chained identifier store <b>3000</b> in response to its query. This operation is depicted within authentication server <b>4000</b> by a process that determines success when the two inputs suitably match. When each stream block of the machine's moving window matches a corresponding one retrieved from the chained identifier store <b>3000</b>, then the machine is deemed to have successfully met the streaming block authentication challenge. In this situation, the authentication server <b>4000</b> outputs an indication of success indicating proper authentication of the machine.</p><p id="p-0074" num="0073">In an alternative implementation, the authentication server <b>4000</b> simply sends the received moving window of stream blocks to the chained identifier store <b>3000</b> together with a request that the chained identifier store <b>3000</b> check those stream blocks against what it already stores. Here, the chained identifier store <b>3000</b> makes the determination as to whether there is a suitable match and returns a result to the authentication server <b>4000</b>.</p><p id="p-0075" num="0074">In yet another alternative implementation, when the machine must respond to an authentication challenge, it computes a hash of each stream block in the moving window and sends just the hashes instead of the entire stream blocks. Here, the authentication server <b>4000</b> queries the chained identifier store <b>3000</b> but obtains hashes of the stored blocks. The authentication server <b>4000</b> determines whether there is a match based on whether the hash values match.</p><p id="p-0076" num="0075">In still another alternative implementation, when the machine must respond to an authentication challenge, it computes a hash of all of the stream blocks in its moving window and sends only one hash value for the whole instead of sending separate hash values for each stream block.</p><p id="p-0077" num="0076">In one further alternative implementation, the machine is adapted so that, whenever the machine is to perform certain operations which will require answering an authentication challenge, the machine proactively sends its request together with the stream blocks, the individual block hashes, or the moving window hash that would answer such an authentication challenge. In other words, in anticipation of the need to answer an authentication challenge, the machine sends the answer without being asked for it.</p><p id="p-0078" num="0077">Regardless of the implementation, the thing that the machine sends to authenticate itself may be referred to herein as the machine sending a &#x201c;stream proof.&#x201d;</p><heading id="h-0017" level="1">Proof of Possession</heading><p id="p-0079" num="0078">Some example implementations thus include a plurality of stream blocks as the stream proof, i.e., full copies of the stream blocks. Other example implementations include as the stream proof information sufficient to show possession of the plurality of stream blocks, i.e., hashes of the stream blocks. In the latter case, the stream proof is, in a more general sense, said to include proof of possession of a plurality of stream blocks since hashes are not the only way to show proof of possession and other proofs are used in various alternative implementations.</p><heading id="h-0018" level="1">Improvements in the Functioning of the Computer Systems</heading><p id="p-0080" num="0079">The implementation in which hashes of stream blocks are sent as the stream proof, instead of the stream blocks themselves, improves the internal efficiency of the machine, the authentication server <b>4000</b>, and the chained identifier store <b>3000</b>, not to mention the network itself.</p><p id="p-0081" num="0080">The internal efficiency of the machine is improved in that the module that formulates the stream proof needs to send much less data. In the example of stream block <b>2000</b>, only field<b>8</b> (the hash of the block) is sent, reducing the amount of data to be sent by at least 75%. The hash for each stream block is computed at the time the stream block is generated, so no additional hash processing is necessary, thereby avoiding the need to expend hardware processor cycles to generate the hash values to be sent. In addition, sending the hash of a stream block is sufficient to demonstrate possession of the stream block since the probability of correctly guessing a given hash value is low. Moreover, where the stream proof includes the respective hash value for more than one block, the odds against correctly guessing all hash values increases exponentially.</p><p id="p-0082" num="0081">The authentication server <b>4000</b> also gains efficiency in this implementation of stream proof by sending only hashes. The message containing the stream proof is much shorter, and fewer cycles of the hardware processor are spent in handling the message. Similarly, the authentication server interacts with the chained identifier store <b>3000</b> by comparatively succinct communications.</p><p id="p-0083" num="0082">The improvement to efficiency of the chained identifier store <b>3000</b> comes from a faster comparison operation. Although in one implementation the chained identifier store <b>3000</b> is equipped with machine code that enables its nodes to handle stream proofs in the form of complete stream blocks, in other implementations the nodes are enabled also by other machine code to handle stream proofs in the form of only hashes. Determining an exact match for each hash in a stream proof is less processor-intensive and less memory-intensive than determining an exact match for each stream block. The reduction in processor and memory use can be as much as 75%.</p><p id="p-0084" num="0083">The network itself finds in the stream-proof-by-hash approach a reduced level of traffic when stream proofs are sent compared to the stream-proof-by-block approach. Some of the technical effects of authentication using streaming stream blocks are now discussed.</p><heading id="h-0019" level="1">Example Environment: Underlying Hardware</heading><p id="p-0085" num="0084">The structural manner in which a given machine is configured is now discussed.</p><p id="p-0086" num="0085">A machine M(x), when it operates, ultimately runs on a physical device that has a hardware processor or possibly multiple hardware processors. Unless otherwise stated, the discussion below and the appended claims pertain to both the single hardware processor case and the multiple hardware processor case, using the singular &#x201c;processor&#x201d; for the sake of convenience. The hardware processor has a small amount of memory including registers, buffers, and cache which are used by the processor to store information for short periods of time. Such information may include instructions or data.</p><heading id="h-0020" level="1">Hardware Processor</heading><p id="p-0087" num="0086">A hardware processor is a type of integrated circuit that contains a vast number of transistors and other electrical components interconnected so as to function as an array of logic gates in a pattern that yields predictable outputs in response to a vector of predefined machine code inputs. The hardware processor is adapted to perform a predefined set of basic operations in response to receiving a corresponding basic instruction, the corresponding basic instruction being one of a plurality of machine codes defining a predetermined native instruction set for the hardware processor. The set of predefined machine codes is finite and well-defined for each hardware processor, as are the corresponding basic operations. The set of predefined machine codes that may validly be provided as input to a given hardware processor defines the native instruction set of the hardware processor.</p><p id="p-0088" num="0087">The machine codes of the native instruction set of a hardware processor are input to the hardware processor in binary form. In binary form, the machine codes constitute particular logical inputs that enter the pattern of logic gates that is hard-wired into (i.e., manufactured as) the hardware processor, resulting in a predictable output that depends on the particular machine code used.</p><p id="p-0089" num="0088">Modern software is typically authored in a form other than binary and then converted through various processes such as compilation or interpretation into binary form. The machine codes must be input into a given hardware processor in binary form.</p><p id="p-0090" num="0089">Software is often referred to as being either operating system software or applications software. In general, operating system software bridges between the hardware of a given computer system and the application software. Regardless, at the time software is executed, it is executed in binary form as machine codes selected from the native instruction set of the given hardware processor.</p><p id="p-0091" num="0090">Modern software is complex, performing numerous functions and often amounting to millions of lines of source code. Each line of source code represents one or more (typically many more) individual instructions selected from the native instruction set of a hardware processor. Hardware processors have registers, buffers, cache, and the like which can store binary information. The amount of such storage is much smaller than the set of machine codes that implement a given software &#x201c;program&#x201d; or &#x201c;app.&#x201d;</p><heading id="h-0021" level="1">Memory</heading><p id="p-0092" num="0091">The set of machine codes are therefore stored in a memory that the hardware processor can access. In other words, the memory is under control of the hardware processor. The hardware processor, when executing a particular set of machine codes selected from the native instruction set, loads the machine codes from the memory, executes the machine codes, and then loads other machine codes from the memory.</p><heading id="h-0022" level="1">Other Hardware</heading><p id="p-0093" num="0092">The machine M(x) in some implementations has a receiver/transmitter unit with which it communicates to the outside world. The receiver/transmitter unit is under control of the hardware processor. In various implementations, the receiver/transmitter unit communicates variously through a mobile telephone network, a satellite network, a wireless local area network, a short-range wireless network such as a personal area network, a citizens' band radio network, or the like. In some implementations, the receiver/transmitter unit has no radio but connects instead through a wired medium such as a cable. In some implementations, the device has more than one receiver/transmitter unit for communication with the outside world. In the implementations discussed below, for the sake of explanation and not limitation, the communication is described as taking place over the Internet, but alternative network implementations are used in alternative implementations.</p><p id="p-0094" num="0093">The machine M(x) in some implementations has an input/output unit with which it may interact with a user. The input/output unit is under control of the hardware processor. In various implementations, the input/output receives inputs from, for example, a keyboard, a touch screen, a stylus, a microphone, a mouse, a motion sensor, a physical button, an embedded camera, a fingerprint sensor, or the like. In various implementations, the input/output provides outputs to, for example, a display, a speaker, an output port, a vibration unit, or the like.</p><p id="p-0095" num="0094"><figref idref="DRAWINGS">FIG. <b>2</b></figref> shows, in simplified schematic form, an example of any given machine M(x) of any given enterprise E(x). Although the machine illustrated in <figref idref="DRAWINGS">FIG. <b>2</b></figref> is hosted on a mobile phone, other implementations include a tablet, a smart watch, a smart thermostat or other household device, a smart television, a laptop computer, a desktop computer, an e-reader, a drone, an autonomous vehicle, an embedded system, a physical server, a virtual server, a cloud service, or the like.</p><p id="p-0096" num="0095">In <figref idref="DRAWINGS">FIG. <b>2</b></figref>, the machine M(x) has an enclosing body or case <b>1200</b>. Within the device is a display overlaid with a touch-sensitive membrane to form a touch screen <b>1210</b>. The device possesses one or more physical user interface buttons <b>1220</b>. In other implementations, the device has no physical user interface buttons. In <figref idref="DRAWINGS">FIG. <b>2</b></figref> a cutaway <b>1250</b> reveals a highly simplified schematic of some internal components of the hardware. Hardware processor <b>1300</b> communicates with and exercises control over a memory <b>1310</b>, a receiver/transmitter unit <b>1320</b>, and an input/output unit <b>1330</b>.</p><heading id="h-0023" level="1">Relationship Between Machine Codes and Hardware Processor</heading><p id="p-0097" num="0096"><figref idref="DRAWINGS">FIG. <b>2</b></figref> also illustrates the storage, in memory <b>1310</b>, of machine codes <b>1400</b>. The machine codes <b>1400</b> are selected from the native instruction set relevant to the given hardware processor <b>1300</b>. In more detail, the memory <b>1310</b> contains numerous sets of the machine codes <b>1400</b> such as a zeroth set <b>1400</b>-<b>0</b> selected from the native instruction set, through an n-th set <b>1400</b>-<i>n </i>selected from the native instruction set. The zeroth set <b>1400</b>-<b>0</b> of the machine codes <b>1400</b> is illustrated as containing an arbitrary number of machine codes in binary format, suitable for execution on the hardware processor <b>1300</b> once loaded from the memory <b>1310</b>. Likewise, the n-th set <b>1400</b>-<i>n </i>of machine codes <b>1400</b> also contains an arbitrary number of machine codes in binary format. As used here, &#x201c;arbitrary&#x201d; does not mean that the codes themselves are unknown or undefined; rather, the count of how many individual machine codes in a given set varies with the functionality that the machine codes are intended to impart, and the particular count of them is not a limitative factor.</p><p id="p-0098" num="0097">The precise implementation of the memory is performed according to the engineering needs of the given device. The memory may be implemented as a hard drive, a solid-state device, a flash memory, an external memory stick, a DRAM, or the like. Furthermore, as used herein, the term &#x201c;memory&#x201d; encompasses lower-level implementations where the machine codes pertain to a dedicated security processor such as in a trusted platform environment and/or are stored at a level such as described in the unified extensible firmware interface (UEFI), in a basic input-output system (BIOS), or are reflected in the makeup of a specialized integrated circuit.</p><heading id="h-0024" level="1">Configuration of Machine Authenticator</heading><p id="p-0099" num="0098">To configure a machine M(x) to perform authentication using streaming stream blocks, the memory <b>1310</b> is modified to include a machine authenticator. The machine authenticator has various modules.</p><p id="p-0100" num="0099">One such module is a stream block generation module comprising a first set of the machine codes (for example, a first set <b>1400</b>-<b>1</b> of the machine codes <b>1400</b> or the like, not separately illustrated), selected from the native instruction set, adapted to enable the processor to generate a stream block <b>2000</b> (such as the example stream block implementations described above).</p><p id="p-0101" num="0100">Configuring the machine M(x) also includes causing the memory <b>1310</b> to include a stream block streaming module comprising a second set of the machine codes selected from the native instruction set, adapted to enable the processor to output the stream block <b>2000</b> via the receiver/transmitter unit <b>1320</b> (for storage in the chained identifier store <b>3000</b>).</p><p id="p-0102" num="0101">Configuring the machine M(x) also includes modifying the memory <b>1310</b> to include a moving window output module comprising a third set of the machine codes selected from the native instruction set, adapted to enable the processor to output the m moving window stream blocks in connection with an authentication event.</p><p id="p-0103" num="0102">With the memory <b>1310</b> of the machine thus modified, the machine is adapted to perform streaming authentication using stream blocks according to the implementations mentioned above.</p><heading id="h-0025" level="1">Example Environment: Blockchain Implementation</heading><p id="p-0104" num="0103">In a specific implementation, shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, a specific system <b>11</b> implements the chained identifier store as a distributed ledger spread across independent nodes A through F of a network. For the sake of this example, chained identifier store <b>3000</b> is a DLN and specifically, a blockchain.</p><p id="p-0105" num="0104">The independent nodes A-F cooperate to receive, collect, and store stream blocks such as stream block <b>2000</b> from a machine illustrated as M(x) in the drawing. The given machine M(x) is configured with the machine authenticator described above and includes various sets of the machine codes that implement the stream block generation module, the stream block streaming module, and the moving window output module.</p><heading id="h-0026" level="1">Chain Blocks</heading><p id="p-0106" num="0105">The stream blocks received from the machines in machine base <b>1000</b> are collected as transactions and are stored in the DLN as blocks that are referred to herein as &#x201c;chain blocks.&#x201d; The chain blocks stored by distributed ledger are larger than stream blocks such as stream block <b>2000</b> and contain multiple stream blocks from multiple machines. In other words, the stream blocks are constituent elements of chain blocks. In this implementation, the chain blocks are stored as a blockchain where each chain block contains a hash of its immediate precedent (like the stream blocks where each stream block contains a hash of its immediate precedent too).</p><p id="p-0107" num="0106">The specific system <b>11</b> includes an authentication server that has a new stream generator for generating new streams. The stream generator has an enterprise root stream generation module, among others.</p><heading id="h-0027" level="1">Storing Stream Blocks in the Blockchain as Chain Blocks</heading><p id="p-0108" num="0107">Prior to an authentication event, machine M(x) repeatedly generates and sends stream blocks such as stream block <b>2000</b> to the distributed ledger (see &#x201c;send stream block every m seconds&#x201d; in the drawing). In particular, the machine M(x) is pre-configured to transmit its stream blocks to one or more of the nodes A-F. The nodes A-F cooperate to combine the received stream blocks (the stream blocks from the various clients) into a chain block whenever the number of received transactions reaches a threshold value or whenever a predefined passage of time has elapsed prior to the number of transactions reaching the threshold value. Each chain block is added to the copy of the blockchain maintained at each of the nodes A-F.</p><p id="p-0109" num="0108">When the machine M(x) makes an API call or the like, machine authenticator previously configured in the machine by machine codes <b>1400</b> sends the previously-discussed stream proof. The authentication server validates the stream proof against values previously stored in the distributed ledger. In particular, in the example shown, the authentication server sends a query to the distributed ledger which may be directed to one or more of the nodes A-F. When the reply from the distributed ledger indicates that the stream proof is valid, the authentication server may indicate approval through a message, through an authentication token, or the like.</p><heading id="h-0028" level="1">Additional Technical Effects Due to Using a Blockchain</heading><p id="p-0110" num="0109">Some of the additional technical effects of authentication using stream blocks stored in a blockchain-based chained identifier store are worth noting here. These technical effects are in addition to those mentioned with respect to the system <b>10</b> previously discussed.</p><p id="p-0111" num="0110">A blockchain-based chained identifier store distributes and stores blocks of cryptographically verifiable data in a way that records are made immutable and decentralized. Therefore, authentication by validating a stream proof is performed with no central storage of security credentials, keys, passwords, or secret material.</p><p id="p-0112" num="0111">Furthermore, the use of a blockchain distributed among some or all of the nodes A-F overcomes risks associated with the compromise of any one of the nodes. For example, if a node such as node C is compromised, any false values that a bad actor may insert into its ledger cannot escape detection by the other nodes.</p><p id="p-0113" num="0112">Moreover, the compromise of a node yields no information useful in predicting or generating the content of future stream blocks. Assuming the compromise of the node is detected (a safe assumption under a blockchain scenario), and it is prevented from receiving further stream blocks and chain blocks, the value of the compromised information will quickly diminish. For example, assume the moving window holds only three stream blocks, and the client sends out a new stream block every minute. The window of opportunity for the bad actor to use the copies of the already-stored stream blocks to attempt to pass an authentication check passes in as quickly as one minute.</p><heading id="h-0029" level="1">Example Environment: Root Streams</heading><p id="p-0114" num="0113">A common use case in which M2M communications frequently occur is the authentication of machines or network elements, such as microservices, running in docker containers that are seeking to access a network of an enterprise via an API. In such a use case, the enterprise may be concerned with ensuring that only authorized machines are allowed to access the customer enterprise network through the API.</p><p id="p-0115" num="0114">In one embodiment, the enterprise implements the framework and requires streaming authentication for network access. In another embodiment, the owner of the machine takes responsibility to use a framework for authentication when, for example, the network is a software-as-a-service (SaaS) platform that stores data belonging to the owner of the machine. In this situation, the enterprise may architect the network to allow for implementation of the framework, thereby enabling the owner of the machine to essentially &#x201c;turn on&#x201d; or activate the streaming authentication enabled by this framework. This model may be similar to models in which public cloud providers create frameworks for custom implementation of third-party multi-factor authentication solutions for authenticating end users.</p><p id="p-0116" num="0115">Turn now to <figref idref="DRAWINGS">FIG. <b>4</b></figref>. This figure depicts a series of blocks (similar to stream block <b>2000</b>) labeled &#x201c;E<b>1</b>: Enterprise Stream&#x201d;. This stream of blocks represents the identity of enterprise E<b>1</b> within the system. An enterprise stream is set up with its origin block (Block <b>0</b>) by the new stream generator illustrated in <figref idref="DRAWINGS">FIG. <b>3</b></figref>. The new stream generator is a process of the authentication server. It includes a set of machine codes that implement an enterprise root stream generation module. Once a new enterprise stream origin block is set up, a different process that is associated with the enterprise can thereafter extend the enterprise stream on some periodic basis with new stream blocks.</p><p id="p-0117" num="0116"><figref idref="DRAWINGS">FIG. <b>4</b></figref> also depicts several machine streams. For example, see the collection of blocks labeled &#x201c;E<b>1</b>:M<b>1</b> Machine Stream&#x201d;. Each machine stream, when first set up, has its origin block chained to a block in the relevant enterprise stream. The machine stream origin block generation module in the stream generator of the authentication server (see <figref idref="DRAWINGS">FIG. <b>3</b></figref>) generates the origin block for each machine stream such as M<b>1</b> Block <b>0</b> of the E<b>1</b>:M<b>1</b> machine stream. Each machine stream origin block in the example implementation of <figref idref="DRAWINGS">FIG. <b>4</b></figref> is chained to (&#x201c;based on&#x201d;) whatever block of the enterprise stream is the current block at that time. In the example, machine E<b>1</b>:M<b>2</b> was configured at some time later than that of E<b>1</b>:M<b>1</b>. This is why M<b>2</b> Block <b>0</b> is chained to E<b>1</b> Block i instead of to E<b>1</b> Block <b>1</b>.</p><p id="p-0118" num="0117">This type of per-machine seeding process may be said to fork and leverage the trust of the root stream of the enterprise. The machine streams effectively become the identity of the machine as to the given enterprise.</p><p id="p-0119" num="0118">In <figref idref="DRAWINGS">FIG. <b>4</b></figref>, each block is shown with arrows connecting back to a block to which it is chained as previously discussed. Arrows with dashed lines indicate a passage of time during which other blocks were generated but are not shown.</p><p id="p-0120" num="0119">Each machine, once provided with its origin block (or, in an alternative implementation, is given enough information to generate its origin block), extends its stream from time to time as discussed previously. Within the blockchain, the streamed blocks form an immutable record of stream blocks that could continue indefinitely.</p><p id="p-0121" num="0120">In use, the machine's machine authenticator (see <figref idref="DRAWINGS">FIG. <b>3</b></figref>) may emit a single stream to authenticate a collection of API endpoints for a given machine. For example, a particular machine may be executing a webserver that exposes multiple representational state transfer (REST) API endpoints. A machine may use one stream to authenticate to another machine via the API and then call any of its API endpoints.</p><p id="p-0122" num="0121">A DLN implementation may maintain a ledger of transactions from the machine stream block writing attempts, authentication codes streamed from machine authenticators, transactions using aware machines, deregistration, etc. The DLN may be designed as a private consortium of nodes, each naturally incentivized to verify the identity of not only their own authentication-driven transactions but also those of other responsible parties on the DLN.</p><p id="p-0123" num="0122">The DLN may be private and permissioned using cryptographic materials such as in a PKI system. Nodes may need to establish their identities with a CA and then use private key certificates to establish secure communication channels with their peers on the DLN.</p><p id="p-0124" num="0123">The authentication server can read from the DLN. Additionally, the authentication server may leverage the same CA system/certificates to establish secure communication channels between the DLN and the machine authenticators.</p><heading id="h-0030" level="1">General Architecture to Implement Manual or Time-Based Rotation of Machine Cryptographic Materials</heading><p id="p-0125" num="0124">Referring to <figref idref="DRAWINGS">FIG. <b>3</b></figref>, the DLN includes business logic. Here, where the DLN is a blockchain, the business logic implements a number of the functions described below using software that implements smart contracts. In some blockchain products, this is also referred to as chaincode.</p><p id="p-0126" num="0125">The business logic implements a state machine that supports manual or automatic cryptographic material rotation.</p><p id="p-0127" num="0126">The state machine appears in <figref idref="DRAWINGS">FIG. <b>5</b></figref>. Four states are shown. In this example, these states pertain to the cryptographic materials that a given machine uses to communicate with when it sends stream blocks to the DLN to extend its machine stream. This is just an example; the states could pertain to any other cryptographic materials or, more generally, to any materials at all that the system is set up to monitor or track. For this example, however, the discussion focuses on a scenario where the given machine uses a public/private key pair over its connection with the DLN.</p><p id="p-0128" num="0127">In the active state, the business logic allows the machine to write to its machine stream.</p><p id="p-0129" num="0128">In the needs-rotation state the business logic does not allow the machine to write to the machine stream but, instead, returns an error message that the cryptographic material needs rotation.</p><p id="p-0130" num="0129">In the rotated state the business logic considers the machine stream to be permanently capped and permits no further writes to it.</p><p id="p-0131" num="0130">In the halted state, the business logic permits no writes to the machine stream but, unlike the rotated state, a halted state can return to the active state.</p><p id="p-0132" num="0131">The business logic implements the state machine by recording a transaction in the machine stream to reflect its current state. As the state changes, new transactions are recorded by the business logic in the machine stream. The business logic can determine the present state of the state machine for any given machine stream by examining the blockchain for the most recent state machine transaction that was recorded.</p><p id="p-0133" num="0132">Speaking more generally, any given machine stream may be thought of as a resource.</p><p id="p-0134" num="0133">W the business logic examines the blockchain for the most recent state machine transaction, and ascertains the present state, it sees if the PKI pair or digital certificate is marked for rotation; this may be thought of in a general way as checking for a status indicator, in a resource, pertaining to the need for rotation of an expirable item (such as cryptographic materials) associated with the given machine.</p><heading id="h-0031" level="1">Transition from Active to NeedsRotation</heading><p id="p-0135" num="0134">The given machine writes to its machine stream via a call that the stream block output module (shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref>) makes, namely, WriteToStream( ).</p><p id="p-0136" num="0135">Turn to <figref idref="DRAWINGS">FIG. <b>6</b></figref>. This drawing shows the interaction between a given machine's machine authenticator and the business logic when the machine wants to extend its machine stream.</p><p id="p-0137" num="0136">The process begins when the machine sends a message containing a WriteToStream( ) call. The message with the WriteToStream( ) call tells the business logic the identity of the machine, the identity of the machine stream to which the write pertains, and the action that the machine wants to take, namely, to write to the machine stream. In more general terms, such a message can be thought of as an access request message indicating an access operation (a write access in the instance of WriteToStream( )), a given machine for which the access operation is to be performed (that is, the machine that originated the message in the specific example), and a resource to which the access operation pertains (the machine stream pointed to by the WriteToStream( ) call).</p><p id="p-0138" num="0137">In <figref idref="DRAWINGS">FIG. <b>6</b></figref>, the business logic executes GetEnrollmentCert( ). This returns enough information to find out when the cryptographic material, namely the digital certificate, expires. In one implementation, the business logic checks to see whether the digital certificate has reached two-thirds of its lifespan. For example, if the digital certificate originally had a thirty-day lifespan, the business logic checks to see if it is twenty or more days from its issue date. If yes, then the business logic executes a MarkToRotate( ) process that records a transaction in the machine stream to say that the needs-rotation state is in effect.</p><p id="p-0139" num="0138"><figref idref="DRAWINGS">FIG. <b>8</b></figref> shows a general algorithm for how the business logic can handle a call to MarkToRotate( ) in the different states of the state machine. Here, where the state was the active state, processing follows the leftmost branch of the diagram to &#x201c;update stream state&#x201d; from whence the transaction in the machine stream comes to set up the needs-rotation state.</p><p id="p-0140" num="0139">In more general terms, the actions of the business logic in this regard may be said to include retrieving expiry information about an expirable item associated with the given machine (here, the digital certificate is a specific example of an expirable item associated with the machine), calculating a validity time until an expiration of the expirable item, based on the expiry information. Still speaking generally, the business logic may be said to compare the validity time (such as the time left in the lifespan) with a threshold (such as two-thirds of the lifespan) to make a rotation determination about the expirable item. Further, in general, when the rotation determination is to rotate the expirable item (to rotate the digital certificate in the example above), the business logic goes about storing a status indicator in the resource (recording the transaction in the machine stream in the specific example) so that the status indicator indicates the need for the rotation of the expirable item. In other words, it changes the state of the state machine for the machine stream from the active to the needs-rotation state.</p><p id="p-0141" num="0140">The processing that takes place, when a given machine makes a WriteToStream( ) call at a time that the machine stream's state machine is in the needs-rotation state, appears in <figref idref="DRAWINGS">FIG. <b>7</b></figref>.</p><p id="p-0142" num="0141">In <figref idref="DRAWINGS">FIG. <b>7</b></figref>, via the access request message <b>100</b>, the machine makes the WriteToStream( ) call to the business logic. The business logic reviews the machine stream to which the machine wants to write and reads the most recent transaction that has a status indicator. In this example, the state is the needs-rotation state. More generally speaking, this operation can be referred to as checking for a status indicator, in a resource (the machine stream in the specific sense), pertaining to a need for rotation of an expirable item (a digital certificate in the example) associated with the given machine.</p><p id="p-0143" num="0142"><figref idref="DRAWINGS">FIG. <b>9</b></figref> shows a general algorithm for how the business logic can handle a call to WriteToStream( ) in the different states of the state machine. Here, where the state was the needs-rotation state, processing follows the second branch from the right in the diagram to &#x201c;return NeedsRotation error&#x201d;.</p><p id="p-0144" num="0143"><figref idref="DRAWINGS">FIG. <b>10</b></figref> shows a general algorithm for how the business logic can handle a call to CheckStreamChallenge( ) received via the authorization server depending on the different states of the state machine. This call comes to have the business logic check the validity of a stream proof, but is given an error reply unless the machine stream is found to be in the active state.</p><p id="p-0145" num="0144">Returning to <figref idref="DRAWINGS">FIG. <b>7</b></figref>, the business logic outputs a rotation needed reply message <b>110</b>. This message indicates the given machine and the NeedsRotation error indication which may be thought of, in a more general sense, as indicating the need for the rotation of the expirable item.</p><heading id="h-0032" level="1">Rotating Cryptographic Materials and Opening a New Machine Stream</heading><p id="p-0146" num="0145">The machine authenticator, now denied the ability to extend its stream, begins the process of certificate rotation. It first generates new cryptographic material such as a new PKI pair.</p><p id="p-0147" num="0146">It also prepares to work with the business logic to establish a new machine stream by generating at least part of a new origin stream block to be used in the new machine stream. The new origin stream block that it forms in part contains at least a hash of the last block it successfully wrote to its old stream. Doing this chains the new machine stream to the prior one, which is ultimately chained back to a block of the enterprise stream. This leaves an unbroken chain of trust back to the enterprise's stream and also further extends the identity that the stream as a whole gives the machine.</p><p id="p-0148" num="0147">The machine authenticator of the given machine also generates a CSR using its new key information.</p><p id="p-0149" num="0148">Next, in <figref idref="DRAWINGS">FIG. <b>7</b></figref>, the machine sends the business logic a rotate-request message <b>120</b>. This message in essence tells the business logic the identity of the given machine, the identity of the stream that is in the needs-rotation state (i.e., the old stream), the identity of the new stream via the partially-complete origin block, and the new cryptographic materials via the CSR. More generally, the rotate-request message indicates the given machine, the first resource (old stream), a second resource (new stream), and another expirable item associated with the given stream (the replacement cryptographic materials).</p><p id="p-0150" num="0149">Following receipt of the rotate-request message, the business logic changes the old stream's state from the needs-rotation state to the rotated state via a call to RotateStream( ). <figref idref="DRAWINGS">FIG. <b>11</b></figref> shows a general algorithm for how the business logic can handle a call to RotateStream( ) in the different states of the state machine. Here, where the state was the needs-rotation state, processing follows the second branch from the right in the diagram to &#x201c;Rotate Stream&#x201d;. Thereafter the business logic records a final transaction in the old stream indicating the rotated state. This permanently caps the stream and no further blocks may be added to it.</p><p id="p-0151" num="0150">Where the old machine stream and the new machine stream are considered in the more general sense as resources, they may be thought of as a first resource and a second resource.</p><p id="p-0152" num="0151">Where the prior cryptographic materials and the new cryptographic materials are considered more generally as expirable items associated with the given machine, the prior cryptographic materials may be thought of as a first expirable item and the new cryptographic materials may be thought of as a second expirable item.</p><p id="p-0153" num="0152">Where the business logic writes a final transaction to cap the old stream, this may be thought of more generally as modifying the status indicator, in the first resource, to indicate a completion of rotation of the first expirable item.</p><p id="p-0154" num="0153">Returning to specifics, the business logic continues on to seed the partially-formed origin block of the new machine stream with entropy-introducing data, signs the CSR, generates the new digital certificate, and provides the final origin block and signed certificate back to the machine authenticator of the given machine via a new-resource-start message <b>130</b>.</p><p id="p-0155" num="0154">Thereafter, the machine authenticator of the given machine carries out the remaining steps shown, one of which is priming the new stream by generating and sending stream blocks using the new cryptographic materials. As shown in <figref idref="DRAWINGS">FIG. <b>12</b></figref>, the priming operation can be effective only when the state machine reflects the active state.</p><heading id="h-0033" level="1">Manual Rotation</heading><p id="p-0156" num="0155"><figref idref="DRAWINGS">FIG. <b>13</b></figref> shows an implementation in which an admin user, via an admin console, can mark a stream for rotation manually. The authorization server, which in an embodiment keeps a local database of status information to reflect the status of each machines as drawn from the DLN, reacts to a manual request by sending a message to the business logic to call MarkToRotate( ). The business logic handles this the same way as has been already described above, the only difference being that the MarkToRotate( ) call has been generated in response to a user input instead of as a result of calculating a validity time until expiration.</p><p id="p-0157" num="0156">For completeness, <figref idref="DRAWINGS">FIG. <b>14</b></figref> and <figref idref="DRAWINGS">FIG. <b>15</b></figref> show how the business logic handles calls to Halt( ) and Resume( ) depending on the present state of the stream being halted or resumed.</p><p id="p-0158" num="0157"><figref idref="DRAWINGS">FIG. <b>16</b></figref> presents, in tabular form, a summary of how the business logic may alter the state of the state machine in response to the calls already discussed above.</p><p id="p-0159" num="0158"><figref idref="DRAWINGS">FIG. <b>11</b></figref> shows</p><heading id="h-0034" level="1">CONCLUSION</heading><p id="p-0160" num="0159">The systems, architectures, and frameworks of the disclosure may be implemented using any of various servers, computers, virtual machines, and other computing devices. The servers, computers, virtual machines, and other computing devices may include hardware and software for implementing the embodiments of the disclosure. For example, the servers, computers, virtual machines, and other computing devices may include hardware, such as one or more processors, one or more non-transitory memories (e.g., RAM, ROM, disk) storing computer-readable instructions, communication interfaces for communicating with other servers, computers, virtual machines, and other computing devices over computer networks. The processors may access the computer-readable instructions, which may be stored in the form of computer programs, to implement the embodiments of the disclosure. The computer programs may be software that is executed by one or more processors for controlling the servers, computers, virtual machines, and other computing devices to perform functions of the embodiments of the disclosure.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>There is claimed:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A method of automatic rotation of materials, intended for use in preventing downtime in computer systems, the method comprising:<claim-text>receiving an access request message indicating:<claim-text>an access operation,</claim-text><claim-text>a given machine for which the access operation is to be performed, and</claim-text><claim-text>a first resource to which the access operation pertains;</claim-text></claim-text><claim-text>checking for a status indicator, in the first resource, pertaining to a need for rotation of a first expirable item associated with the given machine;</claim-text><claim-text>when the status indicator indicates the need for the rotation of the first expirable item, outputting a rotation needed reply message indicating the given machine and the need for the rotation of the first expirable item; and</claim-text><claim-text>when the status indicator is absent from the first resource or does not indicate the need for the rotation of the first expirable item:<claim-text>retrieving expiry information about the first expirable item;</claim-text><claim-text>calculating a validity time until an expiration of the first expirable item, based on the expiry information;</claim-text><claim-text>comparing the validity time with a threshold to make a rotation determination about the first expirable item; and</claim-text><claim-text>when the rotation determination is to rotate the first expirable item, storing the status indicator in the first resource so that the status indicator indicates the need for the rotation of the first expirable item.</claim-text></claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>receiving a rotate-request message indicating:<claim-text>the given machine,</claim-text><claim-text>the first resource,</claim-text><claim-text>a second resource, and</claim-text><claim-text>a second expirable item associated with the given machine;</claim-text></claim-text><claim-text>modifying the status indicator, in the first resource, to indicate a completion of the rotation of the first expirable item; and</claim-text><claim-text>generating a rotation-complete message indicating:<claim-text>the given machine</claim-text><claim-text>the completion of the rotation of the first expirable item,</claim-text><claim-text>the second resource, modified to contain a connection to the first resource, and</claim-text><claim-text>a modified version of the second expirable item.</claim-text></claim-text></claim-text></claim></claims></us-patent-application>