<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230007309A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230007309</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17943366</doc-number><date>20220913</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>70</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>46</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>169</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>172</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>70</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>46</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>188</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>172</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">RANDOM ACCESS POINT ACCESS UNIT IN SCALABLE VIDEO CODING</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>PCT/US2021/022400</doc-number><date>20210315</date></document-id><parent-status>PENDING</parent-status></parent-doc><child-doc><document-id><country>US</country><doc-number>17943366</doc-number></document-id></child-doc></relation></continuation><us-provisional-application><document-id><country>US</country><doc-number>62990387</doc-number><date>20200316</date></document-id></us-provisional-application></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Bytedance Inc.</orgname><address><city>Los Angeles</city><state>CA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>WANG</last-name><first-name>Ye-kui</first-name><address><city>Los Angeles</city><state>CA</state><country>US</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">Methods, devices and systems for configuring different access units in scalable video coding are described. In one example aspect, a method of video processing include performing a conversion between a video comprising one or more pictures in one or more video layers and a bitstream of a video, wherein the bitstream comprises a coded video sequence that includes one or more access units, and wherein the bitstream further comprises a first syntax element indicating whether an access unit includes a picture for each video layer making up the coded video sequence.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="93.13mm" wi="140.04mm" file="US20230007309A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="170.94mm" wi="116.67mm" orientation="landscape" file="US20230007309A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="123.11mm" wi="120.40mm" orientation="landscape" file="US20230007309A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="197.36mm" wi="139.70mm" orientation="landscape" file="US20230007309A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="231.90mm" wi="152.48mm" orientation="landscape" file="US20230007309A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="228.09mm" wi="134.70mm" orientation="landscape" file="US20230007309A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="142.07mm" wi="122.60mm" orientation="landscape" file="US20230007309A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="141.99mm" wi="127.08mm" orientation="landscape" file="US20230007309A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="141.99mm" wi="123.78mm" orientation="landscape" file="US20230007309A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="141.99mm" wi="129.12mm" orientation="landscape" file="US20230007309A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="147.74mm" wi="132.93mm" orientation="landscape" file="US20230007309A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="146.56mm" wi="129.12mm" orientation="landscape" file="US20230007309A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="147.15mm" wi="129.12mm" orientation="landscape" file="US20230007309A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="147.15mm" wi="129.12mm" orientation="landscape" file="US20230007309A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading><p id="p-0002" num="0001">This application is a continuation of International Patent Application No. PCT/US2021/022400, filed on Mar. 15, 2021 which claims the priority to and benefits of U.S. Provisional Patent Application No. 62/990,387 filed on Mar. 16, 2020. All the aforementioned patent applications are hereby incorporated by reference in their entireties.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">TECHNICAL FIELD</heading><p id="p-0003" num="0002">This patent document relates to image and video coding and decoding.</p><heading id="h-0003" level="1">BACKGROUND</heading><p id="p-0004" num="0003">Digital video accounts for the largest bandwidth use on the internet and other digital communication networks. As the number of connected user devices capable of receiving and displaying video increases, it is expected that the bandwidth demand for digital video usage will continue to grow.</p><heading id="h-0004" level="1">SUMMARY</heading><p id="p-0005" num="0004">The present document discloses techniques, which include configuring different access units in scalable video coding, that can be used by video encoders and decoders for processing coded representation of video using control information useful for decoding of the coded representation.</p><p id="p-0006" num="0005">In one example aspect, a video processing method is disclosed. The method includes performing a conversion between a video comprising one or more pictures in one or more video layers and a bitstream of a video, wherein the bitstream comprises a coded video sequence that includes one or more access units, and wherein the bitstream further comprises a first syntax element indicating whether an access unit includes a picture for each video layer making up the coded video sequence.</p><p id="p-0007" num="0006">In another example aspect, a video processing method is disclosed. The method includes performing a conversion between a video comprising one or more pictures in one or more video layers and a bitstream of the video, wherein the bitstream comprises a coded video sequence that includes one or more access units, and wherein the bitstream conforms to a format rule that specifies that each picture in a given access unit carries a layer identifier that is equal to a layer identifier of a first access unit of the coded video sequence comprising the one or more video layers.</p><p id="p-0008" num="0007">In yet another example aspect, a video processing method is disclosed. The method includes performing, a conversion between a video comprising one or more pictures in one or more video layers and a bitstream of a video, wherein the bitstream comprises a coded video sequence that includes one or more access units, and wherein the bitstream further comprises a first syntax element indicative of an access unit of the one or more access units starting a new coded video sequence.</p><p id="p-0009" num="0008">In yet another example aspect, a video processing method is disclosed. The method includes performing a conversion between a video comprising one or more pictures in one or more video layers and a bitstream of the video, wherein the bitstream comprises a coded video sequence that includes one or more access units, and wherein the bitstream conforms to a format rule that specifies that a coded video sequence start access unit, which starts a new coded video sequence, comprises a picture for each video layer specified in a video parameter set.</p><p id="p-0010" num="0009">In yet another example aspect, a video processing method is disclosed. The method includes performing a conversion between a video comprising one or more pictures in one or more video layers and a bitstream of the video, wherein the bitstream comprises a coded video sequence that includes one or more access units, and wherein the bitstream conforms to a format rule that specifies that a given access unit is identified as a coded video sequence start access unit based on the given access unit being a first access unit in the bitstream or an access unit previous to the given access unit comprising end of sequence network abstraction layer units.</p><p id="p-0011" num="0010">In yet another example aspect, a video processing method is disclosed. The method includes performing, based on a rule, a conversion between a video comprising one or more pictures in one or more video layers and a bitstream of the video, wherein the bitstream comprises a coded video sequence that includes one or more access units, and wherein the rule specifies that side information is used to indicate whether an access unit of the one or more access units is a coded video sequence start access unit.</p><p id="p-0012" num="0011">In yet another example aspect, a video processing method is disclosed. The method includes performing a conversion between a video comprising one or more pictures in one or more video layers and a bitstream of a video, wherein the bitstream comprises a coded video sequence that includes one or more access units, and wherein the bitstream conforms to a format rule that specifies that each access unit of the one or more access units that is a gradual decoding refresh access unit includes exactly one picture for each video layer present in the coded video sequence.</p><p id="p-0013" num="0012">In yet another example aspect, a video processing method is disclosed. The method includes performing a conversion between a video comprising one or more pictures in one or more video layers and a bitstream of a video, wherein the bitstream comprises a coded video sequence that includes one or more access units, and wherein the bitstream conforms to a format rule that specifies that each access unit of the one or more access units that is an intra random access points access unit includes exactly one picture for each video layer present in the coded video sequence.</p><p id="p-0014" num="0013">In yet another example aspect, a video encoder apparatus is disclosed. The video encoder comprises a processor configured to implement above-described methods.</p><p id="p-0015" num="0014">In yet another example aspect, a video decoder apparatus is disclosed. The video decoder comprises a processor configured to implement above-described methods.</p><p id="p-0016" num="0015">In yet another example aspect, a computer readable medium having code stored thereon is disclose. The code embodies one of the methods described herein in the form of processor-executable code.</p><p id="p-0017" num="0016">These, and other, features are described throughout the present document.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0005" level="1">BRIEF DESCRIPTION OF DRAWINGS</heading><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram showing an example video processing system in which various techniques disclosed herein may be implemented.</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a block diagram of an example hardware platform used for video processing.</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a block diagram that illustrates an example video coding system that can implement some embodiments of the present disclosure.</p><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a block diagram that illustrates an example of an encoder that can implement some embodiments of the present disclosure.</p><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a block diagram that illustrates an example of a decoder that can implement some embodiments of the present disclosure.</p><p id="p-0023" num="0022"><figref idref="DRAWINGS">FIGS. <b>6</b>-<b>13</b></figref> show flowcharts for example methods of video processing.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0006" level="1">DETAILED DESCRIPTION</heading><p id="p-0024" num="0023">Section headings are used in the present document for ease of understanding and do not limit the applicability of techniques and embodiments disclosed in each section only to that section. Furthermore, H.266 terminology is used in some description only for ease of understanding and not for limiting scope of the disclosed techniques. As such, the techniques described herein are applicable to other video codec protocols and designs also.</p><heading id="h-0007" level="1">1. INITIAL DISCUSSION</heading><p id="p-0025" num="0024">This document is related to video coding technologies. Specifically, it is about specifying and signaling of random access point access unit in scalable video coding, wherein a video bitstream can contains more than one layer. The ideas may be applied individually or in various combination, to any video coding standard or non-standard video codec that supports multi-layer video coding, e.g., the being-developed Versatile Video Coding (VVC).</p><heading id="h-0008" level="1">2. ABBREVIATIONS</heading><p id="p-0026" num="0025">APS Adaptation Parameter Set</p><p id="p-0027" num="0026">AU Access Unit</p><p id="p-0028" num="0027">AUD Access Unit Delimiter</p><p id="p-0029" num="0028">AVC Advanced Video Coding</p><p id="p-0030" num="0029">CLVS Coded Layer Video Sequence</p><p id="p-0031" num="0030">CPB Coded Picture Buffer</p><p id="p-0032" num="0031">CRA Clean Random Access</p><p id="p-0033" num="0032">CTU Coding Tree Unit</p><p id="p-0034" num="0033">CVS Coded Video Sequence</p><p id="p-0035" num="0034">DCI Decoding Capability Information</p><p id="p-0036" num="0035">DPB Decoded Picture Buffer</p><p id="p-0037" num="0036">EOB End Of Bitstream</p><p id="p-0038" num="0037">EOS End Of Sequence</p><p id="p-0039" num="0038">GDR Gradual Decoding Refresh</p><p id="p-0040" num="0039">HEVC High Efficiency Video Coding</p><p id="p-0041" num="0040">HRD Hypothetical Reference Decoder</p><p id="p-0042" num="0041">IDR Instantaneous Decoding Refresh</p><p id="p-0043" num="0042">JEM Joint Exploration Model</p><p id="p-0044" num="0043">MCTS Motion-Constrained Tile Sets</p><p id="p-0045" num="0044">NAL Network Abstraction Layer</p><p id="p-0046" num="0045">OLS Output Layer Set</p><p id="p-0047" num="0046">PH Picture Header</p><p id="p-0048" num="0047">PPS Picture Parameter Set</p><p id="p-0049" num="0048">PTL Profile, Tier and Level</p><p id="p-0050" num="0049">PU Picture Unit</p><p id="p-0051" num="0050">RAP Random Access Point</p><p id="p-0052" num="0051">RB SP Raw Byte Sequence Payload</p><p id="p-0053" num="0052">SEI Supplemental Enhancement Information</p><p id="p-0054" num="0053">SPS Sequence Parameter Set</p><p id="p-0055" num="0054">SVC Scalable Video Coding</p><p id="p-0056" num="0055">VCL Video Coding Layer</p><p id="p-0057" num="0056">VPS Video Parameter Set</p><p id="p-0058" num="0057">VTM VVC Test Model</p><p id="p-0059" num="0058">VUI Video Usability Information</p><p id="p-0060" num="0059">VVC Versatile Video Coding</p><heading id="h-0009" level="1">3. VIDEO CODING INTRODUCTION</heading><p id="p-0061" num="0060">Video coding standards have evolved primarily through the development of the well-known International Telecommunication Union-Telecommunication Standardization Sector (ITU-T) and International Organization for Standardization (ISO)/International Electrotechnical Commission (IEC) standards. The ITU-T produced H.261 and H.263, ISO/IEC produced Moving Picture Experts Group (MPEG)-1 and MPEG-4 Visual, and the two organizations jointly produced the H.262/MPEG-2 Video and H.264/MPEG-4 Advanced Video Coding (AVC) and H.265/HEVC standards. Since H.262, the video coding standards are based on the hybrid video coding structure wherein temporal prediction plus transform coding are utilized. To explore the future video coding technologies beyond High Efficiency Video Coding (HEVC), the Joint Video Exploration Team (JVET) was founded by Video Coding Experts Group (VCEG) and MPEG jointly in 2015. Since then, many new methods have been adopted by JVET and put into the reference software named Joint Exploration Model (JEM). The JVET meeting is concurrently held once every quarter, and the new coding standard is targeting at 50% bitrate reduction as compared to HEVC. The new video coding standard was officially named as Versatile Video Coding (VVC) in the April 2018 JVET meeting, and the first version of VVC test model (VTM) was released at that time. As there are continuous effort contributing to VVC standardization, new coding techniques are being adopted to the VVC standard in every JVET meeting. The VVC working draft and test model VTM are then updated after every meeting. The VVC project is now aiming for technical completion, Final Draft International Standard (FDIS), at the July 2020 meeting.</p><heading id="h-0010" level="1">3.1. Random Access and its Supports in HEVC and VVC</heading><p id="p-0062" num="0061">Random access refers to starting access and decoding of a bitstream from a picture that is not the first picture of the bitstream in decoding order. To support tuning in and channel switching in broadcast/multicast and multiparty video conferencing, seeking in local playback and streaming, as well as stream adaptation in streaming, the bitstream needs to include frequent random access points, which are typically intra coded pictures but may also be inter-coded pictures (e.g., in the case of gradual decoding refresh).</p><p id="p-0063" num="0062">HEVC includes signaling of intra random access points (TRAP) pictures in the network abstraction layer (NAL) unit header, through NAL unit types. Three types of TRAP pictures are supported, namely instantaneous decoder refresh (IDR), clean random access (CRA), and broken link access (BLA) pictures. IDR pictures are constraining the inter-picture prediction structure to not reference any picture before the current group-of-pictures (GOP), conventionally referred to as closed-GOP random access points. CRA pictures are less restrictive by allowing certain pictures to reference pictures before the current GOP, all of which are discarded in case of a random access. CRA pictures are conventionally referred to as open-GOP random access points. BLA pictures usually originate from splicing of two bitstreams or part thereof at a CRA picture, e.g., during stream switching. To enable better systems usage of TRAP pictures, altogether six different NAL units are defined to signal the properties of the TRAP pictures, which can be used to better match the stream access point types as defined in the ISO base media file format (ISOBMFF), which are utilized for random access support in dynamic adaptive streaming over HTTP (DASH).</p><p id="p-0064" num="0063">VVC supports three types of TRAP pictures, two types of IDR pictures (one type with or the other type without associated random access decodable leading (RADL) pictures) and one type of CRA picture. These are basically the same as in HEVC. The BLA picture types in HEVC are not included in VVC, mainly due to two reasons: i) The basic functionality of BLA pictures can be realized by CRA pictures plus the end of sequence NAL unit, the presence of which indicates that the subsequent picture starts a new coded video sequence (CVS) in a single-layer bitstream. Ii) There was a desire in specifying less NAL unit types than HEVC during the development of VVC, as indicated by the use of five instead of six bits for the NAL unit type field in the NAL unit header.</p><p id="p-0065" num="0064">Another key difference in random access support between VVC and HEVC is the support of gradual decoding refresh (GDR) in a more normative manner in VVC. In GDR, the decoding of a bitstream can start from an inter-coded picture and although at the beginning not the entire picture region can be correctly decoded but after a number of pictures the entire picture region would be correct. AVC and HEVC also support GDR, using the recovery point supplemental enhancement information (SEI) message for signaling of GDR random access points and the recovery points. In VVC, a new NAL unit type is specified for indication of GDR pictures and the recovery point is signaled in the picture header syntax structure. A CVS and a bitstream are allowed to start with a GDR picture. This means that it is allowed for an entire bitstream to contain only inter-coded pictures without a single intra-coded picture. The main benefit of specifying GDR support this way is to provide a conforming behavior for GDR. GDR enables encoders to smooth the bit rate of a bitstream by distributing intra-coded slices or blocks in multiple pictures as opposed intra coding entire pictures, thus allowing significant end-to-end delay reduction, which is considered more important nowadays than before as ultralow delay applications like wireless display, online gaming, drone based applications become more popular.</p><p id="p-0066" num="0065">Another GDR related feature in VVC is the virtual boundary signaling. The boundary between the refreshed region (i.e., the correctly decoded region) and the unrefreshed region at a picture between a GDR picture and its recovery point can be signaled as a virtual boundary, and when signaled, in-loop filtering across the boundary would not be applied, thus a decoding mismatch for some samples at or near the boundary would not occur. This can be useful when the application determines to display the correctly decoded regions during the GDR process.</p><p id="p-0067" num="0066">TRAP pictures and GDR pictures can be collectively referred to as random access point (RAP) pictures.</p><heading id="h-0011" level="1">3.2. Scalable Video Coding (SVC) in General and in VVC</heading><p id="p-0068" num="0067">Scalable video coding (SVC, sometimes also just referred to as scalability in video coding) refers to video coding in which a base layer (BL), sometimes referred to as a reference layer (RL), and one or more scalable enhancement layers (Els) are used. In SVC, the base layer can carry video data with a base level of quality. The one or more enhancement layers can carry additional video data to support, for example, higher spatial, temporal, and/or signal-to-noise (SNR) levels. Enhancement layers may be defined relative to a previously encoded layer. For example, a bottom layer may serve as a BL, while a top layer may serve as an EL. Middle layers may serve as either Els or RLs, or both. For example, a middle layer (e.g., a layer that is neither the lowest layer nor the highest layer) may be an EL for the layers below the middle layer, such as the base layer or any intervening enhancement layers, and at the same time serve as a RL for one or more enhancement layers above the middle layer. Similarly, in the Multiview or <b>3</b>D extension of the HEVC standard, there may be multiple views, and information of one view may be utilized to code (e.g., encode or decode) the information of another view (e.g., motion estimation, motion vector prediction and/or other redundancies).</p><p id="p-0069" num="0068">In SVC, the parameters used by the encoder or the decoder are grouped into parameter sets based on the coding level (e.g., video-level, sequence-level, picture-level, slice level, etc.) in which they may be utilized. For example, parameters that may be utilized by one or more coded video sequences of different layers in the bitstream may be included in a video parameter set (VPS), and parameters that are utilized by one or more pictures in a coded video sequence may be included in a sequence parameter set (SPS). Similarly, parameters that are utilized by one or more slices in a picture may be included in a picture parameter set (PPS), and other parameters that are specific to a single slice may be included in a slice header. Similarly, the indication of which parameter set(s) a particular layer is using at a given time may be provided at various coding levels.</p><p id="p-0070" num="0069">Thanks to the support of reference picture resampling (RPR) in VVC, support of a bitstream containing multiple layers, e.g., two layers with standard definition (SD) and high definition (HD) resolutions in VVC can be designed without the need any additional signal-processing-level coding tool, as upsampling needed for spatial scalability support can just use the RPR upsampling filter. Nevertheless, high-level syntax changes (compared to not supporting scalability) are needed for scalability support. Scalability support is specified in VVC version 1. Different from the scalability supports in any earlier video coding standards, including in extensions of AVC and HEVC, the design of VVC scalability has been made friendly to single-layer decoder designs as much as possible. The decoding capability for multi-layer bitstreams are specified in a manner as if there were only a single layer in the bitstream. E.g., the decoding capability, such as decoded picture buffer (DPB) size, is specified in a manner that is independent of the number of layers in the bitstream to be decoded. Basically, a decoder designed for single-layer bitstreams does not need much change to be able to decode multi-layer bitstreams. Compared to the designs of multi-layer extensions of AVC and HEVC, the HLS aspects have been significantly simplified at the sacrifice of some flexibilities. For example, an IRAP access unit (AU) is required to contain a picture for each of the layers present in the CVS.</p><heading id="h-0012" level="1">3.3. Parameter Sets</heading><p id="p-0071" num="0070">AVC, HEVC, and VVC specify parameter sets. The types of parameter sets include sequence parameter set (SPS), picture parameter set (PPS), adaptation parameter set (APS), and video parameter set (VPS). SPS and PPS are supported in all of AVC, HEVC, and VVC. VPS was introduced since HEVC and is included in both HEVC and VVC. APS was not included in AVC or HEVC but is included in the latest VVC draft text.</p><p id="p-0072" num="0071">SPS was designed to carry sequence-level header information, and PPS was designed to carry infrequently changing picture-level header information. With SPS and PPS, infrequently changing information need not to be repeated for each sequence or picture, hence redundant signaled of this information can be avoided. Furthermore, the use of SPS and PPS enables out-of-band transmission of the important header information, thus not only avoiding the need for redundant transmissions but also improving error resilience.</p><p id="p-0073" num="0072">VPS was introduced for carrying sequence-level header information that is common for all layers in multi-layer bitstreams.</p><p id="p-0074" num="0073">APS was introduced for carrying such picture-level or slice-level information that needs quite some bits to code, can be shared by multiple pictures, and in a sequence there can be quite many different variations.</p><heading id="h-0013" level="1">3.4. Related Definitions in in VVC</heading><p id="p-0075" num="0074">Related definitions in the latest VVC text (in JVET-Q2001-Ve/v15) are as follows.<ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0075">Associated IRAP picture (of a particular picture): The previous IRAP picture in decoding order (when present) having the same value of nuh_layer_id as the particular picture.</li>        <li id="ul0002-0002" num="0076">Coded video sequence (CVS): A sequence of Aus that consists, in decoding order, of a CVS start (CUSS) AU, followed by zero or more Aus that are not CVSS Aus, including all subsequent Aus up to but not including any subsequent AU that is a CVSS AU.</li>        <li id="ul0002-0003" num="0077">Coded video sequence start (CVSS) AU: An AU in which there is a prediction unit (PU) for each layer in the CVS and the coded picture in each PU is a coded layer video sequence (CLVS) start (CLVSS) picture.</li>        <li id="ul0002-0004" num="0078">Gradual decoding refresh (GDR) AU: An AU in which the coded picture in each present PU is a GDR picture.</li>        <li id="ul0002-0005" num="0079">Gradual decoding refresh (GDR) PU: A PU in which the coded picture is a GDR picture.</li>        <li id="ul0002-0006" num="0080">Gradual decoding refresh (GDR) picture: A picture for which each VCL NAL unit has nal_unit_type equal to GDR_NUT.</li>        <li id="ul0002-0007" num="0081">Intra random access point (IRAP) AU: An AU in which there is a PU for each layer in the CVS and the coded picture in each PU is an IRAP picture.</li>        <li id="ul0002-0008" num="0082">Intra random access point (IRAP) picture: A coded picture for which all VCL NAL units have the same value of nal_unit_type in the range of IDR_W_RADL to CRA_NUT, inclusive.</li>    </ul>    </li></ul></p><heading id="h-0014" level="1">3.5. VPS Syntax and Semantics in VVC</heading><p id="p-0076" num="0083">VVC supports scalability, also known as scalable video coding, wherein multiple layers can be encoded in one coded video bitstream.</p><p id="p-0077" num="0084">In the latest VVC text (in JVET-Q2001-Ve/v15), the scalability information is signaled in the VPS, for which the syntax and semantics are as follows.</p><p id="p-0078" num="0000">7.3.2.2 Video parameter set syntax</p><p id="p-0079" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="224pt" align="left"/><colspec colname="2" colwidth="49pt" align="center"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>video_parameter_set_rbsp( ) {</entry><entry>Descriptor</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;vps_video_parameter_set_id</entry><entry>u(4)</entry></row><row><entry>&#x2003;vps_max_layers_minus1</entry><entry>u(6)</entry></row><row><entry>&#x2003;vps_max_sublayers_minus1</entry><entry>u(3)</entry></row><row><entry>&#x2003;if( vps_max_layers_minus1 &#x3e; 0 &#x26;&#x26; vps_max_sublayers_minus1 &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;vps_all_layers_same_num_sublayers_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( vps_max_layers_minus1 &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;vps_all_independent_layers_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;for( I = 0; I &#x3c;= vps_max_layers_minus1; i++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;vps_layer_id[ I ]</entry><entry>u(6)</entry></row><row><entry>&#x2003;&#x2003;if( I &#x3e; 0 &#x26;&#x26; !vps_all_independent_layers_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;vps_independent_layer_flag[ I ]</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( !vps_independent_layer_flag[ I ] ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c; I; j++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;vps_direct_ref_layer_flag[ I ][ j ]</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;max_tid_ref_present_flag[ I ]</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( max_tid_ref_present_flag[ I ])</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;max_tid_il_ref_pics_plus1[ I ]</entry><entry>u(3)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( vps_max_layers_minus1 &#x3e; 0 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;if( vps_all_independent_layers_flag ) </entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;each_layer_is_an_ols_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( !each_layer_is_an_ols_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( !vps_all_independent_layers_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ols_mode_idc</entry><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( ols_mode_idc = = 2 ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;num_output_layer_sets_minus1</entry><entry>u(8)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;for( I = 1; I &#x3c;= num_output_layer_sets_minus1; I ++)</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c;= vps_max_layers_minus1; j++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;ols_output_layer_flag[ I ][ j ]</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;vps_num_ptls_minus1</entry><entry>u(8)</entry></row><row><entry>&#x2003;for( I = 0; I &#x3c;= vps_num_ptls_minus1; i++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;if( I &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;pt_present_flag[ I ]</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( vps_max_sublayers_minus1 &#x3e; 0 &#x26;&#x26;</entry><entry/></row><row><entry>!vps_all_layers_same_num_sublayers_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ptl_max_temporal_id[ I ]</entry><entry>u(3)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;while( !byte_aligned( ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;vps_ptl_alignment_zero_bit /* equal to 0 */</entry><entry>f(1)</entry></row><row><entry>&#x2003;for( I = 0; I &#x3c;= vps_num_ptls_minus1; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;profile_tier_level( pt_present flag[ I ], ptl_max_temporal_id[ I ] )</entry><entry/></row><row><entry>&#x2003;for( I = 0; I &#x3c; TotalNumOlss; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;if( vps_num_ptls_minus1 &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ols_ptl_idx[ I ]</entry><entry>u(8)</entry></row><row><entry>&#x2003;if( !vps_all_independent_layers_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;vps_num_dpb_params</entry><entry>ue(v)</entry></row><row><entry>&#x2003;if( vps_num_dpb_params &#x3e; 0 &#x26;&#x26; vps_max_sublayers_minus1 &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;vps_sublayer_dpb_params_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;for( I = 0; I &#x3c; vps_num_dpb_params; i++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;if( vps_max_sublayers_minus1 &#x3e; 0 &#x26;&#x26;</entry><entry/></row><row><entry>!vps_all_layers_same_num_sublayers_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;dpb_max_temporal_id[ I ]</entry><entry>u(3)</entry></row><row><entry>&#x2003;&#x2003;dpb_parameters( dpb_max_temporal_id[ I ],</entry><entry/></row><row><entry>vps_sublayer_dpb_params_present_flag )</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;for( I = 0; I &#x3c; TotalNumOlss; i++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;if( NumLayersInOls[ I ] &#x3e; l ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ols_dpb_pic_width[ I ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;ols_dpb_pic_height[ I ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( vps_num_dpb_params &#x3e; 1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ols_dpb_params_idx[ I ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;if( !each_layer_is_an_ols_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;vps_general_hrd_params_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( vps_general_hrd_params_present_flag ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;general_hrd_parameters( )</entry><entry/></row><row><entry>&#x2003;&#x2003;if( vps_max_sublayers_minus1 &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;vps_sublayer_cpb_params_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;num_ols_hrd_params_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;for( I = 0; I &#x3c;= num_ols_hrd_params_minus1; i++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if( vps_max_sublayers_minus1 &#x3e; 0 &#x26;&#x26;</entry><entry/></row><row><entry>!vps_all_layers_same_num_sublayers_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;hrd_max_tid[ I ]</entry><entry>u(3)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;firstSubLayer = vps_sublayer_cpb_params_present_flag ? 0 :</entry><entry/></row><row><entry>hrd_max_tid[ I ]</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;ols_hrd_parameters( firstSubLayer, hrd_max_tid[ I ] )</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/></row><row><entry>&#x2003;&#x2003;if( num_ols_hrd_params_minus1 + 1 != TotalNumOlss &#x26;&#x26;</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;num_ols_hrd_params_minus1 &#x3e; 0 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;for( I = 1; I &#x3c; TotalNumOlss; i++ )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( NumLayersInOls[ I ] &#x3e; 1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;ols_hrd_idx[ I ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;}</entry><entry/></row><row><entry>&#x2003;vps_extension_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( vps_extension_flag )</entry><entry/></row><row><entry>&#x2003;&#x2003;while( more_rbsp_data( ) )</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;vps_extension_data_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;rbsp_trailing_bits( )</entry><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0015" level="2">7.4.3.2 Video Parameter Set RBSP Semantics</heading><p id="p-0080" num="0085">A VPS raw byte sequence payload (RBSP) shall be available to the decoding process prior to it being referenced, included in at least one AU with TemporalId equal to 0 or provided through external means. All VPS NAL units with a particular value of vps_video_parameter_set_id in a CVS shall have the same content.<br/>Vps_video_parameter_set_id provides an identifier for the VPS for reference by other syntax elements. The value of vps_video_parameter_set_id shall be greater than 0.<br/>Vps_max_layers_minus1 plus 1 specifies the maximum allowed number of layers in each CVS referring to the VPS.<br/>Vps_max_sublayers_minus1 plus 1 specifies the maximum number of temporal sublayers that may be present in a layer in each CVS referring to the VPS. The value of vps_max_sublayers_minus1 shall be in the range of 0 to 6, inclusive.<br/>Vps_all_layers_same_num_sublayers_flag equal to 1 specifies that the number of temporal sublayers is the same for all the layers in each CVS referring to the VPS. Vps_all_layers_same_num_sublayers_flag equal to 0 specifies that the layers in each CVS referring to the VPS may or may not have the same number of temporal sublayers. When not present, the value of vps_all_layers_same_num_sublayers_flag is inferred to be equal to 1.<br/>Vps_all_independent_layers_flag equal to 1 specifies that all layers in the CVS are independently coded without using inter-layer prediction. Vps_all_independent_layers_flag equal to 0 specifies that one or more of the layers in the CVS may use inter-layer prediction. When not present, the value of vps_all_independent_layers_flag is inferred to be equal to 1.<br/>Vps_layer_id[I] specifies the nuh_layer_id value of the i-th layer. For any two non-negative integer values of m and n, when m is less than n, the value of vps_layer_id[m] shall be less than vps_layer_id[n].<br/>Vps_independent_layer_flag[I] equal to 1 specifies that the layer with index I does not use inter-layer prediction. Vps_independent_layer_flag[I] equal to 0 specifies that the layer with index I may use inter-layer prediction and the syntax elements vps_direct_ref_layer_flag[I][j] for j in the range of 0 to I&#x2212;1, inclusive, are present in VPS. When not present, the value of vps_independent_layer_flag[I] is inferred to be equal to 1.<br/>Vps_direct_ref_layer_flag[I][j] equal to 0 specifies that the layer with index j is not a direct reference layer for the layer with index i. vps_direct_ref_layer_flag [I][j] equal to 1 specifies that the layer with index j is a direct reference layer for the layer with index i. When vps_direct_ref_layer_flag[I][j] is not present for I and j in the range of 0 to vps_max_layers_minus1, inclusive, it is inferred to be equal to 0. When vps_independent_layer_flag[I] is equal to 0, there shall be at least one value of j in the range of 0 to I&#x2212;1, inclusive, such that the value of vps_direct_ref_layer_flag[I][j] is equal to 1.<br/>The variables NumDirectRefLayers[I], DirectRefLayerIdx[I][d], NumRefLayers[I], RefLayerIdx[I][r], and LayerUsedAsRefLayerFlag[j] are derived as follows:</p><p id="p-0081" num="0000"><tables id="TABLE-US-00002" num="00002"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>for( I = 0; I &#x3c;= vps_max_layers_minus1; i++ ) {</entry></row><row><entry>&#x2003;for( j = 0; j &#x3c;= vps_max_layers_minus1; j++ ) {</entry></row><row><entry>&#x2003;&#x2003;dependencyFlag[ I ][ j ] = vps_direct_ref_layer_flag[ I ][ j ]</entry></row><row><entry>&#x2003;&#x2003;for( k = 0; k &#x3c; I; k++ )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( vps_direct_ref_layer_flag[ I ][ k ] &#x26;&#x26; dependencyFlag[ k ][ j ] )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;dependencyFlag[ I ][ j ] = 1</entry></row><row><entry>&#x2003;}</entry></row><row><entry>&#x2003;LayerUsedAsRefLayerFlag[ I ] = 0</entry></row><row><entry>}</entry></row><row><entry>for( I = 0; I &#x3c;= vps_max_layers_minus1; i++ ) {</entry></row><row><entry>&#x2003;for( j = 0, d = 0, r = 0; j &#x3c;= vps_max_layers_minus1; j++ ) {&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;(37)</entry></row><row><entry>&#x2003;&#x2003;if( vps_direct_ref_layer_flag[ I ][ j ] ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;DirectRefLayerIdx[ I ][ d++ ] = j</entry></row><row><entry>&#x2003;&#x2003;&#x2003;LayerUsedAsRefLayerFlag[ j ] = 1</entry></row><row><entry>&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;if( dependencyFlag[ I ][ j ] )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;RefLayerIdx[ I ][ r++ ] = j</entry></row><row><entry>&#x2003;}</entry></row><row><entry>&#x2003;NumDirectRefLayers[ I ] = d</entry></row><row><entry>&#x2003;NumRefLayers[ I ] = r</entry></row><row><entry>}</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>The variable GeneralLayerIdx[I], specifying the layer index of the layer with nuh_layer_id equal to vps_layer_id[I], is derived as follows:</p><p id="p-0082" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>for(<i>I=</i>0;<i>I</i>&#x3c;=vps_max_layers_minus1;<i>i</i>++)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0083" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>GeneralLayerIdx[vps_layer_id[<i>I</i>]]=<i>i</i>&#x2003;&#x2003; (38)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0084" num="0000">For any two different values of I and j, both in the range of 0 to vps_max_layers_minus1, inclusive, when dependencyFlag[I][j] equal to 1, it is a requirement of bitstream conformance that the values of chroma_format_idc and bit_depth_minus8 that apply to the i-th layer shall be equal to the values of chroma_format_idc and bit_depth_minus8, respectively, that apply to the j-th layer.<br/>Max_tid_ref_present_flag[I] equal to 1 specifies that the syntax element max_tid_il_ref_pics_plus1[I] is present. Max_tid_ref_present_flag[I] equal to 0 specifies that the syntax element max_tid_il_ref_pics_plus1[I] is not present.<br/>Max_tid_il_ref_pics_plus1[I] equal to 0 specifies that inter-layer prediction is not used by non-IRAP pictures of the i-th layer. Max_tid_il_ref_pics_plus1[I] greater than 0 specifies that, for decoding pictures of the i-th layer, no picture with TemporalId greater than max_tid_il_ref_pics_plus1[I]&#x2212;1 is used as an inter layer reference picture (ILRP). When not present, the value of max_tid_il_ref_pics_plus1[I] is inferred to be equal to 7.<br/>Each_layer_is_an_ols_flag equal to 1 specifies that each output layer set (OLS) contains only one layer and each layer itself in a CVS referring to the VPS is an OLS with the single included layer being the only output layer. Each_layer_is_an_ols_flag equal to 0 that an OLS may contain more than one layer. If vps_max_layers_minus1 is equal to 0, the value of each_layer_is_an_ols_flag is inferred to be equal to 1.<br/>Otherwise, when vps_all_independent_layers_flag is equal to 0, the value of each_layer_is_an_ols_flag is inferred to be equal to 0.<br/>Ols_mode_idc equal to 0 specifies that the total number of OLSs specified by the VPS is equal to vps_max_layers_minus1+1, the i-th OLS includes the layers with layer indices from 0 to I, inclusive, and for each OLS only the highest layer in the OLS is output.<br/>Ols_mode_idc equal to 1 specifies that the total number of OLSs specified by the VPS is equal to vps_max_layers_minus1+1, the i-th OLS includes the layers with layer indices from 0 to I, inclusive, and for each OLS all layers in the OLS are output.<br/>Ols_mode_idc equal to 2 specifies that the total number of OLSs specified by the VPS is explicitly signalled and for each OLS the output layers are explicitly signalled and other layers are the layers that are direct or indirect reference layers of the output layers of the OLS.<br/>The value of ols_mode_idc shall be in the range of 0 to 2, inclusive. The value 3 of ols_mode_idc is reserved for future use by ITU-T|ISO/IEC.<br/>When vps_all_independent_layers_flag is equal to 1 and each_layer_is_an_ols_flag is equal to 0, the value of ols_mode_idc is inferred to be equal to 2.<br/>Num_output_layer_sets_minus1 plus 1 specifies the total number of OLSs specified by the VPS when ols_mode_idc is equal to 2.<br/>The variable TotalNumOlss, specifying the total number of OLSs specified by the VPS, is derived as follows:</p><p id="p-0085" num="0000"><tables id="TABLE-US-00003" num="00003"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>if( vps_max_layers_minus1 = = 0 )</entry></row><row><entry>&#x2003;TotalNumOlss = 1</entry></row><row><entry>else if( each_layer_is_an_ols_flag | | ols_mode_idc = = 0 | | ols_mode_idc = = 1 )</entry></row><row><entry>&#x2003;TotalNumOlss = vps_max_layers_minus1 + 1&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;(39)</entry></row><row><entry>else if( ols_mode_idc = = 2 )</entry></row><row><entry>&#x2003;TotalNumOlss = num_output_layer_sets_minus1 + 1</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>ols_output_layer_flag[I][j] equal to 1 specifies that the layer with nuh_layer_id equal to vps_layer_id[j] is an output layer of the i-th OLS when ols_mode_idc is equal to 2.<br/>Ols_output_layer_flag[I][j] equal to 0 specifies that the layer with nuh_layer_id equal to vps_layer_id[j] is not an output layer of the i-th OLS when ols_mode_idc is equal to 2.<br/>The variable NumOutputLayersInOls[I], specifying the number of output layers in the i-th OLS, the variable NumSubLayersInLayerInOLS[I][j], specifying the number of sublayers in the j-th layer in the i-th OLS, the variable OutputLayerIdInOls[I][j], specifying the nuh_layer_id value of the j-th output layer in the i-th OLS, and the variable LayerUsedAsOutputLayerFlag[k], specifying whether the k-th layer is used as an output layer in at least one OLS, are derived as follows:</p><p id="p-0086" num="0000"><tables id="TABLE-US-00004" num="00004"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>NumOutputLayersInOls[ 0 ] = 1</entry></row><row><entry>OutputLayerIdInOls[ 0 ][ 0 ] = vps_layer_id[ 0 ]</entry></row><row><entry>NumSubLayersInLayerInOLS[ 0 ][ 0 ] = vps_max_sub_layers_minus1 + 1</entry></row><row><entry>LayerUsedAsOutputLayerFlag[ 0 ] = 1</entry></row><row><entry>for( I = 1, I &#x3c;= vps_max_layers_minus1; i++ ) {</entry></row><row><entry>&#x2003;if( each_layer_is_an_ols_flag | | ols_mode_idc &#x3c; 2 )</entry></row><row><entry>&#x2003;&#x2003;LayerUsedAsOutputLayerFlag[ I ] = 1</entry></row><row><entry>&#x2003;else /*( !each_layer_is_an_ols_flag &#x26;&#x26; ols_mode_idc = = 2 ) */</entry></row><row><entry>&#x2003;&#x2003;LayerUsedAsOutputLayerFlag[ I ] = 0</entry></row><row><entry>}</entry></row><row><entry>for( I = 1; I &#x3c; TotalNumOlss; i++ )</entry></row><row><entry>&#x2003;if( each_layer_is_an_ols_flag | | ols_mode_idc = = 0 ) {</entry></row><row><entry>&#x2003;&#x2003;NumOutputLayersInOls[ I ] = 1</entry></row><row><entry>&#x2003;&#x2003;OutputLayerIdInOls[ I ][ 0 ] = vps_layer_id[ I ]</entry></row><row><entry>&#x2003;&#x2003;for( j = 0; j &#x3c; I &#x26;&#x26; ( ols_mode_idc = = 0 ); j++ )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;NumSubLayersInLayerInOLS[ I ][ j ] = max_tid_il_ref_pics_plus1[ I ]</entry></row><row><entry>&#x2003;&#x2003;NumSubLayersInLayerInOLS[ I ][ I ] = vps_max_sub_layers_minus1 + 1</entry></row><row><entry>&#x2003;} else if( ols_mode_idc = = 1 ) {</entry></row><row><entry>&#x2003;&#x2003;NumOutputLayersInOls[ I ] = I + 1</entry></row><row><entry>&#x2003;&#x2003;for( j = 0; j &#x3c; NumOutputLayersInOls[ I ]; j++ ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;OutputLayerIdInOls[ I ][ j ] = vps_layer_id[ j ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;NumSubLayersInLayerInOLS[ I ][ j ] = vps_max_sub_layers_minus1 + 1</entry></row><row><entry>&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;} else if( ols_mode_idc = = 2 ) {</entry></row><row><entry>&#x2003;&#x2003;for( j = 0; j &#x3c;= vps_max_layers_minus1; j++ ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;layerIncludedInOlsFlag[ I ][ j ] = 0</entry></row><row><entry>&#x2003;&#x2003;&#x2003;NumSubLayersInLayerInOLS[ I ][ j ] = 0</entry></row><row><entry>&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;for( k = 0, j = 0; k &#x3c;= vps_max_layers_minus1; k++ )&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;(40)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( ols_output_layer_flag[ I ][ k ] ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;layerIncludedInOlsFlag[ I ][ k ] = 1</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;LayerUsedAsOutputLayerFlag[ k ] = 1</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;OutputLayerIdx[ I ][ j ] = k</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;OutputLayerIdInOls[ I ][ j++ ] = vps_layer_id[ k ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;NumSubLayersInLayerInOLS[ I ][ j ] = vps_max_sub_layers_minus1 + 1</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;NumOutputLayersInOls[ I ] = j</entry></row><row><entry>&#x2003;&#x2003;for( j = 0; j &#x3c; NumOutputLayersInOls[ I ]; j++ ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;idx = OutputLayerIdx[ I ][ j ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( k = 0; k &#x3c; NumRefLayers[ idx ]; k++ ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;layerIncludedInOlsFlag[ I ][ RefLayerIdx[ idx ][ k ] ] = 1</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( NumSubLayersInLayerInOLS[ I ][ RefLayerIdx[ idx ][ k ] ] &#x3c;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;max_tid_il_ref_pics_plus1[ OutputLayerIdInOls[ I ][ j ] ] )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;NumSubLayersInLayerInOLS[ I ][ RefLayerIdx[ idx ][ k ] ] =</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;max_tid_il_ref_pics_plus1[ OutputLayerIdInOls[ I ][ j ] ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;}</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>For each value of I in the range of 0 to vps_max_layers_minus1, inclusive, the values of LayerUsedAsRefLayerFlag[I] and LayerUsedAsOutputLayerFlag[I] shall not be both equal to 0. In other words, there shall be no layer that is neither an output layer of at least one OLS nor a direct reference layer of any other layer.<br/>For each OLS, there shall be at least one layer that is an output layer. In other words, for any value of I in the range of 0 to TotalNumOlss&#x2212;1, inclusive, the value of NumOutputLayersInOls[I] shall be greater than or equal to 1.<br/>The variable NumLayersInOls[I], specifying the number of layers in the i-th OLS, and the variable LayerIdInOls[I][j], specifying the nuh_layer_id value of the j-th layer in the i-th OLS, are derived as follows:</p><p id="p-0087" num="0000"><tables id="TABLE-US-00005" num="00005"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="287pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;NumLayersInOls[ 0 ] = 1</entry></row><row><entry>&#x2003;LayerIdInOls[ 0 ][ 0 ] = vps_layer_id[ 0 ]</entry></row><row><entry>&#x2003;for( I = 1; I &#x3c; TotalNumOlss; i++ ) {</entry></row><row><entry>&#x2003;&#x2003;if( each_layer_is_an_ols_flag ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;NumLayersInOls[ I ] = 1</entry></row><row><entry>&#x2003;&#x2003;&#x2003;LayerIdInOls[ I ][ 0 ] = vps_layer_id[ I ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;(41)</entry></row><row><entry>&#x2003;&#x2003;} else if( ols_mode_idc = = 0 | | ols_mode_idc = = 1 ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;NumLayersInOls[ I ] = I + 1</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c; NumLayersInOls[ I ]; j++ )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;LayerIdInOls[ I ][ j ] = vps_layer_id[ j ]</entry></row><row><entry>&#x2003;&#x2003;} else if( ols_mode_idc = = 2 ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( k = 0, j = 0; k &#x3c;= vps_max_layers_minus1; k++ )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( layerIncludedInOlsFlag[ I ][ k ] )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;LayerIdInOls[ I ][ j++ ] = vps_layer_id[ k ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;NumLayersInOls[ I ] = j</entry></row><row><entry>&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;}</entry></row><row><entry>NOTE 1 - The 0-th OLS contains only the lowest layer (i.e., the layer with nuh_layer_id equal to</entry></row><row><entry>vps_layer_id[ 0 ]) and for the 0-th OLS the only included layer is output.</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>The variable OlsLayerIdx[I][j], specifying the OLS layer index of the layer with nuh_layer_id equal to LayerIdInOls[I][j], is derived as follows:</p><p id="p-0088" num="0000"><tables id="TABLE-US-00006" num="00006"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="21pt" align="left"/><colspec colname="1" colwidth="196pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>for( I = 0; I &#x3c; TotalNumOlss; i++ )</entry></row><row><entry/><entry>&#x2003;for j = 0; j &#x3c; NumLayersInOls[ I ]; j++ )&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;(42)</entry></row><row><entry/><entry>&#x2003;&#x2003;OlsLayerIdx[ I ][ LayerIdInOls[ I ][ j ] ] = j</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>The lowest layer in each OLS shall be an independent layer. In other words, for each I in the range of 0 to TotalNumOlss&#x2212;1, inclusive, the value of vps_independent_layer_flag[GeneralLayerIdx[LayerIdInOls[I][0]]] shall be equal to 1.<br/>Each layer shall be included in at least one OLS specified by the VPS. In other words, for each layer with a particular value of nuh_layer_id nuhLayerId equal to one of vps_layer_id[k] for k in the range of 0 to vps_max_layers_minus1, inclusive, there shall be at least one pair of values of I and j, where I is in the range of 0 to TotalNumOlss&#x2212;1, inclusive, and j is in the range of NumLayersInOls[I]&#x2212;1, inclusive, such that the value of LayerIdInOls[I][j] is equal to nuhLayerId.<br/>Vps_num_ptls_minus1 plus 1 specifies the number of profile_tier_level( ) syntax structures in the VPS. The value of vps_num_ptls_minus1 shall be less than TotalNumOlss.<br/>Pt_present_flag[I] equal to 1 specifies that profile, tier, and general constraints information are present in the i-th profile_tier_level( ) syntax structure in the VPS. Pt_present_flag[I] equal to 0 specifies that profile, tier, and general constraints information are not present in the i-th profile_tier_level( ) syntax structure in the VPS. The value of pt_present_flag[0] is inferred to be equal to 1. When pt_present_flag[I] is equal to 0, the profile, tier, and general constraints information for the i-th profile_tier_level( ) syntax structure in the VPS are inferred to be the same as that for the (I&#x2212;1)-th profile_tier_level( ) syntax structure in the VPS.<br/>Ptl_max_temporal_id[I] specifies the TemporalId of the highest sublayer representation for which the level information is present in the i-th profile_tier_level( ) syntax structure in the VPS. The value of ptl_max_temporal_id[I] shall be in the range of 0 to vps_max_sublayers_minus1, inclusive. When vps_max_sublayers_minus1 is equal to 0, the value of ptl_max_temporal_id[I] is inferred to be equal to 0. When vps_max_sublayers_minus1 is greater than 0 and vps_all_layers_same_num_sublayers_flag is equal to 1, the value of ptl_max_temporal_id[I] is inferred to be equal to vps_max_sublayers_minus1.<br/>Vps_ptl_alignment_zero_bit shall be equal to 0.<br/>Ols_ptl_idx[I] specifies the index, to the list of profile_tier_level( ) syntax structures in the VPS, of the profile_tier_level( ) syntax structure that applies to the i-th OLS. When present, the value of ols_ptl_idx[I] shall be in the range of 0 to vps_num_ptls_minus1, inclusive. When vps_num_ptls_minus1 is equal to 0, the value of ols_ptl_idx[I] is inferred to be equal to 0.<br/>When NumLayersInOls[I] is equal to 1, the profile_tier_level( ) syntax structure that applies to the i-th OLS is also present in the SPS referred to by the layer in the i-th OLS. It is a requirement of bitstream conformance that, when NumLayersInOls[I] is equal to 1, the profile_tier_level( ) syntax structures signalled in the VPS and in the SPS for the i-th OLS shall be identical.<br/>Vps_num_dpb_params specifies the number of dpb_parameters( ) syntax structures in the VPS. The value of vps_num_dpb_params shall be in the range of 0 to 16, inclusive. When not present, the value of vps_num_dpb_params is inferred to be equal to 0.<br/>Vps_sublayer_dpb_params_present_flag is used to control the presence of max_dec_pic_buffering_minus1[ ], max_num_reorder_pics[ ], and max_latency_increase_plus1[ ] syntax elements in the dpb_parameters( ) syntax structures in the VPS. When not present, vps_sub_dpb_params_info_present_flag is inferred to be equal to 0.<br/>Dpb_max_temporal_id[I] specifies the TemporalId of the highest sublayer representation for which the DPB parameters may be present in the i-th dpb_parameters( ) syntax structure in the VPS. The value of dpb_max_temporal_id[I] shall be in the range of 0 to vps_max_sublayers_minus1, inclusive. When vps_max_sublayers_minus1 is equal to 0, the value of dpb_max_temporal_id[I] is inferred to be equal to 0. When vps_max_sublayers_minus1 is greater than 0 and vps_all_layers_same_num_sublayers_flag is equal to 1, the value of dpb_max_temporal_id[I] is inferred to be equal to vps_max_sublayers_minus1.<br/>Ols_dpb_pic_width[I] specifies the width, in units of luma samples, of each picture storage buffer for the i-th OLS.<br/>Ols_dpb_pic_height[I] specifies the height, in units of luma samples, of each picture storage buffer for the i-th OLS.<br/>Ols_dpb_params_idx[I] specifies the index, to the list of dpb_parameters( ) syntax structures in the VPS, of the dpb_parameters( ) syntax structure that applies to the i-th OLS when NumLayersInOls[I] is greater than 1. When present, the value of ols_dpb_params_idx[I] shall be in the range of 0 to vps_num_dpb_params&#x2212;1, inclusive. When ols_dpb_params_idx[I] is not present, the value of ols_dpb_params_idx[I] is inferred to be equal to 0.<br/>When NumLayersInOls[I] is equal to 1, the dpb_parameters( ) syntax structure that applies to the i-th OLS is present in the SPS referred to by the layer in the i-th OLS.<br/>Vps_general_hrd_params_present_flag equal to 1 specifies that the VPS contains a general_hrd_parameters( ) syntax structure and other hypothetical reference decoder (HRD) parameters. Vps_general_hrd_params_present_flag equal to 0 specifies that the VPS does not contain a general_hrd_parameters( ) syntax structure or other HRD parameters. When not present, the value of vps_general_hrd_params_present_flag is inferred to be equal to 0.<br/>When NumLayersInOls[I] is equal to 1, the general_hrd_parameters( ) syntax structure and the ols_hrd_parameters( ) syntax structure that apply to the i-th OLS are present in the SPS referred to by the layer in the i-th OLS.<br/>Vps_sublayer_cpb_params_present_flag equal to 1 specifies that the i-th ols_hrd_parameters( ) syntax structure in the VPS contains HRD parameters for the sublayer representations with TemporalId in the range of 0 to hrd_max_tid[I], inclusive. Vps_sublayer_cpb_params_present_flag equal to 0 specifies that the i-th ols_hrd_parameters( ) syntax structure in the VPS contains HRD parameters for the sublayer representation with TemporalId equal to hrd_max_tid[I] only. When vps_max_sublayers_minus1 is equal to 0, the value of vps_sublayer_cpb_params_present_flag is inferred to be equal to 0.<br/>When vps_sublayer_cpb_params_present_flag is equal to 0, the HRD parameters for the sublayer representations with TemporalId in the range of 0 to hrd_max_tid[I]&#x2212;1, inclusive, are inferred to be the same as that for the sublayer representation with TemporalId equal to hrd_max_tid[I]. These include the HRD parameters starting from the fixed_pic_rate_general_flag[I] syntax element till the sublayer_hrd_parameters(I) syntax structure immediately under the condition &#x201c;if(general_vcl_hrd_params_present_flag)&#x201d; in the ols_hrd_parameters syntax structure.<br/>Num_ols_hrd_params_minus1 plus 1 specifies the number of ols_hrd_parameters( ) syntax structures present in the VPS when vps_general_hrd_params_present_flag is equal to 1. The value of num_ols_hrd_params_minus1 shall be in the range of 0 to TotalNumOlss&#x2212;1, inclusive.<br/>Hrd_max_tid[I] specifies the TemporalId of the highest sublayer representation for which the HRD parameters are contained in the i-th ols_hrd_parameters( ) syntax structure. The value of hrd_max_tid[I] shall be in the range of 0 to vps_max_sublayers_minus1, inclusive. When vps_max_sublayers_minus1 is equal to 0, the value of hrd_max_tid[I] is inferred to be equal to 0. When vps_max_sublayers_minus1 is greater than 0 and vps_all_layers_same_num_sublayers_flag is equal to 1, the value of hrd_max_tid[I] is inferred to be equal to vps_max_sublayers_minus1.<br/>Ols_hrd_idx[I] specifies the index, to the list of ols_hrd_parameters( ) syntax structures in the VPS, of the ols_hrd_parameters( ) syntax structure that applies to the i-th OLS when NumLayersInOls[I] is greater than 1. The value of ols_hrd_idx[[I] shall be in the range of 0 to num_ols_hrd_params_minus1, inclusive.<br/>When NumLayersInOls[I] is equal to 1, the ols_hrd_parameters( ) syntax structure that applies to the i-th OLS is present in the SPS referred to by the layer in the i-th OLS.<br/>If the value of num_ols_hrd_param_minus1+1 is equal to TotalNumOlss, the value of ols_hrd_idx[I] is inferred to be equal to i. Otherwise, when NumLayersInOls[I] is greater than 1 and num_ols_hrd_params_minus1 is equal to 0, the value of ols_hrd_idx[[I] is inferred to be equal to 0.<br/>Vps_extension_flag equal to 0 specifies that no vps_extension_data_flag syntax elements are present in the VPS RBSP syntax structure. Vps_extension_flag equal to 1 specifies that there are vps_extension_data_flag syntax elements present in the VPS RBSP syntax structure.<br/>Vps_extension_data flag may have any value. Its presence and value do not affect decoder conformance to profiles specified in this version of this Specification. Decoders conforming to this version of this Specification shall ignore all vps_extension_data_flag syntax elements.</p><heading id="h-0016" level="1">3.6. Access Unit Delimiter (AUD) Syntax and Semantics in VVC</heading><p id="p-0089" num="0086">In the latest VVC text (in JVET-Q2001-Ve/v15), the AUD syntax and semantics are as follows.</p><heading id="h-0017" level="2">7.3.2.9 AU Delimiter RBSP Syntax</heading><p id="p-0090" num="0087"></p><p id="p-0091" num="0000"><tables id="TABLE-US-00007" num="00007"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="91pt" align="left"/><colspec colname="2" colwidth="91pt" align="center"/><thead><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>access_unit_delimiter_rbsp( ) {</entry><entry>Descriptor</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2003;pictype</entry><entry>u(3)</entry></row><row><entry/><entry>&#x2003;rbsp_trailing_bits( )</entry><entry/></row><row><entry/><entry>}</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0018" level="2">7.4.3.9 AU Delimiter RBSP Semantics</heading><p id="p-0092" num="0088">The AU delimiter is used to indicate the start of an AU and the type of slices present in the coded pictures in the AU containing the AU delimiter NAL unit. There is no normative decoding process associated with the AU delimiter.<br/>Pic_type indicates that the slice type values for all slices of the coded pictures in the AU containing the AU delimiter NAL unit are members of the set listed in Table 7 for the given value of pic_type. The value of pic_type shall be equal to 0, 1 or 2 in bitstreams conforming to this version of this Specification. Other values of pic_type are reserved for future use by ITU-T|ISO/IEC. Decoders conforming to this version of this Specification shall ignore reserved values of pic_type.</p><p id="p-0093" num="0000"><tables id="TABLE-US-00008" num="00008"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 7</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Interpretation of pic_type</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="42pt" align="left"/><colspec colname="1" colwidth="63pt" align="left"/><colspec colname="2" colwidth="112pt" align="left"/><tbody valign="top"><row><entry/><entry/><entry>slice_type values that</entry></row><row><entry/><entry>pic_type</entry><entry>may be present in the AU</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>0</entry><entry>I</entry></row><row><entry/><entry>1</entry><entry>P, I</entry></row><row><entry/><entry>2</entry><entry>B, P, I</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0019" level="1">3.7. Order of Aus and PUs</heading><p id="p-0094" num="0089">In the latest VVC text (in JVET-Q2001-Ve/v15), the specification of the decoding order of Aus and PUs is as follows.</p><p id="p-0095" num="0000">7.4.2.4.2 Order of Aus and their Association to CVSs<br/>A bitstream consists of one or more CVSs.<br/>A CVS consists of one or more Aus. The order of PUs and their association to Aus are described in clause 7.4.2.4.3.<br/>The first AU of a CVS is a CVSS AU, wherein each present PU is a CLVSS PU, which is either an IRAP PU with NoOutputBeforeRecoveryFlag equal to 1 or a GDR PU with NoOutputBeforeRecoveryFlag equal to 1.<br/>Each CVSS AU shall have a PU for each of the layers present in the CVS.<br/>7.4.2.4.3 Order of PUs and their Association to Aus<br/>An AU consists of one or more PUs in increasing order of nuh_layer_id. The order NAL units and coded pictures and their association to PUs are described in clause 7.4.2.4.4.<br/>There can be at most one AUD NAL unit in an AU. When an AUD NAL unit is present in an AU, it shall be the first NAL unit of the AU, and consequently, it is the first NAL unit of the first PU of the AU.<br/>There can be at most one end of bitstream (EOB) NAL unit in an AU. When an EOB NAL unit is present in an AU, it shall be the last NAL unit of the AU, and consequently, it is the last NAL unit of the last PU of the AU.<br/>A VCL NAL unit is the first VCL NAL unit of an AU (and consequently the PU containing the VCL NAL unit is the first PU of the AU) when the VCL NAL unit is the first VCL NAL unit that follows a picture header (PH) NAL unit and one or more of the following conditions are true:<ul id="ul0003" list-style="none">    <li id="ul0003-0001" num="0000">    <ul id="ul0004" list-style="none">        <li id="ul0004-0001" num="0090">The value of nuh_layer_id of the VCL NAL unit is less than the nuh_layer_id of the previous picture in decoding order.</li>        <li id="ul0004-0002" num="0091">The value of ph_pic_order_cnt_lsb of the VCL NAL unit differs from the ph_pic_order_cnt_lsb of the previous picture in decoding order.</li>        <li id="ul0004-0003" num="0092">PicOrderCntVal derived for the VCL NAL unit differs from the PicOrderCntVal of the previous picture in decoding order.<br/>Let firstVclNalUnitInAu be the first VCL NAL unit of an AU. The first of any of the following NAL units preceding firstVclNalUnitInAu and succeeding the last VCL NAL unit preceding firstVclNalUnitInAu, if any, specifies the start of a new AU:</li>        <li id="ul0004-0004" num="0093">AUD NAL unit (when present),</li>        <li id="ul0004-0005" num="0094">Decoding Capability Information (DCI) NAL unit (when present),</li>        <li id="ul0004-0006" num="0095">VPS NAL unit (when present),</li>        <li id="ul0004-0007" num="0096">SPS NAL unit (when present),</li>        <li id="ul0004-0008" num="0097">PPS NAL unit (when present),</li>        <li id="ul0004-0009" num="0098">Prefix APS NAL unit (when present),</li>        <li id="ul0004-0010" num="0099">PH NAL unit (when present),</li>        <li id="ul0004-0011" num="0100">Prefix SEI NAL unit (when present),</li>        <li id="ul0004-0012" num="0101">NAL unit with nal_unit_type equal to RSV_NVCL_26 (when present),</li>        <li id="ul0004-0013" num="0102">NAL unit with nal_unit_type in the range of UNSPEC28 . . . UNSPEC29 (when present).</li>        <li id="ul0004-0014" num="0103">NOTE&#x2014;The first NAL unit preceding firstVclNalUnitInAu and succeeding the last VCL NAL unit preceding firstVclNalUnitInAu, if any, can only be one of the above-listed NAL units.<br/>It is a requirement of bitstream conformance that, when present, the next PU of a particular layer after a PU that belongs to the same layer and contains an end of sequence (EOS) NAL unit shall be a CLVSS PU, which is either an IRAP PU with NoOutputBeforeRecoveryFlag equal to 1 or a GDR PU with NoOutputBeforeRecoveryFlag equal to 1.</li>    </ul>    </li></ul></p><heading id="h-0020" level="1">4. EXAMPLES OF TECHNICAL PROBLEMS SOLVED BY DISCLOSED TECHNICAL SOLUTIONS</heading><p id="p-0096" num="0104">The existing scalability design in the latest VVC text (in JVET-Q2001-Ve/v15) has the following problems:<ul id="ul0005" list-style="none">    <li id="ul0005-0001" num="0000">    <ul id="ul0006" list-style="none">        <li id="ul0006-0001" num="0105">1) A CVSS AU, which starts a new CVS, is required to be complete (i.e., to have a picture for each of the layers present in the CVS). However, according to the current design, the decoder is not able to check whether an AU includes a picture &#x201c;for each of the layers present in the CVS&#x201d; before it receives the last picture of the CVS, while on the other hand, even the last picture of the CVS is not easy to be determined because it is not easy to determine the start of any of CVS except for the very first CVS of the bitstream. Basically, that means, the decoder can only figure out the boundaries of CVSs after receiving the entire bitstream.</li>        <li id="ul0006-0002" num="0106">2) Currently, an IRAP AU may start a new CVS and is required to be complete (i.e., to have a picture for each of the layers present in the CVS), while a GDR AU may also start a new CVS but is NOT required to be complete. This basically disables random accessing a bitstream starting from a GDR AU that is not complete in a conforming manner, because usually the starting AU in random accessing would become a CVSS AU but when such a GDR AU is incomplete it cannot be a CVSS AU.</li>    </ul>    </li></ul></p><heading id="h-0021" level="1">5. EXAMPLE EMBODIMENTS AND TECHNIQUES</heading><p id="p-0097" num="0107">To solve the above problems, and others, methods as summarized below are disclosed. The embodiments should be considered as examples to explain the general concepts and should not be interpreted in a narrow way. Furthermore, these embodiments can be applied individually or combined in any manner.</p><heading id="h-0022" level="2">Solutions for Solving the First Problem</heading><p id="p-0098" num="0000"><ul id="ul0007" list-style="none">    <li id="ul0007-0001" num="0000">    <ul id="ul0008" list-style="none">        <li id="ul0008-0001" num="0108">1) To solve the first problem, an indication of whether an AU is complete, in the sense whether it includes a picture for each of the layers present in the CVS, may be signaled.        <ul id="ul0009" list-style="none">            <li id="ul0009-0001" num="0109">a. In one example, the indication is signaled only for Aus that may start a new CVS.            <ul id="ul0010" list-style="none">                <li id="ul0010-0001" num="0110">i. In one example, furthermore, the indication is signaled only for Aus for which each picture is an IRAP or GDR picture.</li>            </ul>            </li>            <li id="ul0009-0002" num="0111">b. In one example, the indication is signaled in the AUD NAL unit.            <ul id="ul0011" list-style="none">                <li id="ul0011-0001" num="0112">i. In one example, the indication is signaled by a flag (e.g., irap_or_gdr_au_flag) in the AUD NAL unit.                <ul id="ul0012" list-style="none">                    <li id="ul0012-0001" num="0113">1. Alternatively, additionally, when irap_or_gdr_au_flag is equal to 1, a flag (i.e., named irap_au_flag) may be signalled in the AUD to specify whether the AU is an IRAP AU or a GDR AU (irap_au_flag equal to 1 specifies that the AU is an IRAP AU, and irap_au_flag equal to 0 specifies that the AU is a GDR AU). No value of irap_au_flag is inferred when it is not present.</li>                </ul>                </li>                <li id="ul0011-0002" num="0114">ii. In one example, furthermore, one and only one AUD NAL unit is required to be present in each IRAP or GDR AU when vps_max_layers_minus1 is greater than 0.                <ul id="ul0013" list-style="none">                    <li id="ul0013-0001" num="0115">1. Alternatively, one and only one AUD NAL unit is required to be present in each IRAP or GDR AU regardless of the value of vps_max_layers_minus1.</li>                </ul>                </li>                <li id="ul0011-0003" num="0116">iii. In one example, the flag equal to 1 specifies that all slices in the AU have the same NAL unit type in the range of IDR_W_RADL to GDR_NUT, inclusive. Consequently, if the NAL unit type is IDR_W_RADL or IDR_N_LP and this flag is equal to 1, the AU is a CVSS AU. Otherwise (the NAL unit type is CRA_NUT or GDR_NUT), the AU is a CVSS AU when the variable NoOutputBeforeRecoveryFlag for each of the pictures in the AU is equal to 1.</li>            </ul>            </li>            <li id="ul0009-0003" num="0117">c. In one example, furthermore, it is required that each picture in an AU in a CVS shall have nuh_layer_id equal to the nuh_layer_id of one of the pictures present in the first AU of the CVS.</li>            <li id="ul0009-0004" num="0118">d. In one example, the indication is signaled in the NAL unit header.            <ul id="ul0014" list-style="none">                <li id="ul0014-0001" num="0119">i. In one example, use a bit in the NAL unit header, e.g., nuh_reserved_zero_bit, to specify whether the AU is complete.</li>            </ul>            </li>            <li id="ul0009-0005" num="0120">e. In one example, the indication is signaled in a new NAL unit.            <ul id="ul0015" list-style="none">                <li id="ul0015-0001" num="0121">i. In one example, furthermore, the presence of one and only one of the new NAL unit in each IRAP or GDR AU is required when vps_max_layers_minus1 is greater than 0.                <ul id="ul0016" list-style="none">                    <li id="ul0016-0001" num="0122">1. In one example, furthermore, when present in an AU, the new NAL unit shall precede any NAL unit other than the AUD NAL unit, when present, in the AU in decoding order.</li>                    <li id="ul0016-0002" num="0123">2. Alternatively, the presence of one and only one of the new NAL unit in each IRAP or GDR AU is required regardless of the value of vps_max_layers_minus1.</li>                </ul>                </li>            </ul>            </li>            <li id="ul0009-0006" num="0124">f. In one example, the indication is signaled in an SEI message.            <ul id="ul0017" list-style="none">                <li id="ul0017-0001" num="0125">i. In one example, furthermore, the presence of the SEI message in each IRAP or GDR AU is required when vps_max_layers_minus1 is greater than 0.                <ul id="ul0018" list-style="none">                    <li id="ul0018-0001" num="0126">1. In one example, furthermore, when present in an AU, the SEI NAL unit containing the SEI message shall precede any NAL unit other than the AUD NAL unit, when present, in the AU in decoding order.</li>                    <li id="ul0018-0002" num="0127">2. Alternatively, the presence of the SEI message in each IRAP or GDR AU is required regardless of the value of vps_max_layers_minus1.</li>                </ul>                </li>            </ul>            </li>        </ul>        </li>        <li id="ul0008-0002" num="0128">2) Alternatively, to solve the first problem, an indication of whether an AU starts a new CVS may be signaled.        <ul id="ul0019" list-style="none">            <li id="ul0019-0001" num="0129">a. In one example, the indication is signaled in the AUD NAL unit.            <ul id="ul0020" list-style="none">                <li id="ul0020-0001" num="0130">i. In one example, the indication is signaled by a flag (e.g., irap_or_gdr_au_flag) in the AUD NAL unit.                <ul id="ul0021" list-style="none">                    <li id="ul0021-0001" num="0131">1. Alternatively, additionally, when irap_or_gdr_au_flag is equal to 1, a flag (i.e., named irap_au_flag) may be signalled in the AUD to specify whether the AU is an IRAP AU or a GDR AU (irap_au_flag equal to 1 specifies that the AU is an IRAP AU, and irap_au_flag equal to 0 specifies that the AU is a GDR AU). No value of irap_au_flag is inferred when it is not present.</li>                </ul>                </li>                <li id="ul0020-0002" num="0132">ii. In one example, furthermore, one and only one AUD NAL unit is required to be present in each CVSS AU when vps_max_layers_minus1 is greater than 0.                <ul id="ul0022" list-style="none">                    <li id="ul0022-0001" num="0133">1. Alternatively, one and only one AUD NAL unit is required to be present in each CVSS AU regardless of the value of vps_max_layers_minus1.</li>                </ul>                </li>            </ul>            </li>            <li id="ul0019-0002" num="0134">b. In one example, the indication is signaled in the NAL unit header.            <ul id="ul0023" list-style="none">                <li id="ul0023-0001" num="0135">i. In one example, use a bit in the NAL unit header, e.g., nuh_reserved_zero_bit, to specify whether the AU is a CVSS AU.</li>            </ul>            </li>            <li id="ul0019-0003" num="0136">c. In one example, the indication is signaled in a new NAL unit.            <ul id="ul0024" list-style="none">                <li id="ul0024-0001" num="0137">i. In one example, furthermore, the presence of one and only one of the new NAL unit in each CVSS AU is required when vps_max_layers_minus1 is greater than 0.                <ul id="ul0025" list-style="none">                    <li id="ul0025-0001" num="0138">1. In one example, furthermore, when present in an AU, the new NAL unit shall precede any NAL unit other than the AUD NAL unit, when present, in the AU in decoding order.</li>                    <li id="ul0025-0002" num="0139">2. Alternatively, the presence of one and only one of the new NAL unit in each CVSS AU is required regardless of the value of vps_max_layers_minus1.</li>                </ul>                </li>                <li id="ul0024-0002" num="0140">ii. In one example, the presence of the new NAL unit in an AU specifies that the AU is a CVSS AU.                <ul id="ul0026" list-style="none">                    <li id="ul0026-0001" num="0141">1. Alternatively, a flag is included in the new NAL unit to specify whether the AU is a CVSS AU.</li>                </ul>                </li>            </ul>            </li>            <li id="ul0019-0004" num="0142">d. In one example, the indication is signaled in an SEI message.            <ul id="ul0027" list-style="none">                <li id="ul0027-0001" num="0143">i. In one example, furthermore, the presence of the SEI message in each CVSS AU is required when vps_max_layers_minus1 is greater than 0.                <ul id="ul0028" list-style="none">                    <li id="ul0028-0001" num="0144">1. In one example, furthermore, when present in an AU, the SEI NAL unit containing the SEI message shall precede any NAL unit other than the AUD NAL unit, when present, in the AU in decoding order.</li>                </ul>                </li>            </ul>            </li>        </ul>        </li>        <li id="ul0008-0003" num="0145">2. Alternatively, the presence of the SEI message in each CVSS AU is required regardless of the value of vps_max_layers_minus1.</li>        <li id="ul0008-0004" num="0146">3) Alternatively, to solve the first problem, a CVSS AU, which starts a new CVS, is required to have a picture for each of the layers specified by the VPS. Note that a shortcoming of this approach is that then the number of layers signaled in the VPS needs to be precise, and consequently when a layer is removed from the bitstream the VPS needs to be modified.</li>        <li id="ul0008-0005" num="0147">4) Alternatively, to solve the first problem, when vps_max_layers_minus1 is greater than 0, mandate the presence of the EOS NAL unit for each picture in the last AU of each CVS, and optionally also the presence of the EOB NAL unit in the last AU of each bitstream. Thus each CVSS AU would be identified by either being the first AU in the bitstream or the presence of the EOS NAL units in the previous AU.</li>        <li id="ul0008-0006" num="0148">5) Alternatively, to solve the first problem, an external-means-determined variable is specified to specify whether an AU is a CVSS AU.</li>    </ul>    </li></ul></p><heading id="h-0023" level="2">Solutions for Solving the Second Problem</heading><p id="p-0099" num="0000"><ul id="ul0029" list-style="none">    <li id="ul0029-0001" num="0000">    <ul id="ul0030" list-style="none">        <li id="ul0030-0001" num="0149">6) To solve the second problem, it is required that each GDR AU is required to be complete (i.e., to have a picture for each of the layers present in the CVS). That means, an AU consisting of GDR pictures but if it is incomplete then it is not a GDR AU, similarly as currently that an AU consisting of IRAP pictures but if it is incomplete then it is not an IRAP AU.        <ul id="ul0031" list-style="none">            <li id="ul0031-0001" num="0150">a. In one example, a GDR AU may be defined as an AU in which there is a PU for each layer in the CVS and the coded picture in each present PU is a GDR picture.</li>        </ul>        </li>    </ul>    </li></ul></p><heading id="h-0024" level="1">6. EMBODIMENTS</heading><p id="p-0100" num="0151">Below are some example embodiments for some of the aspects summarized above in Section 5, which can be applied to the VVC specification. The changed texts are based on the latest VVC text in JVET-Q2001-Ve v15. Most relevant parts that have been added or modified are shown in underline, bolded and italicized text, and the most relevant removed parts are highlighted in enclosed in bolded double brackets, e.g., [[a]] indicates that &#x201c;a&#x201d; has been removed. There are some other changes that are editorial in nature and thus not highlighted.</p><heading id="h-0025" level="1">6.1. First Embodiment</heading><p id="p-0101" num="0152">This embodiment is for items 1, 1.a, 1.a.i, 1.b, 1.b.i, 1.b.ii, 1.b.iii, 1.c, 6, and 6a.</p><heading id="h-0026" level="1">3 Definitions</heading><p id="p-0102" num="0153">. . .<ul id="ul0032" list-style="none">    <li id="ul0032-0001" num="0000">    <ul id="ul0033" list-style="none">        <li id="ul0033-0001" num="0154">gradual decoding refresh (GDR) AU: An AU in which there is a PU for each layer in the CVS and the coded picture in each present PU is a GDR picture.<br/>. . .</li>    </ul>    </li></ul></p><heading id="h-0027" level="2">7.3.2.9 AU Delimiter RBSP Syntax</heading><p id="p-0103" num="0155"></p><p id="p-0104" num="0000"><tables id="TABLE-US-00009" num="00009"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="91pt" align="left"/><colspec colname="2" colwidth="91pt" align="center"/><thead><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry>access_unit_delimiter_rbsp( ) {</entry><entry>Descriptor</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x2003;irap_or_sdr_au_flag</entry><entry>u(1)</entry></row><row><entry/><entry>&#x2003;pic_type</entry><entry>u(3)</entry></row><row><entry/><entry>&#x2003;rbsp_trailing_bits( )</entry><entry/></row><row><entry/><entry>}</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0028" level="2">7.4.3.9 AU Delimiter RBSP Semantics</heading><p id="p-0105" num="0156">The AU delimiter is used to indicate the start of an AU, whether the AU is an IRAP or GDRAU, and the type of slices present in the coded pictures in the AU containing the AU delimiter NAL unit. For single-layer bitstreams, there is no normative decoding process associated with the AU delimiter.<br/>Irap_or_gdr_au_flag equal to 1 specifies that the AU containing the AU delimiter is an IRAP or GDR AU. Irap_or_gdr_au_flag equal to 0 specifies that the AU containing the AU delimiter is not an IRAP or GDR AU.<br/>. . .<br/>7.4.2.4.2 Order of Aus and their Association to CVSs<br/>A bitstream consists of one or more CVSs.<br/>A CVS consists of one or more Aus. The order of PUs and their association to Aus are described in clause 7.4.2.4.3.<br/>The first AU of a CVS is a CVSS AU, wherein each present PU is a CLVSS PU, which is either an IRAP PU with NoOutputBeforeRecoveryFlag equal to 1 or a GDR PU with NoOutputBeforeRecoveryFlag equal to 1.<br/>Each CVSS AU shall have a PU for each of the layers present in the CVS and each picture in an AU in a CVS shall have nuh_layer_id equal to the nuh_layer_id of one of the pictures present in the first AU of the CVS.<br/>7.4.2.4.3 Order of PUs and their Association to Aus<br/>An AU consists of one or more PUs in increasing order of nuh_layer_id. The order NAL units and coded pictures and their association to PUs are described in clause 7.4.2.4.4.<br/>There can be at most one AUD NAL unit in an AU, and when vps_max_layers_minus1 is greater than 0, there shall be one and only one AUD NAL unit in each IRAP or GDR AU.<br/>When an AUD NAL unit is present in an AU, it shall be the first NAL unit of the AU, and consequently, it is the first NAL unit of the first PU of the AU.<br/>There can be at most one EOB NAL unit in an AU. When an EOB NAL unit is present in an AU, it shall be the last NAL unit of the AU, and consequently, it is the last NAL unit of the last PU of the AU.<br/>. . .</p><p id="p-0106" num="0157"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram showing an example video processing system <b>1000</b> in which various techniques disclosed herein may be implemented. Various implementations may include some or all of the components of the system <b>1000</b>. The system <b>1000</b> may include input <b>1002</b> for receiving video content. The video content may be received in a raw or uncompressed format, e.g., 8 or 10 bit multi-component pixel values, or may be in a compressed or encoded format. The input <b>1002</b> may represent a network interface, a peripheral bus interface, or a storage interface. Examples of network interface include wired interfaces such as Ethernet, passive optical network (PON), etc. and wireless interfaces such as wireless fidelity (Wi-Fi) or cellular interfaces.</p><p id="p-0107" num="0158">The system <b>1000</b> may include a coding component <b>1004</b> that may implement the various coding or encoding methods described in the present document. The coding component <b>1004</b> may reduce the average bitrate of video from the input <b>1002</b> to the output of the coding component <b>1004</b> to produce a coded representation of the video. The coding techniques are therefore sometimes called video compression or video transcoding techniques. The output of the coding component <b>1004</b> may be either stored, or transmitted via a communication connected, as represented by the component <b>1006</b>. The stored or communicated bitstream (or coded) representation of the video received at the input <b>1002</b> may be used by the component <b>1008</b> for generating pixel values or displayable video that is sent to a display interface <b>1010</b>. The process of generating user-viewable video from the bitstream representation is sometimes called video decompression. Furthermore, while certain video processing operations are referred to as &#x201c;coding&#x201d; operations or tools, it will be appreciated that the coding tools or operations are used at an encoder and corresponding decoding tools or operations that reverse the results of the coding will be performed by a decoder.</p><p id="p-0108" num="0159">Examples of a peripheral bus interface or a display interface may include universal serial bus (USB) or high definition multimedia interface (HDMI) or Displayport, and so on. Examples of storage interfaces include serial advanced technology attachment (SATA), peripheral component interconnect (PCI), integrated drive electronics (IDE) interface, and the like. The techniques described in the present document may be embodied in various electronic devices such as mobile phones, laptops, smartphones or other devices that are capable of performing digital data processing and/or video display.</p><p id="p-0109" num="0160"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a block diagram of a video processing apparatus <b>2000</b>. The apparatus <b>2000</b> may be used to implement one or more of the methods described herein. The apparatus <b>2000</b> may be embodied in a smartphone, tablet, computer, Internet of Things (IoT) receiver, and so on. The apparatus <b>2000</b> may include one or more processors <b>2002</b>, one or more memories <b>2004</b> and video processing hardware <b>2006</b>. The processor(s) <b>2002</b> may be configured to implement one or more methods described in the present document. The memory (memories) <b>2004</b> may be used for storing data and code used for implementing the methods and techniques described herein. The video processing hardware <b>2006</b> may be used to implement, in hardware circuitry, some techniques described in the present document. In some embodiments, the hardware <b>2006</b> may be partly or entirely in the one or more processors <b>2002</b>, e.g., a graphics processor.</p><p id="p-0110" num="0161"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a block diagram that illustrates an example video coding system <b>100</b> that may utilize the techniques of this disclosure.</p><p id="p-0111" num="0162">As shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, video coding system <b>100</b> may include a source device <b>110</b> and a destination device <b>120</b>. Source device <b>110</b> generates encoded video data which may be referred to as a video encoding device. Destination device <b>120</b> may decode the encoded video data generated by source device <b>110</b> which may be referred to as a video decoding device.</p><p id="p-0112" num="0163">Source device <b>110</b> may include a video source <b>112</b>, a video encoder <b>114</b>, and an input/output (I/O) interface <b>116</b>.</p><p id="p-0113" num="0164">Video source <b>112</b> may include a source such as a video capture device, an interface to receive video data from a video content provider, and/or a computer graphics system for generating video data, or a combination of such sources. The video data may comprise one or more pictures. Video encoder <b>114</b> encodes the video data from video source <b>112</b> to generate a bitstream. The bitstream may include a sequence of bits that form a coded representation of the video data. The bitstream may include coded pictures and associated data. The coded picture is a coded representation of a picture. The associated data may include sequence parameter sets, picture parameter sets, and other syntax structures. I/O interface <b>116</b> may include a modulator/demodulator (modem) and/or a transmitter. The encoded video data may be transmitted directly to destination device <b>120</b> via I/O interface <b>116</b> through network <b>130</b><i>a</i>. The encoded video data may also be stored onto a storage medium/server <b>130</b><i>b </i>for access by destination device <b>120</b>.</p><p id="p-0114" num="0165">Destination device <b>120</b> may include an I/O interface <b>126</b>, a video decoder <b>124</b>, and a display device <b>122</b>.</p><p id="p-0115" num="0166">I/O interface <b>126</b> may include a receiver and/or a modem. I/O interface <b>126</b> may acquire encoded video data from the source device <b>110</b> or the storage medium/server <b>130</b><i>b</i>. Video decoder <b>124</b> may decode the encoded video data. Display device <b>122</b> may display the decoded video data to a user. Display device <b>122</b> may be integrated with the destination device <b>120</b>, or may be external to destination device <b>120</b> which be configured to interface with an external display device.</p><p id="p-0116" num="0167">Video encoder <b>114</b> and video decoder <b>124</b> may operate according to a video compression standard, such as the High Efficiency Video Coding (HEVC) standard, Versatile Video Coding (VVC) standard and other current and/or further standards.</p><p id="p-0117" num="0168"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a block diagram illustrating an example of video encoder <b>200</b>, which may be video encoder <b>114</b> in the system <b>100</b> illustrated in <figref idref="DRAWINGS">FIG. <b>3</b></figref>.</p><p id="p-0118" num="0169">Video encoder <b>200</b> may be configured to perform any or all of the techniques of this disclosure. In the example of <figref idref="DRAWINGS">FIG. <b>4</b></figref>, video encoder <b>200</b> includes a plurality of functional components. The techniques described in this disclosure may be shared among the various components of video encoder <b>200</b>. In some examples, a processor may be configured to perform any or all of the techniques described in this disclosure.</p><p id="p-0119" num="0170">The functional components of video encoder <b>200</b> may include a partition unit <b>201</b>, a prediction unit <b>202</b> which may include a mode select unit <b>203</b>, a motion estimation unit <b>204</b>, a motion compensation unit <b>205</b> and an intra prediction unit <b>206</b>, a residual generation unit <b>207</b>, a transform unit <b>208</b>, a quantization unit <b>209</b>, an inverse quantization unit <b>210</b>, an inverse transform unit <b>211</b>, a reconstruction unit <b>212</b>, a buffer <b>213</b>, and an entropy encoding unit <b>214</b>.</p><p id="p-0120" num="0171">In other examples, video encoder <b>200</b> may include more, fewer, or different functional components. In an example, prediction unit <b>202</b> may include an intra block copy (IBC) unit. The IBC unit may perform prediction in an IBC mode in which at least one reference picture is a picture where the current video block is located.</p><p id="p-0121" num="0172">Furthermore, some components, such as motion estimation unit <b>204</b> and motion compensation unit <b>205</b> may be highly integrated, but are represented in the example of <figref idref="DRAWINGS">FIG. <b>4</b></figref> separately for purposes of explanation.</p><p id="p-0122" num="0173">Partition unit <b>201</b> may partition a picture into one or more video blocks. Video encoder <b>200</b> and video decoder <b>300</b> may support various video block sizes.</p><p id="p-0123" num="0174">Mode select unit <b>203</b> may select one of the coding modes, intra or inter, e.g., based on error results, and provide the resulting intra- or inter-coded block to a residual generation unit <b>207</b> to generate residual block data and to a reconstruction unit <b>212</b> to reconstruct the encoded block for use as a reference picture. In some example, Mode select unit <b>203</b> may select a combination of intra and inter prediction (CIIP) mode in which the prediction is based on an inter prediction signal and an intra prediction signal. Mode select unit <b>203</b> may also select a resolution for a motion vector (e.g., a sub-pixel or integer pixel precision) for the block in the case of inter-prediction.</p><p id="p-0124" num="0175">To perform inter prediction on a current video block, motion estimation unit <b>204</b> may generate motion information for the current video block by comparing one or more reference frames from buffer <b>213</b> to the current video block. Motion compensation unit <b>205</b> may determine a predicted video block for the current video block based on the motion information and decoded samples of pictures from buffer <b>213</b> other than the picture associated with the current video block.</p><p id="p-0125" num="0176">Motion estimation unit <b>204</b> and motion compensation unit <b>205</b> may perform different operations for a current video block, for example, depending on whether the current video block is in an I slice, a P slice, or a B slice.</p><p id="p-0126" num="0177">In some examples, motion estimation unit <b>204</b> may perform uni-directional prediction for the current video block, and motion estimation unit <b>204</b> may search reference pictures of list 0 or list 1 for a reference video block for the current video block. Motion estimation unit <b>204</b> may then generate a reference index that indicates the reference picture in list 0 or list 1 that contains the reference video block and a motion vector that indicates a spatial displacement between the current video block and the reference video block. Motion estimation unit <b>204</b> may output the reference index, a prediction direction indicator, and the motion vector as the motion information of the current video block. Motion compensation unit <b>205</b> may generate the predicted video block of the current block based on the reference video block indicated by the motion information of the current video block.</p><p id="p-0127" num="0178">In other examples, motion estimation unit <b>204</b> may perform bi-directional prediction for the current video block, motion estimation unit <b>204</b> may search the reference pictures in list 0 for a reference video block for the current video block and may also search the reference pictures in list 1 for another reference video block for the current video block. Motion estimation unit <b>204</b> may then generate reference indexes that indicate the reference pictures in list 0 and list 1 containing the reference video blocks and motion vectors that indicate spatial displacements between the reference video blocks and the current video block. Motion estimation unit <b>204</b> may output the reference indexes and the motion vectors of the current video block as the motion information of the current video block. Motion compensation unit <b>205</b> may generate the predicted video block of the current video block based on the reference video blocks indicated by the motion information of the current video block.</p><p id="p-0128" num="0179">In some examples, motion estimation unit <b>204</b> may output a full set of motion information for decoding processing of a decoder.</p><p id="p-0129" num="0180">In some examples, motion estimation unit <b>204</b> may do not output a full set of motion information for the current video. Rather, motion estimation unit <b>204</b> may signal the motion information of the current video block with reference to the motion information of another video block. For example, motion estimation unit <b>204</b> may determine that the motion information of the current video block is sufficiently similar to the motion information of a neighboring video block.</p><p id="p-0130" num="0181">In one example, motion estimation unit <b>204</b> may indicate, in a syntax structure associated with the current video block, a value that indicates to the video decoder <b>300</b> that the current video block has the same motion information as another video block.</p><p id="p-0131" num="0182">In another example, motion estimation unit <b>204</b> may identify, in a syntax structure associated with the current video block, another video block and a motion vector difference (MVD). The motion vector difference indicates a difference between the motion vector of the current video block and the motion vector of the indicated video block. The video decoder <b>300</b> may use the motion vector of the indicated video block and the motion vector difference to determine the motion vector of the current video block.</p><p id="p-0132" num="0183">As discussed above, video encoder <b>200</b> may predictively signal the motion vector. Two examples of predictive signaling techniques that may be implemented by video encoder <b>200</b> include advanced motion vector predication (AMVP) and merge mode signaling.</p><p id="p-0133" num="0184">Intra prediction unit <b>206</b> may perform intra prediction on the current video block. When intra prediction unit <b>206</b> performs intra prediction on the current video block, intra prediction unit <b>206</b> may generate prediction data for the current video block based on decoded samples of other video blocks in the same picture. The prediction data for the current video block may include a predicted video block and various syntax elements.</p><p id="p-0134" num="0185">Residual generation unit <b>207</b> may generate residual data for the current video block by subtracting (e.g., indicated by the minus sign) the predicted video block(s) of the current video block from the current video block. The residual data of the current video block may include residual video blocks that correspond to different sample components of the samples in the current video block.</p><p id="p-0135" num="0186">In other examples, there may be no residual data for the current video block for the current video block, for example in a skip mode, and residual generation unit <b>207</b> may not perform the subtracting operation.</p><p id="p-0136" num="0187">Transform processing unit <b>208</b> may generate one or more transform coefficient video blocks for the current video block by applying one or more transforms to a residual video block associated with the current video block.</p><p id="p-0137" num="0188">After transform processing unit <b>208</b> generates a transform coefficient video block associated with the current video block, quantization unit <b>209</b> may quantize the transform coefficient video block associated with the current video block based on one or more quantization parameter (QP) values associated with the current video block.</p><p id="p-0138" num="0189">Inverse quantization unit <b>210</b> and inverse transform unit <b>211</b> may apply inverse quantization and inverse transforms to the transform coefficient video block, respectively, to reconstruct a residual video block from the transform coefficient video block. Reconstruction unit <b>212</b> may add the reconstructed residual video block to corresponding samples from one or more predicted video blocks generated by the predication unit <b>202</b> to produce a reconstructed video block associated with the current block for storage in the buffer <b>213</b>.</p><p id="p-0139" num="0190">After reconstruction unit <b>212</b> reconstructs the video block, loop filtering operation may be performed reduce video blocking artifacts in the video block.</p><p id="p-0140" num="0191">Entropy encoding unit <b>214</b> may receive data from other functional components of the video encoder <b>200</b>. When entropy encoding unit <b>214</b> receives the data, entropy encoding unit <b>214</b> may perform one or more entropy encoding operations to generate entropy encoded data and output a bitstream that includes the entropy encoded data.</p><p id="p-0141" num="0192"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a block diagram illustrating an example of video decoder <b>300</b> which may be video decoder <b>114</b> in the system <b>100</b> illustrated in <figref idref="DRAWINGS">FIG. <b>3</b></figref>.</p><p id="p-0142" num="0193">The video decoder <b>300</b> may be configured to perform any or all of the techniques of this disclosure. In the example of <figref idref="DRAWINGS">FIG. <b>5</b></figref>, the video decoder <b>300</b> includes a plurality of functional components. The techniques described in this disclosure may be shared among the various components of the video decoder <b>300</b>. In some examples, a processor may be configured to perform any or all of the techniques described in this disclosure.</p><p id="p-0143" num="0194">In the example of <figref idref="DRAWINGS">FIG. <b>5</b></figref>, video decoder <b>300</b> includes an entropy decoding unit <b>301</b>, a motion compensation unit <b>302</b>, an intra prediction unit <b>303</b>, an inverse quantization unit <b>304</b>, an inverse transformation unit <b>305</b>, and a reconstruction unit <b>306</b> and a buffer <b>307</b>. Video decoder <b>300</b> may, in some examples, perform a decoding pass generally reciprocal to the encoding pass described with respect to video encoder <b>200</b> (<figref idref="DRAWINGS">FIG. <b>4</b></figref>).</p><p id="p-0144" num="0195">Entropy decoding unit <b>301</b> may retrieve an encoded bitstream. The encoded bitstream may include entropy coded video data (e.g., encoded blocks of video data). Entropy decoding unit <b>301</b> may decode the entropy coded video data, and from the entropy decoded video data, motion compensation unit <b>302</b> may determine motion information including motion vectors, motion vector precision, reference picture list indexes, and other motion information. Motion compensation unit <b>302</b> may, for example, determine such information by performing the AMVP and merge mode.</p><p id="p-0145" num="0196">Motion compensation unit <b>302</b> may produce motion compensated blocks, possibly performing interpolation based on interpolation filters. Identifiers for interpolation filters to be used with sub-pixel precision may be included in the syntax elements.</p><p id="p-0146" num="0197">Motion compensation unit <b>302</b> may use interpolation filters as used by video encoder <b>200</b> during encoding of the video block to calculate interpolated values for sub-integer pixels of a reference block. Motion compensation unit <b>302</b> may determine the interpolation filters used by video encoder <b>200</b> according to received syntax information and use the interpolation filters to produce predictive blocks.</p><p id="p-0147" num="0198">Motion compensation unit <b>302</b> may use some of the syntax information to determine sizes of blocks used to encode frame(s) and/or slice(s) of the encoded video sequence, partition information that describes how each macroblock of a picture of the encoded video sequence is partitioned, modes indicating how each partition is encoded, one or more reference frames (and reference frame lists) for each inter-encoded block, and other information to decode the encoded video sequence.</p><p id="p-0148" num="0199">Intra prediction unit <b>303</b> may use intra prediction modes for example received in the bitstream to form a prediction block from spatially adjacent blocks. Inverse quantization unit <b>304</b> inverse quantizes, i.e., de-quantizes, the quantized video block coefficients provided in the bitstream and decoded by entropy decoding unit <b>301</b>. Inverse transform unit <b>305</b> applies an inverse transform.</p><p id="p-0149" num="0200">Reconstruction unit <b>306</b> may sum the residual blocks with the corresponding prediction blocks generated by motion compensation unit <b>302</b> or intra-prediction unit <b>303</b> to form decoded blocks. If desired, a deblocking filter may also be applied to filter the decoded blocks in order to remove blockiness artifacts. The decoded video blocks are then stored in buffer <b>307</b>, which provides reference blocks for subsequent motion compensation/intra predication and also produces decoded video for presentation on a display device.</p><p id="p-0150" num="0201"><figref idref="DRAWINGS">FIGS. <b>6</b>-<b>7</b></figref> show example methods that can implement the technical solution described above in, for example, the embodiments shows in <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>5</b></figref>.</p><p id="p-0151" num="0202"><figref idref="DRAWINGS">FIG. <b>6</b></figref> shows a flowchart for an example method <b>600</b> of video processing. The method <b>600</b> includes, at operation <b>610</b>, performing a conversion between a video comprising one or more pictures in one or more video layers and a bitstream of a video, the bitstream comprising a coded video sequence (CVS) that includes one or more access units (AUs), and the bitstream further comprising a first syntax element indicating whether an AU includes a picture for each video layer making up the CVS.</p><p id="p-0152" num="0203"><figref idref="DRAWINGS">FIG. <b>7</b></figref> shows a flowchart for an example method <b>700</b> of video processing. The method <b>700</b> includes, at operation <b>710</b>, performing a conversion between a video comprising one or more pictures in one or more video layers and a bitstream of the video, the bitstream comprising a coded video sequence (CVS) that includes one or more access units (AUs), and the bitstream conforming to a format rule that specifies that each picture in a given AU carries a layer identifier that is equal to a layer identifier of a first AU of the CVS comprising the one or more video layers.</p><p id="p-0153" num="0204"><figref idref="DRAWINGS">FIG. <b>8</b></figref> shows a flowchart for an example method <b>800</b> of video processing. The method <b>800</b> includes, at operation <b>810</b>, performing, a conversion between a video comprising one or more pictures in one or more video layers and a bitstream of a video, the bitstream comprising a coded video sequence (CVS) that includes one or more access units (AUs), and the bitstream further comprising a first syntax element indicative of an AU of the one or more AUs starting a new CVS.</p><p id="p-0154" num="0205"><figref idref="DRAWINGS">FIG. <b>9</b></figref> shows a flowchart for an example method <b>900</b> of video processing. The method <b>900</b> includes, at operation <b>910</b>, performing a conversion between a video comprising one or more pictures in one or more video layers and a bitstream of the video, the bitstream comprising a coded video sequence (CVS) that includes one or more access units (AUs), and the bitstream conforming to a format rule that specifies that a coded video sequence start (CVSS) AU, which starts a new CVS, comprises a picture for each video layer specified in a video parameter set (VPS).</p><p id="p-0155" num="0206"><figref idref="DRAWINGS">FIG. <b>10</b></figref> shows a flowchart for an example method <b>1000</b> of video processing. The method <b>1000</b> includes, at operation <b>1010</b>, performing a conversion between a video comprising one or more pictures in one or more video layers and a bitstream of the video, the bitstream comprising a coded video sequence (CVS) that includes one or more access units (AUs), and the bitstream conforming to a format rule that specifies that a given AU is identified as a coded video sequence start (CVSS) AU based on the given AU being a first AU in the bitstream or an AU previous to the given AU comprising end of sequence (EOS) network abstraction layer (NAL) units.</p><p id="p-0156" num="0207"><figref idref="DRAWINGS">FIG. <b>11</b></figref> shows a flowchart for an example method <b>1100</b> of video processing. The method <b>1100</b> includes, at operation <b>1110</b>, performing, based on a rule, a conversion between a video comprising one or more pictures in one or more video layers and a bitstream of the video, the bitstream comprising a coded video sequence (CVS) that includes one or more access units (AUs), and the rule specifying that side information is used to indicate whether an AU of the one or more AUs is a coded video sequence start (CVSS) AU.</p><p id="p-0157" num="0208"><figref idref="DRAWINGS">FIG. <b>12</b></figref> shows a flowchart for an example method <b>1200</b> of video processing. The method <b>1200</b> includes, at operation <b>1210</b>, performing a conversion between a video comprising one or more pictures in one or more video layers and a bitstream of a video, the bitstream comprising a coded video sequence (CVS) that includes one or more access units (AUs), and the bitstream conforming to a format rule that specifies that each AU of the one or more AUs that is a gradual decoding refresh AU includes exactly one picture for each video layer present in the CVS.</p><p id="p-0158" num="0209"><figref idref="DRAWINGS">FIG. <b>13</b></figref> shows a flowchart for an example method <b>1300</b> of video processing. The method <b>1300</b> includes, at operation <b>1310</b>, performing a conversion between a video comprising one or more pictures in one or more video layers and a bitstream of a video, the bitstream comprising a coded video sequence that includes one or more access units (AUs), and the bitstream conforming to a format rule that specifies that each AU of the one or more AUs that is an intra random access points AU includes exactly one picture for each video layer present in the CVS.</p><p id="p-0159" num="0210">A listing of solutions preferred by some embodiments is provided next.</p><p id="p-0160" num="0211">P1. A video processing method, comprising performing a conversion between a video having one or more pictures in one or more video layers and a coded representation representing an encoded version of the video; wherein the coded representation includes one or more access units (AU); wherein the coded representation includes a syntax element if and only if an AU is of a type, wherein the syntax element indicates whether the AU includes a picture for each video layer making up a coded video sequence.</p><p id="p-0161" num="0212">P2. The method of solution P1, wherein the type includes all AUs.</p><p id="p-0162" num="0213">P3. The method of solution P1, wherein the type includes AUs that start a new CVS.</p><p id="p-0163" num="0214">P4. The method of solution P1, wherein the syntax element is included in an access unit delimiter network abstraction layer unit.</p><p id="p-0164" num="0215">P5. The method of any of solutions P1 to P4, wherein the syntax element is included in a network abstraction layer unit header.</p><p id="p-0165" num="0216">P6. The method of any of solutions P1 to P4, wherein the syntax element is included in new a network abstraction layer unit.</p><p id="p-0166" num="0217">P7. A video processing method, comprising performing a conversion between a video having one or more pictures in one or more video layers and a coded representation representing an encoded version of the video; wherein the coded representation includes one or more access units (AU); wherein the coded representation conforms to a format rule that specifies that each picture in a given AU carries a layer identifier that is equal to that of a first AU of a coded video sequence.</p><p id="p-0167" num="0218">P8. A video processing method, comprising performing a conversion between a video having one or more pictures in one or more video layers and a coded representation representing an encoded version of the video; wherein the coded representation includes one or more access units (AU); wherein the coded representation includes a syntax element if and only if an AU starts a new coded video sequence.</p><p id="p-0168" num="0219">P9. The method of solution P8, wherein the syntax element is included in an access unit delimiter network abstraction layer unit.</p><p id="p-0169" num="0220">P10. The method of any of solutions P8 to P9, wherein the syntax element is included in a network abstraction layer unit header.</p><p id="p-0170" num="0221">P11. The method of any of solutions P8 to P9, wherein the syntax element is included as a supplemental enhancement information.</p><p id="p-0171" num="0222">P12. A video processing method, comprising performing a conversion between a video having one or more pictures in one or more video layers and a coded representation of the video; wherein the coded representation includes one or more access units (AU); wherein the coded representation conforms to a format rule that specifies that a starting AU for a coded video sequence includes a video picture for each video layer specified by a video parameter set or that the coded representation implicitly signals the starting AU based on a rule.</p><p id="p-0172" num="0223">P13. A video processing method, comprising performing a conversion between a video having one or more pictures in one or more video layers and a coded representation of the video; wherein the coded representation includes one or more access units (AU); wherein the coded representation conforms to a format rule that specifies that each AU of type gradual decoding refresh (GDR) includes at least a video picture for each video layer of a coded video sequence.</p><p id="p-0173" num="0224">P14. The method of solution P13, wherein each AU of type GDR further includes a prediction unit for each layer in the CVS and the PU comprises GDR pictures.</p><p id="p-0174" num="0225">P15. The method of any of solutions P1 to 14, wherein the conversion comprises encoding the video into the coded representation.</p><p id="p-0175" num="0226">P16. The method of any of solutions P1 to 14, wherein the conversion comprises decoding the coded representation to generate pixel values of the video.</p><p id="p-0176" num="0227">P17. A video decoding apparatus comprising a processor configured to implement a method recited in one or more of solutions P1 to P16.</p><p id="p-0177" num="0228">P18. A video encoding apparatus comprising a processor configured to implement a method recited in one or more of solutions P1 to P16.</p><p id="p-0178" num="0229">P19. A computer program product having computer code stored thereon, the code, when executed by a processor, causes the processor to implement a method recited in any of solutions P1 to P16.</p><p id="p-0179" num="0230">Another listing of solutions preferred by some embodiments is provided next.</p><p id="p-0180" num="0231">A1. A method of video processing, comprising performing a conversion between a video comprising one or more pictures in one or more video layers and a bitstream of a video, wherein the bitstream comprises a coded video sequence that includes one or more access units, and wherein the bitstream further comprises a first syntax element indicating whether an access unit includes a picture for each video layer making up the coded video sequence.</p><p id="p-0181" num="0232">A2. The method of solution A1, wherein the access unit is configured to start a new coded video sequence.</p><p id="p-0182" num="0233">A3. The method of solution A2, wherein the picture for each video layer is an intra random access point picture or a gradual decoding refresh picture.</p><p id="p-0183" num="0234">A4. The method of solution A1, wherein the first syntax element is included in an access unit delimiter network abstraction layer unit.</p><p id="p-0184" num="0235">A5. The method of solution A4, wherein the first syntax element is a flag indicating whether an access unit containing an access unit delimiter is an intra random access point access unit or a gradual decoding refresh access unit.</p><p id="p-0185" num="0236">A6. The method of solution A5, wherein the first syntax element is irap_or_gdr_au_flag.</p><p id="p-0186" num="0237">A7. The method of solution A4, wherein the access unit delimiter network abstraction layer unit is the only access unit delimiter network abstraction layer unit present in each intra random access point access unit or gradual decoding refresh access unit when a second syntax element, which is indicative of a number of video layers specified by a video parameter set, is greater than one.</p><p id="p-0187" num="0238">A8. The method of solution A7, wherein the second syntax element indicates a maximum allowed number of layers in each coded video sequence that refers to the video parameter set.</p><p id="p-0188" num="0239">A9. The method of solution A1, wherein the first syntax element equaling one is indicative of all slices in the access unit comprising an identical network abstraction layer unit type in a range of IDR_W_RADL to GDR_NUT, inclusive.</p><p id="p-0189" num="0240">A10. The method of solution A9, wherein the first syntax element equaling one and the network abstraction layer unit type being IDR_W_RADL or IDR_N_LP is indicative of the access unit being a coded video sequence start access unit.</p><p id="p-0190" num="0241">All. The method of solution A9, wherein a variable for each of the pictures in the access unit equaling one and the network abstraction layer unit type being CRA_NUT or GDR_NUT is indicative of the access unit being a coded video sequence start access unit.</p><p id="p-0191" num="0242">A12. The method of solution A11, wherein the variable indicates whether pictures in a decoded picture buffer prior to a current picture in decoding order are output before the pictures are recovered.</p><p id="p-0192" num="0243">A13. The method of solution A11, wherein the variable is NoOutputBeforeRecoveryFlag.</p><p id="p-0193" num="0244">A14. The method of solution A1, wherein the first syntax element is included in a network abstraction layer unit header.</p><p id="p-0194" num="0245">A15. The method of solution A1, wherein the first syntax element is included in a new network abstraction layer unit.</p><p id="p-0195" num="0246">A16. The method of solution A15, wherein the new network abstraction layer unit is the only new network abstraction layer unit present in each intra random access point access unit or gradual decoding refresh access unit when a second syntax element, which is indicative of a number of video layers specified by a video parameter set, is greater than one.</p><p id="p-0196" num="0247">A17. The method of solution A1, wherein the first syntax element is included in a supplementary enhancement information message.</p><p id="p-0197" num="0248">A18. The method of solution A17, wherein the supplementary enhancement information message is the only supplementary enhancement information message present in each intra random access point access unit or gradual decoding refresh access unit when a second syntax element, which is indicative of a number of video layers specified by a video parameter set, is greater than zero.</p><p id="p-0198" num="0249">A19. A method of video processing, comprising performing a conversion between a video comprising one or more pictures in one or more video layers and a bitstream of the video, wherein the bitstream comprises a coded video sequence that includes one or more access units, and wherein the bitstream conforms to a format rule that specifies that each picture in a given access unit carries a layer identifier that is equal to a layer identifier of a first access unit of the coded video sequence comprising the one or more video layers.</p><p id="p-0199" num="0250">A20. A method of video processing, comprising performing, a conversion between a video comprising one or more pictures in one or more video layers and a bitstream of a video, wherein the bitstream comprises a coded video sequence that includes one or more access units, and wherein the bitstream further comprises a first syntax element indicative of an access unit of the one or more access units starting a new coded video sequence.</p><p id="p-0200" num="0251">A21. The method of solution A20, wherein the first syntax element is included in an access unit delimiter network abstraction layer unit.</p><p id="p-0201" num="0252">A22. The method of solution A20, wherein the first syntax element is included in a network abstraction layer unit header.</p><p id="p-0202" num="0253">A23. The method of solution A20, wherein the first syntax element is included in a new network abstraction layer unit.</p><p id="p-0203" num="0254">A24. The method of solution A20, wherein the first syntax element is included in a supplementary enhancement information message.</p><p id="p-0204" num="0255">A25. A method of video processing, comprising performing a conversion between a video comprising one or more pictures in one or more video layers and a bitstream of the video, wherein the bitstream comprises a coded video sequence that includes one or more access units, and wherein the bitstream conforms to a format rule that specifies that a coded video sequence start access unit, which starts a new coded video sequence, comprises a picture for each video layer specified in a video parameter set.</p><p id="p-0205" num="0256">A26. A method of video processing, comprising performing a conversion between a video comprising one or more pictures in one or more video layers and a bitstream of the video, wherein the bitstream comprises a coded video sequence that includes one or more access units, and wherein the bitstream conforms to a format rule that specifies that a given access unit is identified as a coded video sequence start access unit based on the given access unit being a first access unit in the bitstream or an access unit previous to the given access unit comprising end of sequence network abstraction layer units.</p><p id="p-0206" num="0257">A27. A method of video processing, comprising performing, based on a rule, a conversion between a video comprising one or more pictures in one or more video layers and a bitstream of the video, wherein the bitstream comprises a coded video sequence that includes one or more access units, and wherein the rule specifies that side information is used to indicate whether an access unit of the one or more access units is a coded video sequence start access unit.</p><p id="p-0207" num="0258">A28. The method of any of solutions A1 to A27, wherein the conversion comprises decoding the video from the bitstream.</p><p id="p-0208" num="0259">A29. The method of any of solutions A1 to A27, wherein the conversion comprises encoding the video into the bitstream.</p><p id="p-0209" num="0260">A30. A method of storing a bitstream representing a video to a computer-readable recording medium, comprising generating the bitstream from the video according to a method described in any one or more of solutions A1 to A27; and storing the bitstream in the computer-readable recording medium.</p><p id="p-0210" num="0261">A31. A video processing apparatus comprising a processor configured to implement a method recited in any one or more of solutions A1 to A30.</p><p id="p-0211" num="0262">A32. A computer-readable medium having instructions stored thereon, the instructions, when executed, causing a processor to implement a method recited in one or more of solutions A1 to A30.</p><p id="p-0212" num="0263">A33. A computer readable medium that stores the bitstream generated according to any one or more of solutions A1 to A30.</p><p id="p-0213" num="0264">A34. A video processing apparatus for storing a bitstream, wherein the video processing apparatus is configured to implement a method recited in any one or more of solutions A1 to A30.</p><p id="p-0214" num="0265">Yet another listing of solutions preferred by some embodiments is provided next.</p><p id="p-0215" num="0266">B1. A method of video processing, comprising performing a conversion between a video comprising one or more pictures in one or more video layers and a bitstream of a video, wherein the bitstream comprises a coded video sequence that includes one or more access units, and wherein the bitstream conforms to a format rule that specifies that each access unit of the one or more access units that is a gradual decoding refresh access unit includes exactly one picture for each video layer present in the coded video sequence.</p><p id="p-0216" num="0267">B2. The method of solution B1, wherein each access unit that is a gradual decoding refresh access unit includes a prediction unit for the each layer present in the coded video sequence, and wherein the prediction unit for each layer includes a coded picture that is a gradual decoding refresh picture.</p><p id="p-0217" num="0268">B3. A method of video processing, comprising performing a conversion between a video comprising one or more pictures in one or more video layers and a bitstream of a video, wherein the bitstream comprises a coded video sequence that includes one or more access units, and wherein the bitstream conforms to a format rule that specifies that each access unit of the one or more access units that is an intra random access points access unit includes exactly one picture for each video layer present in the coded video sequence.</p><p id="p-0218" num="0269">B4. The method of any of solutions B1 to B3, wherein the conversion comprises decoding the video from the bitstream.</p><p id="p-0219" num="0270">B5. The method of any of solutions B1 to B3, wherein the conversion comprises encoding the video into the bitstream.</p><p id="p-0220" num="0271">B6. A method of storing a bitstream representing a video to a computer-readable recording medium, comprising generating the bitstream from the video according to a method described in any one or more of solutions B1 to B3; and storing the bitstream in the computer-readable recording medium.</p><p id="p-0221" num="0272">B7. A video processing apparatus comprising a processor configured to implement a method recited in any one or more of solutions B1 to B6.</p><p id="p-0222" num="0273">B8. A computer-readable medium having instructions stored thereon, the instructions, when executed, causing a processor to implement a method recited in one or more of solutions B1 to B6.</p><p id="p-0223" num="0274">B9. A computer readable medium that stores the bitstream generated according to any one or more of solutions B1 to B6.</p><p id="p-0224" num="0275">B10. A video processing apparatus for storing a bitstream, wherein the video processing apparatus is configured to implement a method recited in any one or more of solutions B1 to B6.</p><p id="p-0225" num="0276">In the present document, the term &#x201c;video processing&#x201d; may refer to video encoding, video decoding, video compression or video decompression. For example, video compression algorithms may be applied during conversion from pixel representation of a video to a corresponding bitstream representation or vice versa. The bitstream representation of a current video block may, for example, correspond to bits that are either co-located or spread in different places within the bitstream, as is defined by the syntax. For example, a macroblock may be encoded in terms of transformed and coded error residual values and also using bits in headers and other fields in the bitstream. Furthermore, during conversion, a decoder may parse a bitstream with the knowledge that some fields may be present, or absent, based on the determination, as is described in the above solutions. Similarly, an encoder may determine that certain syntax fields are or are not to be included and generate the coded representation accordingly by including or excluding the syntax fields from the coded representation.</p><p id="p-0226" num="0277">The disclosed and other solutions, examples, embodiments, modules and the functional operations described in this document can be implemented in digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this document and their structural equivalents, or in combinations of one or more of them. The disclosed and other embodiments can be implemented as one or more computer program products, i.e., one or more modules of computer program instructions encoded on a computer readable medium for execution by, or to control the operation of, data processing apparatus. The computer readable medium can be a machine-readable storage device, a machine-readable storage substrate, a memory device, a composition of matter effecting a machine-readable propagated signal, or a combination of one or more them. The term &#x201c;data processing apparatus&#x201d; encompasses all apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, or multiple processors or computers. The apparatus can include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or a combination of one or more of them. A propagated signal is an artificially generated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus.</p><p id="p-0227" num="0278">A computer program (also known as a program, software, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program does not necessarily correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub programs, or portions of code). A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.</p><p id="p-0228" num="0279">The processes and logic flows described in this document can be performed by one or more programmable processors executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an field programmable gate array (FPGA) or an application specific integrated circuit (ASIC).</p><p id="p-0229" num="0280">Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read only memory or a random-access memory or both. The essential elements of a computer are a processor for performing instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto optical disks, or optical disks. However, a computer need not have such devices. Computer readable media suitable for storing computer program instructions and data include all forms of non-volatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., erasable programmable read-only memory (EPROM), electrically erasable programmable read-only memory (EEPROM), and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto optical disks; and compact disc, read-only memory (CD ROM) and digital versatile disc read-only memory (DVD-ROM) disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.</p><p id="p-0230" num="0281">While this patent document contains many specifics, these should not be construed as limitations on the scope of any subject matter or of what may be claimed, but rather as descriptions of features that may be specific to particular embodiments of particular techniques. Certain features that are described in this patent document in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.</p><p id="p-0231" num="0282">Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. Moreover, the separation of various system components in the embodiments described in this patent document should not be understood as requiring such separation in all embodiments.</p><p id="p-0232" num="0283">Only a few implementations and examples are described and other implementations, enhancements and variations can be made based on what is described and illustrated in this patent document.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A method of video processing, comprising:<claim-text>performing a conversion between a video comprising one or more pictures in one or more video layers and a bitstream of the video,</claim-text><claim-text>wherein the bitstream comprises a coded video sequence that includes an access unit, and</claim-text><claim-text>wherein the bitstream further comprises a first syntax element indicating whether the access unit includes a first type of picture for each video layer making up the coded video sequence.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the access unit includes the first type of picture for each video layer; and the access unit is configured to start a new coded video sequence, or each picture of the access unit is the first type of picture.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the first type of picture for each video layer is an intra random access point picture or a gradual decoding refresh picture.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the first syntax element is included in an access unit delimiter network abstraction layer unit.</claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the first syntax element is a flag indicating whether the access unit containing an access unit delimiter is an intra random access point access unit or a gradual decoding refresh access unit.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the access unit delimiter network abstraction layer unit is an only access unit delimiter network abstraction layer unit present in each intra random access point access unit or gradual decoding refresh access unit when a second syntax element, which is indicative of a maximum allowed number of layers in each coded video sequence that refers to a video parameter set, is greater than one.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the second syntax element indicates the maximum allowed number of layers by indicating the maximum allowed number minus1.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the bitstream further conforms to a format rule that specifies that each picture in an access unit carries a layer identifier that is equal to a layer identifier of one of pictures present in a first access unit of the coded video sequence.</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the layer identifier is a nuh_layer_id.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the first syntax element equaling one is indicative of all slices in the access unit comprising an identical network abstraction layer unit type in a range of IDR_W_RADL to GDR_NUT, inclusive.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the first syntax element equaling one and the network abstraction layer unit type being IDR_W_RADL or IDR_N_LP are indicative of the access unit being a coded video sequence start access unit.</claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein a variable for each of the pictures in the access unit equaling one and the network abstraction layer unit type being CRA_NUT or GDR_NUT are indicative of the access unit being a coded video sequence start access unit.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The method of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the variable indicates whether pictures in a decoded picture buffer prior to a current picture in decoding order are output before the pictures are recovered.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the conversion comprises decoding the video from the bitstream.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the conversion comprises encoding the video into the bitstream.</claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. An apparatus for processing video data comprising a processor and a non-transitory memory with instructions thereon, wherein the instructions upon execution by the processor, cause the processor to:<claim-text>perform a conversion between a video comprising one or more pictures in one or more video layers and a bitstream of the video,</claim-text><claim-text>wherein the bitstream comprises a coded video sequence that includes an access unit, and</claim-text><claim-text>wherein the bitstream further comprises a first syntax element indicating whether the access unit includes a first type of picture for each video layer making up the coded video sequence.</claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The apparatus of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the first type of picture for each video layer is an intra random access point picture or a gradual decoding refresh picture.</claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The apparatus of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the first syntax element is included in an access unit delimiter network abstraction layer unit, and wherein the access unit delimiter network abstraction layer unit is an only access unit delimiter network abstraction layer unit present in each intra random access point access unit or gradual decoding refresh access unit when a second syntax element, which is indicative of a maximum allowed number of layers in each coded video sequence that refers to a video parameter set, is greater than one.</claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. A non-transitory computer-readable storage medium storing instructions that cause a processor to:<claim-text>perform a conversion between a video comprising one or more pictures in one or more video layers and a bitstream of the video,</claim-text><claim-text>wherein the bitstream comprises a coded video sequence that includes an access unit, and</claim-text><claim-text>wherein the bitstream further comprises a first syntax element indicating whether the access unit includes a first type of picture for each video layer making up the coded video sequence.</claim-text></claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. A non-transitory computer-readable recording medium storing a bitstream of a video which is generated by a method performed by a video processing apparatus, wherein the method comprises:<claim-text>generating a bitstream of a video comprising one or more pictures in one or more video layers,</claim-text><claim-text>wherein the bitstream comprises a coded video sequence that includes an access unit, and</claim-text><claim-text>wherein the bitstream further comprises a first syntax element indicating whether the access unit includes a first type of picture for each video layer making up the coded video sequence.</claim-text></claim-text></claim></claims></us-patent-application>