<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230007243A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230007243</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17943971</doc-number><date>20220913</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20140101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>105</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20140101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>176</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20140101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>159</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>105</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>176</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>159</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">ENCODER, DECODER, ENCODING METHOD, AND DECODING METHOD</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>17137061</doc-number><date>20201229</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11490076</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17943971</doc-number></document-id></child-doc></relation></continuation><continuation><relation><parent-doc><document-id><country>US</country><doc-number>PCT/JP2019/026212</doc-number><date>20190702</date></document-id><parent-status>PENDING</parent-status></parent-doc><child-doc><document-id><country>US</country><doc-number>17137061</doc-number></document-id></child-doc></relation></continuation><us-provisional-application><document-id><country>US</country><doc-number>62693987</doc-number><date>20180704</date></document-id></us-provisional-application></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Panasonic Intellectual Property Corporation of America</orgname><address><city>Torrance</city><state>CA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>LIAO</last-name><first-name>Ru Ling</first-name><address><city>Singapore</city><country>SG</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>LIM</last-name><first-name>Chong Soon</first-name><address><city>Singapore</city><country>SG</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>SUN</last-name><first-name>Hai Wei</first-name><address><city>Singapore</city><country>SG</country></address></addressbook></inventor><inventor sequence="03" designation="us-only"><addressbook><last-name>TEO</last-name><first-name>Han Boon</first-name><address><city>Singapore</city><country>SG</country></address></addressbook></inventor><inventor sequence="04" designation="us-only"><addressbook><last-name>LI</last-name><first-name>Jing Ya</first-name><address><city>Singapore</city><country>SG</country></address></addressbook></inventor><inventor sequence="05" designation="us-only"><addressbook><last-name>SHASHIDHAR</last-name><first-name>Sughosh Pavan</first-name><address><city>Singapore</city><country>SG</country></address></addressbook></inventor><inventor sequence="06" designation="us-only"><addressbook><last-name>ABE</last-name><first-name>Kiyofumi</first-name><address><city>Osaka</city><country>JP</country></address></addressbook></inventor><inventor sequence="07" designation="us-only"><addressbook><last-name>NISHI</last-name><first-name>Takahiro</first-name><address><city>Nara</city><country>JP</country></address></addressbook></inventor><inventor sequence="08" designation="us-only"><addressbook><last-name>TOMA</last-name><first-name>Tadamasa</first-name><address><city>Osaka</city><country>JP</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">An encoder includes: circuitry; and memory coupled to the circuitry. The circuitry, in operation, stores a first parameter into a bitstream, the first parameter indicating, as a prediction mode, one of (i) a multiple prediction mode in which a prediction image is generated by overlapping an inter prediction image of a current block and an intra prediction image of the current block and (ii) one of a plurality of prediction modes including a non-rectangular mode in which a prediction image is generated for each non-rectangular partition in the current block, and encodes the current block according to the prediction mode.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="35.05mm" wi="158.75mm" file="US20230007243A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="236.90mm" wi="73.66mm" orientation="landscape" file="US20230007243A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="238.17mm" wi="164.51mm" orientation="landscape" file="US20230007243A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="223.94mm" wi="164.08mm" orientation="landscape" file="US20230007243A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="235.37mm" wi="157.40mm" orientation="landscape" file="US20230007243A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="234.27mm" wi="145.12mm" orientation="landscape" file="US20230007243A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="230.12mm" wi="129.71mm" orientation="landscape" file="US20230007243A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="239.69mm" wi="145.20mm" orientation="landscape" file="US20230007243A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="111.59mm" wi="99.48mm" file="US20230007243A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="239.44mm" wi="114.64mm" file="US20230007243A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="141.14mm" wi="106.00mm" file="US20230007243A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="233.68mm" wi="152.99mm" orientation="landscape" file="US20230007243A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="125.48mm" wi="104.14mm" file="US20230007243A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="230.63mm" wi="168.74mm" file="US20230007243A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00014" num="00014"><img id="EMI-D00014" he="209.63mm" wi="175.68mm" file="US20230007243A1-20230105-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00015" num="00015"><img id="EMI-D00015" he="207.69mm" wi="174.33mm" file="US20230007243A1-20230105-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00016" num="00016"><img id="EMI-D00016" he="202.10mm" wi="168.32mm" orientation="landscape" file="US20230007243A1-20230105-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00017" num="00017"><img id="EMI-D00017" he="220.64mm" wi="166.37mm" orientation="landscape" file="US20230007243A1-20230105-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00018" num="00018"><img id="EMI-D00018" he="239.18mm" wi="138.35mm" orientation="landscape" file="US20230007243A1-20230105-D00018.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00019" num="00019"><img id="EMI-D00019" he="240.62mm" wi="139.19mm" file="US20230007243A1-20230105-D00019.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00020" num="00020"><img id="EMI-D00020" he="239.35mm" wi="96.86mm" orientation="landscape" file="US20230007243A1-20230105-D00020.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00021" num="00021"><img id="EMI-D00021" he="210.74mm" wi="173.91mm" file="US20230007243A1-20230105-D00021.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00022" num="00022"><img id="EMI-D00022" he="238.93mm" wi="73.07mm" orientation="landscape" file="US20230007243A1-20230105-D00022.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00023" num="00023"><img id="EMI-D00023" he="241.38mm" wi="130.13mm" file="US20230007243A1-20230105-D00023.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00024" num="00024"><img id="EMI-D00024" he="218.10mm" wi="138.35mm" orientation="landscape" file="US20230007243A1-20230105-D00024.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00025" num="00025"><img id="EMI-D00025" he="229.11mm" wi="144.19mm" orientation="landscape" file="US20230007243A1-20230105-D00025.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00026" num="00026"><img id="EMI-D00026" he="194.56mm" wi="57.83mm" orientation="landscape" file="US20230007243A1-20230105-D00026.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00027" num="00027"><img id="EMI-D00027" he="235.12mm" wi="133.77mm" orientation="landscape" file="US20230007243A1-20230105-D00027.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00028" num="00028"><img id="EMI-D00028" he="187.11mm" wi="145.37mm" orientation="landscape" file="US20230007243A1-20230105-D00028.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00029" num="00029"><img id="EMI-D00029" he="125.81mm" wi="115.57mm" file="US20230007243A1-20230105-D00029.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00030" num="00030"><img id="EMI-D00030" he="237.74mm" wi="97.11mm" orientation="landscape" file="US20230007243A1-20230105-D00030.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00031" num="00031"><img id="EMI-D00031" he="99.48mm" wi="101.35mm" file="US20230007243A1-20230105-D00031.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00032" num="00032"><img id="EMI-D00032" he="163.24mm" wi="174.58mm" file="US20230007243A1-20230105-D00032.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00033" num="00033"><img id="EMI-D00033" he="164.85mm" wi="174.84mm" file="US20230007243A1-20230105-D00033.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00034" num="00034"><img id="EMI-D00034" he="180.85mm" wi="163.24mm" file="US20230007243A1-20230105-D00034.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00035" num="00035"><img id="EMI-D00035" he="210.48mm" wi="173.99mm" file="US20230007243A1-20230105-D00035.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00036" num="00036"><img id="EMI-D00036" he="217.76mm" wi="147.83mm" file="US20230007243A1-20230105-D00036.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00037" num="00037"><img id="EMI-D00037" he="179.83mm" wi="173.48mm" file="US20230007243A1-20230105-D00037.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00038" num="00038"><img id="EMI-D00038" he="209.13mm" wi="169.42mm" file="US20230007243A1-20230105-D00038.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00039" num="00039"><img id="EMI-D00039" he="224.96mm" wi="93.56mm" orientation="landscape" file="US20230007243A1-20230105-D00039.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00040" num="00040"><img id="EMI-D00040" he="242.65mm" wi="59.44mm" orientation="landscape" file="US20230007243A1-20230105-D00040.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00041" num="00041"><img id="EMI-D00041" he="212.68mm" wi="159.43mm" orientation="landscape" file="US20230007243A1-20230105-D00041.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00042" num="00042"><img id="EMI-D00042" he="227.75mm" wi="144.36mm" orientation="landscape" file="US20230007243A1-20230105-D00042.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00043" num="00043"><img id="EMI-D00043" he="204.13mm" wi="174.24mm" file="US20230007243A1-20230105-D00043.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00044" num="00044"><img id="EMI-D00044" he="241.30mm" wi="104.06mm" orientation="landscape" file="US20230007243A1-20230105-D00044.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00045" num="00045"><img id="EMI-D00045" he="180.42mm" wi="176.87mm" file="US20230007243A1-20230105-D00045.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00046" num="00046"><img id="EMI-D00046" he="241.22mm" wi="99.31mm" orientation="landscape" file="US20230007243A1-20230105-D00046.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00047" num="00047"><img id="EMI-D00047" he="198.20mm" wi="104.99mm" orientation="landscape" file="US20230007243A1-20230105-D00047.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00048" num="00048"><img id="EMI-D00048" he="240.62mm" wi="141.05mm" file="US20230007243A1-20230105-D00048.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00049" num="00049"><img id="EMI-D00049" he="149.27mm" wi="118.36mm" file="US20230007243A1-20230105-D00049.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00050" num="00050"><img id="EMI-D00050" he="155.19mm" wi="167.05mm" file="US20230007243A1-20230105-D00050.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00051" num="00051"><img id="EMI-D00051" he="156.72mm" wi="174.16mm" file="US20230007243A1-20230105-D00051.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00052" num="00052"><img id="EMI-D00052" he="237.57mm" wi="141.82mm" file="US20230007243A1-20230105-D00052.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00053" num="00053"><img id="EMI-D00053" he="185.17mm" wi="169.76mm" orientation="landscape" file="US20230007243A1-20230105-D00053.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00054" num="00054"><img id="EMI-D00054" he="185.17mm" wi="169.76mm" orientation="landscape" file="US20230007243A1-20230105-D00054.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00055" num="00055"><img id="EMI-D00055" he="156.38mm" wi="175.43mm" file="US20230007243A1-20230105-D00055.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00056" num="00056"><img id="EMI-D00056" he="219.03mm" wi="176.61mm" file="US20230007243A1-20230105-D00056.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00057" num="00057"><img id="EMI-D00057" he="109.22mm" wi="143.17mm" file="US20230007243A1-20230105-D00057.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00058" num="00058"><img id="EMI-D00058" he="238.25mm" wi="122.68mm" orientation="landscape" file="US20230007243A1-20230105-D00058.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00059" num="00059"><img id="EMI-D00059" he="214.12mm" wi="158.41mm" orientation="landscape" file="US20230007243A1-20230105-D00059.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00060" num="00060"><img id="EMI-D00060" he="180.17mm" wi="175.85mm" file="US20230007243A1-20230105-D00060.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00061" num="00061"><img id="EMI-D00061" he="228.43mm" wi="145.20mm" orientation="landscape" file="US20230007243A1-20230105-D00061.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00062" num="00062"><img id="EMI-D00062" he="213.02mm" wi="156.97mm" orientation="landscape" file="US20230007243A1-20230105-D00062.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00063" num="00063"><img id="EMI-D00063" he="220.98mm" wi="171.62mm" orientation="landscape" file="US20230007243A1-20230105-D00063.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00064" num="00064"><img id="EMI-D00064" he="240.96mm" wi="121.58mm" orientation="landscape" file="US20230007243A1-20230105-D00064.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00065" num="00065"><img id="EMI-D00065" he="232.66mm" wi="109.98mm" orientation="landscape" file="US20230007243A1-20230105-D00065.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00066" num="00066"><img id="EMI-D00066" he="147.07mm" wi="174.75mm" file="US20230007243A1-20230105-D00066.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00067" num="00067"><img id="EMI-D00067" he="102.02mm" wi="104.65mm" file="US20230007243A1-20230105-D00067.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00068" num="00068"><img id="EMI-D00068" he="136.57mm" wi="175.26mm" file="US20230007243A1-20230105-D00068.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00069" num="00069"><img id="EMI-D00069" he="176.53mm" wi="165.35mm" file="US20230007243A1-20230105-D00069.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00070" num="00070"><img id="EMI-D00070" he="227.67mm" wi="163.83mm" orientation="landscape" file="US20230007243A1-20230105-D00070.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00071" num="00071"><img id="EMI-D00071" he="231.31mm" wi="130.73mm" orientation="landscape" file="US20230007243A1-20230105-D00071.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00072" num="00072"><img id="EMI-D00072" he="170.18mm" wi="174.67mm" file="US20230007243A1-20230105-D00072.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00073" num="00073"><img id="EMI-D00073" he="201.17mm" wi="173.31mm" file="US20230007243A1-20230105-D00073.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00074" num="00074"><img id="EMI-D00074" he="176.70mm" wi="175.51mm" file="US20230007243A1-20230105-D00074.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00075" num="00075"><img id="EMI-D00075" he="180.34mm" wi="170.86mm" file="US20230007243A1-20230105-D00075.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00076" num="00076"><img id="EMI-D00076" he="243.92mm" wi="150.88mm" orientation="landscape" file="US20230007243A1-20230105-D00076.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00077" num="00077"><img id="EMI-D00077" he="132.76mm" wi="113.45mm" file="US20230007243A1-20230105-D00077.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00078" num="00078"><img id="EMI-D00078" he="236.64mm" wi="154.09mm" file="US20230007243A1-20230105-D00078.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00079" num="00079"><img id="EMI-D00079" he="225.89mm" wi="143.09mm" orientation="landscape" file="US20230007243A1-20230105-D00079.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00080" num="00080"><img id="EMI-D00080" he="232.24mm" wi="156.55mm" orientation="landscape" file="US20230007243A1-20230105-D00080.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00081" num="00081"><img id="EMI-D00081" he="210.65mm" wi="170.18mm" file="US20230007243A1-20230105-D00081.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00082" num="00082"><img id="EMI-D00082" he="244.26mm" wi="132.33mm" orientation="landscape" file="US20230007243A1-20230105-D00082.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00083" num="00083"><img id="EMI-D00083" he="238.08mm" wi="149.44mm" file="US20230007243A1-20230105-D00083.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00084" num="00084"><img id="EMI-D00084" he="233.34mm" wi="164.68mm" orientation="landscape" file="US20230007243A1-20230105-D00084.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00085" num="00085"><img id="EMI-D00085" he="196.51mm" wi="168.32mm" orientation="landscape" file="US20230007243A1-20230105-D00085.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00086" num="00086"><img id="EMI-D00086" he="244.09mm" wi="80.26mm" orientation="landscape" file="US20230007243A1-20230105-D00086.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00087" num="00087"><img id="EMI-D00087" he="106.26mm" wi="148.00mm" file="US20230007243A1-20230105-D00087.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00088" num="00088"><img id="EMI-D00088" he="141.31mm" wi="173.57mm" file="US20230007243A1-20230105-D00088.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00089" num="00089"><img id="EMI-D00089" he="225.04mm" wi="169.42mm" file="US20230007243A1-20230105-D00089.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00090" num="00090"><img id="EMI-D00090" he="202.61mm" wi="167.72mm" file="US20230007243A1-20230105-D00090.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00091" num="00091"><img id="EMI-D00091" he="199.47mm" wi="152.48mm" file="US20230007243A1-20230105-D00091.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00092" num="00092"><img id="EMI-D00092" he="183.05mm" wi="175.94mm" file="US20230007243A1-20230105-D00092.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00093" num="00093"><img id="EMI-D00093" he="120.82mm" wi="157.40mm" file="US20230007243A1-20230105-D00093.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00094" num="00094"><img id="EMI-D00094" he="216.66mm" wi="111.42mm" orientation="landscape" file="US20230007243A1-20230105-D00094.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00095" num="00095"><img id="EMI-D00095" he="143.85mm" wi="175.09mm" file="US20230007243A1-20230105-D00095.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00096" num="00096"><img id="EMI-D00096" he="127.17mm" wi="176.02mm" file="US20230007243A1-20230105-D00096.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00097" num="00097"><img id="EMI-D00097" he="151.89mm" wi="175.60mm" file="US20230007243A1-20230105-D00097.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00098" num="00098"><img id="EMI-D00098" he="155.87mm" wi="176.19mm" file="US20230007243A1-20230105-D00098.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00099" num="00099"><img id="EMI-D00099" he="172.04mm" wi="176.28mm" file="US20230007243A1-20230105-D00099.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00100" num="00100"><img id="EMI-D00100" he="176.95mm" wi="175.01mm" file="US20230007243A1-20230105-D00100.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00101" num="00101"><img id="EMI-D00101" he="235.37mm" wi="137.50mm" file="US20230007243A1-20230105-D00101.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00102" num="00102"><img id="EMI-D00102" he="233.00mm" wi="166.71mm" file="US20230007243A1-20230105-D00102.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00103" num="00103"><img id="EMI-D00103" he="183.30mm" wi="176.53mm" file="US20230007243A1-20230105-D00103.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00104" num="00104"><img id="EMI-D00104" he="201.17mm" wi="169.84mm" file="US20230007243A1-20230105-D00104.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00105" num="00105"><img id="EMI-D00105" he="188.55mm" wi="139.62mm" file="US20230007243A1-20230105-D00105.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00106" num="00106"><img id="EMI-D00106" he="132.00mm" wi="112.10mm" file="US20230007243A1-20230105-D00106.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00107" num="00107"><img id="EMI-D00107" he="210.31mm" wi="99.57mm" orientation="landscape" file="US20230007243A1-20230105-D00107.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00108" num="00108"><img id="EMI-D00108" he="210.06mm" wi="162.90mm" file="US20230007243A1-20230105-D00108.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00109" num="00109"><img id="EMI-D00109" he="118.53mm" wi="126.24mm" file="US20230007243A1-20230105-D00109.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00110" num="00110"><img id="EMI-D00110" he="244.60mm" wi="126.83mm" orientation="landscape" file="US20230007243A1-20230105-D00110.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00111" num="00111"><img id="EMI-D00111" he="243.08mm" wi="106.60mm" orientation="landscape" file="US20230007243A1-20230105-D00111.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00112" num="00112"><img id="EMI-D00112" he="134.03mm" wi="111.93mm" file="US20230007243A1-20230105-D00112.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00113" num="00113"><img id="EMI-D00113" he="206.84mm" wi="96.27mm" orientation="landscape" file="US20230007243A1-20230105-D00113.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00114" num="00114"><img id="EMI-D00114" he="244.69mm" wi="140.72mm" orientation="landscape" file="US20230007243A1-20230105-D00114.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00115" num="00115"><img id="EMI-D00115" he="242.06mm" wi="97.03mm" orientation="landscape" file="US20230007243A1-20230105-D00115.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00116" num="00116"><img id="EMI-D00116" he="246.72mm" wi="139.19mm" orientation="landscape" file="US20230007243A1-20230105-D00116.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00117" num="00117"><img id="EMI-D00117" he="219.79mm" wi="157.90mm" file="US20230007243A1-20230105-D00117.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00118" num="00118"><img id="EMI-D00118" he="121.24mm" wi="111.93mm" file="US20230007243A1-20230105-D00118.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00119" num="00119"><img id="EMI-D00119" he="200.66mm" wi="109.56mm" orientation="landscape" file="US20230007243A1-20230105-D00119.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00120" num="00120"><img id="EMI-D00120" he="200.66mm" wi="133.69mm" orientation="landscape" file="US20230007243A1-20230105-D00120.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00121" num="00121"><img id="EMI-D00121" he="221.57mm" wi="173.14mm" orientation="landscape" file="US20230007243A1-20230105-D00121.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00122" num="00122"><img id="EMI-D00122" he="105.24mm" wi="121.67mm" file="US20230007243A1-20230105-D00122.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00123" num="00123"><img id="EMI-D00123" he="136.82mm" wi="69.51mm" file="US20230007243A1-20230105-D00123.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00124" num="00124"><img id="EMI-D00124" he="162.64mm" wi="110.91mm" file="US20230007243A1-20230105-D00124.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00125" num="00125"><img id="EMI-D00125" he="232.49mm" wi="169.76mm" orientation="landscape" file="US20230007243A1-20230105-D00125.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">CROSS REFERENCE TO RELATED APPLICATIONS</heading><p id="p-0002" num="0001">This application is a U.S. continuation application of U.S. application Ser. No. 17/137,061, filed Dec. 29, 2020, which is a U.S. continuation application of PCT International Patent Application Number PCT/JP2019/026212 filed on Jul. 2, 2019, claiming the benefit of priority of U.S. Provisional Patent Application No. 62/693,987 filed on Jul. 4, 2018, the entire contents of which are hereby incorporated by reference.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">BACKGROUND</heading><heading id="h-0003" level="1">Technical Field</heading><p id="p-0003" num="0002">This disclosure relates to video coding, and particularly to video encoding and decoding systems, components, and methods in video coding and decoding.</p><heading id="h-0004" level="1">Description of the Related Art</heading><p id="p-0004" num="0003">With advancements in video coding technology, from H.261 and MPEG-1 to H.264/AVC (Advanced Video Coding), MPEG-LA, H.265/HEVC (High Efficiency Video Coding) and H.266/VVC (Versatile Video Codec), there remains a constant need to provide improvements and optimizations to the video coding technology to process an ever-increasing amount of digital video data in various applications. This disclosure relates to further advancements, improvements and optimizations in video coding.</p><heading id="h-0005" level="1">BRIEF SUMMARY</heading><p id="p-0005" num="0004">An encoder according to one aspect of the present disclosure is an encoder which encodes a video. The encoder includes: circuitry; and memory coupled to the circuitry. In the encoder, the circuitry, in operation, stores a first parameter into a bitstream, the first parameter indicating, as a prediction mode, one of (i) a multiple prediction mode in which a prediction image is generated by overlapping an inter prediction image of a current block and an intra prediction image of the current block and (ii) one of a plurality of prediction modes including a non-rectangular mode in which a prediction image is generated for each non-rectangular partition in the current block, and encodes the current block according to the prediction mode.</p><p id="p-0006" num="0005">A decoder according to one aspect of the present disclosure is a decoder which decodes a video. The decoder includes: circuitry; and memory coupled to the circuitry. In the decoder, the circuitry, in operation, parses a first parameter from a bitstream, the first parameter indicating, as a prediction mode, one of (i) a multiple prediction mode in which a prediction image is generated by overlapping an inter prediction image of a current block and an intra prediction image of the current block and (ii) one of a plurality of prediction modes including a non-rectangular mode in which a prediction image is generated for each non-rectangular partition in the current block, and decodes the current block according to the prediction mode.</p><p id="p-0007" num="0006">It should be noted that these general and specific aspects may be implemented using a system, an apparatus, a method, an integrated circuit, a computer program, or a non-transitory computer-readable recording medium such as a compact disc read only memory (CD-ROM), or any combination of systems, apparatuses, methods integrated circuits, computer programs, or recording media.</p><p id="p-0008" num="0007">In video coding technology, it is desirable to propose new methods in order to improve coding efficiency, enhance image quality, and reduce circuit scale. Some implementations of embodiments of the present disclosure, including constituent elements of embodiments of the present disclosure considered alone or in various combinations, may facilitate one or more of the following: improvement in coding efficiency, enhancement in image quality, reduction in utilization of processing resources associated with encoding/decoding, reduction in circuit scale, improvement in processing speed of encoding/decoding, etc.</p><p id="p-0009" num="0008">In addition, some implementations of embodiments of the present disclosure, including constituent elements of embodiments of the present disclosure considered alone or in various combinations, may facilitate, in encoding and decoding, appropriate selection of one or more elements, such as a filter, a block, a size, a motion vector, a reference picture, a reference block or an operation. It is to be noted that the present disclosure includes disclosure regarding configurations and methods which may provide advantages other than the above-described advantages. Examples of such configurations and methods include a configuration or method for improving coding efficiency while reducing an increase in the use of processing resources.</p><p id="p-0010" num="0009">Additional benefits and advantages of the disclosed embodiments will become apparent from the specification and drawings. The benefits and/or advantages may be individually obtained by the various embodiments and features of the specification and drawings, not all of which need to be provided in order to obtain one or more of such benefits and/or advantages.</p><p id="p-0011" num="0010">It should be noted that general or specific embodiments may be implemented as a system, a method, an integrated circuit, a computer program, a storage medium, or any selective combination thereof.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0006" level="1">BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS</heading><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a schematic diagram illustrating one example of a functional configuration of a transmission system according to an embodiment.</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a conceptual diagram for illustrating one example of a hierarchical structure of data in a stream.</p><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a conceptual diagram for illustrating one example of a slice configuration.</p><p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a conceptual diagram for illustrating one example of a tile configuration.</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a conceptual diagram for illustrating one example of an encoding structure in scalable encoding.</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a conceptual diagram for illustrating one example of an encoding structure in scalable encoding.</p><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a block diagram illustrating a functional configuration of an encoder according to an embodiment.</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is functional block diagram illustrating a mounting example of the encoder.</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a flow chart indicating one example of an overall encoding process performed by the encoder.</p><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a conceptual diagram for illustrating one example of block splitting.</p><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. <b>11</b></figref> is a block diagram illustrating one example of a functional configuration of a splitter according to an embodiment.</p><p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. <b>12</b></figref> is a conceptual diagram for illustrating examples of splitting patterns.</p><p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. <b>13</b>A</figref> is a conceptual diagram for illustrating one example of a syntax tree of a splitting pattern.</p><p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. <b>13</b>B</figref> is a conceptual diagram for illustrating another example of a syntax tree of a splitting pattern.</p><p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. <b>14</b></figref> is a chart indicating example transform basis functions for various transform types.</p><p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. <b>15</b></figref> is a conceptual diagram for illustrating example spatially varying transforms (SVT).</p><p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. <b>16</b></figref> is a flow chart illustrating one example of a process performed by a transformer.</p><p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. <b>17</b></figref> is a flow chart illustrating another example of a process performed by the transformer.</p><p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. <b>18</b></figref> is a block diagram illustrating one example of a functional configuration of a quantizer according to an embodiment.</p><p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. <b>19</b></figref> is a flow chart illustrating one example of quantization process performed by the quantizer.</p><p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. <b>20</b></figref> is a block diagram illustrating one example of a functional configuration of an entropy encoder according to an embodiment.</p><p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. <b>21</b></figref> is a conceptual diagram for illustrating an example flow of a context-based adaptive binary arithmetic coding (CABAC) process in the entropy encoder.</p><p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. <b>22</b></figref> is a block diagram illustrating one example of a functional configuration of loop filter according to an embodiment.</p><p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. <b>23</b>A</figref> is a conceptual diagram for illustrating one example of a filter shape used in an adaptive loop filter (ALF).</p><p id="p-0036" num="0035"><figref idref="DRAWINGS">FIG. <b>23</b>B</figref> is a conceptual diagram for illustrating another example of a filter shape used in an ALF.</p><p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. <b>23</b>C</figref> is a conceptual diagram for illustrating another example of a filter shape used in an ALF.</p><p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. <b>23</b>D</figref> is a conceptual diagram for illustrating an example flow of a cross component ALF (CC-ALF).</p><p id="p-0039" num="0038"><figref idref="DRAWINGS">FIG. <b>23</b>E</figref> is a conceptual diagram for illustrating an example of a filter shape used in a CC-ALF.</p><p id="p-0040" num="0039"><figref idref="DRAWINGS">FIG. <b>23</b>F</figref> is a conceptual diagram for illustrating an example flow of a Joint Chroma CCALF (JC-CCALF).</p><p id="p-0041" num="0040"><figref idref="DRAWINGS">FIG. <b>23</b>G</figref> is a table illustrating example weight index candidates that may be employed in a JC-CCALF.</p><p id="p-0042" num="0041"><figref idref="DRAWINGS">FIG. <b>24</b></figref> is a block diagram indicating one example of a specific configuration of a loop filter which functions as a deblocking filter (DBF).</p><p id="p-0043" num="0042"><figref idref="DRAWINGS">FIG. <b>25</b></figref> is a conceptual diagram for illustrating an example of a deblocking filter having a symmetrical filtering characteristic with respect to a block boundary.</p><p id="p-0044" num="0043"><figref idref="DRAWINGS">FIG. <b>26</b></figref> is a conceptual diagram for illustrating a block boundary on which a deblocking filter process is performed.</p><p id="p-0045" num="0044"><figref idref="DRAWINGS">FIG. <b>27</b></figref> is a conceptual diagram for illustrating examples of Boundary strength (Bs) values.</p><p id="p-0046" num="0045"><figref idref="DRAWINGS">FIG. <b>28</b></figref> is a flow chart illustrating one example of a process performed by a predictor of the encoder.</p><p id="p-0047" num="0046"><figref idref="DRAWINGS">FIG. <b>29</b></figref> is a flow chart illustrating another example of a process performed by the predictor of the encoder.</p><p id="p-0048" num="0047"><figref idref="DRAWINGS">FIG. <b>30</b></figref> is a flow chart illustrating another example of a process performed by the predictor of the encoder.</p><p id="p-0049" num="0048"><figref idref="DRAWINGS">FIG. <b>31</b></figref> is a conceptual diagram for illustrating sixty-seven intra prediction modes used in intra prediction in an embodiment.</p><p id="p-0050" num="0049"><figref idref="DRAWINGS">FIG. <b>32</b></figref> is a flow chart illustrating one example of a process performed by an intra predictor.</p><p id="p-0051" num="0050"><figref idref="DRAWINGS">FIG. <b>33</b></figref> is a conceptual diagram for illustrating examples of reference pictures.</p><p id="p-0052" num="0051"><figref idref="DRAWINGS">FIG. <b>34</b></figref> is a conceptual diagram for illustrating examples of reference picture lists.</p><p id="p-0053" num="0052"><figref idref="DRAWINGS">FIG. <b>35</b></figref> is a flow chart illustrating an example basic processing flow of inter prediction.</p><p id="p-0054" num="0053"><figref idref="DRAWINGS">FIG. <b>36</b></figref> is a flow chart illustrating one example of a process of derivation of motion vectors.</p><p id="p-0055" num="0054"><figref idref="DRAWINGS">FIG. <b>37</b></figref> is a flow chart illustrating another example of a process of derivation of motion vectors.</p><p id="p-0056" num="0055"><figref idref="DRAWINGS">FIGS. <b>38</b>A and <b>38</b>B</figref> are conceptual diagrams for illustrating example characterizations of modes for MV derivation.</p><p id="p-0057" num="0056"><figref idref="DRAWINGS">FIG. <b>39</b></figref> is a flow chart illustrating an example of a process of inter prediction in normal inter mode.</p><p id="p-0058" num="0057"><figref idref="DRAWINGS">FIG. <b>40</b></figref> is a flow chart illustrating an example of a process of inter prediction in normal merge mode.</p><p id="p-0059" num="0058"><figref idref="DRAWINGS">FIG. <b>41</b></figref> is a conceptual diagram for illustrating one example of a motion vector derivation process in merge mode.</p><p id="p-0060" num="0059"><figref idref="DRAWINGS">FIG. <b>42</b></figref> is a conceptual diagram for illustrating one example of a MV derivation process for a current picture by HMVP merge mode.</p><p id="p-0061" num="0060"><figref idref="DRAWINGS">FIG. <b>43</b></figref> is a flow chart illustrating one example of a frame rate up conversion (FRUC) process.</p><p id="p-0062" num="0061"><figref idref="DRAWINGS">FIG. <b>44</b></figref> is a conceptual diagram for illustrating one example of pattern matching (bilateral matching) between two blocks along a motion trajectory.</p><p id="p-0063" num="0062"><figref idref="DRAWINGS">FIG. <b>45</b></figref> is a conceptual diagram for illustrating one example of pattern matching (template matching) between a template in a current picture and a block in a reference picture.</p><p id="p-0064" num="0063"><figref idref="DRAWINGS">FIG. <b>46</b>A</figref> is a conceptual diagram for illustrating one example of deriving a motion vector of each sub-block based on motion vectors of a plurality of neighboring blocks.</p><p id="p-0065" num="0064"><figref idref="DRAWINGS">FIG. <b>46</b>B</figref> is a conceptual diagram for illustrating one example of deriving a motion vector of each sub-block in affine mode in which three control points are used.</p><p id="p-0066" num="0065"><figref idref="DRAWINGS">FIG. <b>47</b>A</figref> is a conceptual diagram for illustrating an example MV derivation at control points in an affine mode.</p><p id="p-0067" num="0066"><figref idref="DRAWINGS">FIG. <b>47</b>B</figref> is a conceptual diagram for illustrating an example MV derivation at control points in an affine mode.</p><p id="p-0068" num="0067"><figref idref="DRAWINGS">FIG. <b>47</b>C</figref> is a conceptual diagram for illustrating an example MV derivation at control points in an affine mode.</p><p id="p-0069" num="0068"><figref idref="DRAWINGS">FIG. <b>48</b>A</figref> is a conceptual diagram for illustrating an affine mode in which two control points are used.</p><p id="p-0070" num="0069"><figref idref="DRAWINGS">FIG. <b>48</b>B</figref> is a conceptual diagram for illustrating an affine mode in which three control points are used.</p><p id="p-0071" num="0070"><figref idref="DRAWINGS">FIG. <b>49</b>A</figref> is a conceptual diagram for illustrating one example of a method for MV derivation at control points when the number of control points for an encoded block and the number of control points for a current block are different from each other.</p><p id="p-0072" num="0071"><figref idref="DRAWINGS">FIG. <b>49</b>B</figref> is a conceptual diagram for illustrating another example of a method for MV derivation at control points when the number of control points for an encoded block and the number of control points for a current block are different from each other.</p><p id="p-0073" num="0072"><figref idref="DRAWINGS">FIG. <b>50</b></figref> is a flow chart illustrating one example of a process in affine merge mode.</p><p id="p-0074" num="0073"><figref idref="DRAWINGS">FIG. <b>51</b></figref> is a flow chart illustrating one example of a process in affine inter mode.</p><p id="p-0075" num="0074"><figref idref="DRAWINGS">FIG. <b>52</b>A</figref> is a conceptual diagram for illustrating generation of two triangular prediction images.</p><p id="p-0076" num="0075"><figref idref="DRAWINGS">FIG. <b>52</b>B</figref> is a conceptual diagram for illustrating examples of a first portion of a first partition which overlaps with a second partition, and first and second sets of samples which may be weighted as part of a correction process.</p><p id="p-0077" num="0076"><figref idref="DRAWINGS">FIG. <b>52</b>C</figref> is a conceptual diagram for illustrating a first portion of a first partition, which is a portion of the first partition that overlaps with a portion of an adjacent partition.</p><p id="p-0078" num="0077"><figref idref="DRAWINGS">FIG. <b>53</b></figref> is a flow chart illustrating one example of a process in a triangle mode.</p><p id="p-0079" num="0078"><figref idref="DRAWINGS">FIG. <b>54</b></figref> is a conceptual diagram for illustrating one example of an Advanced Temporal Motion Vector Prediction (ATMVP) mode in which a MV is derived in units of a sub-block.</p><p id="p-0080" num="0079"><figref idref="DRAWINGS">FIG. <b>55</b></figref> is a flow chart illustrating a relationship between a merge mode and dynamic motion vector refreshing (DMVR).</p><p id="p-0081" num="0080"><figref idref="DRAWINGS">FIG. <b>56</b></figref> is a conceptual diagram for illustrating one example of DMVR.</p><p id="p-0082" num="0081"><figref idref="DRAWINGS">FIG. <b>57</b></figref> is a conceptual diagram for illustrating another example of DMVR for determining a MV.</p><p id="p-0083" num="0082"><figref idref="DRAWINGS">FIG. <b>58</b>A</figref> is a conceptual diagram for illustrating one example of motion estimation in DMVR.</p><p id="p-0084" num="0083"><figref idref="DRAWINGS">FIG. <b>58</b>B</figref> is a flow chart illustrating one example of a process of motion estimation in DMVR.</p><p id="p-0085" num="0084"><figref idref="DRAWINGS">FIG. <b>59</b></figref> is a flow chart illustrating one example of a process of generation of a prediction image.</p><p id="p-0086" num="0085"><figref idref="DRAWINGS">FIG. <b>60</b></figref> is a flow chart illustrating another example of a process of generation of a prediction image.</p><p id="p-0087" num="0086"><figref idref="DRAWINGS">FIG. <b>61</b></figref> is a flow chart illustrating one example of a correction process of a prediction image by overlapped block motion compensation (OBMC).</p><p id="p-0088" num="0087"><figref idref="DRAWINGS">FIG. <b>62</b></figref> is a conceptual diagram for illustrating one example of a prediction image correction process by OBMC.</p><p id="p-0089" num="0088"><figref idref="DRAWINGS">FIG. <b>63</b></figref> is a conceptual diagram for illustrating a model assuming uniform linear motion.</p><p id="p-0090" num="0089"><figref idref="DRAWINGS">FIG. <b>64</b></figref> is a flow chart illustrating one example of a process of inter prediction according to BIO.</p><p id="p-0091" num="0090"><figref idref="DRAWINGS">FIG. <b>65</b></figref> is a functional block diagram illustrating one example of a functional configuration of an inter predictor which may perform inter prediction according to BIO.</p><p id="p-0092" num="0091"><figref idref="DRAWINGS">FIG. <b>66</b>A</figref> is a conceptual diagram for illustrating one example of process of a prediction image generation method using a luminance correction process performed by LIC.</p><p id="p-0093" num="0092"><figref idref="DRAWINGS">FIG. <b>66</b>B</figref> is a flow chart illustrating one example of a process of prediction image generation method using the LIC.</p><p id="p-0094" num="0093"><figref idref="DRAWINGS">FIG. <b>67</b></figref> is a block diagram illustrating a functional configuration of a decoder according to an embodiment.</p><p id="p-0095" num="0094"><figref idref="DRAWINGS">FIG. <b>68</b></figref> is a functional block diagram illustrating a mounting example of a decoder.</p><p id="p-0096" num="0095"><figref idref="DRAWINGS">FIG. <b>69</b></figref> is a flow chart illustrating one example of an overall decoding process performed by the decoder.</p><p id="p-0097" num="0096"><figref idref="DRAWINGS">FIG. <b>70</b></figref> is a conceptual diagram for illustrating a relationship between a splitting determiner and other constituent elements.</p><p id="p-0098" num="0097"><figref idref="DRAWINGS">FIG. <b>71</b></figref> is a block diagram illustrating one example of a functional configuration of an entropy decoder.</p><p id="p-0099" num="0098"><figref idref="DRAWINGS">FIG. <b>72</b></figref> is a conceptual diagram for illustrating an example flow of a CABAC process in the entropy decoder.</p><p id="p-0100" num="0099"><figref idref="DRAWINGS">FIG. <b>73</b></figref> is a block diagram illustrating one example of a functional configuration of an inverse quantizer.</p><p id="p-0101" num="0100"><figref idref="DRAWINGS">FIG. <b>74</b></figref> is a flow chart illustrating one example of a process of inverse quantization performed by the inverse quantizer.</p><p id="p-0102" num="0101"><figref idref="DRAWINGS">FIG. <b>75</b></figref> is a flow chart illustrating one example of a process performed by an inverse transformer.</p><p id="p-0103" num="0102"><figref idref="DRAWINGS">FIG. <b>76</b></figref> is a flow chart illustrating another example of a process performed by the inverse transformer.</p><p id="p-0104" num="0103"><figref idref="DRAWINGS">FIG. <b>77</b></figref> is a block diagram illustrating one example of a functional configuration of a loop filter.</p><p id="p-0105" num="0104"><figref idref="DRAWINGS">FIG. <b>78</b></figref> is a flow chart illustrating one example of a process performed by a predictor of the decoder.</p><p id="p-0106" num="0105"><figref idref="DRAWINGS">FIG. <b>79</b></figref> is a flow chart illustrating another example of a process performed by the predictor of the decoder.</p><p id="p-0107" num="0106"><figref idref="DRAWINGS">FIGS. <b>80</b>A to <b>80</b>C</figref> are a flow chart illustrating another example of a process performed by the predictor of the decoder.</p><p id="p-0108" num="0107"><figref idref="DRAWINGS">FIG. <b>81</b></figref> is a diagram illustrating one example of a process performed by an intra predictor of the decoder.</p><p id="p-0109" num="0108"><figref idref="DRAWINGS">FIG. <b>82</b></figref> is a flow chart illustrating one example of a process of MV derivation in the decoder.</p><p id="p-0110" num="0109"><figref idref="DRAWINGS">FIG. <b>83</b></figref> is a flow chart illustrating another example of a process of MV derivation in the decoder.</p><p id="p-0111" num="0110"><figref idref="DRAWINGS">FIG. <b>84</b></figref> is a flow chart illustrating an example of a process of inter prediction by normal inter mode in the decoder.</p><p id="p-0112" num="0111"><figref idref="DRAWINGS">FIG. <b>85</b></figref> is a flow chart illustrating an example of a process of inter prediction by normal merge mode in the decoder.</p><p id="p-0113" num="0112"><figref idref="DRAWINGS">FIG. <b>86</b></figref> is a flow chart illustrating an example of a process of inter prediction by FRUC mode in the decoder.</p><p id="p-0114" num="0113"><figref idref="DRAWINGS">FIG. <b>87</b></figref> is a flow chart illustrating an example of a process of inter prediction by affine merge mode in the decoder.</p><p id="p-0115" num="0114"><figref idref="DRAWINGS">FIG. <b>88</b></figref> is a flow chart illustrating an example of a process of inter prediction by affine inter mode in the decoder.</p><p id="p-0116" num="0115"><figref idref="DRAWINGS">FIG. <b>89</b></figref> is a flow chart illustrating an example of a process of inter prediction by triangle mode in the decoder.</p><p id="p-0117" num="0116"><figref idref="DRAWINGS">FIG. <b>90</b></figref> is a flow chart illustrating an example of a process of motion estimation by DMVR in the decoder.</p><p id="p-0118" num="0117"><figref idref="DRAWINGS">FIG. <b>91</b></figref> is a flow chart illustrating one example process of motion estimation by DMVR in the decoder.</p><p id="p-0119" num="0118"><figref idref="DRAWINGS">FIG. <b>92</b></figref> is a flow chart illustrating one example of a process of generation of a prediction image in the decoder.</p><p id="p-0120" num="0119"><figref idref="DRAWINGS">FIG. <b>93</b></figref> is a flow chart illustrating another example of a process of generation of a prediction image in the decoder.</p><p id="p-0121" num="0120"><figref idref="DRAWINGS">FIG. <b>94</b></figref> is a flow chart illustrating an example of a process of correction of a prediction image by OBMC in the decoder.</p><p id="p-0122" num="0121"><figref idref="DRAWINGS">FIG. <b>95</b></figref> is a flow chart illustrating an example of a process of correction of a prediction image by BIO in the decoder.</p><p id="p-0123" num="0122"><figref idref="DRAWINGS">FIG. <b>96</b></figref> is a flow chart illustrating an example of a process of correction of a prediction image by LIC in the decoder.</p><p id="p-0124" num="0123"><figref idref="DRAWINGS">FIG. <b>97</b></figref> is a flowchart illustrating one example of prediction processing according to a first aspect.</p><p id="p-0125" num="0124"><figref idref="DRAWINGS">FIG. <b>98</b></figref> is a diagram for explaining more specifically one example of the prediction processing according to the first aspect.</p><p id="p-0126" num="0125"><figref idref="DRAWINGS">FIG. <b>99</b></figref> is a diagram illustrating an example of a current block being split into a plurality of partitions which include at least one non-quadrilateral partition.</p><p id="p-0127" num="0126"><figref idref="DRAWINGS">FIG. <b>100</b></figref> is a diagram illustrating an example of a current block being split into two triangular partitions.</p><p id="p-0128" num="0127"><figref idref="DRAWINGS">FIG. <b>101</b></figref> is a diagram for explaining one example of encoding processing according to Variation 1 of the first aspect.</p><p id="p-0129" num="0128"><figref idref="DRAWINGS">FIG. <b>102</b></figref> is a diagram for explaining one example of encoding processing according to Variation 2 of the first aspect.</p><p id="p-0130" num="0129"><figref idref="DRAWINGS">FIG. <b>103</b></figref> is a flowchart illustrating one example of encoding processing according to a second aspect.</p><p id="p-0131" num="0130"><figref idref="DRAWINGS">FIG. <b>104</b></figref> is a diagram for explaining more specifically one example of the encoding processing according to the second aspect.</p><p id="p-0132" num="0131"><figref idref="DRAWINGS">FIG. <b>105</b></figref> is a diagram for explaining one example of encoding processing according to Variation 1 of the second aspect.</p><p id="p-0133" num="0132"><figref idref="DRAWINGS">FIG. <b>106</b></figref> is a diagram for explaining one example of encoding processing according to Variation 2 of the second aspect.</p><p id="p-0134" num="0133"><figref idref="DRAWINGS">FIG. <b>107</b></figref> is a diagram for explaining one example of encoding processing according to an aspect of a combination of the first aspect and the second aspect.</p><p id="p-0135" num="0134"><figref idref="DRAWINGS">FIG. <b>108</b></figref> is a flowchart illustrating one example of encoding processing according to a third aspect.</p><p id="p-0136" num="0135"><figref idref="DRAWINGS">FIG. <b>109</b></figref> is a diagram for explaining more specifically one example of the encoding processing according to the third aspect.</p><p id="p-0137" num="0136"><figref idref="DRAWINGS">FIG. <b>110</b></figref> is a flowchart illustrating one example of encoding processing according to a fourth aspect.</p><p id="p-0138" num="0137"><figref idref="DRAWINGS">FIG. <b>111</b></figref> is a diagram for explaining more specifically one example of the encoding processing according to the fourth aspect.</p><p id="p-0139" num="0138"><figref idref="DRAWINGS">FIG. <b>112</b></figref> is a diagram for explaining one example of encoding processing according to a variation of the fourth aspect.</p><p id="p-0140" num="0139"><figref idref="DRAWINGS">FIG. <b>113</b></figref> is a diagram illustrating an example overall configuration of a content providing system for implementing a content distribution service.</p><p id="p-0141" num="0140"><figref idref="DRAWINGS">FIG. <b>114</b></figref> is a conceptual diagram for illustrating an example of a display screen of a web page.</p><p id="p-0142" num="0141"><figref idref="DRAWINGS">FIG. <b>115</b></figref> is a conceptual diagram for illustrating an example of a display screen of a web page.</p><p id="p-0143" num="0142"><figref idref="DRAWINGS">FIG. <b>116</b></figref> is a block diagram illustrating one example of a smartphone.</p><p id="p-0144" num="0143"><figref idref="DRAWINGS">FIG. <b>117</b></figref> is a block diagram illustrating an example of a functional configuration of a smartphone.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0007" level="1">DETAILED DESCRIPTION</heading><p id="p-0145" num="0144">In the drawings, identical reference numbers identify similar elements, unless the context indicates otherwise. The sizes and relative positions of elements in the drawings are not necessarily drawn to scale.</p><p id="p-0146" num="0145">Hereinafter, embodiments will be described with reference to the drawings. Note that the embodiments described below each show a general or specific example. The numerical values, shapes, materials, components, the arrangement and connection of the components, steps, the relation and order of the steps, etc., indicated in the following embodiments are mere examples, and are not intended to limit the scope of the claims.</p><p id="p-0147" num="0146">Embodiments of an encoder and a decoder will be described below. The embodiments are examples of an encoder and a decoder to which the processes and/or configurations presented in the description of aspects of the present disclosure are applicable. The processes and/or configurations can also be implemented in an encoder and a decoder different from those according to the embodiments. For example, regarding the processes and/or configurations as applied to the embodiments, any of the following may be implemented:</p><p id="p-0148" num="0147">(1) Any of the components of the encoder or the decoder according to the embodiments presented in the description of aspects of the present disclosure may be substituted or combined with another component presented anywhere in the description of aspects of the present disclosure.</p><p id="p-0149" num="0148">(2) In the encoder or the decoder according to the embodiments, discretionary changes may be made to functions or processes performed by one or more components of the encoder or the decoder, such as addition, substitution, removal, etc., of the functions or processes. For example, any function or process may be substituted or combined with another function or process presented anywhere in the description of aspects of the present disclosure.</p><p id="p-0150" num="0149">(3) In methods implemented by the encoder or the decoder according to the embodiments, discretionary changes may be made such as addition, substitution, and removal of one or more of the processes included in the method. For example, any process in the method may be substituted or combined with another process presented anywhere in the description of aspects of the present disclosure.</p><p id="p-0151" num="0150">(4) One or more components included in the encoder or the decoder according to embodiments may be combined with a component presented anywhere in the description of aspects of the present disclosure, may be combined with a component including one or more functions presented anywhere in the description of aspects of the present disclosure, and may be combined with a component that implements one or more processes implemented by a component presented in the description of aspects of the present disclosure.</p><p id="p-0152" num="0151">(5) A component including one or more functions of the encoder or the decoder according to the embodiments, or a component that implements one or more processes of the encoder or the decoder according to the embodiments, may be combined or substituted with a component presented anywhere in the description of aspects of the present disclosure, with a component including one or more functions presented anywhere in the description of aspects of the present disclosure, or with a component that implements one or more processes presented anywhere in the description of aspects of the present disclosure.</p><p id="p-0153" num="0152">(6) In methods implemented by the encoder or the decoder according to the embodiments, any of the processes included in the method may be substituted or combined with a process presented anywhere in the description of aspects of the present disclosure or with any corresponding or equivalent process.</p><p id="p-0154" num="0153">(7) One or more processes included in methods implemented by the encoder or the decoder according to the embodiments may be combined with a process presented anywhere in the description of aspects of the present disclosure.</p><p id="p-0155" num="0154">(8) The implementation of the processes and/or configurations presented in the description of aspects of the present disclosure is not limited to the encoder or the decoder according to the embodiments. For example, the processes and/or configurations may be implemented in a device used for a purpose different from the moving picture encoder or the moving picture decoder disclosed in the embodiments.</p><heading id="h-0008" level="1">Definitions of Terms</heading><p id="p-0156" num="0155">The respective terms may be defined as indicated below as examples.</p><p id="p-0157" num="0156">An image is a data unit configured with a set of pixels, is a picture, or includes blocks smaller than a pixel. Images include a still image in addition to a video.</p><p id="p-0158" num="0157">A picture is an image processing unit configured with a set of pixels, and also may be referred to as a frame or a field. A picture may, for example, take the form of an array of luma samples in monochrome format or an array of luma samples and two corresponding arrays of chroma samples in 4:2:0, 4:2:2, and 4:4:4 color format.</p><p id="p-0159" num="0158">A block is a processing unit which is a set of a determined number of pixels. Blocks may have any number of different shapes. For example, a block may have a rectangular shape of M&#xd7;N (M-column by N-row) pixels, a square shape of M&#xd7;M pixels, a triangular shape, a circular shape, etc. Examples of blocks include slices, tiles, bricks, CTUs, super blocks, basic splitting units, VPDUs, processing splitting units for hardware, CUs, processing block units, prediction block units (PUs) orthogonal transform block units (TUs), units, and sub-blocks. A block may take the form of an M&#xd7;N array of samples, or an M&#xd7;N array of transform coefficients. For example, a block may be a square or rectangular region of pixels including one Luma and two Chroma matrices.</p><p id="p-0160" num="0159">A pixel or sample is a smallest point of an image. Pixels or samples include a pixel at an integer position, as well as pixels at sub-pixel positions, e.g., generated based on a pixel at an integer position.</p><p id="p-0161" num="0160">A pixel value or a sample value is an eigenvalue of a pixel. Pixel values or sample values may include one or more of a luma value, a chroma value, an RGB gradation level, a depth value, binary values of zero or 1, etc.</p><p id="p-0162" num="0161">Chroma or chrominance is an intensity of a color, typically represented by the symbols Cb and Cr, which specify that values of a sample array or a single sample value represent values of one of two color difference signals related to the primary colors.</p><p id="p-0163" num="0162">Luma or luminance is a brightness of an image, typically represented by the symbol or the subscript Y or L, which specify that values of a sample array or a single sample value represent values of a monochrome signal related to the primary colors.</p><p id="p-0164" num="0163">A flag comprises one or more bits which indicate a value, for example, of a parameter or index. A flag may be a binary flag which indicates a binary value of the flag, which also may indicate a non-binary value of a parameter.</p><p id="p-0165" num="0164">A signal conveys information, which is symbolized by or encoded into the signal. Signals include discrete digital signals and continuous analog signals.</p><p id="p-0166" num="0165">A stream or a bitstream is a digital data string of a digital data flow. A stream or bitstream may be one stream or may be configured with a plurality of streams having a plurality of hierarchical layers. A stream or bitstream may be transmitted in serial communication using a single transmission path, or may be transmitted in packet communication using a plurality of transmission paths.</p><p id="p-0167" num="0166">A difference refers to various mathematical differences, such as a simple difference (x&#x2212;y), an absolute value of a difference (|x&#x2212;y|), a squared difference (x{circumflex over (&#x2003;)}2&#x2212;y{circumflex over (&#x2003;)}2), a square root of a difference (&#x221a;(x&#x2212;y)), a weighted difference (ax&#x2212;by: a and b are constants), an offset difference (x&#x2212;y+a: a is an offset), etc. In the case of scalar quantity, a simple difference may suffice, and a difference calculation be included. A sum refers to various mathematical sums, such as a simple sum (x+y), an absolute value of a sum (|x+y|), a squared sum (x{circumflex over (&#x2003;)}2+y{circumflex over (&#x2003;)}2), a square root of a sum (&#x221a;(x+y)), a weighted difference (ax+by: a and b are constants), an offset sum (x+y+a: a is an offset), etc. In the case of scalar quantity, a simple sum may suffice, and a sum calculation be included.</p><p id="p-0168" num="0167">A frame is the composition of a top field and a bottom field, where sample rows 0, 2, 4, . . . originate from the top field and sample rows 1, 3, 5, . . . originate from the bottom field.</p><p id="p-0169" num="0168">A slice is an integer number of coding tree units contained in one independent slice segment and all subsequent dependent slice segments (if any) that precede the next independent slice segment (if any) within the same access unit.</p><p id="p-0170" num="0169">A tile is a rectangular region of coding tree blocks within a particular tile column and a particular tile row in a picture. A tile may be a rectangular region of the frame that is intended to be able to be decoded and encoded independently, although loop-filtering across tile edges may still be applied.</p><p id="p-0171" num="0170">A coding tree unit (CTU) may be a coding tree block of luma samples of a picture that has three sample arrays, or two corresponding coding tree blocks of chroma samples. Alternatively, a CTU may be a coding tree block of samples of one of a monochrome picture and a picture that is coded using three separate color planes and syntax structures used to code the samples. A super block may be a square block of 64&#xd7;64 pixels that consists of either 1 or 2 mode info blocks or is recursively partitioned into four 32&#xd7;32 blocks, which themselves can be further partitioned.</p><heading id="h-0009" level="2">[System Configuration]</heading><p id="p-0172" num="0171">First, a transmission system according to an embodiment will be described. <figref idref="DRAWINGS">FIG. <b>1</b></figref> is a schematic diagram illustrating one example of a configuration of a transmission system <b>400</b> according to an embodiment.</p><p id="p-0173" num="0172">The transmission system <b>400</b> is a system which transmits a stream generated by encoding an image and decodes the transmitted stream. As illustrated, transmission system <b>400</b> includes an encoder <b>100</b>, a network <b>300</b>, and decoder <b>200</b> as illustrated in <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0174" num="0173">An image is input to encoder <b>100</b>. Encoder <b>100</b> generates a stream by encoding the input image, and outputs the stream to network <b>300</b>. The stream includes, for example, the encoded image and control information for decoding the encoded image. The image is compressed by the encoding.</p><p id="p-0175" num="0174">It is to be noted that an image before being encoded by the encoder <b>100</b> is also referred to as the original image, the original signal, or the original sample. The image may be a video or a still image. An image is a generic concept of a sequence, a picture, and a block, and thus is not limited to a spatial region having a particular size and to a temporal region having a particular size unless otherwise specified. An image is an array of pixels or pixel values, and the signal representing the image or pixel values are also referred to as samples. The stream may be referred to as a bitstream, an encoded bitstream, a compressed bitstream, or an encoded signal. Furthermore, the encoder <b>100</b> may be referred to as an image encoder or a video encoder. The encoding method performed by encoder <b>100</b> may be referred to as an encoding method, an image encoding method, or a video encoding method.</p><p id="p-0176" num="0175">The network <b>300</b> transmits the stream generated by encoder <b>100</b> to decoder <b>200</b>. The network <b>200</b> may be the Internet, a Wide Area Network (WAN), a Local Area Network (LAN), or any combination of networks. The network <b>300</b> is not limited to a bi-directional communication network, and may be a uni-directional communication network which transmits broadcast waves of digital terrestrial broadcasting, satellite broadcasting, or the like. Alternatively, the network <b>300</b> may be replaced by a recording medium such as a Digital Versatile Disc (DVD) and a Blue-Ray Disc (BD), etc. on which a stream is recorded.</p><p id="p-0177" num="0176">The decoder <b>200</b> generates, for example, a decoded image which is an uncompressed image, by decoding a stream transmitted by network <b>300</b>. For example, the decoder decodes a stream according to a decoding method corresponding to an encoding method employed by encoder <b>100</b>.</p><p id="p-0178" num="0177">It is to be noted that the decoder <b>200</b> may also be referred to as an image decoder or a video decoder, and that the decoding method performed by the decoder <b>200</b> may also be referred to as a decoding method, an image decoding method, or a video decoding method.</p><heading id="h-0010" level="2">[Data Structure]</heading><p id="p-0179" num="0178"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a conceptual diagram for illustrating one example of a hierarchical structure of data in a stream. For convenience, <figref idref="DRAWINGS">FIG. <b>2</b></figref> will be described with reference to the transmission system <b>400</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. A stream includes, for example, a video sequence. As illustrated in (a) of <figref idref="DRAWINGS">FIG. <b>2</b></figref>, the video sequence includes a one or more video parameter sets (VPS), one or more sequence parameter sets (SPS), one or more picture parameter sets (PPS), supplemental enhancement information (SEI), and a plurality of pictures.</p><p id="p-0180" num="0179">In a video having a plurality of layers, a VPS may include a coding parameter which is common between some of the plurality of layers, and a coding parameter related to some of the plurality of layers included in the video or to an individual layer.</p><p id="p-0181" num="0180">An SPS includes a parameter which is used for a sequence, that is, a coding parameter which the decoder <b>200</b> refers to in order to decode the sequence. For example, the coding parameter may indicate the width or height of a picture. It is to be noted that a plurality of SPSs may be present.</p><p id="p-0182" num="0181">A PPS includes a parameter which is used for a picture, that is, a coding parameter which the decoder <b>200</b> refers to in order to decode each of the pictures in the sequence. For example, the coding parameter may include a reference value for a quantization width which is used to decode a picture and a flag indicating application of weighted prediction. It is to be noted that a plurality of PPSs may be present. Each of the SPS and the PPS may be simply referred to as a parameter set.</p><p id="p-0183" num="0182">As illustrated in (b) of <figref idref="DRAWINGS">FIG. <b>2</b></figref>, a picture may include a picture header and one or more slices. A picture header includes a coding parameter which the decoder <b>200</b> refers to in order to decode the one or more slices.</p><p id="p-0184" num="0183">As illustrated in (c) of <figref idref="DRAWINGS">FIG. <b>2</b></figref>, a slice includes a slice header and one or more bricks. A slice header includes a coding parameter which the decoder <b>200</b> refers to in order to decode the one or more bricks.</p><p id="p-0185" num="0184">As illustrated in (d) of <figref idref="DRAWINGS">FIG. <b>2</b></figref>, a brick includes one or more coding tree units (CTU).</p><p id="p-0186" num="0185">It is to be noted that a picture may not include any slice and may include a tile group instead of a slice. In this case, the tile group includes at least one tile. In addition, a brick may include a slice.</p><p id="p-0187" num="0186">A CTU is also referred to as a super block or a basis splitting unit. As illustrated in (e) of <figref idref="DRAWINGS">FIG. <b>2</b></figref>, a CTU includes a CTU header and at least one coding unit (CU). As illustrated, the CTU includes four coding units CU(<b>10</b>), CU(<b>11</b>), (CU(<b>12</b>) and CU(<b>13</b>). A CTU header includes a coding parameter which the decoder <b>200</b> refers to in order to decode the at least one CU.</p><p id="p-0188" num="0187">A CU may be split into a plurality of smaller CUs. As shown, CU(<b>10</b>) is not split into smaller coding units; CU(<b>11</b>) is split into four smaller coding units CU(<b>110</b>), CU(<b>111</b>), CU(<b>112</b>) and CU(<b>113</b>); CU(<b>12</b>) is not split into smaller coding units; and CU(<b>13</b>) is split into seven smaller coding units CU(<b>1310</b>), CU(<b>1311</b>), CU(<b>1312</b>), CU(<b>1313</b>), CU(<b>132</b>), CU(<b>133</b>) and CU(<b>134</b>) As illustrated in (f) of <figref idref="DRAWINGS">FIG. <b>2</b></figref>, a CU includes a CU header, prediction information, and residual coefficient information. Prediction information is information for predicting the CU, and the residual coefficient information is information indicating a prediction residual to be described later. Although a CU is basically the same as a prediction unit (PU) and a transform unit (TU), it is to be noted that, for example, a sub-block transform (SBT) to be described later may include a plurality of TUs smaller than the CU. In addition, the CU may be processed for each virtual pipeline decoding unit (VPDU) included in the CU. The VPDU is, for example, a fixed unit which can be processed at one stage when pipeline processing is performed in hardware.</p><p id="p-0189" num="0188">It is to be noted that a stream may not include all of the hierarchical layers illustrated in <figref idref="DRAWINGS">FIG. <b>2</b></figref>. The order of the hierarchical layers may be exchanged, or any of the hierarchical layers may be replaced by another hierarchical layer. Here, a picture which is a target for a process which is about to be performed by a device such as encoder <b>100</b> or decoder <b>200</b> is referred to as a current picture. A current picture means a current picture to be encoded when the process is an encoding process, and a current picture means a current picture to be decoded when the process is a decoding process. Likewise, for example, a CU or a block of CUs which is a target for a process which is about to be performed by a device such as the encoder <b>100</b> or the decoder <b>200</b> is referred to as a current block. A current block means a current block to be encoded when the process is an encoding process, and a current block means a current block to be decoded when the process is a decoding process.</p><heading id="h-0011" level="2">[Picture Structure: Slice/Tile]</heading><p id="p-0190" num="0189">A picture may be configured with one or more slice units or one or more tile units to facilitate coding/decoding of the picture in parallel.</p><p id="p-0191" num="0190">Slices are basic coding units included in a picture. A picture may include, for example, one or more slices. In addition, a slice includes one or more coding tree units (CTUs).</p><p id="p-0192" num="0191"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a conceptual diagram for illustrating one example of a slice configuration. For example, in <figref idref="DRAWINGS">FIG. <b>3</b></figref> a picture includes 11&#xd7;8 CTUs, and is split into four slices (slices <b>1</b> to <b>4</b>). Slice <b>1</b> includes sixteen CTUs, slice <b>2</b> includes twenty-one CTUs, slice <b>3</b> includes twenty-nine CTUs, and slice <b>4</b> includes twenty-two CTUs. Here, each CTU in the picture belongs to one of the slices. The shape of each slice is a shape obtained by splitting the picture horizontally. A boundary of each slice does not need to coincide with an image end, and may coincide with any of the boundaries between CTUs in the image. The processing order of the CTUs in a slice (an encoding order or a decoding order) is, for example, a raster-scan order. A slice includes a slice header and encoded data. Features of the slice may be written in the slice header. The features may include a CTU address of a top CTU in the slice, a slice type, etc.</p><p id="p-0193" num="0192">A tile is a unit of a rectangular region included in a picture. Tiles of a picture may be assigned with a number referred to as TileId in raster-scan order.</p><p id="p-0194" num="0193"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a conceptual diagram for illustrating one example of a tile configuration. For example, in <figref idref="DRAWINGS">FIG. <b>4</b></figref> a picture includes 11&#xd7;8 CTUs, and is split into four tiles of rectangular regions (tiles <b>1</b> to <b>4</b>). When tiles are used, the processing order of CTUs may be different from the processing order in the case where tiles are not used. When no tile is used, a plurality of CTUs in a picture generally are processed in raster-scan order. When a plurality of tiles are used, at least one CTU in each of the plurality of tiles is processed in raster-scan order. For example, as illustrated in <figref idref="DRAWINGS">FIG. <b>4</b></figref> the processing order of the CTUs included in tile <b>1</b> from the left-end of the first column of tile <b>1</b> toward the right-end of the first column of tile <b>1</b> and then continues from the left-end of the second column of tile <b>1</b> toward the right-end of the second column of tile <b>1</b>.</p><p id="p-0195" num="0194">It is to be noted that the one tile may include one or more slices, and one slice may include one or more tiles.</p><p id="p-0196" num="0195">It is to be noted that the picture may be configured with one or more tile sets. A tile set may include one or more tile groups, or one or more tiles. A picture may be configured with one of a tile set, a tile group, and a tile. For example, an order for scanning a plurality of tiles for each tile set in raster scan order is assumed to be a basic encoding order of tiles. A set of one or more tiles which are continuous in the basic encoding order in each tile set is assumed to be a tile group. Such a picture may be configured by splitter <b>102</b> (see <figref idref="DRAWINGS">FIG. <b>7</b></figref>) to be described later.</p><heading id="h-0012" level="2">[Scalable Encoding]</heading><p id="p-0197" num="0196"><figref idref="DRAWINGS">FIGS. <b>5</b> and <b>6</b></figref> are conceptual diagrams illustrating examples of scalable stream structures, and will be described for convenience with reference to <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0198" num="0197">As illustrated in <figref idref="DRAWINGS">FIG. <b>5</b></figref>, encoder <b>100</b> may generate a temporally/spatially scalable stream by dividing each of a plurality of pictures into any of a plurality of layers and encoding the picture in the layer. For example, encoder <b>100</b> encodes the picture for each layer, thereby achieving scalability where an enhancement layer is present above a base layer. Such encoding of each picture is also referred to as scalable encoding. In this way, decoder <b>200</b> is capable of switching image quality of an image which is displayed by decoding the stream. In other words, decoder <b>200</b> may determine which layer to decode based on internal factors such as the processing ability of decoder <b>200</b> and external factors such as a state of a communication bandwidth. As a result, decoder <b>200</b> is capable of decoding a content while freely switching between low resolution and high resolution. For example, the user of the stream watches a video of the stream halfway using a smartphone on the way to home, and continues watching the video at home on a device such as a TV connected to the Internet. It is to be noted that each of the smartphone and the device described above includes decoder <b>200</b> having the same or different performances. In this case, when the device decodes layers up to the higher layer in the stream, the user can watch the video at high quality at home. In this way, encoder <b>100</b> does not need to generate a plurality of streams having different image qualities of the same content, and thus the processing load can be reduced.</p><p id="p-0199" num="0198">Furthermore, the enhancement layer may include meta information based on statistical information on the image. Decoder <b>200</b> may generate a video whose image quality has been enhanced by performing super-resolution imaging on a picture in the base layer based on the metadata. Super-resolution imaging may include, for example, improvement in the SN ratio in the same resolution, an increase in resolution, etc. Metadata may include, for example, information for identifying a linear or a non-linear filter coefficient, as used in a super-resolution process, or information identifying a parameter value in a filter process, machine learning, or a least squares method used in super-resolution processing, etc.</p><p id="p-0200" num="0199">In an embodiment, a configuration may be provided in which a picture is divided into, for example, tiles in accordance with, for example, the meaning of an object in the picture. In this case, decoder <b>200</b> may decode only a partial region in a picture by selecting a tile to be decoded. In addition, an attribute of the object (person, car, ball, etc.) and a position of the object in the picture (coordinates in identical images) may be stored as metadata. In this case, decoder <b>200</b> is capable of identifying the position of a desired object based on the metadata, and determining the tile including the object. For example, as illustrated in <figref idref="DRAWINGS">FIG. <b>6</b></figref>, the metadata may be stored using a data storage structure different from image data, such as an SEI (supplemental enhancement information) message in HEVC. This metadata indicates, for example, the position, size, or color of the main object.</p><p id="p-0201" num="0200">Metadata may be stored in units of a plurality of pictures, such as a stream, a sequence, or a random access unit. In this way, decoder <b>200</b> is capable of obtaining, for example, the time at which a specific person appears in the video, and by fitting the time information with picture unit information, is capable of identifying a picture in which the object (person) is present and determining the position of the object in the picture.</p><heading id="h-0013" level="2">[Encoder]</heading><p id="p-0202" num="0201">An encoder according to an embodiment will be described. <figref idref="DRAWINGS">FIG. <b>7</b></figref> is a block diagram illustrating a functional configuration of encoder <b>100</b> according to the embodiment. Encoder <b>100</b> is a video encoder which encodes a video in units of a block.</p><p id="p-0203" num="0202">As illustrated in <figref idref="DRAWINGS">FIG. <b>7</b></figref>, encoder <b>100</b> is an apparatus which encodes an image in units of a block, and includes splitter <b>102</b>, subtractor <b>104</b>, transformer <b>106</b>, quantizer <b>108</b>, entropy encoder <b>110</b>, inverse quantizer <b>112</b>, inverse transformer <b>114</b>, adder <b>116</b>, block memory <b>118</b>, loop filter <b>120</b>, frame memory <b>122</b>, intra predictor <b>124</b>, inter predictor <b>126</b>, prediction controller <b>128</b>, and prediction parameter generator <b>130</b>. As illustrated, intra predictor <b>124</b> and inter predictor <b>126</b> are part of a prediction controller.</p><p id="p-0204" num="0203">Encoder <b>100</b> is implemented as, for example, a generic processor and memory. In this case, when a software program stored in the memory is executed by the processor, the processor functions as splitter <b>102</b>, subtractor <b>104</b>, transformer <b>106</b>, quantizer <b>108</b>, entropy encoder <b>110</b>, inverse quantizer <b>112</b>, inverse transformer <b>114</b>, adder <b>116</b>, loop filter <b>120</b>, intra predictor <b>124</b>, inter predictor <b>126</b>, and prediction controller <b>128</b>. Alternatively, encoder <b>100</b> may be implemented as one or more dedicated electronic circuits corresponding to splitter <b>102</b>, subtractor <b>104</b>, transformer <b>106</b>, quantizer <b>108</b>, entropy encoder <b>110</b>, inverse quantizer <b>112</b>, inverse transformer <b>114</b>, adder <b>116</b>, loop filter <b>120</b>, intra predictor <b>124</b>, inter predictor <b>126</b>, and prediction controller <b>128</b>.</p><heading id="h-0014" level="2">[Mounting Example of Encoder]</heading><p id="p-0205" num="0204"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a functional block diagram illustrating a mounting example of an encoder <b>100</b>. Encoder <b>100</b> includes processor a<b>1</b> and memory a<b>2</b>. For example, the plurality of constituent elements of encoder <b>100</b> illustrated in <figref idref="DRAWINGS">FIG. <b>7</b></figref> are mounted on processor a<b>1</b> and memory a<b>2</b> illustrated in <figref idref="DRAWINGS">FIG. <b>8</b></figref>.</p><p id="p-0206" num="0205">Processor a<b>1</b> is circuitry which performs information processing and is coupled to memory a<b>2</b>. For example, processor a<b>1</b> is dedicated or general electronic circuitry which encodes an image. Processor a<b>1</b> may be a processor such as a CPU. In addition, processor a<b>1</b> may be an aggregate of a plurality of electronic circuits. In addition, for example, processor a<b>1</b> may take the roles of two or more constituent elements out of the plurality of constituent elements of encoder <b>100</b> illustrated in <figref idref="DRAWINGS">FIG. <b>7</b></figref>, etc.</p><p id="p-0207" num="0206">Memory a<b>2</b> is dedicated or general memory for storing information that is used by processor a<b>1</b> to encode the image. Memory a<b>2</b> may be electronic circuitry, and may be connected to processor a<b>1</b>. In addition, memory a<b>2</b> may be included in processor a<b>1</b>. In addition, memory a<b>2</b> may be an aggregate of a plurality of electronic circuits. In addition, memory a<b>2</b> may be a magnetic disc, an optical disc, or the like, or may be represented as a storage, a recording medium, or the like. In addition, memory a<b>2</b> may be non-volatile memory, or volatile memory.</p><p id="p-0208" num="0207">For example, memory a<b>2</b> may store an image to be encoded or a bitstream corresponding to an encoded image. In addition, memory a<b>2</b> may store a program for causing processor a<b>1</b> to encode an image.</p><p id="p-0209" num="0208">In addition, for example, memory a<b>2</b> may take the roles of two or more constituent elements for storing information out of the plurality of constituent elements of encoder <b>100</b> illustrated in <figref idref="DRAWINGS">FIG. <b>7</b></figref>, etc. For example, memory a<b>2</b> may take the roles of block memory <b>118</b> and frame memory <b>122</b> illustrated in <figref idref="DRAWINGS">FIG. <b>7</b></figref>. More specifically, memory a<b>2</b> may store a reconstructed block, a reconstructed picture, etc.</p><p id="p-0210" num="0209">It is to be noted that, in encoder <b>100</b>, all of the plurality of constituent elements indicated in <figref idref="DRAWINGS">FIG. <b>7</b></figref>, etc. may not be implemented, and all the processes described herein may not be performed. Part of the constituent elements indicated in <figref idref="DRAWINGS">FIG. <b>7</b></figref>, etc. may be included in another device, or part of the processes described herein may be performed by another device.</p><p id="p-0211" num="0210">Hereinafter, an overall flow of processes performed by encoder <b>100</b> is described, and then each of constituent elements included in encoder <b>100</b> will be described.</p><heading id="h-0015" level="2">[Overall Flow of Encoding Process]</heading><p id="p-0212" num="0211"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a flow chart indicating one example of an overall encoding process performed by encoder <b>100</b>, and for convenience will be described with reference to <figref idref="DRAWINGS">FIG. <b>7</b></figref>.</p><p id="p-0213" num="0212">First, splitter <b>102</b> of encoder <b>100</b> splits each of the pictures included in an input image into a plurality of blocks having a fixed size (e.g., 128&#xd7;128 pixels) (Step Sa_<b>1</b>). Splitter <b>102</b> then selects a splitting pattern for the fixed-size block (also referred to as a block shape) (Step Sa_<b>2</b>). In other words, splitter <b>102</b> further splits the fixed-size block into a plurality of blocks which form the selected splitting pattern. Encoder <b>100</b> performs, for each of the plurality of blocks, Steps Sa_<b>3</b> to Sa_<b>9</b> for the block (that is a current block to be encoded).</p><p id="p-0214" num="0213">Prediction controller <b>128</b> and prediction executor (which includes intra predictor <b>124</b> and inter predictor <b>126</b>) generate a prediction image of a current block (Step Sa-<b>3</b>). The prediction image may also be referred to as a prediction signal, a prediction block, or prediction samples.</p><p id="p-0215" num="0214">Next, subtractor <b>104</b> generates a difference between the current block and a prediction image as a prediction residual (Step Sa_<b>4</b>). The prediction residual may also be referred to as a prediction error.</p><p id="p-0216" num="0215">Next, transformer <b>106</b> transforms the prediction image and quantizer <b>108</b> quantizes the result, to generate a plurality of quantized coefficients (Step Sa_<b>5</b>). The plurality of quantized coefficients may sometimes be referred to as a coefficient block.</p><p id="p-0217" num="0216">Next, entropy encoder <b>110</b> encodes (specifically, entropy encodes) the plurality of quantized coefficients and a prediction parameter related to generation of a prediction image, to generate a stream (Step Sa_<b>6</b>). The stream may sometimes be referred to as an encoded bitstream or a compressed bitstream.</p><p id="p-0218" num="0217">Next, inverse quantizer <b>112</b> performs inverse quantization of the plurality of quantized coefficients and inverse transformer <b>114</b> performs inverse transformation of the result, to restore a prediction residual (Step Sa_<b>7</b>).</p><p id="p-0219" num="0218">Next, adder <b>116</b> adds the prediction image to the restored prediction residual to reconstruct the current block (Step Sa_<b>8</b>). In this way, the reconstructed image is generated. The reconstructed image may also be referred to as a reconstructed block or a decoded image block.</p><p id="p-0220" num="0219">When the reconstructed image is generated, loop filter <b>120</b> performs filtering of the reconstructed image as necessary (Step Sa_<b>9</b>).</p><p id="p-0221" num="0220">Encoder <b>100</b> then determines whether encoding of the entire picture has been finished (Step Sa_<b>10</b>). When determining that the encoding has not yet been finished (No in Step Sa_<b>10</b>), execution of processes from Step Sa_<b>2</b> are repeated for the next block of the picture.</p><p id="p-0222" num="0221">Although encoder <b>100</b> selects one splitting pattern for a fixed-size block, and encodes each block according to the splitting pattern in the above-described example, it is to be noted that each block may be encoded according to a corresponding one of a plurality of splitting patterns. In this case, encoder <b>100</b> may evaluate a cost for each of the plurality of splitting patterns, and, for example, may select the stream obtainable by encoding according to the splitting pattern which yields the smallest cost as a stream which is output.</p><p id="p-0223" num="0222">As illustrated, the processes in Steps Sa_<b>1</b> to Sa_<b>10</b> are performed sequentially by encoder <b>100</b>. Alternatively, two or more of the processes may be performed in parallel, the processes may be reordered, etc.</p><p id="p-0224" num="0223">The encoding process employed by encoder <b>100</b> is a hybrid encoding using prediction encoding and transform encoding. In addition, prediction encoding is performed by an encoding loop configured with subtractor <b>104</b>, transformer <b>106</b>, quantizer <b>108</b>, inverse quantizer <b>112</b>, inverse transformer <b>114</b>, adder <b>116</b>, loop filter <b>120</b>, block memory <b>118</b>, frame memory <b>122</b>, intra predictor <b>124</b>, inter predictor <b>126</b>, and prediction controller <b>128</b>. In other words, the prediction executor configured with intra predictor <b>124</b> and inter predictor <b>126</b> is part of the encoding loop.</p><heading id="h-0016" level="2">[Splitter]</heading><p id="p-0225" num="0224">Splitter <b>102</b> splits each picture included in the original image into a plurality of blocks, and outputs each block to subtractor <b>104</b>. For example, splitter <b>102</b> first splits a picture into blocks of a fixed size (for example, 128&#xd7;128 pixels). Other fixed block sizes may be employed. The fixed-size block is also referred to as a coding tree unit (CTU). Splitter <b>102</b> then splits each fixed-size block into blocks of variable sizes (for example, 64&#xd7;64 pixels or smaller), based on recursive quadtree and/or binary tree block splitting. In other words, splitter <b>102</b> selects a splitting pattern. The variable-size block also may be referred to as a coding unit (CU), a prediction unit (PU), or a transform unit (TU). It is to be noted that, in various kinds of processing examples, there is no need to differentiate between CU, PU, and TU; all or some of the blocks in a picture may be processed in units of a CU, a PU, or a TU.</p><p id="p-0226" num="0225"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a conceptual diagram for illustrating one example of block splitting according to an embodiment. In <figref idref="DRAWINGS">FIG. <b>10</b></figref>, the solid lines represent block boundaries of blocks split by quadtree block splitting, and the dashed lines represent block boundaries of blocks split by binary tree block splitting.</p><p id="p-0227" num="0226">Here, block <b>10</b> is a square block having 128&#xd7;128 pixels (128&#xd7;128 block). This 128&#xd7;128 block <b>10</b> is first split into four square 64&#xd7;64 pixel blocks (quadtree block splitting).</p><p id="p-0228" num="0227">The upper-left 64&#xd7;64 pixel block is further vertically split into two rectangular 32&#xd7;64 pixel blocks, and the left 32&#xd7;64 pixel block is further vertically split into two rectangular 16&#xd7;64 pixel blocks (binary tree block splitting). As a result, the upper-left 64&#xd7;64 pixel block is split into two 16&#xd7;64 pixel blocks <b>11</b> and <b>12</b> and one 32&#xd7;64 pixel block <b>13</b>.</p><p id="p-0229" num="0228">The upper-right 64&#xd7;64 pixel block is horizontally split into two rectangular 64&#xd7;32 pixel blocks <b>14</b> and <b>15</b> (binary tree block splitting).</p><p id="p-0230" num="0229">The lower-left square 64&#xd7;64 pixel block is first split into four square 32&#xd7;32 pixel blocks (quadtree block splitting). The upper-left block and the lower-right block among the four square 32&#xd7;32 pixel blocks are further split. The upper-left square 32&#xd7;32 pixel block is vertically split into two rectangle 16&#xd7;32 pixel blocks, and the right 16&#xd7;32 pixel block is further horizontally split into two 16&#xd7;16 pixel blocks (binary tree block splitting). The lower-right 32&#xd7;32 pixel block is horizontally split into two 32&#xd7;16 pixel blocks (binary tree block splitting). The upper-right square 32&#xd7;32 pixel block is horizontally split into two rectangle 32&#xd7;16 pixel blocks (binary tree block splitting). As a result, the lower-left square 64&#xd7;64 pixel block is split into rectangle 16&#xd7;32 pixel block <b>16</b>, two square 16&#xd7;16 pixel blocks <b>17</b> and <b>18</b>, two square 32&#xd7;32 pixel blocks <b>19</b> and <b>20</b>, and two rectangle 32&#xd7;16 pixel blocks <b>21</b> and <b>22</b>.</p><p id="p-0231" num="0230">The lower-right 64&#xd7;64 pixel block <b>23</b> is not split.</p><p id="p-0232" num="0231">As described above, in <figref idref="DRAWINGS">FIG. <b>10</b></figref>, block <b>10</b> is split into thirteen variable-size blocks <b>11</b> through <b>23</b> based on recursive quadtree and binary tree block splitting. This type of splitting is also referred to as quadtree plus binary tree (QTBT) splitting.</p><p id="p-0233" num="0232">It is to be noted that, in <figref idref="DRAWINGS">FIG. <b>10</b></figref>, one block is split into four or two blocks (quadtree or binary tree block splitting), but splitting is not limited to these examples. For example, one block may be split into three blocks (ternary block splitting). Splitting including such ternary block splitting is also referred to as multi-type tree (MBT) splitting.</p><p id="p-0234" num="0233"><figref idref="DRAWINGS">FIG. <b>11</b></figref> is a block diagram illustrating one example of a functional configuration of splitter <b>102</b> according to one embodiment. As illustrated in <figref idref="DRAWINGS">FIG. <b>11</b></figref>, splitter <b>102</b> may include block splitting determiner <b>102</b><i>a</i>. Block splitting determiner <b>102</b><i>a </i>may perform the following processes as examples.</p><p id="p-0235" num="0234">For example, block splitting determiner <b>102</b><i>a </i>may obtain or retrieve block information from block memory <b>118</b> and/or frame memory <b>122</b>, and determine a splitting pattern (e.g., the above-described splitting pattern) based on the block information. Splitter <b>102</b> splits the original image according to the splitting pattern, and outputs at least one block obtained by the splitting to subtractor <b>104</b>.</p><p id="p-0236" num="0235">In addition, for example, block splitting determiner <b>102</b><i>a </i>outputs one or more parameters indicating the determined splitting pattern (e.g., the above-described splitting pattern) to transformer <b>106</b>, inverse transformer <b>114</b>, intra predictor <b>124</b>, inter predictor <b>126</b>, and entropy encoder <b>110</b>. Transformer <b>106</b> may transform a prediction residual based on the one or more parameters. Intra predictor <b>124</b> and inter predictor <b>126</b> may generate a prediction image based on the one or more parameters. In addition, entropy encoder <b>110</b> may entropy encode the one or more parameters.</p><p id="p-0237" num="0236">The parameter related to the splitting pattern may be written in a stream as indicated below as one example.</p><p id="p-0238" num="0237"><figref idref="DRAWINGS">FIG. <b>12</b></figref> is a conceptual diagram for illustrating examples of splitting patterns. Examples of splitting patterns include: splitting into four regions (QT) in which a block is split into two regions both horizontally and vertically; splitting into three regions (HT or VT) in which a block is split in the same direction in a ratio of 1:2:1; splitting into two regions (HB or VB) in which a block is split in the same direction in a ratio of 1:1; and no splitting (NS).</p><p id="p-0239" num="0238">It is to be noted that the splitting pattern does not have a block splitting direction in the case of splitting into four regions and no splitting, and that the splitting pattern has splitting direction information in the case of splitting into two regions or three regions.</p><p id="p-0240" num="0239"><figref idref="DRAWINGS">FIG. <b>13</b>A</figref> is a conceptual diagram for illustrating one example of a syntax tree of a splitting pattern.</p><p id="p-0241" num="0240"><figref idref="DRAWINGS">FIG. <b>13</b>B</figref> is a conceptual diagram for illustrating another example of a syntax tree of a splitting pattern.</p><p id="p-0242" num="0241"><figref idref="DRAWINGS">FIGS. <b>13</b>A and <b>13</b>B</figref> are conceptual diagrams for illustrating examples of a syntax tree of a splitting pattern. In the example of <figref idref="DRAWINGS">FIG. <b>13</b>A</figref>, first, information indicating whether to perform splitting (S: Split flag) is present, and information indicating whether to perform splitting into four regions (QT: QT flag) is present next. Information indicating which one of splitting into three regions and two regions is to be performed (TT: TT flag or BT: BT flag) is present next, and information indicating a division direction (Ver: Vertical flag or Hor: Horizontal flag) is then present. It is to be noted that each of at least one block obtained by splitting according to such a splitting pattern may be further split repeatedly in a similar process. In other words, as one example, whether splitting is performed, whether splitting into four regions is performed, which one of the horizontal direction and the vertical direction is the direction in which a splitting method is to be performed, which one of splitting into three regions and splitting into two regions is to be performed may be recursively determined, and the determination results may be encoded in a stream according to the encoding order disclosed by the syntax tree illustrated in <figref idref="DRAWINGS">FIG. <b>13</b>A</figref>.</p><p id="p-0243" num="0242">In addition, although information items respectively indicating S, QT, TT, and Ver are arranged in the listed order in the syntax tree illustrated in <figref idref="DRAWINGS">FIG. <b>13</b>A</figref>, information items respectively indicating S, QT, Ver, and BT may be arranged in the listed order. In other words, in the example of <figref idref="DRAWINGS">FIG. <b>13</b>B</figref>, first, information indicating whether to perform splitting (S: Split flag) is present, and information indicating whether to perform splitting into four regions (QT: QT flag) is present next. Information indicating the splitting direction (Ver: Vertical flag or Hor: Horizontal flag) is present next, and information indicating which one of splitting into two regions and splitting into three regions is to be performed (BT: BT flag or TT: TT flag) is then present.</p><p id="p-0244" num="0243">It is to be noted that the splitting patterns described above are examples, and splitting patterns other than the described splitting patterns may be used, or part of the described splitting patterns may be used.</p><heading id="h-0017" level="2">[Subtractor]</heading><p id="p-0245" num="0244">Subtractor <b>104</b> subtracts a prediction image (prediction sample that is input from prediction controller <b>128</b> indicated below) from an original image in units of a block input from splitter <b>102</b> and split by splitter <b>102</b>. In other words, subtractor <b>104</b> calculates prediction residuals (also referred to as errors) of a current block. Subtractor <b>104</b> then outputs the calculated prediction residuals to transformer <b>106</b>.</p><p id="p-0246" num="0245">The original image may be an image which has been input into encoder <b>100</b> as a signal representing an image of each picture included in a video (for example, a luma signal and two chroma signals). A signal representing an image also may be referred to as a sample.</p><heading id="h-0018" level="2">[Transformer]</heading><p id="p-0247" num="0246">Transformer <b>106</b> transforms prediction residuals in a spatial domain into transform coefficients in a frequency domain, and outputs the transform coefficients to quantizer <b>108</b>. More specifically, transformer <b>106</b> applies, for example, a defined discrete cosine transform (DCT) or discrete sine transform (DST) to prediction residuals in a spatial domain. The defined DCT or DST may be predefined.</p><p id="p-0248" num="0247">It is to be noted that transformer <b>106</b> may adaptively select a transform type from among a plurality of transform types, and transform prediction residuals into transform coefficients by using a transform basis function corresponding to the selected transform type. This sort of transform is also referred to as explicit multiple core transform (EMT) or adaptive multiple transform (AMT). A transform basis function may also be referred to as a basis.</p><p id="p-0249" num="0248">The transform types include, for example, DCT-II, DCT-V, DCT-VIII, DST-I, and DST-VII. It is noted that these transform types may be represented as DCT<b>2</b>, DCT<b>5</b>, DCT<b>8</b>, DST<b>1</b> and DST<b>7</b>. <figref idref="DRAWINGS">FIG. <b>14</b></figref> is a chart indicating example transform basis functions for the example transform types. In <figref idref="DRAWINGS">FIG. <b>14</b></figref>, N indicates the number of input pixels. For example, selection of a transform type from among the plurality of transform types may depend on a prediction type (one of intra prediction and inter prediction), and may depend on an intra prediction mode.</p><p id="p-0250" num="0249">Information indicating whether to apply such EMT or AMT (referred to as, for example, an EMT flag or an AMT flag) and information indicating the selected transform type is normally signaled at the CU level. It is to be noted that the signaling of such information does not necessarily need to be performed at the CU level, and may be performed at another level (for example, at the sequence level, picture level, slice level, tile level, or CTU level).</p><p id="p-0251" num="0250">In addition, transformer <b>106</b> may re-transform the transform coefficients (which are transform results). Such re-transform is also referred to as adaptive secondary transform (AST) or non-separable secondary transform (NSST). For example, transformer <b>106</b> performs re-transform in units of a sub-block (for example, 4&#xd7;4 pixel sub-block) included in a transform coefficient block corresponding to an intra prediction residual. Information indicating whether to apply NSST and information related to a transform matrix for use in NSST are normally signaled at the CU level. It is to be noted that the signaling of such information does not necessarily need to be performed at the CU level, and may be performed at another level (for example, at the sequence level, picture level, slice level, tile level, or CTU level).</p><p id="p-0252" num="0251">Transformer <b>106</b> may employ a separable transform and a non-separable transform. A separable transform is a method in which a transform is performed a plurality of times by separately performing a transform for each of a number of directions according to the number of dimensions of inputs. A non-separable transform is a method of performing a collective transform in which two or more dimensions in multidimensional inputs are collectively regarded as a single dimension.</p><p id="p-0253" num="0252">In one example of a non-separable transform, when an input is a 4&#xd7;4 pixel block, the 4&#xd7;4 pixel block is regarded as a single array including sixteen elements, and the transform applies a 16&#xd7;16 transform matrix to the array.</p><p id="p-0254" num="0253">In another example of a non-separable transform, an input block of 4&#xd7;4 pixels is regarded as a single array including sixteen elements, and then a transform (hypercube givens transform) in which givens revolution is performed on the array a plurality of times may be performed.</p><p id="p-0255" num="0254">In the transform in transformer <b>106</b>, the transform types of transform bases functions to be transformed into the frequency domain according to regions in a CU can be switched. Examples include a spatially varying transform (SVT).</p><p id="p-0256" num="0255"><figref idref="DRAWINGS">FIG. <b>15</b></figref> is a conceptual diagram for illustrating one example of an SVT.</p><p id="p-0257" num="0256">In SVT, as illustrated in <figref idref="DRAWINGS">FIG. <b>15</b></figref>, CUs are split into two equal regions horizontally or vertically, and only one of the regions is transformed into the frequency domain. A transform basis type can be set for each region. For example, DST<b>7</b> and DST<b>8</b> are used. For example, among the two regions obtained by splitting a CU vertically into two equal regions, DST<b>7</b> and DCT<b>8</b> may be used for the region at position 0. Alternatively, among the two regions, DST<b>7</b> is used for the region at position 1. Likewise, among the two regions obtained by splitting a CU horizontally into two equal regions, DST<b>7</b> and DCT<b>8</b> are used for the region at position 0. Alternatively, among the two regions, DST<b>7</b> is used for the region at position 1. Although only one of the two regions in a CU is transformed and the other is not transformed in the example illustrated in <figref idref="DRAWINGS">FIG. <b>15</b></figref>, each of the two regions may be transformed. In addition, a splitting method may include not only splitting into two regions but also splitting into four regions. In addition, the splitting method can be more flexible. For example, information indicating the splitting method may be encoded and may be signaled in the same manner as the CU splitting. It is to be noted that SVT also may be referred to as sub-block transform (SBT).</p><p id="p-0258" num="0257">The AMT and EMT described above may be referred to as MTS (multiple transform selection). When MTS is applied, a transform type that is DST<b>7</b>, DCT<b>8</b>, or the like can be selected, and the information indicating the selected transform type may be encoded as index information for each CU. There is another process referred to as IMTS (implicit MTS) as a process for selecting a transform type to be used for orthogonal transform performed without encoding index information. When IMTS is applied, for example, when a CU has a rectangle shape, orthogonal transform of the rectangle shape may be performed using DST<b>7</b> for the short side and DST<b>2</b> for the long side. In addition, for example, when a CU has a square shape, orthogonal transform of the rectangle shape may be performed using DCT<b>2</b> when MTS is effective in a sequence and using DST<b>7</b> when MTS is ineffective in the sequence. DCT<b>2</b> and DST<b>7</b> are mere examples. Other transform types may be used, and it is also possible to change the combination of transform types for use to a different combination of transform types. IMTS may be used only for intra prediction blocks, or may be used for both intra prediction blocks and inter prediction block.</p><p id="p-0259" num="0258">The three processes of MTS, SBT, and IMTS have been described above as selection processes for selectively switching transform types for use in orthogonal transform. However, all of the three selection processes may be employed, or only part of the selection processes may be selectively employed. Whether one or more of the selection processes is employed may be identified, for example, based on flag information or the like in a header such as an SPS. For example, when all of the three selection processes are available for use, one of the three selection processes is selected for each CU and orthogonal transform of the CU is performed. It is to be noted that the selection processes for selectively switching the transform types may be selection processes different from the above three selection processes, or each of the three selection processes may be replaced by another process. Typically, at least one of the following four transfer functions [1] to [4] is performed. Function [1] is a function for performing orthogonal transform of the entire CU and encoding information indicating the transform type used in the transform. Function [2] is a function for performing orthogonal transform of the entire CU and determining the transform type based on a determined rule without encoding information indicating the transform type. Function [3] is a function for performing orthogonal transform of a partial region of a CU and encoding information indicating the transform type used in the transform. Function [4] is a function for performing orthogonal transform of a partial region of a CU and determining the transform type based on a determined rule without encoding information indicating the transform type used in the transform. The determined rules may be predetermined.</p><p id="p-0260" num="0259">It is to be noted that whether MTS, IMTS, and/or SBT is applied may be determined for each processing unit. For example, whether MTS, IMTS, and/or SBT is applied may be determined for each sequence, picture, brick, slice, CTU, or CU.</p><p id="p-0261" num="0260">It is to be noted that a tool for selectively switching transform types in the present disclosure may be described as a method for selectively selecting a basis for use in a transform process, a selection process, or a process for selecting a basis. In addition, the tool for selectively switching transform types may be described as a mode for adaptively selecting transform types.</p><p id="p-0262" num="0261"><figref idref="DRAWINGS">FIG. <b>16</b></figref> is a flow chart illustrating one example of a process performed by transformer <b>106</b>, and will be described for convenience with reference to <figref idref="DRAWINGS">FIG. <b>7</b></figref>.</p><p id="p-0263" num="0262">For example, transformer <b>106</b> determines whether to perform orthogonal transform (Step St_<b>1</b>). Here, when determining to perform orthogonal transform (Yes in Step St_<b>1</b>), transformer <b>106</b> selects a transform type for use in orthogonal transform from a plurality of transform types (Step St_<b>2</b>). Next, transformer <b>106</b> performs orthogonal transform by applying the selected transform type to the prediction residual of a current block (Step St_<b>3</b>). Transformer <b>106</b> then outputs information indicating the selected transform type to entropy encoder <b>110</b>, so as to allow entropy encoder <b>110</b> to encode the information (Step St_<b>4</b>). On the other hand, when determining not to perform orthogonal transform (No in Step St_<b>1</b>), transformer <b>106</b> outputs information indicating that no orthogonal transform is performed, so as to allow entropy encoder <b>110</b> to encode the information (Step St_<b>5</b>). It is to be noted that whether to perform orthogonal transform in Step St_<b>1</b> may be determined based on, for example, the size of a transform block, a prediction mode applied to the CU, etc. Alternatively, orthogonal transform may be performed using a defined transform type without encoding information indicating the transform type for use in orthogonal transform. The defined transform type may be predefined.</p><p id="p-0264" num="0263"><figref idref="DRAWINGS">FIG. <b>17</b></figref> is a flow chart illustrating one example of a process performed by transformer <b>106</b>, and will be described for convenience with reference to <figref idref="DRAWINGS">FIG. <b>7</b></figref>. It is to be noted that the example illustrated in <figref idref="DRAWINGS">FIG. <b>17</b></figref> is an example of orthogonal transform in the case where transform types for use in orthogonal transform are selectively switched as in the case of the example illustrated in <figref idref="DRAWINGS">FIG. <b>16</b></figref>.</p><p id="p-0265" num="0264">As one example, a first transform type group may include DCT<b>2</b>, DST<b>7</b>, and DCT<b>8</b>. As another example, a second transform type group may include DCT<b>2</b>. The transform types included in the first transform type group and the transform types included in the second transform type group may partly overlap with each other, or may be totally different from each other.</p><p id="p-0266" num="0265">Transformer <b>106</b> determines whether a transform size is smaller than or equal to a determined value (Step Su_<b>1</b>). Here, when determining that the transform size is smaller than or equal to the determined value (Yes in Step Su_<b>1</b>), transformer <b>106</b> performs orthogonal transform of the prediction residual of the current block using the transform type included in the first transform type group (Step Su_<b>2</b>). Next, transformer <b>106</b> outputs information indicating the transform type to be used among at least one transform type included in the first transform type group to entropy encoder <b>110</b>, so as to allow entropy encoder <b>110</b> to encode the information (Step Su_<b>3</b>). On the other hand, when determining that the transform size is not smaller than or equal to the determined value (No in Step Su_<b>1</b>), transformer <b>106</b> performs orthogonal transform of the prediction residual of the current block using the second transform type group (Step Su_<b>4</b>). The determined value may be a threshold value, and may be a predetermined value.</p><p id="p-0267" num="0266">In Step Su_<b>3</b>, the information indicating the transform type for use in orthogonal transform may be information indicating a combination of the transform type to be applied vertically in the current block and the transform type to be applied horizontally in the current block. The first type group may include only one transform type, and the information indicating the transform type for use in orthogonal transform may not be encoded. The second transform type group may include a plurality of transform types, and information indicating the transform type for use in orthogonal transform among the one or more transform types included in the second transform type group may be encoded.</p><p id="p-0268" num="0267">Alternatively, a transform type may be indicated based on a transform size without encoding information indicating the transform type. It is to be noted that such determinations are not limited to the determination as to whether the transform size is smaller than or equal to the determined value, and other processes are also possible for determining a transform type for use in orthogonal transform based on the transform size.</p><heading id="h-0019" level="2">[Quantizer]</heading><p id="p-0269" num="0268">Quantizer <b>108</b> quantizes the transform coefficients output from transformer <b>106</b>. More specifically, quantizer <b>108</b> scans, in a determined scanning order, the transform coefficients of the current block, and quantizes the scanned transform coefficients based on quantization parameters (QP) corresponding to the transform coefficients. Quantizer <b>108</b> then outputs the quantized transform coefficients (hereinafter also referred to as quantized coefficients) of the current block to entropy encoder <b>110</b> and inverse quantizer <b>112</b>. The determined scanning order may be predetermined.</p><p id="p-0270" num="0269">A determined scanning order is an order for quantizing/inverse quantizing transform coefficients. For example, a determined scanning order may be defined as ascending order of frequency (from low to high frequency) or descending order of frequency (from high to low frequency).</p><p id="p-0271" num="0270">A quantization parameter (QP) is a parameter defining a quantization step (quantization width). For example, when the value of the quantization parameter increases, the quantization step also increases. In other words, when the value of the quantization parameter increases, the error in quantized coefficients (quantization error) increases.</p><p id="p-0272" num="0271">In addition, a quantization matrix may be used for quantization. For example, several kinds of quantization matrices may be used correspondingly to frequency transform sizes such as 4&#xd7;4 and 8&#xd7;8, prediction modes such as intra prediction and inter prediction, and pixel components such as luma and chroma pixel components. It is to be noted that quantization means digitalizing values sampled at determined intervals correspondingly to determined levels. In this technical field, quantization may be referred to using other expressions, such as rounding and scaling, and may employ rounding and scaling. The determined intervals and determined levels may be predetermined.</p><p id="p-0273" num="0272">Methods using quantization matrices may include a method using a quantization matrix which has been set directly at the encoder <b>100</b> side, and a method using a quantization matrix which has been set as a default (default matrix). At the encoder <b>100</b> side, a quantization matrix suitable for features of an image can be set by directly setting a quantization matrix. This case, however, may have a disadvantage of increasing a coding amount for encoding the quantization matrix. It is to be noted that a quantization matrix to be used to quantize the current block may be generated based on a default quantization matrix or an encoded quantization matrix, instead of directly using the default quantization matrix or the encoded quantization matrix.</p><p id="p-0274" num="0273">There is a method for quantizing a high-frequency coefficient and a low-frequency coefficient without using a quantization matrix. It is to be noted that this method may be viewed as equivalent to a method using a quantization matrix (flat matrix) whose coefficients have the same value.</p><p id="p-0275" num="0274">The quantization matrix may be encoded, for example, at the sequence level, picture level, slice level, brick level, or CTU level. The quantization matrix may be specified using, for example, a sequence parameter set (SPS) or a picture parameter set (PPS). The SPS includes a parameter which is used for a sequence, and the PPS includes a parameter which is used for a picture. Each of the SPS and the PPS may be simply referred to as a parameter set.</p><p id="p-0276" num="0275">When using a quantization matrix, quantizer <b>108</b> scales, for each transform coefficient, for example a quantization width which can be calculated based on a quantization parameter, etc., using the value of the quantization matrix. The quantization process performed without using a quantization matrix may be a process for quantizing transform coefficients based on the quantization width calculated based on the quantization parameter, etc. It is to be noted that, in the quantization process performed without using any quantization matrix, the quantization width may be multiplied by a determined value which is common for all the transform coefficients in a block. The determined value may be predetermined.</p><p id="p-0277" num="0276"><figref idref="DRAWINGS">FIG. <b>18</b></figref> is a block diagram illustrating one example of a functional configuration of a quantizer according to an embodiment. For example, quantizer <b>108</b> includes difference quantization parameter generator <b>108</b><i>a</i>, predicted quantization parameter generator <b>108</b><i>b</i>, quantization parameter generator <b>108</b><i>c</i>, quantization parameter storage <b>108</b><i>d</i>, and quantization executor <b>108</b><i>e. </i></p><p id="p-0278" num="0277"><figref idref="DRAWINGS">FIG. <b>19</b></figref> is a flow chart illustrating one example of a quantization process performed by quantizer <b>108</b>, and will be described for convenience with reference to <figref idref="DRAWINGS">FIGS. <b>7</b> and <b>18</b></figref>.</p><p id="p-0279" num="0278">As one example, quantizer <b>108</b> may perform quantization for each CU based on the flow chart illustrated in <figref idref="DRAWINGS">FIG. <b>19</b></figref>. More specifically, quantization parameter generator <b>108</b><i>c </i>determines whether to perform quantization (Step Sv_<b>1</b>). Here, when determining to perform quantization (Yes in Step Sv_<b>1</b>), quantization parameter generator <b>108</b><i>c </i>generates a quantization parameter for a current block (Step Sv_<b>2</b>), and stores the quantization parameter to quantization parameter storage <b>108</b><i>d </i>(Step Sv_<b>3</b>).</p><p id="p-0280" num="0279">Next, quantization executor <b>108</b><i>e </i>quantizes transform coefficients of the current block using the quantization parameter generated in Step Sv_<b>2</b> (Step Sv_<b>4</b>). Predicted quantization parameter generator <b>108</b><i>b </i>then obtains a quantization parameter for a processing unit different from the current block from quantization parameter storage <b>108</b><i>d </i>(Step Sv_<b>5</b>). Predicted quantization parameter generator <b>108</b><i>b </i>generates a predicted quantization parameter of the current block based on the obtained quantization parameter (Step Sv_<b>6</b>). Difference quantization parameter generator <b>108</b><i>a </i>calculates the difference between the quantization parameter of the current block generated by quantization parameter generator <b>108</b><i>c </i>and the predicted quantization parameter of the current block generated by predicted quantization parameter generator <b>108</b><i>b </i>(Step Sv_<b>7</b>). The difference quantization parameter may be generated by calculating the difference. Difference quantization parameter generator <b>108</b><i>a </i>outputs the difference quantization parameter to entropy encoder <b>110</b>, so as to allow entropy encoder <b>110</b> to encode the difference quantization parameter (Step Sv_<b>8</b>).</p><p id="p-0281" num="0280">It is to be noted that the difference quantization parameter may be encoded, for example, at the sequence level, picture level, slice level, brick level, or CTU level. In addition, an initial value of the quantization parameter may be encoded at the sequence level, picture level, slice level, brick level, or CTU level. At initialization, the quantization parameter may be generated using the initial value of the quantization parameter and the difference quantization parameter.</p><p id="p-0282" num="0281">It is to be noted that quantizer <b>108</b> may include a plurality of quantizers, and may apply dependent quantization in which transform coefficients are quantized using a quantization method selected from a plurality of quantization methods.</p><heading id="h-0020" level="2">[Entropy Encoder]</heading><p id="p-0283" num="0282"><figref idref="DRAWINGS">FIG. <b>20</b></figref> is a block diagram illustrating one example of a functional configuration of entropy encoder <b>110</b> according to an embodiment, and will be described for convenience with reference to <figref idref="DRAWINGS">FIG. <b>7</b></figref>. Entropy encoder <b>110</b> generates a stream by entropy encoding the quantized coefficients input from quantizer <b>108</b> and a prediction parameter input from prediction parameter generator <b>130</b>. For example, context-based adaptive binary arithmetic coding (CABAC) is used as the entropy encoding. More specifically, entropy encoder <b>110</b> as illustrated includes binarizer <b>110</b><i>a</i>, context controller <b>110</b><i>b</i>, and binary arithmetic encoder <b>110</b><i>c</i>. Binarizer <b>110</b><i>a </i>performs binarization in which multi-level signals such as quantized coefficients and a prediction parameter are transformed into binary signals. Examples of binarization methods include truncated Rice binarization, exponential Golomb codes, and fixed length binarization. Context controller <b>110</b><i>b </i>derives a context value according to a feature or a surrounding state of a syntax element, that is an occurrence probability of a binary signal. Examples of methods for deriving a context value include bypass, referring to a syntax element, referring to an upper and left adjacent blocks, referring to hierarchical information, etc. Binary arithmetic encoder <b>110</b><i>c </i>arithmetically encodes the binary signal using the derived context.</p><p id="p-0284" num="0283"><figref idref="DRAWINGS">FIG. <b>21</b></figref> is a conceptual diagram for illustrating an example flow of a CABAC process in the entropy encoder <b>110</b>. First, initialization is performed in CABAC in entropy encoder <b>110</b>. In the initialization, initialization in binary arithmetic encoder <b>110</b><i>c </i>and setting of an initial context value are performed. For example, binarizer <b>110</b><i>a </i>and binary arithmetic encoder <b>110</b><i>c </i>may execute binarization and arithmetic encoding of the plurality of quantization coefficients in a CTU sequentially. Context controller <b>110</b><i>b </i>may update the context value each time arithmetic encoding is performed. Context controller <b>110</b><i>b </i>may then save the context value as a post process. The saved context value may be used, for example, to initialize the context value for the next CTU.</p><heading id="h-0021" level="2">[Inverse Quantizer]</heading><p id="p-0285" num="0284">Inverse quantizer <b>112</b> inverse quantizes quantized coefficients which have been input from quantizer <b>108</b>. More specifically, inverse quantizer <b>112</b> inverse quantizes, in a determined scanning order, quantized coefficients of the current block. Inverse quantizer <b>112</b> then outputs the inverse quantized transform coefficients of the current block to inverse transformer <b>114</b>. The determined scanning order may be predetermined.</p><heading id="h-0022" level="2">[Inverse Transformer]</heading><p id="p-0286" num="0285">Inverse transformer <b>114</b> restores prediction residuals by inverse transforming transform coefficients which have been input from inverse quantizer <b>112</b>. More specifically, inverse transformer <b>114</b> restores the prediction residuals of the current block by performing an inverse transform corresponding to the transform applied to the transform coefficients by the transformer <b>106</b>. Inverse transformer <b>114</b> then outputs the restored prediction residuals to adder <b>116</b>.</p><p id="p-0287" num="0286">It is to be noted that since information is normally lost in quantization, the restored prediction residuals do not match the prediction residuals calculated by subtractor <b>104</b>. In other words, the restored prediction residuals normally include quantization errors.</p><heading id="h-0023" level="2">[Adder]</heading><p id="p-0288" num="0287">Adder <b>116</b> reconstructs the current block by adding the prediction residuals which have been input from inverse transformer <b>114</b> and prediction images which have been input from prediction controller <b>128</b>. Consequently, a reconstructed image is generated. Adder <b>116</b> then outputs the reconstructed image to block memory <b>118</b> and loop filter <b>120</b>. A reconstructed block may also be referred to as a local decoded block.</p><heading id="h-0024" level="2">[Block Memory]</heading><p id="p-0289" num="0288">Block memory <b>118</b> is storage for storing blocks in a current picture, for example, for use in intra prediction. More specifically, block memory <b>118</b> stores reconstructed images output from adder <b>116</b>.</p><heading id="h-0025" level="2">[Frame Memory]</heading><p id="p-0290" num="0289">Frame memory <b>122</b> is, for example, storage for storing reference pictures for use in inter prediction, and is also referred to as a frame buffer. More specifically, frame memory <b>122</b> stores reconstructed images filtered by loop filter <b>120</b>.</p><heading id="h-0026" level="2">[Loop Filter]</heading><p id="p-0291" num="0290">Loop filter <b>120</b> applies a loop filter to a reconstructed image output by adder <b>116</b>, and outputs the filtered reconstructed image to frame memory <b>122</b>. A loop filter is a filter used in an encoding loop (in-loop filter). Examples of loop filters include, for example, an adaptive loop filter (ALF), a deblocking filter (DB or DBF), a sample adaptive offset (SAO) filter, etc.</p><p id="p-0292" num="0291"><figref idref="DRAWINGS">FIG. <b>22</b></figref> is a block diagram illustrating one example of a functional configuration of loop filter <b>120</b> according to an embodiment. For example, as illustrated in <figref idref="DRAWINGS">FIG. <b>22</b></figref>, loop filter <b>120</b> includes deblocking filter executor <b>120</b><i>a</i>, SAO executor <b>120</b><i>b</i>, and ALF executor <b>120</b><i>c</i>. Deblocking filter executor <b>120</b><i>a </i>performs a deblocking filter process on the reconstructed image. SAO executor <b>120</b><i>b </i>performs a SAO process on the reconstructed image after being subjected to the deblocking filter process. ALF executor <b>120</b><i>c </i>performs an ALF process on the reconstructed image after being subjected to the SAO process. The ALF and deblocking filter are described later in detail. The SAO process is a process for enhancing image quality by reducing ringing (a phenomenon in which pixel values are distorted like waves around an edge) and correcting deviation in pixel value. Examples of SAO processes include an edge offset process and a band offset process. It is to be noted that loop filter <b>120</b>, in some embodiments, may not include all the constituent elements disclosed in <figref idref="DRAWINGS">FIG. <b>22</b></figref>, and may include some of the constituent elements, and may include additional elements. In addition, loop filter <b>120</b> may be configured to perform the above processes in a processing order different from the one disclosed in <figref idref="DRAWINGS">FIG. <b>22</b></figref>, may not perform all of the processes, etc.</p><heading id="h-0027" level="2">[Loop Filter&#x3e;Adaptive Loop Filter]</heading><p id="p-0293" num="0292">In an ALF, a least square error filter for removing compression artifacts is applied. For example, one filter selected from among a plurality of filters based on the direction and activity of local gradients is applied for each 2&#xd7;2 pixel sub-block in the current block.</p><p id="p-0294" num="0293">More specifically, first, each sub-block (for example, each 2&#xd7;2 pixel sub-block) is categorized into one out of a plurality of classes (for example, fifteen or twenty-five classes). The classification of the sub-block may be based on, for example, gradient directionality and activity. In an example, category index C (for example, C=5D+A) is calculated or determined based on gradient directionality D (for example, 0 to 2 or 0 to 4) and gradient activity A (for example, 0 to 4). Then, based on classification index C, each sub-block is categorized into one out of a plurality of classes.</p><p id="p-0295" num="0294">For example, gradient directionality D is calculated by comparing gradients of a plurality of directions (for example, the horizontal, vertical, and two diagonal directions). Moreover, for example, gradient activity A is calculated by adding gradients of a plurality of directions and quantizing the result of addition.</p><p id="p-0296" num="0295">The filter to be used for each sub-block may be determined from among the plurality of filters based on the result of such categorization.</p><p id="p-0297" num="0296">The filter shape to be used in an ALF is, for example, a circular symmetric filter shape. <figref idref="DRAWINGS">FIG. <b>23</b>A</figref> through <figref idref="DRAWINGS">FIG. <b>23</b>C</figref> are conceptual diagrams for illustrating examples of filter shapes used in ALFs. <figref idref="DRAWINGS">FIG. <b>23</b>A</figref> illustrates a 5&#xd7;5 diamond shape filter, <figref idref="DRAWINGS">FIG. <b>23</b>B</figref> illustrates a 7&#xd7;7 diamond shape filter, and <figref idref="DRAWINGS">FIG. <b>23</b>C</figref> illustrates a 9&#xd7;9 diamond shape filter. Information indicating the filter shape is normally signaled at the picture level. It is to be noted that the signaling of such information indicating the filter shape does not necessarily need to be performed at the picture level, and may be performed at another level (for example, at the sequence level, slice level, tile level, CTU level, or CU level).</p><p id="p-0298" num="0297">The ON or OFF of the ALF may be determined, for example, at the picture level or CU level. For example, the decision of whether to apply the ALF to luma may be made at the CU level, and the decision of whether to apply ALF to chroma may be made at the picture level. Information indicating ON or OFF of the ALF is normally signaled at the picture level or CU level. It is to be noted that the signaling of information indicating ON or OFF of the ALF does not necessarily need to be performed at the picture level or CU level, and may be performed at another level (for example, at the sequence level, slice level, tile level, or CTU level).</p><p id="p-0299" num="0298">In addition, as described above, one filter is selected from the plurality of filters, and an ALF process of a sub-block is performed. A coefficient set of coefficients to be used for each of the plurality of filters (for example, up to the fifteenth or twenty-fifth filter) is normally signaled at the picture level. It is to be noted that the signaling of the coefficient set does not necessarily need to be performed at the picture level, and may be performed at another level (for example, at the sequence level, slice level, tile level, CTU level, CU level, or sub-block level).</p><heading id="h-0028" level="2">[Loop Filter&#x3e;Cross Component Adaptive Loop Filter]</heading><p id="p-0300" num="0299"><figref idref="DRAWINGS">FIG. <b>23</b>D</figref> is a conceptual diagram for illustrating an example flow of a cross component ALF (CC-ALF). <figref idref="DRAWINGS">FIG. <b>23</b>E</figref> is a conceptual diagram for illustrating an example of a filter shape used in a CC-ALF, such as the CC-ALF of <figref idref="DRAWINGS">FIG. <b>23</b>D</figref>. The example CC-ALF of <figref idref="DRAWINGS">FIGS. <b>23</b>D and <b>23</b>E</figref> operates by applying a linear, diamond shaped filter to the luma channel for each chroma component. The filter coefficients, for example, may be transmitted in the APS, scaled by a factor of 2{circumflex over (&#x2003;)}10, and rounded for fixed point representation. For example, in <figref idref="DRAWINGS">FIG. <b>23</b>D</figref>, Y samples (first component) are used for CCALF for Cb and CCALF for Cr (components different from the first component).</p><p id="p-0301" num="0300">The application of the filters may be controlled on a variable block size and signaled by a context-coded flag received for each block of samples. The block size along with an CC-ALF enabling flag may be received at the slice-level for each chroma component. CC-ALF may support various block sizes, for example (in chroma samples) 16&#xd7;16 pixels, 32&#xd7;32 pixels, 64&#xd7;64 pixels, 128&#xd7;128 pixels.</p><heading id="h-0029" level="2">[Loop Filter&#x3e;Joint Chroma Cross Component Adaptive Loop Filter]</heading><p id="p-0302" num="0301">One example of Joint Chroma-CCALF, is illustrated in <figref idref="DRAWINGS">FIGS. <b>23</b>F and <b>23</b>G</figref>. <figref idref="DRAWINGS">FIG. <b>23</b>F</figref> is a conceptual diagram for illustrating an example flow of a Joint Chroma CCALF. <figref idref="DRAWINGS">FIG. <b>23</b>G</figref> is a table illustrating example weight index candidates. As illustrated, one CCALF filter is used to generate one CCALF filtered output as the chroma refinement signal for one color component, while a weighted version of the same chroma refinement signal is applied to the other color component. In this way, the complexity of existing CCALF is reduced roughly by half. The weight value may be coded into a sign flag and a weight index. The weight index (denoted as weight_index) may be coded into 3 bits, and specifies the magnitude of the JC-CCALF weight JcCcWeight, which is a non-zero magnitude. The magnitude of JcCcWeight may, for example, be determined as follows:</p><p id="p-0303" num="0302">If weight_index is less than or equal to 4, JcCcWeight is equal to weight_index&#x3e;&#x3e;2;</p><p id="p-0304" num="0303">Otherwise, JcCcWeight is equal to 4/(weight_index&#x2212;4).</p><p id="p-0305" num="0304">The block-level on/off control of ALF filtering for Cb and Cr may be separate. This is the same as in CCALF, and two separate sets of block-level on/off control flags may be coded. Different from CCALF, herein, the Cb, Cr on/off control block sizes are the same, and thus, only one block size variable may be coded.</p><heading id="h-0030" level="2">[Loop Filter&#x3e;Deblocking Filter]</heading><p id="p-0306" num="0305">In a deblocking filter process, loop filter <b>120</b> performs a filter process on a block boundary in a reconstructed image so as to reduce distortion which occurs at the block boundary.</p><p id="p-0307" num="0306"><figref idref="DRAWINGS">FIG. <b>24</b></figref> is a block diagram illustrating one example of a specific configuration of deblocking filter executor <b>120</b><i>a </i>of a loop filter <b>120</b> (see <figref idref="DRAWINGS">FIGS. <b>7</b> and <b>22</b></figref>) which functions as a deblocking filter.</p><p id="p-0308" num="0307">Deblocking filter executor <b>120</b><i>a </i>includes: boundary determiner <b>1201</b>; filter determiner <b>1203</b>; filtering executor <b>1205</b>; process determiner <b>1208</b>; filter characteristic determiner <b>1207</b>; and switches <b>1202</b>, <b>1204</b>, and <b>1206</b>.</p><p id="p-0309" num="0308">Boundary determiner <b>1201</b> determines whether a pixel to be deblock-filtered (that is, a current pixel) is present around a block boundary. Boundary determiner <b>1201</b> then outputs the determination result to switch <b>1202</b> and processing determiner <b>1208</b>.</p><p id="p-0310" num="0309">In the case where boundary determiner <b>1201</b> has determined that a current pixel is present around a block boundary, switch <b>1202</b> outputs an unfiltered image to switch <b>1204</b>. In the opposite case where boundary determiner <b>1201</b> has determined that no current pixel is present around a block boundary, switch <b>1202</b> outputs an unfiltered image to switch <b>1206</b>. It is to be noted that the unfiltered image is an image configured with a current pixel and at least one surrounding pixel located around the current pixel.</p><p id="p-0311" num="0310">Filter determiner <b>1203</b> determines whether to perform deblocking filtering of the current pixel, based on the pixel value of at least one surrounding pixel located around the current pixel. Filter determiner <b>1203</b> then outputs the determination result to switch <b>1204</b> and process determiner <b>1208</b>.</p><p id="p-0312" num="0311">In the case where filter determiner <b>1203</b> has determined to perform deblocking filtering of the current pixel, switch <b>1204</b> outputs the unfiltered image obtained through switch <b>1202</b> to filtering executor <b>1205</b>. In the opposite case where filter determiner <b>1203</b> has determined not to perform deblocking filtering of the current pixel, switch <b>1204</b> outputs the unfiltered image obtained through switch <b>1202</b> to switch <b>1206</b>.</p><p id="p-0313" num="0312">When obtaining the unfiltered image through switches <b>1202</b> and <b>1204</b>, filtering executor <b>1205</b> executes, for the current pixel, deblocking filtering with the filter characteristic determined by filter characteristic determiner <b>1207</b>. Filtering executor <b>1205</b> then outputs the filtered pixel to switch <b>1206</b>.</p><p id="p-0314" num="0313">Under control by processing determiner <b>1208</b>, switch <b>1206</b> selectively outputs one of a pixel which has not been deblock-filtered and a pixel which has been deblock-filtered by filtering executor <b>1205</b>.</p><p id="p-0315" num="0314">Processing determiner <b>1208</b> controls switch <b>1206</b> based on the results of determinations made by boundary determiner <b>1201</b> and filter determiner <b>1203</b>. In other words, processing determiner <b>1208</b> causes switch <b>1206</b> to output the pixel which has been deblock-filtered when boundary determiner <b>1201</b> has determined that the current pixel is present around the block boundary and when filter determiner <b>1203</b> has determined to perform deblocking filtering of the current pixel. In addition, other than the above case, processing determiner <b>1208</b> causes switch <b>1206</b> to output the pixel which has not been deblock-filtered. A filtered image is output from switch <b>1206</b> by repeating output of a pixel in this way. It is to be noted that the configuration illustrated in <figref idref="DRAWINGS">FIG. <b>24</b></figref> is one example of a configuration in deblocking filter executor <b>120</b><i>a</i>. Deblocking filter executor <b>120</b><i>a </i>may have various configurations.</p><p id="p-0316" num="0315"><figref idref="DRAWINGS">FIG. <b>25</b></figref> is a conceptual diagram for illustrating an example of a deblocking filter having a symmetrical filtering characteristic with respect to a block boundary.</p><p id="p-0317" num="0316">In a deblocking filter process, one of two deblocking filters having different characteristics, that is, a strong filter and a weak filter, may be selected using pixel values and quantization parameters. In the case of the strong filter, when pixels p<b>0</b> to p<b>2</b> and pixels q<b>0</b> to q<b>2</b> are present across a block boundary as illustrated in <figref idref="DRAWINGS">FIG. <b>25</b></figref>, the pixel values of the respective pixel q<b>0</b> to q<b>2</b> are changed to pixel values q&#x2032;<b>0</b> to q&#x2032;<b>2</b> by performing, for example, computations according to the expressions below.</p><p id="p-0318" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>q&#x2032;</i>0=(<i>p</i>1+2&#xd7;<i>p</i>0+2&#xd7;<i>q</i>0+2&#xd7;<i>q</i>1+<i>q</i>2+4)/8<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0319" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>q&#x2032;</i>1=(<i>p</i>0+<i>q</i>0+<i>q</i>1+<i>q</i>2+2)/4<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0320" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>q&#x2032;</i>2=(<i>p</i>0+<i>q</i>0+<i>q</i>1+3&#xd7;<i>q</i>2+2&#xd7;<i>q</i>3+4)/8<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0321" num="0317">It is to be noted that, in the above expressions, p<b>0</b> to p<b>2</b> and q<b>0</b> to q<b>2</b> are the pixel values of respective pixels p<b>0</b> to p<b>2</b> and pixels q<b>0</b> to q<b>2</b>. In addition, q<b>3</b> is the pixel value of neighboring pixel q<b>3</b> located at the opposite side of pixel q<b>2</b> with respect to the block boundary. In addition, in the right side of each of the expressions, coefficients which are multiplied with the respective pixel values of the pixels to be used for deblocking filtering are filter coefficients.</p><p id="p-0322" num="0318">Furthermore, in the deblocking filtering, clipping may be performed so that the calculated pixel values are not changed more than a threshold value. For example, in the clipping process the pixel values calculated according to the above expressions may be clipped to a value obtained according to &#x201c;a computation pixel value &#xb1;2&#xd7; a threshold value&#x201d; using a threshold value determined based on a quantization parameter. In this way, it is possible to prevent excessive smoothing.</p><p id="p-0323" num="0319"><figref idref="DRAWINGS">FIG. <b>26</b></figref> is a conceptual diagram for illustrating a block boundary on which a deblocking filter process is performed. <figref idref="DRAWINGS">FIG. <b>27</b></figref> is a conceptual diagram for illustrating examples of Boundary strength (Bs) values.</p><p id="p-0324" num="0320">The block boundary on which the deblocking filter process is performed is, for example, a boundary between CUs, Pus, or TUs having 8&#xd7;8 pixel blocks as illustrated in <figref idref="DRAWINGS">FIG. <b>26</b></figref>. The deblocking filter process may be performed, for example, in units of four rows or four columns. First, boundary strength (Bs) values are determined as indicated in <figref idref="DRAWINGS">FIG. <b>27</b></figref> for block P and block Q illustrated in <figref idref="DRAWINGS">FIG. <b>26</b></figref>.</p><p id="p-0325" num="0321">According to the Bs values in <figref idref="DRAWINGS">FIG. <b>27</b></figref>, whether to perform deblocking filter processes of block boundaries belonging to the same image using different strengths may be determined. The deblocking filter process for a chroma signal is performed when a Bs value is 2. The deblocking filter process for a luma signal is performed when a Bs value is 1 or more and a determined condition is satisfied. The determined condition may be predetermined. It is noted that conditions for determining Bs values are not limited to those indicated in <figref idref="DRAWINGS">FIG. <b>27</b></figref>, and a Bs value may be determined based on another parameter.</p><heading id="h-0031" level="2">[Predictor (Intra Predictor, Inter Predictor, Prediction Controller)]</heading><p id="p-0326" num="0322"><figref idref="DRAWINGS">FIG. <b>28</b></figref> is a flow chart illustrating one example of a process performed by a predictor of encoder <b>100</b>. It is to be noted that the predictor includes all or part of the following constituent elements: intra predictor <b>124</b>; inter predictor <b>126</b>; and prediction controller <b>128</b>. The prediction executor includes, for example, intra predictor <b>124</b> and inter predictor <b>126</b>.</p><p id="p-0327" num="0323">The predictor generates a prediction image of a current block (Step Sb_<b>1</b>). This prediction image may also be referred to as a prediction signal or a prediction block. It is to be noted that the prediction signal is, for example, an intra prediction image (image prediction signal) or an inter prediction image (inter prediction signal). The predictor generates the prediction image of the current block using a reconstructed image which has been already obtained through another block through generation of a prediction image, generation of a prediction residual, generation of quantized coefficients, restoring of a prediction residual, and addition of the prediction image.</p><p id="p-0328" num="0324">The reconstructed image may be, for example, an image in a reference picture, or an image of an encoded block (that is, the other block described above) in a current picture which is the picture including the current block. The encoded block in the current picture is, for example, a neighboring block of the current block.</p><p id="p-0329" num="0325"><figref idref="DRAWINGS">FIG. <b>29</b></figref> is a flow chart illustrating another example of a process performed by the predictor of the encoder <b>100</b>.</p><p id="p-0330" num="0326">The predictor generates a prediction image using a first method (Step Sc_<b>1</b><i>a</i>), generates a prediction image using a second method (Step Sc_<b>1</b><i>b</i>), and generates a prediction image using a third method (Step Sc_<b>1</b><i>c</i>). The first method, the second method, and the third method may be mutually different methods for generating a prediction image. Each of the first to third methods may be an inter prediction method, an intra prediction method, or another prediction method. The above-described reconstructed image may be used in these prediction methods.</p><p id="p-0331" num="0327">Next, the prediction processor evaluates the prediction images generated in Steps Sc_<b>1</b><i>a</i>, Sc_<b>1</b><i>b</i>, and Sc_<b>1</b><i>c </i>(Step Sc_<b>2</b>). For example, the predictor calculates costs C for the prediction images generated in Step Sc_<b>1</b><i>a</i>, Sc_<b>1</b><i>b</i>, and Sc_<b>1</b>, and evaluates the prediction images by comparing the costs C of the prediction images. It is to be noted that cost C may be calculated, for example, according to an expression of an R-D optimization model, for example, C=D+&#x3bb;&#xd7;R. In this expression, D indicates compression artifacts of a prediction image, and is represented as, for example, a sum of absolute differences between the pixel value of a current block and the pixel value of a prediction image. In addition, R indicates a bit rate of a stream. In addition, &#x3bb; indicates, for example, a multiplier according to the method of Lagrange multipliers.</p><p id="p-0332" num="0328">The predictor then selects one of the prediction images generated in Steps Sc_<b>1</b><i>a</i>, Sc_<b>1</b><i>b</i>, and Sc_<b>1</b><i>c </i>(Step Sc_<b>3</b>). In other words, the predictor selects a method or a mode for obtaining a final prediction image. For example, the predictor selects the prediction image having the smallest cost C, based on costs C calculated for the prediction images. Alternatively, the evaluation in Step Sc_<b>2</b> and the selection of the prediction image in Step Sc_<b>3</b> may be made based on a parameter which is used in an encoding process. Encoder <b>100</b> may transform information for identifying the selected prediction image, the method, or the mode into a stream. The information may be, for example, a flag or the like. In this way, decoder <b>200</b> is capable of generating a prediction image according to the method or the mode selected by encoder <b>100</b>, based on the information. It is to be noted that, in the example illustrated in <figref idref="DRAWINGS">FIG. <b>29</b></figref>, the predictor selects any of the prediction images after the prediction images are generated using the respective methods. However, the predictor may select a method or a mode based on a parameter for use in the above-described encoding process before generating prediction images, and may generate a prediction image according to the method or mode selected.</p><p id="p-0333" num="0329">For example, the first method and the second method may be intra prediction and inter prediction, respectively, and the predictor may select a final prediction image for a current block from prediction images generated according to the prediction methods.</p><p id="p-0334" num="0330"><figref idref="DRAWINGS">FIG. <b>30</b></figref> is a flow chart illustrating another example of a process performed by the predictor of encoder <b>100</b>.</p><p id="p-0335" num="0331">First, the predictor generates a prediction image using intra prediction (Step Sd_<b>1</b><i>a</i>), and generates a prediction image using inter prediction (Step Sd_<b>1</b><i>b</i>). It is to be noted that the prediction image generated by intra prediction is also referred to as an intra prediction image, and the prediction image generated by inter prediction is also referred to as an inter prediction image.</p><p id="p-0336" num="0332">Next, the predictor evaluates each of the intra prediction image and the inter prediction image (Step Sd_<b>2</b>). Cost C described above may be used in the evaluation. The predictor may then select the prediction image for which the smallest cost C has been calculated among the intra prediction image and the inter prediction image, as the final prediction image for the current block (Step Sd_<b>3</b>). In other words, the prediction method or the mode for generating the prediction image for the current block is selected.</p><p id="p-0337" num="0333">The prediction processor then selects the prediction image for which the smallest cost C has been calculated among the intra prediction image and the inter prediction image, as the final prediction image for the current block (Step Sd_<b>3</b>). In other words, the prediction method or the mode for generating the prediction image for the current block is selected.</p><heading id="h-0032" level="2">[Intra Predictor]</heading><p id="p-0338" num="0334">Intra predictor <b>124</b> generates a prediction signal (that is, intra prediction image) by performing intra prediction (also referred to as intra frame prediction) of the current block by referring to a block or blocks in the current picture and stored in block memory <b>118</b>. More specifically, intra predictor <b>124</b> generates an intra prediction image by performing intra prediction by referring to pixel values (for example, luma and/or chroma values) of a block or blocks neighboring the current block, and then outputs the intra prediction image to prediction controller <b>128</b>.</p><p id="p-0339" num="0335">For example, intra predictor <b>124</b> performs intra prediction by using one mode from among a plurality of intra prediction modes which have been defined. The intra prediction modes typically include one or more non-directional prediction modes and a plurality of directional prediction modes. The defined modes may be predefined.</p><p id="p-0340" num="0336">The one or more non-directional prediction modes include, for example, the planar prediction mode and DC prediction mode defined in the H.265/high-efficiency video coding (HEVC) standard.</p><p id="p-0341" num="0337">The plurality of directional prediction modes include, for example, the thirty-three directional prediction modes defined in the H.265/HEVC standard. It is to be noted that the plurality of directional prediction modes may further include thirty-two directional prediction modes in addition to the thirty-three directional prediction modes (for a total of sixty-five directional prediction modes). <figref idref="DRAWINGS">FIG. <b>31</b></figref> is a conceptual diagram for illustrating sixty-seven intra prediction modes in total that may be used in intra prediction (two non-directional prediction modes and sixty-five directional prediction modes). The solid arrows represent the thirty-three directions defined in the H.265/HEVC standard, and the dashed arrows represent the additional thirty-two directions (the two non-directional prediction modes are not illustrated in <figref idref="DRAWINGS">FIG. <b>31</b></figref>).</p><p id="p-0342" num="0338">In various kinds of processing examples, a luma block may be referred to in intra prediction of a chroma block. In other words, a chroma component of the current block may be predicted based on a luma component of the current block. Such intra prediction is also referred to as cross-component linear model (CCLM) prediction. The intra prediction mode for a chroma block in which such a luma block is referred to (also referred to as, for example, a CCLM mode) may be added as one of the intra prediction modes for chroma blocks.</p><p id="p-0343" num="0339">Intra predictor <b>124</b> may correct intra-predicted pixel values based on horizontal/vertical reference pixel gradients. Intra prediction accompanied by this sort of correcting is also referred to as position dependent intra prediction combination (PDPC).</p><p id="p-0344" num="0340">Information indicating whether to apply PDPC (referred to as, for example, a PDPC flag) is normally signaled at the CU level. It is to be noted that the signaling of such information does not necessarily need to be performed at the CU level, and may be performed at another level (for example, at the sequence level, picture level, slice level, tile level, or CTU level).</p><p id="p-0345" num="0341"><figref idref="DRAWINGS">FIG. <b>32</b></figref> is a flow chart illustrating one example of a process performed by intra predictor <b>124</b>.</p><p id="p-0346" num="0342">Intra predictor <b>124</b> selects one intra prediction mode from a plurality of intra prediction modes (Step Sw_<b>1</b>). Intra predictor <b>124</b> then generates a prediction image according to the selected intra prediction mode (Step Sw_<b>2</b>). Next, intra predictor <b>124</b> determines most probable modes (MPMs) (Step Sw_<b>3</b>). MPMs include, for example, six intra prediction modes. For example, two modes among the six intra prediction modes may be planar mode and DC prediction mode, and the other four modes may be directional prediction modes. Intra predictor <b>124</b> determines whether the intra prediction mode selected in Step Sw_<b>1</b> is included in the MPMs (Step Sw_<b>4</b>).</p><p id="p-0347" num="0343">Here, when determining that the intra prediction mode selected in Step Sw_<b>1</b> is included in the MPMs (Yes in Step Sw_<b>4</b>), intra predictor <b>124</b> sets an MPM flag to 1 (Step Sw_<b>5</b>), and generates information indicating the selected intra prediction mode among the MPMs (Step Sw_<b>6</b>). It is to be noted that the MPM flag set to 1 and the information indicating the intra prediction mode may be encoded as prediction parameters by entropy encoder <b>110</b>.</p><p id="p-0348" num="0344">When determining that the selected intra prediction mode is not included in the MPMs (No in Step Sw_<b>4</b>), intra predictor <b>124</b> sets the MPM flag to 0 (Step Sw_<b>7</b>). Alternatively, intra predictor <b>124</b> does not set any MPM flag. Intra predictor <b>124</b> then generates information indicating the selected intra prediction mode among at least one intra prediction mode which is not included in the MPMs (Step Sw_<b>8</b>). It is to be noted that the MPM flag set to 0 and the information indicating the intra prediction mode may be encoded as prediction parameters by entropy encoder <b>110</b>. The information indicating the intra prediction mode indicates, for example, any one of 0 to 60.</p><heading id="h-0033" level="2">[Intra Predictor]</heading><p id="p-0349" num="0345">Inter predictor <b>126</b> generates a prediction image (inter prediction image) by performing inter prediction (also referred to as inter frame prediction) of the current block by referring to a block or blocks in a reference picture, which is different from the current picture and is stored in frame memory <b>122</b>. Inter prediction is performed in units of a current block or a current sub-block (for example, a 4&#xd7;4 block) in the current block. The sub-block is included in the block and is a unit smaller than the block. The size of the sub-block may be in the form of a slice, brick, picture, etc.</p><p id="p-0350" num="0346">For example, inter predictor <b>126</b> performs motion estimation in a reference picture for a current block or a current sub-block, and finds a reference block or a reference sub-block which best matches the current block or the current sub-block. Inter predictor <b>126</b> then obtains motion information (for example, a motion vector) which compensates a motion or a change from the reference block or the reference sub-block to the current block or the sub-block. Inter predictor <b>126</b> generates an inter prediction image of the current block or the sub-block by performing motion compensation (or motion prediction) based on the motion information. Inter predictor <b>126</b> outputs the generated inter prediction image to prediction controller <b>128</b>.</p><p id="p-0351" num="0347">The motion information used in motion compensation may be signaled as inter prediction signals in various forms. For example, a motion vector may be signaled. As another example, the difference between a motion vector and a motion vector predictor may be signaled.</p><heading id="h-0034" level="2">[Reference Picture List]</heading><p id="p-0352" num="0348"><figref idref="DRAWINGS">FIG. <b>33</b></figref> is a conceptual diagram for illustrating examples of reference pictures. <figref idref="DRAWINGS">FIG. <b>34</b></figref> is a conceptual diagram for illustrating examples of reference picture lists. A reference picture list is a list indicating at least one reference picture stored in frame memory <b>122</b>. It is to be noted that, in <figref idref="DRAWINGS">FIG. <b>33</b></figref>, each of rectangles indicates a picture, each of arrows indicates a picture reference relationship, the horizontal axis indicates time, I, P, and B in the rectangles indicate an intra prediction picture, a uni-prediction picture, and a bi-prediction picture, respectively, and numerals in the rectangles indicate a decoding order. As illustrated in <figref idref="DRAWINGS">FIG. <b>33</b></figref>, the decoding order of the pictures is an order of I<b>0</b>, P<b>1</b>, B<b>2</b>, B<b>3</b>, and B<b>4</b>, and the display order of the pictures is an order of I<b>0</b>, B<b>3</b>, B<b>2</b>, B<b>4</b>, and P<b>1</b>. As illustrated in <figref idref="DRAWINGS">FIG. <b>34</b></figref>, the reference picture list is a list representing reference picture candidates. For example, one picture (or a slice) may include at least one reference picture list. For example, one reference picture list is used when a current picture is a uni-prediction picture, and two reference picture lists are used when a current picture is a bi-prediction picture. In the examples of <figref idref="DRAWINGS">FIGS. <b>33</b> and <b>34</b></figref>, picture B<b>3</b> which is current picture Cur Pic has two reference picture lists which are the L0 list and the L1 list. When current picture Cur Pic is picture B<b>3</b>, reference picture candidates for current picture Cur Pic are I<b>0</b>, P<b>1</b>, and B<b>2</b>, and the reference picture lists (which are the L0 list and the L1 list) indicate these pictures. Inter predictor <b>126</b> or prediction controller <b>128</b> specifies which picture in each reference picture list is to be actually referred to in form of a reference picture index refidxLx. In <figref idref="DRAWINGS">FIG. <b>34</b></figref>, reference pictures P<b>1</b> and B<b>2</b> are specified by reference picture indices refIdxL0 and refIdxL1.</p><p id="p-0353" num="0349">Such a reference picture list may be generated for each unit such as a sequence, picture, slice, brick, CTU, or CU. In addition, among reference pictures indicated in reference picture lists, a reference picture index indicating a reference picture to be referred to in inter prediction may be signaled at the sequence level, picture level, slice level, brick level, CTU level, or CU level. In addition, a common reference picture list may be used in a plurality of inter prediction modes.</p><heading id="h-0035" level="2">[Basic Flow of Inter Prediction]</heading><p id="p-0354" num="0350"><figref idref="DRAWINGS">FIG. <b>35</b></figref> is a flow chart illustrating an example basic processing flow of a process of inter prediction.</p><p id="p-0355" num="0351">First, inter predictor <b>126</b> generates a prediction signal (Steps Se_<b>1</b> to Se_<b>3</b>). Next, subtractor <b>104</b> generates the difference between a current block and a prediction image as a prediction residual (Step Se_<b>4</b>).</p><p id="p-0356" num="0352">Here, in the generation of the prediction image, inter predictor <b>126</b> generates the prediction image through determination of a motion vector (MV) of the current block (Steps Se_<b>1</b> and Se_<b>2</b>) and motion compensation (Step Se_<b>3</b>). Furthermore, in determination of a MV, inter predictor <b>126</b> determines the MV through selection of a motion vector candidate (MV candidate) (Step Se_<b>1</b>) and derivation of a MV (Step Se_<b>2</b>). The selection of the MV candidate is made by, for example, inter predictor <b>126</b> generating a MV candidate list and selecting at least one MV candidate from the MV candidate list. It is to be noted that MVs derived in the past may be added to the MV candidate list. Alternatively, in derivation of a MV, inter predictor <b>126</b> may further select at least one MV candidate from the at least one MV candidate, and determine the selected at least one MV candidate as the MV for the current block. Alternatively, inter predictor <b>126</b> may determine the MV for the current block by performing estimation in a reference picture region specified by each of the selected at least one MV candidate. It is to be noted that the estimation in a reference picture region may be referred to as motion estimation.</p><p id="p-0357" num="0353">In addition, although Steps Se_<b>1</b> to Se_<b>3</b> are performed by inter predictor <b>126</b> in the above-described example, a process that is for example Step Se_<b>1</b>, Step Se_<b>2</b>, or the like may be performed by another constituent element included in encoder <b>100</b>.</p><p id="p-0358" num="0354">It is to be noted that a MV candidate list may be generated for each process in inter prediction mode, or a common MV candidate list may be used in a plurality of inter prediction modes. The processes in Steps Se_<b>3</b> and Se_<b>4</b> correspond to Steps Sa_<b>3</b> and Sa_<b>4</b> illustrated in <figref idref="DRAWINGS">FIG. <b>9</b></figref>, respectively. The process in Step Se_<b>3</b> corresponds to the process in Step Sd_<b>1</b><i>b </i>in <figref idref="DRAWINGS">FIG. <b>30</b></figref>.</p><heading id="h-0036" level="2">[Motion Vector Derivation Flow]</heading><p id="p-0359" num="0355"><figref idref="DRAWINGS">FIG. <b>36</b></figref> is a flow chart illustrating one example of a process of derivation of motion vectors.</p><p id="p-0360" num="0356">Inter predictor <b>126</b> may derive a MV of a current block in a mode for encoding motion information (for example, a MV). In this case, for example, the motion information may be encoded as a prediction parameter, and may be signaled. In other words, the encoded motion information is included in a stream.</p><p id="p-0361" num="0357">Alternatively, inter predictor <b>126</b> may derive a MV in a mode in which motion information is not encoded. In this case, no motion information is included in the stream.</p><p id="p-0362" num="0358">Here, MV derivation modes may include a normal inter mode, a normal merge mode, a FRUC mode, an affine mode, etc. which are described later. Modes in which motion information is encoded among the modes include the normal inter mode, the normal merge mode, the affine mode (specifically, an affine inter mode and an affine merge mode), etc. It is to be noted that motion information may include not only a MV but also motion vector predictor selection information which is described later. Modes in which no motion information is encoded include the FRUC mode, etc. Inter predictor <b>126</b> selects a mode for deriving a MV of the current block from the plurality of modes, and derives the MV of the current block using the selected mode.</p><p id="p-0363" num="0359"><figref idref="DRAWINGS">FIG. <b>37</b></figref> is a flow chart illustrating another example of derivation of motion vectors.</p><p id="p-0364" num="0360">Inter predictor <b>126</b> may derives a MV for a current block in a mode in which a MV difference is encoded. In this case, for example, the MV difference may be encoded as a prediction parameter, and may be signaled. In other words, the encoded MV difference is included in a stream. The MV difference is the difference between the MV of the current block and the MV predictor. It is to be noted that the MV predictor is a motion vector predictor.</p><p id="p-0365" num="0361">Alternatively, inter predictor <b>126</b> may derive a MV in a mode in which no MV difference is encoded. In this case, no encoded MV difference is included in the stream.</p><p id="p-0366" num="0362">Here, as described above, the MV derivation modes include the normal inter mode, the normal merge mode, the FRUC mode, the affine mode, etc. which are described later. Modes in which a MV difference is encoded among the modes include the normal inter mode, the affine mode (specifically, the affine inter mode), etc. Modes in which no MV difference is encoded include the FRUC mode, the normal merge mode, the affine mode (specifically, the affine merge mode), etc. Inter predictor <b>126</b> selects a mode for deriving a MV of the current block from the plurality of modes, and derives the MV of the current block using the selected mode.</p><heading id="h-0037" level="2">[Motion Vector Derivation Modes]</heading><p id="p-0367" num="0363"><figref idref="DRAWINGS">FIGS. <b>38</b>A and <b>38</b>B</figref> are conceptual diagrams for illustrating example categorization of modes for MV derivation. For example, as illustrated in <figref idref="DRAWINGS">FIG. <b>38</b>A</figref>, MV derivation modes are roughly categorized into three modes according to whether to encode motion information and whether to encode MV differences. The three modes are inter mode, merge mode, and frame rate up-conversion (FRUC) mode. The inter mode is a mode in which motion estimation is performed, and in which motion information and a MV difference are encoded. For example, as illustrated in <figref idref="DRAWINGS">FIG. <b>38</b>B</figref>, the inter mode includes affine inter mode and normal inter mode. The merge mode is a mode in which no motion estimation is performed, and in which a MV is selected from an encoded surrounding block and a MV for the current block is derived using the MV. The merge mode is a mode in which, basically, motion information is encoded and no MV difference is encoded. For example, as illustrated in <figref idref="DRAWINGS">FIG. <b>38</b>B</figref>, the merge modes include normal merge mode (also referred to as normal merge mode or regular merge mode), merge with motion vector difference (MMVD) mode, combined inter merge/intra prediction (CIIP) mode, triangle mode, ATMVP mode, and affine merge mode. Here, a MV difference is encoded exceptionally in the MMVD mode among the modes included in the merge modes. It is to be noted that the affine merge mode and the affine inter mode are modes included in the affine modes. The affine mode is a mode for deriving, as a MV of a current block, a MV of each of a plurality of sub-blocks included in the current block, assuming affine transform. The FRUC mode is a mode which is for deriving a MV of the current block by performing estimation between encoded regions, and in which neither motion information nor any MV difference is encoded. It is to be noted that the respective modes will be described later in more detail.</p><p id="p-0368" num="0364">It is to be noted that the categorization of the modes illustrated in <figref idref="DRAWINGS">FIGS. <b>38</b>A and <b>38</b>B</figref> are examples, and categorization is not limited thereto. For example, when a MV difference is encoded in CIIP mode, the CIIP mode is categorized into inter modes.</p><heading id="h-0038" level="2">[MV Derivation&#x3e;Normal Inter Mode]</heading><p id="p-0369" num="0365">The normal inter mode is an inter prediction mode for deriving a MV of a current block based on a block similar to the image of the current block from a reference picture region specified by a MV candidate. In this normal inter mode, a MV difference is encoded.</p><p id="p-0370" num="0366"><figref idref="DRAWINGS">FIG. <b>39</b></figref> is a flow chart illustrating an example of a process of inter prediction in normal inter mode.</p><p id="p-0371" num="0367">First, inter predictor <b>126</b> obtains a plurality of MV candidates for a current block based on information such as MVs of a plurality of encoded blocks temporally or spatially surrounding the current block (Step Sg_<b>1</b>). In other words, inter predictor <b>126</b> generates a MV candidate list.</p><p id="p-0372" num="0368">Next, inter predictor <b>126</b> extracts N (an integer of 2 or larger) MV candidates from the plurality of MV candidates obtained in Step Sg_<b>1</b>, as motion vector predictor candidates (also referred to as MV predictor candidates) according to a determined priority order (Step Sg_<b>2</b>). It is to be noted that the priority order may be determined in advance for each of the N MV candidates.</p><p id="p-0373" num="0369">Next, inter predictor <b>126</b> selects one motion vector predictor candidate from the N motion vector predictor candidates, as the motion vector predictor (also referred to as a MV predictor) of the current block (Step Sg_<b>3</b>). At this time, inter predictor <b>126</b> encodes, in a stream, motion vector predictor selection information for identifying the selected motion vector predictor. In other words, inter predictor <b>126</b> outputs the MV predictor selection information as a prediction parameter to entropy encoder <b>110</b> through prediction parameter generator <b>130</b>.</p><p id="p-0374" num="0370">Next, inter predictor <b>126</b> derives a MV of a current block by referring to an encoded reference picture (Step Sg_<b>4</b>). At this time, inter predictor <b>126</b> further encodes, in the stream, the difference value between the derived MV and the motion vector predictor as a MV difference. In other words, inter predictor <b>126</b> outputs the MV difference as a prediction parameter to entropy encoder <b>110</b> through prediction parameter generator <b>130</b>. It is to be noted that the encoded reference picture is a picture including a plurality of blocks which have been reconstructed after being encoded.</p><p id="p-0375" num="0371">Lastly, inter predictor <b>126</b> generates a prediction image for the current block by performing motion compensation of the current block using the derived MV and the encoded reference picture (Step Sg_<b>5</b>). The processes in Steps Sg_<b>1</b> to Sg_<b>5</b> are executed on each block. For example, when the processes in Steps Sg_<b>1</b> to Sg_<b>5</b> are executed on all the blocks in the slice, inter prediction of the slice using the normal inter mode finishes. For example, when the processes in Steps Sg_<b>1</b> to Sg_<b>5</b> are executed on all the blocks in the picture, inter prediction of the picture using the normal inter mode finishes. It is to be noted that not all the blocks included in the slice the processes may be subjected to in Steps Sg_<b>1</b> to Sg_<b>5</b>, and inter prediction of the slice using the normal inter mode may finish when part of the blocks are subjected to the processes. This also applies to processes in Steps Sg_<b>1</b> to Sg_<b>5</b>. Inter prediction of the picture using the normal inter mode may finish when the processes are executed on part of the blocks in the picture.</p><p id="p-0376" num="0372">It is to be noted that the prediction image is an inter prediction signal as described above. In addition, information indicating the inter prediction mode (normal inter mode in the above example) used to generate the prediction image is, for example, encoded as a prediction parameter in an encoded signal.</p><p id="p-0377" num="0373">It is to be noted that the MV candidate list may be also used as a list for use in another mode. In addition, the processes related to the MV candidate list may be applied to processes related to the list for use in another mode. The processes related to the MV candidate list include, for example, extraction or selection of a MV candidate from the MV candidate list, reordering of MV candidates, or deletion of a MV candidate.</p><heading id="h-0039" level="2">[MV Derivation&#x3e;Normal Merge Mode]</heading><p id="p-0378" num="0374">The normal merge mode is an inter prediction mode for selecting a MV candidate from a MV candidate list as a MV of a current block, thereby deriving the MV. It is to be noted that the normal merge mode is a type of merge mode and may simply be referred to as a merge mode. In this embodiment, the normal merge mode and the merge mode are distinguished, and the merge mode is used in a broader meaning.</p><p id="p-0379" num="0375"><figref idref="DRAWINGS">FIG. <b>40</b></figref> is a flow chart illustrating an example of inter prediction in normal merge mode.</p><p id="p-0380" num="0376">First, inter predictor <b>126</b> obtains a plurality of MV candidates for a current block based on information such as MVs of a plurality of encoded blocks temporally or spatially surrounding the current block (Step Sh_<b>1</b>). In other words, inter predictor <b>126</b> generates a MV candidate list.</p><p id="p-0381" num="0377">Next, inter predictor <b>126</b> selects one MV candidate from the plurality of MV candidates obtained in Step Sh_<b>1</b>, thereby deriving a MV of the current block (Step Sh_<b>2</b>). At this time, inter predictor <b>126</b> encodes, in a stream, MV selection information for identifying the selected MV candidate. In other words, inter predictor <b>126</b> outputs the MV selection information as a prediction parameter to entropy encoder <b>110</b> through prediction parameter generator <b>130</b>.</p><p id="p-0382" num="0378">Lastly, inter predictor <b>126</b> generates a prediction image for the current block by performing motion compensation of the current block using the derived MV and the encoded reference picture (Step Sh_<b>3</b>). The processes in Steps Sh_<b>1</b> to Sh_<b>3</b> are executed, for example, on each block. For example, when the processes in Steps Sh_<b>1</b> to Sh_<b>3</b> are executed on all the blocks in the slice, inter prediction of the slice using the normal merge mode finishes. In addition, when the processes in Steps Sh_<b>1</b> to Sh_<b>3</b> are executed on all the blocks in the picture, inter prediction of the picture using the normal merge mode finishes. It is to be noted that not all the blocks included in the slice may be subjected to the processes in Steps Sh_<b>1</b> to Sh_<b>3</b>, and inter prediction of the slice using the normal merge mode may finish when part of the blocks are subjected to the processes. This also applies to processes in Steps Sh_<b>1</b> to Sh_<b>3</b>. Inter prediction of the picture using the normal merge mode may finish when the processes are executed on part of the blocks in the picture.</p><p id="p-0383" num="0379">In addition, information indicating the inter prediction mode (normal merge mode in the above example) used to generate the prediction image and included in the encoded signal is, for example, encoded as a prediction parameter in a stream.</p><p id="p-0384" num="0380"><figref idref="DRAWINGS">FIG. <b>41</b></figref> is a conceptual diagram for illustrating one example of a motion vector derivation process of a current picture by a normal merge mode.</p><p id="p-0385" num="0381">First, inter predictor <b>126</b> generates a MV candidate list in which MV candidates are registered. Examples of MV candidates include: spatially neighboring MV candidates which are MVs of a plurality of encoded blocks located spatially surrounding a current block; temporally neighboring MV candidates which are MVs of surrounding blocks on which the position of a current block in an encoded reference picture is projected; combined MV candidates which are MVs generated by combining the MV value of a spatially neighboring MV predictor and the MV value of a temporally neighboring MV predictor; and a zero MV candidate which is a MV having a zero value.</p><p id="p-0386" num="0382">Next, inter predictor <b>126</b> selects one MV candidate from a plurality of MV candidates registered in a MV candidate list, and determines the MV candidate as the MV of the current block.</p><p id="p-0387" num="0383">Furthermore, entropy encoder <b>110</b> writes and encodes, in a stream, merge_idx which is a signal indicating which MV candidate has been selected.</p><p id="p-0388" num="0384">It is to be noted that the MV candidates registered in the MV candidate list described in <figref idref="DRAWINGS">FIG. <b>41</b></figref> are examples. The number of MV candidates may be different from the number of MV candidates in the diagram, the MV candidate list may be configured in such a manner that some of the kinds of the MV candidates in the diagram may not be included, or that one or more MV candidates other than the kinds of MV candidates in the diagram are included.</p><p id="p-0389" num="0385">A final MV may be determined by performing a dynamic motion vector refreshing (DMVR) to be described later using the MV of the current block derived by normal merge mode. It is to be noted that, in normal merge mode, motion information is encoded and no MV difference is encoded. In MMVD mode, one MV candidate is selected from a MV candidate list as in the case of normal merge mode, a MV difference is encoded. As illustrated in <figref idref="DRAWINGS">FIG. <b>38</b>B</figref>, MMVD may be categorized into merge modes together with normal merge mode. It is to be noted that the MV difference in MMVD mode does not always need to be the same as the MV difference for use in inter mode. For example, MV difference derivation in MMVD mode may be a process that requires a smaller amount of processing than the amount of processing required for MV difference derivation in inter mode.</p><p id="p-0390" num="0386">In addition, a combined inter merge/intra prediction (CIIP) mode may be performed. The mode is for overlapping a prediction image generated in inter prediction and a prediction image generated in intra prediction to generate a prediction image for a current block.</p><p id="p-0391" num="0387">It is to be noted that the MV candidate list may be referred to as a candidate list. In addition, merge_idx is MV selection information.</p><heading id="h-0040" level="2">[MV Derivation&#x3e;HMVP Mode]</heading><p id="p-0392" num="0388"><figref idref="DRAWINGS">FIG. <b>42</b></figref> is a conceptual diagram for illustrating one example of a MV derivation process for a current picture using HMVP merge mode.</p><p id="p-0393" num="0389">In normal merge mode, a MV for, for example, a CU which is a current block is determined by selecting one MV candidate from a MV list generated by referring to an encoded block (for example, a CU). Here, another MV candidate may be registered in the MV candidate list. The mode in which such another MV candidate is registered is referred to as HMVP mode.</p><p id="p-0394" num="0390">In HMVP mode, MV candidates are managed using a first-in first-out (FIFO) server for HMVP, separately from the MV candidate list for normal merge mode.</p><p id="p-0395" num="0391">In a FIFO buffer, motion information such as MVs of blocks processed in the past are stored newest first. In the management of the FIFO buffer, each time when one block is processed, the MV for the newest block (that is the CU processed immediately before) is stored in the FIFO buffer, and the MV of the oldest CU (that is, the CU processed earliest) is deleted from the FIFO buffer. In the example illustrated in <figref idref="DRAWINGS">FIG. <b>42</b></figref>, HMVP<b>1</b> is the MV for the newest block, and HMVP<b>5</b> is the MV for the oldest MV.</p><p id="p-0396" num="0392">Inter predictor <b>126</b> then, for example, checks whether each MV managed in the FIFO buffer is a MV different from all the MV candidates which have been already registered in the MV candidate list for normal merge mode starting from HMVP<b>1</b>. When determining that the MV is different from all the MV candidates, inter predictor <b>126</b> may add the MV managed in the FIFO buffer in the MV candidate list for normal merge mode as a MV candidate. At this time, one or more of the MV candidates in the FIFO buffer may be registered (added to the MV candidate list).</p><p id="p-0397" num="0393">By using the HMVP mode in this way, it is possible to add not only the MV of a block which neighbors the current block spatially or temporally but also a MV for a block processed in the past. As a result, the variation of MV candidates for normal merge mode is expanded, which increases the probability that coding efficiency can be increased.</p><p id="p-0398" num="0394">It is to be noted that the MV may be motion information. In other words, information stored in the MV candidate list and the FIFO buffer may include not only MV values but also reference picture information, reference directions, the numbers of pictures, etc. In addition, the block may be, for example, a CU.</p><p id="p-0399" num="0395">It is to be noted that the MV candidate list and the FIFO buffer illustrated in <figref idref="DRAWINGS">FIG. <b>42</b></figref> are examples. The MV candidate list and FIFO buffer may be different in size from those in <figref idref="DRAWINGS">FIG. <b>42</b></figref>, or may be configured to register MV candidates in an order different from the one in <figref idref="DRAWINGS">FIG. <b>42</b></figref>. In addition, the process described here may be common between encoder <b>100</b> and decoder <b>200</b>.</p><p id="p-0400" num="0396">It is to be noted that the HMVP mode can be applied for modes other than the normal merge mode. For example, it is also possible that motion information such as MVs of blocks processed in affine mode in the past may be stored newest first, and may be used as MV candidates, which may facilitate better efficiency. The mode obtained by applying HMVP mode to affine mode may be referred to as history affine mode.</p><heading id="h-0041" level="2">[MV Derivation&#x3e;FRUC Mode]</heading><p id="p-0401" num="0397">Motion information may be derived at the decoder side without being signaled from the encoder side. For example, motion information may be derived by performing motion estimation at the decoder <b>200</b> side. In an embodiment, at the decoder side, motion estimation is performed without using any pixel value in a current block. Modes for performing motion estimation at the decoder <b>200</b> side without using any pixel value in a current block include a frame rate up-conversion (FRUC) mode, a pattern matched motion vector derivation (PMMVD) mode, etc.</p><p id="p-0402" num="0398">One example of a FRUC process in the form of a flow chart is illustrated in <figref idref="DRAWINGS">FIG. <b>43</b></figref>. First, a list which indicates, as MV candidates, MVs for encoded blocks each of which neighbors the current block spatially or temporally by referring to the MVs (the list may be a MV candidate list, and be also used as the MV candidate list for normal merge mode) (Step Si_<b>1</b>).</p><p id="p-0403" num="0399">Next, a best MV candidate is selected from the plurality of MV candidates registered in the MV candidate list (Step Si_<b>2</b>). For example, the evaluation values of the respective MV candidates included in the MV candidate list are calculated, and one MV candidate is selected based on the evaluation values. Based on the selected motion vector candidates, a motion vector for the current block is then derived (Step Si_<b>4</b>). More specifically, for example, the selected motion vector candidate (best MV candidate) is derived directly as the motion vector for the current block. In addition, for example, the motion vector for the current block may be derived using pattern matching in a surrounding region of a position in a reference picture where the position in the reference picture corresponds to the selected motion vector candidate. In other words, estimation using the pattern matching and the evaluation values may be performed in the surrounding region of the best MV candidate, and when there is a MV that yields a better evaluation value, the best MV candidate may be updated to the MV that yields the better evaluation value, and the updated MV may be determined as the final MV for the current block. In some embodiments, updating of the motion vector which yields a better evaluation value may not be performed.</p><p id="p-0404" num="0400">Lastly, inter predictor <b>126</b> generates a prediction image for the current block by performing motion compensation of the current block using the derived MV and the encoded reference picture (Step Si_<b>5</b>). The processes in Steps Si_<b>1</b> to Si_<b>5</b> are executed, for example, on each block. For example, when the processes in Steps Si_<b>1</b> to Si_<b>5</b> are executed on all the blocks in the slice, inter prediction of the slice using the FRUC mode finishes. For example, when the processes in Steps Si_<b>1</b> to Si_<b>5</b> are executed on all the blocks in the picture, inter prediction of the picture using the FRUC mode finishes. It is to be noted that not all the blocks included in the slice may be subjected to the processes in Steps Si_<b>1</b> to Si_<b>5</b>, and inter prediction of the slice using the FRUC mode may finish when part of the blocks are subjected to the processes. When the processes in Steps Si_<b>1</b> to Si_<b>5</b> are executed on part of blocks included in a picture in a similar manner, inter prediction of the picture using the FRUC mode may finish.</p><p id="p-0405" num="0401">A similar process may be performed in units of a sub-block.</p><p id="p-0406" num="0402">Evaluation values may be calculated according to various kinds of methods. For example, a comparison is made between a reconstructed image in a region in a reference picture corresponding to a motion vector, and a reconstructed image in a determined region (the region may be, for example, a region in another reference picture or a region in a neighboring block of a current picture, as indicated below). The determined region may be predetermined.</p><p id="p-0407" num="0403">The difference between the pixel values of the two reconstructed images may be used for an evaluation value of the motion vectors. It is to be noted that an evaluation value may be calculated using information other than the value of the difference.</p><p id="p-0408" num="0404">Next, an example of pattern matching is described in detail. First, one MV candidate included in a MV candidate list (for example, a merge list) is selected as a start point of estimation by the pattern matching. For example, as the pattern matching, either a first pattern matching or a second pattern matching may be used. The first pattern matching and the second pattern matching may be referred to as bilateral matching and template matching, respectively.</p><heading id="h-0042" level="2">[MV Derivation&#x3e;FRUC&#x3e;Bilateral Matching]</heading><p id="p-0409" num="0405">In the first pattern matching, pattern matching is performed between two blocks which are located along a motion trajectory of a current block and are included in two different reference pictures. Accordingly, in the first pattern matching, a region in another reference picture along the motion trajectory of the current block is used as a determined region for calculating the evaluation value of the above-described candidate. The determined region may be predetermined.</p><p id="p-0410" num="0406"><figref idref="DRAWINGS">FIG. <b>44</b></figref> is a conceptual diagram for illustrating one example of the first pattern matching (bilateral matching) between the two blocks in the two reference pictures along the motion trajectory. As illustrated in <figref idref="DRAWINGS">FIG. <b>44</b></figref>, in the first pattern matching, two motion vectors (MV<b>0</b>, MV<b>1</b>) are derived by estimating a pair which best matches among pairs in the two blocks included in the two different reference pictures (Ref<b>0</b>, Ref<b>1</b>) and located along the motion trajectory of the current block (Cur block). More specifically, a difference between the reconstructed image at a specified location in the first encoded reference picture (Ref<b>0</b>) specified by a MV candidate, and the reconstructed image at a specified location in the second encoded reference picture (Ref<b>1</b>) specified by a symmetrical MV obtained by scaling the MV candidate at a display time interval is derived for the current block, and an evaluation value is calculated using the value of the obtained difference. It is possible to select, as the final MV, the MV candidate which yields the best evaluation value among the plurality of MV candidates, and which is likely to produce good results.</p><p id="p-0411" num="0407">In the assumption of a continuous motion trajectory, the motion vectors (MV<b>0</b>, MV<b>1</b>) specifying the two reference blocks are proportional to temporal distances (TD<b>0</b>, TD<b>1</b>) between the current picture (Cur Pic) and the two reference pictures (Ref<b>0</b>, Ref<b>1</b>). For example, when the current picture is temporally located between the two reference pictures and the temporal distances from the current picture to the respective two reference pictures are equal to each other, mirror-symmetrical bi-directional motion vectors are derived in the first pattern matching.</p><heading id="h-0043" level="2">[MV Derivation&#x3e;FRUC&#x3e;Template Matching]</heading><p id="p-0412" num="0408">In the second pattern matching (template matching), pattern matching is performed between a block in a reference picture and a template in the current picture (the template is a block neighboring the current block in the current picture (the neighboring block is, for example, an upper and/or left neighboring block(s))). Accordingly, in the second pattern matching, the block neighboring the current block in the current picture is used as the determined region for calculating the evaluation value of the above-described MV candidate.</p><p id="p-0413" num="0409"><figref idref="DRAWINGS">FIG. <b>45</b></figref> is a conceptual diagram for illustrating one example of pattern matching (template matching) between a template in a current picture and a block in a reference picture. As illustrated in <figref idref="DRAWINGS">FIG. <b>45</b></figref>, in the second pattern matching, the motion vector of the current block (Cur block) is derived by estimating, in the reference picture (Ref<b>0</b>), the block which best matches the block neighboring the current block in the current picture (Cur Pic). More specifically, the difference between a reconstructed image in an encoded region which neighbors both left and above or either left or above and a reconstructed image which is in a corresponding region in the encoded reference picture (Ref<b>0</b>) and is specified by a MV candidate is derived, and an evaluation value is calculated using the value of the obtained difference. The MV candidate which yields the best evaluation value among a plurality of MV candidates may be selected as the best MV candidate.</p><p id="p-0414" num="0410">Such information indicating whether to apply the FRUC mode (referred to as, for example, a FRUC flag) may be signaled at the CU level. In addition, when the FRUC mode is applied (for example, when a FRUC flag is true), information indicating an applicable pattern matching method (e.g., the first pattern matching or the second pattern matching) may be signaled at the CU level. It is to be noted that the signaling of such information does not necessarily need to be performed at the CU level, and may be performed at another level (for example, at the sequence level, picture level, slice level, tile level, CTU level, or sub-block level).</p><heading id="h-0044" level="2">[MV Derivation&#x3e;Affine Mode]</heading><p id="p-0415" num="0411">The affine mode is a mode for generating a MV using affine transform. For example, a MV may be derived in units of a sub-block based on motion vectors of a plurality of neighboring blocks. This mode is also referred to as an affine motion compensation prediction mode.</p><p id="p-0416" num="0412"><figref idref="DRAWINGS">FIG. <b>46</b>A</figref> is a conceptual diagram for illustrating one example of MV derivation in units of a sub-block based on motion vectors of a plurality of neighboring blocks. In <figref idref="DRAWINGS">FIG. <b>46</b>A</figref>, the current block includes, for example, sixteen 4&#xd7;4 sub-blocks. Here, motion vector V<sub>0 </sub>at an upper-left corner control point in the current block is derived based on a motion vector of a neighboring block, and likewise, motion vector V<sub>1 </sub>at an upper-right corner control point in the current block is derived based on a motion vector of a neighboring sub-block. Two motion vectors v<sub>0 </sub>and v<sub>1 </sub>may be projected according to an expression (1A) indicated below, and motion vectors (v<sub>x</sub>, v<sub>y</sub>) for the respective sub-blocks in the current block may be derived.</p><p id="p-0417" num="0000"><maths id="MATH-US-00001" num="00001"><math overflow="scroll"> <mrow>  <mo>[</mo>  <mrow>   <mrow>    <mi>Math</mi>    <mo>.</mo>    <mtext>   </mtext>    <mn>1</mn>   </mrow>   <mo>&#x2062;</mo>   <mi>A</mi>  </mrow>  <mo>]</mo> </mrow></math></maths><maths id="MATH-US-00001-2" num="00001.2"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mo>{</mo>     <mtable>      <mtr>       <mtd>        <mrow>         <msub>          <mi>v</mi>          <mi>x</mi>         </msub>         <mo>=</mo>         <mrow>          <mrow>           <mfrac>            <mrow>             <mo>(</mo>             <mrow>              <msub>               <mi>v</mi>               <mrow>                <mn>1</mn>                <mo>&#x2062;</mo>                <mi>x</mi>               </mrow>              </msub>              <mo>-</mo>              <msub>               <mi>v</mi>               <mrow>                <mn>0</mn>                <mo>&#x2062;</mo>                <mi>x</mi>               </mrow>              </msub>             </mrow>             <mo>)</mo>            </mrow>            <mi>w</mi>           </mfrac>           <mo>&#x2062;</mo>           <mi>x</mi>          </mrow>          <mo>-</mo>          <mrow>           <mfrac>            <mrow>             <mo>(</mo>             <mrow>              <msub>               <mi>v</mi>               <mrow>                <mn>1</mn>                <mo>&#x2062;</mo>                <mi>y</mi>               </mrow>              </msub>              <mo>-</mo>              <msub>               <mi>v</mi>               <mrow>                <mn>0</mn>                <mo>&#x2062;</mo>                <mi>y</mi>               </mrow>              </msub>             </mrow>             <mo>)</mo>            </mrow>            <mi>w</mi>           </mfrac>           <mo>&#x2062;</mo>           <mi>y</mi>          </mrow>          <mo>+</mo>          <msub>           <mi>v</mi>           <mrow>            <mn>0</mn>            <mo>&#x2062;</mo>            <mi>x</mi>           </mrow>          </msub>         </mrow>        </mrow>       </mtd>      </mtr>      <mtr>       <mtd>        <mrow>         <msub>          <mi>v</mi>          <mi>y</mi>         </msub>         <mo>=</mo>         <mrow>          <mrow>           <mfrac>            <mrow>             <mo>(</mo>             <mrow>              <msub>               <mi>v</mi>               <mrow>                <mn>1</mn>                <mo>&#x2062;</mo>                <mi>y</mi>               </mrow>              </msub>              <mo>-</mo>              <msub>               <mi>v</mi>               <mrow>                <mn>0</mn>                <mo>&#x2062;</mo>                <mi>y</mi>               </mrow>              </msub>             </mrow>             <mo>)</mo>            </mrow>            <mi>w</mi>           </mfrac>           <mo>&#x2062;</mo>           <mi>x</mi>          </mrow>          <mo>-</mo>          <mrow>           <mfrac>            <mrow>             <mo>(</mo>             <mrow>              <msub>               <mi>v</mi>               <mrow>                <mn>1</mn>                <mo>&#x2062;</mo>                <mi>x</mi>               </mrow>              </msub>              <mo>-</mo>              <msub>               <mi>v</mi>               <mrow>                <mn>0</mn>                <mo>&#x2062;</mo>                <mi>x</mi>               </mrow>              </msub>             </mrow>             <mo>)</mo>            </mrow>            <mi>w</mi>           </mfrac>           <mo>&#x2062;</mo>           <mi>y</mi>          </mrow>          <mo>+</mo>          <msub>           <mi>v</mi>           <mrow>            <mn>0</mn>            <mo>&#x2062;</mo>            <mi>y</mi>           </mrow>          </msub>         </mrow>        </mrow>       </mtd>      </mtr>     </mtable>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mrow>      <mn>1</mn>      <mo>&#x2062;</mo>      <mi>A</mi>     </mrow>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0418" num="0413">Here, x and y indicate the horizontal position and the vertical position of the sub-block, respectively, and w indicates a determined weighting coefficient. The determined weighting coefficient may be predetermined.</p><p id="p-0419" num="0414">Such information indicating the affine mode (for example, referred to as an affine flag) may be signaled at the CU level. It is to be noted that the signaling of the information indicating the affine mode does not necessarily need to be performed at the CU level, and may be performed at another level (for example, at the sequence level, picture level, slice level, tile level, CTU level, or sub-block level).</p><p id="p-0420" num="0415">In addition, the affine mode may include several modes for different methods for deriving motion vectors at the upper-left and upper-right corner control points. For example, the affine mode include two modes which are the affine inter mode (also referred to as an affine normal inter mode) and the affine merge mode.</p><heading id="h-0045" level="2">[MV Derivation&#x3e;Affine Mode]</heading><p id="p-0421" num="0416"><figref idref="DRAWINGS">FIG. <b>46</b>B</figref> is a conceptual diagram for illustrating one example of MV derivation in units of a sub-block in affine mode in which three control points are used. In <figref idref="DRAWINGS">FIG. <b>46</b>B</figref>, the current block includes, for example, sixteen 4&#xd7;4 blocks. Here, motion vector V<sub>0 </sub>at the upper-left corner control point in the current block is derived based on a motion vector of a neighboring block. Here, motion vector V<sub>1 </sub>at the upper-right corner control point in the current block is derived based on a motion vector of a neighboring block, and likewise motion vector V<sub>2 </sub>at the lower-left corner control point for the current block is derived based on a motion vector of a neighboring block. Three motion vectors v<sub>0</sub>, v<sub>1</sub>, and v<sub>2 </sub>may be projected according to an expression (1B) indicated below, and motion vectors (v<sub>x</sub>, v<sub>y</sub>) for the respective sub-blocks in the current block may be derived.</p><p id="p-0422" num="0000"><maths id="MATH-US-00002" num="00002"><math overflow="scroll"> <mrow>  <mo>[</mo>  <mrow>   <mrow>    <mi>Math</mi>    <mo>.</mo>    <mtext>   </mtext>    <mn>1</mn>   </mrow>   <mo>&#x2062;</mo>   <mi>B</mi>  </mrow>  <mo>]</mo> </mrow></math></maths><maths id="MATH-US-00002-2" num="00002.2"><math overflow="scroll"> <mtable>  <mtr>   <mtd>    <mrow>     <mo>{</mo>     <mtable>      <mtr>       <mtd>        <mrow>         <msub>          <mi>v</mi>          <mi>x</mi>         </msub>         <mo>=</mo>         <mrow>          <mrow>           <mfrac>            <mrow>             <mo>(</mo>             <mrow>              <msub>               <mi>v</mi>               <mrow>                <mn>1</mn>                <mo>&#x2062;</mo>                <mi>x</mi>               </mrow>              </msub>              <mo>-</mo>              <msub>               <mi>v</mi>               <mrow>                <mn>0</mn>                <mo>&#x2062;</mo>                <mi>x</mi>               </mrow>              </msub>             </mrow>             <mo>)</mo>            </mrow>            <mi>w</mi>           </mfrac>           <mo>&#x2062;</mo>           <mi>x</mi>          </mrow>          <mo>-</mo>          <mrow>           <mfrac>            <mrow>             <mo>(</mo>             <mrow>              <msub>               <mi>v</mi>               <mrow>                <mn>2</mn>                <mo>&#x2062;</mo>                <mi>x</mi>               </mrow>              </msub>              <mo>-</mo>              <msub>               <mi>v</mi>               <mrow>                <mn>0</mn>                <mo>&#x2062;</mo>                <mi>x</mi>               </mrow>              </msub>             </mrow>             <mo>)</mo>            </mrow>            <mi>h</mi>           </mfrac>           <mo>&#x2062;</mo>           <mi>y</mi>          </mrow>          <mo>+</mo>          <msub>           <mi>v</mi>           <mrow>            <mn>0</mn>            <mo>&#x2062;</mo>            <mi>x</mi>           </mrow>          </msub>         </mrow>        </mrow>       </mtd>      </mtr>      <mtr>       <mtd>        <mrow>         <msub>          <mi>v</mi>          <mi>y</mi>         </msub>         <mo>=</mo>         <mrow>          <mrow>           <mfrac>            <mrow>             <mo>(</mo>             <mrow>              <msub>               <mi>v</mi>               <mrow>                <mn>1</mn>                <mo>&#x2062;</mo>                <mi>y</mi>               </mrow>              </msub>              <mo>-</mo>              <msub>               <mi>v</mi>               <mrow>                <mn>0</mn>                <mo>&#x2062;</mo>                <mi>y</mi>               </mrow>              </msub>             </mrow>             <mo>)</mo>            </mrow>            <mi>w</mi>           </mfrac>           <mo>&#x2062;</mo>           <mi>x</mi>          </mrow>          <mo>-</mo>          <mrow>           <mfrac>            <mrow>             <mo>(</mo>             <mrow>              <msub>               <mi>v</mi>               <mrow>                <mn>2</mn>                <mo>&#x2062;</mo>                <mi>y</mi>               </mrow>              </msub>              <mo>-</mo>              <msub>               <mi>v</mi>               <mrow>                <mn>0</mn>                <mo>&#x2062;</mo>                <mi>y</mi>               </mrow>              </msub>             </mrow>             <mo>)</mo>            </mrow>            <mi>h</mi>           </mfrac>           <mo>&#x2062;</mo>           <mi>y</mi>          </mrow>          <mo>+</mo>          <msub>           <mi>v</mi>           <mrow>            <mn>0</mn>            <mo>&#x2062;</mo>            <mi>y</mi>           </mrow>          </msub>         </mrow>        </mrow>       </mtd>      </mtr>     </mtable>    </mrow>   </mtd>   <mtd>    <mrow>     <mo>(</mo>     <mrow>      <mn>1</mn>      <mo>&#x2062;</mo>      <mi>B</mi>     </mrow>     <mo>)</mo>    </mrow>   </mtd>  </mtr> </mtable></math></maths></p><p id="p-0423" num="0417">Here, x and y indicate the horizontal position and the vertical position of the sub-block, respectively, and w and h may be weighting coefficients, which may be predetermined weighting coefficients. In an embodiment, w may indicate the width of the current block, and h may indicate the height of the current block.</p><p id="p-0424" num="0418">Affine modes in which different numbers of control points (for example, two and three control points) are used may be switched and signaled at the CU level. It is to be noted that information indicating the number of control points in affine mode used at the CU level may be signaled at another level (for example, the sequence level, picture level, slice level, tile level, CTU level, or sub-block level).</p><p id="p-0425" num="0419">In addition, such an affine mode in which three control points are used may include different methods for deriving motion vectors at the upper-left, upper-right, and lower-left corner control points. For example, the affine modes in which three control points are used may include two modes which are the affine inter mode and the affine merge mode, as in the case of affine modes in which two control points are used.</p><p id="p-0426" num="0420">It is to be noted that, in the affine modes, the size of each sub-block included in the current block may not be limited to 4&#xd7;4 pixels, and may be another size. For example, the size of each sub-block may be 8&#xd7;8 pixels.</p><heading id="h-0046" level="2">[MV Derivation&#x3e;Affine Mode&#x3e;Control Point]</heading><p id="p-0427" num="0421"><figref idref="DRAWINGS">FIG. <b>47</b>A</figref>, <figref idref="DRAWINGS">FIG. <b>47</b>B</figref>, and <figref idref="DRAWINGS">FIG. <b>47</b>C</figref> are conceptual diagrams for illustrating examples of MV derivation at control points in an affine mode.</p><p id="p-0428" num="0422">As illustrated in <figref idref="DRAWINGS">FIG. <b>47</b>A</figref>, in the affine mode, for example, motion vector predictors at respective control points of a current block are calculated based on a plurality of motion vectors corresponding to blocks encoded according to the affine mode among encoded block A (left), block B (upper), block C (upper-right), block D (lower-left), and block E (upper-left) which neighbor the current block. More specifically, encoded block A (left), block B (upper), block C (upper-right), block D (lower-left), and block E (upper-left) are checked in the listed order, and the first effective block encoded according to the affine mode is identified. Motion vector predictors at the control points of the current block are calculated based on a plurality of motion vectors corresponding to the identified block.</p><p id="p-0429" num="0423">For example, as illustrated in <figref idref="DRAWINGS">FIG. <b>47</b>B</figref>, when block A which neighbors to the left of the current block has been encoded according to an affine mode in which two control points are used, motion vectors v<sub>3 </sub>and v<sub>4 </sub>projected at the upper-left corner position and the upper-right corner position of the encoded block including block A are derived. Motion vector v<sub>0 </sub>at the upper-left corner control point of the current block and motion vector v<sub>1 </sub>at the upper-right corner control point of the current block are then calculated from derived motion vectors v<sub>3 </sub>and v<sub>4</sub>.</p><p id="p-0430" num="0424">For example, as illustrated in <figref idref="DRAWINGS">FIG. <b>47</b>C</figref>, when block A which neighbors to the left of the current block has been encoded according to an affine mode in which three control points are used, motion vectors v<sub>3</sub>, v<sub>4</sub>, and v<sub>5 </sub>projected at the upper-left corner position, the upper-right corner position, and the lower-left corner position of the encoded block including block A are derived. Motion vector v<sub>0 </sub>at the upper-left corner control point of the current block, motion vector v<sub>1 </sub>at the upper-right corner control point of the current block, and motion vector v<sub>2 </sub>at the lower-left corner control point of the current block are then calculated from derived motion vectors v<sub>3</sub>, v<sub>4</sub>, and v<sub>5</sub>.</p><p id="p-0431" num="0425">The MV derivation methods illustrated in <figref idref="DRAWINGS">FIGS. <b>47</b>A to <b>47</b>C</figref> may be used in the MV derivation at each control point for the current block in Step Sk_<b>1</b> illustrated in <figref idref="DRAWINGS">FIG. <b>50</b></figref>, or may be used for MV predictor derivation at each control point for the current block in Step Sj_<b>1</b> illustrated in <figref idref="DRAWINGS">FIG. <b>51</b></figref> described later.</p><p id="p-0432" num="0426"><figref idref="DRAWINGS">FIGS. <b>48</b>A and <b>48</b>B</figref> are conceptual diagrams for illustrating examples of MV derivation at control points in affine mode.</p><p id="p-0433" num="0427"><figref idref="DRAWINGS">FIG. <b>48</b>A</figref> is a conceptual diagram for illustrating an example affine mode in which two control points are used.</p><p id="p-0434" num="0428">In the affine mode, as illustrated in <figref idref="DRAWINGS">FIG. <b>48</b>A</figref>, a MV selected from MVs at encoded block A, block B, and block C which neighbor the current block is used as motion vector v<sub>0 </sub>at the upper-left corner control point for the current block. Likewise, a MV selected from MVs of encoded block D and block E which neighbor the current block is used as motion vector v<sub>1 </sub>at the upper-right corner control point for the current block.</p><p id="p-0435" num="0429"><figref idref="DRAWINGS">FIG. <b>48</b>B</figref> is a conceptual diagram for illustrating an example affine mode in which three control points are used.</p><p id="p-0436" num="0430">In the affine mode, as illustrated in <figref idref="DRAWINGS">FIG. <b>48</b>B</figref>, a MV selected from MVs at encoded block A, block B, and block C which neighbor the current block is used as motion vector v<sub>0 </sub>at the upper-left corner control point for the current block. Likewise, a MV selected from MVs of encoded block D and block E which neighbor the current block is used as motion vector v<sub>1 </sub>at the upper-right corner control point for the current block. Furthermore, a MV selected from MVs of encoded block F and block G which neighbor the current block is used as motion vector v<sub>2 </sub>at the lower-left corner control point for the current block.</p><p id="p-0437" num="0431">It is to be noted that the MV derivation methods illustrated in <figref idref="DRAWINGS">FIGS. <b>48</b>A and <b>48</b>B</figref> may be used in the MV derivation at each control point for the current block in Step Sk_<b>1</b> illustrated in <figref idref="DRAWINGS">FIG. <b>50</b></figref> described later, or may be used for MV predictor derivation at each control point for the current block in Step Sj_<b>1</b> illustrated in <figref idref="DRAWINGS">FIG. <b>51</b></figref> described later.</p><p id="p-0438" num="0432">Here, when affine modes in which different numbers of control points (for example, two and three control points) are used may be switched and signaled at the CU level, the number of control points for an encoded block and the number of control points for a current block may be different from each other.</p><p id="p-0439" num="0433"><figref idref="DRAWINGS">FIGS. <b>49</b>A and <b>49</b>B</figref> are conceptual diagrams for illustrating examples of a method for MV derivation at control points when the number of control points for an encoded block and the number of control points for a current block are different from each other.</p><p id="p-0440" num="0434">For example, as illustrated in <figref idref="DRAWINGS">FIG. <b>49</b>A</figref>, a current block has three control points at the upper-left corner, the upper-right corner, and the lower-left corner, and block A which neighbors to the left of the current block has been encoded according to an affine mode in which two control points are used. In this case, motion vectors v<sub>3 </sub>and v<sub>4 </sub>projected at the upper-left corner position and the upper-right corner position in the encoded block including block A are derived. Motion vector v<sub>0 </sub>at the upper-left corner control point and motion vector v<sub>1 </sub>at the upper-right corner control point for the current block are then calculated from derived motion vectors v<sub>3 </sub>and v<sub>4</sub>. Furthermore, motion vector v<sub>2 </sub>at the lower-left corner control point is calculated from derived motion vectors v<sub>0 </sub>and v<sub>1</sub>.</p><p id="p-0441" num="0435">For example, as illustrated in <figref idref="DRAWINGS">FIG. <b>49</b>B</figref>, a current block has two control points at the upper-left corner and the upper-right corner, and block A which neighbors to the left of the current block has been encoded according to an affine mode in which three control points are used. In this case, motion vectors v<sub>3</sub>, v<sub>4</sub>, and v<sub>5 </sub>projected at the upper-left corner position in the encoded block including block A, the upper-right corner position in the encoded block, and the lower-left corner position in the encoded block are derived. Motion vector v<sub>0 </sub>at the upper-left corner control point for the current block and motion vector v<sub>1 </sub>at the upper-right corner control point for the current block are then calculated from derived motion vectors v<sub>3</sub>, v<sub>4</sub>, and v<sub>5</sub>.</p><p id="p-0442" num="0436">It is to be noted that the MV derivation methods illustrated in <figref idref="DRAWINGS">FIGS. <b>49</b>A and <b>49</b>B</figref> may be used in the MV derivation at each control point for the current block in Step Sk_<b>1</b> illustrated in <figref idref="DRAWINGS">FIG. <b>50</b></figref> described later, or may be used for MV predictor derivation at each control point for the current block in Step Sj_<b>1</b> illustrated in <figref idref="DRAWINGS">FIG. <b>51</b></figref> described later.</p><heading id="h-0047" level="2">[MV Derivation&#x3e;Affine Mode&#x3e;Affine Merge Mode]</heading><p id="p-0443" num="0437"><figref idref="DRAWINGS">FIG. <b>50</b></figref> is a flow chart illustrating one example of a process in the affine merge mode.</p><p id="p-0444" num="0438">In affine merge mode as illustrated, first, inter predictor <b>126</b> derives MVs at respective control points for a current block (Step Sk_<b>1</b>). The control points are an upper-left corner point of the current block and an upper-right corner point of the current block as illustrated in <figref idref="DRAWINGS">FIG. <b>46</b>A</figref>, or an upper-left corner point of the current block, an upper-right corner point of the current block, and a lower-left corner point of the current block as illustrated in <figref idref="DRAWINGS">FIG. <b>46</b>B</figref>. Inter predictor <b>126</b> may encode MV selection information for identifying two or three derived MVs in a stream.</p><p id="p-0445" num="0439">For example, when MV derivation methods illustrated in <figref idref="DRAWINGS">FIGS. <b>47</b>A to <b>47</b>C</figref> are used, as illustrated in <figref idref="DRAWINGS">FIG. <b>47</b>A</figref>, inter predictor <b>126</b> checks encoded block A (left), block B (upper), block C (upper-right), block D (lower-left), and block E (upper-left) in the listed order, and identifies the first effective block encoded according to the affine mode.</p><p id="p-0446" num="0440">Inter predictor <b>126</b> derives the MV at the control point using the identified first effective block encoded according to the identified affine mode. For example, when block A is identified and block A has two control points, as illustrated in <figref idref="DRAWINGS">FIG. <b>47</b>B</figref>, inter predictor <b>126</b> calculates motion vector v<sub>0 </sub>at the upper-left corner control point of the current block and motion vector v<sub>1 </sub>at the upper-right corner control point of the current block from motion vectors v<sub>3 </sub>and v<sub>4 </sub>at the upper-left corner of the encoded block including block A and the upper-right corner of the encoded block. For example, inter predictor <b>126</b> calculates motion vector v<sub>0 </sub>at the upper-left corner control point of the current block and motion vector v<sub>1 </sub>at the upper-right corner control point of the current block by projecting motion vectors v<sub>3 </sub>and v<sub>4 </sub>at the upper-left corner and the upper-right corner of the encoded block onto the current block.</p><p id="p-0447" num="0441">Alternatively, when block A is identified and block A has three control points, as illustrated in <figref idref="DRAWINGS">FIG. <b>47</b>C</figref>, inter predictor <b>126</b> calculates motion vector v<sub>0 </sub>at the upper-left corner control point of the current block, motion vector v<sub>1 </sub>at the upper-right corner control point of the current block, and motion vector v<sub>2 </sub>at the lower-left corner control point of the current block from motion vectors v<sub>3</sub>, v<sub>4</sub>, and v<sub>5 </sub>at the upper-left corner of the encoded block including block A, the upper-right corner of the encoded block, and the lower-left corner of the encoded block. For example, inter predictor <b>126</b> calculates motion vector v<sub>0 </sub>at the upper-left corner control point of the current block, motion vector v<sub>1 </sub>at the upper-right corner control point of the current block, and motion vector v<sub>2 </sub>at the lower-left corner control point of the current block by projecting motion vectors v<sub>3</sub>, v<sub>4</sub>, and v<sub>5 </sub>at the upper-left corner, the upper-right corner, and the lower-left corner of the encoded block onto the current block.</p><p id="p-0448" num="0442">It is to be noted that, as illustrated in <figref idref="DRAWINGS">FIG. <b>49</b>A</figref> described above, MVs at three control points may be calculated when block A is identified and block A has two control points, and that, as illustrated in <figref idref="DRAWINGS">FIG. <b>49</b>B</figref> described above, MVs at two control points may be calculated when block A is identified and block A has three control points.</p><p id="p-0449" num="0443">Next, inter predictor <b>126</b> performs motion compensation of each of a plurality of sub-blocks included in the current block. In other words, inter predictor <b>126</b> calculates a MV for each of a plurality of sub-blocks as an affine MV, for example using two motion vectors v<sub>0 </sub>and v<sub>1 </sub>and the above expression (1A) or three motion vectors v<sub>0</sub>, v<sub>1</sub>, and v<sub>2 </sub>and the above expression (1B) (Step Sk_<b>2</b>). Inter predictor <b>126</b> then performs motion compensation of the sub-blocks using these affine MVs and encoded reference pictures (Step Sk_<b>3</b>). When the processes in Steps Sk_<b>2</b> and Sk_<b>3</b> are executed for each of all the sub-blocks included in the current block, the process for generating a prediction image using the affine merge mode for the current block finishes. In other words, motion compensation of the current block is performed to generate a prediction image of the current block.</p><p id="p-0450" num="0444">It is to be noted that the above-described MV candidate list may be generated in Step Sk_<b>1</b>. The MV candidate list may be, for example, a list including MV candidates derived using a plurality of MV derivation methods for each control point. The plurality of MV derivation methods may be, for example, any combination of the MV derivation methods illustrated in <figref idref="DRAWINGS">FIGS. <b>47</b>A to <b>47</b>C</figref>, the MV derivation methods illustrated in <figref idref="DRAWINGS">FIGS. <b>48</b>A and <b>48</b>B</figref>, the MV derivation methods illustrated in <figref idref="DRAWINGS">FIGS. <b>49</b>A and <b>49</b>B</figref>, and other MV derivation methods.</p><p id="p-0451" num="0445">It is to be noted that MV candidate lists may include MV candidates in a mode in which prediction is performed in units of a sub-block, other than the affine mode.</p><p id="p-0452" num="0446">It is to be noted that, for example, a MV candidate list including MV candidates in an affine merge mode in which two control points are used and an affine merge mode in which three control points are used may be generated as a MV candidate list. Alternatively, a MV candidate list including MV candidates in the affine merge mode in which two control points are used and a MV candidate list including MV candidates in the affine merge mode in which three control points are used may be generated separately. Alternatively, a MV candidate list including MV candidates in one of the affine merge mode in which two control points are used and the affine merge mode in which three control points are used may be generated. The MV candidate(s) may be, for example, MVs for encoded block A (left), block B (upper), block C (upper-right), block D (lower-left), and block E (upper-left), or a MV for an effective block among the blocks.</p><p id="p-0453" num="0447">It is to be noted that index indicating one of the MVs in a MV candidate list may be transmitted as MV selection information.</p><heading id="h-0048" level="2">[MV Derivation&#x3e;Affine Mode&#x3e;Affine Inter Mode]</heading><p id="p-0454" num="0448"><figref idref="DRAWINGS">FIG. <b>51</b></figref> is a flow chart illustrating one example of a process in an affine inter mode.</p><p id="p-0455" num="0449">In the affine inter mode, first, inter predictor <b>126</b> derives MV predictors (v<sub>0</sub>, v<sub>1</sub>) or (v<sub>0</sub>, v<sub>1</sub>, v<sub>2</sub>) of respective two or three control points for a current block (Step Sj_<b>1</b>). The control points may be, for example, an upper-left corner point for the current block, an upper-right corner point of the current block, and an upper-right corner point for the current block as illustrated in <figref idref="DRAWINGS">FIG. <b>46</b>A</figref> or <figref idref="DRAWINGS">FIG. <b>46</b>B</figref>.</p><p id="p-0456" num="0450">For example, when the MV derivation methods illustrated in <figref idref="DRAWINGS">FIGS. <b>48</b>A and <b>48</b>B</figref> are used, inter predictor <b>126</b> derives the MV predictors (v<sub>0</sub>, v<sub>1</sub>) or (v<sub>0</sub>, v, v<sub>2</sub>) at respective two or three control points for the current block by selecting MVs of any of the blocks among encoded blocks in the vicinity of the respective control points for the current block illustrated in <figref idref="DRAWINGS">FIG. <b>48</b>A</figref> or <figref idref="DRAWINGS">FIG. <b>48</b>B</figref>. At this time, inter predictor <b>126</b> encodes, in a stream, MV predictor selection information for identifying the selected two or three MV predictors.</p><p id="p-0457" num="0451">For example, inter predictor <b>126</b> may determine, using a cost evaluation or the like, the block from which a MV as a MV predictor at a control point is selected from among encoded blocks neighboring the current block, and may write, in a bitstream, a flag indicating which MV predictor has been selected. In other words, inter predictor <b>126</b> outputs, as a prediction parameter, the MV predictor selection information such as a flag to entropy encoder <b>110</b> through prediction parameter generator <b>130</b>.</p><p id="p-0458" num="0452">Next, inter predictor <b>126</b> performs motion estimation (Step Sj_<b>3</b> and Sj_<b>4</b>) while updating the MV predictor selected or derived in Step Sj_<b>1</b> (Step Sj_<b>2</b>). In other words, inter predictor <b>126</b> calculates, as an affine MV, a MV of each of sub-blocks which corresponds to an updated MV predictor, using the expression (1A) or expression (1B) described above (Step Sj_<b>3</b>). Inter predictor <b>126</b> then performs motion compensation of the sub-blocks using these affine MVs and encoded reference pictures (Step Sj_<b>4</b>). The processes in Step Sj_<b>3</b> and Sj_<b>4</b> are executed on all the blocks in the current block when a MV predictor is updated in Step Sj_<b>2</b>. As a result, for example, inter predictor <b>126</b> determines the MV predictor which yields the smallest cost as the MV at a control point in a motion estimation loop (Step Sj_<b>5</b>). At this time, inter predictor <b>126</b> further encodes, in the stream, the difference value between the determined MV and the MV predictor as a MV difference. In other words, inter predictor <b>126</b> outputs the MV difference as a prediction parameter to entropy encoder <b>110</b> through prediction parameter generator <b>130</b>.</p><p id="p-0459" num="0453">Lastly, inter predictor <b>126</b> generates a prediction image for the current block by performing motion compensation of the current block using the determined MV and the encoded reference picture (Step Sj_<b>6</b>).</p><p id="p-0460" num="0454">It is to be noted that the above-described MV candidate list may be generated in Step Sj_<b>1</b>. The MV candidate list may be, for example, a list including MV candidates derived using a plurality of MV derivation methods for each control point. The plurality of MV derivation methods may be, for example, any combination of the MV derivation methods illustrated in <figref idref="DRAWINGS">FIGS. <b>47</b>A to <b>47</b>C</figref>, the MV derivation methods illustrated in <figref idref="DRAWINGS">FIGS. <b>48</b>A and <b>48</b>B</figref>, the MV derivation methods illustrated in <figref idref="DRAWINGS">FIGS. <b>49</b>A and <b>49</b>B</figref>, and other MV derivation methods.</p><p id="p-0461" num="0455">It is to be noted that MV candidate lists may include MV candidates in a mode in which prediction is performed in units of a sub-block, other than the affine mode.</p><p id="p-0462" num="0456">It is to be noted that, for example, a MV candidate list including MV candidates in an affine inter mode in which two control points are used and an affine inter mode in which three control points are used may be generated as a MV candidate list. Alternatively, a MV candidate list including MV candidates in the affine inter mode in which two control points are used and a MV candidate list including MV candidates in the affine inter mode in which three control points are used may be generated separately. Alternatively, a MV candidate list including MV candidates in one of the affine inter mode in which two control points are used and the affine inter mode in which three control points are used may be generated. The MV candidate(s) may be, for example, MVs for encoded block A (left), block B (upper), block C (upper-right), block D (lower-left), and block E (upper-left), or a MV for an effective block among the blocks.</p><p id="p-0463" num="0457">It is to be noted that index indicating one of the MV candidates in a MV candidate list may be transmitted as MV predictor selection information.</p><heading id="h-0049" level="2">[MV Derivation&#x3e;Triangle Mode]</heading><p id="p-0464" num="0458">Inter predictor <b>126</b> generates one rectangular prediction image for a current rectangular block in the above example. However, inter predictor <b>126</b> may generate a plurality of prediction images each having a shape different from a rectangle for the current rectangular block, and may combine the plurality of prediction images to generate the final rectangular prediction image. The shape different from a rectangle may be, for example, a triangle.</p><p id="p-0465" num="0459"><figref idref="DRAWINGS">FIG. <b>52</b>A</figref> is a conceptual diagram for illustrating generation of two triangular prediction images.</p><p id="p-0466" num="0460">Inter predictor <b>126</b> generates a triangular prediction image by performing motion compensation of a first partition having a triangular shape in a current block by using a first MV of the first partition, to generate a triangular prediction image. Likewise, inter predictor <b>126</b> generates a triangular prediction image by performing motion compensation of a second partition having a triangular shape in a current block by using a second MV of the second partition, to generate a triangular prediction image. Inter predictor <b>126</b> then generates a prediction image having the same rectangular shape as the rectangular shape of the current block by combining these prediction images.</p><p id="p-0467" num="0461">It is to be noted that a first prediction image having a rectangular shape corresponding to a current block may be generated as a prediction image for a first partition, using a first MV. In addition, a second prediction image having a rectangular shape corresponding to a current block may be generated as a prediction image for a second partition, using a second MV. A prediction image for the current block may be generated by performing a weighted addition of the first prediction image and the second prediction image. It is to be noted that the part which is subjected to the weighted addition may be a partial region across the boundary between the first partition and the second partition.</p><p id="p-0468" num="0462"><figref idref="DRAWINGS">FIG. <b>52</b>B</figref> is a conceptual diagram for illustrating examples of a first portion of a first partition which overlaps with a second partition, and first and second sets of samples which may be weighted as part of a correction process. The first portion may be, for example, one quarter of the width or height of the first partition. In another example, the first portion may have a width corresponding to N samples adjacent to an edge of the first partition, where N is an integer greater than zero, for example, N may be the integer 2. As illustrated, the left example of <figref idref="DRAWINGS">FIG. <b>52</b>B</figref> shows a rectangular partition having a rectangular portion with a width which is one fourth of the width of the first partition, with the first set of samples including samples outside of the first portion and samples inside of the first portion, and the second set of samples including samples within the first portion. The center example of <figref idref="DRAWINGS">FIG. <b>52</b>B</figref> shows a rectangular partition having a rectangular portion with a height which is one fourth of the height of the first partition, with the first set of samples including samples outside of the first portion and samples inside of the first portion, and the second set of samples including samples within the first portion. The right example of <figref idref="DRAWINGS">FIG. <b>52</b>B</figref> shows a triangular partition having a polygonal portion with a height which corresponds to two samples, with the first set of samples including samples outside of the first portion and samples inside of the first portion, and the second set of samples including samples within the first portion.</p><p id="p-0469" num="0463">The first portion may be a portion of the first partition which overlaps with an adjacent partition. <figref idref="DRAWINGS">FIG. <b>52</b>C</figref> is a conceptual diagram for illustrating a first portion of a first partition, which is a portion of the first partition that overlaps with a portion of an adjacent partition. For ease of illustration, a rectangular partition having an overlapping portion with a spatially adjacent rectangular partition is shown. Partitions having other shapes, such as triangular partitions, may be employed, and the overlapping portions may overlap with a spatially or temporally adjacent partition.</p><p id="p-0470" num="0464">In addition, although an example is given in which a prediction image is generated for each of two partitions using inter prediction, a prediction image may be generated for at least one partition using intra prediction.</p><p id="p-0471" num="0465"><figref idref="DRAWINGS">FIG. <b>53</b></figref> is a flow chart illustrating one example of a process in a triangle mode.</p><p id="p-0472" num="0466">In the triangle mode, first, inter predictor <b>126</b> splits the current block into the first partition and the second partition (Step Sx_<b>1</b>). At this time, inter predictor <b>126</b> may encode, in a stream, partition information which is information related to the splitting into the partitions as a prediction parameter. In other words, inter predictor <b>126</b> may output the partition information as the prediction parameter to entropy encoder <b>110</b> through prediction parameter generator <b>130</b>.</p><p id="p-0473" num="0467">First, inter predictor <b>126</b> obtains a plurality of MV candidates for a current block based on information such as MVs of a plurality of encoded blocks temporally or spatially surrounding the current block (Step Sx_<b>2</b>). In other words, inter predictor <b>126</b> generates a MV candidate list.</p><p id="p-0474" num="0468">Inter predictor <b>126</b> then selects the MV candidate for the first partition and the MV candidate for the second partition as a first MV and a second MV, respectively, from the plurality of MV candidates obtained in Step Sx_<b>1</b> (Step Sx_<b>3</b>). At this time, inter predictor <b>126</b> encodes, in a stream, MV selection information for identifying the selected MV candidate as a prediction parameter. In other words, inter predictor <b>126</b> outputs the MV selection information as a prediction parameter to entropy encoder <b>110</b> through prediction parameter generator <b>130</b>.</p><p id="p-0475" num="0469">Next, inter predictor <b>126</b> generates a first prediction image by performing motion compensation using the selected first MV and an encoded reference picture (Step Sx_<b>4</b>). Likewise, inter predictor <b>126</b> generates a second prediction image by performing motion compensation using the selected second MV and an encoded reference picture (Step Sx_<b>5</b>).</p><p id="p-0476" num="0470">Lastly, inter predictor <b>126</b> generates a prediction image for the current block by performing a weighted addition of the first prediction image and the second prediction image (Step Sx_<b>6</b>).</p><p id="p-0477" num="0471">It is to be noted that, although the first partition and the second partition are triangles in the example illustrated in <figref idref="DRAWINGS">FIG. <b>52</b>A</figref>, the first partition and the second partition may be trapezoids, or other shapes different from each other. Furthermore, although the current block includes two partitions in the examples illustrated in <figref idref="DRAWINGS">FIGS. <b>52</b>A and <b>52</b>C</figref>, the current block may include three or more partitions.</p><p id="p-0478" num="0472">In addition, the first partition and the second partition may overlap with each other. In other words, the first partition and the second partition may include the same pixel region. In this case, a prediction image for a current block may be generated using a prediction image in the first partition and a prediction image in the second partition.</p><p id="p-0479" num="0473">In addition, although the example in which the prediction image is generated for each of the two partitions using inter prediction has been illustrated, a prediction image may be generated for at least one partition using intra prediction.</p><p id="p-0480" num="0474">It is to be noted that the MV candidate list for selecting the first MV and the MV candidate list for selecting the second MV may be different from each other, or the MV candidate list for selecting the first MV may be also used as the MV candidate list for selecting the second MV.</p><p id="p-0481" num="0475">It is to be noted that partition information may include an index indicating the splitting direction in which at least a current block is split into a plurality of partitions. The MV selection information may include an index indicating the selected first MV and an index indicating the selected second MV. One index may indicate a plurality of pieces of information. For example, one index collectively indicating a part or the entirety of partition information and a part or the entirety of MV selection information may be encoded.</p><heading id="h-0050" level="2">[MV Derivation&#x3e;ATMVP Mode]</heading><p id="p-0482" num="0476"><figref idref="DRAWINGS">FIG. <b>54</b></figref> is a conceptual diagram for illustrating one example of an Advanced Temporal Motion Vector Prediction (ATMVP) mode in which a MV is derived in units of a sub-block.</p><p id="p-0483" num="0477">The ATMVP mode is a mode categorized into the merge mode. For example, in the ATMVP mode, a MV candidate for each sub-block is registered in a MV candidate list for use in normal merge mode.</p><p id="p-0484" num="0478">More specifically, in the ATMVP mode, first, as illustrated in <figref idref="DRAWINGS">FIG. <b>54</b></figref>, a temporal MV reference block associated with a current block is identified in an encoded reference picture specified by a MV (MV<b>0</b>) of a neighboring block located at the lower-left position with respect to the current block. Next, in each sub-block in the current block, the MV used to encode the region corresponding to the sub-block in the temporal MV reference block is identified. The MV identified in this way is included in a MV candidate list as a MV candidate for the sub-block in the current block. When the MV candidate for each sub-block is selected from the MV candidate list, the sub-block is subjected to motion compensation in which the MV candidate is used as the MV for the sub-block. In this way, a prediction image for each sub-block is generated.</p><p id="p-0485" num="0479">Although the block located at the lower-left position with respect the current block is used as a surrounding MV reference block in the example illustrated in <figref idref="DRAWINGS">FIG. <b>54</b></figref>, it is to be noted that another block may be used. In addition, the size of the sub-block may be 4&#xd7;4 pixels, 8&#xd7;8 pixels, or another size. The size of the sub-block may be switched for a unit such as a slice, brick, picture, etc.</p><heading id="h-0051" level="2">[MV Derivation&#x3e;DMVR]</heading><p id="p-0486" num="0480"><figref idref="DRAWINGS">FIG. <b>55</b></figref> is a flow chart illustrating a relationship between the merge mode and Decoder Motion Vector Refinement DMVR.</p><p id="p-0487" num="0481">Inter predictor <b>126</b> derives a motion vector for a current block according to the merge mode (Step Sl_<b>1</b>). Next, inter predictor <b>126</b> determines whether to perform estimation of a motion vector, that is, motion estimation (Step Sl_<b>2</b>). Here, when determining not to perform motion estimation (No in Step Sl_<b>2</b>), inter predictor <b>126</b> determines the motion vector derived in Step Sl_<b>1</b> as the final motion vector for the current block (Step Sl_<b>4</b>). In other words, in this case, the motion vector of the current block is determined according to the merge mode.</p><p id="p-0488" num="0482">When determining to perform motion estimation in Step Sl_<b>1</b> (Yes in Step Sl_<b>2</b>), inter predictor <b>126</b> derives the final motion vector for the current block by estimating a surrounding region of the reference picture specified by the motion vector derived in Step Sl_<b>1</b> (Step Sl_<b>3</b>). In other words, in this case, the motion vector of the current block is determined according to the DMVR.</p><p id="p-0489" num="0483"><figref idref="DRAWINGS">FIG. <b>56</b></figref> is a conceptual diagram for illustrating one example of a DMVR process for determining a MV.</p><p id="p-0490" num="0484">First, in the merge mode for example, MV candidates (L0 and L1) are selected for the current block. A reference pixel is identified from a first reference picture (L0) which is an encoded picture in the L0 list according to the MV candidate (L0). Likewise, a reference pixel is identified from the second reference picture (L1) which is an encoded picture in the L1 list according to the MV candidate (L1). A template is generated by calculating an average of these reference pixels.</p><p id="p-0491" num="0485">Next, each of the surrounding regions of MV candidates of the first reference picture (L0) and the second reference picture (L1) are estimated using the template, and the MV which yields the smallest cost is determined to be the final MV. It is to be noted that the cost may be calculated, for example, using a difference value between each of the pixel values in the template and a corresponding one of the pixel values in the estimation region, the values of MV candidates, etc.</p><p id="p-0492" num="0486">Exactly the same processes described here do not always need to be performed. Other process for enabling derivation of the final MV by estimation in surrounding regions of MV candidates may be used.</p><p id="p-0493" num="0487"><figref idref="DRAWINGS">FIG. <b>57</b></figref> is a conceptual diagram for illustrating another example of DMVR for determining a MV. Unlike the example of DMVR illustrated in <figref idref="DRAWINGS">FIG. <b>56</b></figref>, in the example illustrated in <figref idref="DRAWINGS">FIG. <b>57</b></figref>, costs are calculated without generating a template.</p><p id="p-0494" num="0488">First, inter predictor <b>126</b> estimates a surrounding region of a reference block included in each of reference pictures in the L0 list and L1 list, based on an initial MV which is a MV candidate obtained from each MV candidate list. For example, as illustrated in <figref idref="DRAWINGS">FIG. <b>57</b></figref>, the initial MV corresponding to the reference block in the L0 list is InitMV_L0, and the initial MV corresponding to the reference block in the L1 list is InitMV_L1. In motion estimation, inter predictor <b>126</b> first sets the search position for the reference picture in the L0 list. Based on the position indicated by the vector difference indicating the search position to be set, specifically, the initial MV (that is, InitMV_L0, the vector difference to the search position is MVd_L0. Inter predictor <b>126</b> then determines the estimation position in the reference picture in the L1 list. This search position is indicated by the vector difference to the search position from the position indicated by the initial MV (that is, InitMV_L1). More specifically, inter predictor <b>126</b> determines the vector difference as MVd_L1 by mirroring of MVd_L0. In other words, inter predictor <b>126</b> determines the position which is symmetrical with respect to the position indicated by the initial MV to be the search position in each reference picture in the L0 list and the L1 list. Inter predictor <b>126</b> calculates, for each search position, the total sum of the absolute differences (SADs) between values of pixels at search positions in blocks as a cost, and finds out the search position that yields the smallest cost.</p><p id="p-0495" num="0489"><figref idref="DRAWINGS">FIG. <b>58</b>A</figref> is a conceptual diagram for illustrating one example of motion estimation in DMVR, and <figref idref="DRAWINGS">FIG. <b>58</b>B</figref> is a flow chart illustrating one example of a process of motion estimation.</p><p id="p-0496" num="0490">First, in Step <b>1</b>, inter predictor <b>126</b> calculates the cost between the search position (also referred to as a starting point) indicated by the initial MV and eight surrounding search positions. Inter predictor <b>126</b> then determines whether the cost at each of the search positions other than the starting point is the smallest. Here, when determining that the cost at the search position other than the starting point is the smallest, inter predictor <b>126</b> changes a target to the search position at which the smallest cost is obtained, and performs the process in Step <b>2</b>. When the cost at the starting point is the smallest, inter predictor <b>126</b> skips the process in Step <b>2</b> and performs the process in Step <b>3</b>.</p><p id="p-0497" num="0491">In Step <b>2</b>, inter predictor <b>126</b> performs the search similar to the process in Step <b>1</b>, regarding, as a new starting point, the search position after the target change according to the result of the process in Step <b>1</b>. Inter predictor <b>126</b> then determines whether the cost at each of the search positions other than the starting point is the smallest. Here, when determining that the cost at the search position other than the starting point is the smallest, inter predictor <b>126</b> performs the process in Step <b>4</b>. When the cost at the starting point is the smallest, inter predictor <b>126</b> performs the process in Step <b>3</b>.</p><p id="p-0498" num="0492">In Step <b>4</b>, inter predictor <b>126</b> regards the search position at the starting point as the final search position, and determines the difference between the position indicated by the initial MV and the final search position to be a vector difference.</p><p id="p-0499" num="0493">In Step <b>3</b>, inter predictor <b>126</b> determines the pixel position at sub-pixel accuracy at which the smallest cost is obtained, based on the costs at the four points located at upper, lower, left, and right positions with respect to the starting point in Step <b>1</b> or Step <b>2</b>, and regards the pixel position as the final search position. The pixel position at the sub-pixel accuracy is determined by performing weighted addition of each of the four upper, lower, left, and right vectors ((0, 1), (0, &#x2212;1), (&#x2212;1, 0), and (1, 0)), using, as a weight, the cost at a corresponding one of the four search positions. Inter predictor <b>126</b> then determines the difference between the position indicated by the initial MV and the final search position to be the vector difference.</p><heading id="h-0052" level="2">[Motion Compensation&#x3e;BIO/OBMC/LIC]</heading><p id="p-0500" num="0494">Motion compensation involves a mode for generating a prediction image, and correcting the prediction image. The mode is, for example, bi-directional optical flow (BIO), overlapped block motion compensation (OBMC), local illumination compensation (LIC), to be described later, etc.</p><p id="p-0501" num="0495"><figref idref="DRAWINGS">FIG. <b>59</b></figref> is a flow chart illustrating one example of a process of generation of a prediction image.</p><p id="p-0502" num="0496">Inter predictor <b>126</b> generates a prediction image (Step Sm_<b>1</b>), and corrects the prediction image, for example, according to, for example, any of the modes described above (Step Sm_<b>2</b>).</p><p id="p-0503" num="0497"><figref idref="DRAWINGS">FIG. <b>60</b></figref> is a flow chart illustrating another example of a process of generation of a prediction image.</p><p id="p-0504" num="0498">Inter predictor <b>126</b> determines a motion vector of a current block (Step Sn_<b>1</b>). Next, inter predictor <b>126</b> generates a prediction image using the motion vector (Step Sn_<b>2</b>), and determines whether to perform a correction process (Step Sn_<b>3</b>). Here, when determining to perform a correction process (Yes in Step Sn_<b>3</b>), inter predictor <b>126</b> generates the final prediction image by correcting the prediction image (Step Sn_<b>4</b>). It is to be noted that, in LIC described later, luminance and chrominance may be corrected in Step Sn_<b>4</b>. When determining not to perform a correction process (No in Step Sn_<b>3</b>), inter predictor <b>126</b> outputs the prediction image as the final prediction image without correcting the prediction image (Step Sn_<b>5</b>).</p><heading id="h-0053" level="2">[Motion Compensation&#x3e;OBMC]</heading><p id="p-0505" num="0499">It is to be noted that an inter prediction image may be generated using motion information for a neighboring block in addition to motion information for the current block obtained by motion estimation. More specifically, an inter prediction image may be generated for each sub-block in a current block by performing weighted addition of a prediction image based on the motion information obtained by motion estimation (in a reference picture) and a prediction image based on the motion information of the neighboring block (in the current picture). Such inter prediction (motion compensation) is also referred to as overlapped block motion compensation (OBMC) or an OBMC mode.</p><p id="p-0506" num="0500">In OBMC mode, information indicating a sub-block size for OBMC (referred to as, for example, an OBMC block size) may be signaled at the sequence level. Moreover, information indicating whether to apply the OBMC mode (referred to as, for example, an OBMC flag) may be signaled at the CU level. It is to be noted that the signaling of such information does not necessarily need to be performed at the sequence level and CU level, and may be performed at another level (for example, at the picture level, slice level, brick level, CTU level, or sub-block level).</p><p id="p-0507" num="0501">The OBMC mode will be described in further detail. <figref idref="DRAWINGS">FIGS. <b>61</b> and <b>62</b></figref> are a flow chart and a conceptual diagram for illustrating an outline of a prediction image correction process performed by OBMC.</p><p id="p-0508" num="0502">First, as illustrated in <figref idref="DRAWINGS">FIG. <b>62</b></figref>, a prediction image (Pred) by normal motion compensation is obtained using a MV assigned to a current block. In <figref idref="DRAWINGS">FIG. <b>62</b></figref>, the arrow &#x201c;MV&#x201d; points a reference picture, and indicates what the current block of the current picture refers to in order to obtain the prediction image.</p><p id="p-0509" num="0503">Next, a prediction image (Pred_L) is obtained by applying a motion vector (MV_L) which has been already derived for the encoded block neighboring to the left of the current block to the current block (re-using the motion vector for the current block). The motion vector (MV_L) is indicated by an arrow &#x201c;MV_L&#x201d; indicating a reference picture from a current block. A first correction of a prediction image is performed by overlapping two prediction images Pred and Pred_L. This provides an effect of blending the boundary between neighboring blocks.</p><p id="p-0510" num="0504">Likewise, a prediction image (Pred_U) is obtained by applying a MV (MV_U) which has been already derived for the encoded block neighboring above the current block to the current block (re-using the MV for the current block). The MV (MV_U) is indicated by an arrow &#x201c;MV_U&#x201d; indicating a reference picture from a current block. A second correction of a prediction image is performed by overlapping the prediction image Pred_U to the prediction images (for example, Pred and Pred_L) on which the first correction has been performed. This provides an effect of blending the boundary between neighboring blocks. The prediction image obtained by the second correction is the one in which the boundary between the neighboring blocks has been blended (smoothed), and thus is the final prediction image of the current block.</p><p id="p-0511" num="0505">Although the above example is a two-path correction method using left and upper neighboring blocks, it is to be noted that the correction method may be three- or more-path correction method using also the right neighboring block and/or the lower neighboring block.</p><p id="p-0512" num="0506">It is to be noted that the region in which such overlapping is performed may be only part of a region near a block boundary instead of the pixel region of the entire block.</p><p id="p-0513" num="0507">It is to be noted that the prediction image correction process according to OBMC for obtaining one prediction image Pred from one reference picture by overlapping additional prediction image Pred_L and Pred_U have been described above. However, when a prediction image is corrected based on a plurality of reference images, a similar process may be applied to each of the plurality of reference pictures. In such a case, after corrected prediction images are obtained from the respective reference pictures by performing OBMC image correction based on the plurality of reference pictures, the obtained corrected prediction images are further overlapped to obtain the final prediction image.</p><p id="p-0514" num="0508">It is to be noted that, in OBMC, a current block unit may be a PU or a sub-block unit obtained by further splitting the PU.</p><p id="p-0515" num="0509">One example of a method for determining whether to apply OBMC is a method for using an obmc_flag which is a signal indicating whether to apply OBMC. As one specific example, encoder <b>100</b> may determine whether the current block belongs to a region having complicated motion. Encoder <b>100</b> sets the obmc_flag to a value of &#x201c;1&#x201d; when the block belongs to a region having complicated motion and applies OBMC when encoding, and sets the obmc_flag to a value of &#x201c;0&#x201d; when the block does not belong to a region having complicated motion and encodes the block without applying OBMC. Decoder <b>200</b> switches between application and non-application of OBMC by decoding the obmc_flag written in a stream.</p><heading id="h-0054" level="2">[Motion Compensation&#x3e;BIO]</heading><p id="p-0516" num="0510">Next, a MV derivation method is described. First, a mode for deriving a MV based on a model assuming uniform linear motion is described. This mode is also referred to as a bi-directional optical flow (BIO) mode. In addition, this bi-directional optical flow may be written as BDOF instead of BIO.</p><p id="p-0517" num="0511"><figref idref="DRAWINGS">FIG. <b>63</b></figref> is a conceptual diagram for illustrating a model assuming uniform linear motion. In <figref idref="DRAWINGS">FIG. <b>63</b></figref>, (v<sub>x</sub>, v<sub>y</sub>) indicates a velocity vector, and &#x3c4;<b>0</b> and &#x3c4;<b>1</b> indicate temporal distances between a current picture (Cur Pic) and two reference pictures (Ref<sub>0</sub>, Ref<sub>1</sub>). (MV<sub>x0</sub>, MV<sub>y0</sub>) indicate MVs corresponding to reference picture Ref<sub>0</sub>, and (MV<sub>x1</sub>, MV<sub>y1</sub>) indicate MVs corresponding to reference picture Ref<sub>1</sub>.</p><p id="p-0518" num="0512">Here, under the assumption of uniform linear motion exhibited by a velocity vector (v<sub>x</sub>, v<sub>y</sub>), (MV<sub>x0</sub>, MV<sub>y0</sub>) and (MV<sub>x1</sub>, MV<sub>y1</sub>) are represented as (v<sub>x</sub>&#x3c4;<sub>0</sub>, v<sub>y</sub>&#x3c4;<sub>0</sub>) and (&#x2212;v<sub>x&#x3c4;1</sub>, &#x2212;v<sub>y&#x3c4;1</sub>), respectively, and the following optical flow equation (2) is given.</p><p id="p-0519" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>[Math 2]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0520" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>&#x2202;<i>I</i><sup>(k)</sup><i>/&#x2202;t+v</i><sub>x</sub><i>&#x2202;I</i><sup>(k)</sup><i>/&#x2202;x+v</i><sub>y</sub><i>&#x2202;I</i><sup>(k)</sup><i>/&#x2202;y</i>=0&#x2003;&#x2003;(2)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0521" num="0513">Here, I(k) indicates a motion-compensated luma value of reference picture k (k=0, 1) after motion compensation. This optical flow equation shows that the sum of (i) the time derivative of the luma value, (ii) the product of the horizontal velocity and the horizontal component of the spatial gradient of a reference image, and (iii) the product of the vertical velocity and the vertical component of the spatial gradient of a reference image is equal to zero. A motion vector of each block obtained from, for example, a MV candidate list may be corrected in units of a pixel, based on a combination of the optical flow equation and Hermite interpolation.</p><p id="p-0522" num="0514">It is to be noted that a motion vector may be derived on the decoder side <b>200</b> using a method other than deriving a motion vector based on a model assuming uniform linear motion. For example, a motion vector may be derived in units of a sub-block based on motion vectors of a plurality of neighboring blocks.</p><p id="p-0523" num="0515"><figref idref="DRAWINGS">FIG. <b>64</b></figref> is a flow chart illustrating one example of a process of inter prediction according to BIO. <figref idref="DRAWINGS">FIG. <b>65</b></figref> is a functional block diagram illustrating one example of a functional configuration of inter predictor <b>126</b> which may perform inter prediction according to BIO.</p><p id="p-0524" num="0516">As illustrated in <figref idref="DRAWINGS">FIG. <b>65</b></figref>, inter predictor <b>126</b> includes, for example, memory <b>126</b><i>a</i>, interpolated image deriver <b>126</b><i>b</i>, gradient image deriver <b>126</b><i>c</i>, optical flow deriver <b>126</b><i>d</i>, correction value deriver <b>126</b><i>e</i>, and prediction image corrector <b>126</b><i>f</i>. It is to be noted that memory <b>126</b><i>a </i>may be frame memory <b>122</b>.</p><p id="p-0525" num="0517">Inter predictor <b>126</b> derives two motion vectors (M<sub>0</sub>, M<sub>1</sub>), using two reference pictures (Ref<sub>0</sub>, Ref<sub>1</sub>) different from the picture (Cur Pic) including a current block. Inter predictor <b>126</b> then derives a prediction image for the current block using the two motion vectors (M<sub>0</sub>, M<sub>1</sub>) (Step Sy_<b>1</b>). It is to be noted that motion vector M<sub>0 </sub>is motion vector (MV<sub>x0</sub>, MV<sub>y0</sub>) corresponding to reference picture Ref<sub>0</sub>, and motion vector M<sub>1 </sub>is motion vector (MV<sub>x1</sub>, MV<sub>y1</sub>) corresponding to reference picture Ref<sub>1</sub>.</p><p id="p-0526" num="0518">Next, interpolated image deriver <b>126</b><i>b </i>derives interpolated image I<sup>0 </sup>for the current block, using motion vector M<sub>0 </sub>and reference picture L<sub>0 </sub>by referring to memory <b>126</b><i>a</i>. Next, interpolated image deriver <b>126</b><i>b </i>derives interpolated image I<sup>1 </sup>for the current block, using motion vector M<sub>1 </sub>and reference picture L<sub>1 </sub>by referring to memory <b>126</b><i>a </i>(Step Sy_<b>2</b>). Here, interpolated image I<sup>0 </sup>is an image included in reference picture Ref<sub>0 </sub>and to be derived for the current block, and interpolated image I<sup>1 </sup>is an image included in reference picture Ref<sub>1 </sub>and to be derived for the current block. Each of interpolated image I<sup>0 </sup>and interpolated image I<sup>1 </sup>may be the same in size as the current block. Alternatively, each of interpolated image I<sup>0 </sup>and interpolated image I<sup>1 </sup>may be an image larger than the current block. Furthermore, interpolated image I<sup>0 </sup>and interpolated image I<sup>1 </sup>may include a prediction image obtained by using motion vectors (M<sub>0</sub>, M<sub>1</sub>) and reference pictures (L<sub>0</sub>, L<sub>1</sub>) and applying a motion compensation filter.</p><p id="p-0527" num="0519">In addition, gradient image deriver <b>126</b><i>c </i>derives gradient images (Ix<sup>0</sup>, Ix<sup>1</sup>, Iy<sup>0</sup>, Iy<sup>1</sup>) of the current block, from interpolated image I<sup>0 </sup>and interpolated image I<sup>1 </sup>(Step Sy_<b>3</b>). It is to be noted that the gradient images in the horizontal direction are (Ix<sup>0</sup>, Ix<sup>1</sup>), and the gradient images in the vertical direction are (Iy<sup>0</sup>, Iy<sup>1</sup>). Gradient image deriver <b>126</b><i>c </i>may derive each gradient image by, for example, applying a gradient filter to the interpolated images. The gradient image may indicate the amount of spatial change in pixel value along the horizontal direction, along the vertical direction, or both.</p><p id="p-0528" num="0520">Next, optical flow deriver <b>126</b><i>d </i>derives, for each sub-block of the current block, an optical flow (vx, vy) which is a velocity vector, using the interpolated images (I<sup>0</sup>, I<sup>1</sup>) and the gradient images (Ix<sup>0</sup>, Ix<sup>1</sup>, Iy<sup>0</sup>, Iy<sup>1</sup>) (Step Sy_<b>4</b>). The optical flow indicates coefficients for correcting the amount of spatial pixel movement, and may be referred to as a local motion estimation value, a corrected motion vector, or a corrected weighting vector. As one example, a sub-block may be 4&#xd7;4 pixel sub-CU. It is to be noted that the optical flow derivation may be performed for each pixel unit, or the like, instead of being performed for each sub-block.</p><p id="p-0529" num="0521">Next, inter predictor <b>126</b> corrects a prediction image for the current block using the optical flow (vx, vy). For example, correction value deriver <b>126</b><i>e </i>derives a correction value for the value of a pixel included in a current block, using the optical flow (vx, vy) (Step Sy_<b>5</b>). Prediction image corrector <b>126</b><i>f </i>may then correct the prediction image for the current block using the correction value (Step Sy_<b>6</b>). It is to be noted that the correction value may be derived in units of a pixel, or may be derived in units of a plurality of pixels or in units of a sub-block.</p><p id="p-0530" num="0522">It is to be noted that the BIO process flow is not limited to the process disclosed in <figref idref="DRAWINGS">FIG. <b>64</b></figref>. For example, only part of the processes disclosed in <figref idref="DRAWINGS">FIG. <b>64</b></figref> may be performed, or a different process may be added or used as a replacement, or the processes may be executed in a different processing order, etc.</p><heading id="h-0055" level="2">[Motion Compensation&#x3e;LIC]</heading><p id="p-0531" num="0523">Next, one example of a mode for generating a prediction image (prediction) using a local illumination compensation (LIC) process is described.</p><p id="p-0532" num="0524"><figref idref="DRAWINGS">FIG. <b>66</b>A</figref> is a conceptual diagram for illustrating one example of process of a prediction image generation method using a luminance correction process performed by LIC. <figref idref="DRAWINGS">FIG. <b>66</b>B</figref> is a flow chart illustrating one example of a process of prediction image generation method using the LIC.</p><p id="p-0533" num="0525">First, inter predictor <b>126</b> derives a MV from an encoded reference picture, and obtains a reference image corresponding to the current block (Step Sz_<b>1</b>).</p><p id="p-0534" num="0526">Next, inter predictor <b>126</b> extracts, for the current block, information indicating how the luma value has changed between the current block and the reference picture (Step Sz_<b>2</b>). This extraction is performed based on the luma pixel values of the encoded left neighboring reference region (surrounding reference region) and the encoded upper neighboring reference region (surrounding reference region) in the current picture, and the luma pixel values at the corresponding positions in the reference picture specified by the derived MVs. Inter predictor <b>126</b> calculates a luminance correction parameter, using the information indicating how the luma value has changed (Step Sz_<b>3</b>).</p><p id="p-0535" num="0527">Inter predictor <b>126</b> generates a prediction image for the current block by performing a luminance correction process in which the luminance correction parameter is applied to the reference image in the reference picture specified by the MV (Step Sz_<b>4</b>). In other words, the prediction image which is the reference image in the reference picture specified by the MV is subjected to the correction based on the luminance correction parameter. In this correction, luminance may be corrected, or chrominance may be corrected, or both. In other words, a chrominance correction parameter may be calculated using information indicating how chrominance has changed, and a chrominance correction process may be performed.</p><p id="p-0536" num="0528">It is to be noted that the shape of the surrounding reference region illustrated in <figref idref="DRAWINGS">FIG. <b>66</b>A</figref> is one example; another shape may be used.</p><p id="p-0537" num="0529">Moreover, although the process in which a prediction image is generated from a single reference picture has been described here, cases in which a prediction image is generated from a plurality of reference pictures can be described in the same manner. The prediction image may be generated after performing a luminance correction process of the reference images obtained from the reference pictures in the same manner as described above.</p><p id="p-0538" num="0530">One example of a method for determining whether to apply LIC is a method for using a lic_flag which is a signal indicating whether to apply the LIC. As one specific example, encoder <b>100</b> determines whether the current block belongs to a region having a luminance change. Encoder <b>100</b> sets the lic_flag to a value of &#x201c;1&#x201d; when the block belongs to a region having a luminance change and applies LIC when encoding, and sets the lic_flag to a value of &#x201c;0&#x201d; when the block does not belong to a region having a luminance change and performs encoding without applying LIC. Decoder <b>200</b> may decode the lic_flag written in the stream and decode the current block by switching between application and non-application of LIC in accordance with the flag value.</p><p id="p-0539" num="0531">One example of a different method of determining whether to apply a LIC process is a determining method in accordance with whether a LIC process has been applied to a surrounding block. As one specific example, when a current block has been processed in merge mode, inter predictor <b>126</b> determines whether an encoded surrounding block selected in MV derivation in merge mode has been encoded using LIC. Inter predictor <b>126</b> performs encoding by switching between application and non-application of LIC according to the result. It is to be noted that, also in this example, the same processes are applied in processes at the decoder <b>200</b> side.</p><p id="p-0540" num="0532">The luminance correction (LIC) process has been described with reference to <figref idref="DRAWINGS">FIGS. <b>66</b>A and <b>66</b>B</figref>, and is further described below.</p><p id="p-0541" num="0533">First, inter predictor <b>126</b> derives a MV for obtaining a reference image corresponding to a current block to be encoded from a reference picture which is an encoded picture.</p><p id="p-0542" num="0534">Next, inter predictor <b>126</b> extracts information indicating how the luma value of the reference picture has been changed to the luma value of the current picture, using the luma pixel values of encoded surrounding reference regions which neighbor to the left of and above the current block and the luma values in the corresponding positions in the reference pictures specified by MVs, and calculates a luminance correction parameter. For example, it is assumed that the luma pixel value of a given pixel in the surrounding reference region in the current picture is p<b>0</b>, and that the luma pixel value of the pixel corresponding to the given pixel in the surrounding reference region in the reference picture is p<b>1</b>. Inter predictor <b>126</b> calculates coefficients A and B for optimizing A&#xd7;p<b>1</b>+B=p<b>0</b> as the luminance correction parameter for a plurality of pixels in the surrounding reference region.</p><p id="p-0543" num="0535">Next, inter predictor <b>126</b> performs a luminance correction process using the luminance correction parameter for the reference image in the reference picture specified by the MV, to generate a prediction image for the current block. For example, it is assumed that the luma pixel value in the reference image is p<b>2</b>, and that the luminance-corrected luma pixel value of the prediction image is p<b>3</b>. Inter predictor <b>126</b> generates the prediction image after being subjected to the luminance correction process by calculating A&#xd7;p<b>2</b>+B=p<b>3</b> for each of the pixels in the reference image.</p><p id="p-0544" num="0536">For example, a region having a determined number of pixels extracted from each of an upper neighboring pixel and a left neighboring pixel may be used as a surrounding reference region. In addition, the surrounding reference region is not limited to a region which neighbors the current block, and may be a region which does not neighbor the current block. In the example illustrated in <figref idref="DRAWINGS">FIG. <b>66</b>A</figref>, the surrounding reference region in the reference picture may be a region specified by another MV in a current picture, from a surrounding reference region in the current picture. For example, the other MV may be a MV in a surrounding reference region in the current picture.</p><p id="p-0545" num="0537">Although operations performed by encoder <b>100</b> have been described here, it is to be noted that decoder <b>200</b> performs similar operations.</p><p id="p-0546" num="0538">It is to be noted that LIC may be applied not only to luma but also to chroma. At this time, a correction parameter may be derived individually for each of Y, Cb, and Cr, or a common correction parameter may be used for any of Y, Cb, and Cr.</p><p id="p-0547" num="0539">In addition, the LIC process may be applied in units of a sub-block. For example, a correction parameter may be derived using a surrounding reference region in a current sub-block and a surrounding reference region in a reference sub-block in a reference picture specified by a MV of the current sub-block.</p><heading id="h-0056" level="2">[Prediction Controller]</heading><p id="p-0548" num="0540">Prediction controller <b>128</b> selects one of an intra prediction signal (an image or a signal output from intra predictor <b>124</b>) and an inter prediction signal (an image or a signal output from inter predictor <b>126</b>), and outputs the selected prediction image to subtractor <b>104</b> and adder <b>116</b> as a prediction signal.</p><heading id="h-0057" level="2">[Prediction Parameter Generator]</heading><p id="p-0549" num="0541">Prediction parameter generator <b>130</b> may output information related to intra prediction, inter prediction, selection of a prediction image in prediction controller <b>128</b>, etc. as a prediction parameter to entropy encoder <b>110</b>. Entropy encoder <b>110</b> may generate a stream, based on the prediction parameter which is input from prediction parameter generator <b>130</b> and quantized coefficients which are input from quantizer <b>108</b>. The prediction parameter may be used in decoder <b>200</b>. Decoder <b>200</b> may receive and decode the stream, and perform the same processes as the prediction processes performed by intra predictor <b>124</b>, inter predictor <b>126</b>, and prediction controller <b>128</b>. The prediction parameter may include, for example, (i) a selection prediction signal (for example, a MV, a prediction type, or a prediction mode used by intra predictor <b>124</b> or inter predictor <b>126</b>), or (ii) an optional index, a flag, or a value which is based on a prediction process performed in each of intra predictor <b>124</b>, inter predictor <b>126</b>, and prediction controller <b>128</b>, or which indicates the prediction process.</p><heading id="h-0058" level="2">[Decoder]</heading><p id="p-0550" num="0542">Next, decoder <b>200</b> capable of decoding a stream output from encoder <b>100</b> described above is described. <figref idref="DRAWINGS">FIG. <b>67</b></figref> is a block diagram illustrating a functional configuration of decoder <b>200</b> according to this embodiment. Decoder <b>200</b> is an apparatus which decodes a stream that is an encoded image in units of a block.</p><p id="p-0551" num="0543">As illustrated in <figref idref="DRAWINGS">FIG. <b>67</b></figref>, decoder <b>200</b> includes entropy decoder <b>202</b>, inverse quantizer <b>204</b>, inverse transformer <b>206</b>, adder <b>208</b>, block memory <b>210</b>, loop filter <b>212</b>, frame memory <b>214</b>, intra predictor <b>216</b>, inter predictor <b>218</b>, prediction controller <b>220</b>, prediction parameter generator <b>222</b>, and splitting determiner <b>224</b>. It is to be noted that intra predictor <b>216</b> and inter predictor <b>218</b> are configured as part of a prediction executor.</p><heading id="h-0059" level="2">[Mounting Example of Decoder]</heading><p id="p-0552" num="0544"><figref idref="DRAWINGS">FIG. <b>68</b></figref> is a functional block diagram illustrating a mounting example of decoder <b>200</b>. Decoder <b>200</b> includes processor b<b>1</b> and memory b<b>2</b>. For example, the plurality of constituent elements of decoder <b>200</b> illustrated in <figref idref="DRAWINGS">FIG. <b>67</b></figref> are mounted on processor b<b>1</b> and memory b<b>2</b> illustrated in <figref idref="DRAWINGS">FIG. <b>68</b></figref>.</p><p id="p-0553" num="0545">Processor b<b>1</b> is circuitry which performs information processing and is coupled to memory b<b>2</b>. For example, processor b<b>1</b> is a dedicated or general electronic circuit which decodes a stream. Processor b<b>1</b> may be a processor such as a CPU. In addition, processor b<b>1</b> may be an aggregate of a plurality of electronic circuits. In addition, for example, processor b<b>1</b> may take the roles of two or more constituent elements other than a constituent element for storing information out of the plurality of constituent elements of decoder <b>200</b> illustrated in <figref idref="DRAWINGS">FIG. <b>67</b></figref>, etc.</p><p id="p-0554" num="0546">Memory b<b>2</b> is dedicated or general memory for storing information that is used by processor b<b>1</b> to decode a stream. Memory b<b>2</b> may be electronic circuitry, and may be connected to processor b<b>1</b>. In addition, memory b<b>2</b> may be included in processor b<b>1</b>. In addition, memory b<b>2</b> may be an aggregate of a plurality of electronic circuits. In addition, memory b<b>2</b> may be a magnetic disc, an optical disc, or the like, or may be represented as a storage, a recording medium, or the like. In addition, memory b<b>2</b> may be a non-volatile memory, or a volatile memory.</p><p id="p-0555" num="0547">For example, memory b<b>2</b> may store an image or a stream. In addition, memory b<b>2</b> may store a program for causing processor b<b>1</b> to decode a stream.</p><p id="p-0556" num="0548">In addition, for example, memory b<b>2</b> may take the roles of two or more constituent elements for storing information out of the plurality of constituent elements of decoder <b>200</b> illustrated in <figref idref="DRAWINGS">FIG. <b>67</b></figref>, etc. More specifically, memory b<b>2</b> may take the roles of block memory <b>210</b> and frame memory <b>214</b> illustrated in <figref idref="DRAWINGS">FIG. <b>67</b></figref>. More specifically, memory b<b>2</b> may store a reconstructed image (specifically, a reconstructed block, a reconstructed picture, or the like).</p><p id="p-0557" num="0549">It is to be noted that, in decoder <b>200</b>, not all of the plurality of constituent elements illustrated in <figref idref="DRAWINGS">FIG. <b>67</b></figref>, etc. may be implemented, and not all the processes described herein may be performed. Part of the constituent elements indicated in <figref idref="DRAWINGS">FIG. <b>67</b></figref>, etc. may be included in another device, or part of the processes described herein may be performed by another device.</p><p id="p-0558" num="0550">Hereinafter, an overall flow of the processes performed by decoder <b>200</b> is described, and then each of the constituent elements included in decoder <b>200</b> is described. It is to be noted that, some of the constituent elements included in decoder <b>200</b> perform the same processes as performed by some of encoder <b>100</b>, and thus the same processes are not repeatedly described in detail. For example, inverse quantizer <b>204</b>, inverse transformer <b>206</b>, adder <b>208</b>, block memory <b>210</b>, frame memory <b>214</b>, intra predictor <b>216</b>, inter predictor <b>218</b>, prediction controller <b>220</b>, and loop filter <b>212</b> included in decoder <b>200</b> perform similar processes as performed by inverse quantizer <b>112</b>, inverse transformer <b>114</b>, adder <b>116</b>, block memory <b>118</b>, frame memory <b>122</b>, intra predictor <b>124</b>, inter predictor <b>126</b>, prediction controller <b>128</b>, and loop filter <b>120</b> included in decoder <b>200</b>, respectively.</p><heading id="h-0060" level="2">[Overall Flow of Decoding Process]</heading><p id="p-0559" num="0551"><figref idref="DRAWINGS">FIG. <b>69</b></figref> is a flow chart illustrating one example of an overall decoding process performed by decoder <b>200</b>.</p><p id="p-0560" num="0552">First, splitting determiner <b>224</b> in decoder <b>200</b> determines a splitting pattern of each of a plurality of fixed-size blocks (128&#xd7;128 pixels) included in a picture, based on a parameter which is input from entropy decoder <b>202</b> (Step Sp_<b>1</b>). This splitting pattern is a splitting pattern selected by encoder <b>100</b>. Decoder <b>200</b> then performs processes of Step Sp_<b>2</b> to Sp_<b>6</b> for each of a plurality of blocks of the splitting pattern.</p><p id="p-0561" num="0553">Entropy decoder <b>202</b> decodes (specifically, entropy decodes) encoded quantized coefficients and a prediction parameter of a current block (Step Sp_<b>2</b>).</p><p id="p-0562" num="0554">Next, inverse quantizer <b>204</b> performs inverse quantization of the plurality of quantized coefficients and inverse transformer <b>206</b> performs inverse transform of the result, to restore prediction residuals (that is, a difference block) (Step Sp_<b>3</b>).</p><p id="p-0563" num="0555">Next, the prediction executor including all or part of intra predictor <b>216</b>, inter predictor <b>218</b>, and prediction controller <b>220</b> generates a prediction signal of the current block (Step Sp_<b>4</b>).</p><p id="p-0564" num="0556">Next, adder <b>208</b> adds the prediction image to a prediction residual to generate a reconstructed image (also referred to as a decoded image block) of the current block (Step Sp_<b>5</b>).</p><p id="p-0565" num="0557">When the reconstructed image is generated, loop filter <b>212</b> performs filtering of the reconstructed image (Step Sp_<b>6</b>).</p><p id="p-0566" num="0558">Decoder <b>200</b> then determines whether decoding of the entire picture has been finished (Step Sp_<b>7</b>). When determining that the decoding has not yet been finished (No in Step Sp_<b>7</b>), decoder <b>200</b> repeats to the processes starting with Step Sp_<b>1</b>.</p><p id="p-0567" num="0559">It is to be noted that the processes of these Steps Sp_<b>1</b> to Sp_<b>7</b> may be performed sequentially by decoder <b>200</b>, or two or more of the processes may be performed in parallel. The processing order of the two or more of the processes may be modified.</p><heading id="h-0061" level="2">[Splitting Determiner]</heading><p id="p-0568" num="0560"><figref idref="DRAWINGS">FIG. <b>70</b></figref> is a conceptual diagram for illustrating a relationship between splitting determiner <b>224</b> and other constituent elements in an embodiment. Splitting determiner <b>224</b> may perform the following processes as examples.</p><p id="p-0569" num="0561">For example, splitting determiner <b>224</b> collects block information from block memory <b>210</b> or frame memory <b>214</b>, and furthermore obtains a parameter from entropy decoder <b>202</b>. Splitting determiner <b>224</b> may then determine the splitting pattern of a fixed-size block, based on the block information and the parameter. Splitting determiner <b>224</b> may then output the information indicating the determined splitting pattern to inverse transformer <b>206</b>, intra predictor <b>216</b>, and inter predictor <b>218</b>. Inverse transformer <b>206</b> may perform inverse transform of transform coefficients, based on the splitting pattern indicated by the information from splitting determiner <b>224</b>. Intra predictor <b>216</b> and inter predictor <b>218</b> may generate a prediction image, based on the splitting pattern indicated by the information from splitting determiner <b>224</b>.</p><heading id="h-0062" level="2">[Entropy Decoder]</heading><p id="p-0570" num="0562"><figref idref="DRAWINGS">FIG. <b>71</b></figref> is a block diagram illustrating one example of a functional configuration of entropy decoder <b>202</b>.</p><p id="p-0571" num="0563">Entropy decoder <b>202</b> generates quantized coefficients, a prediction parameter, and a parameter related to a splitting pattern, by entropy decoding the stream. For example, CABAC is used in the entropy decoding. More specifically, entropy decode <b>202</b> includes, for example, binary arithmetic decoder <b>202</b><i>a</i>, context controller <b>202</b><i>b</i>, and debinarizer <b>202</b><i>c</i>. Binary arithmetic decoder <b>202</b><i>a </i>arithmetically decodes the stream using a context value derived by context controller <b>202</b><i>b </i>to a binary signal. Context controller <b>202</b><i>b </i>derives a context value according to a feature or a surrounding state of a syntax element, that is an occurrence probability of a binary signal, in the same manner as performed by context controller <b>110</b><i>b </i>of encoder <b>100</b>. Debinarizer <b>202</b><i>c </i>performs debinarization for transforming the binary signal output from binary arithmetic decoder <b>202</b><i>a </i>to a multi-level signal indicating quantized coefficients as described above. This binarization may be performed according to the binarization method described above.</p><p id="p-0572" num="0564">With this, entropy decoder <b>202</b> outputs quantized coefficients of each block to inverse quantizer <b>204</b>. Entropy decoder <b>202</b> may output a prediction parameter included in a stream (see <figref idref="DRAWINGS">FIG. <b>1</b></figref>) to intra predictor <b>216</b>, inter predictor <b>218</b>, and prediction controller <b>220</b>. Intra predictor <b>216</b>, inter predictor <b>218</b>, and prediction controller <b>220</b> are capable of executing the same prediction processes as those performed by intra predictor <b>124</b>, inter predictor <b>126</b>, and prediction controller <b>128</b> at the encoder <b>100</b> side.</p><p id="p-0573" num="0565"><figref idref="DRAWINGS">FIG. <b>72</b></figref> is a conceptual diagram for illustrating a flow of an example CABAC process in entropy decoder <b>202</b>.</p><p id="p-0574" num="0566">First, initialization is performed in CABAC in entropy decoder <b>202</b>. In the initialization, initialization in binary arithmetic decoder <b>202</b><i>a </i>and setting of an initial context value are performed. Binary arithmetic decoder <b>202</b><i>a </i>and debinarizer <b>202</b><i>c </i>then execute arithmetic decoding and debinarization of, for example, encoded data of a CTU. At this time, context controller <b>202</b><i>b </i>updates the context value each time arithmetic decoding is performed. Context controller <b>202</b><i>b </i>then saves the context value as a post process. The saved context value is used, for example, to initialize the context value for the next CTU.</p><heading id="h-0063" level="2">[Inverse Quantizer]</heading><p id="p-0575" num="0567">Inverse quantizer <b>204</b> inverse quantizes quantized coefficients of a current block which are inputs from entropy decoder <b>202</b>. More specifically, inverse quantizer <b>204</b> inverse quantizes the quantized coefficients of the current block, based on quantization parameters corresponding to the quantized coefficients. Inverse quantizer <b>204</b> then outputs the inverse quantized transform coefficients (that are transform coefficients) of the current block to inverse transformer <b>206</b>.</p><p id="p-0576" num="0568"><figref idref="DRAWINGS">FIG. <b>73</b></figref> is a block diagram illustrating one example of a functional configuration of inverse quantizer <b>204</b>.</p><p id="p-0577" num="0569">Inverse quantizer <b>204</b> includes, for example, quantization parameter generator <b>204</b><i>a</i>, predicted quantization parameter generator <b>204</b><i>b</i>, quantization parameter storage <b>204</b><i>d</i>, and inverse quantization executor <b>204</b><i>e. </i></p><p id="p-0578" num="0570"><figref idref="DRAWINGS">FIG. <b>74</b></figref> is a flow chart illustrating one example of a process of inverse quantization performed by inverse quantizer <b>204</b>.</p><p id="p-0579" num="0571">Inverse quantizer <b>204</b> may perform an inverse quantization process as one example for each CU based on the flow illustrated in <figref idref="DRAWINGS">FIG. <b>74</b></figref>. More specifically, quantization parameter generator <b>204</b><i>a </i>determines whether to perform inverse quantization (Step Sv_<b>11</b>). Here, when determining to perform inverse quantization (Yes in Step Sv_<b>11</b>), quantization parameter generator <b>204</b><i>a </i>obtains a difference quantization parameter for the current block from entropy decoder <b>202</b> (Step Sv_<b>12</b>).</p><p id="p-0580" num="0572">Next, predicted quantization parameter generator <b>204</b><i>b </i>then obtains a quantization parameter for a processing unit different from the current block from quantization parameter storage <b>204</b><i>d </i>(Step Sv_<b>13</b>). Predicted quantization parameter generator <b>204</b><i>b </i>generates a predicted quantization parameter of the current block based on the obtained quantization parameter (Step Sv_<b>14</b>).</p><p id="p-0581" num="0573">Quantization parameter generator <b>204</b><i>a </i>then generates a quantization parameter for the current block based on the difference quantization parameter for the current block obtained from entropy decoder <b>202</b> and the predicted quantization parameter for the current block generated by predicted quantization parameter generator <b>204</b><i>b </i>(Step Sv_<b>15</b>). For example, the difference quantization parameter for the current block obtained from entropy decoder <b>202</b> and the predicted quantization parameter for the current block generated by predicted quantization parameter generator <b>204</b><i>b </i>may be added together to generate the quantization parameter for the current block. In addition, quantization parameter generator <b>204</b><i>a </i>stores the quantization parameter for the current block in quantization parameter storage <b>204</b><i>d </i>(Step Sv_<b>16</b>).</p><p id="p-0582" num="0574">Next, inverse quantization executor <b>204</b><i>e </i>inverse quantizes the quantized coefficients of the current block into transform coefficients, using the quantization parameter generated in Step Sv_<b>15</b> (Step Sv_<b>17</b>).</p><p id="p-0583" num="0575">It is to be noted that the difference quantization parameter may be decoded at the bit sequence level, picture level, slice level, brick level, or CTU level. In addition, the initial value of the quantization parameter may be decoded at the sequence level, picture level, slice level, brick level, or CTU level. At this time, the quantization parameter may be generated using the initial value of the quantization parameter and the difference quantization parameter.</p><p id="p-0584" num="0576">It is to be noted that inverse quantizer <b>204</b> may include a plurality of inverse quantizers, and may inverse quantize the quantized coefficients using an inverse quantization method selected from a plurality of inverse quantization methods.</p><heading id="h-0064" level="2">[Inverse Transformer]</heading><p id="p-0585" num="0577">Inverse transformer <b>206</b> restores prediction residuals by inverse transforming the transform coefficients which are inputs from inverse quantizer <b>204</b>.</p><p id="p-0586" num="0578">For example, when information parsed from a stream indicates that EMT or AMT is to be applied (for example, when an AMT flag is true), inverse transformer <b>206</b> inverse transforms the transform coefficients of the current block based on information indicating the decoded transform type.</p><p id="p-0587" num="0579">Moreover, for example, when information parsed from a stream indicates that NSST is to be applied, inverse transformer <b>206</b> applies a secondary inverse transform to the transform coefficients.</p><p id="p-0588" num="0580"><figref idref="DRAWINGS">FIG. <b>75</b></figref> is a flow chart illustrating one example of a process performed by inverse transformer <b>206</b>.</p><p id="p-0589" num="0581">For example, inverse transformer <b>206</b> determines whether information indicating that no orthogonal transform is performed is present in a stream (Step St_<b>11</b>). Here, when determining that no such information is present (No in Step St_<b>11</b>) (e.g.: the absence of any indication as to whether an orthogonal transform is performed; the presence of an indication that an orthogonal transform is to be performed); inverse transformer <b>206</b> obtains the information indicating the transform type decoded by entropy decoder <b>202</b> (Step St_<b>12</b>). Next, based on the information, inverse transformer <b>206</b> determines the transform type used for the orthogonal transform in encoder <b>100</b> (Step St_<b>13</b>). Inverse transformer <b>206</b> then performs inverse orthogonal transform using the determined transform type (Step St_<b>14</b>). As illustrated in <figref idref="DRAWINGS">FIG. <b>75</b></figref>, when determining that information indicating that no orthogonal transform is performed is present (Yes in Step St_<b>11</b>) (e.g., an express indication that no orthogonal transform is performed; the absence of an indication an orthogonal transform is performed), no orthogonal transform is performed.</p><p id="p-0590" num="0582"><figref idref="DRAWINGS">FIG. <b>76</b></figref> is a flow chart illustrating one example of a process performed by inverse transformer <b>206</b>.</p><p id="p-0591" num="0583">For example, inverse transformer <b>206</b> determines whether a transform size is smaller than or equal to a determined value (Step Su_<b>11</b>). The determined value may be predetermined. Here, when determining that the transform size is smaller than or equal to a determined value (Yes in Step Su_<b>11</b>), inverse transformer <b>206</b> obtains, from entropy decoder <b>202</b>, information indicating which transform type has been used by encoder <b>100</b> among the at least one transform type included in the first transform type group (Step Su_<b>12</b>). It is to be noted that such information is decoded by entropy decoder <b>202</b> and output to inverse transformer <b>206</b>.</p><p id="p-0592" num="0584">Based on the information, inverse transformer <b>206</b> determines the transform type used for the orthogonal transform in encoder <b>100</b> (Step Su_<b>13</b>). Inverse transformer <b>206</b> then inverse orthogonal transforms the transform coefficients of the current block using the determined transform type (Step Su_<b>14</b>). When determining that a transform size is not smaller than or equal to the determined value (No in Step Su_<b>11</b>), inverse transformer <b>206</b> inverse transforms the transform coefficients of the current block using the second transform type group (Step Su_<b>15</b>).</p><p id="p-0593" num="0585">It is to be noted that the inverse orthogonal transform by inverse transformer <b>206</b> may be performed according to the flow illustrated in <figref idref="DRAWINGS">FIG. <b>75</b></figref> or <figref idref="DRAWINGS">FIG. <b>76</b></figref> for each TU as one example. In addition, inverse orthogonal transform may be performed by using a defined transform type without decoding information indicating a transform type used for orthogonal transform. The defined transform type may be a predefined transform type or a default transform type. In addition, the transform type may be specifically DST<b>7</b>, DCT<b>8</b>, or the like. In an inverse orthogonal transform, an inverse transform basis function corresponding to the transform type is used.</p><heading id="h-0065" level="2">[Adder]</heading><p id="p-0594" num="0586">Adder <b>208</b> reconstructs the current block by adding a prediction residual which is an input from inverse transformer <b>206</b> and a prediction image which is an input from prediction controller <b>220</b>. In other words, a reconstructed image of the current block is generated. Adder <b>208</b> then outputs the reconstructed image of the current block to block memory <b>210</b> and loop filter <b>212</b>.</p><heading id="h-0066" level="2">[Block Memory]</heading><p id="p-0595" num="0587">Block memory <b>210</b> is storage for storing a block which is included in a current picture and may be referred to in intra prediction. More specifically, block memory <b>210</b> stores a reconstructed image output from adder <b>208</b>.</p><heading id="h-0067" level="2">[Loop Filter]</heading><p id="p-0596" num="0588">Loop filter <b>212</b> applies a loop filter to the reconstructed image generated by adder <b>208</b>, and outputs the filtered reconstructed image to frame memory <b>214</b> and provides an output of the decoder <b>200</b>, e.g., and output to a display device, etc.</p><p id="p-0597" num="0589">When information indicating ON or OFF of an ALF parsed from a stream indicates that an ALF is ON, one filter from among a plurality of filters may be selected, for example, based on the direction and activity of local gradients, and the selected filter is applied to the reconstructed image.</p><p id="p-0598" num="0590"><figref idref="DRAWINGS">FIG. <b>77</b></figref> is a block diagram illustrating one example of a functional configuration of loop filter <b>212</b>. It is to be noted that loop filter <b>212</b> has a configuration similar to the configuration of loop filter <b>120</b> of encoder <b>100</b>.</p><p id="p-0599" num="0591">For example, as illustrated in <figref idref="DRAWINGS">FIG. <b>77</b></figref>, loop filter <b>212</b> includes deblocking filter executor <b>212</b><i>a</i>, SAO executor <b>212</b><i>b</i>, and ALF executor <b>212</b><i>c</i>. Deblocking filter executor <b>212</b><i>a </i>performs a deblocking filter process on the reconstructed image. SAO executor <b>212</b><i>b </i>performs a SAO process on the reconstructed image after being subjected to the deblocking filter process. ALF executor <b>212</b><i>c </i>performs an ALF process on the reconstructed image after being subjected to the SAO process. It is to be noted that loop filter <b>212</b> does not always need to include all the constituent elements disclosed in <figref idref="DRAWINGS">FIG. <b>77</b></figref>, and may include only part of the constituent elements. In addition, loop filter <b>212</b> may be configured to perform the above processes in a processing order different from the one disclosed in <figref idref="DRAWINGS">FIG. <b>77</b></figref>, may not perform all of the processes illustrated in <figref idref="DRAWINGS">FIG. <b>77</b></figref>, etc.</p><heading id="h-0068" level="2">[Frame Memory]</heading><p id="p-0600" num="0592">Frame memory <b>214</b> is, for example, storage for storing reference pictures for use in inter prediction, and may also be referred to as a frame buffer. More specifically, frame memory <b>214</b> stores a reconstructed image filtered by loop filter <b>212</b>.</p><heading id="h-0069" level="2">[Predictor (Intra Predictor, Inter Predictor, Prediction Controller)]</heading><p id="p-0601" num="0593"><figref idref="DRAWINGS">FIG. <b>78</b></figref> is a flow chart illustrating one example of a process performed by a predictor of decoder <b>200</b>. It is to be noted that the prediction executor may include all or part of the following constituent elements: intra predictor <b>216</b>; inter predictor <b>218</b>; and prediction controller <b>220</b>. The prediction executor includes, for example, intra predictor <b>216</b> and inter predictor <b>218</b>.</p><p id="p-0602" num="0594">The predictor generates a prediction image of a current block (Step Sq_<b>1</b>). This prediction image is also referred to as a prediction signal or a prediction block. It is to be noted that the prediction signal is, for example, an intra prediction signal or an inter prediction signal. More specifically, the predictor generates the prediction image of the current block using a reconstructed image which has been already obtained for another block through generation of a prediction image, restoration of a prediction residual, and addition of a prediction image. The predictor of decoder <b>200</b> generates the same prediction image as the prediction image generated by the predictor of encoder <b>100</b>. In other words, the prediction images are generated according to a method common between the predictors or mutually corresponding methods.</p><p id="p-0603" num="0595">The reconstructed image may be, for example, an image in a reference picture, or an image of a decoded block (that is, the other block described above) in a current picture which is the picture including the current block. The decoded block in the current picture is, for example, a neighboring block of the current block.</p><p id="p-0604" num="0596"><figref idref="DRAWINGS">FIG. <b>79</b></figref> is a flow chart illustrating another example of a process performed by the predictor of decoder <b>200</b>.</p><p id="p-0605" num="0597">The predictor determines either a method or a mode for generating a prediction image (Step Sr_<b>1</b>). For example, the method or mode may be determined based on, for example, a prediction parameter, etc.</p><p id="p-0606" num="0598">When determining a first method as a mode for generating a prediction image, the predictor generates a prediction image according to the first method (Step Sr_<b>2</b><i>a</i>). When determining a second method as a mode for generating a prediction image, the predictor generates a prediction image according to the second method (Step Sr_<b>2</b><i>b</i>). When determining a third method as a mode for generating a prediction image, the predictor generates a prediction image according to the third method (Step Sr_<b>2</b><i>c</i>).</p><p id="p-0607" num="0599">The first method, the second method, and the third method may be mutually different methods for generating a prediction image. Each of the first to third methods may be an inter prediction method, an intra prediction method, or another prediction method. The above-described reconstructed image may be used in these prediction methods.</p><p id="p-0608" num="0600"><figref idref="DRAWINGS">FIGS. <b>80</b>A to <b>80</b>C</figref> (collectively, <figref idref="DRAWINGS">FIG. <b>80</b></figref>) are a flow chart illustrating another example of a process performed by a predictor of decoder <b>200</b>.</p><p id="p-0609" num="0601">The predictor may perform a prediction process according to the flow illustrated in <figref idref="DRAWINGS">FIG. <b>80</b></figref> as one example. It is to be noted that intra block copy illustrated in <figref idref="DRAWINGS">FIG. <b>80</b></figref> is one mode which belongs to inter prediction, and in which a block included in a current picture is referred to as a reference image or a reference block. In other words, a picture different from the current picture is not referred to in intra block copy. In addition, the PCM mode illustrated in <figref idref="DRAWINGS">FIG. <b>80</b></figref> is one mode which belongs to intra prediction, and in which no transform and quantization is performed.</p><heading id="h-0070" level="2">[Intra Predictor]</heading><p id="p-0610" num="0602">Intra predictor <b>216</b> performs intra prediction by referring to a block in a current picture stored in block memory <b>210</b>, based on the intra prediction mode parsed from the stream, to generate a prediction image of a current block (that is, an intra prediction block). More specifically, intra predictor <b>216</b> performs intra prediction by referring to pixel values (for example, luma and/or chroma values) of a block or blocks neighboring the current block to generate an intra prediction image, and then outputs the intra prediction image to prediction controller <b>220</b>.</p><p id="p-0611" num="0603">It is to be noted that when an intra prediction mode in which a luma block is referred to in intra prediction of a chroma block is selected, intra predictor <b>216</b> may predict the chroma component of the current block based on the luma component of the current block.</p><p id="p-0612" num="0604">Moreover, when information parsed from a stream indicates that PDPC is to be applied, intra predictor <b>216</b> corrects intra predicted pixel values based on horizontal/vertical reference pixel gradients.</p><p id="p-0613" num="0605"><figref idref="DRAWINGS">FIG. <b>81</b></figref> is a diagram illustrating one example of a process performed by intra predictor <b>216</b> of decoder <b>200</b>.</p><p id="p-0614" num="0606">Intra predictor <b>216</b> first determines whether an MPM is to be employed. As illustrated in <figref idref="DRAWINGS">FIG. <b>81</b></figref>, intra predictor <b>216</b> determines whether an MPM flag indicating <b>1</b> is present in the stream (Step Sw_<b>11</b>). Here, when determining that the MPM flag indicating <b>1</b> is present (Yes in Step Sw_<b>11</b>), intra predictor <b>216</b> obtains, from entropy decoder <b>202</b>, information indicating the intra prediction mode selected in encoder <b>100</b> among MPMs. It is to be noted that such information is decoded by entropy decoder <b>202</b> and output to intra predictor <b>216</b>. Next, intra predictor <b>216</b> determines the MPMs (Step Sw_<b>13</b>). MPMs include, for example, six intra prediction modes. Intra predictor <b>216</b> then determines the intra prediction mode which is included in a plurality of intra prediction modes included in the MPMs and is indicated by the information obtained in Step Sw_<b>12</b> (Step Sw_<b>14</b>).</p><p id="p-0615" num="0607">When determining that no MPM flag indicating <b>1</b> is present (No in Step Sw_<b>11</b>), intra predictor <b>216</b> obtains information indicating the intra prediction mode selected in encoder <b>100</b> (Step Sw_<b>15</b>). In other words, intra predictor <b>216</b> obtains, from entropy decoder <b>202</b>, information indicating the intra prediction mode selected in encoder <b>100</b> from among the at least one intra prediction mode which is not included in the MPMs. It is to be noted that such information is decoded by entropy decoder <b>202</b> and output to intra predictor <b>216</b>. Intra predictor <b>216</b> then determines the intra prediction mode which is not included in a plurality of intra prediction modes included in the MPMs and is indicated by the information obtained in Step Sw_<b>15</b> (Step Sw_<b>17</b>).</p><p id="p-0616" num="0608">Intra predictor <b>216</b> generates a prediction image according to the intra prediction mode determined in Step Sw_<b>14</b> or Step Sw_<b>17</b> (Step Sw_<b>18</b>).</p><heading id="h-0071" level="2">[Inter Predictor]</heading><p id="p-0617" num="0609">Inter predictor <b>218</b> predicts the current block by referring to a reference picture stored in frame memory <b>214</b>. Prediction is performed in units of a current block or a current sub-block in the current block. It is to be noted that the sub-block is included in the block and is a unit smaller than the block. The size of the sub-block may be 4&#xd7;4 pixels, 8&#xd7;8 pixels, or another size. The size of the sub-block may be switched for a unit such as a slice, brick, picture, etc.</p><p id="p-0618" num="0610">For example, inter predictor <b>218</b> generates an inter prediction image of a current block or a current sub-block by performing motion compensation using motion information (for example, a MV) parsed from a stream (for example, a prediction parameter output from entropy decoder <b>202</b>), and outputs the inter prediction image to prediction controller <b>220</b>.</p><p id="p-0619" num="0611">When the information parsed from the stream indicates that the OBMC mode is to be applied, inter predictor <b>218</b> generates the inter prediction image using motion information of a neighboring block in addition to motion information of the current block obtained through motion estimation.</p><p id="p-0620" num="0612">Moreover, when the information parsed from the stream indicates that the FRUC mode is to be applied, inter predictor <b>218</b> derives motion information by performing motion estimation in accordance with a pattern matching method (e.g., bilateral matching or template matching) parsed from the stream. Inter predictor <b>218</b> then performs motion compensation (prediction) using the derived motion information.</p><p id="p-0621" num="0613">Moreover, when the BIO mode is to be applied, inter predictor <b>218</b> derives a MV based on a model assuming uniform linear motion. In addition, when the information parsed from the stream indicates that the affine mode is to be applied, inter predictor <b>218</b> derives a MV for each sub-block, based on the MVs of a plurality of neighboring blocks.</p><heading id="h-0072" level="2">[MV Derivation Flow]</heading><p id="p-0622" num="0614"><figref idref="DRAWINGS">FIG. <b>82</b></figref> is a flow chart illustrating one example of a process of MV derivation in decoder <b>200</b>.</p><p id="p-0623" num="0615">Inter predictor <b>218</b> determines, for example, whether to decode motion information (for example, a MV). For example, inter predictor <b>218</b> may make the determination according to the prediction mode included in the stream, or may make the determination based on other information included in the stream. Here, when determining to decode motion information, inter predictor <b>218</b> derives a MV for a current block in a mode in which the motion information is decoded. When determining not to decode motion information, inter predictor <b>218</b> derives a MV in a mode in which no motion information is decoded.</p><p id="p-0624" num="0616">Here, MV derivation modes include a normal inter mode, a normal merge mode, a FRUC mode, an affine mode, etc. which are described later. Modes in which motion information is decoded among the modes include the normal inter mode, the normal merge mode, the affine mode (specifically, an affine inter mode and an affine merge mode), etc. It is to be noted that motion information may include not only a MV but also MV predictor selection information which is described later. Modes in which no motion information is decoded include the FRUC mode, etc. Inter predictor <b>218</b> selects a mode for deriving a MV for the current block from the plurality of modes, and derives the MV for the current block using the selected mode.</p><p id="p-0625" num="0617"><figref idref="DRAWINGS">FIG. <b>83</b></figref> is a flow chart illustrating one example of a process of MV derivation in decoder <b>200</b>.</p><p id="p-0626" num="0618">For example, inter predictor <b>218</b> may determine whether to decode a MV difference, that is for example, may make the determination according to the prediction mode included in the stream, or may make the determination based on other information included in the stream. Here, when determining to decode a MV difference, inter predictor <b>218</b> may derive a MV for a current block in a mode in which the MV difference is decoded. In this case, for example, the MV difference included in the stream is decoded as a prediction parameter.</p><p id="p-0627" num="0619">When determining not to decode any MV difference, inter predictor <b>218</b> derives a MV in a mode in which no MV difference is decoded. In this case, no encoded MV difference is included in the stream.</p><p id="p-0628" num="0620">Here, as described above, the MV derivation modes include the normal inter mode, the normal merge mode, the FRUC mode, the affine mode, etc. which are described later. Modes in which a MV difference is encoded among the modes include the normal inter mode and the affine mode (specifically, the affine inter mode), etc. Modes in which no MV difference is encoded include the FRUC mode, the normal merge mode, the affine mode (specifically, the affine merge mode), etc. Inter predictor <b>218</b> selects a mode for deriving a MV for the current block from the plurality of modes, and derives the MV for the current block using the selected mode.</p><heading id="h-0073" level="2">[MV Derivation&#x3e;Normal Inter Mode]</heading><p id="p-0629" num="0621">For example, when information parsed from a stream indicates that the normal inter mode is to be applied, inter predictor <b>218</b> derives a MV based on the information parsed from the stream and performs motion compensation (prediction) using the MV.</p><p id="p-0630" num="0622"><figref idref="DRAWINGS">FIG. <b>84</b></figref> is a flow chart illustrating an example of a process of inter prediction by normal inter mode in decoder <b>200</b>.</p><p id="p-0631" num="0623">Inter predictor <b>218</b> of decoder <b>200</b> performs motion compensation for each block. First, inter predictor <b>218</b> obtains a plurality of MV candidates for a current block based on information such as MVs of a plurality of decoded blocks temporally or spatially surrounding the current block (Step Sg_<b>11</b>). In other words, inter predictor <b>218</b> generates a MV candidate list.</p><p id="p-0632" num="0624">Next, inter predictor <b>218</b> extracts N (an integer of 2 or larger) MV candidates from the plurality of MV candidates obtained in Step Sg_<b>11</b>, as motion vector predictor candidates (also referred to as MV predictor candidates) according to the determined ranks in priority order (Step Sg_<b>12</b>). It is to be noted that the ranks in priority order may be determined in advance for the respective N MV predictor candidates and may be predetermined.</p><p id="p-0633" num="0625">Next, inter predictor <b>218</b> decodes the MV predictor selection information from the input stream, and selects one MV predictor candidate from the N MV predictor candidates as the MV predictor for the current block using the decoded MV predictor selection information (Step Sg_<b>13</b>).</p><p id="p-0634" num="0626">Next, inter predictor <b>218</b> decodes a MV difference from the input stream, and derives a MV for the current block by adding a difference value which is the decoded MV difference and the selected MV predictor (Step Sg_<b>14</b>).</p><p id="p-0635" num="0627">Lastly, inter predictor <b>218</b> generates a prediction image for the current block by performing motion compensation of the current block using the derived MV and the decoded reference picture (Step Sg_<b>15</b>). The processes in Steps Sg_<b>11</b> to Sg_<b>15</b> are executed on each block. For example, when the processes in Steps Sg_<b>11</b> to Sg_<b>15</b> are executed on each of all the blocks in the slice, inter prediction of the slice using the normal inter mode finishes. For example, when the processes in Steps Sg_<b>11</b> to Sg_<b>15</b> are executed on each of all the blocks in the picture, inter prediction of the picture using the normal inter mode finishes. It is to be noted that not all the blocks included in the slice may be subjected to the processes in Steps Sg_<b>11</b> to Sg_<b>15</b>, and inter prediction of the slice using the normal inter mode may finish when part of the blocks are subjected to the processes. This also applies to pictures in Steps Sg_<b>11</b> to Sg_<b>15</b>. Inter prediction of the picture using the normal inter mode may finish when the processes are executed on part of the blocks in the picture.</p><heading id="h-0074" level="2">[MV Derivation&#x3e;Normal Merge Mode]</heading><p id="p-0636" num="0628">For example, when information parsed from a stream indicates that the normal merge mode is to be applied, inter predictor <b>218</b> derives a MV and performs motion compensation (prediction) using the MV.</p><p id="p-0637" num="0629"><figref idref="DRAWINGS">FIG. <b>85</b></figref> is a flow chart illustrating an example of a process of inter prediction by normal merge mode in decoder <b>200</b>.</p><p id="p-0638" num="0630">First, inter predictor <b>218</b> obtains a plurality of MV candidates for a current block based on information such as MVs of a plurality of decoded blocks temporally or spatially surrounding the current block (Step Sh_<b>11</b>). In other words, inter predictor <b>218</b> generates a MV candidate list.</p><p id="p-0639" num="0631">Next, inter predictor <b>218</b> selects one MV candidate from the plurality of MV candidates obtained in Step Sh_<b>11</b>, deriving a MV for the current block (Step Sh_<b>12</b>). More specifically, inter predictor <b>218</b> obtains MV selection information included as a prediction parameter in a stream, and selects the MV candidate identified by the MV selection information as the MV for the current block.</p><p id="p-0640" num="0632">Lastly, inter predictor <b>218</b> generates a prediction image for the current block by performing motion compensation of the current block using the derived MV and the decoded reference picture (Step Sh_<b>13</b>). The processes in Steps Sh_<b>11</b> to Sh_<b>13</b> are executed, for example, on each block. For example, when the processes in Steps Sh_<b>11</b> to Sh_<b>13</b> are executed on each of all the blocks in the slice, inter prediction of the slice using the normal merge mode finishes. In addition, when the processes in Steps Sh_<b>11</b> to Sh_<b>13</b> are executed on each of all the blocks in the picture, inter prediction of the picture using the normal merge mode finishes. It is to be noted that not all the blocks included in the slice are subjected to the processes in Steps Sh_<b>11</b> to Sh_<b>13</b>, and inter prediction of the slice using the normal merge mode may finish when part of the blocks are subjected to the processes. This also applies to pictures in Steps Sh_<b>11</b> to Sh_<b>13</b>. Inter prediction of the picture using the normal merge mode may finish when the processes are executed on part of the blocks in the picture.</p><heading id="h-0075" level="2">[MV Derivation&#x3e;FRUC Mode]</heading><p id="p-0641" num="0633">For example, when information parsed from a stream indicates that the FRUC mode is to be applied, inter predictor <b>218</b> derives a MV in the FRUC mode and performs motion compensation (prediction) using the MV. In this case, the motion information is derived at the decoder <b>200</b> side without being signaled from the encoder <b>100</b> side. For example, decoder <b>200</b> may derive the motion information by performing motion estimation. In this case, decoder <b>200</b> performs motion estimation without using any pixel values in a current block.</p><p id="p-0642" num="0634"><figref idref="DRAWINGS">FIG. <b>86</b></figref> is a flow chart illustrating an example of a process of inter prediction by FRUC mode in decoder <b>200</b>.</p><p id="p-0643" num="0635">First, inter predictor <b>218</b> generates a list indicating MVs of decoded blocks spatially or temporally neighboring the current block by referring to the MVs as MV candidates (the list is a MV candidate list, and may, for example, be used also as a MV candidate list for normal merge mode (Step Si_<b>11</b>). Next, a best MV candidate is selected from the plurality of MV candidates registered in the MV candidate list (Step Si_<b>12</b>). For example, inter predictor <b>218</b> calculates the evaluation value of each MV candidate included in the MV candidate list, and selects one of the MV candidates as the best MV candidate based on the evaluation values. Based on the selected best MV candidates, inter predictor <b>218</b> then derives a MV for the current block (Step Si_<b>14</b>). More specifically, for example, the selected best MV candidates are directly derived as the MV for the current block. In addition, for example, the MV for the current block may be derived using pattern matching in a surrounding region of a position which is included in a reference picture and corresponds to the selected best MV candidate. In other words, estimation using the pattern matching in a reference picture and the evaluation values may be performed in the surrounding region of the best MV candidate, and when there is a MV that yields a better evaluation value, the best MV candidate may be updated to the MV that yields the better evaluation value, and the updated MV may be determined as the final MV for the current block. In an embodiment, updating to a MV that yields a better evaluation value may not be performed.</p><p id="p-0644" num="0636">Lastly, inter predictor <b>218</b> generates a prediction image for the current block by performing motion compensation of the current block using the derived MV and the decoded reference picture (Step Si_<b>15</b>). The processes in Steps Si_<b>11</b> to Si_<b>15</b> are executed, for example, on each block. For example, when the processes in Steps Si_<b>11</b> to Si_<b>15</b> are executed on each of all the blocks in the slice, inter prediction of the slice using the FRUC mode finishes. For example, when the processes in Steps Si_<b>11</b> to Si_<b>15</b> are executed on each of all the blocks in the picture, inter prediction of the picture using the FRUC mode finishes. Each sub-block may be processed similarly to the case of each block.</p><heading id="h-0076" level="2">[MV Derivation&#x3e;FRUC Mode]</heading><p id="p-0645" num="0637">For example, when information parsed from a stream indicates that the affine merge mode is to be applied, inter predictor <b>218</b> derives a MV in the affine merge mode and performs motion compensation (prediction) using the MV.</p><p id="p-0646" num="0638"><figref idref="DRAWINGS">FIG. <b>87</b></figref> is a flow chart illustrating an example of a process of inter prediction by the affine merge mode in decoder <b>200</b>.</p><p id="p-0647" num="0639">In the affine merge mode, first, inter predictor <b>218</b> derives MVs at respective control points for a current block (Step Sk_<b>11</b>). The control points are an upper-left corner point of the current block and an upper-right corner point of the current block as illustrated in <figref idref="DRAWINGS">FIG. <b>46</b>A</figref>, or an upper-left corner point of the current block, an upper-right corner point of the current block, and a lower-left corner point of the current block as illustrated in <figref idref="DRAWINGS">FIG. <b>46</b>B</figref>.</p><p id="p-0648" num="0640">For example, when the MV derivation methods illustrated in <figref idref="DRAWINGS">FIGS. <b>47</b>A to <b>47</b>C</figref> are used, as illustrated in <figref idref="DRAWINGS">FIG. <b>47</b>A</figref>, inter predictor <b>218</b> checks decoded block A (left), block B (upper), block C (upper-right), block D (lower-left), and block E (upper-left) in this order, and identifies the first effective block decoded according to the affine mode. Inter predictor <b>218</b> derives the MV at the control point using the identified first effective block decoded according to the affine mode. For example, when block A is identified and block A has two control points, as illustrated in <figref idref="DRAWINGS">FIG. <b>47</b>B</figref>, inter predictor <b>218</b> calculates motion vector v<b>0</b> at the upper-left corner control point of the current block and motion vector v<b>1</b> at the upper-right corner control point of the current block from motion vectors v<b>3</b> and v<b>4</b> at the upper-left corner and the upper-right corner of the decoded block including block A. In this way, the MV at each control point is derived.</p><p id="p-0649" num="0641">It is to be noted that, as illustrated in <figref idref="DRAWINGS">FIG. <b>49</b>A</figref>, MVs at three control points may be calculated when block A is identified and block A has two control points, and that, as illustrated in <figref idref="DRAWINGS">FIG. <b>49</b>B</figref>, MVs at two control points may be calculated when block A is identified and when block A has three control points.</p><p id="p-0650" num="0642">In addition, when MV selection information is included as a prediction parameter in a stream, inter predictor <b>218</b> may derive the MV at each control point for the current block using the MV selection information.</p><p id="p-0651" num="0643">Next, inter predictor <b>218</b> performs motion compensation of each of a plurality of sub-blocks included in the current block. In other words, inter predictor <b>218</b> calculates a MV for each of a plurality of sub-blocks as an affine MV, using either two motion vectors v<b>0</b> and v<b>1</b> and the above expression (1A) or three motion vectors v<b>0</b>, v<b>1</b>, and v<b>2</b> and the above expression (1B) (Step Sk_<b>12</b>). Inter predictor <b>218</b> then performs motion compensation of the sub-blocks using these affine MVs and decoded reference pictures (Step Sk_<b>13</b>). When the processes in Steps Sk_<b>12</b> and Sk_<b>13</b> are executed for each of the sub-blocks included in the current block, the inter prediction using the affine merge mode for the current block finishes. In other words, motion compensation of the current block is performed to generate a prediction image of the current block.</p><p id="p-0652" num="0644">It is to be noted that the above-described MV candidate list may be generated in Step Sk_<b>11</b>. The MV candidate list may be, for example, a list including MV candidates derived using a plurality of MV derivation methods for each control point. The plurality of MV derivation methods may, for example, be any combination of the MV derivation methods illustrated in <figref idref="DRAWINGS">FIGS. <b>47</b>A to <b>47</b>C</figref>, the MV derivation methods illustrated in <figref idref="DRAWINGS">FIGS. <b>48</b>A and <b>48</b>B</figref>, the MV derivation methods illustrated in <figref idref="DRAWINGS">FIGS. <b>49</b>A and <b>49</b>B</figref>, and other MV derivation methods.</p><p id="p-0653" num="0645">It is to be noted that a MV candidate list may include MV candidates in a mode in which prediction is performed in units of a sub-block, other than the affine mode.</p><p id="p-0654" num="0646">It is to be noted that, for example, a MV candidate list including MV candidates in an affine merge mode in which two control points are used and an affine merge mode in which three control points are used may be generated as a MV candidate list. Alternatively, a MV candidate list including MV candidates in the affine merge mode in which two control points are used and a MV candidate list including MV candidates in the affine merge mode in which three control points are used may be generated separately. Alternatively, a MV candidate list including MV candidates in one of the affine merge mode in which two control points are used and the affine merge mode in which three control points are used may be generated.</p><heading id="h-0077" level="2">[MV Derivation&#x3e;Affine Inter Mode]</heading><p id="p-0655" num="0647">For example, when information parsed from a stream indicates that the affine inter mode is to be applied, inter predictor <b>218</b> derives a MV in the affine inter mode and performs motion compensation (prediction) using the MV.</p><p id="p-0656" num="0648"><figref idref="DRAWINGS">FIG. <b>88</b></figref> is a flow chart illustrating an example of a process of inter prediction by the affine inter mode in decoder <b>200</b>.</p><p id="p-0657" num="0649">In the affine inter mode, first, inter predictor <b>218</b> derives MV predictors (v<b>0</b>, v<b>1</b>) or (v<b>0</b>, v<b>1</b>, v<b>2</b>) of respective two or three control points for a current block (Step Sj_<b>11</b>). The control points are an upper-left corner point of the current block, an upper-right corner point of the current block, and a lower-left corner point of the current block as illustrated in <figref idref="DRAWINGS">FIG. <b>46</b>A</figref> or <figref idref="DRAWINGS">FIG. <b>46</b>B</figref>.</p><p id="p-0658" num="0650">Inter predictor <b>218</b> obtains MV predictor selection information included as a prediction parameter in the stream, and derives the MV predictor at each control point for the current block using the MV identified by the MV predictor selection information. For example, when the MV derivation methods illustrated in <figref idref="DRAWINGS">FIGS. <b>48</b>A and <b>48</b>B</figref> are used, inter predictor <b>218</b> derives the motion vector predictors (v<b>0</b>, v<b>1</b>) or (v<b>0</b>, v<b>1</b>, v<b>2</b>) at control points for the current block by selecting the MV of the block identified by the MV predictor selection information among decoded blocks in the vicinity of the respective control points for the current block illustrated in either <figref idref="DRAWINGS">FIG. <b>48</b>A</figref> or <figref idref="DRAWINGS">FIG. <b>48</b>B</figref>.</p><p id="p-0659" num="0651">Next, inter predictor <b>218</b> obtains each MV difference included as a prediction parameter in the stream, and adds the MV predictor at each control point for the current block and the MV difference corresponding to the MV predictor (Step Sj_<b>12</b>). In this way, the MV at each control point for the current block is derived.</p><p id="p-0660" num="0652">Next, inter predictor <b>218</b> performs motion compensation of each of the plurality of sub-blocks included in the current block. In other words, inter predictor <b>218</b> calculates a MV for each of a plurality of sub-blocks as an affine MV, using either two motion vectors v<b>0</b> and v<b>1</b> and the above expression (1A) or three motion vectors v<b>0</b>, v<b>1</b>, and v<b>2</b> and the above expression (1B) (Step Sj_<b>13</b>). Inter predictor <b>218</b> then performs motion compensation of the sub-blocks using these affine MVs and decoded reference pictures (Step Sj_<b>14</b>). When the processes in Steps Sj_<b>13</b> and Sj_<b>14</b> are executed for each of the sub-blocks included in the current block, the inter prediction using the affine merge mode for the current block finishes. In other words, motion compensation of the current block is performed to generate a prediction image of the current block.</p><p id="p-0661" num="0653">It is to be noted that the above-described MV candidate list may be generated in Step Sj_<b>11</b> as in Step Sk_<b>11</b>.</p><heading id="h-0078" level="2">[MV Derivation&#x3e;Triangle Mode]</heading><p id="p-0662" num="0654">For example, when information parsed from a stream indicates that the triangle mode is to be applied, inter predictor <b>218</b> derives a MV in the triangle mode and performs motion compensation (prediction) using the MV.</p><p id="p-0663" num="0655"><figref idref="DRAWINGS">FIG. <b>89</b></figref> is a flow chart illustrating an example of a process of inter prediction by the triangle mode in decoder <b>200</b>.</p><p id="p-0664" num="0656">In the triangle mode, first, inter predictor <b>218</b> splits the current block into the first partition and the second partition (Step Sx_<b>11</b>). For example, inter predictor <b>218</b> may obtain, from the stream, partition information which is information related to the splitting as a prediction parameter. Inter predictor <b>218</b> may then split a current block into a first partition and a second partition according to the partition information.</p><p id="p-0665" num="0657">Next, inter predictor <b>218</b> obtains a plurality of MV candidates for a current block based on information such as MVs of a plurality of decoded blocks temporally or spatially surrounding the current block (Step Sx_<b>12</b>). In other words, inter predictor <b>218</b> generates a MV candidate list.</p><p id="p-0666" num="0658">Inter predictor <b>218</b> then selects the MV candidate for the first partition and the MV candidate for the second partition as a first MV and a second MV, respectively, from the plurality of MV candidates obtained in Step Sx_<b>11</b> (Step Sx_<b>13</b>). At this time, inter predictor <b>218</b> may obtain, from the stream, MV selection information for identifying each selected MV candidate as a prediction parameter. Inter predictor <b>218</b> may then select the first MV and the second MV according to the MV selection information.</p><p id="p-0667" num="0659">Next, inter predictor <b>218</b> generates a first prediction image by performing motion compensation using the selected first MV and a decoded reference picture (Step Sx_<b>14</b>). Likewise, inter predictor <b>218</b> generates a second prediction image by performing motion compensation using the selected second MV and a decoded reference picture (Step Sx_<b>15</b>).</p><p id="p-0668" num="0660">Lastly, inter predictor <b>218</b> generates a prediction image for the current block by performing a weighted addition of the first prediction image and the second prediction image (Step Sx_<b>16</b>).</p><heading id="h-0079" level="2">[MV Estimation&#x3e;DMVR]</heading><p id="p-0669" num="0661">For example, information parsed from a stream indicates that DMVR is to be applied, inter predictor <b>218</b> performs motion estimation using DMVR.</p><p id="p-0670" num="0662"><figref idref="DRAWINGS">FIG. <b>90</b></figref> is a flow chart illustrating an example of a process of motion estimation by DMVR in decoder <b>200</b>.</p><p id="p-0671" num="0663">Inter predictor <b>218</b> derives a MV for a current block according to the merge mode (Step Sl_<b>11</b>). Next, inter predictor <b>218</b> derives the final MV for the current block by searching the region surrounding the reference picture indicated by the MV derived in Sl_<b>11</b> (Step Sl_<b>12</b>). In other words, in this case, the MV of the current block is determined according to the DMVR.</p><p id="p-0672" num="0664"><figref idref="DRAWINGS">FIG. <b>91</b></figref> is a flow chart illustrating an example of a process of motion estimation by DMVR in decoder <b>200</b>, and is the same as <figref idref="DRAWINGS">FIG. <b>58</b>B</figref>.</p><p id="p-0673" num="0665">First, in Step <b>1</b> illustrated in <figref idref="DRAWINGS">FIGS. <b>58</b>A</figref>, inter predictor <b>218</b> calculates the cost between the search position (also referred to as a starting point) indicated by the initial MV and eight surrounding search positions. Inter predictor <b>218</b> then determines whether the cost at each of the search positions other than the starting point is the smallest. Here, when determining that the cost at one of the search positions other than the starting point is the smallest, inter predictor <b>218</b> changes a target to the search position at which the smallest cost is obtained, and performs the process in Step <b>2</b> illustrated in <figref idref="DRAWINGS">FIG. <b>58</b></figref>. When the cost at the starting point is the smallest, inter predictor <b>218</b> skips the process in Step <b>2</b> illustrated in <figref idref="DRAWINGS">FIG. <b>58</b>A</figref> and performs the process in Step <b>3</b>.</p><p id="p-0674" num="0666">In Step <b>2</b> illustrated in <figref idref="DRAWINGS">FIG. <b>58</b>A</figref>, inter predictor <b>218</b> performs search similar the process in Step <b>1</b>, regarding the search position after the target change as new starting point according to the result of the process in Step <b>1</b>. Inter predictor <b>218</b> then determines whether the cost at each of the search positions other than the starting point is the smallest. Here, when determining that the cost at one of the search positions other than the starting point is the smallest, inter predictor <b>218</b> performs the process in Step <b>4</b>. When the cost at the starting point is the smallest, inter predictor <b>218</b> performs the process in Step <b>3</b>.</p><p id="p-0675" num="0667">In Step <b>4</b>, inter predictor <b>218</b> regards the search position at the starting point as the final search position, and determines the difference between the position indicated by the initial MV and the final search position to be a vector difference.</p><p id="p-0676" num="0668">In Step <b>3</b> illustrated in <figref idref="DRAWINGS">FIG. <b>58</b>A</figref>, inter predictor <b>218</b> determines the pixel position at sub-pixel accuracy at which the smallest cost is obtained, based on the costs at the four points located at upper, lower, left, and right positions with respect to the starting point in Step <b>1</b> or Step <b>2</b>, and regards the pixel position as the final search position.</p><p id="p-0677" num="0669">The pixel position at the sub-pixel accuracy is determined by performing weighted addition of each of the four upper, lower, left, and right vectors ((0, 1), (0, &#x2212;1), (&#x2212;1, 0), and (1, 0)), using, as a weight, the cost at a corresponding one of the four search positions. Inter predictor <b>218</b> then determines the difference between the position indicated by the initial MV and the final search position to be the vector difference.</p><heading id="h-0080" level="2">[Motion Compensation&#x3e;BIO/OBMC/LIC]</heading><p id="p-0678" num="0670">For example, when information parsed from a stream indicates that correction of a prediction image is to be performed, upon generating a prediction image, inter predictor <b>218</b> corrects the prediction image based on the mode for the correction. The mode is, for example, one of BIO, OBMC, and LIC described above.</p><p id="p-0679" num="0671"><figref idref="DRAWINGS">FIG. <b>92</b></figref> is a flow chart illustrating one example of a process of generation of a prediction image in decoder <b>200</b>.</p><p id="p-0680" num="0672">Inter predictor <b>218</b> generates a prediction image (Step Sm_<b>11</b>), and corrects the prediction image according to any of the modes described above (Step Sm_<b>12</b>).</p><p id="p-0681" num="0673"><figref idref="DRAWINGS">FIG. <b>93</b></figref> is a flow chart illustrating another example of a process of generation of a prediction image in decoder <b>200</b>.</p><p id="p-0682" num="0674">Inter predictor <b>218</b> derives a MV for a current block (Step Sn_<b>11</b>). Next, inter predictor <b>218</b> generates a prediction image using the MV (Step Sn_<b>12</b>), and determines whether to perform a correction process (Step Sn_<b>13</b>). For example, inter predictor <b>218</b> obtains a prediction parameter included in the stream, and determines whether to perform a correction process based on the prediction parameter. This prediction parameter is, for example, a flag indicating whether one or more of the above-described modes is to be applied. Here, when determining to perform a correction process (Yes in Step Sn_<b>13</b>), inter predictor <b>218</b> generates the final prediction image by correcting the prediction image (Step Sn_<b>14</b>). It is to be noted that, in LIC, luminance and chrominance may be corrected in Step Sn_<b>14</b>. When determining not to perform a correction process (No in Step Sn_<b>13</b>), inter predictor <b>218</b> outputs the final prediction image without correcting the prediction image (Step Sn_<b>15</b>).</p><heading id="h-0081" level="2">[Motion Compensation&#x3e;OBMC]</heading><p id="p-0683" num="0675">For example, when information parsed from a stream indicates that OBMC is to be performed, upon generating a prediction image, inter predictor <b>218</b> corrects the prediction image according to the OBMC.</p><p id="p-0684" num="0676"><figref idref="DRAWINGS">FIG. <b>94</b></figref> is a flow chart illustrating an example of a process of correction of a prediction image by OBMC in decoder <b>200</b>. It is to be noted that the flow chart in <figref idref="DRAWINGS">FIG. <b>94</b></figref> indicates the correction flow of a prediction image using the current picture and the reference picture illustrated in <figref idref="DRAWINGS">FIG. <b>62</b></figref>.</p><p id="p-0685" num="0677">First, as illustrated in <figref idref="DRAWINGS">FIG. <b>62</b></figref>, inter predictor <b>218</b> obtains a prediction image (Pred) by normal motion compensation using a MV assigned to the current block.</p><p id="p-0686" num="0678">Next, inter predictor <b>218</b> obtains a prediction image (Pred_L) by applying a motion vector (MV_L) which has been already derived for the decoded block neighboring to the left of the current block to the current block (re-using the motion vector for the current block). Inter predictor <b>218</b> then performs a first correction of a prediction image by overlapping two prediction images Pred and Pred_L. This provides an effect of blending the boundary between neighboring blocks.</p><p id="p-0687" num="0679">Likewise, inter predictor <b>218</b> obtains a prediction image (Pred_U) by applying a MV (MV_U) which has been already derived for the decoded block neighboring above the current block to the current block (re-using the motion vector for the current block). Inter predictor <b>218</b> then performs a second correction of a prediction image by overlapping the prediction image Pred_U to the prediction images (for example, Pred and Pred_L) on which the first correction has been performed. This provides an effect of blending the boundary between neighboring blocks. The prediction image obtained by the second correction is the one in which the boundary between the neighboring blocks has been blended (smoothed), and thus is the final prediction image of the current block.</p><heading id="h-0082" level="2">[Motion Compensation&#x3e;BIO]</heading><p id="p-0688" num="0680">For example, when information parsed from a stream indicates that BIO is to be performed, upon generating a prediction image, inter predictor <b>218</b> corrects the prediction image according to the BIO.</p><p id="p-0689" num="0681"><figref idref="DRAWINGS">FIG. <b>95</b></figref> is a flow chart illustrating an example of a process of correction of a prediction image by the BIO in decoder <b>200</b>.</p><p id="p-0690" num="0682">As illustrated in <figref idref="DRAWINGS">FIG. <b>63</b></figref>, inter predictor <b>218</b> derives two motion vectors (M<sub>0</sub>, M<sub>1</sub>), using two reference pictures (Ref<sub>0</sub>, Ref<sub>1</sub>) different from the picture (Cur Pic) including a current block. Inter predictor <b>218</b> then derives a prediction image for the current block using the two motion vectors (M<sub>0</sub>, M<sub>1</sub>) (Step Sy_<b>11</b>). It is to be noted that motion vector M<sub>0 </sub>is a motion vector (MV<sub>x0</sub>, MV<sub>y0</sub>) corresponding to reference picture Ref<sub>0</sub>, and motion vector M<sub>1 </sub>is a motion vector (MV<sub>x1</sub>, MV<sub>y1</sub>) corresponding to reference picture Ref<sub>1</sub>.</p><p id="p-0691" num="0683">Next, inter predictor <b>218</b> derives interpolated image I<sup>0 </sup>for the current block using motion vector M<sub>0 </sub>and reference picture L<sub>0</sub>. In addition, inter predictor <b>218</b> derives interpolated image I<sup>1 </sup>for the current block using motion vector M<sub>1 </sub>and reference picture L<sub>1 </sub>(Step Sy_<b>12</b>). Here, interpolated image I<sup>0 </sup>is an image included in reference picture Ref<sub>0 </sub>and to be derived for the current block, and interpolated image I<sup>1 </sup>is an image included in reference picture Ref<sub>1 </sub>and to be derived for the current block. Each of interpolated image I<sup>0 </sup>and interpolated image I<sup>1 </sup>may be the same in size as the current block. Alternatively, each of interpolated image I<sup>0 </sup>and interpolated image I<sup>1 </sup>may be an image larger than the current block. Furthermore, interpolated image I<sup>0 </sup>and interpolated image I<sup>1 </sup>may include a prediction image obtained by using motion vectors (M<sub>0</sub>, M<sub>1</sub>) and reference pictures (L<sub>0</sub>, L<sub>1</sub>) and applying a motion compensation filter.</p><p id="p-0692" num="0684">In addition, inter predictor <b>218</b> derives gradient images (Ix<sup>0</sup>, Ix<sup>1</sup>, Iy<sup>0</sup>, Iy<sup>1</sup>) of the current block, from interpolated image I<sup>0 </sup>and interpolated image I<sup>1 </sup>(Step Sy_<b>13</b>). It is to be noted that the gradient images in the horizontal direction are (Ix<sup>0</sup>, Ix<sup>1</sup>), and the gradient images in the vertical direction are (Iy<sup>0</sup>, Iy<sup>1</sup>). Inter predictor <b>218</b> may derive the gradient images by, for example, applying a gradient filter to the interpolated images. The gradient images may be the ones each of which indicates the amount of spatial change in pixel value along the horizontal direction or the amount of spatial change in pixel value along the vertical direction.</p><p id="p-0693" num="0685">Next, inter predictor <b>218</b> derives, for each sub-block of the current block, an optical flow (vx, vy) which is a velocity vector, using the interpolated images (I<sup>0</sup>, I<sup>1</sup>) and the gradient images (Ix<sup>0</sup>, Ix<sup>1</sup>, Iy<sup>0</sup>, Iy<sup>1</sup>) (Step Sy_<b>14</b>). As one example, a sub-block may be 4&#xd7;4 pixel sub-CU.</p><p id="p-0694" num="0686">Next, inter predictor <b>218</b> corrects a prediction image for the current block using the optical flow (vx, vy). For example, inter predictor <b>218</b> derives a correction value for the value of a pixel included in a current block, using the optical flow (vx, vy) (Step Sy_<b>15</b>). Inter predictor <b>218</b> may then correct the prediction image for the current block using the correction value (Step Sy_<b>16</b>). It is to be noted that the correction value may be derived in units of a pixel, or may be derived in units of a plurality of pixels or in units of a sub-block, etc.</p><p id="p-0695" num="0687">It is to be noted that the BIO process flow is not limited to the process disclosed in <figref idref="DRAWINGS">FIG. <b>95</b></figref>. Only part of the processes disclosed in <figref idref="DRAWINGS">FIG. <b>95</b></figref> may be performed, or a different process may be added or used as a replacement, or the processes may be executed in a different processing order.</p><heading id="h-0083" level="2">[Motion Compensation&#x3e;LIC]</heading><p id="p-0696" num="0688">For example, when information parsed from a stream indicates that LIC is to be performed, upon generating a prediction image, inter predictor <b>218</b> corrects the prediction image according to the LIC.</p><p id="p-0697" num="0689"><figref idref="DRAWINGS">FIG. <b>96</b></figref> is a flow chart illustrating an example of a process of correction of a prediction image by the LIC in decoder <b>200</b>.</p><p id="p-0698" num="0690">First, inter predictor <b>218</b> obtains a reference image corresponding to a current block from a decoded reference picture using a MV (Step Sz_<b>11</b>).</p><p id="p-0699" num="0691">Next, inter predictor <b>218</b> extracts, for the current block, information indicating how the luminance value has changed between the current picture and the reference picture (Step Sz_<b>12</b>). This extraction may be performed based on the luma pixel values for the decoded left neighboring reference region (surrounding reference region) and the decoded upper neighboring reference region (surrounding reference region), and the luma pixel values at the corresponding positions in the reference picture specified by the derived MVs. Inter predictor <b>218</b> calculates a luminance correction parameter, using the information indicating how the luma value changed (Step Sz_<b>13</b>).</p><p id="p-0700" num="0692">Inter predictor <b>218</b> generates a prediction image for the current block by performing a luminance correction process in which the luminance correction parameter is applied to the reference image in the reference picture specified by the MV (Step Sz_<b>14</b>). In other words, the prediction image which is the reference image in the reference picture specified by the MV is subjected to the correction based on the luminance correction parameter. In this correction, luminance may be corrected, or chrominance may be corrected.</p><heading id="h-0084" level="2">[Prediction Controller]</heading><p id="p-0701" num="0693">Prediction controller <b>220</b> selects an intra prediction image or an inter prediction image, and outputs the selected image to adder <b>208</b>. As a whole, the configurations, functions, and processes of prediction controller <b>220</b>, intra predictor <b>216</b>, and inter predictor <b>218</b> at the decoder <b>200</b> side may correspond to the configurations, functions, and processes of prediction controller <b>128</b>, intra predictor <b>124</b>, and inter predictor <b>126</b> at the encoder <b>100</b> side.</p><heading id="h-0085" level="2">[First Aspect]</heading><p id="p-0702" num="0694">In the first aspect, syntax for a triangular partition mode (hereinafter referred to as a triangular mode) and a multiple prediction mode is designed as a prediction mode for predicting a current block that is a block to be processed.</p><p id="p-0703" num="0695">In the triangular mode, a quadrilateral first partition (hereinafter also referred to as a current block) is split into a plurality of partitions including at least one triangular partition, and motion compensation is performed for each of the partitions using a different motion vector. More specifically, for example, two quadrilateral prediction images are generated for the quadrilateral first partition. Then, weighted addition according to each region of two triangular partitions in the first partition is performed on the two quadrilateral prediction images. In this manner, one prediction image corresponding to the quadrilateral first partition is generated based on two prediction images for the two triangular partitions.</p><p id="p-0704" num="0696">In the multiple prediction mode, a prediction image for the current block is generated using at least two items of prediction information. More specifically, in the multiple prediction mode, a plurality of prediction images are generated, for the current block, using at least two items of prediction information obtained by a plurality of prediction methods, and a prediction image of the current block is generated by overlapping the generated plurality of prediction images. For example, in the multiple prediction mode, a prediction image of the current block may be generated by overlapping an inter prediction image of the current block with an intra prediction image of the current block. In addition, for example, in the multiple prediction mode, a prediction image of the current block may be generated by overlapping prediction images predicted in a plurality of inter prediction modes. In addition, for example, a prediction image of the current block may be generated by overlapping an inter prediction image resulting from bidirectional prediction with an inter prediction image resulting from unidirectional prediction. In addition, for example, in the multiple prediction mode, a prediction image of the current block may be generated by overlapping three or more prediction images. It should be noted that an example of the at least two items of prediction information will be described later.</p><p id="p-0705" num="0697">In the first aspect, a first parameter (hereinafter also referred to as a first flag) which indicates whether the prediction mode is the triangular mode is encoded prior to a second parameter (hereinafter also referred to as a second flag) which indicates whether the prediction mode is the multiple prediction mode.</p><p id="p-0706" num="0698"><figref idref="DRAWINGS">FIG. <b>97</b></figref> is a flowchart illustrating one example of encoding processing according to the first aspect. <figref idref="DRAWINGS">FIG. <b>98</b></figref> is a diagram for explaining more specifically one example of the encoding processing according to the first aspect.</p><p id="p-0707" num="0699">As illustrated in <figref idref="DRAWINGS">FIG. <b>97</b></figref>, in Step S<b>1001</b>, a first parameter, which indicates whether a current block is split into a plurality of partitions including at least one non-quadrilateral partition, is written into a bitstream. The non-quadrilateral partition is a partition having a shape other than a quadrilateral shape; that is, other than a square and a rectangle.</p><p id="p-0708" num="0700">In the example illustrated in <figref idref="DRAWINGS">FIG. <b>98</b></figref>, the non-quadrilateral partition is a triangular partition. As illustrated in <figref idref="DRAWINGS">FIG. <b>98</b></figref>, in Step S<b>1001</b>, a first parameter, which indicates whether a current block is split into a plurality of partitions including at least one triangular partition; that is, a first parameter, which indicates whether a prediction mode is the triangular mode, is written into a bitstream. When the first parameter, which indicates that the prediction mode is the triangular mode, is written into a bitstream (Yes in Step S<b>1001</b>), the current block is predicted in the triangular mode (Step S<b>1005</b>). At this time, the current block is split into a plurality of partitions which include at least one triangular partition.</p><p id="p-0709" num="0701"><figref idref="DRAWINGS">FIG. <b>99</b></figref> is a diagram illustrating an example of a current block being split into a plurality of partitions which include at least one non-quadrilateral partition. In the example denoted as (a) in <figref idref="DRAWINGS">FIG. <b>99</b></figref>, the current block is split into two triangular partitions. In the example denoted as (b) in <figref idref="DRAWINGS">FIG. <b>99</b></figref>, the current block is split into a quadrilateral partition and an L-shape partition. In the example denoted as (c) in <figref idref="DRAWINGS">FIG. <b>99</b></figref>, the current block is split into a triangular partition and a pentagonal partition. In the example denoted as (d) in <figref idref="DRAWINGS">FIG. <b>99</b></figref>, the current block is split into a pentagonal partition and a polygonal partition. In the example denoted as (e) in <figref idref="DRAWINGS">FIG. <b>99</b></figref>, the current block is split into two polygonal partitions.</p><p id="p-0710" num="0702"><figref idref="DRAWINGS">FIG. <b>100</b></figref> is a diagram illustrating an example of a current block being split into two triangular partitions. When a current block is split into two triangular partitions, the splitting direction is one of two ways. In one example, as illustrated in (a) in <figref idref="DRAWINGS">FIG. <b>100</b></figref>, the current block is split from a top-left corner to a bottom-right corner. In another example, as illustrated in (b) in <figref idref="DRAWINGS">FIG. <b>100</b></figref>, the current block is split from a top-right corner to a bottom-left corner.</p><p id="p-0711" num="0703">Next, in Step S<b>1002</b>, when the current block is not split into a plurality of partitions including at least one non-quadrilateral partition, a second parameter is written into a bitstream. For example, as illustrated in <figref idref="DRAWINGS">FIG. <b>98</b></figref>, when the first parameter, which indicates that the prediction mode is not the triangular mode, is written into a bitstream (No in Step S<b>1001</b> of <figref idref="DRAWINGS">FIG. <b>98</b></figref>), a second parameter, which indicates whether the prediction mode is the multiple prediction mode, is written into the bitstream (Step S<b>1002</b>).</p><p id="p-0712" num="0704">As described above, in the multiple prediction mode, a prediction image may be generated by overlapping an inter prediction image of the current block with an intra prediction image of the current block. In this case, the at least two items of prediction information are the inter prediction image and the intra prediction image. However, the prediction information is not limited to this example. The prediction information may be, for example, a direction of intra prediction, an index of a candidate list generated for a prediction mode such as a merge mode, a unidirectional motion vector predictor, or a bidirectional motion vector predictor.</p><p id="p-0713" num="0705">For example, the current block may be predicted using the unidirectional motion vector predictor and the index of a candidate list generated for a prediction mode such as a merge mode.</p><p id="p-0714" num="0706">In addition, for example, the current block may be predicted using a first merge index and a second merge index of the candidate list generated for a prediction mode such as a merge mode. The first merge index is different from the second merge index.</p><p id="p-0715" num="0707">In addition, for example, the current block may be predicted using the direction of intra prediction and the index of a candidate list generated for a prediction mode such as a merge mode.</p><p id="p-0716" num="0708">In addition, for example, the current block may be predicted using the bidirectional motion vector predictor and the unidirectional motion vector predictor.</p><p id="p-0717" num="0709">In addition, for example, the current block may be predicted using the bidirectional motion vector predictor and two unidirectional motion vector predictors.</p><p id="p-0718" num="0710">In addition, for example, the current block may be predicted using the direction of intra prediction and the unidirectional motion vector predictor or the bidirectional motion vector predictor.</p><p id="p-0719" num="0711">Returning to explaining the one example of encoding processing according to the first aspect with reference to <figref idref="DRAWINGS">FIG. <b>97</b></figref> again, in Step S<b>1003</b>, the current block is encoded according to the prediction mode indicated by the first parameter and the second parameter. More specifically, as illustrated in <figref idref="DRAWINGS">FIG. <b>98</b></figref>, when the first parameter, which indicates that the prediction mode is not the triangular mode, is written into a bitstream (No in Step S<b>1001</b>) and further the second parameter, which indicates that the prediction mode is the multiplex prediction mode, is written into the bitstream (Yes in Step S<b>1002</b>), the current block is predicted in the multiplex prediction mode (Step S<b>10031</b>). Meanwhile, when the first parameter, which indicates that the prediction mode is not the triangular mode, is written into a bitstream (No in Step S<b>1001</b>) and further the second parameter, which indicates that the prediction mode is not the multiplex prediction mode, is written into the bitstream (No in Step S<b>1002</b>), the current block is predicted in another inter prediction mode (Step S<b>10032</b>).</p><p id="p-0720" num="0712">The other inter prediction mode is, for example, a merge with motion vector difference (MMVD) mode, a merge mode in a sub-block unit, or a normal merge mode.</p><p id="p-0721" num="0713">It should be noted that encoding the first parameter and the second parameter may be controlled using information that is already determined such as a size or a prediction mode (hereinafter also referred to as an encoding mode) of the current block.</p><heading id="h-0086" level="2">[Variation 1 of First Aspect]</heading><p id="p-0722" num="0714">The following describes encoding processing according to Variation 1 of the first aspect. The present variation differs from the first aspect in that the first parameter is not encoded into a bitstream according to the size of a current block or the encoding mode of the current block. More specifically, when the current block has a size greater than or equal to a specific size, or when an encoding mode of the current block is not a specific mode, both the first parameter and the second parameter are encoded. On the other hand, when the current block has a size smaller than the specific size, or when an encoding mode of the current block is the specific mode, only the second parameter is encoded.</p><p id="p-0723" num="0715"><figref idref="DRAWINGS">FIG. <b>101</b></figref> is a diagram for explaining one example of encoding processing according to Variation 1 of the first aspect.</p><p id="p-0724" num="0716">As illustrated in <figref idref="DRAWINGS">FIG. <b>101</b></figref>, whether the size of the current block is greater than or equal to a threshold (for example, 8&#xd7;8 pixels) is determined (Step S<b>1101</b>). When the size of the current block is greater than or equal to the threshold (Yes in Step S<b>1101</b>), the first parameter, which indicates whether the prediction mode is the triangular mode, is written into a bitstream (Step S<b>1102</b>). When the first parameter, which indicates that the prediction mode is the triangular mode, is written into the bitstream (Yes in Step S<b>1102</b>), the current block is split into a plurality of partitions including at least one triangular partition (Step S<b>1103</b>). On the other hand, when the first parameter, which indicates that the prediction mode is not the triangular mode, is written into a bitstream (No in Step S<b>1102</b>), a second parameter, which indicates whether the prediction mode is the multiple prediction mode, is written into the bitstream (Step S<b>1104</b>). When the second parameter, which indicates that the prediction mode is the multiplex prediction mode, is written into the bitstream (Yes in Step S<b>1104</b>), the current block is predicted in the multiplex prediction mode (Step S<b>1105</b>). On the other hand, when the second parameter, which indicates that the prediction mode is not the multiplex prediction mode, is written into the bitstream (No in Step S<b>1104</b>), the current block is predicted in another inter prediction mode (Step S<b>1106</b>).</p><p id="p-0725" num="0717">Meanwhile, when the size of the current block is smaller than the threshold (No in Step S<b>1101</b>), a second parameter, which indicates whether the prediction mode is the multiple prediction mode, is written into a bitstream (Step S<b>1107</b>). When the second parameter, which indicates that the prediction mode is the multiplex prediction mode, is written into the bitstream (Yes in Step S<b>1107</b>), the current block is predicted in the multiplex prediction mode (Step S<b>1108</b>). On the other hand, when the second parameter, which indicates that the prediction mode is not the multiplex prediction mode, is written into a bitstream (No in Step S<b>1107</b>), the current block is predicted in another inter prediction mode (Step S<b>1109</b>).</p><p id="p-0726" num="0718">It should be noted that the threshold of the size of a current block may be greater than or equal to 64 pixels.</p><p id="p-0727" num="0719">As described above, according to Variation 1 of the first aspect, when a current block has a size greater than or equal to a threshold, both the first parameter and the second parameter are encoded such that the both modes are selectable. On the other hand, when the current block has a size smaller than the threshold, the first parameter is not encoded (in other words, only the second parameter is encoded), to exclude the triangular mode from options.</p><heading id="h-0087" level="2">[Variation 2 of First Aspect]</heading><p id="p-0728" num="0720">The following describes encoding processing according to Variation 2 of the first aspect. The present variation differs from the first aspect and Variation 1 in that the second parameter is not encoded into a bitstream according to a size of a current block or an encoding mode of the current block. More specifically, when the current block has a size greater than or equal to a specific size, or when an encoding mode of the current block is not a specific mode, both the first parameter and the second parameter are encoded. On the other hand, when the current block has a size smaller than the specific size, or when an encoding mode of the current block is the specific mode, only the first parameter is encoded.</p><p id="p-0729" num="0721"><figref idref="DRAWINGS">FIG. <b>102</b></figref> is a diagram for explaining one example of encoding processing according to Variation 2 of the first aspect.</p><p id="p-0730" num="0722">As illustrated in <figref idref="DRAWINGS">FIG. <b>102</b></figref>, the first parameter, which indicates whether a prediction mode is the triangular mode, is written into a bitstream (Step S<b>1201</b>). When the first parameter, which indicates that the prediction mode is the triangular mode, is written into the bitstream (Yes in Step S<b>1201</b>), the current block is split into a plurality of partitions including at least one triangular partition (Step S<b>1202</b>). On the other hand, when the first parameter, which indicates that the prediction mode is not the triangular mode, is written into the bitstream (No in Step S<b>1201</b>), whether the encoding mode of the current block is a skip mode is determined (Step S<b>1203</b>). When the encoding mode of the current block is the skip mode (Yes in Step S<b>1203</b>), the current block is encoded in the skip mode in which the triangular prediction processing and the multiplex prediction processing are not used (Step S<b>1204</b>). On the other hand, when the encoding mode of the current block is not the skip mode (No in Step S<b>1203</b>), the second parameter, which indicates whether the prediction mode is the multiple prediction mode, is written into the bitstream (Step S<b>1205</b>). When the second parameter, which indicates that the prediction mode is the multiplex prediction mode, is written into the bitstream (Yes in Step S<b>1205</b>), the current block is predicted in the multiplex prediction mode (Step S<b>1206</b>). On the other hand, when the second parameter, which indicates that the prediction mode is not the multiplex prediction mode, is written into the bitstream (No in Step S<b>1205</b>), the current block is predicted in another inter prediction mode (Step S<b>1207</b>).</p><p id="p-0731" num="0723">As described above, according to Variation 2 of the first aspect, when the encoding mode of a current block is not a specific mode (for example, the skip mode), both the first parameter and the second parameter are encoded such that the both modes are selectable. On the other hand, when the encoding mode of the current block is the specific mode (skip mode), the second parameter is not encoded (in other words, only the first parameter is encoded), to exclude the multiple prediction mode from options.</p><p id="p-0732" num="0724">It should be noted that, in the description of the present aspect, the terms &#x201c;writing&#x201d; and &#x201c;encoding&#x201d; used in the description for the encoding method and the encoding processing performed by the encoder may be replaced with the terms &#x201c;parsing&#x201d; and &#x201c;decoding&#x201d; for a decoding method and decoding processing performed by a decoder.</p><heading id="h-0088" level="2">[Technical Advantages of First Aspect]</heading><p id="p-0733" num="0725">In the first aspect, a syntax design for the triangular partition mode (in other words, the triangular mode) and the multiple prediction mode is introduced. With the syntax design, it is possible to combine the multiple prediction mode with the triangular mode, and thus coding efficiency is improved. According to the first aspect, it is possible to implement a combination of the triangular mode and the multiple prediction mode without increasing the required worst-case memory access of each block (in other words, without increasing the worst-case memory access of each block as memory access).</p><heading id="h-0089" level="2">[Combination Including the Other Aspects]</heading><p id="p-0734" num="0726">At least a portion of the present aspect may be combined with at least a portion of one or more of other aspects. A portion of the processing in flowcharts, a portion of the devices, syntax, and/or other features may be combined with the other aspects.</p><p id="p-0735" num="0727">It should be noted that all the above-described processes/elements are not always required. The device/method may contain a portion of the processes/elements. The above-described processes may be performed by a decoder in the same manner as the encoder.</p><heading id="h-0090" level="2">[Second Aspect]</heading><p id="p-0736" num="0728">In the second aspect, syntax for a triangular mode and a multiple prediction mode is designed as a prediction mode for predicting a current block.</p><p id="p-0737" num="0729">According to the first aspect, the first parameter is a flag indicating whether the prediction mode is the triangular mode, and the second parameter is a flag indicating whether the prediction mode is the multiple prediction mode. The second aspect differs from the first aspect in that the first parameter and the second parameter are flags related respectively to the prediction modes opposite to the prediction modes of the first aspect.</p><p id="p-0738" num="0730">In the second aspect, a first flag which indicates whether the prediction mode is the multiple prediction mode is encoded prior to a second flag which indicates whether the prediction mode is the triangular mode.</p><p id="p-0739" num="0731"><figref idref="DRAWINGS">FIG. <b>103</b></figref> is a flowchart illustrating one example of encoding processing according to the second aspect. <figref idref="DRAWINGS">FIG. <b>104</b></figref> is a diagram for explaining more specifically one example of the encoding processing according to the second aspect.</p><p id="p-0740" num="0732">As illustrated in <figref idref="DRAWINGS">FIG. <b>103</b></figref>, in Step S<b>2001</b>, a first parameter, which indicates whether a prediction mode for a current block is the multiple prediction mode, is written into a bitstream. As described in the first aspect, in the multiple prediction mode, for example, a prediction image of the current block is generated by overlapping an inter prediction image of the current block with an intra prediction image of the current block. As illustrated in <figref idref="DRAWINGS">FIG. <b>104</b></figref>, in Step S<b>2001</b>, a first parameter, which indicates whether a prediction mode for predicting a current block is the multiple prediction mode, is written into a bitstream. When the first parameter, which indicates that the prediction mode is the multiplex prediction mode, is written into the bitstream (Yes in Step S<b>2001</b>), the current block is predicted in the multiplex prediction mode (Step S<b>2005</b>).</p><p id="p-0741" num="0733">Next, in Step S<b>2002</b>, when the current block is not predicted using at least two items of prediction information, a second parameter is written into the bitstream. For example, as illustrated in <figref idref="DRAWINGS">FIG. <b>104</b></figref>, when the first parameter, which indicates that the prediction mode is not the multiple prediction mode, is written into a bitstream (No in Step S<b>2001</b>), a second parameter, which indicates whether the prediction mode is the triangular mode, is written into the bitstream (Step S<b>2002</b>).</p><p id="p-0742" num="0734">Next, in Step S<b>2003</b>, the current block is encoded according to the prediction mode indicated by the first parameter and the second parameter. More specifically, as illustrated in <figref idref="DRAWINGS">FIG. <b>104</b></figref>, when the first parameter, which indicates that the prediction mode is not the multiple mode, is written into a bitstream (No in Step S<b>2001</b>) and further the second parameter, which indicates that the prediction mode is the triangular mode is written into the bitstream (Yes in Step S<b>2002</b>), the current block is predicted in the triangular mode (Step S<b>20031</b>). On the other hand, when the first parameter, which indicates that the prediction mode is not the multiple mode, is written into a bitstream (No in Step S<b>2001</b>) and further the second parameter, which indicates that the prediction mode is not the triangular mode, is written into the bitstream (No in Step S<b>2002</b>), the current block is predicted in another inter prediction mode (Step S<b>20032</b>). It should be noted that the other inter prediction mode has been described in the first aspect, and thus description for the other prediction mode will be omitted here.</p><p id="p-0743" num="0735">According to the second aspect, the first parameter, which indicates whether the prediction mode is the multiple prediction mode, is encoded into syntax, and then the second parameter, which indicates whether the prediction mode is the triangular mode, is encoded into syntax. Accordingly, the second aspect and the first aspect are same in that the multiple prediction mode and the triangular mode are not used at the same time (in other words, exclude each other).</p><p id="p-0744" num="0736">In addition, in the second aspect, the first parameter, which indicates whether the prediction mode is the multiple prediction mode, is encoded, and when (i) the first parameter indicates that the prediction mode is not the multiple prediction mode and (ii) the determined condition is satisfied, the current block may be predicted in the triangular mode without a flag. On the other hand, when the determined condition is not satisfied, the current block may be predicted in the other inter prediction mode (for example, a normal merge mode).</p><p id="p-0745" num="0737">For example, the condition is (a) the size of the current block is greater than or equal to 64 pixels, (b) the encoding mode of the current block is not a specific mode, or (c) the triangular mode can be used. At this time, when the size of the current block is less than 64 pixels, the above-described condition may be determined not to be satisfied. In addition, when the encoding mode of the current block is the specific mode, the above-described condition may be determined not to be satisfied. Furthermore, when it is prohibited to use the triangular mode, the above-described condition may be determined not to be satisfied. It should be noted that the determined condition may be a predetermined condition.</p><p id="p-0746" num="0738">It should be noted that, in the second aspect as with the first aspect, encoding the first parameter and the second parameter may be controlled using information that is already determined such as the size or the prediction mode of the current block.</p><heading id="h-0091" level="2">[Variation 1 of Second Aspect]</heading><p id="p-0747" num="0739">The following describes encoding processing according to Variation 1 of the second aspect. The present variation differs from the second aspect in that the first parameter is not encoded into a bitstream according to the size of a current block or the encoding mode of the current block. More specifically, when the current block has a size greater than or equal to a specific size, or when an encoding mode of the current block is not a specific mode, both the first parameter and the second parameter are encoded. On the other hand, when the current block has a size smaller than the specific size, or when an encoding mode of the current block is the specific mode, only the second parameter is encoded.</p><p id="p-0748" num="0740"><figref idref="DRAWINGS">FIG. <b>105</b></figref> is a diagram for explaining one example of encoding processing according to Variation 1 of the second aspect.</p><p id="p-0749" num="0741">As illustrated in <figref idref="DRAWINGS">FIG. <b>105</b></figref>, whether the encoding mode of a current block is the skip mode is determined (Step S<b>2101</b>). When the encoding mode of the current block is the skip mode (Yes in Step S<b>2101</b>), the second parameter, which indicates whether the prediction mode is the triangular mode, is written into a bitstream (Step S<b>2102</b>). When the second parameter, which indicates that the prediction mode is the triangular mode, is written into the bitstream (Yes in Step S<b>2102</b>), the current block is predicted in the triangular mode (Step S<b>2103</b>). On the other hand, when the second parameter, which indicates that the prediction mode is not the triangular mode, is written into the bitstream (No in Step S<b>2102</b>), the current block is encoded in the skip mode in which the triangular prediction processing and the multiplex prediction processing are not used (Step S<b>2104</b>).</p><p id="p-0750" num="0742">On the other hand, when the prediction mode of the current block is not the skip mode (No in Step S<b>2101</b>), the first parameter, which indicates whether the prediction mode is the multiple prediction mode, is written into a bitstream (Step S<b>2105</b>). When the first parameter, which indicates that the prediction mode is the multiple prediction mode, is written into the bitstream (Yes in Step S<b>2105</b>, the current block is predicted in the multiplex prediction mode (Step S<b>2106</b>). On the other hand, when the first parameter, which indicates that the prediction mode is not the multiple prediction mode, is written into the bitstream (No in Step S<b>2105</b>), a second parameter, which indicates whether the prediction mode is the triangular mode, is written into the bitstream (Step S<b>2107</b>). When the second parameter, which indicates that the prediction mode is the triangular mode, is written into the bitstream (Yes in Step S<b>2107</b>), the current block is predicted in the triangular mode (Step S<b>2108</b>). On the other hand, when the second parameter, which indicates that the prediction mode is not the triangular mode, is written into the bitstream (No in Step S<b>2107</b>), the current block is predicted in another inter prediction mode (Step S<b>2109</b>).</p><p id="p-0751" num="0743">As described above, according to Variation 1 of the second aspect, when the encoding mode of the current block is not the specific mode (for example, the skip mode), both the first parameter and the second parameter are encoded such that the both modes are selectable. On the other hand, when the encoding mode of the current block is the specific mode (for example, skip mode), the first parameter is not encoded (in other words, only the second parameter is encoded), to exclude the multiple prediction mode from options.</p><heading id="h-0092" level="2">[Variation 2 of Second Aspect]</heading><p id="p-0752" num="0744">The following describes encoding processing according to Variation 2 of the second aspect. The present variation differs from the second aspect and Variation 1 in that the second parameter is not encoded into a bitstream according to the size of a current block or the encoding mode of the current block. More specifically, when the current block has a size greater than or equal to the specific size, or when an encoding mode of the current block is not the specific mode, both the first parameter and the second parameter are encoded. On the other hand, when the current block has a size smaller than the specific size, or when an encoding mode of the current block is the specific mode, only the first parameter is encoded.</p><p id="p-0753" num="0745"><figref idref="DRAWINGS">FIG. <b>106</b></figref> is a diagram for explaining one example of encoding processing according to Variation 2 of the second aspect.</p><p id="p-0754" num="0746">As illustrated in <figref idref="DRAWINGS">FIG. <b>106</b></figref>, the first parameter, which indicates whether a prediction mode is the multiple mode, is written into a bitstream (Step S<b>2201</b>). When the first parameter, which indicates that the prediction mode is the multiple prediction mode, is written into the bitstream (Yes in Step S<b>2201</b>), the current block is predicted in the multiple prediction mode (Step S<b>2202</b>). On the other hand, when the first parameter, which indicates that the prediction mode is not the multiple prediction mode, is written into the bitstream (No in Step S<b>2201</b>), whether the size of the current block is greater than or equal to a threshold (here, 8&#xd7;8 pixels) is determined (Step S<b>2203</b>). When the size of the current block is less than the threshold (here, 8&#xd7;8 pixels) (No in Step S<b>2203</b>), the current block is predicted in another inter prediction mode (Step S<b>2204</b>). On the other hand, when the size of the current block is greater than or equal to the threshold (8&#xd7;8 pixels) (Yes in Step S<b>2203</b>), the second parameter, which indicates whether the prediction mode is the triangular mode, is written into a bitstream (Step S<b>2205</b>). When the second parameter, which indicates that the prediction mode is the triangular mode, is written into the bitstream (Yes in Step S<b>2205</b>), the current block is split into a plurality of partitions including at least one triangular partition (Step S<b>2206</b>). On the other hand, when the second parameter, which indicates that the prediction mode is not the triangular mode, is written into the bitstream (No in Step S<b>2205</b>), the current block is predicted in another inter prediction mode (Step S<b>2207</b>).</p><p id="p-0755" num="0747">It should be noted that the threshold of the size of a current block may be greater than or equal to 64 pixels.</p><p id="p-0756" num="0748">As described above, according to Variation 2 of the second aspect, when a current block has a size greater than or equal to a specific size (for example, 8&#xd7;8 pixels), both the first parameter and the second parameter are encoded such that the both modes are selectable. On the other hand, when the current block has a size smaller than the specific size, the second parameter is not encoded (in other words, only the first parameter is encoded), to exclude the triangular mode from options.</p><p id="p-0757" num="0749">It should be noted that, in the description of the present aspect, the terms &#x201c;writing&#x201d; and &#x201c;encoding&#x201d; used in the description for the encoding method and the encoding processing performed by the encoder may be replaced with the terms &#x201c;parsing&#x201d; and &#x201c;decoding&#x201d; for a decoding method and decoding processing performed by a decoder.</p><heading id="h-0093" level="2">[Technical Advantages of Second Aspect]</heading><p id="p-0758" num="0750">In the second aspect, a syntax design for the triangular mode and the multiple prediction mode is introduced. With the syntax design, it is possible to combine the multiple prediction mode with the triangular mode, and thus coding efficiency is improved. According to the second aspect, it is possible to implement a combination of the triangular mode and the multiple prediction mode without increasing the required worst-case memory access of each block.</p><heading id="h-0094" level="2">[Combination Including the Other Aspects]</heading><p id="p-0759" num="0751">At least a portion of the present aspect may be combined with at least a portion of one or more of other aspects. A portion of the processing in flowcharts, a portion of the devices, syntax, and/or other features may be combined with the other aspects.</p><p id="p-0760" num="0752">It should be noted that all the above-described processes/elements are not always required. The device/method may contain a portion of the processes/elements. The above-described processes may be performed by a decoder in the same manner as the encoder.</p><p id="p-0761" num="0753">For example, the second aspect may be combined with the first aspect. <figref idref="DRAWINGS">FIG. <b>107</b></figref> is a diagram for explaining one example of encoding processing according to an aspect of a combination of the first aspect and the second aspect.</p><p id="p-0762" num="0754">According to an aspect of a combination of the first aspect and the second aspect, an encoding order of a parameter indicating whether a prediction image is generated by splitting a current block into a plurality of partitions including at least one non-quadrilateral partition (for example, a triangular partition) and a parameter indicating whether a current block is predicted using at least two items of prediction information is determined based on a size of the current block or an encoding mode of the current block.</p><p id="p-0763" num="0755">As illustrated in <figref idref="DRAWINGS">FIG. <b>107</b></figref>, a flag indicating whether the encoding mode of a current block is the skip mode is written into a bitstream (Step S<b>2301</b>). When the prediction mode of the current block is the skip mode (Yes in Step S<b>2301</b>), a parameter, which indicates whether the prediction mode is the triangular mode, is written into the bitstream (Step S<b>2302</b>). When the parameter, which indicates that the prediction mode is the triangular mode, is written into the bitstream (Yes in Step S<b>2302</b>), the current block is predicted in the triangular mode (Step S<b>2303</b>). On the other hand, when the parameter, which indicates that the prediction mode is not the triangular mode, is written into the bitstream (No in Step S<b>2302</b>), a parameter, which indicates whether the prediction mode is the multiple prediction mode, is written into the bitstream (Step S<b>2304</b>). When the parameter, which indicates that the prediction mode is the multiple prediction mode, is written into the bitstream (Yes in Step S<b>2304</b>), the current block is predicted in the multiple prediction mode (Step S<b>2305</b>). On the other hand, when the parameter, which indicates that the prediction mode is not the multiple prediction mode, is written into the bitstream (No in Step S<b>2304</b>), the current block is encoded in the skip mode in which the triangular prediction processing and the multiple prediction processing are not used (Step S<b>2306</b>).</p><p id="p-0764" num="0756">Meanwhile, when the encoding mode of the current block is not the skip mode (No in Step S<b>2301</b>), a parameter, which indicates whether the prediction mode is the multiple prediction mode, is written into a bitstream (Step S<b>2307</b>). When the parameter, which indicates that the prediction mode is the multiple prediction mode, is written into the bitstream (Yes in Step S<b>2307</b>), the current block is predicted in the multiple prediction mode (Step S<b>2308</b>). On the other hand, when the parameter, which indicates that the prediction mode of the current block is not the multiple prediction mode, is written into the bitstream (No in Step S<b>2307</b>), a parameter, which indicates whether the prediction mode is the triangular mode, is written into the bitstream (Step S<b>2309</b>). When the parameter, which indicates that the prediction mode is the triangular mode, is written into the bitstream (Yes in Step S<b>2309</b>), the current block is predicted in the triangular mode (Step S<b>2310</b>). On the other hand, when the parameter, which indicates that the prediction mode is not the triangular mode, is written into the bitstream (No in Step S<b>2309</b>), the current block is predicted in another inter prediction mode (Step S<b>2311</b>).</p><p id="p-0765" num="0757">As described above, according to the aspect of the combination of the first aspect and the second aspect, an encoding processing flow may be switched between the encoding processing flow in the first aspect and the encoding processing flow in the second aspect, based on whether the current block satisfies a determined condition (here, the determined condition is that the encoding mode is the skip mode). For example, the encoding processing flow of the first aspect is performed when the encoding mode of the current block is the specific mode (for example, the skip mode), and the encoding processing flow of the second aspect is performed when the prediction mode of the current block is not the specific mode. In this manner, the encoding order of the triangular mode and the multiple prediction mode may be switched according to the size of the current block or the encoding mode of the current block.</p><heading id="h-0095" level="2">[Third Aspect]</heading><p id="p-0766" num="0758">According to the third aspect, syntax for a triangular mode and a multiple prediction mode is designed as a prediction mode for predicting a current block.</p><p id="p-0767" num="0759">In the third aspect, a first parameter indicating: whether at least one additional prediction information is used for the current block; or whether the current block is split into a plurality of partitions including at least one triangular partition is encoded.</p><p id="p-0768" num="0760"><figref idref="DRAWINGS">FIG. <b>108</b></figref> is a flowchart illustrating one example of encoding processing according to the third aspect. <figref idref="DRAWINGS">FIG. <b>109</b></figref> is a diagram for explaining more specifically one example of the encoding processing according to the third aspect.</p><p id="p-0769" num="0761">As illustrated in <figref idref="DRAWINGS">FIG. <b>108</b></figref>, in Step S<b>3001</b>, a first parameter is written into a bitstream. The first parameter indicates, as a prediction mode, one of (i) a multiple prediction mode in which a prediction image is generated by overlapping an inter prediction image of the current block and an intra prediction image of the current block and (ii) one of a plurality of prediction modes including a triangular mode in which a prediction image is generated by splitting the current block into triangular regions. For example, as illustrated in <figref idref="DRAWINGS">FIG. <b>109</b></figref>, in Step S<b>3001</b>, the first parameter, which indicates which one of (i) the multiple prediction mode and (ii) one of the plurality of prediction modes including the triangular mode is the prediction mode of the current block, is written into a bitstream. It should be noted that the first parameter may be, instead of the parameter having a binary value indicating one of (i) the multiple prediction mode and (ii) one of the plurality of prediction modes including the triangular mode, a parameter having a ternary value indicating one of (i) the multiple prediction mode, (ii) the triangular mode, and (iii) another inter prediction mode, or a parameter having a multiple value greater than the ternary value.</p><p id="p-0770" num="0762">Next, in Step S<b>3002</b>, the current block is encoded according to the prediction mode indicated by the first parameter. For example, as illustrated in <figref idref="DRAWINGS">FIG. <b>109</b></figref>, when the first parameter, which indicates that the prediction mode is the multiple prediction mode, is written into the bitstream, the current block is predicted in the multiple prediction mode (Step S<b>30021</b>). When the first parameter, which indicates that the prediction mode is the triangular mode, is written into the bitstream, the current block is predicted in the triangular mode (Step S<b>30022</b>). When the first parameter, which indicates that the prediction mode is another inter prediction mode, is written into the bitstream, the current block is predicted in the other inter prediction mode (Step S<b>30023</b>).</p><p id="p-0771" num="0763">It should be noted that, in the description of the present aspect, the terms &#x201c;writing&#x201d; and &#x201c;encoding&#x201d; used in the description for the encoding method and the encoding processing performed by the encoder may be replaced with the terms &#x201c;parsing&#x201d; and &#x201c;decoding&#x201d; for a decoding method and decoding processing performed by a decoder.</p><heading id="h-0096" level="2">[Technical Advantages of Third Aspect]</heading><p id="p-0772" num="0764">In the third aspect, a syntax design for the triangular mode and the multiple prediction mode is introduced. With the syntax design, it is possible to combine the multiple prediction mode with the triangular mode, and thus coding efficiency is improved. According to the third aspect, it is possible to implement a combination of the triangular mode and the multiple prediction mode without increasing the required worst-case memory access of each block.</p><heading id="h-0097" level="2">[Combination Including the Other Aspects]</heading><p id="p-0773" num="0765">At least a portion of the present aspect may be combined with at least a portion of one or more of other aspects. A portion of the processing in flowcharts, a portion of the devices, syntax, and/or other features may be combined with the other aspects.</p><p id="p-0774" num="0766">It should be noted that all the above-described processes/elements are not always required. The device/method may contain a portion of the processes/elements. The above-described processes may be performed by a decoder in the same manner as the encoder.</p><heading id="h-0098" level="2">[Fourth Aspect]</heading><p id="p-0775" num="0767">According to the fourth aspect, syntax for a triangular mode and a multiple prediction mode is designed.</p><p id="p-0776" num="0768">According to the fourth aspect, a first flag indicating whether a prediction mode is a triangular mode in which a current block is split into a plurality of partitions including at least one triangular partition is encoded, and then a second flag indicating whether a prediction mode is a multiple prediction mode in which at least one triangular partition is predicted using at least two items of prediction information is encoded. In other words, according to the fourth aspect, unlike the first aspect to the third aspect, when a parameter indicating that the prediction mode is the triangular mode and a parameter indicating that the prediction mode is the multiple prediction mode are both encoded, both of the triangular mode and the multiple prediction mode are applied to a current block.</p><p id="p-0777" num="0769"><figref idref="DRAWINGS">FIG. <b>110</b></figref> is a flowchart illustrating one example of encoding processing according to the fourth aspect. <figref idref="DRAWINGS">FIG. <b>111</b></figref> is a diagram for explaining more specifically one example of the encoding processing according to the fourth aspect.</p><p id="p-0778" num="0770">As illustrated in <figref idref="DRAWINGS">FIG. <b>110</b></figref>, in Step S<b>4001</b>, a first parameter, which indicates whether a prediction mode is the triangular mode, is written into a bitstream. For example, as illustrated in <figref idref="DRAWINGS">FIG. <b>111</b></figref>, the first parameter, which indicates whether a prediction mode is the triangular mode, is written into a bitstream.</p><p id="p-0779" num="0771">Next, in Step S<b>4002</b>, a second parameter, which indicates whether the prediction mode is the multiple prediction mode, is written into a bitstream. For example, in <figref idref="DRAWINGS">FIG. <b>111</b></figref>, when the first parameter, which indicates that the prediction mode for a current block is not the triangular mode, is written into the bitstream (No in Step S<b>4001</b>), the current block is predicted in another inter prediction mode (Step S<b>4005</b>). On the other hand, when the first parameter, which indicates that the prediction mode for the current block is the triangular mode, is written into the bitstream (Yes in Step S<b>4001</b>), a second parameter, which indicates whether the prediction mode is the multiple prediction mode, is written into the bitstream (Step S<b>4002</b>).</p><p id="p-0780" num="0772">Next, in Step S<b>4003</b>, at least one non-quadrilateral partition is encoded according to the prediction mode indicated by the first parameter and the second parameter. For example, in <figref idref="DRAWINGS">FIG. <b>111</b></figref>, when the second parameter, which indicates that the prediction mode for the current block is the multiple prediction mode, is written into the bitstream (Yes in Step S<b>4002</b>), at least one triangular partition of the current block is predicted in the multiple prediction mode (Step S<b>4003</b>). On the other hand, when the second parameter, which indicates that the prediction mode is not the multiplex prediction mode, is written into the bitstream (No in Step S<b>4002</b>), the current block is predicted in the triangular mode (Step S<b>4004</b>).</p><heading id="h-0099" level="2">[Variation of Fourth Aspect]</heading><p id="p-0781" num="0773">The following describes encoding processing according to a variation of the fourth aspect. This variation differs from the fourth aspect in that the second parameter is encoded prior to the first parameter.</p><p id="p-0782" num="0774"><figref idref="DRAWINGS">FIG. <b>112</b></figref> is a diagram for explaining one example of encoding processing according to the variation of the fourth aspect. As illustrated in <figref idref="DRAWINGS">FIG. <b>112</b></figref>, the second parameter, which indicates whether a prediction mode for a current block is the multiple mode, is written into a bitstream (Step S<b>4101</b>). When the second parameter, which indicates that the prediction mode is not the multiplex prediction mode, is written into the bitstream (No in Step S<b>4101</b>), the current block is predicted in another inter prediction mode (Step S<b>4105</b>). On the other hand, when the second parameter, which indicates that the prediction mode is the multiple prediction mode, is written into the bitstream (Yes in Step S<b>4101</b>), a first parameter, which indicates whether the prediction mode is the triangular mode, is written into the bitstream (Step S<b>4102</b>).</p><p id="p-0783" num="0775">When the first parameter, which indicates that the prediction mode is the triangular mode, is written into the bitstream (Yes in Step S<b>4102</b>), at least one triangular partition of the current block is predicted in the multiple prediction mode (Step S<b>4103</b>). On the other hand, when the first parameter, which indicates that the prediction mode is not the triangular mode, is written into the bitstream (No in Step S<b>4102</b>), the current block is predicted in the multiple prediction mode (Step S<b>4104</b>).</p><p id="p-0784" num="0776">As described above, according to the fourth aspect, the first parameter and the second parameter are both encoded, and the current block is encoded according to the prediction mode indicated by the first parameter and the second parameter.</p><p id="p-0785" num="0777">It should be noted that, in the description of the present aspect, the terms &#x201c;writing&#x201d; and &#x201c;encoding&#x201d; used in the description for the encoding method and the encoding processing performed by the encoder may be replaced with the terms &#x201c;parsing&#x201d; and &#x201c;decoding&#x201d; for a decoding method and decoding processing performed by a decoder.</p><heading id="h-0100" level="2">[Technical Advantages of Fourth Aspect]</heading><p id="p-0786" num="0778">In the fourth aspect, a syntax design for the triangular mode and the multiple prediction mode is introduced. With the syntax design, it is possible to combine the multiple prediction mode with the triangular mode, and thus coding efficiency is improved.</p><heading id="h-0101" level="2">[Combination Including the Other Aspects]</heading><p id="p-0787" num="0779">At least a portion of the present aspect may be combined with at least a portion of one or more of other aspects. A portion of the processing in flowcharts, a portion of the devices, syntax, and/or other features may be combined with the other aspects.</p><p id="p-0788" num="0780">It should be noted that all the above-described processes/elements are not always required. The device/method may contain a portion of the processes/elements. The above-described processes may be performed by a decoder in the same manner as the encoder.</p><p id="p-0789" num="0781">It should be noted that the non-quadrilateral partition may be a triangular partition.</p><p id="p-0790" num="0782">In addition, the first parameter may be a flag or an index. Likewise, the second parameter may be a flag or an index.</p><heading id="h-0102" level="2">[Supplements]</heading><p id="p-0791" num="0783">Encoder <b>100</b> and decoder <b>200</b> according to the present embodiment may be used as an image encoder and an image decoder, respectively, or as a video encoder and a video decoder, respectively.</p><p id="p-0792" num="0784">Alternatively, encoder <b>100</b> and decoder <b>200</b> may be used as an entropy encoder and an entropy decoder, respectively. In other words, encoder <b>100</b> and decoder <b>200</b> may only correspond to entropy encoder <b>110</b> and entropy decoder <b>202</b>, respectively. Other constituent elements may be included in another apparatus.</p><p id="p-0793" num="0785">Furthermore, at least part of the present embodiment may be used as an encoding method, a decoding method, an entropy encoding method, an entropy decoding method, or other methods.</p><p id="p-0794" num="0786">It should be noted that, each of the constituent elements in the present embodiment may be configured in the form of an exclusive hardware product, or may be realized by executing a software program suitable for the constituent element. Each of the constituent elements may be realized by means of a program executing unit, such as a CPU and a processor, reading and executing the software program recorded on a recording medium such as a hard disk or a semiconductor memory.</p><p id="p-0795" num="0787">More specifically, each of encoder <b>100</b> and decoder <b>200</b> may include processing circuitry and storage which is electrically connected to the processing circuitry and accessible from the processing circuitry. For example, the processing circuitry corresponds to processor a<b>1</b> or b<b>1</b>, and the storage corresponds to memory a<b>2</b> or b<b>2</b>.</p><p id="p-0796" num="0788">The processing circuitry includes at least one of the exclusive hardware and the program executing unit, and executes the processing using the storage. In addition, when the processing circuitry includes the program executing unit, the storage stores a software program that is executed by the program executing unit.</p><p id="p-0797" num="0789">Here, the software for implementing encoder <b>100</b>, decoder <b>200</b>, or the like according to this embodiment includes programs as indicated below.</p><p id="p-0798" num="0790">For example, the program may cause a computer to execute an encoding method for encoding a video. the encoding method includes: writing a first parameter into a bitstream, the first parameter indicating, as a prediction mode, one of (i) a multiple prediction mode in which a prediction image is generated by overlapping an inter prediction image of a current block and an intra prediction image of the current block and (ii) one of a plurality of prediction modes including a triangular mode in which a prediction image is generated by splitting the current block into triangular regions; and encoding the current block according to the prediction mode.</p><p id="p-0799" num="0791">In addition, for example, the program may cause a computer to execute a decoding method for decoding a video. The decoding method includes: parsing a first parameter from a bitstream, the first parameter indicating, as a prediction mode, one of (i) a multiple prediction mode in which a prediction image is generated by overlapping an inter prediction image of a current block and an intra prediction image of the current block and (ii) one of a plurality of prediction modes including a triangular mode in which a prediction image is generated by splitting the current block into triangular regions; and decoding the current block according to the prediction mode.</p><p id="p-0800" num="0792">In addition, each of the constituent elements may be circuitry as described above. The circuitry may be configured as a single circuitry as a whole, or as separate circuitries. In addition, each of the constituent elements may be implemented as a general purpose processor or as a dedicated processor.</p><p id="p-0801" num="0793">In addition, processes executed by a specific constituent element may be performed by a different constituent element. In addition, the order in which processes are performed may be changed, or a plurality of processes may be performed in parallel. In addition, an encoder/decoder may include encoder <b>100</b> and decoder <b>200</b>.</p><p id="p-0802" num="0794">The ordinal numbers such as first, second, etc. used for explanation may be arbitrarily replaced. In addition, an ordinal number may be newly added to a given one of the constituent elements, or the like, or the ordinal number of a given one of the constituent elements, or the like may be removed.</p><p id="p-0803" num="0795">Aspects of encoder <b>100</b> and decoder <b>200</b> have been described above based on the embodiments. However, aspects of encoder <b>100</b> and decoder <b>200</b> are not limited to the embodiments described above. The one or more aspects of the present disclosure may encompass embodiments obtainable by adding, to the embodiments, various kinds of modifications that a person skilled in the art would arrive at and embodiments configurable by combining constituent elements in different embodiments within the scope of the aspects of encoder <b>100</b> and decoder <b>200</b>.</p><p id="p-0804" num="0796">One of the aspects may be performed by combining at least part of the other aspects in the present disclosure. In addition, one of the aspects may be performed by combining, with other aspects, part of the processes indicated in any of the flow charts according to the aspects, part of the configuration of any of the devices, part of syntax, etc.</p><heading id="h-0103" level="2">[Implementations and Applications]</heading><p id="p-0805" num="0797">One or more of the aspects disclosed herein may be performed in combination with at least part of the other aspects in the present disclosure. In addition, one or more of the aspects disclosed herein may be performed by combining, with other aspects, part of the processes indicated in any of the flow charts according to the aspects, part of the configuration of any of the devices, part of syntaxes, etc. Aspects described with reference to a constituent element of an encoder may be performed similarly by a corresponding constituent element of a decoder.</p><heading id="h-0104" level="2">[Implementations and Applications]</heading><p id="p-0806" num="0798">As described in each of the above embodiments, each functional or operational block may typically be realized as an MPU (micro processing unit) and memory, for example. Moreover, processes performed by each of the functional blocks may be realized as a program execution unit, such as a processor which reads and executes software (a program) recorded on a recording medium such as ROM. The software may be distributed. The software may be recorded on a variety of recording media such as semiconductor memory. Note that each functional block can also be realized as hardware (dedicated circuit). Various combinations of hardware and software may be employed.</p><p id="p-0807" num="0799">The processing described in each of the embodiments may be realized via integrated processing using a single apparatus (system), and, alternatively, may be realized via decentralized processing using a plurality of apparatuses. Moreover, the processor that executes the above-described program may be a single processor or a plurality of processors. In other words, integrated processing may be performed, and, alternatively, decentralized processing may be performed.</p><p id="p-0808" num="0800">Embodiments of the present disclosure are not limited to the above exemplary embodiments; various modifications may be made to the exemplary embodiments, the results of which are also included within the scope of the embodiments of the present disclosure.</p><p id="p-0809" num="0801">Next, application examples of the moving picture encoding method (image encoding method) and the moving picture decoding method (image decoding method) described in each of the above embodiments will be described, as well as various systems that implement the application examples. Such a system may be characterized as including an image encoder that employs the image encoding method, an image decoder that employs the image decoding method, or an image encoder-decoder that includes both the image encoder and the image decoder. Other configurations of such a system may be modified on a case-by-case basis.</p><heading id="h-0105" level="2">[Usage Examples]</heading><p id="p-0810" num="0802"><figref idref="DRAWINGS">FIG. <b>113</b></figref> illustrates an overall configuration of content providing system ex<b>100</b> suitable for implementing a content distribution service. The area in which the communication service is provided is divided into cells of desired sizes, and base stations ex<b>106</b>, ex<b>107</b>, ex<b>108</b>, ex<b>109</b>, and ex<b>110</b>, which are fixed wireless stations in the illustrated example, are located in respective cells.</p><p id="p-0811" num="0803">In content providing system ex<b>100</b>, devices including computer ex<b>111</b>, gaming device ex<b>112</b>, camera ex<b>113</b>, home appliance ex<b>114</b>, and smartphone ex<b>115</b> are connected to internet ex<b>101</b> via internet service provider ex<b>102</b> or communications network ex<b>104</b> and base stations ex<b>106</b> through ex<b>110</b>. Content providing system ex<b>100</b> may combine and connect any combination of the above devices. In various implementations, the devices may be directly or indirectly connected together via a telephone network or near field communication, rather than via base stations ex<b>106</b> through ex<b>110</b>. Further, streaming server ex<b>103</b> may be connected to devices including computer ex<b>111</b>, gaming device ex<b>112</b>, camera ex<b>113</b>, home appliance ex<b>114</b>, and smartphone ex<b>115</b> via, for example, internet ex<b>101</b>. Streaming server ex<b>103</b> may also be connected to, for example, a terminal in a hotspot in airplane ex<b>117</b> via satellite ex<b>116</b>.</p><p id="p-0812" num="0804">Note that instead of base stations ex<b>106</b> through ex<b>110</b>, wireless access points or hotspots may be used. Streaming server ex<b>103</b> may be connected to communications network ex<b>104</b> directly instead of via internet ex<b>101</b> or internet service provider ex<b>102</b>, and may be connected to airplane ex<b>117</b> directly instead of via satellite ex<b>116</b>.</p><p id="p-0813" num="0805">Camera ex<b>113</b> may be a device capable of capturing still images and video, such as a digital camera. Smartphone ex<b>115</b> may be a smartphone device, cellular phone, or personal handy-phone system (PHS) phone that can operate under the mobile communications system standards of the 2G, 3G, 3.9G, and 4G systems, as well as the next-generation 5G system.</p><p id="p-0814" num="0806">Home appliance ex<b>114</b> is, for example, a refrigerator or a device included in a home fuel cell cogeneration system.</p><p id="p-0815" num="0807">In content providing system ex<b>100</b>, a terminal including an image and/or video capturing function is capable of, for example, live streaming by connecting to streaming server ex<b>103</b> via, for example, base station ex<b>106</b>. When live streaming, a terminal (e.g., computer ex<b>111</b>, gaming device ex<b>112</b>, camera ex<b>113</b>, home appliance ex<b>114</b>, smartphone ex<b>115</b>, or a terminal in airplane ex<b>117</b>) may perform the encoding processing described in the above embodiments on still-image or video content captured by a user via the terminal, may multiplex video data obtained via the encoding and audio data obtained by encoding audio corresponding to the video, and may transmit the obtained data to streaming server ex<b>103</b>. In other words, the terminal functions as the image encoder according to one aspect of the present disclosure.</p><p id="p-0816" num="0808">Streaming server ex<b>103</b> streams transmitted content data to clients that request the stream. Client examples include computer ex<b>111</b>, gaming device ex<b>112</b>, camera ex<b>113</b>, home appliance ex<b>114</b>, smartphone ex<b>115</b>, and terminals inside airplane ex<b>117</b>, which are capable of decoding the above-described encoded data. Devices that receive the streamed data may decode and reproduce the received data. In other words, the devices may each function as the image decoder, according to one aspect of the present disclosure.</p><heading id="h-0106" level="2">[Decentralized Processing]</heading><p id="p-0817" num="0809">Streaming server ex<b>103</b> may be realized as a plurality of servers or computers between which tasks such as the processing, recording, and streaming of data are divided. For example, streaming server ex<b>103</b> may be realized as a content delivery network (CDN) that streams content via a network connecting multiple edge servers located throughout the world. In a CDN, an edge server physically near the client may be dynamically assigned to the client. Content is cached and streamed to the edge server to reduce load times. In the event of, for example, some type of error or change in connectivity due, for example, to a spike in traffic, it is possible to stream data stably at high speeds, since it is possible to avoid affected parts of the network by, for example, dividing the processing between a plurality of edge servers, or switching the streaming duties to a different edge server and continuing streaming.</p><p id="p-0818" num="0810">Decentralization is not limited to just the division of processing for streaming; the encoding of the captured data may be divided between and performed by the terminals, on the server side, or both. In one example, in typical encoding, the processing is performed in two loops. The first loop is for detecting how complicated the image is on a frame-by-frame or scene-by-scene basis, or detecting the encoding load. The second loop is for processing that maintains image quality and improves encoding efficiency. For example, it is possible to reduce the processing load of the terminals and improve the quality and encoding efficiency of the content by having the terminals perform the first loop of the encoding and having the server side that received the content perform the second loop of the encoding. In such a case, upon receipt of a decoding request, it is possible for the encoded data resulting from the first loop performed by one terminal to be received and reproduced on another terminal in approximately real time. This makes it possible to realize smooth, real-time streaming.</p><p id="p-0819" num="0811">In another example, camera ex<b>113</b> or the like extracts a feature amount (an amount of features or characteristics) from an image, compresses data related to the feature amount as metadata, and transmits the compressed metadata to a server. For example, the server determines the significance of an object based on the feature amount, and changes the quantization accuracy accordingly to perform compression suitable for the meaning (or content significance) of the image. Feature amount data is particularly effective in improving the precision and efficiency of motion vector prediction during the second compression pass performed by the server. Moreover, encoding that has a relatively low processing load, such as variable length coding (VLC), may be handled by the terminal, and encoding that has a relatively high processing load, such as context-adaptive binary arithmetic coding (CABAC), may be handled by the server.</p><p id="p-0820" num="0812">In yet another example, there are instances in which a plurality of videos of approximately the same scene are captured by a plurality of terminals in, for example, a stadium, shopping mall, or factory. In such a case, for example, the encoding may be decentralized by dividing processing tasks between the plurality of terminals that captured the videos and, if necessary, other terminals that did not capture the videos, and the server, on a per-unit basis. The units may be, for example, groups of pictures (GOP), pictures, or tiles resulting from dividing a picture. This makes it possible to reduce load times and achieve streaming that is closer to real time.</p><p id="p-0821" num="0813">Since the videos are of approximately the same scene, management and/or instructions may be carried out by the server so that the videos captured by the terminals can be cross-referenced. Moreover, the server may receive encoded data from the terminals, change the reference relationship between items of data, or correct or replace pictures themselves, and then perform the encoding. This makes it possible to generate a stream with increased quality and efficiency for the individual items of data.</p><p id="p-0822" num="0814">Furthermore, the server may stream video data after performing transcoding to convert the encoding format of the video data. For example, the server may convert the encoding format from MPEG to VP (e.g., VP9), may convert H.264 to H.265, etc.</p><p id="p-0823" num="0815">In this way, encoding can be performed by a terminal or one or more servers. Accordingly, although the device that performs the encoding is referred to as a &#x201c;server&#x201d; or &#x201c;terminal&#x201d; in the following description, some or all of the processes performed by the server may be performed by the terminal, and likewise some or all of the processes performed by the terminal may be performed by the server. This also applies to decoding processes.</p><heading id="h-0107" level="2">[3D, Multi-Angle]</heading><p id="p-0824" num="0816">There has been an increase in usage of images or videos combined from images or videos of different scenes concurrently captured, or of the same scene captured from different angles, by a plurality of terminals such as camera ex<b>113</b> and/or smartphone ex<b>115</b>. Videos captured by the terminals may be combined based on, for example, the separately obtained relative positional relationship between the terminals, or regions in a video having matching feature points.</p><p id="p-0825" num="0817">In addition to the encoding of two-dimensional moving pictures, the server may encode a still image based on scene analysis of a moving picture, for example automatically or at a point in time specified by the user, and transmit the encoded still image to a reception terminal. Furthermore, when the server can obtain the relative positional relationship between the video capturing terminals, in addition to two-dimensional moving pictures, the server can generate three-dimensional geometry of a scene based on video of the same scene captured from different angles. The server may separately encode three-dimensional data generated from, for example, a point cloud and, based on a result of recognizing or tracking a person or object using three-dimensional data, may select or reconstruct and generate a video to be transmitted to a reception terminal, from videos captured by a plurality of terminals.</p><p id="p-0826" num="0818">This allows the user to enjoy a scene by freely selecting videos corresponding to the video capturing terminals, and allows the user to enjoy the content obtained by extracting a video at a selected viewpoint from three-dimensional data reconstructed from a plurality of images or videos. Furthermore, as with video, sound may be recorded from relatively different angles, and the server may multiplex audio from a specific angle or space with the corresponding video, and transmit the multiplexed video and audio.</p><p id="p-0827" num="0819">In recent years, content that is a composite of the real world and a virtual world, such as virtual reality (VR) and augmented reality (AR) content, has also become popular. In the case of VR images, the server may create images from the viewpoints of both the left and right eyes, and perform encoding that tolerates reference between the two viewpoint images, such as multi-view coding (MVC), and, alternatively, may encode the images as separate streams without referencing. When the images are decoded as separate streams, the streams may be synchronized when reproduced, so as to recreate a virtual three-dimensional space in accordance with the viewpoint of the user.</p><p id="p-0828" num="0820">In the case of AR images, the server may superimpose virtual object information existing in a virtual space onto camera information representing a real-world space, for example based on a three-dimensional position or movement from the perspective of the user. The decoder may obtain or store virtual object information and three-dimensional data, generate two-dimensional images based on movement from the perspective of the user, and then generate superimposed data by seamlessly connecting the images. Alternatively, the decoder may transmit, to the server, motion from the perspective of the user in addition to a request for virtual object information. The server may generate superimposed data based on three-dimensional data stored in the server in accordance with the received motion, and encode and stream the generated superimposed data to the decoder. Note that superimposed data typically includes, in addition to RGB values, an a value indicating transparency, and the server sets the a value for sections other than the object generated from three-dimensional data to, for example, 0, and may perform the encoding while those sections are transparent. Alternatively, the server may set the background to a determined RGB value, such as a chroma key, and generate data in which areas other than the object are set as the background. The determined RGB value may be predetermined.</p><p id="p-0829" num="0821">Decoding of similarly streamed data may be performed by the client (e.g., the terminals), on the server side, or be divided therebetween. In one example, one terminal may transmit a reception request to a server, the requested content may be received and decoded by another terminal, and a decoded signal may be transmitted to a device having a display. It is possible to reproduce high image quality data by decentralizing processing and appropriately selecting content regardless of the processing ability of the communications terminal itself. In yet another example, while a TV, for example, is receiving image data that is large in size, a region of a picture, such as a tile obtained by dividing the picture, may be decoded and displayed on a personal terminal or terminals of a viewer or viewers of the TV. This makes it possible for the viewers to share a big-picture view as well as for each viewer to check his or her assigned area, or inspect a region in further detail up close.</p><p id="p-0830" num="0822">In situations in which a plurality of wireless connections are possible over near, mid, and far distances, indoors or outdoors, it may be possible to seamlessly receive content using a streaming system standard such as MPEG-DASH. The user may switch between data in real time while freely selecting a decoder or display apparatus including the user's terminal, displays arranged indoors or outdoors, etc. Moreover, using, for example, information on the position of the user, decoding can be performed while switching which terminal handles decoding and which terminal handles the displaying of content. This makes it possible to map and display information, while the user is on the move in route to a destination, on the wall of a nearby building in which a device capable of displaying content is embedded, or on part of the ground. Moreover, it is also possible to switch the bit rate of the received data based on the accessibility to the encoded data on a network, such as when encoded data is cached on a server quickly accessible from the reception terminal, or when encoded data is copied to an edge server in a content delivery service.</p><heading id="h-0108" level="2">[Web Page Optimization]</heading><p id="p-0831" num="0823"><figref idref="DRAWINGS">FIG. <b>114</b></figref> illustrates an example of a display screen of a web page on computer ex<b>111</b>, for example. <figref idref="DRAWINGS">FIG. <b>115</b></figref> illustrates an example of a display screen of a web page on smartphone ex<b>115</b>, for example. As illustrated in <figref idref="DRAWINGS">FIG. <b>114</b></figref> and <figref idref="DRAWINGS">FIG. <b>115</b></figref>, a web page may include a plurality of image links that are links to image content, and the appearance of the web page may differ depending on the device used to view the web page. When a plurality of image links are viewable on the screen, until the user explicitly selects an image link, or until the image link is in the approximate center of the screen or the entire image link fits in the screen, the display apparatus (decoder) may display, as the image links, still images included in the content or I pictures; may display video such as an animated gif using a plurality of still images or I pictures; or may receive only the base layer, and decode and display the video.</p><p id="p-0832" num="0824">When an image link is selected by the user, the display apparatus performs decoding while, for example, giving the highest priority to the base layer. Note that if there is information in the HTML code of the web page indicating that the content is scalable, the display apparatus may decode up to the enhancement layer. Further, in order to facilitate real-time reproduction, before a selection is made or when the bandwidth is severely limited, the display apparatus can reduce delay between the point in time at which the leading picture is decoded and the point in time at which the decoded picture is displayed (that is, the delay between the start of the decoding of the content to the displaying of the content) by decoding and displaying only forward reference pictures (I picture, P picture, forward reference B picture). Still further, the display apparatus may purposely ignore the reference relationship between pictures, and coarsely decode all B and P pictures as forward reference pictures, and then perform normal decoding as the number of pictures received over time increases.</p><heading id="h-0109" level="2">[Autonomous Driving]</heading><p id="p-0833" num="0825">When transmitting and receiving still image or video data such as two- or three-dimensional map information for autonomous driving or assisted driving of an automobile, the reception terminal may receive, in addition to image data belonging to one or more layers, information on, for example, the weather or road construction as metadata, and associate the metadata with the image data upon decoding. Note that metadata may be assigned per layer and, alternatively, may simply be multiplexed with the image data.</p><p id="p-0834" num="0826">In such a case, since the automobile, drone, airplane, etc., containing the reception terminal is mobile, the reception terminal may seamlessly receive and perform decoding while switching between base stations among base stations ex<b>106</b> through ex<b>110</b> by transmitting information indicating the position of the reception terminal. Moreover, in accordance with the selection made by the user, the situation of the user, and/or the bandwidth of the connection, the reception terminal may dynamically select to what extent the metadata is received, or to what extent the map information, for example, is updated.</p><p id="p-0835" num="0827">In content providing system ex<b>100</b>, the client may receive, decode, and reproduce, in real time, encoded information transmitted by the user.</p><heading id="h-0110" level="2">[Streaming of Individual Content]</heading><p id="p-0836" num="0828">In content providing system ex<b>100</b>, in addition to high image quality, long content distributed by a video distribution entity, unicast or multicast streaming of low image quality, and short content from an individual are also possible. Such content from individuals is likely to further increase in popularity. The server may first perform editing processing on the content before the encoding processing, in order to refine the individual content. This may be achieved using the following configuration, for example.</p><p id="p-0837" num="0829">In real time while capturing video or image content, or after the content has been captured and accumulated, the server performs recognition processing based on the raw data or encoded data, such as capture error processing, scene search processing, meaning analysis, and/or object detection processing. Then, based on the result of the recognition processing, the server&#x2014;for example when prompted or automatically&#x2014;edits the content, examples of which include: correction such as focus and/or motion blur correction; removing low-priority scenes such as scenes that are low in brightness compared to other pictures, or out of focus; object edge adjustment; and color tone adjustment. The server encodes the edited data based on the result of the editing. It is known that excessively long videos tend to receive fewer views. Accordingly, in order to keep the content within a specific length that scales with the length of the original video, the server may, in addition to the low-priority scenes described above, automatically clip out scenes with low movement, based on an image processing result. Alternatively, the server may generate and encode a video digest based on a result of an analysis of the meaning of a scene.</p><p id="p-0838" num="0830">There may be instances in which individual content may include content that infringes a copyright, moral right, portrait rights, etc. Such instance may lead to an unfavorable situation for the creator, such as when content is shared beyond the scope intended by the creator. Accordingly, before encoding, the server may, for example, edit images so as to blur faces of people in the periphery of the screen or blur the inside of a house, for example. Further, the server may be configured to recognize the faces of people other than a registered person in images to be encoded, and when such faces appear in an image, may apply a mosaic filter, for example, to the face of the person. Alternatively, as pre- or post-processing for encoding, the user may specify, for copyright reasons, a region of an image including a person or a region of the background to be processed. The server may process the specified region by, for example, replacing the region with a different image, or blurring the region. If the region includes a person, the person may be tracked in the moving picture, and the person's head region may be replaced with another image as the person moves.</p><p id="p-0839" num="0831">Since there is a demand for real-time viewing of content produced by individuals, which tends to be small in data size, the decoder may first receive the base layer as the highest priority, and perform decoding and reproduction, although this may differ depending on bandwidth. When the content is reproduced two or more times, such as when the decoder receives the enhancement layer during decoding and reproduction of the base layer, and loops the reproduction, the decoder may reproduce a high image quality video including the enhancement layer. If the stream is encoded using such scalable encoding, the video may be low quality when in an unselected state or at the start of the video, but it can offer an experience in which the image quality of the stream progressively increases in an intelligent manner. This is not limited to just scalable encoding; the same experience can be offered by configuring a single stream from a low quality stream reproduced for the first time and a second stream encoded using the first stream as a reference.</p><heading id="h-0111" level="2">[Other Implementation and Application Examples]</heading><p id="p-0840" num="0832">The encoding and decoding may be performed by LSI (large scale integration circuitry) ex<b>500</b> (see <figref idref="DRAWINGS">FIG. <b>113</b></figref>), which is typically included in each terminal. LSI ex<b>500</b> may be configured from a single chip or a plurality of chips. Software for encoding and decoding moving pictures may be integrated into some type of a recording medium (such as a CD-ROM, a flexible disk, or a hard disk) that is readable by, for example, computer ex<b>111</b>, and the encoding and decoding may be performed using the software. Furthermore, when smartphone ex<b>115</b> is equipped with a camera, the video data obtained by the camera may be transmitted. In this case, the video data may be coded by LSI ex<b>500</b> included in smartphone ex<b>115</b>.</p><p id="p-0841" num="0833">Note that LSI ex<b>500</b> may be configured to download and activate an application. In such a case, the terminal first determines whether it is compatible with the scheme used to encode the content, or whether it is capable of executing a specific service. When the terminal is not compatible with the encoding scheme of the content, or when the terminal is not capable of executing a specific service, the terminal may first download a codec or application software and then obtain and reproduce the content.</p><p id="p-0842" num="0834">Aside from the example of content providing system ex<b>100</b> that uses internet ex<b>101</b>, at least the moving picture encoder (image encoder) or the moving picture decoder (image decoder) described in the above embodiments may be implemented in a digital broadcasting system. The same encoding processing and decoding processing may be applied to transmit and receive broadcast radio waves superimposed with multiplexed audio and video data using, for example, a satellite, even though this is geared toward multicast, whereas unicast is easier with content providing system ex<b>100</b>.</p><heading id="h-0112" level="2">[Hardware Configuration]</heading><p id="p-0843" num="0835"><figref idref="DRAWINGS">FIG. <b>116</b></figref> illustrates further details of an example smartphone ex<b>115</b> shown in <figref idref="DRAWINGS">FIG. <b>113</b></figref>. <figref idref="DRAWINGS">FIG. <b>117</b></figref> illustrates a functional configuration example of a smartphone ex<b>115</b>. Smartphone ex<b>115</b> includes antenna ex<b>450</b> for transmitting and receiving radio waves to and from base station ex<b>110</b>, camera ex<b>465</b> capable of capturing video and still images, and display ex<b>458</b> that displays decoded data, such as video captured by camera ex<b>465</b> and video received by antenna ex<b>450</b>. Smartphone ex<b>115</b> further includes user interface ex<b>466</b> such as a touch panel; audio output unit ex<b>457</b> such as a speaker for outputting speech or other audio; audio input unit ex<b>456</b> such as a microphone for audio input; memory ex<b>467</b> capable of storing decoded data such as captured video or still images, recorded audio, received video or still images, and mail, as well as decoded data; and slot ex<b>464</b> which is an interface for SIM ex<b>468</b> for authorizing access to a network and various data. Note that external memory may be used instead of or in addition to memory ex<b>467</b>.</p><p id="p-0844" num="0836">Main controller ex<b>460</b>, which may comprehensively control display ex<b>458</b> and user interface ex<b>466</b>, power supply circuit ex<b>461</b>, user interface input controller ex<b>462</b>, video signal processor ex<b>455</b>, camera interface ex<b>463</b>, display controller ex<b>459</b>, modulator/demodulator ex<b>452</b>, multiplexer/demultiplexer ex<b>453</b>, audio signal processor ex<b>454</b>, slot ex<b>464</b>, and memory ex<b>467</b> are connected via bus ex<b>470</b>.</p><p id="p-0845" num="0837">When the user turns on the power button of power supply circuit ex<b>461</b>, smartphone ex<b>115</b> is powered on into an operable state, and each component is supplied with power, for example, from a battery pack.</p><p id="p-0846" num="0838">Smartphone ex<b>115</b> performs processing for, for example, calling and data transmission, based on control performed by main controller ex<b>460</b>, which includes a CPU, ROM, and RAM. When making calls, an audio signal recorded by audio input unit ex<b>456</b> is converted into a digital audio signal by audio signal processor ex<b>454</b>, to which spread spectrum processing is applied by modulator/demodulator ex<b>452</b> and digital-analog conversion, and frequency conversion processing is applied by transmitter/receiver ex<b>451</b>, and the resulting signal is transmitted via antenna ex<b>450</b>. The received data is amplified, frequency converted, and analog-digital converted, inverse spread spectrum processed by modulator/demodulator ex<b>452</b>, converted into an analog audio signal by audio signal processor ex<b>454</b>, and then output from audio output unit ex<b>457</b>.</p><p id="p-0847" num="0839">In data transmission mode, text, still-image, or video data may be transmitted under control of main controller ex<b>460</b> via user interface input controller ex<b>462</b> based on operation of user interface ex<b>466</b> of the main body, for example. Similar transmission and reception processing is performed. In data transmission mode, when sending a video, still image, or video and audio, video signal processor ex<b>455</b> compression encodes, via the moving picture encoding method described in the above embodiments, a video signal stored in memory ex<b>467</b> or a video signal input from camera ex<b>465</b>, and transmits the encoded video data to multiplexer/demultiplexer ex<b>453</b>. Audio signal processor ex<b>454</b> encodes an audio signal recorded by audio input unit ex<b>456</b> while camera ex<b>465</b> is capturing a video or still image, and transmits the encoded audio data to multiplexer/demultiplexer ex<b>453</b>. Multiplexer/demultiplexer ex<b>453</b> multiplexes the encoded video data and encoded audio data using a determined scheme, modulates and converts the data using modulator/demodulator (modulator/demodulator circuit) ex<b>452</b> and transmitter/receiver ex<b>451</b>, and transmits the result via antenna ex<b>450</b>. The determined scheme may be predetermined.</p><p id="p-0848" num="0840">When video appended in an email or a chat, or a video linked from a web page, is received, for example, in order to decode the multiplexed data received via antenna ex<b>450</b>, multiplexer/demultiplexer ex<b>453</b> demultiplexes the multiplexed data to divide the multiplexed data into a bitstream of video data and a bitstream of audio data, supplies the encoded video data to video signal processor ex<b>455</b> via synchronous bus ex<b>470</b>, and supplies the encoded audio data to audio signal processor ex<b>454</b> via synchronous bus ex<b>470</b>. Video signal processor ex<b>455</b> decodes the video signal using a moving picture decoding method corresponding to the moving picture encoding method described in the above embodiments, and video or a still image included in the linked moving picture file is displayed on display ex<b>458</b> via display controller ex<b>459</b>. Audio signal processor ex<b>454</b> decodes the audio signal and outputs audio from audio output unit ex<b>457</b>. Since real-time streaming is becoming increasingly popular, there may be instances in which reproduction of the audio may be socially inappropriate, depending on the user's environment. Accordingly, as an initial value, a configuration in which only video data is reproduced, e.g., the audio signal is not reproduced, may be preferable; audio may be synchronized and reproduced only when an input, such as when the user clicks video data, is received.</p><p id="p-0849" num="0841">Although smartphone ex<b>115</b> was used in the above example, other implementations are conceivable: a transceiver terminal including both an encoder and a decoder; a transmitter terminal including only an encoder; and a receiver terminal including only a decoder. In the description of the digital broadcasting system, an example is given in which multiplexed data obtained as a result of video data being multiplexed with audio data is received or transmitted. The multiplexed data, however, may be video data multiplexed with data other than audio data, such as text data related to the video. Further, the video data itself rather than multiplexed data may be received or transmitted.</p><p id="p-0850" num="0842">Although main controller ex<b>460</b> including a CPU is described as controlling the encoding or decoding processes, various terminals often include graphics processing units (GPUs). Accordingly, a configuration is acceptable in which a large area is processed at once by making use of the performance ability of the GPU via memory shared by the CPU and GPU, or memory including an address that is managed so as to allow common usage by the CPU and GPU, or via separate memories. This makes it possible to shorten encoding time, maintain the real-time nature of the stream, and reduce delay. In particular, processing relating to motion estimation, deblocking filtering, sample adaptive offset (SAO), and transformation/quantization can be effectively carried out by the GPU instead of the CPU in units of pictures, for example, all at once.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-math idrefs="MATH-US-00001 MATH-US-00001-2" nb-file="US20230007243A1-20230105-M00001.NB"><img id="EMI-M00001" he="15.83mm" wi="76.20mm" file="US20230007243A1-20230105-M00001.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00002 MATH-US-00002-2" nb-file="US20230007243A1-20230105-M00002.NB"><img id="EMI-M00002" he="15.83mm" wi="76.20mm" file="US20230007243A1-20230105-M00002.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. An encoder which encodes a video, comprising:<claim-text>circuitry; and</claim-text><claim-text>memory coupled to the circuitry, wherein</claim-text><claim-text>the circuitry, in operation,</claim-text><claim-text>obtains a current block from a coding tree unit (CTU);</claim-text><claim-text>stores a first parameter into a bitstream, the first parameter indicating, as a prediction mode, one of (i) a multiple prediction mode in which a prediction image is generated by overlapping an inter prediction image of the current block and an intra prediction image of the current block and (ii) one of a plurality of prediction modes including a non-rectangular mode in which a prediction image is generated for each non-rectangular partition in the current block; and</claim-text><claim-text>encodes the current block according to the prediction mode, wherein encoding the current block using the multiple prediction mode and encoding the current block using the non-rectangular mode are mutually exclusive.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. A decoder which decodes a video, comprising:<claim-text>circuitry; and</claim-text><claim-text>memory coupled to the circuitry, wherein</claim-text><claim-text>the circuitry, in operation,</claim-text><claim-text>obtains a current block from a coding tree unit (CTU);</claim-text><claim-text>parses a first parameter from a bitstream, the first parameter indicating, as a prediction mode, one of (i) a multiple prediction mode in which a prediction image is generated by overlapping an inter prediction image of the current block and an intra prediction image of the current block and (ii) one of a plurality of prediction modes including a non-rectangular mode in which a prediction image is generated for each non-rectangular partition in the current block; and</claim-text><claim-text>decodes the current block according to the prediction mode, wherein decoding the current block using the multiple prediction mode and decoding the current block using the non-rectangular mode are mutually exclusive.</claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. A non-transitory computer readable medium storing a bitstream, the bitstream including information according to which a decoder performs a prediction mode, the information indicating, as a prediction mode, one of (i) a multiple prediction mode in which a prediction image is generated by overlapping an inter prediction image of a current block and an intra prediction image of the current block and (ii) one of a plurality of prediction modes including a non-rectangular mode in which a prediction image is generated for each non-rectangular partition in the current block, wherein,<claim-text>in the prediction mode:</claim-text><claim-text>the current block is obtained from a coding tree unit (CTU); and</claim-text><claim-text>the current block is decoded according to the prediction mode, wherein decoding the current block using the multiple prediction mode and decoding the current block using the non-rectangular mode are mutually exclusive.</claim-text></claim-text></claim></claims></us-patent-application>