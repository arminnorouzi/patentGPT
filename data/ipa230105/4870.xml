<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004871A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004871</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17364787</doc-number><date>20210630</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>N</subclass><main-group>20</main-group><subgroup>10</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>38</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>30</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>17</main-group><subgroup>16</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>N</subclass><main-group>3</main-group><subgroup>02</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>N</subclass><main-group>20</main-group><subgroup>10</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>3867</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>30141</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>3887</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>17</main-group><subgroup>16</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>N</subclass><main-group>3</main-group><subgroup>02</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">MACHINE LEARNING CLUSTER PIPELINE FUSION</invention-title><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Advanced Micro Devices, Inc.</orgname><address><city>Santa Clara</city><state>CA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Sakharshete</last-name><first-name>Swapnil P.</first-name><address><city>San Diego</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Kazakov</last-name><first-name>Maxim V.</first-name><address><city>San Diego</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>Nemlekar</last-name><first-name>Milind N.</first-name><address><city>San Diego</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="03" designation="us-only"><addressbook><last-name>Wasmundt</last-name><first-name>Samuel Lawrence</first-name><address><city>San Diego</city><state>CA</state><country>US</country></address></addressbook></inventor></inventors></us-parties><assignees><assignee><addressbook><orgname>Advanced Micro Devices, Inc.</orgname><role>02</role><address><city>Santa Clara</city><state>CA</state><country>US</country></address></addressbook></assignee></assignees></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">Methods, systems, and devices for pipeline fusion of a plurality of kernels. In some implementations, a first batch of a first kernel is executed on a first processing device to generate a first output of the first kernel based on an input. A first batch of a second kernel is executed on a second processing device to generate a first output of the second kernel based on the first output of the first kernel. A second batch of the first kernel is executed on the first processing device to generate a second output of the first kernel based on the input. The execution of the second batch of the first kernel overlaps at least partially in time with executing the first batch of the second kernel.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="91.27mm" wi="158.75mm" file="US20230004871A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="168.49mm" wi="146.13mm" orientation="landscape" file="US20230004871A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="212.94mm" wi="153.42mm" orientation="landscape" file="US20230004871A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="208.87mm" wi="150.88mm" orientation="landscape" file="US20230004871A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="223.35mm" wi="157.48mm" orientation="landscape" file="US20230004871A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="171.79mm" wi="151.21mm" orientation="landscape" file="US20230004871A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="216.66mm" wi="150.96mm" orientation="landscape" file="US20230004871A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="223.52mm" wi="143.26mm" orientation="landscape" file="US20230004871A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="218.61mm" wi="145.71mm" file="US20230004871A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">BACKGROUND</heading><p id="p-0002" num="0001">Machine learning (e.g., deep learning) is widely used in a variety of technologies (e.g., image classification) to make predictions or decisions to perform a particular task (e.g., whether an image includes a certain object). For example, a convolutional neural network (CNN) is a class of deep learning algorithms widely used in machine learning applications. These networks typically include multiple layers. At each layer, a set of filters is applied to the output of previous layer, and the outputs of each layer are written to and read from memory.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0002" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0003" num="0002">A more detailed understanding can be had from the following description, given by way of example in conjunction with the accompanying drawings wherein:</p><p id="p-0004" num="0003"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram of an example device in which one or more features of the disclosure can be implemented;</p><p id="p-0005" num="0004"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a block diagram of the device of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, illustrating additional detail;</p><p id="p-0006" num="0005"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a block diagram illustrating example components of an accelerated processing device for implementing one or more features of the present disclosure;</p><p id="p-0007" num="0006"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a block diagram illustrating example components of a GPU shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref> with additional detail;</p><p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a block diagram illustrating example interconnections between components of the accelerated processing device shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref>;</p><p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a flow diagram illustrating an example machine learning task;</p><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a block diagram illustrating example operations of execution of kernels of a dot-product operation; and</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a flow chart illustrating an example method for pipeline fusion of a first kernel and a second kernel.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0003" level="1">DETAILED DESCRIPTION</heading><p id="p-0012" num="0011">Machine learning models typically use significant memory bandwidth, which can lead to bandwidth bottlenecks, negatively impacting performance, and increasing power consumption. The amount of memory used to store output data at different layers of machine learning neural networks is typically large enough that the data cannot be saved in on-chip memory. Accordingly, storing the data includes transfer of the data to and from off-chip memory.</p><p id="p-0013" num="0012">Deep learning algorithms (e.g., CNNs, recurrent neural networks and other forms of artificial neural networks) typically include matrix multiplication operations. Accelerated processors, such as GPUs, have been used to perform matrix multiplication using techniques which employ parallelization to increase the efficiency of matrix multiplication. For example, two matrices are typically divided into smaller portions (e.g., columns, rows, and portions of columns and rows) and a matrix multiplication operation of the two matrices is performed by executing a plurality of matrix multiplication computations each including the multiplication of a portion of one matrix with a portion of another matrix. The matrix multiplication computations are mapped to and executed by different processor cores of a processor network to perform the matrix multiplication operation.</p><p id="p-0014" num="0013">Conventional GPU architectures are not well suited for machine learning. Operations processed during execution of machine learning applications, typically include a series of operations, such as matrix multiplication operations followed by other operations (e.g., post matrix multiplication operations, such as point operations) in which operations are performed using the data resulting from the matrix multiplication operations. The data resulting from the matrix multiplication operations is processed, during these post matrix multiplication operations, in the CUs of the GPU. Accordingly, if sufficient bandwidth is not available for the CUs to access the resulting data, bottlenecks occur. The cache subsystem architecture (e.g., L1, L2 cache and so on) of conventional GPUs does not, however, typically have capacities large enough to hold intermediate data, e.g., between neural network layers, and accordingly, CUs typically fetch data from slower system memory, which negatively impacts the overall performance.</p><p id="p-0015" num="0014">It may be desired to provide a GPU architecture which instantiates dedicated arithmetic logic units ALUs which are separate from each CU, and which are configured to perform matrix multiplication operations and post matrix multiplication operations.</p><p id="p-0016" num="0015">For example, matrix multiplication typically includes reusable data. When two matrices are multiplied, the data for the first matrix is used for multiple blocks of the second matrix. Thus, the same data for the first matrix is fetched repeatedly into different CUs to multiply with blocks of another matrix. That is, bottlenecks (i.e., matrix multiplication bottlenecks) may result because the same data is inefficiently fetched multiple times, e.g., from the cache subsystem architecture of the GPU, for the dedicated arithmetic logic units ALUs in each CU.</p><p id="p-0017" num="0016">Some implementations provide accelerated processors designed for data reuse which include interconnects between the ALUs instantiated in each CU for data sharing between CUs to reduce these matrix multiplication bottlenecks. In some implementations, these dedicated accelerated processors, however, are not well suited for executing non-matrix multiplication operations.</p><p id="p-0018" num="0017">Accordingly, some implementations provide devices and methods for efficiently executing matrix multiplication operations and non-matrix multiplication operations. Features of the present disclosure include ALUs instantiated separately from the CUs, and dedicated ALU interconnects connecting the ALUs and configured to provide shared access to data by the CUs. In some implementations, each ALU includes its own register file, which may be referred to as a &#x201c;scratchpad&#x201d; memory, for storing the data provided to the ALUs and receiving data resulting operations executed on the ALUs, such as matrix multiplication calculations. In some implementations, the register files are accessible by each CU to store data which the ALUs use to perform certain operations (e.g., matrix multiplication), and accessible by each CU to read the data to perform other operations (e.g., softmax, scaling, or other non-matrix-multiplication or post-matrix-multiplication operations).</p><p id="p-0019" num="0018">Some implementations provide a method for pipeline fusion of a plurality of kernels. A first batch of a first kernel is executed on a first processing device to generate a first output of the first kernel based on an input. A first batch of a second kernel is executed on a second processing device to generate a first output of the second kernel based on the first output of the first kernel. A second batch of the first kernel is executed on the first processing device to generate a second output of the first kernel based on the input. The execution of the second batch of the first kernel overlaps at least partially in time with executing the first batch of the second kernel.</p><p id="p-0020" num="0019">In some implementations, a first batch of a third kernel is executed to generate a first output of the third kernel based on the first output of the second kernel. In some implementations, executing the first batch of the third kernel overlaps at least partially in time with executing the second batch of the second kernel. In some implementations, a second batch of the third kernel is executed to generate a second output of the third kernel based on the second output of the second kernel, and concatenating the first output of the third kernel is concatenated with the second output of the third kernel to generate an output of the plurality of kernels. In some implementations, the first output of the first kernel is written to a scratch memory of the first processing device by the first processing device. In some implementations, the first output of the first kernel is read from the scratch memory of the first processing device by the second processing device. In some implementations, the first output of the first kernel is written to a register file of the first processing device by the first processing device. In some implementations, the first output of the first kernel is read from the register file of the first processing device by the second processing device. In some implementations, the first processing device includes an arithmetic logic unit (ALU). In some implementations, the second processing device includes a compute unit (CU). In some implementations, the first kernel performs a matrix multiply operation and the second kernel does not perform a matrix multiply operation.</p><p id="p-0021" num="0020">Some implementations provide a processor configured for pipeline fusion of a plurality of kernels. The processor includes a first processing device configured to execute a first batch of a first kernel to generate a first output of the first kernel based on an input. The processor also includes a second processing device configured to execute a first batch of a second kernel to generate a first output of the second kernel based on the first output of the first kernel. The first processing device is configured to execute a second batch of the first kernel to generate a second output of the first kernel based on the input. The first processing device is also configured to execute the second batch of the first kernel overlapping in time at least partially with the second processing device executing the first batch of the second kernel.</p><p id="p-0022" num="0021">In some implementations, the first processing device is configured to execute a first batch of a third kernel to generate a first output of the third kernel based on the first output of the second kernel. In some implementations, the first processing device is configured to execute the first batch of the third kernel overlapping at least partially in time with the second processing device executing the second batch of the second kernel. In some implementations, the first processing device is configured to execute a second batch of the third kernel to generate a second output of the third kernel based on the second output of the second kernel. In some implementations, the processor includes circuitry configured to concatenate the first output of the third kernel with the second output of the third kernel to generate an output of the plurality of kernels. In some implementations, the first processing device is configured to write the first output of the first kernel to a scratch memory of the first processing device. In some implementations, the second processing device is configured to read the first output of the first kernel from the scratch memory of the first processing device. In some implementations, the first processing device is configured to write the first output of the first kernel is to a register file of the first processing device. In some implementations, the second processing device is configured to read the first output of the first kernel from the register file of the first processing device. In some implementations, the first processing device comprises an arithmetic logic unit (ALU). In some implementations, the second processing device comprises a compute unit (CU). In some implementations, the processor includes circuitry configured to copy the first output of the first kernel from a scratch memory of the first processing device to a cache memory.</p><p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram of an example device <b>100</b> in which one or more features of the disclosure can be implemented. The device <b>100</b> can include, for example, a computer, a gaming device, a handheld device, a set-top box, a television, a mobile phone, server, a tablet computer or other types of computing devices. The device <b>100</b> includes a processor <b>102</b>, a memory <b>104</b>, a storage <b>106</b>, one or more input devices <b>108</b>, and one or more output devices <b>110</b>. The device <b>100</b> can also optionally include an input driver <b>112</b> and an output driver <b>114</b>. It is understood that the device <b>100</b> can include additional components not shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0024" num="0023">In various alternatives, the processor <b>102</b> includes a central processing unit (CPU), a graphics processing unit (GPU), a CPU and GPU located on the same die, or one or more processor cores, wherein each processor core can be a CPU or a GPU. In various alternatives, the memory <b>104</b> is located on the same die as the processor <b>102</b>, or is located separately from the processor <b>102</b>. The memory <b>104</b> includes a volatile or non-volatile memory, for example, random access memory (RAM), dynamic RAM, or a cache.</p><p id="p-0025" num="0024">The storage <b>106</b> includes a fixed or removable storage, for example, a hard disk drive, a solid-state drive, an optical disk, or a flash drive. The input devices <b>108</b> include, without limitation, a keyboard, a keypad, a touch screen, a touch pad, a detector, a microphone, an accelerometer, a gyroscope, a biometric scanner, or a network connection (e.g., a wireless local area network card for transmission and/or reception of wireless IEEE 802 signals). The output devices <b>110</b> include, without limitation, a display, a speaker, a printer, a haptic feedback device, one or more lights, an antenna, or a network connection (e.g., a wireless local area network card for transmission and/or reception of wireless IEEE 802 signals).</p><p id="p-0026" num="0025">The input driver <b>112</b> communicates with the processor <b>102</b> and the input devices <b>108</b>, and permits the processor <b>102</b> to receive input from the input devices <b>108</b>. The output driver <b>114</b> communicates with the processor <b>102</b> and the output devices <b>110</b>, and permits the processor <b>102</b> to send output to the output devices <b>110</b>. It is noted that the input driver <b>112</b> and the output driver <b>114</b> are optional components, and that the device <b>100</b> will operate in the same manner if the input driver <b>112</b> and the output driver <b>114</b> are not present. The output driver <b>116</b> includes an accelerated processing device (&#x201c;APD&#x201d;) <b>116</b> which is coupled to a display device <b>118</b>. The APD accepts compute commands and graphics rendering commands from processor <b>102</b>, processes those compute and graphics rendering commands, and provides pixel output to display device <b>118</b> for display. As described in further detail below, the APD <b>116</b> includes one or more parallel processing units to perform computations in accordance with a single-instruction-multiple-data (&#x201c;SIMD&#x201d;) paradigm. Thus, although various functionality is described herein as being performed by or in conjunction with the APD <b>116</b>, in various alternatives, the functionality described as being performed by the APD <b>116</b> is additionally or alternatively performed by other computing devices having similar capabilities that are not driven by a host processor (e.g., processor <b>102</b>) and provides graphical output to a display device <b>118</b>. For example, it is contemplated that any processing system that performs processing tasks in accordance with a SIMD paradigm may perform the functionality described herein. Alternatively, it is contemplated that computing systems that do not perform processing tasks in accordance with a SIMD paradigm can also perform the functionality described herein.</p><p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a block diagram of the device <b>100</b>, illustrating additional details related to execution of processing tasks on the APD <b>116</b>. The processor <b>102</b> maintains, in system memory <b>104</b>, one or more control logic modules for execution by the processor <b>102</b>. The control logic modules include an operating system <b>120</b>, a kernel mode driver <b>122</b>, and applications <b>126</b>. These control logic modules control various features of the operation of the processor <b>102</b> and the APD <b>116</b>. For example, the operating system <b>120</b> directly communicates with hardware and provides an interface to the hardware for other software executing on the processor <b>102</b>. The kernel mode driver <b>122</b> controls operation of the APD <b>116</b> by, for example, providing an application programming interface (&#x201c;API&#x201d;) to software (e.g., applications <b>126</b>) executing on the processor <b>102</b> to access various functionality of the APD <b>116</b>. The kernel mode driver <b>122</b> also includes a just-in-time compiler that compiles programs for execution by processing components (such as the SIMD units <b>138</b> discussed in further detail below) of the APD <b>116</b>.</p><p id="p-0028" num="0027">The APD <b>116</b> executes commands and programs for selected functions, such as graphics operations and non-graphics operations that are or can be suited for parallel processing. The APD <b>116</b> can be used for executing graphics pipeline operations such as pixel operations, geometric computations, and rendering an image to display device <b>118</b> based on commands received from the processor <b>102</b>. The APD <b>116</b> also executes compute processing operations that are not directly related to graphics operations, such as operations related to video, physics simulations, computational fluid dynamics, or other tasks, based on commands received from the processor <b>102</b>.</p><p id="p-0029" num="0028">The APD <b>116</b> includes compute units <b>132</b> that include one or more SIMD units <b>138</b> that perform operations at the request of the processor <b>102</b> in a parallel manner according to a SIMD paradigm. The SIMD paradigm is one in which multiple processing elements share a single program control flow unit and program counter and thus execute the same program but are able to execute that program with or using different data. In one example, each SIMD unit <b>138</b> includes sixteen lanes, where each lane executes the same instruction at the same time as the other lanes in the SIMD unit <b>138</b> but can execute that instruction with different data. Lanes can be switched off with predication if not all lanes need to execute a given instruction. Predication can also be used to execute programs with divergent control flow. More specifically, for programs with conditional branches or other instructions where control flow is based on calculations performed by an individual lane, predication of lanes corresponding to control flow paths not currently being executed, and serial execution of different control flow paths allows for arbitrary control flow.</p><p id="p-0030" num="0029">The basic unit of execution in compute units <b>132</b> is a work-item. Each work-item represents a single instantiation of a program that is to be executed in parallel in a particular lane. Work-items can be executed simultaneously as a &#x201c;wavefront&#x201d; on a single SIMD processing unit <b>138</b>. One or more wavefronts are included in a &#x201c;work group,&#x201d; which includes a collection of work-items designated to execute the same program. A work group can be executed by executing each of the wavefronts that make up the work group. In alternatives, the wavefronts are executed sequentially on a single SIMD unit <b>138</b> or partially or fully in parallel on different SIMD units <b>138</b>. Wavefronts can be thought of as the largest collection of work-items that can be executed simultaneously on a single SIMD unit <b>138</b>. Thus, if commands received from the processor <b>102</b> indicate that a particular program is to be parallelized to such a degree that the program cannot execute on a single SIMD unit <b>138</b> simultaneously, then that program is broken up into wavefronts which are parallelized on two or more SIMD units <b>138</b> or serialized on the same SIMD unit <b>138</b> (or both parallelized and serialized as needed). A scheduler <b>136</b> performs operations related to scheduling various wavefronts on different compute units <b>132</b> and SIMD units <b>138</b>.</p><p id="p-0031" num="0030">The parallelism afforded by the compute units <b>132</b> is suitable for graphics related operations such as pixel value calculations, vertex transformations, and other graphics operations. Thus, in some instances, a graphics pipeline <b>134</b>, which accepts graphics processing commands from the processor <b>102</b>, provides computation tasks to the compute units <b>132</b> for execution in parallel.</p><p id="p-0032" num="0031">The compute units <b>132</b> are also used to perform computation tasks not related to graphics or not performed as part of the &#x201c;normal&#x201d; operation of a graphics pipeline <b>134</b> (e.g., custom operations performed to supplement processing performed for operation of the graphics pipeline <b>134</b>). An application <b>126</b> or other software executing on the processor <b>102</b> transmits programs that define such computation tasks to the APD <b>116</b> for execution.</p><p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a block diagram illustrating example components of an accelerated processing device for implementing one or more features of the present disclosure. For simplified explanation, the accelerated processing device is described as a GPU <b>300</b>. The GPU <b>300</b> is an example of an accelerated processing device.</p><p id="p-0034" num="0033">As shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, GPU <b>300</b> include a plurality of compute units <b>302</b>. Each compute unit <b>302</b> includes a corresponding level 1 cache controller <b>306</b> in communication with a corresponding level 1 cache <b>304</b>. As further shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, GPU <b>300</b> includes a level 2 cache controller <b>310</b> in communication with level 2 cache <b>308</b>. Level 2 cache <b>308</b> is shared by each of the CUs <b>302</b>. Cache controller <b>310</b> can also be in communication with a next cache level (higher cache level), as indicated in <figref idref="DRAWINGS">FIG. <b>3</b></figref>.</p><p id="p-0035" num="0034">GPU <b>300</b> also includes ALU network <b>312</b>. ALU network <b>312</b> includes a plurality of ALUs, instantiated separate from the CUs <b>302</b> as well as dedicated ALU interconnects, connecting the ALUs to provide shared access to data, by the CUs <b>302</b>, in register files of the ALUs as described in more detail below with regard to <figref idref="DRAWINGS">FIG. <b>4</b></figref>.</p><p id="p-0036" num="0035"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a block diagram illustrating example components of the GPU <b>300</b> shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref> with additional detail. As shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref>, GPU <b>300</b> includes a first group of CUs <b>302</b>(<b>1</b>), a second group of CUs <b>301</b>(<b>2</b>), a first ALU network <b>312</b>(<b>1</b>), a second ALU network <b>312</b>(<b>2</b>). The GPU <b>300</b> also includes GPU interconnects <b>306</b> for data access, by the CUs <b>302</b>, to memory <b>104</b> (e.g., RAM, DRAM, cache memory and the like). The GPU <b>300</b> also includes clocks <b>404</b>.</p><p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. <b>4</b></figref> illustrates two groups of CUs (i.e., <b>302</b>(<b>1</b>) and <b>302</b>(<b>2</b>)) and two ALU networks (i.e., <b>312</b>(<b>1</b>) and <b>312</b>(<b>2</b>)). The number of CU groups and <b>301</b>(<b>2</b>)) and the number of ALU networks shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref> is merely an example. Features of the present disclosure can be implemented using any number CU groups and any number of ALU networks. <figref idref="DRAWINGS">FIG. <b>4</b></figref> also illustrates twenty CUs <b>302</b> in each CU group (<b>302</b>(<b>1</b>) and <b>301</b>(<b>2</b>)) and eight ALUs <b>412</b> in each ALU networks (<b>312</b>(<b>1</b>) and <b>312</b>(<b>2</b>)). The number of CUs shown in each group and the number ALUs shown in each ALU network is merely an example. Features of the present disclosure can be implemented using any number of CUs per group and any number ALUs per ALU network.</p><p id="p-0038" num="0037">Each of the ALU networks <b>312</b>(<b>1</b>) and <b>312</b>(<b>2</b>) include a plurality of ALUs <b>412</b> and a plurality of interconnects <b>406</b>. Each ALU <b>412</b> includes its own corresponding register file, such as for example scratchpad memory <b>502</b> shown in <figref idref="DRAWINGS">FIG. <b>5</b></figref>. The interconnects <b>406</b> provide each of the ALUs <b>412</b> with shared access to the data stored at other ALUs <b>412</b> for communication between the ALUs <b>412</b>. The interconnects <b>406</b> also provide each of the CUs <b>302</b> with shared access to the data stored at any of the ALUs <b>412</b> for communication between the CUs <b>302</b>. Accordingly, the register files (e.g., scratchpad memory <b>502</b>) are used to store data provided to the ALUs <b>412</b> (e.g., by other ALUs <b>412</b> and CUs <b>302</b>) and to store data resulting from performing calculations during execution of operations, such as matrix multiplication operations and post matrix multiplication operations. The data stored in the scratchpad memory <b>502</b> is also read from other ALUs <b>412</b> and CUs <b>302</b> to perform matrix multiplication calculations and perform post matrix multiplication operations.</p><p id="p-0039" num="0038">GPU <b>300</b> also includes interconnects <b>408</b> which are used to communicate data between the CUs <b>302</b> and memory <b>104</b> (e.g., main memory and cache memory). The interconnects <b>408</b> are not used for data communication between ALUs <b>412</b>.</p><p id="p-0040" num="0039"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a block diagram illustrating example interconnections between components of the accelerated processing device shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref>. The arrows shown in <figref idref="DRAWINGS">FIG. <b>5</b></figref> are used to represent interconnects between the ALUs and CUs <b>302</b>. The register files of each ALU <b>412</b> is directly accessible by a plurality of CUs <b>302</b>. For example, as indicated by arrow <b>504</b> in <figref idref="DRAWINGS">FIG. <b>5</b></figref>, the scratchpad memory <b>502</b> of the top ALU <b>412</b> in <figref idref="DRAWINGS">FIG. <b>5</b></figref> is in direct communication with three of the CUs <b>302</b> (<b>3</b> leftmost CUs <b>302</b> in <figref idref="DRAWINGS">FIG. <b>5</b></figref>) and is connected to the scratchpad memory <b>502</b> of the adjacent ALU <b>412</b> (as indicated by arrow <b>506</b>). The scratchpad memories <b>502</b> of other ALUs <b>412</b> of the ALU network are connected via arrows <b>508</b>. That is, the scratchpad memory <b>502</b> of the other ALUs <b>412</b> of a corresponding ALU network are indirect accessible by the top ALU <b>412</b> in <figref idref="DRAWINGS">FIG. <b>5</b></figref> via the interconnects represented by arrows <b>506</b> and <b>508</b>.</p><p id="p-0041" num="0040">Machine learning tasks typically include both matrix multiplication operations (e.g., general matrix multiply (GEMM) operations) and operations that are not matrix multiplication operations. For example, in some cases a machine learning task includes a matrix multiplication of two variables, followed by a softmax operation on the result, followed by a matrix multiplication of the result of the softmax operation with a third variable.</p><p id="p-0042" num="0041">In some implementations, the ALUs implement hardware for performing calculations that may be useful for machine learning applications, such as matrix multiplication operations, or convolution, and the CUs implement hardware configured for computations that are not matrix multiplication operations, such as scaling, softmax, masking, pooling, normalization, and other operations.</p><p id="p-0043" num="0042">If all of the kernels of the machine learning task are executed on the same processor, these tasks would typically be performed consecutively due to data dependencies (e.g., the result of the first matrix multiplication kernel would be input to the softmax kernel, and the output of the softmax kernel would be input, along with the third variable, to the second matrix multiplication kernel. In such cases, delays accrue due to storing of the results of one kernel to memory from the register file, launching of the next kernel on the processor, and loading of the results of the prior kernel from memory back to the register file as input to the next kernel.</p><p id="p-0044" num="0043"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a flow diagram illustrating an example machine learning task <b>600</b> having three inputs Q, K, V, and one output. Machine learning task <b>600</b> includes a scaled dot-product operation <b>602</b>. Scaled dot-product operation is performed on h sets of Q, K, V input data.</p><p id="p-0045" num="0044">Machine learning task <b>600</b> includes several component kernels. For example, scaled dot-product operation <b>602</b> includes a matrix multiplication <b>604</b> of inputs Q and K (matrix multiplication <b>604</b> notated as Q*K for convenience), scaling <b>606</b>, masking <b>608</b>, and softmax <b>610</b> of the output of matrix multiplication <b>604</b> (where scaling <b>606</b>, masking <b>608</b>, and softmax <b>610</b> are notated as SM for convenience), and a matrix multiplication <b>612</b> of the output of softmax <b>610</b> and the input V (matrix multiplication <b>612</b> notated as QK*V for convenience).</p><p id="p-0046" num="0045">If the kernels of scaled dot-product operation <b>602</b> were all executed by the same processor, execution would typically be performed serially, with matrix multiplication <b>604</b> followed by scaling <b>606</b>, masking <b>608</b>, softmax <b>610</b>, and matrix multiplication <b>612</b>, repeating for each of the h sets of Q, K, V input data. However, if matrix multiplication operations <b>604</b> and <b>612</b> are executable on an ALU (e.g., ALU <b>412</b>) and non- or post-matrix multiplication operations (e.g., scaling <b>606</b>, masking <b>608</b>, softmax <b>610</b>) are executable on a CU (e.g., CU <b>302</b>), in some implementations, it is possible to pipeline execution of the kernels such that processing of different sets of Q, K, V input data can overlap, increasing processing speed.</p><p id="p-0047" num="0046"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a block diagram illustrating example operations of a CU <b>302</b> and ALU <b>412</b> executing kernels of a dot-product operation for inputs Q, K, V. The dot-product operation includes a kernel which performs a GEMM of inputs Q, K (Q*K) a kernel which performs a softmax (SM) on the result of Q*K, and a GEMM of the result of the SM and input V (QK*V). CU <b>302</b>, and ALU <b>412</b> store intermediate results in scratchpad <b>502</b>, which enables pipelining of &#x201c;unrolled&#x201d; Q*K, SM, and QK*V kernels. Unrolling, in this context, refers to performing an operation (such as GEMM operation Q*K) in batches such that each batch produces a portion of the output, and not the entire output. The results of each batch are referred to as a result tile. In this example, each kernel is unrolled into 4 batches (i.e., unroll depth=4). The size of each result tile is based on the capacity of scratchpad <b>502</b>, and the unroll depth. The final <b>4</b> result tiles are concatenated or otherwise processed to yield a final result.</p><p id="p-0048" num="0047">Because the discrete GEMM and SM kernels are unrolled and pipelined to run during overlapping time periods, the two kernels can be referred to as &#x201c;pipeline fused&#x201d;. GEMM and SM kernels are merely examples. It is noted that any suitable type and/or number of kernels are pipeline fusable in a similar manner. For example, kernels are suitable for pipeline fusing where a GEMM or convolutional kernel is executed on an ALU, whereas a non-GEMM or non-convolutional kernel is executed on the CU. In this example, because all of the GEMM kernels are executed on ALU <b>412</b>, and all SM kernels are executed on CU <b>302</b>, it is possible for the unrolled matrix multiplication kernels and SM kernels to run simultaneously or during overlapping time periods. Accordingly, the corresponding kernels are unrolled to operate on inputs Q, K, V in 4 batches (0-3) in this example.</p><p id="p-0049" num="0048">In this example, for batch 0, matrix multiplication Q*K is performed by executing kernel <b>700</b> on ALU <b>412</b>, and the result tile A0 is stored in scratchpad <b>502</b>. Softmax SM is performed on result tile A0 by executing kernel <b>702</b> on CU <b>302</b> and the result tile B0 is stored in scratchpad <b>502</b>. Matrix multiplication QK*V is performed on result tile B0 by executing kernel <b>704</b> on ALU <b>412</b>. The output of kernel <b>704</b> (not shown) is written to a global memory (e.g., memory <b>104</b>), or to a different memory or cache, depending on the desired implementation. In cases where further operations are performed on the output of kernel <b>704</b>, these results can be written to the scratchpad <b>502</b> instead.</p><p id="p-0050" num="0049">For batch 1, matrix multiplication Q*K is performed by executing kernel <b>706</b> on ALU <b>412</b>, and the result tile A1 is stored in scratchpad <b>502</b>. In this example, kernel <b>706</b> begins executing on ALU <b>412</b> before batch 0 is complete, since the SM kernel <b>702</b> is executed on CU <b>302</b>, and does not require the use of ALU <b>412</b>. Softmax SM is performed on result tile A1 by executing kernel <b>708</b> on CU <b>302</b> and the result tile B1 is stored in scratchpad <b>502</b>. In this example, kernel <b>708</b> begins executing on CU <b>304</b> before batch 0 is complete, since the QK*V kernel <b>704</b> is executed on ALU <b>412</b>, and does not require the use of CU <b>302</b>. Matrix multiplication QK*V is performed on result tile B1 by executing kernel <b>710</b> on ALU <b>412</b>. The result tile of kernel <b>710</b> (not shown) is written to the scratchpad <b>502</b>, or to a different memory, depending on the desired implementation.</p><p id="p-0051" num="0050">For batch 2, matrix multiplication Q*K is performed by executing kernel <b>712</b> on ALU <b>412</b>, and the result tile A2 is stored in scratchpad <b>502</b>. In this example, kernel <b>712</b> begins executing on ALU <b>412</b> before batch 1 is complete, since the SM kernel <b>708</b> is executed on CU <b>302</b>, and does not require the use of ALU <b>412</b>. Softmax SM is performed on result tile A2 by executing kernel <b>714</b> on CU <b>302</b> and the result tile B2 is stored in scratchpad <b>502</b>. In this example, kernel <b>714</b> begins executing on CU <b>304</b> before batch 1 is complete, since the QK*V kernel <b>710</b> is executed on ALU <b>412</b>, and does not require the use of CU <b>302</b>. Matrix multiplication QK*V is performed on result tile B2 by executing kernel <b>716</b> on ALU <b>412</b>. The result tile of kernel <b>716</b> (not shown) is written to the scratchpad <b>502</b>, or a different memory, depending on the desired implementation.</p><p id="p-0052" num="0051">For batch 3, matrix multiplication Q*K is performed by executing kernel <b>718</b> on ALU <b>412</b>, and the result tile A3 is stored in scratchpad <b>502</b>. In this example, kernel <b>718</b> begins executing on ALU <b>412</b> before batch 2 is complete, since the SM kernel <b>714</b> is executed on CU <b>302</b>, and does not require the use of ALU <b>412</b>. Softmax SM is performed on result tile A1 by executing kernel <b>720</b> on CU <b>302</b> and the result tile B3 is stored in scratchpad <b>502</b>. In this example, kernel <b>720</b> begins executing on CU <b>304</b> before batch 2 is complete, since the QK*V kernel <b>716</b> is executed on ALU <b>412</b>, and does not require the use of CU <b>302</b>. Matrix multiplication QK*V is performed on result B3 by executing kernel <b>722</b> on ALU <b>412</b>. The output of kernel <b>722</b> (not shown) is written to the scratchpad <b>502</b>, or a different memory, depending on the desired implementation.</p><p id="p-0053" num="0052">In some implementations, executing the unrolled kernels during overlapping time periods on CU <b>302</b> and ALU <b>412</b> has the advantage of performing the operation in less time than would be possible the kernels were not unrolled, and were executed serially (e.g., due to waiting for the availability of results.)</p><p id="p-0054" num="0053">It is noted that where the result of a first kernel is input to a second kernel in this example, in some implementations, the result of the first kernel is written to a register of the scratchpad that is designated as an input of the second kernel. Because the result stored and read from the scratchpad, which is a set of registers that is local to the ALU, and the result is not read back from a cache, memory, or other memory for input to the second kernel, performance is increased in some implementations; e.g., by reducing the latency that is due to memory storage operations.</p><p id="p-0055" num="0054"><figref idref="DRAWINGS">FIG. <b>7</b></figref> also illustrates example operations of ALUDMA <b>750</b>, which is a memory access (e.g., direct memory access (DMA)) controller configured to copy information from registers of scratchpad <b>502</b> to a memory (e.g., off-chip memory or a cache memory). For example, in some implementations it may be desired to retain a copy of the intermediate results (e.g., for backpropagation training). ALUDMA <b>750</b> is configured to copy the information from the registers of scratchpad <b>502</b> to the memory. Copying information using hardware other than ALU <b>412</b> and CU <b>302</b>, in some implementations, also has the advantage of increasing performance, e.g., by reducing the latency that is due to memory storage operations.</p><p id="p-0056" num="0055">In the examples above, pipeline fusion is described for a GEMM and SM operation. As mentioned above however GEMM and SM kernels are merely examples of kernels which are pipeline fusable. It is noted that any suitable type and/or number of kernels are pipeline fusable in a similar manner, if they are capable of executing during overlapping time periods (e.g., by unrolling) on an ALU and CU as described above. For example, in some implementations, a gaussian error linear unit (GeLU) kernel and fully connected (FC) kernel are pipeline fusable. In another example, a rectified linear unit (ReLU) and FC operation are pipeline fusable.</p><p id="p-0057" num="0056"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a flow chart illustrating an example method <b>800</b> for pipeline fusion of a first kernel and a second kernel. Method <b>800</b> is useable with any of the devices and techniques described above. Example method <b>800</b> pipeline fuses only two kernels in this example, using an unroll depth of 2, however it is noted that any suitable number of kernels can be pipeline fused using any suitable unroll depth in other implementations.</p><p id="p-0058" num="0057">In step <b>802</b>, kernel 1 and kernel 2 are unrolled into batch 1 and batch 2. In some implementations, kernel 1 is a matrix multiplication kernel in this example, and kernel 2 is a function that does not include matrix multiplication.</p><p id="p-0059" num="0058">In step <b>804</b>, batch 1 of kernel 1 is executed on a first processing device. In some implementations, the first processing device is an ALU. In some implementations, the first processing device is optimized for matrix multiplication operations. In some implementations, the result of the execution of batch 1 kernel 1 is written to a scratch memory or register file of the first processing device, or another local memory, e.g., as further discussed herein.</p><p id="p-0060" num="0059">In step <b>806</b>, after batch 1 of kernel 1 has completed execution on the first processing device, batch 2 of kernel 1 is executed on the first processing device. In some implementations, the result of the execution of batch 2 of kernel 1 is written to the scratch memory, register file, or other local memory.</p><p id="p-0061" num="0060">In step <b>808</b>, also after batch 1 of kernel 1 has completed execution on the first processing device, batch 1 of kernel 2 is executed on the second processing device. In some implementations, the second processing device is a CU. In some implementations, the second processing device is optimized for general purpose computation or otherwise not optimized for matrix multiplication operations. In some implementations, the result of the execution of batch 1 of kernel 2 is written to the scratch memory, register file, or other local memory. The execution of batch 1 of kernel 2 on the second processing device overlaps at least partially in time with the execution of batch 2 of kernel 1 on the first processing device.</p><p id="p-0062" num="0061">In step <b>810</b>, after batch 2 of kernel 1 has completed execution on the first processing device, batch 2 of kernel 2 is executed on the second processing device. In some implementations, the result of the execution of batch 2 of kernel 2 is written to the scratch memory, register file, or other local memory.</p><p id="p-0063" num="0062">In step <b>812</b>, the result of the execution of batch 1 of kernel 2 and the result of the execution of batch 2 of kernel 2 are concatenated to generate a result of the pipeline fused first kernel and second kernel. In some implementations, the overlap in execution exhibited during example method <b>800</b> has the advantage of facilitating generation of the result of the pipeline fused first kernel and second kernel in less time than generation of the result of the first kernel and second kernel without pipeline fusion.</p><p id="p-0064" num="0063">It should be understood that many variations are possible based on the disclosure herein. Although features and elements are described above in particular combinations, each feature or element can be used alone without the other features and elements or in various combinations with or without other features and elements.</p><p id="p-0065" num="0064">The various functional units illustrated in the figures and/or described herein (including, but not limited to, the processor <b>102</b>, the input driver <b>112</b>, the input devices <b>108</b>, the output driver <b>114</b>, the output devices <b>110</b>, the accelerated processing device <b>116</b>, the scheduler <b>136</b>, the graphics processing pipeline <b>134</b>, the compute units <b>132</b>, the SIMD units <b>138</b>, may be implemented as a general purpose computer, a processor, or a processor core, or as a program, software, or firmware, stored in a non-transitory computer readable medium or in another medium, executable by a general purpose computer, a processor, or a processor core. The methods provided can be implemented in a general purpose computer, a processor, or a processor core. Suitable processors include, by way of example, a general purpose processor, a special purpose processor, a conventional processor, a digital signal processor (DSP), a plurality of microprocessors, one or more microprocessors in association with a DSP core, a controller, a microcontroller, Application Specific Integrated Circuits (ASICs), Field Programmable Gate Arrays (FPGAs) circuits, any other type of integrated circuit (IC), and/or a state machine. Such processors can be manufactured by configuring a manufacturing process using the results of processed hardware description language (HDL) instructions and other intermediary data including netlists (such instructions capable of being stored on a computer readable media). The results of such processing can be maskworks that are then used in a semiconductor manufacturing process to manufacture a processor which implements features of the disclosure.</p><p id="p-0066" num="0065">The methods or flow charts provided herein can be implemented in a computer program, software, or firmware incorporated in a non-transitory computer-readable storage medium for execution by a general purpose computer or a processor. Examples of non-transitory computer-readable storage mediums include a read only memory (ROM), a random access memory (RAM), a register, cache memory, semiconductor memory devices, magnetic media such as internal hard disks and removable disks, magneto-optical media, and optical media such as CD-ROM disks, and digital versatile disks (DVDs).</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A method for pipeline fusion of a plurality of kernels, the method comprising:<claim-text>executing a first batch of a first kernel on a first processing device to generate a first output of the first kernel based on an input;</claim-text><claim-text>executing a first batch of a second kernel on a second processing device to generate a first output of the second kernel based on the first output of the first kernel; and</claim-text><claim-text>executing a second batch of the first kernel on the first processing device to generate a second output of the first kernel based on the input;</claim-text><claim-text>wherein executing the second batch of the first kernel overlaps at least partially in time with executing the first batch of the second kernel.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising executing a first batch of a third kernel to generate a first output of the third kernel based on the first output of the second kernel;<claim-text>wherein executing the first batch of the third kernel overlaps at least partially in time with executing the second batch of the second kernel.</claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, further comprising executing a second batch of the third kernel to generate a second output of the third kernel based on the second output of the second kernel; and concatenating the first output of the third kernel with the second output of the third kernel to generate an output of the plurality of kernels.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the first output of the first kernel is written to a scratch memory of the first processing device by the first processing device.</claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the first output of the first kernel is read from the scratch memory of the first processing device by the second processing device.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the first output of the first kernel is written to a register file of the first processing device by the first processing device.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the first output of the first kernel is read from the register file of the first processing device by the second processing device.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the first processing device comprises an arithmetic logic unit (ALU).</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the second processing device comprises a compute unit (CU).</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the first kernel performs a matrix multiply operation and the second kernel does not perform a matrix multiply operation.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. A processor configured for pipeline fusion of a plurality of kernels, the processor comprising:<claim-text>a first processing device configured to execute a first batch of a first kernel to generate a first output of the first kernel based on an input;</claim-text><claim-text>a second processing device configured to execute a first batch of a second kernel to generate a first output of the second kernel based on the first output of the first kernel; and</claim-text><claim-text>the first processing device further configured to execute a second batch of the first kernel to generate a second output of the first kernel based on the input;</claim-text><claim-text>wherein the first processing device is further configured to execute the second batch of the first kernel overlapping in time at least partially with the second processing device executing the first batch of the second kernel.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The processor of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the first processing device is configured to execute a first batch of a third kernel to generate a first output of the third kernel based on the first output of the second kernel; and wherein the first processing device is configured to execute the first batch of the third kernel overlapping at least partially in time with the second processing device executing the second batch of the second kernel.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The processor of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the first processing device is configured to execute a second batch of the third kernel to generate a second output of the third kernel based on the second output of the second kernel; the processor further comprising circuitry configured to concatenate the first output of the third kernel with the second output of the third kernel to generate an output of the plurality of kernels.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The processor of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the first processing device is configured to write the first output of the first kernel to a scratch memory of the first processing device.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The processor of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the second processing device is configured to read the first output of the first kernel from the scratch memory of the first processing device.</claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The processor of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the first processing device is configured to write the first output of the first kernel is to a register file of the first processing device.</claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The processor of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the second processing device is configured to read the first output of the first kernel from the register file of the first processing device.</claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The processor of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the first processing device comprises an arithmetic logic unit (ALU).</claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The processor of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the second processing device comprises a compute unit (CU).</claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The processor of <claim-ref idref="CLM-00011">claim 11</claim-ref>, further comprising circuitry configured to copy the first output of the first kernel from a scratch memory of the first processing device to a cache memory.</claim-text></claim></claims></us-patent-application>