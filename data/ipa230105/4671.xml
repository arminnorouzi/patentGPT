<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004672A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004672</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17900759</doc-number><date>20220831</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>21</main-group><subgroup>62</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>2455</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>L</subclass><main-group>9</main-group><subgroup>32</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>21</main-group><subgroup>6227</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>2456</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>L</subclass><main-group>9</main-group><subgroup>3242</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">SECURE DATA POINT MATCHING IN A MULTIPLE TENANT DATABASE SYSTEM</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>17847681</doc-number><date>20220623</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11461493</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17900759</doc-number></document-id></child-doc></relation></continuation><continuation><relation><parent-doc><document-id><country>US</country><doc-number>17521348</doc-number><date>20211108</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11386222</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17847681</doc-number></document-id></child-doc></relation></continuation><continuation><relation><parent-doc><document-id><country>US</country><doc-number>17321327</doc-number><date>20210514</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11170125</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17521348</doc-number></document-id></child-doc></relation></continuation><continuation><relation><parent-doc><document-id><country>US</country><doc-number>17004375</doc-number><date>20200827</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11048817</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17321327</doc-number></document-id></child-doc></relation></continuation><continuation><relation><parent-doc><document-id><country>US</country><doc-number>16902266</doc-number><date>20200616</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>10783271</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17004375</doc-number></document-id></child-doc></relation></continuation><continuation><relation><parent-doc><document-id><country>US</country><doc-number>16708067</doc-number><date>20191209</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>10713380</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>16902266</doc-number></document-id></child-doc></relation></continuation><continuation><relation><parent-doc><document-id><country>US</country><doc-number>16368339</doc-number><date>20190328</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11188670</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>16708067</doc-number></document-id></child-doc></relation></continuation></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>SNOWFLAKE INC.</orgname><address><city>Bozeman</city><state>MT</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Langseth</last-name><first-name>Justin</first-name><address><city>Kailua</city><state>HI</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Glickman</last-name><first-name>Matthew J.</first-name><address><city>Larchmont</city><state>NY</state><country>US</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>Kleinerman</last-name><first-name>Christian</first-name><address><city>Burlingame</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="03" designation="us-only"><addressbook><last-name>Muglia</last-name><first-name>Robert</first-name><address><city>Mercer Island</city><state>WA</state><country>US</country></address></addressbook></inventor><inventor sequence="04" designation="us-only"><addressbook><last-name>Freundel</last-name><first-name>Daniel</first-name><address><city>San Francisco</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="05" designation="us-only"><addressbook><last-name>Cruanes</last-name><first-name>Thierry</first-name><address><city>San Mateo</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="06" designation="us-only"><addressbook><last-name>Lee</last-name><first-name>Allison Waingold</first-name><address><city>San Carlos</city><state>CA</state><country>US</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">Systems, methods, and devices for generating a secure join of database data are disclosed. A method creates a secure view of datapoints of a consumer account and processes, using a secure user defined function (UDF), the datapoints of the consumer account and datapoints of a provider account to generate a secure join key. The secure UDF returns a count of matching data points between the consumer account and the provider account, and the method provides the count of matching data points to the consumer account.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="56.39mm" wi="135.38mm" file="US20230004672A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="224.96mm" wi="148.67mm" file="US20230004672A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="206.16mm" wi="157.90mm" file="US20230004672A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="198.97mm" wi="157.82mm" file="US20230004672A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="197.19mm" wi="174.84mm" file="US20230004672A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="122.43mm" wi="141.99mm" file="US20230004672A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="200.66mm" wi="169.25mm" orientation="landscape" file="US20230004672A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="192.87mm" wi="154.01mm" orientation="landscape" file="US20230004672A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="221.66mm" wi="155.28mm" orientation="landscape" file="US20230004672A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="223.69mm" wi="168.40mm" orientation="landscape" file="US20230004672A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="161.88mm" wi="181.86mm" file="US20230004672A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="226.74mm" wi="181.86mm" file="US20230004672A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="230.80mm" wi="156.46mm" file="US20230004672A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading><p id="p-0002" num="0001">This application is a continuation of U.S. application Ser. No. 17/847,681 filed on Jun. 23, 2022, entitled &#x201c;DATA OVERLAP COUNT ADJUSTMENT IN A MULTIPLE TENANT DATABASE SYSTEM,&#x201d; which is a continuation of U.S. application Ser. No. 17/521,348 filed on Nov. 8, 2021, now U.S. Pat. No. 11,386,222 issued on Jul. 12, 2022, entitled &#x201c;DATA OVERLAP COUNT IN A MULTIPLE TENANT DATABASE SYSTEM,&#x201d; which is a continuation of U.S. application Ser. No. 17/321,327 filed on May 14, 2021, now U.S. Pat. No. 11,170,125 issued on Nov. 9, 2021, entitled &#x201c;DATA OVERLAP COUNT IN A MULTIPLE TENANT DATABASE SYSTEM,&#x201d; which is a continuation of U.S. application Ser. No. 17/004,375 filed on Aug. 27, 2020, now U.S. Pat. No. 11,048,817 issued on Jun. 29, 2021, entitled &#x201c;SHARE BASED DATA OVERLAP COUNT IN A MULTIPLE TENANT DATABASE SYSTEM,&#x201d; which is a continuation of U.S. application Ser. No. 16/902,266 filed on Jun. 16, 2020, now U.S. Pat. No. 10,783,271 issued on Sep. 22, 2020, entitled &#x201c;SECURE VIEW-BASED DATA JOINS IN A MULTIPLE TENANT DATABASE SYSTEM,&#x201d; which is a continuation of U.S. application Ser. No. 16/708,067 filed on Dec. 9, 2019, now U.S. Pat. No. 10,713,380 issued on Jul. 14, 2020, entitled &#x201c;SECURE DATA JOINS IN A MULTIPLE TENANT DATABASE SYSTEM,&#x201d; which is a continuation of U.S. application Ser. No. 16/368,339 filed on Mar. 28, 2019, now U.S. Pat. No. 11,188,670 issued on Nov. 30, 2021, entitled &#x201c;SECURE DATA JOINS IN A MULTIPLE TENANT DATABASE SYSTEM,&#x201d; the entire contents of which are hereby incorporated by reference.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">TECHNICAL FIELD</heading><p id="p-0003" num="0002">The present disclosure relates to databases and more particularly relates to secure joins of database data.</p><heading id="h-0003" level="1">BACKGROUND</heading><p id="p-0004" num="0003">Databases are widely used for data storage and access in computing applications. A goal of database storage is to provide enormous sums of information in an organized manner so that it can be accessed, managed, and updated. In a database, data may be organized into rows, columns, and tables. Different database storage systems may be used for storing different types of content, such as bibliographic, full text, numeric, and/or image content. Further, in computing, different database systems may be classified according to the organization approach of the database. There are many different types of databases, including relational databases, distributed databases, cloud databases, object-oriented and others.</p><p id="p-0005" num="0004">Databases are used by various entities and companies for storing information that may need to be accessed or analyzed. In an example, a retail company may store a listing of all sales transactions in a database. The database may include information about when a transaction occurred, where it occurred, a total cost of the transaction, an identifier and/or description of all items that were purchased in the transaction, and so forth. The same retail company may also store, for example, employee information in that same database that might include employee names, employee contact information, employee work history, employee pay rate, and so forth. Depending on the needs of this retail company, the employee information and the transactional information may be stored in different tables of the same database. The retail company may have a need to &#x201c;query&#x201d; its database when it wants to learn information that is stored in the database. This retail company may want to find data about, for example, the names of all employees working at a certain store, all employees working on a certain date, all transactions for a certain product made during a certain time frame, and so forth.</p><p id="p-0006" num="0005">When the retail store wants to query its database to extract certain organized information from the database, a query statement is executed against the database data. The query returns certain data according to one or more query predicates that indicate what information should be returned by the query. The query extracts specific data from the database and formats that data into a readable form. The query may be written in a language that is understood by the database, such as Structured Query Language (&#x201c;SQL&#x201d;), so the database systems can determine what data should be located and how it should be returned. The query may request any pertinent information that is stored within the database. If the appropriate data can be found to respond to the query, the database has the potential to reveal complex trends and activities. This power can only be harnessed through the use of a successfully executed query.</p><p id="p-0007" num="0006">In certain implementations of database technology, different organizations or companies may wish to securely link or join their database data. Further to the above example, the retail store may wish to link or share some of its data with outside organizations, such as a product vendor, a healthcare provider for its employees, a shipping company, and so forth. However, the retail store would want to ensure that its data was secure and that the outside organizations could not view all of its data with unrestricted access. The retail store may also wish to enable outside organizations to link, join, and/or analyze its data without permitting the outside organizations to view or export raw data. Depending on the content of the data, it can be imperative to ensure that the data is secure due to privacy concerns, contractual agreements, government agency restrictions, and so forth. For example, personally identifiable information (PII), protected health information (PHI), and other forms of fine-grained data may need to remain secure even when such database data is shared with outside organizations.</p><p id="p-0008" num="0007">In database systems, secure views may be used as a security mechanism to restrict access to specific information stored in the database. A secure view may be specifically designated for data privacy to limit access to sensitive data, such as PII or PHI, that should not be exposed to outside organizations and/or all users of the database. The implementation of views, and how the implementation of views is handled, can potentially lead to information leakage. For example, during query optimization, certain filters may be pushed across the view definition closer to input tables and information may be leaked to a user if a user-specified filter is evaluated before secure predicates are evaluated. Secure views can ensure that the security of a regular view cannot be circumvented by clever querying of data that is stored in the regular view.</p><p id="p-0009" num="0008">In some instances, two or more organizations may wish to join data to make certain determinations about data that is common between the two or more organizations, or for one organization to enrich the data of the other. For example, two companies may wish to determine how many customers the two companies have in common. This may be a common inquiry between, for example, buyers and sellers of advertising, between healthcare payers and providers, and so forth. This can be a challenging question to answer without one party exposing its entire customer list to the other party. The customer list may include sensitive information that should not be shared with the other party and/or it may include information that the sharing party does not wish to expose for contractual or business reasons. The two parties may wish to securely join data so the parties may determine common data between the two parties or make other beneficial determinations, or to enrich each other's data, without exposing all underlying data. Disclosed herein are methods, systems, and devices for securely joining database data.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0010" num="0009">Non-limiting and non-exhaustive implementations of the present disclosure are described with reference to the following figures, wherein like reference numerals refer to like or similar parts throughout the various views unless otherwise specified. Advantages of the present disclosure will become better understood with regard to the following description and accompanying drawings where:</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a schematic block diagram illustrating accounts in a multi-tenant database, according to one embodiment;</p><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a schematic diagram illustrating a system for providing and accessing database services, according to one embodiment;</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a schematic diagram illustrating a multi-tenant database with separation of storage and computing resources, according to one embodiment;</p><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a schematic block diagram illustrating object hierarchies, according to one embodiment;</p><p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a schematic diagram illustrating role-based access, according to one embodiment;</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a schematic diagram illustrating a usage grant between roles, according to one embodiment;</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a schematic diagram illustrating a share object, according to one embodiment;</p><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a schematic diagram illustrating cross-account grants, according to one embodiment;</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a schematic block diagram illustrating components of a share component, according to one embodiment;</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a schematic diagram of a system for generating a secure join across database accounts, according to one embodiment;</p><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. <b>11</b></figref> is a schematic diagram of a system for generating a secure join across database accounts, according to one embodiment;</p><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. <b>12</b></figref> is a schematic block diagram of work distribution for generating a secure join across database accounts, according to one embodiment;</p><p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. <b>13</b></figref> is a schematic block diagram of work distribution for generating a secure join across database accounts, according to one embodiment;</p><p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. <b>14</b></figref> is a schematic block diagram illustrating a method for generating a secure join across database accounts, according to one embodiment;</p><p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. <b>15</b></figref> is a schematic block diagram illustrating a method for generating a secure join across database accounts, according to one embodiment; and</p><p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. <b>16</b></figref> is a block diagram depicting an example computing device or system consistent with one or more embodiments disclosed herein.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0005" level="1">DETAILED DESCRIPTION</heading><p id="p-0027" num="0026">In certain instances, two or more organizations or companies may wish to share data, join data, or enrich data. In an example of joining data, two companies may wish to determine how many customers the two companies have in common. This can be a difficult inquiry to answer without one or both parties exposing its entire customer list to the other party. The customer list might include sensitive information such as personally identifiable information or protected health information, or the customer list itself might constitute valuable intellectual property that should not be shared with other parties. In such an instance, it may be valuable to securely compare data stored in separate data stores that are associated with the two companies, without allowing either company to view certain information about the data itself or how the data is stored.</p><p id="p-0028" num="0027">Disclosed herein are systems, methods, and devices for joining database data between two parties in a secure manner that does not expose sensitive information included in the data itself or sensitive information about structural or organization details about how the data is stored. Such methods and systems for joining database may herein be referred to as a secure join. In an embodiment, a method includes determining data stored in a first account to be compared with data stored in a second account, wherein the data stored in the first account and the data stored in the second account are directed to a same subject matter. In an exemplary embodiment, the first account is associated with a first company and the second account is associated with a second company. The first company and the second company wish to compare customer lists to determine which customers, and/or how many customers, the two companies have in common. The method includes defining a user-defined function including procedural logic for determining an overlap count between the data stored in the first account and the data stored in the second. The user-defined function further includes as an input a secure join key. The secure join key is a hash that may include a salted value from each account, wherein the one or more salted values are salted before being hashed. The user-defined function may be defined by either of the first account or the second account and may be shared with the other account such that it may be run by a compute node associated with either of the first account or the second account. The user-defined function, along with the secure join key, is configured to compare data stored by the first account against data stored by the second account to determine which datapoints, and/or how many datapoints, the two accounts have in common.</p><p id="p-0029" num="0028">In an example, a first account (referred to in this example as the Provider) will share a secure user-defined function (UDF) that permits a second account (referred to in this example as the Consumer) to check if a specific datapoint exists in the Provider's database. For purposes of this example, the specific datapoint will refer to a customer identification number that should not otherwise be shared between the accounts. The secure UDF will return a one if there is a match between the Consumer's list of customer identification numbers and the Provider's list of customer identification numbers. The secure UDF will return a zero if there is not a match. The secure UDF may be used as part of a SQL statement to compare all datapoints between the Provider's customer identification numbers and the Consumer's customer identification numbers to determine all matches. The Consumer connects to the Provider's shared secure UDF The secure UDF is used to count common customers using the Provider's secure direct lookup function. Because the secure UDF can securely access the Provider's data without exposing it to the Consumer, and because the Provider cannot see which datapoints the Consumer looks up, the process is secure. However, there is a risk that the Consumer can know with certainty if any particular customer for which the Consumer is aware of is a customer of the Provider. This property may not be desirable in some implementations as it allows the Consumer to probe the Provider's customer base for any particular known customer.</p><p id="p-0030" num="0029">Further to the above example, a different implementation is provided that may be referred to herein as a secure join. The Provider defines a secure user-defined function (UDF) to generate a secure join key. In an embodiment, the secure join key is a hash that includes salted data from the Provider and salted data from the Consumer. The Provider's data may be salted and the Consumer's data may be salted before either data is hashed to generate the secure join key. In an embodiment, the secure join key may further include a customer account number associated with the Provider and/or the Consumer. The customer account number may be associated with a cloud-based database system that generates the secure join key. The secure UDF is shared with the Consumer along with another Structure Query Language (SQL) secure UDF to perform a count of overlapping customer datapoints between the Provider and the Consumer. The secure UDF uses a one-way hash to convert the Consumer's customer datapoints into a meaningless string. The secure UDF may run inside the Consumer's compute nodes. The secure UDF may run on compute nodes of either company such that the other company does not attain visibility into when or whether the secure UDF was run. In an example, the Provider includes an account identification associated with the Consumer as part of the one-way hash. This ensures that hashes cannot be used to measure data overlap with any other account or provider. The Consumer may use this hash approach for row-by-row or bulk matching to compare the customer datapoints stored in the Provider's data store versus the customer datapoints stored in the Consumer's data store.</p><p id="p-0031" num="0030">Further to the above example, a different implementation is provided that may be referred to herein as a reverse share secure join. In this implementation, the Consumer may create a secure view of its own customer datapoints and run the secure view through a hash function such that the customer datapoints are encoded and &#x201c;salted.&#x201d; When a datapoint is salted, additional information (i.e. the salt) is added to the datapoint. The salt is only known by the owner of that datapoint. In an example, the datapoint is customer's first name, for example the datapoint is &#x201c;John.&#x201d; The salted datapoint will have a salt adhered to it that is only known by the owner of the datapoint. In the example, the salted datapoint may read &#x201c;JohnSALT123.&#x201d; It should be appreciated that the salt may include any string of characters that is known only to the owner of the datapoint. The Consumer may share only the salted hash values with the Provider in a reverse share. In this example, the Consumer may include additional salted hash values that do not represent any real customer datapoints. This may prevent the Provider from deducing any information about the true size of the Consumer's customer base by inspecting the contents of the reverse share. This technique may be referred to as &#x201c;noise injection&#x201d; and does not harm the analysis of the common customer datapoints existing between the Provider and the Consumer. After the Consumer shares the salted hashed customer datapoints with the Provider, the Consumer may call a secure SQL UDF to perform a secure join. The Consumer provides the hash value and the salt value to the secure SQL UDF such that the secure SQL UDF may process the salted hashed customer datapoints. The secure SQL UDF may then hash and salt the Provider's customer datapoints to generate the secure join key and return the distinct count of joint customer datapoints between the Provider and the Consumer.</p><p id="p-0032" num="0031">Disclosed herein are systems, methods, and devices for creating a secure join of database data. A first party and a second party may wish to determine common data between the two parties. The first party and the second party may wish to determine all common datapoints of a certain subject matter, or of a certain column identifier, between a data store associated with the first account and a data store associated with the second account. The first party may generate a secure UDF and share it with the second party. The secure UDF may include, in an example embodiment, a SQL script that is configured to count overlapping data between the two parties. The first party may define the secure UDF to use a one-way hash to convert the second party's sensitive data into a meaningless string to generate a secure join key. This secure UDF may run inside the second party's compute nodes such that the first party does not know that the secure UDF was run or what data was passed through the secure UDF. The first party may further include an account identification as part of the one-way hash that is associated with the second party account. When the second party's account identification is included as part of the one-way hash, the secure UDF cannot be used to measure data overlap with anyone other than the two parties, and in some implementations may not be used to measure data overlap with any account outside the same database of the first account. The first party may generate and share the secure UDF according to the following example SQL script:</p><p id="p-0033" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>create or replace secure function</entry></row><row><entry>get_secure_join_key(customer_key_string string)</entry></row><row><entry>returns string as</entry></row><row><entry>$$</entry></row><row><entry>sha2(customer_key_string || sha2(current_account( ) || &#x2018;provider secret salt&#x2019;))</entry></row><row><entry>$$;</entry></row><row><entry>create or replace secure function secure_lookup(secure_join_key string,</entry></row><row><entry>consumer_salt string)</entry></row><row><entry>returns numeric(10)</entry></row><row><entry>as</entry></row><row><entry>$$</entry></row><row><entry>select count(*) as count_custs</entry></row><row><entry>from provider_customers c</entry></row><row><entry>where secure_join_key = sha2(nvl(C_EMAIL_ADDRESS,to_char(random( ))) ||</entry></row><row><entry>consumer_salt || sha2(current_account( ) || &#x2018;provider secret salt&#x2019;))</entry></row><row><entry>$$;</entry></row><row><entry>grant usage on function get_secure_join_key(string) to share SJ_DEMO_SHARE;</entry></row><row><entry>grant usage on function secure_lookup(string, string) to share</entry></row><row><entry>SJ_DEMO_SHARE;</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0034" num="0032">Further to this example, the second party may use the hash approach to determine matching between the two parties one row at a time, or to perform bulk matching. Either method may give the same security benefit because the first party does not have visibility into how or when the first party's secure UDF is called by the second party. Additionally, the first party cannot see what data was run through the secure UDF by the second party. This provides enhanced security benefits over the use of a secure UDF when attempting to discern matching data between two accounts. The following example SQL script illustrates how the second party may set up a share from the first party and perform a count of common datapoints between the second party and the first party.</p><p id="p-0035" num="0000"><tables id="TABLE-US-00002" num="00002"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="center"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>CONSUMER ACCOUNT</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="left"/><tbody valign="top"><row><entry>create customer key string function</entry></row><row><entry>create or replace function</entry></row><row><entry>get_customer_key_string(c_email_address string, consumer_salt string)</entry></row><row><entry>returns string as</entry></row><row><entry>$$</entry></row><row><entry>nvl(C_EMAIL_ADDRESS,to_char(random( )))|| consumer_salt</entry></row><row><entry>$$;</entry></row><row><entry>--make table of secure join keys (this is needed in some cases UDF's can not call</entry></row><row><entry>other UDFs within them).</entry></row><row><entry>create or replace temporary table joinkeys as</entry></row><row><entry>select</entry></row><row><entry>sj_test.public.get_secure_join_key(get_customer_key_string(C_EMAIL_ADDRE</entry></row><row><entry>SS,&#x2018;consumersalt&#x2019;)) secure_join_key</entry></row><row><entry>from consumer_customers c;</entry></row><row><entry>--run secure join overlap count</entry></row><row><entry>select sum(sj_test.public.secure_lookup(secure_join_key,&#x2018;consumersalt&#x2019;))</entry></row><row><entry>overlapping_customers,</entry></row><row><entry>count(*) total_customers, ((overlapping_customers / total_customers ) * 100 )</entry></row><row><entry>overlap_pct</entry></row><row><entry>from joinkeys;</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="42pt" align="center"/><colspec colname="2" colwidth="91pt" align="center"/><colspec colname="3" colwidth="77pt" align="center"/><colspec colname="4" colwidth="49pt" align="center"/><tbody valign="top"><row><entry>Row</entry><entry>overlapping_customers</entry><entry>total_customers</entry><entry>overlap_pct</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row><row><entry>1</entry><entry>570761</entry><entry>2926535</entry><entry>19.503000</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0036" num="0033">In an embodiment, the second party may provide a &#x201c;reverse share&#x201d; to provide additional security. In this embodiment, the second party may create a secure view of its data and run the data in the secure view through a hash function. The salted hash values that have been run through the hash function may be shared with the first party in the reverse share. The second party may call an SQL UDF to perform a secure join and provide a salt value for the hashed data points. This SQL UDF may return a distinct count of joint data points between the second party and the first party. In an embodiment, the SQL UDF runs on the second party's compute resources such that the first party does not have any visibility into whether the query was run or into the results of the query. Likewise, the second party is only able to see how many overlapping data points exist between the second party and the first party. The second party is unable to see any information about the content or the size of the first party's non-overlapping data points.</p><p id="p-0037" num="0034">Further in a reverse share embodiment, the second party has the option to include additional hash values that do not represent any actual data points in the database. The additional hash values may prevent the first party from deducing anything about the size of the second party's actual data by inspecting the contents of the reverse share. This technique may be referred to as a &#x201c;noise injection&#x201d; and does not harm analysis of the shared data.</p><p id="p-0038" num="0035">One potential risk the first party faces is the second party intentionally probing the first party with successive requests and only altering one row with each request. The second party may do this to determine whether a specific data point is present in the first party's dataset. In an implementation where this is a concern, the first party may include additional logic in the counting UDF to protect against this raw-row probing by the second party. The first party may instruct the counting UDF to perform a distinct row reduction on the reverse share input set. The first party may instruct the counting UDF to enforce a minimum number of distinct rows on the reverse share inputs. The first party may instruct the counting UDF to add a random numeric value that randomly varies the returned result by, for example, plus or minus ten.</p><p id="p-0039" num="0036">The first party may instruct the counting UDF to round off the actual distinct overlapping result to a certain integer, for example to the nearest ten by using SQL mathematical functions. The first party may instruct the counting UDF to enforce a minimum number of overlap &#x201c;hits&#x201d; for the UDF to return a non-zero result through the use of a SQL HAVING clause. One or more of these instructions may provide Provider-side noise to the result such that raw row probing by the second party is more difficult.</p><p id="p-0040" num="0037">A user-defined function (UDF) is a function that may be provided by a user of a program, database, or other environment. As discussed herein, a secure UDF refers to a UDF having a secure definition. In a relational database management system, a UDF may provide a mechanism for extending functionality of the database server by adding a function that may be evaluated in, for example, structured query language (SQL) statements. The SQL standard may distinguish between scalar UDFs and table UDFs. A scalar UDF may return only a single value whereas a table UDF may return a relational table comprising zero or more rows where each row may have one or more columns. Once created, a UDF may be used in expressions in SQL statements.</p><p id="p-0041" num="0038">Each user-defined function includes properties and characteristics. A scalar function returns a single data value (i.e. not a table) with a return clause. In an embodiment, scalar functions may utilize all scalar data types with the exception of user-defined data types. A table-valued function may return the result of a single select statement and a multi-statement table-valued function may return a table.</p><p id="p-0042" num="0039">In embodiments disclosed herein, where a user-defined function is used for securely analyzing data, the user-defined function may have a secure user-defined function definition. The secure UDF may be created by a first account and shared with one or more secondary accounts. The first account may grant usage privileges to the one or more secondary accounts such that the secondary accounts may, for example, utilize the functionality of the UDF without viewing any procedural logic making up the UDF.</p><p id="p-0043" num="0040">With respect to secure views, some optimizations for views require access to underlying data in the base tables for the view. Access to the underlying data may permit data that is hidden from users of the view to be exposed by, for example, UDFs or other programmatic methods. Secure views as disclosed in the present application do not utilize such optimizations and ensure that users have no access to the underlying data. According to one embodiment, the query expression to create a standard view (may also be referred to as the view definition or text) may be visible to users. In such an embodiment, a user may not wish to expose the underlying tables or internal structural details for a view due to security or privacy reasons. With a secure view as disclosed herein, the view definition and details are only visible to authorized users i.e. users that have been granted the role that owns the view.</p><p id="p-0044" num="0041">A view may be defined as a secure view when it is specifically designated for data privacy or to limit access to data that should not be exposed to all accounts of the underlying table. Data might be exposed in a non-secure view when, for example, an account has access to only a subset of data. An example scenario where information may be leaked includes the following. A database table includes employee data for an entire company and a view is defined to expose employee data for a single department. An account, for example belonging to a head of the single department, is granted access to the view but not the underlying table. In such an embodiment, a user may gain insight into data from other departments by querying on the view. If the filter in the query is evaluated before the join between the &#x201c;employee&#x201d; field and the &#x201c;department&#x201d; field, the user may deduce whether anyone in the entire company satisfies a certain metric (e.g. has a salary over x amount, etc.). Such a technique may be utilized to query any data within the base table. A user-defined function that carries a state across invocations can be utilized in a similar way to leak the results of even more sophisticated queries on the base table data.</p><p id="p-0045" num="0042">Secure views permit database client accounts to expose a restricted data set to other users without the possibility of the underlying, unrestricted data being exposed to those other users. Similar to views, user-defined functions (UDFs) permit a client account to expose restricted data to other users, with additional capabilities due to argument processing and procedural language support. Secure UDFs may provide the same security guarantees as secure views.</p><p id="p-0046" num="0043">In an embodiment, a secure view provides several security guarantees when compared against a regular view. In an embodiment, the secure view does not expose the view definition to non-owners of the view. This impacts various operations that access the data dictionary. In an embodiment, the secure view does not expose information about any underlying data of the view, including the amount of data processed by the view, the tables accessed by the view, and so forth. This impacts the statistics that are displayed about the number of bytes and partitions scanned in a query, and what is displayed in the query profile for a query referring to a secure view. In an embodiment, the secure view does not expose data from tables accessed by the view which is filtered out by the view. In such an embodiment, a client account associated with a non-secure view may access data that would be filtered out by taking advantage of query optimizations that may cause user expressions to be evaluated before security expressions (e.g. filters and joints). In such an embodiment, to achieve this requirement, the set of query optimizations that can be applied to a query containing a secure view may be restricted to guarantee that the user expressions that can leak data are not evaluated before the view is filtered.</p><p id="p-0047" num="0044">Multi-tenant databases or multi-tenant data warehouse support multiple distinct customer accounts at once. As an example, <figref idref="DRAWINGS">FIG. <b>1</b></figref> is a schematic block diagram illustrating a multi-tenant database or data warehouse that supports many different customer accounts A<b>1</b>, A<b>2</b>, A<b>3</b>, An, etc. Customer accounts may be separated by multiple security controls, including different uniform resource locators (URLs) to connect to, different access credentials, different data storage locations (such as Amazon Web Services S<b>3</b> buckets), and different account-level encryption keys. Thus, each customer may only be allowed to see, read, and/or write the customer's own data. By design it may be impossible for a customer to see, read, or write another customer's data. In some cases, strict separation of customer accounts is the backbone of a multi-tenant data warehouses or database system.</p><p id="p-0048" num="0045">In some cases, it may be desirable to allow cross-account data sharing. However, no current multi-tenant database system allows sharing of data between different customer accounts in an instantaneous, zero-copy, easy-controllable fashion.</p><p id="p-0049" num="0046">Based on the foregoing, disclosed herein are systems, methods, and devices that, in one embodiment, may be implemented for generating a secure join in a multi-tenant online database system. Some embodiments allow the implementation of secure joins, secure UDFs, and/or secure views between different customer accounts and may make the data instantly accessible with no need to copy data. Some embodiments provide access to data using fine-grained controls to maintain separation of desired data while allowing access to data that a customer wishes to share.</p><p id="p-0050" num="0047">Embodiments disclosed herein provide systems, methods, and devices for sharing a &#x201c;share object&#x201d; or &#x201c;database object&#x201d; between a sharer account and one or more other accounts in a database system. The share object or database object in one implementation may include procedural logic that is defined by a user of a client account (in one implementation, by a user of the sharer account). The share object may be supported in scalar and table-valued user-defined functions (UDFs) and may be defined by any suitable language. In an implementation, the procedural logic of the share object may be used by one or more other accounts without permitting the one or more other accounts to view the underlying code defining the procedural logic. The share object or database object may further include database data such as data stored in a table of the database. The share object or database object may include metadata about database data such as minimum/maximum values for a table or micro-partition of a database, underlying structural or architectural details of the database data, and so forth. The share object may include a listing of all other accounts that may receive cross-account access rights to elements of the share object. The listing may indicate, for example, that a second account may use procedural logic of the share object without seeing any underlying code defining the procedural logic. The listing may further indicate, for example, that a third account may use database data of one or more tables without seeing any structural information or metadata about the database data. The listing may indicate any combination of usage privileges for elements of the share object, including whether secondary accounts may see metadata or structural information for database data or procedural logic.</p><p id="p-0051" num="0048">The embodiments disclosed herein may be supported in scalar and table-valued user-defined functions (UDFs). Various languages may be utilized including SQL and Javascript for each of the scalar and table-valued UDFs.</p><p id="p-0052" num="0049">In an embodiment, a scalar SQL UDF includes a SQL expression that including parameters that may be replaced with arguments appearing in the function invocation. The expression may include a query expression (i.e. a subquery), and in an embodiment, the query expression must be guaranteed to return a single row and a single column. At compile-time, a function invocation is replaced with the SQL expression and parameters in the expression are replaced with the invocation's arguments. The result may be a simple SQL expression or a subquery (may be correlated or non-correlated). In an embodiment, because a scalar SQL UDF may include arbitrary SQL expressions, the secure UDF may be configured to (1) not expose the view definition to non-owners of the view and (2) not expose information about any underlying data of the view.</p><p id="p-0053" num="0050">In an embodiment, a table-valued SQL UDF is similar to a view wherein the query may include parameters. As a result, table-valued UDFs may appear as correlated tables and may be decorrelated during query compilation. In an embodiment, because a table-valued SQL UDF can include arbitrary SQL expressions, the secure UDFs may be configured to (1) not expose the view definition to non-owners of the view, (2) not expose information about any underlying data of the view, and (3) not expose data from tables accessed by the view which is filtered out by the view.</p><p id="p-0054" num="0051">In an embodiment, a scalar Javascript UDF is converted to a built-in function that evaluates a piece of Javascript code for reach row that is processed and passes arguments from those rows into the function. In an embodiment, because a Javascript UDF cannot access database tables, the UDF may be configured to (1) not expose information about any underlying data of the view and (2) not expose data from tables accessed by the view which is filtered out by the view.</p><p id="p-0055" num="0052">In an embodiment, a table-valued Javascript UDF is processed such that rows are grouped together and the Javascript code is evaluated per group and row processed by passing expressions from rows into the function. In an embodiment, because a Javascript UDF cannot access database tables, the UDF may be configured to (1) not expose information about any underlying data of the view and (2) not expose data from tables accessed by the view that are filtered out by the view.</p><p id="p-0056" num="0053">Embodiments disclosed herein provide technology which may be used for determining common datapoints between different customer accounts in an online database and/or online data warehouse. In one embodiment, a secure join to determine common datapoints is enabled using cross-account role grants that allow users in one customer account to access data in another customer account in a controlled and instantaneous fashion by way of a secure view and/or a secure UDF, without the need to copy data. For example, the shared data may remain within the sharing account while allowing a foreign account to run a secure UDF on the shared data.</p><p id="p-0057" num="0054">A detailed description of systems and methods consistent with embodiments of the present disclosure is provided below. While several embodiments are described, it should be understood that this disclosure is not limited to any one embodiment, but instead encompasses numerous alternatives, modifications, and equivalents. In addition, while numerous specific details are set forth in the following description to provide a thorough understanding of the embodiments disclosed herein, some embodiments may be practiced without some or all these details. Moreover, for the purpose of clarity, certain technical material that is known in the related art has not been described in detail to avoid unnecessarily obscuring the disclosure.</p><p id="p-0058" num="0055">Referring now to the figures, <figref idref="DRAWINGS">FIG. <b>1</b></figref> is a schematic block diagram illustrating a multi-tenant database or data warehouse that supports many different customer accounts A<b>1</b>, A<b>2</b>, A<b>3</b>, An, etc. Customer accounts may be separated by multiple security controls, including different uniform resource locators (URLs) to connect to, different access credentials, different data storage locations (such as Amazon Web Services S<b>3</b> buckets), and different account-level encryption keys. Thus, each customer may only be allowed to see, read, and/or write the customer's own data. By design it may be impossible for a customer to see, read, or write another customer's data. In some cases, strict separation of customer accounts is the backbone of a multi-tenant data warehouses or database system.</p><p id="p-0059" num="0056"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a schematic diagram of a system <b>200</b> for providing and accessing database data or services. The system <b>200</b> includes a database system <b>202</b>, one or more servers <b>204</b>, and a client computing system <b>206</b>. The database system <b>202</b>, the one or more servers <b>204</b>, and/or the client computing system <b>206</b> may communicate with each other over a network <b>208</b>, such as the Internet. For example, the one or more servers <b>204</b>, and/or the client computing system <b>206</b> may access the database system <b>202</b> over the network <b>208</b> to query a database and/or receive data from a database. The data from the database may be used by the one or more servers <b>204</b> or client computing system <b>206</b> for any type of computing application. In one embodiment, the database system <b>202</b> is a multi-tenant database system hosting data for a plurality of different accounts.</p><p id="p-0060" num="0057">The database system <b>202</b> includes a share component <b>210</b> and storage <b>212</b>. The storage <b>212</b> may include storage media for storing data. For example, the storage <b>212</b> may include one or more storage devices for storing database tables, schemas, encryption keys, data files, or any other data. The share component <b>210</b> may include hardware and/or software for enabling the cross-account sharing of data or services and/or for associating view privileges with data or services. For example, the share component <b>210</b> may define a secure UDF and/or a secure view such that two or more accounts may determine common datapoints by way of the secure UDF without revealing the datapoints themselves or any other datapoints that are not common between the accounts. Further for example, the share component <b>210</b> may process queries/instructions received from remote devices to access shared data or share data. The queries/instructions may be received from the one or more servers <b>204</b> or client computing system <b>206</b>. In one embodiment, the share component <b>210</b> is configured to allow sharing data between accounts without creating duplicate copies of tables, data, or the like outside the sharing account. For example, the share component may allow for computer resources allocated to a sharing account to perform any queries or instructions provided by a foreign account.</p><p id="p-0061" num="0058">In one embodiment, the share component <b>210</b> defines a user-defined function that includes procedural logic for determining an overlap count between data stored in a first account and data stored in a second account. The data stored in the first account and the data stored in the second account may be identified by, for example, a resource manager or global services associated with each of the two accounts. The share component <b>210</b> may share the user-defined function with the second account such that the second account may run the user-defined function on one or more compute nodes to determine common datapoints between the first account and the second account.</p><p id="p-0062" num="0059">In one embodiment, storage and compute resources for a database system <b>100</b> may be logically and/or physically separated. In one embodiment, storage is a common, shared resource across all accounts. Compute resources may be set up independently, per account, as virtual warehouses. In one embodiment, a virtual warehouse is a set of compute nodes that access data in a storage layer and compute a query result. Separating the compute nodes or resources from the storage allows scaling each layer independently. Separation of storage and compute also allows that shared data can be processed independently by different accounts, without the computation in one account affecting the computation in other accounts. That is, in at least some embodiments, there is no contention among computing resources when running queries on shared data.</p><p id="p-0063" num="0060"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a schematic block diagram of a multi-tenant database <b>300</b> illustrating separation of storage and computing resources. For example, the multi-tenant database <b>300</b> may be a data warehouse where a plurality of different accounts (A<b>1</b>, A<b>2</b>, A<b>3</b>, through An) are hosted. In <figref idref="DRAWINGS">FIG. <b>3</b></figref>, account A<b>1</b> has three virtual warehouses running, account A<b>2</b> has one virtual warehouse running, and account A<b>3</b> has no virtual warehouse running. In one embodiment, all these virtual warehouses have access to the storage layer that is separated from the compute nodes of the virtual warehouses. In one embodiment, virtual warehouses can be dynamically provisioned or removed based on a current workload for an account.</p><p id="p-0064" num="0061">In one embodiment, a multi-tenant database system <b>300</b> uses object hierarchies in accounts. For example, each customer account may contain object hierarchies. Object hierarchies are often rooted in databases. For example, databases may contain schemas and schemas, in turn, may contain objects such as tables, views, sequences, file formats, and functions. Each of these objects serves a special purpose: tables store relational or semi-structured data; views define logical abstractions over the stored data; sequences provide means to generate ever-increasing numbers; file formats define ways to parse ingested data files; and functions hold user-defined execution procedures. In embodiments as disclosed herein, views may be associated with secure user-defined function definitions such that underlying data associated with the view is hidden from non-owner accounts who have access to the view.</p><p id="p-0065" num="0062"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a schematic block diagram illustrating object hierarchies within customer accounts. Specifically, accounts may include hierarchies of objects which may be referenced in a database. For example, customer account A<b>1</b> contains two databases objects D<b>1</b> and D<b>2</b>. Database object D<b>1</b> contains schema object S<b>1</b>, which in turn contains table object T<b>1</b> and view object V<b>1</b>. Database object D<b>2</b> contains schema object S<b>2</b>, which contains function object F<b>2</b>, sequence object Q<b>2</b>, and table object T<b>2</b>. Customer account A<b>2</b> contains a database object D<b>3</b> with schema object S<b>3</b> and table object T<b>3</b>. The object hierarchies may control how objects, data, functions, or other information or services of an account or database system are accessed or referenced.</p><p id="p-0066" num="0063">In one embodiment, a database system implements role-based access control to govern access to objects in customer accounts. In general, role-based access control consists of two basic principles: roles and grants. In one embodiment, roles are special objects in a customer account that are assigned to users. Grants between roles and database objects define what privileges a role has on these objects. For example, a role that has a usage grant on a database can &#x201c;see&#x201d; this database when executing the command &#x201c;show databases&#x201d;; a role that has a select grant on a table can read from this table but not write to the table. The role would need to have a modify grant on the table to be able to write to it.</p><p id="p-0067" num="0064"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a schematic block diagram illustrating role-based access to objects in customer accounts. A customer account A<b>1</b> contains role R<b>1</b>, which has grants to all objects in the object hierarchy. Assuming these grants are usage grants between R<b>1</b> and D<b>1</b>, D<b>2</b>, S<b>1</b>, S<b>2</b> and select grants between R<b>1</b> and T<b>1</b>, V<b>1</b>, F<b>2</b>, Q<b>2</b>, T<b>2</b>, a user with activated role R<b>1</b> can see all objects and read data from all tables, views, and sequences and can execute function F<b>2</b> within account A<b>1</b>. Customer account A<b>2</b> contains role R<b>3</b>, which has grants to all objects in the object hierarchy. Assuming these grants are usage grants between R<b>3</b> and D<b>3</b>, S<b>3</b>, and select a grant between R<b>3</b> and T<b>3</b>, a user with activated role R<b>3</b> can see all objects and read data from all tables, views, and sequences within account A<b>2</b>.</p><p id="p-0068" num="0065"><figref idref="DRAWINGS">FIG. <b>6</b></figref> illustrates a usage grant between roles. With role-based access control, it is also possible to grant usage from one role to another role. A role that has a usage grant to another role &#x201c;inherits&#x201d; all access privileges of the other role. For example, in role R<b>2</b> has a usage grant on role R<b>1</b>. A user (e.g., with corresponding authorization details) with activated role R<b>2</b> can see and read from all objects because role R<b>2</b> inherits all grants from role R<b>1</b>.</p><p id="p-0069" num="0066"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a schematic block diagram illustrating a share object SH<b>1</b>. In an embodiment, the share object is a column of data across one or more tables and cross-account access rights are granted to the share object such that one or more other accounts may determine common datapoints between data stored in the share object and data stored in the one or more other accounts. Customer account A<b>1</b> contains share object SH<b>1</b>. Share object SH<b>1</b> has a unique name &#x201c;SH<b>1</b>&#x201d; in customer account A<b>1</b>. Share object SH<b>1</b> contains role R<b>4</b> with grants to database D<b>2</b>, schema S<b>2</b>, and table T<b>2</b>. The grants on database D<b>2</b> and schema S<b>2</b> may be usage grants and the grant on table T<b>2</b> may be a select grant. In this case, table T<b>2</b> in schema S<b>2</b> in database D<b>2</b> would be shared read-only. Share object SH<b>1</b> contains a list of references to other customer accounts, including account A<b>2</b>.</p><p id="p-0070" num="0067">After a share object is created, the share object may be imported or referenced by a target account listed in the share object. For example, importing a share object from a sharer account is possible from other customer accounts. A target account may run a command to list all available share objects for importing. Only if a share object was created with references that included the target account, the target account may list the share object and subsequently import it. In one embodiment, references to a share object in another account are always qualified by account name. For example, target account A<b>2</b> would reference share SH<b>1</b> in sharer account A<b>1</b> with the example qualified name &#x201c;A<b>1</b>.SH<b>1</b>&#x201d;.</p><p id="p-0071" num="0068">In one embodiment, a process or importing a share object may include: creating an alias object in the target account; linking the alias object with the top-most shared object in the sharer account in the object hierarchy; granting a role in the target account usage privileges to the alias object; and granting the target account role usage privileges to the role contained in the share object.</p><p id="p-0072" num="0069">In one embodiment, a target account that imports the share object or data creates an alias object. An alias object is similar to a normal object in a customer account. An alias object has its own unique name with which it is identified. An alias object may be linked to the top-most object in each object hierarchy that is shared. If multiple object hierarchies are shared, multiple alias objects may be created in the target account. Whenever an alias object is used (e.g., reading from the alias object, writing to the alias object), the alias object is internally replaced by the normal object in the sharer account to which it links. This way, alias objects are merely proxy objects of normal objects, and not duplicate objects. Thus, when reading from or writing to an alias object, the operations affect the original object that the alias links to. Like normal objects, when an alias object is created it is granted to the activated role of the user.</p><p id="p-0073" num="0070">In addition to the alias object, a grant between a role in the target account and the role contained in the share object is created. This is a usage grant from role to role across customer accounts. Role-based access control now allows a user in the target account to access objects in the sharer account.</p><p id="p-0074" num="0071"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a schematic block diagram illustrating logical grants and links between different accounts. A database alias object D<b>5</b> is created in account A<b>2</b>. Database alias D<b>5</b> references database D<b>2</b> via link L<b>1</b>. Role R<b>3</b> has a usage grant G<b>1</b> on database D<b>5</b>. Role R<b>3</b> has a second usage grant G<b>2</b> to role R<b>4</b> in customer account A<b>1</b>. Grant G<b>2</b> is a cross-account grant between accounts A<b>1</b> and A<b>2</b>. In one embodiment, role-based access control allows a user in account A<b>2</b> with activated role R<b>3</b> to access data in account A<b>1</b>. For example, if a user in account A<b>2</b> wants to read data in table T<b>2</b>, role-based access control allows that because role R<b>3</b> has a usage grant of role R<b>4</b> and role R<b>4</b>, in turn, has a select grant on table T<b>2</b>. By way of illustration, a user with activated role R<b>3</b> may access T<b>2</b> by running a query or selection directed to &#x201c;D<b>5</b>.S<b>2</b>.T<b>2</b>&#x201d;.</p><p id="p-0075" num="0072">Using object aliases and cross-account grants from a role in the target account to a role in the sharer account allows users in the target account to access information in the sharer account. In this way, a database system may enable sharing of data between different customer accounts in an instantaneous, zero-copy, easy-controllable fashion. The sharing can be instantaneous because alias objects and cross-account grants can be created in milliseconds. The sharing can be zero-copy because no data must be duplicated in the process. For example, all queries, or selections can be made directly to the shared object in the sharer account without creating a duplicate in the target account. The sharing is also easy to control because it utilizes easy-to-use techniques of role-based access control. Additionally, in embodiments with separated storage and compute, there is no contention among computing resources when executing queries on shared data. Thus, different virtual warehouses in different customer accounts may individually process shared data. For example, a first virtual warehouse for a first account may process a database query or statement using data shared by a sharer account and a second virtual warehouse for a second account, or the sharer account, may process a database query or statement using the shared data of the sharer account.</p><p id="p-0076" num="0073"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a schematic block diagram of a share component <b>210</b>. The share component <b>210</b> includes a cross-account rights component <b>902</b>, an alias component <b>904</b>, a request component <b>906</b>, an access component <b>908</b>, a processing component <b>910</b>, and a secure view component <b>912</b>. The components <b>902</b>-<b>912</b> are given by way of example only and may not all be included in all embodiments. For example, each of the components <b>902</b>-<b>912</b> may be included in or may be implemented as part of a separate device or system.</p><p id="p-0077" num="0074">The cross-account rights component <b>902</b> is configured to create and manage rights or grants between accounts. The cross-account rights component <b>902</b> may generate a share object in a sharer account. For example, a user of the sharer account may provide input indicating that one or more resources should be shared with another account. In one embodiment, the user may select an option to create a new share object so that resources can be shared with foreign accounts. In response to the user input, the cross-account rights component <b>902</b> may create a share object in the sharer account. The share object may include a role to which access rights can be granted to resources for sharing with a foreign account. The foreign account may include a customer account or other account that is separate from the sharer account. For example, the foreign account may be another account hosted on a multi-tenant database system.</p><p id="p-0078" num="0075">Upon creation, the share object may be granted rights to one or more resources within the sharer account. The resources may include a database, a schema, a table, a sequence, or a function of the sharer account. For example, the share object may contain a role (i.e., share role) which is granted right to read, select, query, or modify a data storage object, such as a database. The share object, or share role in the share object, may be granted rights similar to how rights may be granted to other roles using role-based access control. A user may be able to access an account and grant rights to the share role so that the share role can access resources that are meant to be shared with foreign accounts. In one embodiment, the share object may include a list of objects, and an access level, for which the share role has rights.</p><p id="p-0079" num="0076">The share object may also be made available or linked to specific foreign accounts. For example, the share object may store a list of accounts that have rights to the share role or share object in the sharer account. A user with the sharer account may add or remove accounts to the list of accounts. For example, the user may be able to modify the list to control which accounts can access objects shared via the share object. Foreign accounts listed or identified in the share object may be given access to resources with access rights granted to a share role of the share object. In one embodiment, a specific account can perform a search to identify share objects or sharer accounts that have been shared with the specific account. A list of available share objects can be viewed by a user of the target or specific account.</p><p id="p-0080" num="0077">The alias component <b>904</b> is configured to generate an alias for data or a data object shared by a separate account. For example, the alias object may create, in a target account, an alias object corresponding to a shared resource shared by a sharer account. In one embodiment, the alias object is created in response to a target account accepting a shared resource or trying to access a shared resource for the first time. The alias object may act as an alias for a data object for the highest object hierarchy shared by the sharer account (see, e.g., <figref idref="DRAWINGS">FIG. <b>8</b></figref> where D<b>5</b> is an alias for D<b>2</b>). The alias component <b>904</b> may also generate a link between the alias object and a shared object (see, e.g., <figref idref="DRAWINGS">FIG. <b>8</b></figref> where L<b>1</b> is the link between D<b>5</b> and D<b>2</b>). The link may be created and/or stored in the form of an identifier or name of the original or &#x201c;real&#x201d; object. For example, the link L<b>1</b> in <figref idref="DRAWINGS">FIG. <b>8</b></figref> may include an identifier for D<b>2</b> stored in the alias object D<b>5</b> that includes a unique system wide name, such as &#x201c;A<b>1</b>. D<b>2</b>&#x201d;.</p><p id="p-0081" num="0078">The alias component <b>904</b> may also grant a role in the target account (the account with which the sharer account has shared data or resources) access rights to the alias object (see, e.g., G<b>1</b> of <figref idref="DRAWINGS">FIG. <b>8</b></figref>). Additionally, the alias component <b>904</b> may also grant the role in the target account to a share role in the share object of the sharer account (see, e.g., G<b>2</b> of <figref idref="DRAWINGS">FIG. <b>8</b></figref>). With the alias object created, a link between the alias object and an object in the sharer account, and grants to a role in the target account, the target account may be free to run queries, statements, or &#x201c;see&#x201d; shared data or resources in the sharer account.</p><p id="p-0082" num="0079">The request component <b>906</b> is configured to receive a request from an account to access a shared resource in a different account. The request may include a database query, select statement, or the like to access a resource. In one embodiment, the request includes a request directed to an alias object of the requesting account. The request component <b>906</b> may identify a resource with which the alias object is linked, such as a database or table in a sharer account. The request component <b>906</b> may identify the linked object based on an identifier of the alias object.</p><p id="p-0083" num="0080">The request component <b>906</b> may further be configured to receive a request from an account to count common datapoints between two accounts. The request component <b>906</b> may be associated with a first account and may receive a request from a second account to generate a secure join between the two accounts and determine how many, and which, datapoints are shared between the two accounts. The datapoints may be of a single subject matter or column identifier or may be of multiple subject matters.</p><p id="p-0084" num="0081">The access component <b>908</b> is configured to determine whether an account has access to a shared resource of a different account. For example, if a first account requests access to a resource of a different, second account, the access component <b>908</b> may determine whether the second account has granted access to the first account. The access component <b>908</b> may determine whether a requesting account has access by determining whether a share object identifies the requesting account. For example, the access component <b>908</b> may check if the requesting account is present in a list of accounts stored by a share object. The access component <b>908</b> may also check whether the share object that identifies the requesting account has access rights (e.g., grants) to the targeted data resource in the sharer account.</p><p id="p-0085" num="0082">In one embodiment, the access component <b>908</b> may check for the presence of a grant from a share role in a sharer account to a requesting role in the requesting account. The access component <b>908</b> may check whether a link exists between an alias object to which a database request or statement was directed or whether a grant exists between a requesting role and the alias object. For example, the access component <b>908</b> may check for the existence or presence of one or more of L<b>1</b>, G<b>1</b> and G<b>2</b> illustrated in <figref idref="DRAWINGS">FIG. <b>8</b></figref>. Furthermore, the access component <b>908</b> may check for a grant between a role in a share object to an object (such as a table or database) of the sharer account. For example, the access component <b>908</b> may check for the existence of a grant between the role R<b>4</b> and the database D<b>2</b> in <figref idref="DRAWINGS">FIG. <b>8</b></figref>. If the access component <b>908</b> determines that the requesting account has access to the shared resource, the request may be fulfilled by the share component <b>210</b> or a processing component <b>910</b>. If the access component <b>908</b> determines that the requesting account does not have rights to the requested data or object, the request will be denied.</p><p id="p-0086" num="0083">The processing component <b>910</b> is configured to process database requests, queries, or statements. The processing component <b>910</b> may process and provide a response to a request from an account to access or use data or services in another account. In one embodiment, the processing component <b>910</b> provides a response to a request by processing the request using original data in a sharer account that is different from the requesting account. For example, the request may be directed toward a database or table stored in or for a first account and the processing component <b>910</b> may process the request using the database or table of the first account and return a response to a requesting, second account.</p><p id="p-0087" num="0084">In one embodiment, the processing component <b>910</b> performs processing of shared data without creating a duplicate table or other data source in the requesting account. Generally, data must be first ingested into an account that wishes to process that data or perform operations against the data. The processing component <b>910</b> may save processing time, delay, and/or memory resources by allowing a target account to access shared resources in a sharer account without creating a copy of a data resource in the target account.</p><p id="p-0088" num="0085">The processing component <b>910</b> may perform processing of the same data using different processing resources for different accounts. For example, a first virtual warehouse for a first account may process a database query or statement using data shared by a sharer account and a second virtual warehouse for a second account, or the sharer account, may process a database query or statement using the shared data of the sharer account. Using separate processing resources to process the same data may prevent contention for processing resources between accounts. The processing resources may include dynamically provisioned processing resources. In one embodiment, processing of shared data is performed using a virtual warehouse for the requesting account even though the data may be in storage for a different account.</p><p id="p-0089" num="0086">The secure view component <b>912</b> is configured to define a secure view for a share object, a data field of a share object, a data field of a database object, and so forth. In an embodiment, the secure view component <b>912</b> defines the secure view using a SECURE keyword in a view field and may set or unset the SECURE property on a view using an ALTER VIEW command. In various embodiments, the secure view component <b>912</b> may implement such commands only at the manual direction of a client account or may be configured to automatically implement such commands. The secure view component <b>912</b> may alter the parser to support the secure keyword before the view name and the new alter view rule. In an embodiment, the alter view rule may be more general to incorporate further view-level attributes. In terms of metadata support, the vies may effectively be stored as tables, and the change may involve altering a table data persistence object that includes a secure flag indicating whether the view is a secure view (this may be implemented in addition to the view text comprising the secure tag). The secure user-defined function definition (i.e. the table data persistence object) may be hidden from users that are not the owner of the view. In such an embodiment, a command to show views will return results as usual to the owner of the view but will not return the secure user-defined function definition to a non-owner second account that has access to the view.</p><p id="p-0090" num="0087">The secure view component <b>912</b> may alter transformations of a parse tree, e.g. view merging and predicate information. The canonical implementation may include annotating query blocks such that the query blocks are designated as coming from secure view. In such an implementation, the query blocks cannot be combined with external query blocks (e.g. view merging) or expressions (e.g. via filter pushdown).</p><p id="p-0091" num="0088">The secure view component <b>912</b> may rewrite the query plan tree during optimization e.g. during filter pullup and/or filter pushdown. The secure view component <b>912</b> may be configured to ensure that no expression that does not stem from a secure view can be pushed down below the view boundaries. The secure view component <b>912</b> may be configured to achieve this by implementing a new type of projection that behaves identically to a standard projection but, since it is not a standard projection, fails to match any of the rewrite rule preconditions. As a result, the relevant rewrites are not applied. The secure view component <b>912</b> may be configured to identify what type of projection is to be generated (e.g. a standard projection or a secure projection) after query blocks have been designated as coming from a secure user-defined function definition or not.</p><p id="p-0092" num="0089">The secure view component <b>912</b> is configured to optimize performance for secure views in a zero-copy data sharing system. In various embodiments known in the art, secure views are known to cause a loss of performance that may effectively cripple the optimizer from applying certain transformations. Such embodiments might be improved by deeming certain transformations as safe, where safety indicates that the operations being transformed will not have any side effects on the system. Such side effects may be caused by a user defined function (UDF) that performs operations that cannot readily identify unsafe operations, or operations that can fail and reveal information about the data value that caused the failure (e.g. when dividing by zero or some similar operation). The secure view component <b>912</b> may annotate expressions with the expression's safety properties and then enable transformations that allow an expression to be pushed through a secure view boundary if the expression is deemed safe. The expression may be deemed safe if the expression is known to produce no errors and the expression does not contain a user defined function (UDF). The secure view component <b>912</b> may determine whether the expression produces errors by utilizing an expression properties framework where the expression properties store an indication whether an expression may produce errors.</p><p id="p-0093" num="0090"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a schematic diagram of a system <b>1000</b> for generating a secure join between two accounts. The secure join takes place between a provider <b>1002</b> and a receiver <b>1006</b>. It should be appreciated that the terms &#x201c;provider&#x201d; and &#x201c;receiver&#x201d; are illustrative only and may alternatively be referred to as a first account and a second account, as a sharer account and a target account, as a provider and a consumer, and so forth. In an embodiment, the provider <b>1002</b> and the receiver <b>1006</b> are different accounts associated with the same cloud-based database administrator. In an embodiment, the provider <b>1002</b> and the receiver <b>1006</b> are associated with different cloud-based and/or traditional database systems. The provider <b>1002</b> includes a provider execution platform <b>1004</b> having one or more execution nodes capable of executing processing tasks on the database data of the provider <b>1002</b>, wherein the database data is stored in a data store associated with the provider <b>1002</b>. Similarly, the receiver <b>1006</b> includes a receiver execution platform <b>1008</b> having one or more execution nodes capable of executing processing tasks on the database data of the receiver <b>1006</b>, wherein the database data is stored on a data store associated with the receiver <b>1006</b>. The data store may include cloud-based scalable storage such that the database data is spread across a plurality of shared storage devices accessible by an execution platform such as <b>1004</b> or <b>1008</b>. The secure join between the provider <b>1002</b> and the receiver <b>1006</b> is implemented with a secure user-defined function <b>1010</b> (&#x201c;secure UDF&#x201d;). The secure UDF <b>1010</b> includes programming logic and/or a hash key for generating a secure join key <b>1012</b>. The secure UDF <b>1010</b> may be generated by the provider <b>1002</b>, the receiver <b>1006</b>, a database administration system, and/or a third party. The secure UDF <b>1010</b> may be run on the provider execution platform <b>1004</b> and/or the receiver execution platform <b>1008</b>. In an embodiment, the secure UDF <b>1010</b> is only run on the receiver execution platform <b>1008</b> and the provider <b>1002</b> has no visibility into whether or when the secure UDF <b>1010</b> was run by the receiver <b>1006</b>.</p><p id="p-0094" num="0091">In an embodiment, the secure UDF <b>1010</b> is defined by the provider <b>1002</b> and made available to the receiver <b>1006</b>. The secure UDF <b>1010</b> is configured to generate the secure join key <b>1012</b> for joining data associated with the provider <b>1002</b> with data associated with the receiver <b>1006</b>. The secure join key <b>1012</b> is a hash string. In an embodiment, the secure join key <b>1012</b> is a one-way hash that cannot be read by either of the provider <b>1002</b> or the receiver <b>1006</b> to discern the original data. The secure join key <b>1012</b> includes data from the provider <b>1002</b> and data from the receiver <b>1006</b>. In an embodiment, the data from the provider <b>1002</b> and/or the data from the receiver <b>1006</b> is salted before running the secure UDF <b>1010</b> to generate the secure join key <b>1012</b>. In such an embodiment, the salted value is hashed by the secure UDF <b>1010</b> and cannot be read by the other party. In an embodiment, a database administrator implements the secure UDF <b>1010</b> to generate the secure join key <b>1012</b> and the database administrator is solely capable of reverting the secure join key <b>1012</b> to the original data. This introduces additional security benefits that may be necessary in certain implementations, for example where the data includes sensitive information such as personally identifiable information and/or personal health information.</p><p id="p-0095" num="0092">In an embodiment, the original data from the provider <b>1002</b> and/or the original data from the receiver <b>1006</b> is salted before the secure join key is generated. The salt may include any information or characters that are only known to the owner of the data, i.e. the provider <b>1002</b> or the receiver <b>1006</b>. A salted datapoint may include the original datapoint with a salt adhered to it. By way of example, if the original datapoint is a customer's name such as &#x201c;Susan,&#x201d; the salted datapoint may read something like &#x201c;SusanSALT123&#x201d; where &#x201c;SALT123&#x201d; represents any string of characters (i.e., the salt) that is known only by the owner of the data. In an embodiment, the salt may be known to the owner of the data and may further be known to a database system or provider that is responsible for generating the secure join key, implementing the secure UDF, and/or storing database data.</p><p id="p-0096" num="0093">In an embodiment, the secure UDF <b>1010</b> is in communication with and can access the data of the provider <b>1002</b> and is run on the receiver execution platform <b>1008</b>. The secure UDF <b>1010</b> includes hashing code and generates the secure join key <b>1012</b>. The secure UDF <b>1010</b> performs the on-way hash on the provider's <b>1002</b> data to generate the secure join key <b>1012</b>. In an embodiment, an additional secure user-defined function is configured to perform analysis at <b>1014</b> that is based on the secure join key. Example analyses that may be performed based on the secure join key <b>1012</b> includes a count of overlapping datapoints at <b>1016</b>, an identification of overlapping datapoints at <b>1018</b>, and/or an analysis on shared datapoints at <b>1020</b>. A number of different analyses may be performed to determine similarities or differences between the provider's <b>1002</b> data and the receiver's <b>1006</b> data. Each of the different analyses may be performed by a different secure user-defined function that may be programmed by the provider <b>1002</b>, the receiver <b>1006</b>, a third party, a system administrator, and so forth.</p><p id="p-0097" num="0094">The system <b>1000</b> is configured such that neither of the provider <b>1002</b> nor the receiver <b>1006</b> has any visibility into the original data stored in the other account. The original data is hashed by the secure UDF <b>1010</b> using a one-way hash such that the original data is converted into an unidentifiable stream of hashed data and cannot be reverted by the provider <b>1002</b> or the receiver <b>1006</b> to determine the original data.</p><p id="p-0098" num="0095">An additional secure user-defined function may perform any of the one or more analyses based on the secure join key at <b>1014</b>. In an embodiment, a secure user-defined function performs a count of overlapping datapoints based on the hashed streams that make up the secure join key <b>1012</b>. The secure UDF <b>1010</b> may generate a separate hash stream of data from the provider <b>1002</b> and data from the receiver <b>1006</b>, and the collective hash streams may be referred to as the secure join key <b>1012</b>. The secure user-defined function that is configured to perform the count of overlapping datapoints may perform a row-by-row count or a bulk count to determine how many and which datapoints are the same between the provider <b>1002</b> and the receiver <b>1006</b>. This secure user-defined function may be configured to return only a yes/no answer for each pair of hashed datapoints to determine whether the pair of hashed datapoints is the same and therefore the provider <b>1002</b> and the receiver <b>1006</b> have a matching original datapoint. This secure user-defined function may return a listing of the identities of all matching datapoints and/or a total count of how many matching datapoints exist between the provider <b>1002</b> and the receiver <b>1006</b>.</p><p id="p-0099" num="0096"><figref idref="DRAWINGS">FIG. <b>11</b></figref> is a schematic diagram of a system <b>1100</b> for a reverse share secure join between a provider <b>1102</b> and a receiver <b>1106</b>. The reverse share provides a secure option for the receiver <b>1106</b> to generate a secure view <b>1114</b> of its data that may be provided to the receiver <b>1106</b> such that the receiver <b>1106</b> may run a secure user-defined function <b>1110</b> (&#x201c;secure UDF&#x201d;) on the provider's <b>1102</b> data. The secure UDF <b>1110</b> includes hashing code such that it is configured to take data from the provider <b>1102</b> and/or the receiver <b>1106</b> and hash the data to generate a secure join key <b>1112</b>. The secure join key <b>1112</b> may be used to perform various analyses on the provider's <b>1102</b> and the receiver's <b>1106</b> data, such as to determine how many and which datapoints are common between the provider <b>1102</b> and the receiver <b>1106</b>.</p><p id="p-0100" num="0097">In an embodiment, the secure UDF <b>1110</b> is only run on the receiver execution platform <b>1108</b> and is not run on any compute nodes owned or operated by the provider <b>1102</b>. In such an embodiment, the provider <b>1102</b> has no visibility into whether or when the secure UDF <b>1110</b> was run by the receiver. In the system <b>1100</b>, the secure UDF <b>1110</b> may be defined by the provider <b>1102</b>, by the receiver <b>1106</b>, by a third party, or by a database system administrator or database provider. The secure UDF <b>1110</b> generates the secure join key <b>1112</b> by hashing data from the provider <b>1102</b> and the receiver <b>1106</b>.</p><p id="p-0101" num="0098">In a reverse share as illustrated in <figref idref="DRAWINGS">FIG. <b>11</b></figref>, the data provided to the secure UDF <b>1110</b> may be salted. The salted data may be hashed to generate the secure join key <b>1112</b>. This provides additional security benefits so the other party cannot determine the original data. For example, the provider <b>1102</b> may adhere a salt to each of its datapoints and provide those salted datapoints to the secure view <b>1114</b> to be read by the secure UDF <b>1110</b>. When the secure UDF <b>1110</b> hashes the salted data points to generate the secure join key <b>1112</b>, each datapoint will have additional characters that have also been hashed. This hash string includes the original data and the salt, and both have been hashed such that the other party (the receiver <b>1106</b>) cannot determine the provider's <b>1102</b> actual data.</p><p id="p-0102" num="0099">For example, the provider <b>1102</b> and the receiver <b>1106</b> may be accounts associated with retail business. The two business may have stored their customer base on a database and may wish to determine how many and which customers the two business have in common. The customer base may include personal identifiable information about each customer, such as name, address, telephone number, and so forth. Each business (the provider <b>1102</b> and the receiver <b>1106</b>) may have an agreement with their customers to ensure such information remains private. Additionally, the provider <b>1102</b> and the receiver <b>1106</b> may not wish the other party to know who their customers are and may only wish to know how many customers they have in common. In the example, the provider <b>1102</b> may define the secure UDF <b>1110</b> with hashing code such that the secure UDF <b>1110</b> can generate a secure join key <b>1112</b>. The secure join key is an unidentifiable hash string of the provider's <b>1102</b> data and the receiver's data <b>1106</b>. The secure UDF <b>1110</b> may be run on the receiver execution platform <b>1108</b> such that the provider <b>1102</b> does not have any visibility into when or if the secure UDF <b>1110</b> was run. The provider <b>1102</b> may salt its data values to further disguise the original data from the receiver. For example, one datapoint owned by the provider <b>1102</b> may be a telephone number associated with one of the provider's <b>1102</b> customers. The provider <b>1102</b> may salt the telephone number (e.g. 801-555-5555) by adding a &#x201c;salt&#x201d; to the telephone number. The salted telephone number may have any characters added to it to disguise the original datapoint. By way of example, the salted telephone number may read SALT1238015555555SALT987. It should be appreciated that the salt added to the datapoints may be any suitable string of characters and may be known only by the salting party. The provider <b>1102</b> may provide the salted data values to the receiver <b>1106</b> by way of the secure view <b>1114</b>. The provider's <b>1102</b> salted data values will be hashed to generate the secure join key <b>1112</b>. Because the receiver <b>1106</b> does not have any knowledge of the salt, the receiver <b>1106</b> cannot discern any of the original data values by de-hashing the secure join key <b>1112</b>. The receiver <b>1106</b> may run the secure UDF <b>1110</b> on the receiver execution platform <b>1108</b> to generate the secure join key <b>1112</b>, and the receiver <b>1106</b> may further run one or more additional user-defined functions to analyze the data that is hashed in the secure join key <b>1112</b>. The receiver <b>1106</b> may wish to know, for example, how many customers the parties have in common, which customers the parties have in common, and so forth.</p><p id="p-0103" num="0100">In an embodiment as illustrated in <figref idref="DRAWINGS">FIG. <b>11</b></figref>, the receiver <b>1106</b> salts its data and may further hash its data before providing the data to the secure UDF <b>1110</b>. The receiver <b>1106</b> may provide salted hash values of its data to the secure UDF <b>1110</b> that was defined by the provider <b>1102</b>. The secure UDF <b>1110</b> generates the secure join key <b>1112</b> based on hashing code and on the salted hash values received from the receiver <b>1106</b>. The secure join key <b>1112</b> may be provided to the provider <b>1102</b> by way of the secure view <b>1114</b>.</p><p id="p-0104" num="0101">In an embodiment, the receiver <b>1106</b> may include additional salted hash values that do not represent any real receiver datapoints. This may prevent the provider <b>1102</b> from deducing anything about the size of the receiver's <b>1106</b> actual datastore by inspecting the contents of the reverse share. This technique may be referred to as &#x201c;noise injection&#x201d; and does not harm analytics performed on the data such as the count of common datapoints between the provider <b>1102</b> and the receiver <b>1106</b>.</p><p id="p-0105" num="0102"><figref idref="DRAWINGS">FIG. <b>12</b></figref> is a schematic block diagram of an exemplary embodiment of work distribution <b>1200</b> for a secure join between a provider <b>1202</b> and a receiver <b>1206</b>. The work distribution <b>1200</b> is split amongst the provider <b>1202</b>, the secure user-defined function (UDF) <b>1204</b>, and the receiver <b>1206</b>. In an embodiment, the secure UDF <b>1204</b> is run on an execution platform belonging to the receiver <b>1206</b>. The secure UDF <b>1204</b> may be defined by the provider <b>1202</b> as shown in <figref idref="DRAWINGS">FIG. <b>12</b></figref> or it may be defined by the receiver <b>1206</b>, a third party, a database provider, a database administrator, and so forth. When the secure UDF <b>1204</b> is run on an execution platform associated with the receiver, the provider may be prohibited from knowing whether or when the secure UDF <b>1204</b> was run.</p><p id="p-0106" num="0103">The provider <b>1202</b> defines at <b>1208</b> the secure UDF and generates at <b>1210</b> a secure join key. The provider <b>1202</b> shares at <b>1212</b> the secure UDF with the receiver. The receiver <b>1206</b> receives at <b>1214</b> the share of the secure UDF from the provider <b>1202</b>. The secure UDF <b>1204</b> hashes at <b>1216</b> the provider's data using the secure join key. The secure UDF <b>1204</b> hashes at <b>1218</b> the receiver's data with the secure join key. The secure UDF <b>1204</b> performs at <b>1220</b> a secure join overlap count between the hashed provider's data and the hashed receiver's data. The secure UDF <b>1204</b> provides at <b>1222</b> the secure join overlap count to the receiver.</p><p id="p-0107" num="0104"><figref idref="DRAWINGS">FIG. <b>13</b></figref> is a schematic block diagram of an exemplary embodiment of work distribution <b>1300</b> for a reverse share secure join between a provider <b>1302</b> and a receiver <b>1306</b>. The work distribution <b>1300</b> is split amongst the provider <b>1302</b>, the receiver <b>1306</b>, and a secure user-defined function (UDF) <b>1304</b>. The secure UDF <b>1304</b> is run on an execution platform belonging to the receiver <b>1306</b>. When the secure UDF <b>1304</b> is run on an execution platform associated with the receiver <b>1306</b>, the provider <b>1302</b> may be prohibited from knowing whether or when the secure UDF <b>1304</b> was run.</p><p id="p-0108" num="0105">The provider <b>1302</b> defines at <b>1308</b> a secure UDF definition. Defining the secure UDF definition includes generating at <b>1310</b> a secure join key. The provider <b>1302</b> shares at <b>1312</b> the secure UDF including the secure join key generator with the receiver <b>1306</b>. The receiver <b>1306</b> receives at <b>1314</b> the share of the secure UDF. The receiver <b>1306</b> generates at <b>1316</b> a receiver key that may include a hash key. The receiver <b>1306</b> generates at <b>1318</b> salted datapoints using the receiver key. The receiver <b>1306</b> shares at <b>1320</b> the salted datapoints with the secure UDF. The secure UDF <b>1304</b> hashes at <b>1322</b> the provider's data using the secure join key. The secure UDF <b>1304</b> receives at <b>1324</b> the receiver key and decrypts at <b>1326</b> the salted datapoints with the receiver key. The secure UDF <b>1304</b> hashes at <b>1328</b> the receiver's data using the secure join key. The secure UDF <b>1304</b> performs at <b>1330</b> a secure join overlap count of the hashed provider's data and the hashed receiver's data. The secure UDF <b>1304</b> provides at <b>1332</b> the secure join overlap count to the receiver. The secure UDF <b>1304</b> may further provide the secure join overlap count to the provider.</p><p id="p-0109" num="0106"><figref idref="DRAWINGS">FIG. <b>14</b></figref> is a schematic flow chart diagram of a method <b>1400</b> for generating a secure join of database data. The method <b>1400</b> may be implemented in a multi-tenant database system such as that illustrated in <figref idref="DRAWINGS">FIG. <b>1</b></figref>. The method may be performed by any suitable computing device such as a share component <b>210</b> as disclosed herein.</p><p id="p-0110" num="0107">The method <b>1400</b> begins and the computing device determines at <b>1402</b> data stored in a first account to be compared with data stored in a second account. The data stored in the first account and the data stored in the second account may be directed to the same subject matter. In an exemplary implementation, the first account and the second account may be associated with the same multi-tenant database system and may represent different client accounts within that multi-tenant database system. The first account and the second account may wish to determine all common datapoints of a certain subject matter between the two accounts. For example, the first account and the second account may be associated with companies wishing to determine all customers that the two companies have in common. The companies may be storing customer data with certain personally identifiable information such as, for example, a telephone number for each customer, a social security number for each customer, an address for each customer, and so forth. Such personally identifiable information may be sensitive and should not be shared with any entity or person outside of the company to which the customer provided the information. In this implementation, the two companies may wish to securely compare all datapoints of a certain type, such as all customer phone numbers, all customer social security numbers, all customer addresses, and so forth. The companies may wish to compare such datapoints without permitting the other company to view the personally identifiable information for any customers and/or a total number of customers. The method <b>1400</b> continues and the computing device determines at <b>1404</b> a function for generating a secure join key, wherein the secure join key comprises a hashed string that hashes one or more of a data entry of the first account or a data entry of the second account. The function may be defined by either of the first account or the second account, a third party, or a database administrator or provider. The method <b>1400</b> continues and the computing devices provides at <b>1406</b> the secure join key to the first account and/or the second account.</p><p id="p-0111" num="0108"><figref idref="DRAWINGS">FIG. <b>15</b></figref> is a schematic flow chart diagram of a method <b>1500</b> for generating a secure join of database data. The method <b>1500</b> may be implemented in a multi-tenant database system such as that illustrated in <figref idref="DRAWINGS">FIG. <b>1</b></figref>. The method may be performed by any suitable computing device such as a share component <b>210</b> as disclosed herein.</p><p id="p-0112" num="0109">The method <b>1500</b> begins and the computing device determines at <b>1502</b> data stored in a first account to be compared with data stored in a second account. The computing device determines at <b>1504</b> a function for generating a secure join key, wherein the secure join key comprises a hashed string that hashes one or more of a data entry of the first account or a data entry of the second account. The computing device provides at <b>1506</b> the secure join key to the first account and/or the second account. The computing device compares at <b>1508</b> the data stored in the first account with the data stored in the second account based on the secure join key by identifying common data entries between the first account and the second account. The computing device enriches at <b>1510</b> the data stored in the first account and/or the data stored in the second account based on common data entries between the first account and the second account.</p><p id="p-0113" num="0110"><figref idref="DRAWINGS">FIG. <b>16</b></figref> is a block diagram depicting an example computing device <b>1600</b>. In some embodiments, computing device <b>1600</b> is used to implement one or more of the systems and components discussed herein. Further, computing device <b>1600</b> may interact with any of the systems and components described herein. Accordingly, computing device <b>1600</b> may be used to perform various procedures and tasks, such as those discussed herein. Computing device <b>1600</b> can function as a server, a client or any other computing entity. Computing device <b>1600</b> can be any of a wide variety of computing devices, such as a desktop computer, a notebook computer, a server computer, a handheld computer, a tablet, and the like.</p><p id="p-0114" num="0111">Computing device <b>1600</b> includes one or more processor(s) <b>1602</b>, one or more memory device(s) <b>1604</b>, one or more interface(s) <b>1606</b>, one or more mass storage device(s) <b>1608</b>, and one or more Input/Output (I/O) device(s) <b>1610</b>, all of which are coupled to a bus <b>1612</b>. Processor(s) <b>1602</b> include one or more processors or controllers that execute instructions stored in memory device(s) <b>1604</b> and/or mass storage device(s) <b>1608</b>. Processor(s) <b>1602</b> may also include various types of computer-readable media, such as cache memory.</p><p id="p-0115" num="0112">Memory device(s) <b>1604</b> include various computer-readable media, such as volatile memory (e.g., random access memory (RAM)) and/or nonvolatile memory (e.g., read-only memory (ROM)). Memory device(s) <b>1604</b> may also include rewritable ROM, such as Flash memory.</p><p id="p-0116" num="0113">Mass storage device(s) <b>1608</b> include various computer readable media, such as magnetic tapes, magnetic disks, optical disks, solid state memory (e.g., Flash memory), and so forth. Various drives may also be included in mass storage device(s) <b>1608</b> to enable reading from and/or writing to the various computer readable media. Mass storage device(s) <b>1608</b> include removable media and/or non-removable media.</p><p id="p-0117" num="0114">I/O device(s) <b>1610</b> include various devices that allow data and/or other information to be input to or retrieved from computing device <b>1600</b>. Example I/O device(s) <b>1610</b> include cursor control devices, keyboards, keypads, microphones, monitors or other display devices, speakers, printers, network interface cards, modems, lenses, CCDs or other image capture devices, and the like.</p><p id="p-0118" num="0115">Interface(s) <b>1606</b> include various interfaces that allow computing device <b>1600</b> to interact with other systems, devices, or computing environments. Example interface(s) <b>1606</b> include any number of different network interfaces, such as interfaces to local area networks (LANs), wide area networks (WANs), wireless networks, and the Internet.</p><p id="p-0119" num="0116">Bus <b>1612</b> allows processor(s) <b>1602</b>, memory device(s) <b>1604</b>, interface(s) <b>1606</b>, mass storage device(s) <b>1608</b>, and I/O device(s) <b>1610</b> to communicate with one another, as well as other devices or components coupled to bus <b>1612</b>. Bus <b>1612</b> represents one or more of several types of bus structures, such as a system bus, PCI bus, IEEE 1394 bus, USB bus, and so forth.</p><p id="p-0120" num="0117">For purposes of illustration, programs and other executable program components are shown herein as discrete blocks, although it is understood that such programs and components may reside at various times in different storage components of computing device <b>1600</b> and are executed by processor(s) <b>1602</b>. Alternatively, the systems and procedures described herein can be implemented in hardware, or a combination of hardware, software, and/or firmware. For example, one or more application specific integrated circuits (ASICs) can be programmed to carry out one or more of the systems and procedures described herein. As used herein, the terms &#x201c;module&#x201d; or &#x201c;component&#x201d; are intended to convey the implementation apparatus for accomplishing a process, such as by hardware, or a combination of hardware, software, and/or firmware, for the purposes of performing all or parts of operations disclosed herein.</p><heading id="h-0006" level="1">Examples</heading><p id="p-0121" num="0118">The following examples pertain to further embodiments.</p><p id="p-0122" num="0119">Example 1 is a system for performing a secure join of database data, the system comprising. The system includes means for determining data stored in a first account to be compared with data stored in a second account. The system includes means for determining a function for generating a secure join key, wherein the secure join key comprises a hash string that hashes one or more of: a data entry of the first account; a first salt string associated with the first account; a first account identification number associated with the first account; a data entry of the second account; a second salt string associated with the second account; or a second account identification number associated with the second account; and means for providing the secure join key to the first account and/or the second account.</p><p id="p-0123" num="0120">Example 2 is a system as in Example 1, wherein the secure join key comprises a double salted hash value and the function is configured to generate the secure join key based on: the data entry of the first account with the first salt string associated with the first account; and the data entry of the second account with the second salt string associated with the second account; wherein original non-hashed or non-salted data cannot be identified by the first account or the second account based on the secure join key.</p><p id="p-0124" num="0121">Example 3 is a system as in any of Examples 1-2, further comprising means for comparing the data stored in the first account with the data stored in the second account based on the secure join key, wherein the means for comparing is configured to one or more of: identify common data entries between the first account and the second account; determine a number of common data entries between the first account and the second account; or enrich the data stored in the first account and/or the data stored in the second account based on common data entries between the first account and the second account.</p><p id="p-0125" num="0122">Example 4 is a system as in any of Examples 1-3, wherein the function generates the secure join key further based on a salted data entry received from the second account that does not refer to any real data entry in the second account and is included to insert noise into the secure join key.</p><p id="p-0126" num="0123">Example 5 is a system as in any of Examples 1-4, further comprising means for determining a comparison function that comprises procedural logic having instructions for comparing the data stored in the first account with the data stored in the second account, the instructions comprising: comparing a first hashed datapoint from the first account with a second hashed datapoint from the second account, wherein the first hashed datapoint and the second hashed datapoint are generated by the function; determining whether the first hashed datapoint is the same as the second hashed datapoint; and in response to determining that the first hashed datapoint and the second hashed datapoint are the same, generating an indication that the first account and the second account have a common datapoint.</p><p id="p-0127" num="0124">Example 6 is a system as in any of Examples 1-5, wherein the instructions further comprise, in response to determining that the first hashed datapoint and the second hashed datapoint are the same: reverting the first hashed datapoint to a first original datapoint; reverting the second hashed datapoint to a second original datapoint; and enriching the data stored in the first account and/or the data stored in the second account with the first original datapoint and/or the second original datapoint.</p><p id="p-0128" num="0125">Example 7 is a system as in any of Examples 1-6, wherein the function for generating the secure join key is defined by the first account and is executed on an execution platform associated with the second account.</p><p id="p-0129" num="0126">Example 8 is a system as in any of Examples 1-7, wherein the first account does not have visibility into when or if the function for generating the secure join key was executed by the second account.</p><p id="p-0130" num="0127">Example 9 is a system as in any of Examples 1-8, wherein the instructions of the procedural logic further comprise: determining a number of common data entries between the first account and the second account; determining whether the number of common data entries meets a threshold number defined by an account; in response to determining the number of common data entries meets the threshold number, returning results of the comparison function to the account; and in response to determining the number of common data entries does not meet the threshold number, withholding a notification of the results of the comparison function from being delivered to the account.</p><p id="p-0131" num="0128">Example 10 is a system as in any of Examples 1-9, further comprising means for jittering results of the function for generating the secure join key by introducing a random factor that does not comprise a data entry found in either of the first account or the second account.</p><p id="p-0132" num="0129">Example 11 is a method for performing a secure join on database data. The method includes determining data stored in a first account to be compared with data stored in a second account. The method includes determining a function for generating a secure join key, wherein the secure join key comprises a hashed string that hashes one or more of: a data entry of the first account; a first salt string associated with the first account; a first account identification number associated with the first account; a data entry of the second account; a second salt string associated with the second account; or a second account identification number associated with the second account. The method includes providing the secure join key to the first account and/or the second account.</p><p id="p-0133" num="0130">Example 12 is a method as in Example 11, wherein the secure join key comprises a double salted hash value and the function is configured to generate the secure join key based on: the data entry of the first account with the first salt string associated with the first account; and the data entry of the second account with the second salt string associated with the second account; wherein original non-hashed or non-salted data cannot be identified by the first account or the second account based on the secure join key.</p><p id="p-0134" num="0131">Example 13 is a method as in any of Examples 11-12, further comprising comparing the data stored in the first account with the data stored in the second account based on the secure join key, wherein the comparing comprises: identifying common data entries between the first account and the second account; determining a number of common data entries between the first account and the second account; or enriching the data stored in the first account and/or the data stored in the second account based on common data entries between the first account and the second account.</p><p id="p-0135" num="0132">Example 14 is a method as in any of Examples 11-13, wherein the function generates the secure join key further based on a salted data entry received from the second account that does not refer to any real data entry in the second account and is included to insert noise into the secure join key.</p><p id="p-0136" num="0133">Example 15 is a method as in any of Examples 11-14, further comprising determining a comparison function that comprises procedural logic having instructions for comparing the data stored in the first account with the data stored in the second account, the instructions of the procedural logic comprising: comparing a first hashed datapoint from the first account with a second hashed datapoint from the second account, wherein the first hashed datapoint and the second hashed datapoint are generated by the function; determining whether the first hashed datapoint is the same as the second hashed datapoint; and in response to determining that the first hashed datapoint and the second hashed datapoint are the same, generating an indication that the first account and the second account have a common datapoint.</p><p id="p-0137" num="0134">Example 16 is a method as in any of Examples 11-15, wherein the instructions of the procedural logic further comprise, in response to determining that the first hashed datapoint and the second hashed datapoint are the same: reverting the first hashed datapoint to a first original datapoint; reverting the second hashed datapoint to a second original datapoint; and enriching the data stored in the first account and/or the data stored in the second account with the first original datapoint and/or the second original datapoint.</p><p id="p-0138" num="0135">Example 17 is a method as in any of Examples 11-16, wherein the function for generating the secure join key is defined by the first account and is executed on an execution platform associated with the second account.</p><p id="p-0139" num="0136">Example 18 is a method as in any of Examples 11-17, wherein the first account does not have visibility into when or if the function for generating the secure join key was executed by the second account.</p><p id="p-0140" num="0137">Example 19 is a method as in any of Examples 11-18, wherein the instructions of the procedural logic further comprise: determining a number of common data entries between the first account and the second account; determining whether the number of common data entries meets a threshold number defined by an account; in response to determining the number of common data entries meets the threshold number, returning results of the comparison function to the account; and in response to determining the number of common data entries does not meet the threshold number, withholding a notification of the results of the comparison function from being delivered to the account.</p><p id="p-0141" num="0138">Example 20 is a method as in any of Examples 11-19, further comprising jittering results of the function for generating the secure join key by introducing a random factor that does not comprise a data entry found in either of the first account or the second account.</p><p id="p-0142" num="0139">Example 21 is a processor that is programmable to execute instructions stored in non-transitory computer readable storage media. The instructions include determining data stored in a first account to be compared with data stored in a second account. The instructions include determining a function for generating a secure join key, wherein the secure join key comprises a hashed string that hashes one or more of: a data entry of the first account; a first salt string associated with the first account; a first account identification number associated with the first account; a data entry of the second account; a second salt string associated with the second account; or a second account identification number associated with the second account. The method includes providing the secure join key to the first account and/or the second account.</p><p id="p-0143" num="0140">Example 22 is a processor as in Example 21, wherein the secure join key comprises a double salted hash value and the function is configured to generate the secure join key based on: the data entry of the first account with the first salt string associated with the first account; and the data entry of the second account with the second salt string associated with the second account; wherein original non-hashed or non-salted data cannot be identified by the first account or the second account based on the secure join key.</p><p id="p-0144" num="0141">Example 23 is a processor as in any of Examples 21-22, wherein the instructions further comprise comparing the data stored in the first account with the data stored in the second account based on the secure join key, wherein the comparing comprises: identifying common data entries between the first account and the second account; determining a number of common data entries between the first account and the second account; or enriching the data stored in the first account and/or the data stored in the second account based on common data entries between the first account and the second account.</p><p id="p-0145" num="0142">Example 24 is a processor as in any of Examples 21-23, wherein the function generates the secure join key further based on a salted data entry received from the second account that does not refer to any real data entry in the second account and is included to insert noise into the secure join key.</p><p id="p-0146" num="0143">Example 25 is a processor as in any of Examples 21-24, wherein the instructions further comprise determining a comparison function that comprises procedural logic having instructions for comparing the data stored in the first account with the data stored in the second account, the instructions of the procedural logic comprising: comparing a first hashed datapoint from the first account with a second hashed datapoint from the second account, wherein the first hashed datapoint and the second hashed datapoint are generated by the function; determining whether the first hashed datapoint is the same as the second hashed datapoint; and in response to determining that the first hashed datapoint and the second hashed datapoint are the same, generating an indication that the first account and the second account have a common datapoint.</p><p id="p-0147" num="0144">Example 26 is an apparatus including means to perform a method or realize an apparatus or system as in any of Examples 1-25.</p><p id="p-0148" num="0145">Example 27 is a machine-readable storage including machine-readable instructions, when executed, to implement a method or realize an apparatus of any of Examples 1-25.</p><p id="p-0149" num="0146">Various techniques, or certain aspects or portions thereof, may take the form of program code (i.e., instructions) embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, a non-transitory computer readable storage medium, or any other machine-readable storage medium wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the various techniques. In the case of program code execution on programmable computers, the computing device may include a processor, a storage medium readable by the processor (including volatile and non-volatile memory and/or storage elements), at least one input device, and at least one output device. The volatile and non-volatile memory and/or storage elements may be a RAM, an EPROM, a flash drive, an optical drive, a magnetic hard drive, or another medium for storing electronic data. One or more programs that may implement or utilize the various techniques described herein may use an application programming interface (API), reusable controls, and the like. Such programs may be implemented in a high-level procedural or an object-oriented programming language to communicate with a computer system. However, the program(s) may be implemented in assembly or machine language, if desired. In any case, the language may be a compiled or interpreted language, and combined with hardware implementations.</p><p id="p-0150" num="0147">It should be understood that many of the functional units described in this specification may be implemented as one or more components, which is a term used to more particularly emphasize their implementation independence. For example, a component may be implemented as a hardware circuit comprising custom very large-scale integration (VLSI) circuits or gate arrays, off-the-shelf semiconductors such as logic chips, transistors, or other discrete components. A component may also be implemented in programmable hardware devices such as field programmable gate arrays, programmable array logic, programmable logic devices, or the like.</p><p id="p-0151" num="0148">Components may also be implemented in software for execution by various types of processors. An identified component of executable code may, for instance, comprise one or more physical or logical blocks of computer instructions, which may, for instance, be organized as an object, a procedure, or a function. Nevertheless, the executables of an identified component need not be physically located together but may comprise disparate instructions stored in different locations that, when joined logically together, comprise the component and achieve the stated purpose for the component.</p><p id="p-0152" num="0149">Indeed, a component of executable code may be a single instruction, or many instructions, and may even be distributed over several different code segments, among different programs, and across several memory devices. Similarly, operational data may be identified and illustrated herein within components and may be embodied in any suitable form and organized within any suitable type of data structure. The operational data may be collected as a single data set or may be distributed over different locations including over different storage devices, and may exist, at least partially, merely as electronic signals on a system or network. The components may be passive or active, including agents operable to perform desired functions.</p><p id="p-0153" num="0150">Reference throughout this specification to &#x201c;an example&#x201d; means that a particular feature, structure, or characteristic described in connection with the example is included in at least one embodiment of the present disclosure. Thus, appearances of the phrase &#x201c;in an example&#x201d; in various places throughout this specification are not necessarily all referring to the same embodiment.</p><p id="p-0154" num="0151">As used herein, a plurality of items, structural elements, compositional elements, and/or materials may be presented in a common list for convenience. However, these lists should be construed as though each member of the list is individually identified as a separate and unique member. Thus, no individual member of such list should be construed as a de facto equivalent of any other member of the same list solely based on its presentation in a common group without indications to the contrary. In addition, various embodiments and examples of the present disclosure may be referred to herein along with alternatives for the various components thereof. It is understood that such embodiments, examples, and alternatives are not to be construed as de facto equivalents of one another but are to be considered as separate and autonomous representations of the present disclosure.</p><p id="p-0155" num="0152">Although the foregoing has been described in some detail for purposes of clarity, it will be apparent that certain changes and modifications may be made without departing from the principles thereof. It should be noted that there are many alternative ways of implementing both the processes and apparatuses described herein. Accordingly, the present embodiments are to be considered illustrative and not restrictive.</p><p id="p-0156" num="0153">Those having skill in the art will appreciate that many changes may be made to the details of the above-described embodiments without departing from the underlying principles of the disclosure. The scope of the present disclosure should, therefore, be determined only by the following claims.</p><?detailed-description description="Detailed Description" end="tail"?></description><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A method comprising:<claim-text>creating a secure view of datapoints of a consumer account;</claim-text><claim-text>processing, using a secure user defined function (UDF), the datapoints of the consumer account and datapoints of a provider account to generate a secure join key, wherein the datapoints of the consumer account are provided to the secure UDF using the secure view, and wherein secure UDF returns a count of matching data points between the consumer account and the provider account; and</claim-text><claim-text>providing the count of matching data points to the consumer account.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the secure UDF is executed by the consumer account and the consumer account is devoid of visibility into the datapoints of the provider account.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the secure join key comprises a hash string of the datapoints of the provider account and hashed datapoints of the consumer account, and wherein the hashed datapoints of the consumer account are processed via the secure view.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref> further comprising:<claim-text>salting the hashed datapoints of the consumer account; and</claim-text><claim-text>providing the salted hashed datapoints of the consumer account to the provider account.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref> further comprising:<claim-text>inserting, by the consumer account, one or more additional hashed datapoints into the hashed datapoints of the consumer account, wherein the one or more additional hashed datapoints correspond to non-actual values.</claim-text></claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>salting the datapoints of the consumer account, wherein the salting of the datapoints of the consumer account comprises:</claim-text><claim-text>including with the salted datapoints, one or more additional salted datapoints that represent non-real datapoints of the consumer account.</claim-text></claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the secure join key is based at least in part on the salted datapoints received from the consumer account that represent the non-real datapoints of the consumer account.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. A system comprising:<claim-text>a memory; and</claim-text><claim-text>a processor operatively coupled to the memory, the processor to:<claim-text>create a secure view of datapoints of a consumer account;</claim-text><claim-text>process, using a secure user defined function (UDF), the datapoints of the consumer account and datapoints of a provider account to generate a secure join key, wherein the datapoints of the consumer account are provided to the secure UDF using the secure view, and wherein secure UDF returns a count of matching data points between the consumer account and the provider account; and</claim-text><claim-text>provide the count of matching data points to the consumer account.</claim-text></claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The system of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the secure UDF is executed by the consumer account and the consumer account is devoid of visibility into the datapoints of the provider account.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The system of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the secure join key comprises a hash string of the datapoints of the provider account and hashed datapoints of the consumer account, and wherein the hashed datapoints of the consumer account are processed via the secure view.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The system of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the processor is further to:<claim-text>salt the hashed datapoints of the consumer account; and</claim-text><claim-text>provide the salted hashed datapoints of the consumer account to the provider account.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The system of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the processor is further to:<claim-text>insert, by the consumer account, one or more additional hashed datapoints into the hashed datapoints of the consumer account, wherein the one or more additional hashed datapoints correspond to non-actual values.</claim-text></claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The system of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the processor is further to:<claim-text>salt the datapoints of the consumer account; and</claim-text><claim-text>include with the salted datapoints, one or more additional salted datapoints that represent non-real datapoints of the consumer account.</claim-text></claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The system of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the secure join key is based at least in part on the salted datapoints received from the consumer account that represent the non-real datapoints of the consumer account.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. A non-transitory computer-readable medium having instructions stored thereon which, when executed by a processor, cause the processor to:<claim-text>create a secure view of datapoints of a consumer account;</claim-text><claim-text>process, using a secure user defined function (UDF), the datapoints of the consumer account and datapoints of a provider account to generate a secure join key, wherein the datapoints of the consumer account are provided to the secure UDF using the secure view, and wherein secure UDF returns a count of matching data points between the consumer account and the provider account; and</claim-text><claim-text>provide the count of matching data points to the consumer account.</claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The non-transitory computer-readable medium of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the secure UDF is executed by the consumer account and the consumer account is devoid of visibility into the datapoints of the provider account.</claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The non-transitory computer-readable medium of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the secure join key comprises a hash string of the datapoints of the provider account and hashed datapoints of the consumer account, and wherein the hashed datapoints of the consumer account are processed via the secure view.</claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The non-transitory computer-readable medium of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the processor is further to:<claim-text>salt the hashed datapoints of the consumer account; and</claim-text><claim-text>provide the salted hashed datapoints of the consumer account to the provider account.</claim-text></claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The non-transitory computer-readable medium of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the processor is further to:<claim-text>insert, by the consumer account, one or more additional hashed datapoints into the hashed datapoints of the consumer account, wherein the one or more additional hashed datapoints correspond to non-actual values.</claim-text></claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The non-transitory computer-readable medium of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the processor is further to:<claim-text>salt the datapoints of the consumer account; and</claim-text><claim-text>include with the salted datapoints, one or more additional salted datapoints that represent non-real datapoints of the consumer account.</claim-text></claim-text></claim></claims></us-patent-application>