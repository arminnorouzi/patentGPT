<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004477A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004477</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17899401</doc-number><date>20220830</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>11</main-group><subgroup>36</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>11</main-group><subgroup>3612</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>11</main-group><subgroup>3692</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">PROVIDING A PSEUDO LANGUAGE FOR MANIPULATING COMPLEX VARIABLES OF AN ORCHESTRATION FLOW</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>17171978</doc-number><date>20210209</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11461217</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17899401</doc-number></document-id></child-doc></relation></continuation><continuation><relation><parent-doc><document-id><country>US</country><doc-number>16296043</doc-number><date>20190307</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>10949327</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17171978</doc-number></document-id></child-doc></relation></continuation><us-provisional-application><document-id><country>US</country><doc-number>62748164</doc-number><date>20181019</date></document-id></us-provisional-application></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>ORACLE INTERNATIONAL CORPORATION</orgname><address><city>Redwood Shores</city><state>CA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Herreria</last-name><first-name>Jorge</first-name><address><city>Littleton</city><state>CO</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Mohanram</last-name><first-name>Venkatesh</first-name><address><city>Bengaluru KARNATAKA</city><country>IN</country></address></addressbook></inventor></inventors></us-parties><assignees><assignee><addressbook><orgname>ORACLE INTERNATIONAL CORPORATION</orgname><role>02</role><address><city>Redwood Shores</city><state>CA</state><country>US</country></address></addressbook></assignee></assignees></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A pseudo language is provided for manipulating the complex variables associated with the orchestration flow. Verbs are specified in the pseudo language. The verbs cause operations to be performed on the complex variables during processing of the orchestration flow. A first verb of the verbs is specified with a first operation of the operations The first operation, when processed, transfers data from a first set of source elements in a source complex variable to new target elements in a target complex variable based on a description of a target schema of the target complex variable. The target complex variable does not include the first subset of source elements and the target schema includes the description of the first subset of the source elements.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="114.30mm" wi="158.75mm" file="US20230004477A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="216.07mm" wi="166.54mm" orientation="landscape" file="US20230004477A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="202.01mm" wi="128.78mm" orientation="landscape" file="US20230004477A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="219.63mm" wi="114.81mm" orientation="landscape" file="US20230004477A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="223.77mm" wi="166.54mm" orientation="landscape" file="US20230004477A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="223.35mm" wi="161.46mm" orientation="landscape" file="US20230004477A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="202.01mm" wi="148.34mm" orientation="landscape" file="US20230004477A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="217.76mm" wi="151.98mm" file="US20230004477A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="138.09mm" wi="149.01mm" file="US20230004477A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">CROSS REFERENCES TO RELATED APPLICATIONS</heading><p id="p-0002" num="0001">This application is a continuation of U.S. patent application Ser. No. 17/171,978, entitled TRANSFERRING DATA FROM A SOURCE COMPLEX VARIABLE TO A TARGET COMPLEX VARIABLE, filed on Feb. 9, 2021 (ORACP0247CNT1/ORA180764-US-CNT-1), which is a continuation of U.S. patent application Ser. No. 16/296,043, entitled MANIPULATION OF COMPLEX VARIABLES IN ORCHESTRATION APPLICATIONS, filed on Mar. 7, 2019 (ORACP0247/ORA180764-US-NP) which claims the benefit of U.S. Provisional Patent Application Ser. No. 62/748,164, entitled MANIPULATION OF COMPLEX VARIABLES IN ORCHESTRATION APPLICATIONS, filed on Oct. 19, 2018, which are all hereby incorporated by reference as if set forth in full in this application for all purposes.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">BACKGROUND</heading><p id="p-0003" num="0002">The present application relates to computing and more specifically to systems and methods for manipulating computing objects, such data objects used to implement and orchestrate process-based software applications.</p><p id="p-0004" num="0003">Systems for manipulating data objects and/or moving data between different data objects are employed in various demanding applications, including facilitating integrating (e.g., enabling interoperability and intercommunications between) different software systems; orchestrating process flows and enabling data to seamlessly pass between different steps of a process-based software application, and so on. Such applications often demand efficient, user friendly, versatile, and fault-tolerant systems and methods for selectively and accurately manipulating data of a target object using data from a source and/or one or more rules or methods.</p><p id="p-0005" num="0004">Generally, process orchestration may involve transferring data between different steps or activities of one or more process-based business applications (e.g., which may be modeled by Business Process Modeling and Notation (BPMN) flows describing Business Process Execution Language (BPEL) composite process-based software applications) and selectively manipulating the data in accordance with the requirements of each step or software application. Such flows often require the mapping of complex data objects from one form or type to another form or type.</p><p id="p-0006" num="0005">The complex data objects (also called complex variables) may include various hierarchical arrangements of fields or elements/attributes. The fields may be arranged in accordance with the object schema describing a namespace and associated organizational structure that the associated Document Object Models (DOMs) of the complex variables are structured in accordance with and should adhere to.</p><p id="p-0007" num="0006">Integrations and orchestrations may require functionality for accurately mapping data from one complex variable (called the source) to another complex variable (called the target). In certain cases, the hierarchical structures of the source complex variables may differ from the structures of the target complex variables. Furthermore individual fields of the source and target complex variables may exhibit different properties, e.g., may accommodate specific types of data (e.g., integer, float, date, string, etc.) and may accommodate different numbers of (and arrangements of) data element instances.</p><p id="p-0008" num="0007">As such, mechanisms for accurately editing or modifying fields of the target can be particularly important for accurate data mappings and successful integrations and orchestrations for process-based software applications. Conventionally, this can require that developers, when developing integration and/or orchestration flows, pay close attention to the properties and structures of the target and source complex variables to ensure compatibility between source data and target data (and associated structures, data types, properties, etc.) being mapped, and to avoid inadvertent data deletions and other errors.</p><p id="p-0009" num="0008">This may require that the developer create/assign data fields (to the targets) in a particular order, so as to preserve the sequence or hierarchical relationships of elements of the sources when mapped to elements of the targets and vice versa. Conventional techniques, e.g., using BPEL and accompanying eXtensible Stylesheet Language Transformations (XSLT) mappings, may fail to enforce correct mappings, i.e., fail to detect errors related to attempts to map one complex variable, or portion thereof, into another.</p><p id="p-0010" num="0009">Accordingly, the developer is often tasked with developing complex work-arounds so as to ensure consistency and to avoid errors in the data mappings. This may involve use of stage files and calling other web services to ensure that data is not lost during the data mapping process. However, use of stage files, etc., can be time-consuming and error prone.</p><p id="p-0011" num="0010">Conventionally, when using conventional BPEL assignments for integrations and orchestrations, data fields from a source object are often mapped to a target object in a sequence corresponding to the order of the fields or elements in the target. If this practice is not adhered to, data of the target may be overwritten by incorrect fields, as conventional BPEL assignments may lack adequate built-in data-validation checks.</p><heading id="h-0003" level="1">SUMMARY</heading><p id="p-0012" num="0011">An example embodiment provides a simplified replacement for Business Process Execution Language (BPEL) that is particularly suitable for facilitating design and implementation of process orchestrations and accompanying data mappings and manipulations of complex variables and/or hierarchically structured business objects.</p><p id="p-0013" num="0012">The BPEL replacement, also called a pseudo language herein, incorporates enhanced mechanisms (including newly introduced programming language verbs, as discussed more fully below) for detecting mapping or transformation errors early (during design time as opposed to thereafter, e.g., at runtime) and sensing of target schema characteristics during runtime to facilitate smart implementation of the accompanying pseudo language statements and associated operations, e.g., the appending of data to a target complex variable (even if an element of the variable to be appended to is not specified in the target variable, but can be inferred by referring to the schema definition of the target variable); the assignment or insertion of data into a target complex variable (at automatically inferred proper locations in the target complex variable); the removal of data from complex variable, and so on.</p><p id="p-0014" num="0013">An example method includes analyzing a statement involving the performance of an operation on the target complex variable, wherein the operation involves transferring of data from one or more elements of a source complex variable to one or more elements of the target complex variable; during design time, confirming, based on the analysis that the source complex variable and the target complex variable, that the complex variables have compatible numbers of element instances; processing, during runtime of a process orchestration flow that specifies the operation, a target schema of the target complex variable in view of the statement, so as to determine how to implement the operation; and implementing the operation based on the results of the processing.</p><p id="p-0015" num="0014">Hence, various embodiments discussed herein provide efficient mechanisms to update fields of a complex-variable (e.g., target complex variable) without losing the existing data; to incrementally update fields of complex variables; to alleviate certain implementation responsibilities from developers (such as data type and cardinality checking of source and target complex variables, etc.); to ensure that data is assigned/appended in the proper sequence, and so on.</p><p id="p-0016" num="0015">Furthermore, various embodiments provide a simplified BPEL replacement with enhanced mechanisms for detecting data mapping errors early (before runtime), and sensing of target schema characteristics to facilitate smart implementation of specialized verbs that form part of a pseudo language or language abstraction, as discussed more fully below.</p><p id="p-0017" num="0016">A further understanding of the nature and the advantages of particular embodiments disclosed herein may be realized by reference of the remaining portions of the specification and the attached drawings.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates a first example system and accompanying computing environment for facilitating orchestrations and associated data mappings for process-based software applications, which enables efficient, versatile, and robust manipulation of complex variables using an abstraction of Business Process Execution Language (BPEL), the abstraction called a pseudo language herein.</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a flow diagram of a first example method that is suitable for use with the system of <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates example relationships between a set of BPEL verbs used for manipulating data objects, and verbs of the simplified higher-level pseudo language discussed herein.</p><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. <b>4</b></figref> illustrates an example use case involving specific example inputs and outputs of the analysis and mapping module of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, and further illustrating use of schema awareness and a new pseudo-language ASSIGN verb to assign data into an unbounded element that does not initially exist in a target Document Object Model (DOM).</p><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. <b>5</b></figref> illustrates a portion of an example schema of a data object, which may correspond to the target variable schema used by the analysis and mapping modules of <figref idref="DRAWINGS">FIGS. <b>1</b> and <b>4</b></figref>.</p><p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a flow diagram of a second example method that is usable with the embodiments of <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>5</b></figref>.</p><p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a general block diagram of a system and accompanying computing environment usable to implement the embodiments of <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>6</b></figref>.</p><p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a general block diagram of a computing device usable to implement the embodiments of <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>7</b></figref>.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0005" level="1">DETAILED DESCRIPTION OF EMBODIMENTS</heading><p id="p-0026" num="0025">For the purposes of the present discussion, a computing environment may be any collection of computing resources used to perform one or more tasks involving computer processing. A computer may be any processor in communication with a memory. A computing resource may be any component, mechanism, or capability or quantities thereof of a computing environment, including, but not limited to, processors, memories, software applications, user input devices, and output devices, servers, and so on.</p><p id="p-0027" num="0026">An enterprise computing environment may be any computing environment used for a business or organization. An example enterprise computing environment includes various computing resources distributed across a network and may further include private and shared content on Intranet Web servers, databases, files on local hard discs or file servers, email systems, document management systems, portals, and so on.</p><p id="p-0028" num="0027">A given software application may include (but not necessarily) constituent software applications or modules (e.g., services, functions, procedures, computing objects, etc.). Accordingly, the term &#x201c;software application&#x201d; may also include networked software applications or integrated groups thereof.</p><p id="p-0029" num="0028">A software system may be any collection of computing resources implementing machine-readable instructions, i.e., computer code. Accordingly, the term &#x201c;software system&#x201d; may refer to a software application, and depending upon the context in which the term is used, may further refer to the accompanying computer(s) and associated computing resources used to run the software application.</p><p id="p-0030" num="0029">Depending upon the context in which the term is used, a software system may further include hardware, firmware, and other computing resources enabling running of the software application. Note that certain software systems may include collections of disparate services, which are implemented in particular sequences in accordance with a process template and accompanying logic. Accordingly, the terms &#x201c;software system,&#x201d; &#x201c;system,&#x201d; and &#x201c;software application&#x201d; may be employed interchangeably herein to refer to modules or groups of modules or computing resources used for computer processing.</p><p id="p-0031" num="0030">Certain embodiments discussed herein are particularly useful for development, deployment, and implementation of process-based software applications. A process-based software application may be any software application definable by one or more sequences of steps, also called software activities. A sequence of steps of a process-based software application may be called a process flow. Process flows are often modeled and illustrated via swim lanes in a User Interface (UI) display screen. Process-based applications are often implemented via composite applications that may leverage different web services for different process steps.</p><p id="p-0032" num="0031">For clarity, certain well-known components, such as hard drives, processors, operating systems, power supplies, routers, Internet Service Providers (ISPs), workflow orchestrators, process schedulers, Tenant Automation Systems (TASs), certain web services, virtual machines, middleware, enterprise databases, MetaData Services (MDS) modules, and so on, are not necessarily explicitly called out in the figures. However, those skilled in the art with access to the present teachings will know which components to implement and how to implement them to meet the needs of a given implementation.</p><p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates a first example system <b>10</b> and accompanying computing environment for facilitating orchestrations and associated data mappings for process-based software applications. The example system <b>10</b> enables efficient, versatile, and robust manipulation of complex variables using an abstraction of BPEL. The abstraction is called a pseudo language herein, and provides a set of operations corresponding to verbs <b>28</b>-<b>34</b> (also called abstracted functions herein) that can be employed in statements of the pseudo language. The verbs <b>28</b>-<b>34</b> represent higher-level operations or functions, which can be implemented using underlying BPEL code, but with simplified and enhanced resiliency when compared to verbs currently specified in the BPEL specification.</p><p id="p-0034" num="0033">Note that in general, groupings of various modules of the system <b>10</b> are illustrative and may vary, e.g., certain modules may be combined with other modules or implemented inside of other modules, or the modules may otherwise be distributed differently (than shown) among a network or within one or more computing devices or virtual machines, without departing from the scope of the present teachings.</p><p id="p-0035" num="0034">The overall system <b>10</b> includes one or more developer systems <b>12</b> in communication with a server-side orchestration flow designer <b>22</b> hosted on a server system <b>14</b>, which includes one or more servers (e.g., web servers, application servers, etc.) that may represent (or be a part of) a cloud.</p><p id="p-0036" num="0035">The orchestration flow designer <b>22</b> includes functionality for facilitating development of orchestration flows <b>26</b>, which may be process-based software applications used to implement orchestrations involving the mapping of data from elements or fields of one complex variable into elements or fields of another complex variable, or may otherwise involve assigning, inserting, appending, or removing data from elements of a target complex variable.</p><p id="p-0037" num="0036">For the purposes of the present discussion, a complex variable may be any computing object that includes a hierarchical structure of data arranged within categories of data (e.g., other objects) or otherwise hierarchically arranged. A first data element, attribute, or object that is within or subordinate to a second data object is called a child of the second data element. The second data element is called a parent of the first data element or attribute. Furthermore, the first data element and second data element may themselves represent complex variables or business objects. Note that an object may be any collection of data and/or functionality, and a business object may be any object that contains data and/or functionality related to a business or organization.</p><p id="p-0038" num="0037">The orchestration flows <b>26</b> may be implemented using a strategic set of verbs, including map <b>28</b>, assign <b>30</b>, append <b>32</b>, and remove <b>34</b>. The new verbs, which may be implemented using underlying BPEL code, include strategic behaviors, such as enabling incremental updating of data objects (e.g., complex variables); efficient and selective modification of leaf nodes of complex variables; smart assignments of portions of data from a source complex variable into a target complex variable; appending of portions of data of a source complex variable into a target complex variable even if the element to be appended to does not currently exist in the target complex variable; removing of identified portions (e.g., identified by one or more statements of the pseudo language) of data from a complex variable, and so on.</p><p id="p-0039" num="0038">For the purposes of the present discussion, programming language statements incorporating one or more of the newly developed verbs (i.e., assign <b>30</b>, append <b>32</b>, or remove <b>34</b>) represent statements of an orchestration pseudo language discussed herein. For the purposes of the present discussion, an orchestration pseudo language may be any programming language that represents a higher level language or collection of one or more statements or constructs that are implemented via another process-execution language, such as BPEL.</p><p id="p-0040" num="0039">In the present example embodiment, the orchestration flow designer <b>22</b> further includes a data-type validation module <b>36</b> and a complex variable cardinality checking module <b>38</b>.</p><p id="p-0041" num="0040">The data-type validation module <b>36</b> implements functionality for checking content of the orchestration flows <b>26</b>, including source complex variables and target complex variables to ensure that the data types of the source complex variables are compatible with the data types of the target complex variables for the purposes of mapping data specified via one or more pseudo language statements using one or more of the verbs <b>28</b>-<b>34</b>.</p><p id="p-0042" num="0041">If a pseudo language statement of one of the orchestration flows <b>26</b> specifies a mapping (e.g., using the assign verb <b>30</b>) from a first portion of a source complex variable to a second portion of a target complex variable that is of an incompatible data type relative to the first portion, then the data type validation module <b>36</b> will alert the developer. For example, an attempt to map or assign a date field into a name field can be caught by the data type validation module <b>36</b>. This enables the developer to make adjustments or corrections to their orchestration flows and to catch errors early, i.e., before runtime, where such errors could be particularly problematic.</p><p id="p-0043" num="0042">The complex variable cardinality checking module <b>38</b> implements functionality for confirming that the pseudo language correctly specify data mappings or operations between source complex variables and target complex variables, where the number of data elements to be mapped from the source complex variable match (or is otherwise compatible with) the number of data elements in the target complex variable to which the data elements of the source complex variable are to be mapped.</p><p id="p-0044" num="0043">For example, if a given pseudo language statement specifies an operation that attempts to use the assign verb <b>30</b> to assign a first portion of a source complex variable that has five elements or children to a second portion of a target complex variable that has two elements or children, the complex variable cardinality checking module <b>38</b> may flag the error and notify the developer. Accordingly, this further enables the developer to catch errors early, during design time, as opposed to allowing such errors to propagate into problematic runtime errors.</p><p id="p-0045" num="0044">After a given orchestration flow employing one or more pseudo language statements incorporating one or more of the verbs <b>28</b>-<b>34</b> is checked for data-type consistency (via the data type validation module <b>36</b>) and cardinality consistency (via the complex variable cardinality checking module <b>38</b>), the flow may then be moved to (or published to) the runtime system <b>24</b> for execution of the associated orchestration flow.</p><p id="p-0046" num="0045">The runtime system <b>24</b> includes an analysis and mapping module <b>40</b>, which implements the pseudo language statements and associated functionality represented by one or more of the verbs <b>28</b>-<b>34</b>, as may be included in a particular orchestration flow. The analysis and mapping module <b>40</b> processes pseudo language statements <b>42</b> that are part of an orchestration flow and implements any of the associated verbs <b>28</b>-<b>34</b> included in the pseudo language statements. Implementation of the statements <b>42</b> and associated verbs <b>28</b>-<b>34</b> includes an analysis of the target schema <b>44</b> of the target complex variable to enable smart implementation of the pseudo language statements <b>42</b>.</p><p id="p-0047" num="0046">The implementation is said to be &#x201c;smart,&#x201d; as the analysis and mapping module <b>40</b> is aware of or otherwise incorporates analysis of the target schema when implementing the verbs <b>28</b>-<b>34</b>. For example, for an assign operation specified by a pseudo language statement using the assign verb <b>30</b>, a target complex variable may be missing a particular entry that is defined in its schema, i.e., definition of the format of the target complex variable.</p><p id="p-0048" num="0047">By analyzing the target schema, the analysis and mapping module <b>40</b> can determine where in the target complex variable to implement insert the data (into the target complex variable) from the source complex variable that is specified in the pseudo language statement. Accurate insertion of the data into the target complex variable can occur even if the specific location at which to insert the data in the target complex variable is not specified in the pseudo language statement. This represents and enhancement over other approaches involving use of BPEL and accompanying XSLT (eXtensible Stylesheet Language Transformations) to implement data mappings or transformations.</p><p id="p-0049" num="0048">The analysis and mapping module <b>40</b> completes the operations specified in the pseudo language statement(s) <b>42</b>, and the resultant updated or altered target complex variable can then be fed into a subsequent step in a given orchestration flow.</p><p id="p-0050" num="0049">In summary, process orchestrations, also called integrations or orchestration integrations herein, may involve manipulation of complex variables (also called complex structures or complex objects herein) that also include complex structures (e.g., business objects). For example, a complex variable representing a price quote for an item may have a data structure with various fields, such as customer name, a ship-to field, date, item list, item names, item code, quantity, price, tax, and so on.</p><p id="p-0051" num="0050">Certain embodiments discussed herein provide mechanisms that enable a user, e.g., developer, to manipulate (e.g., map, append, assign, or remove) the variables data at different steps on the orchestration.</p><p id="p-0052" num="0051">Currently, orchestration and data integration systems often lack efficient mechanisms for assigning or appending data in to complex variables. While BPEL and accompanying XSLT (eXtensible Stylesheet Language Transformations) may be employed for integrations and complex variable manipulations, XSLT maps typically to not provide efficient ways to update variable fields. For example XSLT may delete or replace any existing data in a target complex variable that is being written to. If the target complex variable contains, for instance customer data, an XSLT map statement that only maps items for a price quote in the associated complex variable may delete the customer data in the complex variable, i.e., the customer data gets lost.</p><p id="p-0053" num="0052">The various verbs <b>28</b>-<b>34</b>; particularly the assign verb <b>30</b> and the append verb <b>32</b> provide mechanisms enabling a user to update some fields of a complex variable without losing existing data. This is enabled, in part, through schema aware ness of the analysis and mapping module <b>40</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0054" num="0053">To populate the complex-variable fields, the industry generally provides ways to create statements that are expressed either as XPath (XML Path query language) expressions or JSON (JavaScript Object Notation) and/or JavaScript means, but not both.</p><p id="p-0055" num="0054">The pseudo language (and accompanying verbs <b>28</b>-<b>34</b>) discussed herein facilitate expressing statements in a polyglot (accommodating different languages) way, such that the statements of the pseudo language can be XPath expressions, JSON/JavaScript expressions, and/or other types of expressions.</p><p id="p-0056" num="0055">Furthermore, the present example embodiment removes various implementation responsibilities (e.g., data type validation and cardinality checking) that the BPEL specification delegates to the developer. The system <b>10</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref> can ensure that the data being assigned/appended to a given complex variable is cardinality-compatible (e.g., it may prevent assignment of an unbounded (aka repeating, aka Array) field into a bounded field). It further ensures that data being data being assigned/appended is data-type compatible, and ensures that ensures the field creation is performed in the proper sequence, i.e., in accordance with the sequence of the target object schema <b>44</b>.</p><p id="p-0057" num="0056">Note that with BPEL alone (i.e., not using embodiments discussed herein), to choose the correct constructor (copy, copy list, append, etc.) to assign or append data into a field of a complex variable, the developer must often evaluate several factors, including: whether or not the target element (of the target complex variable) exists at runtime; whether or not the target element cardinality is compatible with the operation, same for the Source (FROM) cardinality; whether or not the data type and cardinality of the source (from) is compatible with the target (to), and so on.</p><p id="p-0058" num="0057">With BPEL alone, the developer may have to create/assign the data fields in top-down deep-first fashion to preserve the sequence defined by the schema which defines the complex variable shape or Document Object Model (DOM). For example in the price quote complex variable (discussed above), if the complex field for the customer is first; the item list is next, then the BPEL developer may have to create and assign the customer data first prior to creating, assigning, and/or appending the items list. Otherwise, the customer data will be created after the item list.</p><p id="p-0059" num="0058">In addition, the BPEL specification alone does not specify efficient mechanisms to enforce any data-type validation. Generally, BPEL lets the developer assign incompatible complex and simple data types. For example, BPEL allows assigning the complex address data into the item name (which is a scalar/string), without flagging such assignments at design time.</p><p id="p-0060" num="0059">The present example embodiment removes many of such responsibilities from the developer, while enabling users/developers to update the complex variables without losing the existing data.</p><p id="p-0061" num="0060">Note that the present example embodiment need only use a small number of verbs <b>28</b>-<b>34</b> (versus <b>11</b> verbs used in BPEL) to efficiently achieve robust integrations and data mappings, transformations, or complex variable manipulations.</p><p id="p-0062" num="0061"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a flow diagram of an example method <b>50</b> that is suitable for use with the system <b>10</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. The example method <b>50</b> facilitates the mapping of or transformation of data from a source complex variable to a target complex variable during a process orchestration flow.</p><p id="p-0063" num="0062">With reference to <figref idref="DRAWINGS">FIGS. <b>1</b> and <b>2</b></figref>, a first step <b>52</b> includes analyzing a statement (e.g., corresponding to the pseudo language statement <b>42</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>) involving the performance of an operation on the target complex variable. The operation involves transferring of data from one or more elements of a source complex variable to one or more elements of the target complex variable. The operation may be part of one of the orchestration flows <b>22</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0064" num="0063">A second step <b>54</b> includes, at design time, confirming, based on the analysis that the source complex variable and the target complex variable are of compatible data types (e.g., using the data type validation module <b>36</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>), and that the one or more elements of the source complex variable include compatible numbers of elements as in the one or more elements of the target complex variable (e.g., using the complex variable cardinality checking module <b>38</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>), as discussed more fully below.</p><p id="p-0065" num="0064">Note that in the present example embodiment, cardinality validation occurs at design time. The cardinality validation involves verifying that the element(s) of the source complex variable (i.e., source elements) to be mapped to a target are compatible with the portion (e.g., target element(s)) of the target complex variable to which the source element(s) is/are to be mapped. In other words, target elements of the target complex variable should be capable of having or accommodating the number of source elements that are to be mapped thereto from the source complex variable. In practice, this may mean that the target element(s) is capable of having the number of element instances as the source element instances to be mapped thereto.</p><p id="p-0066" num="0065">For example, a complex variable that represents a price quote may have name, price, quantity, etc. as elements. A given price quote complex variable can have multiple instances of an item. For example, a price quote may have multiple prices (e.g., prices in Dollars, Euros, etc.). If a price quote's item is assigned to a purchase order's item, then the purchase order item shall be capable of having or storing the multiple items (e.g., prices in Dollars, Euros, etc.).</p><p id="p-0067" num="0066">As another example, a source element to be mapped or assigned to a target element may have a cardinality of 1 (i.e., one instance only), and the corresponding target element may be specified as unbounded/unlimited. In this example case, the cardinality of the source element is not the same as the cardinality of the target element, but the cardinality of the source element and target element are compatible, as the unbounded target element can accept or accommodate the assignment of a single corresponding source element that is to be mapped to the unbounded target element.</p><p id="p-0068" num="0067">As another example, if the source element is specified as including a maximum of 10 instances, and the target is specified as unbounded/unlimited, then the source element and target element are compatible in terms of cardinality, as the unbounded target element can accommodate the <b>10</b> source element instances.</p><p id="p-0069" num="0068">As yet another example, if a source element is specified as unbounded/unlimited, and the target element accommodates only one element instance (e.g., specified as having a cardinality of 1), then the cardinality of the source element instance(s) and target element instance are not compatible. In this case, the accompanying system (e.g., the part of the system <b>10</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref> corresponding to the orchestration flow designer <b>22</b>) will detect this incompatibility and then ask the user to specify, filter, and/or select a single source element instance at design time.</p><p id="p-0070" num="0069">A third step <b>56</b> includes processing, during runtime of a process orchestration flow that specifies the operation, a target schema of the target complex variable (e.g., as illustrated by the input schema <b>44</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>) in view of the statement, so as to determine how to implement the operation; and implementing the operation (e.g., via the analysis and mapping module <b>40</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>) based on the results of the processing.</p><p id="p-0071" num="0070">Note that the example method <b>50</b> may be modified, without departing from the scope of the present teachings, e.g., the order of steps may be altered; new steps may be added or interchanged with existing steps; and so on. For example, the second step <b>54</b> may further specify that the indicated confirmations or validations occur during design time of a process orchestration flow, and that the confirmations further include data-type validation (e.g., as may be performed by the data type validation module <b>36</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>) to ensure that the source complex variable is of a data type that is compatible with a data type of the target complex variable; and complex variable cardinality checking (e.g., as may be implemented via the complex variable cardinality checking module <b>38</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>) to ensure that a number of elements in the source complex variable is to be mapped to a similar number of elements in the target complex variable.</p><p id="p-0072" num="0071">The third step <b>56</b> may further include processing a pseudo language statement that includes one or more verbs specifying an operation to perform when mapping data from the source complex variable to the target complex variable. The one or more verbs may include an assign verb of the pseudo language, wherein the assign verb incorporates or is linked to functionality for enabling allocation of data to the target complex variable even when the target complex variable does not include a data element corresponding to an element specified in the statement.</p><p id="p-0073" num="0072">The assign verb may further incorporates functionality for enabling allocation of data specifically to one or more leaf nodes of the target complex variable, without overwriting a parent node of the one or more leaf nodes.</p><p id="p-0074" num="0073">The one or more verbs may further include an append verb of the pseudo language, wherein the append verb incorporates functionality for enabling incremental updating of a target complex variable. The one or more verbs may be implemented using BPEL, such that the one or more verbs represent higher level constructs or abstractions of BPEL functions.</p><p id="p-0075" num="0074"><figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates example relationships between a set of BPEL <b>94</b> assignment verbs (also called assignment constructors, or simply, assignments) <b>72</b>-<b>92</b> used for manipulating data objects, and verbs <b>30</b>-<b>34</b> of the simplified higher-level pseudo language <b>70</b> discussed herein. The simplified functionality <b>70</b> is analogous to a higher-level layer that is stacked on top of the BPEL functionality <b>94</b>, where the simplified verbs <b>30</b>-<b>34</b> and associated functionality may be implemented via underlying BPEL verbs and functionality.</p><p id="p-0076" num="0075">The example BPEL functionality <b>94</b> is shown including eleven verbs <b>72</b>-<b>90</b> or data-object manipulation functions or activities. The verbs include map <b>72</b>, copy, copy list <b>76</b>, append, <b>78</b>, insert after <b>80</b>, insert before <b>82</b>, function call <b>84</b>, append XML fragment <b>86</b>, remove <b>88</b>, rename <b>90</b>, and recast <b>92</b>.</p><p id="p-0077" num="0076">Note that BPEL functionality <b>94</b> includes additional programming language constructs, in addition to the example eleven verbs <b>72</b>-<b>90</b> shown, which are usable to construct the verbs <b>30</b>-<b>34</b> of the pseudo-language functionality <b>70</b>. For example, additional constructs, such as Switch, CountNodes( ), etc. may be used to implement the various higher-level verbs <b>30</b>-<b>34</b>.</p><p id="p-0078" num="0077">For illustrative purposes, the new assign verb <b>30</b> is shown selectively making use of BPEL copy <b>74</b> and copy list <b>76</b> verbs. The append verb <b>32</b> selectively leverages BPEL copy <b>74</b>, copy list <b>76</b>, and insert after <b>80</b> verbs. The new remove verb <b>34</b> uses the BPEL remove verb <b>88</b>.</p><p id="p-0079" num="0078">Note that the new verbs <b>30</b>-<b>34</b> are not limited to being implemented using the BPEL verbs <b>72</b>-<b>92</b> shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref>. In fact, another language, other than BPEL, may be used to implement the data-object manipulation functionality of the new verbs <b>30</b>-<b>34</b>, as discussed herein, without departing from the scope of the present teachings.</p><p id="p-0080" num="0079">Note that in practice, whether a particular implementation or use case of the new assign verb <b>30</b> uses BPEL copy <b>74</b>, copy list <b>76</b>, and/or other verbs, functions, and/or constructs, is implementation specific and use-case specific. Similarly, the specific BPEL functionality <b>94</b> used to implement the append verb <b>32</b> and the remove verb <b>34</b> are implementation specific and use-case specific. For example, different uses of the assign verb <b>30</b> or append verb <b>32</b> (in associated programming language statements) may require use of different BPEL functionality <b>94</b>, depending on demands implicit in the operation to be performed, as specified by the programming language statements and the source and target data objects, properties, schema definitions, and so on.</p><p id="p-0081" num="0080">Generally, the fault-tolerant, simplified functionality <b>70</b> for facilitating data-object manipulations, is based on the three primary verbs <b>30</b>-<b>34</b>, including assign <b>30</b>, append <b>32</b>, and remove <b>34</b>. The methods associated with the verbs <b>30</b>-<b>34</b> enforce data-type validation, cardinality checking, schema-order enforcement (e.g., ensuring that data is assigned to a target in an appropriated order), and so on, during design-checks.</p><p id="p-0082" num="0081">During runtime, schema definitions are also used to implement operations specified by each use of the verbs <b>20</b>-<b>24</b>. For example, regardless of whether assign <b>30</b>, append <b>32</b>, or remove <b>34</b> verbs are used, it's possible that the data element to be assigned to, appended onto, or removed does not exist in the target data object at runtime.</p><p id="p-0083" num="0082">Conventionally, a BPEL developer would have to painstakingly write statements using one or more of the BPEL verbs <b>72</b>-<b>92</b> to check if a particular element to be manipulated exists in the target data object; and if the element does not exist, then create and add the new element before attempting to remove it, assign data to it, and/or append data to it. If the developer does not perform such painstaking and tedious steps during development, then the developed BPEL code may crash at runtime.</p><p id="p-0084" num="0083">Note that use of the verbs <b>30</b>-<b>34</b> efficiently mitigates the previously required tedious steps. Use of the verbs <b>30</b>-<b>34</b> include built in functionality for automatically checking the target data object and associated DOM and schema, and automatically creating any requisite element in accordance with the target object schema.</p><p id="p-0085" num="0084">Accordingly, the developer is no longer required to know or manually discover if a field or element is present in a target data object. If the element is not present in the target data object, the analysis and mapping module <b>40</b> can automatically add the element and insert intended values (i.e., values specified via programming language statements using assign <b>30</b>, append <b>32</b>, and/or remove <b>34</b>).</p><p id="p-0086" num="0085">In an example use case scenario, a complex variable, such as a purchase order object, may have an address object included therein as a component of the purchase order object. The assign method <b>30</b> can facilitate, for instance, just assigning information into only the address portion of the purchase order.</p><p id="p-0087" num="0086">For example, supposed that the address object is a complex variable, which includes sub-elements or fields, such as street, city, zip code, state, and so on. Now suppose that BPEL copy list <b>76</b> is used (e.g., in a copy list statement) to copy data into the address object. If the source object (also called the &#x201c;from&#x201d;) is not a list, and/or the address object (the &#x201c;to&#x201d;) is not organized as a list, then the associated BPEL code (e.g., code attempting to update address information in the address object) will crash at runtime.</p><p id="p-0088" num="0087">Now, suppose that BPEL copy <b>74</b> is used to copy the address object into another address object of another target purchase order object. Use of the BPEL copy <b>74</b> will copy the entire source address object into the target address object of the target purchase order object. However, the data type, cardinality, structure, etc., between the source and the target should be compatible, or the conventional BPEL statements will crash at runtime. Use of the new assign verb <b>30</b> incorporates built-in intelligence to avoid such errors during design time, and implementation of more efficient functions during runtime, in part by leveraging schema awareness, as discussed more fully below.</p><p id="p-0089" num="0088">Note that with use of the new assign verb <b>30</b>, data in an element or field of a target complex variable that is being assigned data will be overwritten with the data being assigned to the element.</p><p id="p-0090" num="0089">Note that the verbs <b>30</b>-<b>34</b> have been configured to enable statements using the verbs that enable the mapping of individual fields of a business object, and/or higher-level objects, i.e., complex variables, that include the individual fields and/or other objects. Accordingly, fields can be individually mapped, or the entire object can be mapped.</p><p id="p-0091" num="0090">Fields or elements of an object can be appended using the append verb <b>30</b> (also called the append method). For example, if payload information of the above-described purchase order object has five lines or fields, and additional sixth line may be appended using the append verb <b>32</b>, if the additional line is supported by the object's schema definition. The append method <b>32</b> will retain what is in the target complex variable, and append to it whatever data is specified as coming from the source complex variable for the purposes of appending into the target complex variable.</p><p id="p-0092" num="0091">The append verb <b>32</b> uses similar schema awareness as does the assign verb <b>30</b>, so as to facilitate target data object manipulations. For example, if the append method <b>32</b> is used to append an element into a target complex variable, the location as to where the element should be positioned within the target complex variable can be automatically inferred based on analysis and awareness of the target schema (e.g., as implemented via the analysis and mapping module <b>40</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>).</p><p id="p-0093" num="0092">Note that conventionally, a developer using the BPEL append <b>78</b>, as opposed to the new pseudo-language append <b>32</b>, should confirm that the element to be appended to exists in the DOM of the target data object (called the &#x201c;To DOM&#x201d;). However use of the new pseudo-language append <b>32</b> may analyze the schema of the target data object or complex variable, and then automatically create (in the DOM) an element that is to be appended to, if the element does not exist in the target data object, and if the schema of the target data object allows for creation of such an element.</p><p id="p-0094" num="0093">As to the new remove verb <b>34</b> (also called the remove method), in an example scenario, a developer wishes to remove data from a price field of a purchase order object, e.g., so as to allow a target application to calculate and provide a new price. The price data in the target purchase order object can be blanked or deleted using the new remove method <b>34</b>. Generally, if a field or element with data to be removed exists in the target data object, then the data therein will be removed. However, it the field or element does not exist, then the remove method <b>34</b> will not remove it. However, use of the conventional BPEL remove <b>88</b>, i.e., to remove a field or element that does not exist, may result in crashing of the associated software at runtime.</p><p id="p-0095" num="0094">In summary, conventional BPEL and XSLT methods <b>72</b>-<b>92</b> for implementing data mappings between a source and a target object generally lack efficient built-in data-type validation, cardinality checking, and so on. Accordingly, developers are prone to inadvertently implement data mappings between incompatible data fields and structures of source and target business objects.</p><p id="p-0096" num="0095">The incompatibility may include cardinality incompatibilities and other data-type incompatibilities. For example, BPEL may allow assignment of complex address data into an item name field of a target, as BPEL methods lack built-in enforcement of data-type validation rules.</p><p id="p-0097" num="0096">Generally, conventional BPEL methods allow the developer to assign incompatible complex and simple data types. For example BPEL allows (without flagging or alerting at design time) assignment of complex address data into a scalar or string, such as an item name.</p><p id="p-0098" num="0097">These conventional BPEL issues are overcome via embodiments discussed herein, in part via the new verbs <b>30</b>-<b>34</b> and enhanced schema awareness, which can remove some developer implementation responsibilities, such as: ensuring that the data being assigned/appended exhibit compatible cardinalities (e.g., assignment of an unbounded field will be flagged during design time, if the developer attempts to specify assignment of the unbounded field into a bounded field); ensuring that the data being assigned and/or appended exhibit compatible data types (e.g., a date field will not be assigned into a name field); ensuring that field creation is done in the right structural order (e.g., a &#x201c;b&#x201d; section created after an &#x201c;a&#x201d; section and before a &#x201c;c&#x201d; section, as discussed more fully below), i.e., in accordance with the schema of the target variable, and so on.</p><p id="p-0099" num="0098"><figref idref="DRAWINGS">FIG. <b>4</b></figref> illustrates an example use case involving specific example inputs <b>42</b>, <b>100</b>, <b>102</b>, <b>44</b> and outputs <b>46</b> of the analysis and mapping module <b>40</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, and further illustrating use awareness of the target schema <b>44</b> and a new pseudo-language ASSIGN statement <b>104</b> to assign data into an unbounded element (e.g., &#x3c;b&#x3e; . . . &#x3c;/b&#x3e; of the output variable <b>46</b>) that does not initially exist in a target Document Object Model (DOM) <b>106</b> of a target variable <b>102</b>.</p><p id="p-0100" num="0099">An assignment statement <b>42</b> is represented by a specific example assignment statement <b>104</b> used to assign source data <b>108</b> from a source variable <b>100</b> into a structure (DOM) <b>106</b> of the target variable <b>102</b>. Note that the specific assignment statement <b>104</b> specifies the target variable <b>102</b> (as $OutputVarNamOnEB) and associated node into which the bch1 data <b>108</b> from the source variable <b>100</b> is to be assigned. Similarly, the right-hand side of the specific assignment statement <b>104</b> specifies the source variable <b>100</b> (as $V1Content) and the source variable node with the bch1 data <b>108</b> to be assigned into the DOM <b>106</b> of the target variable <b>102</b>.</p><p id="p-0101" num="0100">Note that in the present example use case scenario, the target variable <b>102</b> and accompanying DOM <b>106</b> does not have a &#x201c;b&#x201d; section or element into which the source data <b>108</b> is to be assigned. Ordinarily, using conventional BPEL techniques, such an assignment would cause a runtime error, as the runtime engine would determine that the &#x201c;b&#x201d; section or element doesn't exist in the target variable <b>102</b>, and therefore nothing can be assigned into it.</p><p id="p-0102" num="0101">However, the present example embodiment employs awareness of the schema <b>44</b> of the target variable <b>102</b>. If the analysis and mapping module <b>40</b> determines that the &#x201c;b&#x201d; section or element does not exist in the current DOM <b>106</b> of the target variable <b>102</b>, it then determines whether or not the target variable schema <b>44</b> allows for the creation of such a &#x201c;b&#x201d; section or element in the target variable <b>102</b> (so as to yield the output variable <b>46</b> with the data <b>108</b> inserted at the proper location). Note that the example schema <b>44</b> is illustrated in more detail in <figref idref="DRAWINGS">FIG. <b>5</b></figref>.</p><p id="p-0103" num="0102">In the present example scenario, the analysis and mapping module <b>40</b> determines that the target variable schema <b>44</b> allows for the creation of the &#x201c;b&#x201d; section <b>108</b> in the target variable <b>102</b>, so as to thereby yield an updated version of the target variable <b>102</b> as the output variable <b>46</b>. The output variable <b>46</b> includes the data <b>108</b> in a newly created &#x201c;b&#x201d; section or element, as obtained from the source variable <b>100</b> in accordance with the specific assignment statement <b>104</b>.</p><p id="p-0104" num="0103">Accordingly, the analysis and mapping module <b>40</b> processes the specific assignment statement <b>104</b>, in view of the source variable <b>100</b>, target variable <b>102</b>, and target variable schema <b>44</b>, so as to make appropriate modifications to the output variable <b>46</b> in accordance with the specific assignment statement <b>104</b>, as allowed by the target variable schema <b>44</b>.</p><p id="p-0105" num="0104"><figref idref="DRAWINGS">FIG. <b>5</b></figref> illustrates a portion of an example schema <b>44</b> of a data object, which may correspond to the target variable schema <b>44</b> used by the analysis and mapping modules of <figref idref="DRAWINGS">FIGS. <b>1</b> and <b>4</b></figref>. The schema <b>44</b> may be implemented using an XSD (XML Schema Definition) file for setting forth rules (in accordance with a specified namespace) that a given computing object and associated DOM must follow to be considered valid.</p><p id="p-0106" num="0105">The example schema <b>44</b> represents a portion of the schema for the target variable <b>102</b> of <figref idref="DRAWINGS">FIG. <b>4</b></figref>. The example schema specifies a root node <b>110</b>, which can include various sub-sections (also called sub-objects, elements, sub-variables, or sub-nodes), including an &#x201c;a&#x201d; section <b>112</b>, a &#x201c;b&#x201d; section <b>114</b>, <b>118</b>-<b>128</b>, a &#x201c;c&#x201d; section <b>130</b>, <b>132</b>-<b>134</b>, and so on.</p><p id="p-0107" num="0106">In particular, with reference to <figref idref="DRAWINGS">FIG. <b>4</b></figref>, the DOM <b>106</b> of the target variable <b>102</b> does not have &#x201c;b&#x201d; or &#x201c;c&#x201d; section. However, the analysis and mapping module <b>40</b> can reference the target schema <b>44</b> to ascertain that the target variable <b>102</b> can accommodate a new &#x201c;b&#x201d; section <b>114</b> in the DOM <b>106</b>, and that this section will occur after the &#x201c;a&#x201d; section <b>112</b> and before any &#x201c;c&#x201d; section <b>116</b> or latter sections, e.g., a &#x201c;d&#x201d; section.</p><p id="p-0108" num="0107">Note that for other verbs (other than assign verb <b>30</b> of <figref idref="DRAWINGS">FIG. <b>3</b></figref>, and as used in the specific assignment statement <b>104</b> of <figref idref="DRAWINGS">FIG. <b>4</b></figref>), e.g., append <b>32</b> and remove <b>34</b> verbs, also leverage target variable schema awareness to manipulate the target variable <b>102</b> in accordance with the demands of the associated statement <b>104</b>, but in conformity with the target variable schema <b>44</b>. For example, the append <b>32</b> verb may also append data into an element that does not exist in a target variable DOM <b>106</b>, i.e., if the target schema <b>44</b> allows for such element to be automatically created in the target variable <b>102</b>.</p><p id="p-0109" num="0108">System awareness of the target variable schema <b>44</b> when implementing the verbs <b>30</b>-<b>34</b> of <figref idref="DRAWINGS">FIG. <b>3</b></figref>, further enables built-in design-time data-type checking/validation, cardinality checking/validation, and other validity checking of code, e.g., statements using the verbs <b>30</b>-<b>34</b> of <figref idref="DRAWINGS">FIG. <b>3</b></figref>. This can help to prevent runtime errors, and thereby reduce associated costs.</p><p id="p-0110" num="0109">In summary, with reference to <figref idref="DRAWINGS">FIGS. <b>4</b> and <b>5</b></figref>, certain embodiments can not only inhibit breaking of the schema definition of a target variable at design time, but at runtime, can also determine if and where a particular element to be assigned should be created and assigned into in target variable (e.g. the target variable <b>102</b>).</p><p id="p-0111" num="0110">For example, the analysis and mapping system <b>40</b> can determine whether a &#x201c;b&#x201d; element that the user wants to assign to the target variable <b>102</b> should be located between lines <b>2</b> and <b>3</b> in the target DOM <b>106</b>, or elsewhere. For example, in certain scenarios, section &#x201c;a&#x201d; may not exist, but &#x201c;d&#x201d; might exist. The analysis and mapping module <b>40</b> can reference the target variable schema <b>44</b> to confirm that data of the &#x201c;b&#x201d; section should be placed before the &#x201c;d&#x201d; section.</p><p id="p-0112" num="0111">Conventionally, a developer would have to conduct manual analysis of the target variable schema <b>44</b> and make decisions as to how to assign data into the target variable <b>102</b>, but while risking crashing of the software at runtime if any mistake are made when observing the target variable DOM <b>106</b>, schema <b>44</b>, and so on.</p><p id="p-0113" num="0112">Similarly, for appending data (e.g., using the append method <b>32</b> of <figref idref="DRAWINGS">FIG. <b>3</b></figref>), the analysis and mapping module <b>40</b> incorporates functionality for determining, for instance, that a user wishes to append a bch3 value into a &#x201c;b&#x201d; section of the target variable <b>102</b>, where the &#x201c;b&#x201d; section does not exist in the DOM <b>106</b>. The analysis and mapping module <b>40</b> of <figref idref="DRAWINGS">FIG. <b>4</b></figref> may create the &#x201c;b&#x201d; section if it does not already exist in the DOM <b>106</b>.</p><p id="p-0114" num="0113">The creation of the &#x201c;b&#x201d; section is done in accordance with the target variable schema definition <b>44</b>, thereby preserving the defined schema structure <b>44</b> in the DOM <b>106</b> after any modifications are made to the target variable <b>102</b> and associated DOM <b>106</b> via use of the new verbs <b>30</b>-<b>34</b> of <figref idref="DRAWINGS">FIG. <b>3</b></figref>.</p><p id="p-0115" num="0114"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a flow diagram of a second example method <b>140</b> that is usable with the embodiments of <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>5</b></figref>. The second example method <b>140</b> facilitates manipulation of data objects, such as complex variables, used by a process-based software application and/or web service.</p><p id="p-0116" num="0115">The second example method <b>140</b> includes an initial verb-providing step <b>142</b>, which includes providing a first verb for facilitating specifying assignment of source data from one or more elements (e.g., corresponding to the &#x201c;b&#x201d; element and accompanying data <b>108</b> of <figref idref="DRAWINGS">FIG. <b>4</b></figref>) a source data object (e.g., the source variable <b>100</b> of <figref idref="DRAWINGS">FIG. <b>4</b></figref>) into one or more elements of a target data object (e.g., the target variable <b>102</b> of <figref idref="DRAWINGS">FIG. <b>4</b></figref>).</p><p id="p-0117" num="0116">Subsequently, a verb-detection step <b>144</b> includes, during design time of a process-based software application, detecting use of the first verb (e.g., ASSIGN) to assign the source data to the one or more elements of the target data object.</p><p id="p-0118" num="0117">Next, after detecting use of the first verb, a first schema-referencing step <b>146</b> includes referencing a schema of the target data object (e.g., the target variable schema <b>44</b> of <figref idref="DRAWINGS">FIG. <b>4</b></figref>) to determine if a first data type of the source data is compatible with a second data type of the one or more elements of the target data object to be assigned the source data (e.g., the data <b>108</b> of <figref idref="DRAWINGS">FIG. <b>4</b></figref>), and if not, then issuing a first alert.</p><p id="p-0119" num="0118">A second schema-referencing step <b>148</b> includes ascertaining if a cardinality of the source data is compatible with a cardinality of the one or more elements of the target data object to be assigned the source data, such that the source data can fit within the one or more elements of the target data object, and if not, then issuing a second alert.</p><p id="p-0120" num="0119">A third schema-referencing step <b>150</b> includes ensuring that the source data (e.g., data <b>108</b> of <figref idref="DRAWINGS">FIG. <b>4</b></figref>) is inserted into a location in the target data object (e.g., target variable <b>102</b> of <figref idref="DRAWINGS">FIG. <b>4</b></figref>) in accordance with the target schema (e.g., the schema <b>44</b> of <figref idref="DRAWINGS">FIGS. <b>4</b> and <b>5</b></figref>) and use of the first verb.</p><p id="p-0121" num="0120">Note that the method <b>140</b> may be altered, without departing from the scope of the present teachings. For example, steps may be interchanged, omitted, or replaced with other steps, and steps and/or details may be added as needed to meet the needs of a given implementation.</p><p id="p-0122" num="0121">For example, the second example method <b>140</b> may further specify providing a second verb, i.e., an append verb, for facilitating specifying appending of data from the source data object into the target data object; and providing a third verb, i.e., a remove verb, for facilitating specifying removing of data from the target data object.</p><p id="p-0123" num="0122">The first verb may represent a pseudo-language assign function that uses one or more BPEL verbs to implement software functionality of the assign verb.</p><p id="p-0124" num="0123">The second verb may also represent a pseudo-language append function that uses one or more BPEL verbs to implement software functionality of the append verb.</p><p id="p-0125" num="0124">The second example method <b>140</b> may also specify that one more elements of the source data object include a source variable that is a subset of the source data object, and wherein the one or more elements of the target data object include a target variable that is a subset of the target data object. In this case, the source data object and the target data object represent a source complex variable and a target complex variable, respectively.</p><p id="p-0126" num="0125">The second example method <b>140</b> may further include: during runtime, detecting when the target complex variable does not preexist in the target data object; referencing a schema of the target data object to determine if the target complex variable can be automatically created in the target data object, and generating a first signal in response thereto; automatically generating, in response to the first signal, a target complex variable in the target data object to accommodate the source data, wherein the target complex variable is created at a location in the target data object that is consistent with a location specified by the schema of the target data object.</p><p id="p-0127" num="0126"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a general block diagram of a system <b>900</b> and accompanying computing environment usable to implement the embodiments of <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>6</b></figref>. Embodiments may be implemented as standalone applications (for example, residing in a user device) or as web-based applications implemented using a combination of client-side and server-side code.</p><p id="p-0128" num="0127">The general system <b>900</b> includes user devices <b>960</b>-<b>990</b>, including desktop computers <b>960</b>, notebook computers <b>970</b>, smartphones <b>980</b>, mobile phones <b>985</b>, and tablets <b>990</b>. The general system <b>900</b> can interface with any type of user device, such as a thin-client computer, Internet-enabled mobile telephone, mobile Internet access device, tablet, electronic book, or personal digital assistant, capable of displaying and navigating web pages or other types of electronic documents and UIs, and/or executing applications. Although the system <b>900</b> is shown with five user devices, any number of user devices can be supported.</p><p id="p-0129" num="0128">A web server <b>910</b> is used to process requests from web browsers and standalone applications for web pages, electronic documents, enterprise data or other content, and other data from the user computers. The web server <b>910</b> may also provide push data or syndicated content, such as RSS feeds, of data related to enterprise operations.</p><p id="p-0130" num="0129">An application server <b>920</b> operates one or more applications. The applications can be implemented as one or more scripts or programs written in any programming language, such as Java, C, C++, C#, or any scripting language, such as JavaScript or ECMAScript (European Computer Manufacturers Association Script), Perl, PHP (Hypertext Preprocessor), Python, Ruby, or TCL (Tool Command Language).</p><p id="p-0131" num="0130">Applications can be built using libraries or application frameworks, such as Rails, Enterprise JavaBeans, or .NET. Web content can created using HTML (HyperText Markup Language), CSS (Cascading Style Sheets), and other web technology, including templating languages and parsers.</p><p id="p-0132" num="0131">The data applications running on the application server <b>920</b> are adapted to process input data and user computer requests and can store or retrieve data from data storage device or database <b>930</b>. Database <b>930</b> stores data created and used by the data applications. In an embodiment, the database <b>930</b> includes a relational database that is adapted to store, update, and retrieve data in response to SQL format commands or other database query languages. Other embodiments may use unstructured data storage architectures and NoSQL (Not Only SQL) databases.</p><p id="p-0133" num="0132">In an embodiment, the application server <b>920</b> includes one or more general-purpose computers capable of executing programs or scripts. In an embodiment, web server <b>910</b> is implemented as an application running on the one or more general-purpose computers. The web server <b>910</b> and application server <b>920</b> may be combined and executed on the same computers.</p><p id="p-0134" num="0133">An electronic communication network <b>940</b>-<b>950</b> enables communication between user computers <b>960</b>-<b>990</b>, web server <b>910</b>, application server <b>920</b>, and database <b>930</b>. In an embodiment, networks <b>940</b>-<b>950</b> may further include any form of electrical or optical communication devices, including wired network <b>940</b> and wireless network <b>950</b>. Networks <b>940</b>-<b>950</b> may also incorporate one or more local-area networks, such as an Ethernet network, wide-area networks, such as the Internet; cellular carrier data networks; and virtual networks, such as a virtual private network.</p><p id="p-0135" num="0134">The system is one example for executing applications according to an embodiment of the invention. In another embodiment, application server <b>910</b>, web server <b>920</b>, and optionally database <b>930</b> can be combined into a single server computer application and system. In a further embodiment, virtualization and virtual machine applications may be used to implement one or more of the application server <b>910</b>, web server <b>920</b>, and database <b>930</b>.</p><p id="p-0136" num="0135">In still further embodiments, all or a portion of the web and application serving functions may be integrated into an application running on each of the user computers. For example, a JavaScript application on the user computer may be used to retrieve or analyze data and display portions of the applications.</p><p id="p-0137" num="0136"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a general block diagram of a computing device usable to implement the embodiments of <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>6</b></figref>. While system <b>402</b> of <figref idref="DRAWINGS">FIG. <b>8</b></figref> is described as facilitating performing the steps as described in certain implementations herein, any suitable component or combination of components of system <b>402</b> or any suitable processor or processors associated with system <b>402</b> may be used for performing the steps described.</p><p id="p-0138" num="0137"><figref idref="DRAWINGS">FIG. <b>8</b></figref> illustrates a block diagram of an example computing system <b>500</b>, which may be used for implementations described herein. For example, computing system <b>500</b> may be used to implement server devices <b>910</b>, <b>920</b> of <figref idref="DRAWINGS">FIG. <b>7</b></figref> as well as to perform the method implementations described herein. In some implementations, computing system <b>500</b> may include a processor <b>502</b>, an operating system <b>504</b>, a memory <b>506</b>, and an input/output (I/O) interface <b>508</b>. In various implementations, processor <b>502</b> may be used to implement various functions and features described herein, as well as to perform the method implementations described herein. While processor <b>502</b> is described as performing implementations described herein, any suitable component or combination of components of system <b>500</b> or any suitable processor or processors associated with system <b>500</b> or any suitable system may perform the steps described. Implementations described herein may be carried out on a user device, on a server, or a combination of both.</p><p id="p-0139" num="0138">Computing device <b>500</b> also includes a software application <b>510</b>, which may be stored on memory <b>506</b> or on any other suitable storage location or computer-readable medium. Software application <b>510</b> provides instructions that enable processor <b>502</b> to perform the functions described herein and other functions. The components of computing system <b>500</b> may be implemented by one or more processors or any combination of hardware devices, as well as any combination of hardware, software, firmware, etc.</p><p id="p-0140" num="0139">For ease of illustration, <figref idref="DRAWINGS">FIG. <b>8</b></figref> shows one block for each of processor <b>502</b>, operating system <b>504</b>, memory <b>506</b>, I/O interface <b>508</b>, and software application <b>510</b>. These blocks <b>502</b>, <b>504</b>, <b>506</b>, <b>508</b>, and <b>510</b> may represent multiple processors, operating systems, memories, I/O interfaces, and software applications. In various implementations, computing system <b>500</b> may not have all of the components shown and/or may have other elements including other types of components instead of, or in addition to, those shown herein.</p><p id="p-0141" num="0140">Although the description has been described with respect to particular embodiments thereof, these particular embodiments are merely illustrative, and not restrictive. For example, while embodiments are primarily discussed as usable for manipulating complex variables implemented in XML during orchestrations involving process-based software applications, embodiments are not limited thereto. For example, embodiments may be readily adapted to selectively manipulate elements of data objects implemented in JSON or other languages, without departing from the scope of the present teachings.</p><p id="p-0142" num="0141">Any suitable programming language can be used to implement the routines of particular embodiments including C, C++, Java, assembly language, etc. Different programming techniques can be employed such as procedural or object oriented. The routines can execute on a single processing device or multiple processors. Although the steps, operations, or computations may be presented in a specific order, this order may be changed in different particular embodiments. In some particular embodiments, multiple steps shown as sequential in this specification can be performed at the same time.</p><p id="p-0143" num="0142">Particular embodiments may be implemented in a computer-readable storage medium for use by or in connection with the instruction execution system, apparatus, system, or device. Particular embodiments can be implemented in the form of control logic in software or hardware or a combination of both. The control logic, when executed by one or more processors, may be operable to perform that which is described in particular embodiments. For example, a tangible medium such as a hardware storage device can be used to store the control logic, which can include executable instructions.</p><p id="p-0144" num="0143">Particular embodiments may be implemented by using a programmed general purpose digital computer, by using application specific integrated circuits, programmable logic devices, field programmable gate arrays, optical, chemical, biological, quantum or nanoengineered systems, etc. Other components and mechanisms may be used. In general, the functions of particular embodiments can be achieved by any means as is known in the art. Distributed, networked systems, components, and/or circuits can be used. Cloud computing or cloud services can be employed. Communication, or transfer, of data may be wired, wireless, or by any other means.</p><p id="p-0145" num="0144">It will also be appreciated that one or more of the elements depicted in the drawings/figures can also be implemented in a more separated or integrated manner, or even removed or rendered as inoperable in certain cases, as is useful in accordance with a particular application. It is also within the spirit and scope to implement a program or code that can be stored in a machine-readable medium to permit a computer to perform any of the methods described above.</p><p id="p-0146" num="0145">A &#x201c;processor&#x201d; includes any suitable hardware and/or software system, mechanism or component that processes data, signals or other information. A processor can include a system with a general-purpose central processing unit, multiple processing units, dedicated circuitry for achieving functionality, or other systems. Processing need not be limited to a geographic location, or have temporal limitations. For example, a processor can perform its functions in &#x201c;real time,&#x201d; &#x201c;offline,&#x201d; in a &#x201c;batch mode,&#x201d; etc. Portions of processing can be performed at different times and at different locations, by different (or the same) processing systems. Examples of processing systems can include servers, clients, end user devices, routers, switches, networked storage, etc. A computer may be any processor in communication with a memory. The memory may be any suitable processor-readable storage medium, such as random-access memory (RAM), read-only memory (ROM), magnetic or optical disk, or other tangible media suitable for storing instructions for execution by the processor.</p><p id="p-0147" num="0146">As used in the description herein and throughout the claims that follow, &#x201c;a&#x201d;, &#x201c;an&#x201d;, and &#x201c;the&#x201d; includes plural references unless the context clearly dictates otherwise. Also, as used in the description herein and throughout the claims that follow, the meaning of &#x201c;in&#x201d; includes &#x201c;in&#x201d; and &#x201c;on&#x201d; unless the context clearly dictates otherwise.</p><p id="p-0148" num="0147">Thus, while particular embodiments have been described herein, latitudes of modification, various changes, and substitutions are intended in the foregoing disclosures, and it will be appreciated that in some instances some features of particular embodiments will be employed without a corresponding use of other features without departing from the scope and spirit as set forth. Therefore, many modifications may be made to adapt a particular situation or material to the essential scope and spirit.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>We claim:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A non-transitory processor-readable medium including instructions for a method of providing a pseudo language for manipulating complex variables of an orchestration flow, the method comprising:<claim-text>providing the pseudo language for manipulating the complex variables associated with the orchestration flow; and</claim-text><claim-text>specifying verbs in the pseudo language, wherein the verbs cause operations to be performed on the complex variables during processing of the orchestration flow; and</claim-text><claim-text>specifying a first verb of the verbs with a first operation of the operations, wherein the first operation, when processed, transfers data from a first set of source elements in a source complex variable to new target elements in a target complex variable based on a description of a target schema of the target complex variable, wherein the target complex variable does not include the first subset of source elements and the target schema includes the description of the first subset of the source elements.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The non-transitory processor-readable medium as recited by <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the method further comprises:<claim-text>receiving the orchestration flow that includes a statement involving the operation to be performed.</claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The non-transitory processor-readable medium as recited by <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the statement includes the first verb.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The non-transitory processor-readable medium as recited by <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the verb is an append verb for the transferring of the data from the first set of source elements in the source complex variable to the new target elements in the target complex variable.</claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The non-transitory processor-readable medium as recited by <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the verbs include an assign verb specifying a mapping from a portion of the source complex variable to a portion of the target complex variable.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The non-transitory processor-readable medium as recited by <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the verbs include a remove verb for removing data in a target element of the target complex variable enabling a target application to recalculate data for the target element.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The non-transitory processor-readable medium as recited by <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the method further comprises:<claim-text>providing incremental update of the target complex variable.</claim-text></claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The non-transitory processor-readable medium as recited by <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the method further comprises:<claim-text>providing a first hierarchy structure of leaf nodes, arranged according to categories, for the source complex variable; and</claim-text><claim-text>providing a second hierarchy structure of leaf nodes, arranged according to categories, for the target complex variable.</claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The non-transitory processor-readable medium as recited by <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the method further comprises:<claim-text>providing selective modification of one or more of the leaf nodes of the target complex variable based on at least one of the verbs, wherein the verbs include an assign verb, an append verb, and a remove verb.</claim-text></claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The non-transitory processor-readable medium as recited by <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the method further comprises:<claim-text>performing the first operation for a first step in the orchestration flow, wherein the first step specifies the first verb; and</claim-text><claim-text>upon completion of the first operation, feeding the target complex variable into a subsequent step of the orchestration flow.</claim-text></claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. A method of providing a pseudo language for manipulating complex variables of an orchestration flow, the method comprising:<claim-text>providing the pseudo language for manipulating the complex variables associated with the orchestration flow; and</claim-text><claim-text>specifying verbs in the pseudo language, wherein the verbs cause operations to be performed on the complex variables during processing of the orchestration flow; and</claim-text><claim-text>specifying a first verb of the verbs with a first operation of the operations, wherein the first operation, when processed, transfers data from a first set of source elements in a source complex variable to new target elements in a target complex variable based on a description of a target schema of the target complex variable, wherein the target complex variable does not include the first subset of source elements and the target schema includes the description of the first subset of the source elements.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The method as recited by <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the method further comprises:<claim-text>receiving the orchestration flow that includes a statement involving the operation to be performed.</claim-text></claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The method as recited by <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the statement includes the first verb.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The method as recited by <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the verb is an append verb for the transferring of the data from the first set of source elements in the source complex variable to the new target elements in the target complex variable.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The method as recited by <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the verbs include an assign verb specifying a mapping from a portion of the source complex variable to a portion of the target complex variable.</claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The method as recited by <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the verbs include a remove verb for removing data in a target element of the target complex variable enabling a target application to recalculate data for the target element.</claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The method as recited by <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the method further comprises:<claim-text>providing incremental update of the target complex variable.</claim-text></claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The method as recited by <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the method further comprises:<claim-text>providing a first hierarchy structure of leaf nodes, arranged according to categories, for the source complex variable;</claim-text><claim-text>providing a second hierarchy structure of leaf nodes, arranged according to categories, for the target complex variable; and</claim-text><claim-text>providing selective modification of one or more of the leaf nodes of the target complex variable based on at least one of the verbs, wherein the verbs include an assign verb, an append verb, and a remove verb.</claim-text></claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The method as recited by <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the method further comprises:<claim-text>performing the first operation for a first step in the orchestration flow, wherein the first step specifies the first verb; and</claim-text><claim-text>upon completion of the first operation, feeding the target complex variable into a subsequent step of the orchestration flow.</claim-text></claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. An apparatus of providing a pseudo language for manipulating complex variables of an orchestration flow, the apparatus comprising:<claim-text>one or more hardware computer processors; and</claim-text><claim-text>logic encoded in one or more non-transitory processor-readable medium for execution by the one or more hardware computer processors and when executed operable for:</claim-text><claim-text>providing the pseudo language for manipulating the complex variables associated with the orchestration flow; and</claim-text><claim-text>specifying verbs in the pseudo language, wherein the verbs cause operations to be performed on the complex variables during processing of the orchestration flow; and</claim-text><claim-text>specifying a first verb of the verbs with a first operation of the operations, wherein the first operation, when processed, transfers data from a first set of source elements in a source complex variable to new target elements in a target complex variable based on a description of a target schema of the target complex variable, wherein the target complex variable does not include the first subset of source elements and the target schema includes the description of the first subset of the source elements.</claim-text></claim-text></claim></claims></us-patent-application>