<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004624A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004624</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17855391</doc-number><date>20220630</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>17</main-group><subgroup>16</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>7</main-group><subgroup>544</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>17</main-group><subgroup>15</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>17</main-group><subgroup>16</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>7</main-group><subgroup>5443</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>17</main-group><subgroup>153</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">HIGH THROUGHPUT MATRIX PROCESSOR WITH SUPPORT FOR CONCURRENTLY PROCESSING MULTIPLE MATRICES</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>16667791</doc-number><date>20191029</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11409838</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17855391</doc-number></document-id></child-doc></relation></continuation></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Meta Platforms, Inc.</orgname><address><city>Menlo Park</city><state>CA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Nair</last-name><first-name>Krishnakumar Narayanan</first-name><address><city>Newark</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Wu</last-name><first-name>Olivia</first-name><address><city>Los Altos</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>Khish Ardestani Zadeh</last-name><first-name>Ehsan</first-name><address><city>San Jose</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="03" designation="us-only"><addressbook><last-name>Diril</last-name><first-name>Abdulkadir Utku</first-name><address><city>Menlo Park</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="04" designation="us-only"><addressbook><last-name>Ulrich</last-name><first-name>Thomas Mark</first-name><address><city>Sunnyvale</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="05" designation="us-only"><addressbook><last-name>Hao</last-name><first-name>Yuchen</first-name><address><city>Sunnyvale</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="06" designation="us-only"><addressbook><last-name>Komuravelli</last-name><first-name>Rakesh</first-name><address><city>Fremont</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="07" designation="us-only"><addressbook><last-name>Kalaiah</last-name><first-name>Aravind</first-name><address><city>San Jose</city><state>CA</state><country>US</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A system comprises a data input vector unit, a weight input vector unit, and a plurality of calculation units. The data input vector unit is configured to concurrently receive elements of different rows of a first and second data matrix. The weight input vector unit is configured to receive a combined weight vector and at least in part concurrently provide obtained weight elements of a first and second weight matrix to a corresponding first and second group of calculation units. At least one calculation unit of each group of the first and second group of calculation units is configured to multiply elements from the data input vector unit with corresponding elements of the corresponding weight matrix from the weight input vector unit and sum together multiplication results of the corresponding calculation unit to at least in part determine a corresponding element in a first or second convolution result matrix.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="99.23mm" wi="158.75mm" file="US20230004624A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="224.28mm" wi="161.63mm" orientation="landscape" file="US20230004624A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="222.67mm" wi="162.64mm" orientation="landscape" file="US20230004624A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="215.22mm" wi="147.40mm" file="US20230004624A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="172.55mm" wi="65.62mm" file="US20230004624A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="180.17mm" wi="83.40mm" file="US20230004624A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="202.10mm" wi="65.70mm" file="US20230004624A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="197.70mm" wi="167.39mm" file="US20230004624A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="167.89mm" wi="65.53mm" file="US20230004624A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="61.38mm" wi="104.14mm" orientation="landscape" file="US20230004624A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="197.27mm" wi="123.36mm" orientation="landscape" file="US20230004624A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="210.40mm" wi="142.07mm" orientation="landscape" file="US20230004624A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="210.40mm" wi="142.24mm" orientation="landscape" file="US20230004624A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="210.99mm" wi="142.66mm" orientation="landscape" file="US20230004624A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00014" num="00014"><img id="EMI-D00014" he="210.40mm" wi="142.75mm" orientation="landscape" file="US20230004624A1-20230105-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00015" num="00015"><img id="EMI-D00015" he="213.53mm" wi="142.75mm" orientation="landscape" file="US20230004624A1-20230105-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00016" num="00016"><img id="EMI-D00016" he="213.11mm" wi="142.75mm" orientation="landscape" file="US20230004624A1-20230105-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00017" num="00017"><img id="EMI-D00017" he="213.19mm" wi="142.58mm" orientation="landscape" file="US20230004624A1-20230105-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00018" num="00018"><img id="EMI-D00018" he="213.36mm" wi="142.58mm" orientation="landscape" file="US20230004624A1-20230105-D00018.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">CROSS REFERENCE TO OTHER APPLICATIONS</heading><p id="p-0002" num="0001">This application is a continuation of U.S. patent application Ser. No. 16/667,791 entitled HIGH THROUGHPUT MATRIX PROCESSOR WITH SUPPORT FOR CONCURRENTLY PROCESSING MULTIPLE MATRICES filed Oct. 29, 2019 which is incorporated herein by reference for all purposes.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">BACKGROUND OF THE INVENTION</heading><p id="p-0003" num="0002">Processing neural networks to solve artificial intelligence problems is improved by using hardware solutions. These solutions can include hardware matrix multiplication units and dedicated matrix processing pipelines. The performance improvements can be significant due to the computation and data intensive nature of problems solved using neural networks. As the artificial neural networks become more complex, however, the characteristics of the neural networks can change. For example, neural networks can exist with different numbers of layers and each layer can have different dimensions. As the layers advance from the input layer to the output layer, the size of the layers can reduce resulting in reduced matrix sizes. Hardware sized to efficiently process matrix operations required by an input layer may be inefficient when used to solve a differently sized intermediate or output layer. Therefore, there exists a need for a high throughput matrix multiplication scheme compatible with matrices with reduced dimensions.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0004" num="0003">Various embodiments of the invention are disclosed in the following detailed description and the accompanying drawings.</p><p id="p-0005" num="0004"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram illustrating an embodiment of a system for solving artificial intelligence problems using a neural network.</p><p id="p-0006" num="0005"><figref idref="DRAWINGS">FIG. <b>2</b>A</figref> is a block diagram illustrating an embodiment of a processor system for solving artificial intelligence problems using a neural network.</p><p id="p-0007" num="0006"><figref idref="DRAWINGS">FIG. <b>2</b>B</figref> is a block diagram illustrating an embodiment of a matrix processor unit for solving artificial intelligence problems using a neural network.</p><p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a flow chart illustrating an embodiment of a process for performing multiple two-dimensional convolution operations in parallel using a matrix processor unit.</p><p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a flow chart illustrating an embodiment of a process for performing a two-dimensional convolution operation using a matrix processor unit.</p><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a flow chart illustrating an embodiment of a process for performing a two-dimensional convolution operation using a matrix processor unit and vector unit operations.</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. <b>6</b>A</figref> is a flow chart illustrating an embodiment of a process for performing a two-dimensional convolution operation using a matrix processor unit and vector unit operations.</p><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>6</b>B</figref> is a flow chart illustrating an embodiment of a process for preparing weight input operands for performing two-dimensional convolution operations using a matrix processor unit and vector unit operations.</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIGS. <b>7</b>A and <b>7</b>B</figref> are diagrams illustrating example matrix operands for performing depthwise convolution.</p><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIGS. <b>8</b>A and <b>8</b>B</figref> are diagrams illustrating an example of an unrolled data matrix for performing depthwise convolution.</p><p id="p-0015" num="0014"><figref idref="DRAWINGS">FIGS. <b>9</b>A and <b>9</b>B</figref> are diagrams illustrating an example of an unrolled weight matrix for performing depthwise convolution.</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIGS. <b>10</b>A and <b>10</b>B</figref> are diagrams illustrating an example of vector computations for performing depthwise convolution.</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIGS. <b>11</b>A and <b>11</b>B</figref> are diagrams illustrating an example of a combined weight vector used for performing multiple depthwise convolution operations in parallel.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0004" level="1">DETAILED DESCRIPTION</heading><p id="p-0018" num="0017">The invention can be implemented in numerous ways, including as a process; an apparatus; a system; a composition of matter; a computer program product embodied on a computer readable storage medium; and/or a processor, such as a processor configured to execute instructions stored on and/or provided by a memory coupled to the processor. In this specification, these implementations, or any other form that the invention may take, may be referred to as techniques. In general, the order of the steps of disclosed processes may be altered within the scope of the invention. Unless stated otherwise, a component such as a processor or a memory described as being configured to perform a task may be implemented as a general component that is temporarily configured to perform the task at a given time or a specific component that is manufactured to perform the task. As used herein, the term &#x2018;processor&#x2019; refers to one or more devices, circuits, and/or processing cores configured to process data, such as computer program instructions.</p><p id="p-0019" num="0018">A detailed description of one or more embodiments of the invention is provided below along with accompanying figures that illustrate the principles of the invention. The invention is described in connection with such embodiments, but the invention is not limited to any embodiment. The scope of the invention is limited only by the claims and the invention encompasses numerous alternatives, modifications and equivalents. Numerous specific details are set forth in the following description in order to provide a thorough understanding of the invention. These details are provided for the purpose of example and the invention may be practiced according to the claims without some or all of these specific details. For the purpose of clarity, technical material that is known in the technical fields related to the invention has not been described in detail so that the invention is not unnecessarily obscured.</p><p id="p-0020" num="0019">A processor system for performing efficient convolution operations is disclosed. Using the disclosed techniques, the throughput and power efficiency for computing convolution operations and in particular depthwise convolutions is significantly increased for a range of matrix dimensions, including reduced matrix dimensions. In some embodiments, the processor system includes a matrix processor unit capable of performing matrix operations on two input matrices. The matrix processor unit includes a plurality of calculation units such as vector units used to process input vectors of the input matrices. In various embodiments, a calculation unit includes at least a vector multiply unit and a vector adder unit. The vector multiply unit is capable of performing multiply operations using corresponding elements of two input vectors. In some embodiments, the vector adder unit is used to sum the vector of multiplication results computed using a vector multiply unit. For example, the vector adder unit can be used to compute the dot product result of two vectors using the vector multiplication results of vector elements from corresponding input vectors. In some embodiments, the vector adder unit is an adder tree. For example, an adder tree computes the sum of the multiplication results by summing multiplication results and subsequent partial sums in parallel.</p><p id="p-0021" num="0020">In various embodiments, the matrix processor unit is used to compute, in parallel, at least the partial result of multiple convolution operations such as multiple depthwise convolutions each involving two input matrices, such as a weight input and a data input matrix, by unrolling the input matrices. For example, two convolution operations are performed in parallel by assigning the vector calculation units of the matrix processor unit between the two convolution operations. A first group of vector calculation units solves the first convolution operation and a second group of vector calculation units solves the second convolution operation. A pair of weight matrices, one corresponding to each convolution operation, is read from memory and each is unrolled. For example, each weight matrix is a two-dimensional matrix that is linearized. The linearized weight matrices are stored together as a combined weight vector in memory. Once read from memory, each weight matrix is extracted from the combined weight vector and unrolled into a single row formatted as its own weight input vector. In some embodiments, the weights are extracted and converted to unrolled weight vectors by an input vector unit. As an example, two 3&#xd7;3 matrices are merged and represented as 18 elements in a single combined weight vector. The elements corresponding to the weight matrix of the first convolution operation are extracted and unrolled into a single vector that may include padding, such as zero elements, between rows. Similarly, elements corresponding to the weight matrix of the second convolution operation are extracted and unrolled into another single vector that may include padding, such as zero elements, between rows. Concurrently with unrolling the weight input matrices, the corresponding data input matrices are also unrolled. In various embodiments, the corresponding data input matrices are unrolled and formatted to align the elements of the vector input data with the corresponding elements from the weight input data. The input vectors corresponding to the first convolution operation are directed to the first group of vector calculation units and the input vectors corresponding to the second convolution operation are directed to the second group of vector calculation units. Using as an example a matrix processor unit with 32 vector calculation units, 16 vector units can be allocated to solving each convolution operation. The input vectors are then processed using the matrix processor unit to compute two corresponding result sums, one for each convolution operation. In some embodiments, the two different convolution operations can correspond to different channels and are solved in parallel. For example, the different data matrices for each convolution operation may be different channels of the same three-dimensional data matrix.</p><p id="p-0022" num="0021">In various embodiments, the elements of the unrolled weight vectors are shifted, for example, during an iteration, to compute at least a partial convolution result of each weight vector with the next column of corresponding data input elements. For example, the elements of an unrolled weight input vector may be shifted by one row element to align the weight vector elements with the corresponding next column of an unrolled data input vector. In some embodiments, the number of shifts performed during an iteration corresponds to the amount of padding between the rows of a weight input vector. For example, in the event seven zero-padded elements separate each unrolled row from a weight input matrix, after an initial set of matrix computation operations are performed, seven shifts and corresponding matrix computation operations may be performed before progressing to the next iteration. In various embodiments, the unrolled weight input vector may be broadcasted to each of the corresponding vector calculation units allocated for a particular convolution operation to compute the vector result for multiple rows in parallel. In some embodiments, multiple matrix processor units may be utilized and different matrix processor units may compute the partial sums of different iterations of the same input matrices in parallel. The partial sum results from each matrix processor unit may be combined to compute a result sum. Although described with respect to solving two convolution operations in parallel, more than two convolutions operations can be solved in parallel depending on the number of vector calculation units available. For example, three convolution operations involving 3&#xd7;3 weight matrices can be solved in parallel. The three weight matrices can be merged by storing the 27 weight elements as a single combined weight vector in memory. Once read from memory, the three weight matrices can be expanded by an input vector unit into three separate unrolled weight input vectors and the available vector calculation units are allocated among the three convolution operations. In the event more than one read is necessary to read the weight matrices from memory, multiple reads can be utilized to read additional weight matrices. For example, a processing element limited to 32-element reads may require multiple reads to load four or more 3&#xd7;3 weight matrices, since four weight matrices may require 36 weight elements.</p><p id="p-0023" num="0022">In some embodiments, a system comprises a data input vector unit, a weight input vector unit, and a matrix processor unit with a plurality of calculation units. For example, a matrix processor unit contains multiple vector calculation units used to process input vectors prepared by a data input vector unit and a weight input vector unit. The plurality of calculation units of the matrix processor unit includes both a first group of one or more calculation units and a second group of one or more calculation units. Each group may be associated with a different convolution operation. The data input vector unit is configured to concurrently receive elements of a plurality of different rows of a first data matrix and a plurality of different rows of a second data matrix. For example, the matrix processor unit can process two convolution operations in parallel. A data input vector unit can prepare data input vectors corresponding to two different data matrices. The data input vector unit may read the data elements from corresponding data matrices from memory. A weight input vector unit is configured to receive a combined weight vector, wherein the combined weight vector includes weight elements of a first weight matrix and weight elements of a second weight matrix. For example, the two weight matrices are each associated with one of the two data matrices and correspond to two different convolution operations. In various embodiments, the two weight matrices are combined and stored as a combined weight vector. The weight input vector unit obtains weight elements of the first weight matrix and weight elements of the second weight matrix from the combined weight vector. For example, the first weight matrix is extracted from the combined weight vector by identifying and obtaining the corresponding weight elements for the first weight matrix from the combined weight vector. Similarly, the second weight matrix is extracted by identifying and obtaining the corresponding weight elements for the second weight matrix from the combined weight vector. In some embodiments, the weight input vector unit at least in part concurrently provides the obtained weight elements of the first weight matrix to the first group of one or more calculation units and provides the obtained weight elements of the second weight matrix to the second group of one or more calculation units. For example, the weight elements of each weight matrix are formatted into a weight input mask and broadcasted to a corresponding group of calculation units of the matrix processor unit. A first group of vector calculation units receives the formatted weight matrix for a first convolution operation and a second group of calculation units receives the formatted weight matrix for a second convolution operation. In some embodiments, each calculation unit of the first group of calculation units is configured to multiply provided elements of the first data matrix from the data input vector unit with provided corresponding elements of the first weight matrix from the weight input vector unit and sum together multiplication results of the corresponding calculation unit to at least in part determine a corresponding element in a first convolution result matrix. Similarly, each calculation unit of the second group of calculation units is configured to multiply provided elements of the second data matrix from the data input vector unit with provided corresponding elements of the second weight matrix from the weight input vector unit and sum together multiplication results of the corresponding calculation unit to at least in part determine a corresponding element in a second convolution result matrix. For example, each group of calculation units performs vector operations on the received input vectors prepared by the data input vector unit and the weight input vector unit. In some embodiments, each calculation unit includes a vector multiply unit and a vector adder unit for performing vector operations such as a dot product result. The result of each calculation unit from the first or second group of calculation units is used to determine a result or partial result of the associated convolution operation. In some embodiments, the vector output results may be used to at least in part determine a result of multiplying a weight matrix and at least a portion of the corresponding data matrix. For example, successive accumulation of vector output results may be used to determine the result of multiplying one of the weight input matrices with one of the corresponding data input matrices. In some embodiments, the vector output results may be used to at least in part determine a corresponding element in a result matrix of convoluting a data matrix with a weight matrix. For example, successive accumulation of vector output results may be used to determine the result of a depthwise convolution using a weight input matrix with a data input matrix.</p><p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram illustrating an embodiment of a system for solving artificial intelligence problems using a neural network. In the example shown, system <b>100</b> includes processing element <b>101</b> and memory <b>161</b>. Processing element <b>101</b> includes data input vector unit <b>103</b>, weight input vector unit <b>105</b>, matrix processor unit <b>107</b>, and output vector unit <b>151</b>. Matrix processor unit <b>107</b> includes multiple vector calculation units including at least vector units <b>111</b>, <b>121</b>, <b>131</b>, and <b>141</b>. In various embodiments, matrix processor unit <b>107</b> receives one or more data input vectors (not shown) from data input vector unit <b>103</b> and at least one weight input vector (not shown) from weight input vector unit <b>105</b>. For example, a data input vector is generated by data input vector unit <b>103</b> and a weight input vector is generated by weight input vector unit <b>105</b>. The generated data input vector and weight input vector pair may be passed as arguments to a vector calculation unit, such as one of vector units <b>111</b>, <b>121</b>, <b>131</b>, and <b>141</b>, of matrix processor unit <b>107</b>. For example, a vector unit of matrix processor unit <b>107</b> may determine a matrix result, such as a dot product result, using a data input vector and weight input vector pair. In some embodiments, matrix processor unit <b>107</b> includes 32 vector units. Each vector unit may take two 32-element vectors as arguments and can each produce a single element result. Taken across all vector units, the results are an output vector result. In various embodiments, the output of matrix processor unit <b>107</b> can be an output vector and is received at output vector unit <b>151</b>. In some embodiments, the output vector is determined by accumulating partial vector results across multiple vector unit operations. In some embodiments, the output vector received at output vector unit <b>151</b> is a 32-element vector. Other vector lengths may be utilized as appropriate. Similarly, the size of the elements processed by system <b>100</b> can be configured as appropriate. For example, elements may be 4-bits, 8-bits, 2-byte, 4-bytes, or another appropriate size.</p><p id="p-0025" num="0024">In various embodiments, matrix processor unit <b>107</b> is configured to receive two input matrices, each matrix a two-dimensional matrix via data input vector unit <b>103</b> and weight input vector unit <b>105</b>, respectively. Data input vector unit <b>103</b>, weight input vector unit <b>105</b>, and output vector unit <b>151</b> may be implemented using hardware registers, such as flip-flop circuits, for transferring multiple input and output elements to/from matrix processor unit <b>107</b>. In some embodiments, elements corresponding to each data input vector are retrieved from memory <b>161</b> and loaded into a corresponding vector unit, such as vector units <b>111</b>, <b>121</b>, <b>131</b>, or <b>141</b>, of matrix processor unit <b>107</b> via data input vector unit <b>103</b>. For example, a matrix processor unit with 32 vector units is loaded with 32 vectors of data elements via data input vector unit <b>103</b>. Correspondingly, a vector of weight elements may be loaded from memory <b>161</b> via weight input vector unit <b>105</b> and broadcasted to all the applicable vector units of matrix processor unit <b>107</b>. By broadcasting the same weight input vector using unit weight input vector unit <b>105</b> to all vector units of matrix processor unit <b>107</b>, the same weight values can be applied to different data vectors by the matrix processor unit and each respective vector unit. In some embodiments, data input vector unit <b>103</b>, weight input vector unit <b>105</b>, and/or output vector unit <b>151</b> may process more than one input/output vector simultaneously. In various embodiments, the thick arrows of <figref idref="DRAWINGS">FIG. <b>1</b></figref> represent the direction data moves through the components of system <b>100</b>. For example, the arrows may correspond to multi-element wide communication/data buses and/or data lines. In various embodiments, an output vector result received at output vector unit <b>151</b> can be written back to memory <b>161</b>.</p><p id="p-0026" num="0025">In various embodiments, each vector unit of matrix processor unit <b>107</b>, such as vector units <b>111</b>, <b>121</b>, <b>131</b>, or <b>141</b>, receives two vector operands and can perform one or more vector operations. For example, a vector unit can compute the dot product of the two input operands and output the result as one element of an output vector to output vector unit <b>151</b>. In some embodiments, the vector unit result is accumulated and used as an operand to a subsequent operation performed by the vector unit. In some embodiments, each vector unit of matrix processor unit <b>107</b>, such as vector units <b>111</b>, <b>121</b>, <b>131</b>, or <b>141</b>, includes both a multiply unit and an adder unit (not shown). In some embodiments, each vector unit of matrix processor unit <b>107</b> may include a vector accumulator (not shown), for example, for storing partial results between vector operations.</p><p id="p-0027" num="0026">In some embodiments, matrix processor unit <b>107</b> is configured to receive input data corresponding to more than two input matrices in parallel. By processing multiple pairs of matrices in parallel, the throughput and efficiency of processing element <b>101</b> and matrix processor unit <b>107</b> is significantly increased. If matrix processor unit <b>107</b> is utilized to process only a single pair of input matrices, for example, a pair of input matrices corresponding to a single depthwise convolution operation, as the input matrix sizes decrease, some vector units will remain unutilized. For example, for a matrix processor unit configured with 32 vector units, only half of the vector units (i.e., 16 vector units) are needed to process a data matrix with 18 rows. Instead, multiple convolution operations, such as multiple depthwise convolution operations, are processed in parallel. In some embodiments, the vector units of matrix processor unit <b>107</b> such as vector units <b>111</b>, <b>121</b>, <b>131</b>, and <b>141</b> are allocated to different convolution operations. Each data input matrix of the different convolution operations is loaded as data input vectors into the corresponding vector units allocated for the particular convolution operation via data input vector unit <b>103</b>. The corresponding weight input matrix for the particular convolution operation is broadcasted as a weight input vector to the same corresponding vector units via weight input vector unit <b>105</b>. For example, 16 vector units of a 32 vector unit matrix processor unit can be allocated to a first convolution operation and the remaining 16 vector units of the matrix processor unit can be allocated to a second convolution operation. Each group of vector units receives data input vectors corresponding to the assigned convolution operation. Similarly, a corresponding weight input vector is broadcasted to each group of vector units based on the assigned convolution operation. In some embodiments, the different weight matrices, for example, corresponding to different convolution operations, are loaded into processing element <b>101</b> by weight input vector unit <b>105</b> via a combined weight vector (not shown). Weight input vector unit <b>105</b> reads the combined weight vector from memory <b>161</b> and expands the combined weight vector into multiple weight input vectors that are broadcasted to different groups of vector units of matrix processor unit <b>107</b>.</p><p id="p-0028" num="0027">Using the disclosed techniques, system <b>100</b> and in particular matrix processor unit <b>107</b> can be utilized to efficiently perform depthwise convolution operations for solving artificial intelligence problems using a neural network. In particular, system <b>100</b> can efficiently solve multiple depthwise convolution operations in parallel as the sizes of the data matrices decrease. Two-dimensional matrix operands may be unrolled and formatted into input vectors via data input vector unit <b>103</b> and/or weight input vector unit <b>105</b>. And in some embodiments, multiple weight matrices can be read from memory <b>161</b> using a single read of a combined weight vector. Once unrolled, the input vectors can be used to implement depthwise convolution using the vector units, such as vector units <b>111</b>, <b>121</b>, <b>131</b>, or <b>141</b>, of a matrix processor unit <b>107</b>. In some embodiments, an input vector unit, such as weight input vector unit <b>105</b>, includes logic for efficiently shifting elements within the input vector. For example, the elements can be shifted to the right by one position. In various embodiments, the shifting logic/circuit may be configured to shift the elements right (or left) and by different numbers of positions. In some embodiments, the elements loop around when shifted past the start or end of the input vector and/or may be replaced with a default value such as a zero padding element. Weight input vector unit <b>105</b> may also include logic to expand a combined weight vector into multiple weight input vectors that can be directed to different vector units of matrix processor unit <b>107</b>. Weight input vector unit <b>105</b> may include logic to format each weight input vector by inserting zero elements between rows to effectively create a weight input mask. In some embodiments, an input vector unit, such as data input vector unit <b>103</b>, includes logic for efficiently retrieving data elements from memory <b>161</b> and formatting the elements in a linearized order for matrix processor unit <b>107</b>. For example, data input vector unit <b>103</b> can include logic for efficiently formatting a matrix (or matrix slice) of data elements using a pattern associated with transposing the matrix (or matrix slice). Once the formatting pattern is applied, the elements can be linearized into a data input vector and passed as an operand to a vector unit of matrix processor unit <b>107</b>.</p><p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. <b>2</b>A</figref> is a block diagram illustrating an embodiment of a processor system for solving artificial intelligence problems using a neural network. In the example shown, processing element <b>200</b> includes matrix processor unit <b>201</b>, data input vector unit <b>203</b>, weight input vector unit <b>205</b>, and output vector unit <b>231</b>. Matrix processor unit <b>201</b> includes multiple vector units including at least vector units <b>213</b>, <b>215</b>, <b>223</b>, and <b>225</b>. The vector units of matrix processor unit <b>201</b> are allocated to two different vector unit groups <b>211</b> and <b>221</b>. Vector unit group <b>211</b> includes vector units <b>213</b> and <b>215</b> and vector unit group <b>221</b> includes vector units <b>223</b> and <b>225</b>. The three dots between vector units <b>213</b> and <b>215</b> and between vector units <b>223</b> and <b>225</b> indicate optional additional vector units (not shown) included in each group. In some embodiments, vector unit groups <b>211</b> and <b>221</b> are logical groups as indicated by the dotted rectangles. The number and the particular vector units assigned to each vector unit group can change, for example, depending on the processor workload. For example, a 32 vector unit matrix processor unit may allocate 16 vector units to one vector unit group and the remaining 16 vector units to a second vector unit group. Based on a different workload, 14 vector units may be allocated to one vector unit group, 14 vector units to a second vector unit group, and the remaining 4 vector units may be unutilized and unallocated to any vector unit group. Although the vector units in <figref idref="DRAWINGS">FIG. <b>2</b>A</figref> are allocated among two different groups, the number of vector unit groups can exceed two. In various embodiments, each vector unit group corresponds to a convolution operation. For example, vector unit group <b>211</b> corresponds to a first convolution operation and vector unit group <b>221</b> corresponds to a second convolution operation.</p><p id="p-0030" num="0029">In some embodiments, matrix processor unit <b>201</b> is configured to receive two input matrices, each matrix a two-dimensional matrix via data input vector unit <b>203</b> and weight input vector unit <b>205</b>, respectively, and output a matrix result to output vector unit <b>231</b>. Matrix processor unit <b>201</b> is also configured to receive multiple pairs of input matrices, for example, each pair of matrices corresponding to a different matrix or convolution operation, and output the matrix result (or partial result) of each operation to output vector unit <b>231</b>. In the example shown, matrix processor unit <b>201</b>, data input vector unit <b>203</b>, and weight input vector unit <b>205</b> are configured to receive up to two pairs of input matrices. Data input vector unit <b>203</b> directs data input vectors processed for different convolution operations to the corresponding vector units of vector unit group <b>211</b> or <b>221</b>. Weight input vector unit <b>205</b> processes a combined weight vector to create a weight input vector for each convolution operation. The created weight input vectors are stored in weight input vector registers <b>207</b> and <b>209</b>. A first weight input vector is stored in weight input vector register <b>207</b> and a second weight input vector is stored in weight input vector register <b>209</b>. The weight input vector of weight input vector register <b>207</b> is broadcasted to the vector units of vector unit group <b>211</b>, including vector units <b>213</b> and <b>215</b>. Similarly, the weight input vector of weight input vector register <b>209</b> is broadcasted to the vector units of vector unit group <b>221</b>, including vector units <b>223</b> and <b>225</b>. The same vector units receive corresponding data input vectors from data input vector unit <b>203</b>. In various embodiments, the result or partial result of vector unit group <b>211</b> or vector unit group <b>221</b> can be outputted independently to output vector unit <b>231</b>. In some embodiments, output vector unit <b>231</b> may include multiple output buffers or registers to receive multiple output results.</p><p id="p-0031" num="0030">In the example shown, the solid arrows of <figref idref="DRAWINGS">FIG. <b>2</b>A</figref> indicate logical connectivity. For example, the connection between weight input vector register <b>207</b> to vector unit group <b>211</b> and between weight input vector register <b>209</b> to vector unit group <b>221</b> may be implemented using a shared bus and logic. Similarly, the connection between data input vector unit <b>203</b> to vector unit group <b>211</b> and between data input vector unit <b>203</b> to vector unit group <b>221</b> may be implemented using a shared bus and logic. Although processing element <b>200</b> is configured for processing two matrix pairs in parallel, a processing element can be configured to process additional matrix pairs as appropriate. For example, in some embodiments, a processing element is configured for processing three or more matrix pairs in parallel. A weight input vector unit generates corresponding weight input vectors for each matrix pair and a data input vector unit generates the corresponding data input vectors. The vector units are allocated into vector unit groups based on the number of simultaneous matrix operations and matrix pairs. The corresponding input vectors of each matrix pair are directed to the assigned vector units.</p><p id="p-0032" num="0031">In some embodiments, processing element <b>200</b> is processing element <b>101</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref> and matrix processor unit <b>201</b>, data input vector unit <b>203</b>, weight input vector unit <b>205</b>, and output vector unit <b>231</b> are matrix processor unit <b>107</b>, data input vector unit <b>103</b>, weight input vector unit <b>105</b>, and output vector unit <b>151</b>, respectively, of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. In some embodiments, vector units <b>213</b>, <b>215</b>, <b>223</b>, and <b>225</b> are each one of vector units <b>111</b>, <b>121</b>, <b>131</b>, or <b>141</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. In some embodiments, processing elements, such as processing element <b>200</b>, and multiple matrix processor units, such as matrix processor unit <b>201</b>, may be utilized in parallel for increased performance. For example, one processing element and its matrix processor unit can be used to process one slice of a large matrix and another processing element and its matrix processor unit can be used to process a separate slice of the same matrix.</p><p id="p-0033" num="0032">In some embodiments, data input vector unit <b>203</b> is used to load a vector operand into matrix processor unit <b>201</b>. For example, data corresponding to at least a portion of a two-dimensional matrix can be read from memory and processed by data input vector unit <b>203</b> before being loaded into matrix processor unit <b>201</b>. In various embodiments, the data input vector operand generated by data input vector unit <b>203</b> may be directed to any one of the vector units of matrix processor unit <b>201</b>, such as vector unit <b>213</b>, <b>215</b>, <b>223</b>, or <b>225</b>. For example, in some embodiments, matrix processor unit <b>201</b> includes 32 vector units. Over 32 cycles, 32 vector operands can be loaded into matrix processor unit <b>201</b> via data input vector unit <b>203</b>. For each cycle, one data input vector operand is generated by data input vector unit <b>203</b> and then loaded into one of the 32 vector units. After 32 cycles, all 32 vector units have received a data input vector operand. In some embodiments, multiple data input vectors can be generated and loaded each cycle. For example, four data input vectors can be generated in parallel to load 32 vector units in 8 cycles. In some embodiments, the data input vectors that are loaded may be sourced from different data matrices corresponding to different convolution operations. For example, data input vectors for a first convolution operation may be read from a first data input matrix and directed to vector units of vector unit group <b>211</b>. Data input vectors for a second convolution operation may be read from a second data input matrix and directed to vector units of vector unit group <b>221</b>.</p><p id="p-0034" num="0033">Similarly, weight input vector unit <b>205</b> is used to load a second vector operand for each applicable vector unit of matrix processor unit <b>201</b>. For example, weight data corresponding to at least a portion of a two-dimensional weight matrix can be read from memory and processed by weight input vector unit <b>205</b> before being loaded into matrix processor unit <b>201</b>. In various embodiments, the weight input vector operand generated by weight input vector unit <b>205</b> may be directed to any one, a group, or all of the vector units of matrix processor unit <b>201</b>, such as vector unit <b>213</b>, <b>215</b>, <b>223</b>, or <b>225</b> or vector unit groups <b>211</b> or <b>221</b>. For example, the same weight input vector operand can be broadcasted to all vector units of matrix processor unit <b>201</b>. This allows the same weight data to be applied to each data input vector operand. Similarly, the same weight input vector operand can be broadcasted to all vector units of a vector unit group. This allows the same weight data to be applied to each data input vector operand corresponding to the matrix operation assigned to the group.</p><p id="p-0035" num="0034">In some embodiments, multiple weight input vectors are generated from a combined weight vector. For example, a pair of two-dimensional weight matrices are stored in a single vector and can be read from memory in a single memory read. Weight input vector unit <b>205</b> extracts the weights for each weight matrix from the combined weight vector and creates two weight input vectors, one corresponding to each weight matrix. The weight input vectors may be stored independently in different weight input vector registers <b>207</b> and <b>209</b> before being broadcasted to their respective vector unit groups. For example, a first vector unit group <b>211</b> is assigned to a first convolution operation and a second vector unit group <b>221</b> is assigned to a second convolution operation. Each weight input vector is broadcasted to the vector units of the appropriate vector unit group. This allows two convolution operations to be solved in parallel and significantly increases the utilization of the vector units when the matrix sizes are reduced. In various embodiments, three or more convolution operations corresponding to three or more weight matrices may be processed in parallel. For example, a combined vector unit may include three linearized weight matrices. In some embodiments, multiple reads may be required to load multiple weight matrices. In some embodiments, data input vector unit <b>203</b> can be used to similarly broadcast a vector operand to multiple vector units.</p><p id="p-0036" num="0035">In some embodiments, the number of cycles required to load a vector operand from memory via data input vector unit <b>203</b> and/or weight input vector unit <b>205</b> into matrix processor unit <b>201</b> is based on the utilization of the matrix processor unit. For example, to keep the matrix processor near full utilization, data arguments for the vector units are retrieved from memory and prepared over a time period (e.g., a certain number of cycles) that closely matches the compute utilization of the vector units. By matching the load and compute times, the matrix processor can be kept near full utilization. In some embodiments, data read times are reduced, for example, by increasing the bus speed, to better match the load and compute times. For example, in various embodiments, matrix processor unit <b>201</b> may take approximately eight clock cycles to complete a certain set of computations. (An example of a set of computations might include applying eight different weight input vectors to a set of data input vectors.) A read rate of one vector operand per cycle would require at least 32 cycles to load all vector units. Increasing the read rate by a factor of four allows all 32 vector operands to be loaded in approximately 8 cycles, matching the processing compute time of the matrix processor unit. In various embodiments, by matching the data read speed, for example, the data bus speed used to load vector operands, with matrix processor unit compute performance and workload, the overall efficiency and throughput of the matrix processor unit is significantly increased. In some embodiments, the data read speed is at least in part increased using the techniques disclosed herein. For example, multiple data input vectors may be generated in parallel to multiply to overall effective data read speed. In some embodiments, data input vector unit <b>203</b> may process multiple data input vectors in parallel to reduce the number of cycles required to load a corresponding data input vector to all of the vector units of matrix processor unit <b>201</b>. Similarly, weight input vector unit <b>205</b> may process multiple weight input vectors in parallel to reduce the number of cycles required to load a corresponding weight input vector to a group of vector units of matrix processor unit <b>201</b>.</p><p id="p-0037" num="0036">In some embodiments, data input vector unit <b>203</b> and/or weight input vector unit <b>205</b> includes shifting hardware (not shown) to shift the elements of the vector operands. For example, weight input vector unit <b>205</b> can be loaded with one or more vector operands that are used for a first iteration. During a second iteration, the vector operands can be shifted by one or more positions (to the right or left) as appropriate. The newly shifted vector operands can be used for matrix computations. Once the matrix computations are completed, the vector operands can be shifted again and the newly shifted vector operands can be used for the next iteration. In this manner, the new vector operands (determined by shifting the contents of the input vector) are applied during each iteration and may be stored or shifted in place in a weight input vector register such as weight input vector registers <b>207</b> and <b>209</b>. For example, in some embodiments, the shifting logic is utilized on an unrolled matrix operand, such as an unrolled weight matrix, to align the unrolled matrix operand with appropriate elements from a second matrix operand, such as an unrolled data matrix.</p><p id="p-0038" num="0037">In some embodiments, matrix processor unit <b>201</b> includes multiple vector units that each include a vector multiply and vector adder unit. Each vector multiply unit is configured to multiply corresponding elements received via data input vector unit <b>203</b> and weight input vector unit <b>205</b>. In some embodiments, the result is a vector of multiplication results. For example, for two 32-byte input vectors, the result of a vector multiply unit is a vector of 32 multiplication results. For each vector unit, the first element of a data input vector from data input vector unit <b>203</b> is multiplied with the first element of a weight input vector from weight input vector unit <b>205</b>. Similarly, the second element of a data input vector is multiplied with the second element of a weight input vector. In various embodiments, corresponding elements from a data input vector generated by data input vector unit <b>203</b> and a weight input vector generated by weight input vector unit <b>205</b> are multiplied in parallel. In various embodiments, the vector of multiplication results is passed to a vector adder unit of the vector unit.</p><p id="p-0039" num="0038">In some embodiments, each vector adder unit is configured to compute the sum of the elements from an input vector. For example, the sum of each of the elements from a vector of multiplication results computed by a vector multiply unit is computed by a vector adder unit. In some embodiments, the result of a vector adder unit is a dot product of the vectors used as input to the corresponding vector multiply unit. In various embodiments, each vector adder unit is implemented as an adder tree. For example, the top level of an adder tree may add pairs of elements to determine a set of partial sums, such as adding elements 0 and 1 to determine a first partial sum and elements 2 and 3 to determine a second partial sum, etc. Each subsequent level may sum pairs of partial sums from the previous level until the last level computes a final result sum. In various embodiments, each adder tree computes partial sums in parallel to arrive at a result sum. The parallel operation significantly improves the efficiency of summing a vector of numbers. In various embodiments, multiple vector units can operate in parallel to compute multiple dot products in parallel, significantly improving the throughput of matrix and convolution operations.</p><p id="p-0040" num="0039">In some embodiments, matrix processor unit <b>201</b> includes one or more accumulators, for example, to accumulate the results of each vector unit. In some embodiments, an accumulator is included as part of a vector unit or as part of matrix processor unit <b>201</b> as appropriate. The accumulator(s) can be used to sum the results computed across multiple iterations of the vector units. For example, the final result sum of one iteration of a vector unit can be stored in an accumulator and added to the final result sum of the next iteration of the vector unit. In some embodiments, the accumulator is a vector accumulator. For example, the accumulator may be sized based on the size of the output vector received by output vector unit <b>231</b>. In various embodiments, once matrix processing is complete, the accumulator results may be pushed to output vector unit <b>231</b>. In some embodiments, an accumulator exists for each vector unit group.</p><p id="p-0041" num="0040"><figref idref="DRAWINGS">FIG. <b>2</b>B</figref> is a block diagram illustrating an embodiment of a matrix processor unit for solving artificial intelligence problems using a neural network. In the example shown, matrix processor unit <b>251</b> includes multiple vector unit groups including vector unit groups <b>253</b> and <b>255</b>. Each vector unit group includes multiple vector units. The vector units <b>263</b>, <b>265</b>, <b>283</b>, and <b>285</b> of matrix processor unit <b>251</b> are allocated to two different vector unit groups <b>253</b> and <b>255</b>. Vector unit group <b>253</b> includes vector units <b>263</b> and <b>265</b>. Vector unit group <b>255</b> includes vector units <b>283</b> and <b>285</b>. The three dots between vector units <b>263</b> and <b>265</b> and between vector units <b>283</b> and <b>285</b> indicate optional additional vector units (not shown) included in each group. In some embodiments, vector unit groups <b>253</b> and <b>255</b> are logical groups as indicated by the dotted rectangles. The number and the particular vector units assigned to each vector unit group can change, for example, depending on the processor workload. In various embodiments, a matrix processor unit may include more or fewer vector units. For example, a matrix processor unit may include 32 vector units, each capable of processing two 32-element vectors. In some embodiments, each vector unit includes a vector multiply unit and a vector adder unit. In the example shown, vector unit <b>263</b> includes vector multiply unit <b>271</b> and vector adder unit <b>273</b>. Similarly, vector unit <b>265</b> includes vector multiply unit <b>275</b> and vector adder unit <b>277</b>, vector unit <b>283</b> includes vector multiply unit <b>291</b> and vector adder unit <b>293</b>, and vector unit <b>285</b> includes vector multiply unit <b>295</b> and vector adder unit <b>297</b>. In various embodiments, matrix processor unit <b>251</b> is matrix processor unit <b>201</b> of <figref idref="DRAWINGS">FIG. <b>2</b>A</figref>, vector unit groups <b>253</b> and <b>255</b> are vector unit groups <b>211</b> and <b>221</b> of <figref idref="DRAWINGS">FIG. <b>2</b>A</figref>, respectively, and vector units <b>263</b>, <b>265</b>, <b>283</b>, and <b>285</b> are vector units <b>213</b>, <b>215</b>, <b>223</b>, and <b>225</b> of <figref idref="DRAWINGS">FIG. <b>2</b>A</figref>, respectively.</p><p id="p-0042" num="0041">In some embodiments, each vector unit of matrix processor unit <b>251</b>, such as vector units <b>263</b>, <b>265</b>, <b>283</b>, and <b>285</b>, receives two vector operands and can perform one or more vector operations. For example, a vector unit can compute the result of multiple multiply operations by multiplying each element of the first input vector with a corresponding element of a second input vector. The resulting multiplication results can be accumulated and used for future operations, such as summing partial results. For example, a vector unit result can be accumulated and used as an operand to a subsequent operation performed by the vector unit. In various embodiments, the vector units of each vector unit group receive vector operands associated with the same matrix operation, such as a depthwise convolution operation. For example, vector units of vector unit group <b>253</b>, such as vector units <b>263</b> and <b>265</b>, receive vector operands associated with a first convolution operation and vector units of vector unit group <b>255</b>, such as vector units <b>283</b> and <b>285</b>, receive vector operands associated with a second convolution operation. The vector units of each group may be configured to receive the same weight input vector (e.g., via a broadcast) but may receive different data input vectors corresponding to different elements of the same data matrix associated with the group. This allows the same weight matrix to be applied to different portions of the same data matrix while also processing multiple weight and data matrices.</p><p id="p-0043" num="0042">In the example shown, matrix processor unit <b>251</b> includes multiple vector units that each include a vector multiply and a vector adder unit. Each vector multiply unit, such as vector multiply units <b>271</b>, <b>275</b>, <b>291</b>, or <b>295</b>, is configured to multiply corresponding elements received via a data input vector unit (not shown) and a weight input vector unit (not shown). In some embodiments, the result is a vector of multiplication results. For example, for two 32-byte input vectors, the result of a vector multiply unit is a vector of 32 multiplication results. The first element from a data input vector is multiplied with the first element of a weight input vector. Similarly, the second element from a data input vector is multiplied with the second element of a weight input vector. In various embodiments, corresponding elements from a data input vector and a weight input vector are multiplied in parallel. In various embodiments, the vector of multiplication results is passed to a vector adder unit of the vector unit. For example, vector multiply unit <b>271</b> passes its multiplication results to vector adder unit <b>273</b>, vector multiply unit <b>275</b> passes its multiplication results to vector adder unit <b>277</b>, vector multiply unit <b>291</b> passes its multiplication results to vector adder unit <b>293</b>, and vector multiply unit <b>295</b> passes its multiplication results to vector adder unit <b>297</b>.</p><p id="p-0044" num="0043">In some embodiments, each vector adder unit of a vector unit, such as vector adder unit <b>273</b>, <b>277</b>, <b>293</b>, or <b>297</b>, is configured to compute addition operations using elements from an input vector. For example, the sum of selected elements from a vector of multiplication results computed by vector multiply unit <b>271</b> is computed by vector adder unit <b>273</b>. Similarly, the sum of each of the elements from a vector of multiplication results computed by vector multiply unit <b>275</b> is computed by vector adder unit <b>277</b>, the sum of each of the elements from a vector of multiplication results computed by vector multiply unit <b>291</b> is computed by vector adder unit <b>293</b>, and the sum of each of the elements from a vector of multiplication results computed by vector multiply unit <b>295</b> is computed by vector adder unit <b>297</b>. In some embodiments, the result of a vector adder unit is a dot product of the vectors used as input to the corresponding vector multiply unit. In various embodiments, each vector adder unit, such as vector adder unit <b>273</b>, <b>277</b>, <b>293</b>, or <b>297</b>, is implemented as an adder tree. For example, the top level of an adder tree may add pairs of elements to determine a set of partial sums, such as adding elements 0 and 1 to determine a first partial sum and elements 2 and 3 to determine a second partial sum, etc. Each subsequent level may sum pairs of partial sums from the previous level until the last level computes a final result sum. In some embodiments, any partial sums may be outputted as a result of the adder unit. In various embodiments, each adder tree computes partial sums in parallel to arrive at a result sum. The parallel operation significantly improves the efficiency of summing a vector of numbers. In various embodiments, multiple vector units can operate in parallel to compute multiple results in parallel, significantly improving the throughput of matrix processor unit <b>251</b>.</p><p id="p-0045" num="0044">In some embodiments, matrix processor unit <b>251</b> includes one or more accumulators (not shown), for example, to accumulate the results of each vector unit. In some embodiments, an accumulator is included as part of a vector unit or as part of matrix processor unit <b>251</b> as appropriate. The accumulator(s) can be used to sum the results computed across multiple iterations of the vector units. For example, the result from one iteration of a vector unit can be stored in an accumulator and added to the result of the next iteration of the vector unit. In some embodiments, the accumulator is a vector accumulator. For example, the accumulator may be sized based on the size of an output vector of matrix processor unit <b>251</b>. In various embodiments, once matrix processing is complete, the accumulator results may be pushed to memory. In some embodiments, matrix processor unit <b>251</b> may be configured with multiple vector accumulators to accumulate an output result associated with each vector unit group.</p><p id="p-0046" num="0045"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a flow chart illustrating an embodiment of a process for performing multiple two-dimensional convolution operations in parallel using a matrix processor unit. For example, an artificial intelligence problem is solved using a neural network in part by analyzing one or more layers of a neural network by solving one or more two-dimensional convolution operations. The appropriate two-dimensional convolution operations may be initiated by issuing one or more two-dimensional convolution operation instructions to one or more matrix processor units. Each instruction may indicate two or more pairs of operand matrices, for example, by specifying the location of each matrix operand in memory, in a register, or in another appropriate location. In some embodiments, the instruction corresponds to multiple depthwise convolution operations using a data (or activation) matrix and a weight matrix for each depthwise convolution. In some embodiments, the convolution operations are performed using processing element <b>101</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref> and/or processing element <b>200</b> of <figref idref="DRAWINGS">FIG. <b>2</b>A</figref> and in particular using a matrix processor such as matrix processor unit <b>107</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, matrix processor unit <b>201</b> of <figref idref="DRAWINGS">FIG. <b>2</b>A</figref>, and/or matrix processor unit <b>251</b> of <figref idref="DRAWINGS">FIG. <b>2</b>B</figref>.</p><p id="p-0047" num="0046">At <b>301</b>, an instruction describing two-dimensional convolution operations is received. For example, an instruction is received by a processor element such as a processor element that includes a matrix processor unit, input vector registers, and/or an output vector register, among other components. In various embodiments, the processor element may include additional or fewer components in addition to the matrix processor unit. The received two-dimensional convolution operations instruction directs the processor element to perform multiple two-dimensional convolution operations and can specify two matrix operands for each convolution operation. For example, a first pair of matrices may be a two-dimensional data matrix and a two-dimensional weight matrix for a first convolution operation and a second pair of matrices may be a different two-dimensional data matrix and a different two-dimensional weight matrix for a second convolution operation. In some embodiments, multiple weight matrices are referenced as a single operand. For example, two or more matrices can be referenced as a combined weight vector stored in memory. In some embodiments, the matrix operands may be too large for loading into the matrix processor unit without first splitting one or more of the matrix operands into smaller matrix slices. In some embodiments, the different convolution operations are specified using multiple instructions but are solved in parallel.</p><p id="p-0048" num="0047">At <b>303</b>, vector units are assigned to each convolution operation. For example, a first group of vector units is assigned to a first convolution operation and a second group of vector units is assigned to a second convolution operation. In some embodiments, the number of vector units to assign for a specific convolution operation is determined by one or more instructions received at <b>301</b>. For example, the instruction may specify the number of vector units to assign to a convolution operation and/or one or more dimensions of a matrix argument. The size of the matrix operands may further dictate the number of vector units to assign. For example, in some embodiments, the number of vector units required for a matrix with N rows is N+2 vector units when three rows of a matrix are unrolled into a single input vector. By unrolling three rows into a single input vector, a data matrix with 18 rows can utilize at most 16 vector units.</p><p id="p-0049" num="0048">At <b>305</b>, two-dimensional data input operands are prepared. For example, a two-dimensional data matrix is prepared as an operand for each convolution operation. In some embodiments, data corresponding to each two-dimensional data input operand is retrieved from memory or another location. The retrieved data may be certain rows and/or columns of a data input operand. For example, different slices of a data input operand may be prepared separately and/or may be prepared in parallel by different processing elements. In various embodiments, the preparation may include unrolling portions of the two-dimensional data input operand. For example, the specified portions of a data input matrix may be linearized into a vector. In some embodiments, only a portion of the matrix or matrix slice is linearized, for example, only a subset of the rows. In unrolling and linearizing the selected portions of a data matrix, the rows may be separated by padding elements, such as zero elements, to at least in part align the selected matrix elements with corresponding elements from a weight input operand. In various embodiments, each prepared data input operand is loaded into a vector unit of a matrix processor unit. Depending on the input operand, additional portions of the corresponding matrix are unrolled, linearized, and loaded into the matrix processor unit. For example, a vector corresponding to a different (and possibly overlapping) portion of a two-dimensional data input operand is unrolled, linearized, and loaded into a different vector unit of the matrix processor unit. In some embodiments, the prepared data input operands are loaded using a data input vector unit such as data input vector unit <b>103</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref> and/or data input vector unit <b>203</b> of <figref idref="DRAWINGS">FIG. <b>2</b>A</figref>.</p><p id="p-0050" num="0049">At <b>307</b>, two-dimensional weight input operands are prepared. For example, a two-dimensional weight matrix is prepared as a second operand for each convolution operation. In some embodiments, data corresponding to each two-dimensional weight input operand is retrieved from memory or another location. In some embodiments, the data for multiple weight input operands is retrieved together as a combined weight vector. The retrieved weight data may be certain rows and/or columns of the weight input operand. For example, different slices of the weight input operand may be prepared separately and/or may be prepared in parallel by different processing elements. In various embodiments, the preparation may include unrolling portions of a two-dimensional weight input operand. For example, the specified portions of a weight input matrix may be linearized into a vector. In some embodiments, only a portion of the matrix or matrix slice is linearized, for example, only a subset of the rows. In unrolling and linearizing the selected portions of a matrix, the rows may be separated by padding elements, such as zero elements, to at least in part align the selected matrix elements with corresponding elements from a data input operand. The number of padding elements may vary at least in part based on data sizes supported by the matrix processor unit and the dimensions of the weight input matrix. In various embodiments, the prepared weight input operand is loaded into a vector unit of a matrix processor unit. In some embodiments, the prepared weight input operand is broadcasted and loaded into more than one vector unit of the matrix processor unit. For example, the same weight input operand can be broadcasted to every vector unit of the matrix processor unit or every vector unit of a vector unit group of the matrix processor unit assigned to the associated convolution operation. In some embodiments, the prepared weight input operand is loaded using a weight input vector unit such as weight input vector unit <b>105</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref> and/or weight input vector unit <b>205</b> of <figref idref="DRAWINGS">FIG. <b>2</b>A</figref>. In some embodiments, a weight input vector unit extracts the elements of each weight matrix from a combined weight vector to prepare each weight input operand for each convolution operation specified at <b>301</b>.</p><p id="p-0051" num="0050">At <b>309</b>, two-dimensional convolution operations are performed. Using the data input operands and the weight input operands prepared at <b>305</b> and <b>307</b>, respectively, two-dimensional convolution operations are performed by a matrix processor unit. The convolution operations may include computing partial and/or intermediate results that are accumulated across different iterations. In various embodiments, the matrix processor unit provides a vector of output results as an output vector. In some embodiments, each vector unit group computes the results or partial results of a corresponding convolution operation in parallel with other vector unit groups. In some embodiments, the output vectors are received by an output vector unit such as output vector unit <b>151</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref> and/or output vector unit <b>231</b> of <figref idref="DRAWINGS">FIG. <b>2</b>A</figref>. In some embodiments, a complete two-dimensional convolution operation may involve shifting the elements of the weight input operand to at least in part compute the depthwise convolution of the weight input matrix with different portions of the data input matrix.</p><p id="p-0052" num="0051"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a flow chart illustrating an embodiment of a process for performing a two-dimensional convolution operation using a matrix processor unit. For example, the result of a two-dimensional convolution operation is computed by performing multiple vector operations on two-dimensional slices of matrix arguments. One or more input arguments, such as a data input matrix, may exceed the maximum operand size of a matrix processor unit. As a result, an input operand may be sliced into smaller matrices compatible with the operand size of a matrix processor unit. The compatible-sized slices can be passed as operands to one or more different matrix processor units and the results combined. In some embodiments, the slices are operated on different matrix processor units, for example, matrix processor units corresponding to different processor elements. In some scenarios, the input arguments for a two-dimensional convolution operation are small enough that solving the convolution operation does not fully utilize a matrix processor unit. As a result, the matrix processor unit can allocate processing among different convolution operations. For example, vector units of a matrix processor unit can be assigned to different vector unit groups and each group can process a different convolution operation allowing multiple convolution operations to be solved in parallel.</p><p id="p-0053" num="0052">In various embodiments, the process of <figref idref="DRAWINGS">FIG. <b>4</b></figref> may be performed in response to a convolution operations instruction such as the convolution operations instruction received at <b>301</b> of <figref idref="DRAWINGS">FIG. <b>3</b></figref>. In some embodiments, the process of <figref idref="DRAWINGS">FIG. <b>4</b></figref> is performed at <b>305</b>, <b>307</b>, and/or <b>309</b> of <figref idref="DRAWINGS">FIG. <b>3</b></figref> utilizing the vector units assigned to the convolution operation at <b>303</b> of <figref idref="DRAWINGS">FIG. <b>3</b></figref>. In some embodiments, the process of <figref idref="DRAWINGS">FIG. <b>4</b></figref> is performed using matrix processor unit <b>107</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref> and/or matrix processor unit <b>201</b> of <figref idref="DRAWINGS">FIG. <b>2</b>A</figref>.</p><p id="p-0054" num="0053">At <b>401</b>, the next two-dimensional slice of a matrix operand is identified. For example, one or more matrix operands with sizes compatible with the operand size of a matrix processor unit are identified. The slices may be identified in memory and a read request may be issued to load the identified data. In some embodiments, it may be common for the size of the data input matrix to be extremely large compared to the size of the weight input matrix. The data input matrix is sliced into smaller sizes for processing. In some embodiments, the data input matrix is sliced into slices based on the number of vector units allocated to the convolution operation. At <b>401</b>, the next slice is identified for processing.</p><p id="p-0055" num="0054">At <b>403</b>, the input arguments are unrolled and vector operations are performed. For example, a slice of a data input matrix and a weight input matrix are unrolled. In various embodiments, the unrolling linearizes a two-dimensional matrix (or matrix slice) into a vector operand that is loaded into at least one vector unit of a matrix processor unit. The unrolling may require more than one iteration. For example, in some embodiments, the unrolled matrix operand is unrolled over several iterations such that only a subset of rows is unrolled for each iteration. For example, for larger weight matrices, the weight matrix cannot be unrolled to fit in its entirety in a vector unit. Multiple iterations are utilized until the entire matrix is unrolled. In various embodiments, the weight matrix may be unrolled into a vector operand and broadcasted to more than one vector unit of the matrix processor unit. In some embodiments, each iteration may further include shifting the unrolled weight matrix to apply the elements of the weight matrix to different columns of the unrolled data matrix. In various embodiments, intermediate results may be accumulated and used as arguments for subsequent iterations. The vector operations performed can include a vector multiply and a vector add. For example, a dot product operation can be performed on vector data and weight arguments by each vector unit of a matrix processor unit to compute at least a portion of a depthwise convolution result.</p><p id="p-0056" num="0055">At <b>405</b>, the vector unit results are outputted. For example, each vector unit outputs a vector unit result to an element of an output vector. In various embodiments, the output vector may be stored in a vector output unit such as output vector unit <b>151</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. In various embodiments, the vector unit results may be determined by accumulating multiple vector unit results over multiple iterations. In various embodiments, the vector unit results are outputted to an output vector unit for writing the results back to memory. In some embodiments, the vector unit results are portions of a depthwise convolution result.</p><p id="p-0057" num="0056">At <b>407</b>, a determination is made whether additional two-dimensional slices require processing. In the event additional two-dimensional slices remain to be processed, processing loops back to <b>401</b> to process the next slice. In the event no additional two-dimensional slices remain to be processed, processing ends.</p><p id="p-0058" num="0057"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a flow chart illustrating an embodiment of a process for performing a two-dimensional convolution operation using a matrix processor unit and vector unit operations. For example, using the process of <figref idref="DRAWINGS">FIG. <b>5</b></figref>, input matrices are unrolled, linearized, and fed as input vectors to vector units of a matrix processor unit. Vector unit operations are performed to compute at least a partial result for the two-dimensional convolution operation. In various embodiments, a data input matrix and a weight input matrix are converted to input vectors. For example, a data slice may be identified from a data input matrix and converted to one or more data input vectors. In some embodiments, the process of <figref idref="DRAWINGS">FIG. <b>5</b></figref> is performed at <b>403</b> and/or <b>405</b> of <figref idref="DRAWINGS">FIG. <b>4</b></figref>. In some embodiments, the process of <figref idref="DRAWINGS">FIG. <b>5</b></figref> is performed using matrix processor unit <b>107</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref> and/or matrix processor unit <b>201</b> of <figref idref="DRAWINGS">FIG. <b>2</b>A</figref>.</p><p id="p-0059" num="0058">At <b>501</b>, data input vectors are identified. For example, one or more data input vectors are identified from a slice of a data input matrix. In some embodiments, a data input vector is identified and prepared for each vector unit of a matrix processor unit assigned to the convolution operation. The data input vectors may include overlapping elements and correspond to selected elements used for performing a matrix operation, such as a two-dimensional convolution operation.</p><p id="p-0060" num="0059">At <b>503</b>, data input vectors are prepared and loaded to vector units. For example, elements corresponding to a subset of a data matrix are identified. In some embodiments, the data matrix may be a two-dimensional matrix slice of a larger data matrix. In various embodiments, the identified elements are a subset of the data matrix and selected based on a corresponding weight matrix and in particular the dimensions of the weight matrix and the number of rows that will be unrolled. For example, in some embodiments, an entire weight matrix can be unrolled and linearized to fit into a vector unit operand. However, as the dimensions of the weight matrix increase relative to the size of operands supported by the vector unit, the weight matrix may be too large to be unrolled into a single input vector and instead the weight matrix and corresponding data matrix are unrolled across multiple iterations.</p><p id="p-0061" num="0060">In various embodiments, a weight matrix is either fully unrolled in one iteration or can be partially unrolled across multiple iterations. Whether a matrix is fully or partially unrolled can depend on the dimensions of the matrix arguments, in particular the weight matrix, relative to the size of the supported input vectors for the matrix processor unit. For example, in a scenario with a 3&#xd7;3 weight matrix and support for a 32-element input vector, all nine elements (corresponding to three rows) of the weight matrix can be unrolled into a single 32-element weight input vector. As part of preparing a corresponding data input vector, elements from columns corresponding to three rows of the data matrix are selected. The selected elements from three rows are unrolled into a one-dimensional vector. The number of columns utilized may be based on the size of the data input vector. In the example scenario with a 32-element data input vector, three rows are identified and 10 elements (corresponding to 10 columns) for each row are selected. A total of 30 elements are selected from three rows and ten columns. The remaining two locations in the data input vector for two elements are insufficient to fit an entire column from the identified three rows and instead are padded, for example, with two zero-value elements. In this manner, a 3&#xd7;10 portion of a data matrix can be unrolled and linearized into a data input vector and padded with two zero-value elements. Once prepared, the data input vector is loaded to an appropriate vector unit of the matrix processor unit. In various embodiments, each vector unit of the matrix processor unit is loaded with a prepared data input vector. For example, each vector unit of the matrix processor unit can be loaded by selecting elements starting with a different row. In the event the matrix processor unit is processing multiple convolution operations in parallel, the vector units are assigned to vector unit groups. Each vector unit group is dedicated to processing a different convolution operation. The vector units for each group are loaded with the matrix elements corresponding to that group's assigned convolution operation.</p><p id="p-0062" num="0061">In some embodiments, the initial number of columns to select from for preparing a data input vector is determined by dividing the size of the data input vector by the number of rows being unrolled. For example, in the event two, three, or four rows are being unrolled, a 32-element data input vector can be loaded with elements from sixteen, ten, or eight columns, respectively. Any unused elements of the data input vector can be filled with zero-value elements as padding. Once the number of columns is determined, each iteration can utilize the same number of columns. For example, a 7&#xd7;7 matrix can be loaded into a 32-element data input vector over four iterations. For the first three iterations, two rows (i.e., rows 1-2, 3-4, and 5-6) are unrolled each iteration and the last row (i.e., row 7) is unrolled for the fourth iteration. Each iteration can select 16 elements from different columns for the corresponding selected rows. The last iteration has additional padding since only one row is being unrolled. In various embodiments, zero-value elements are used as padding elements. A padding element with a value of zero allows the vector unit to perform multiply and addition vector operations with no impact on a resulting vector sum or dot product result.</p><p id="p-0063" num="0062">In various embodiments, once properly prepared using the appropriate format, a data input vector is loaded into a corresponding vector unit of the matrix processor unit. In some embodiments, a data input vector is prepared and loaded into each of the vector units of the matrix processor unit. For example, the data input vector prepared for each vector unit can correspond to a sub-matrix of a data input matrix with each sub-matrix starting at a different row of the data input matrix. For example, in the event the weight matrix is a fully unrolled 3&#xd7;3 matrix, the first vector unit may correspond to a sub-matrix with elements from rows 1-3, the second vector unit may correspond to a sub-matrix with elements from rows 2-4, the third vector unit may correspond to a sub-matrix with elements from rows 3-5, and so forth. In an embodiment, with 32 vector units, the 32nd vector unit may correspond to a sub-matrix with elements from rows 32-34. In some embodiments, the vector units are assigned to particular vector unit groups and only sub-matrices from the assigned group's data matrix are loaded to the vector units of the group.</p><p id="p-0064" num="0063">At <b>505</b>, weight input rows are identified. For example, one or more rows from a weight input matrix are identified for performing vector unit operations. In some embodiments, a weight input matrix is fully unrolled and each row of the weight input matrix is identified for unrolling. In various embodiments, a weight input matrix may be too large for full unrolling and is only partially unrolled. Only the rows selected for unrolling are identified for further processing at <b>507</b>. For example, a 3&#xd7;3 weight matrix (with 9 elements) can be fully unrolled into a 32-element weight input vector so each row of the weight matrix is utilized. As another example, a 7&#xd7;7 weight matrix (with 49 elements) cannot be fully unrolled into a 32-element weight input vector. Only the unrolled rows are identified for the current iteration. In various embodiments, successive iterations are used to identify the remaining rows.</p><p id="p-0065" num="0064">At <b>507</b>, a weight input mask is prepared and broadcasted to vector units. For example, elements corresponding to the weight input rows identified at <b>505</b> are prepared into a weight input mask. The weight input mask is linearized as a one-dimensional input vector for vector units of the matrix processor unit associated with a particular convolution operation. For example, the prepared weight input mask is broadcasted to each vector unit of a vector unit group assigned to a unique convolution operation. Other vector units not included in the vector unit group may receive a different weight input mask or may be unutilized. In various embodiments, the linearized weight elements are formatted with padding to align the start of each weight input row with an associated data input row prepared at <b>503</b>. For example, using a 32-element vector and a 3&#xd7;3 weight matrix with all rows identified at <b>505</b>, all nine elements of the weight matrix are selected. The nine elements of the weight matrix are formatted into a weight input mask using an additional 23 padding elements. In some embodiments, 30 elements are used for the three rows of the selected 3&#xd7;3 matrix. Each row includes three elements from a row followed by seven padding elements. The remaining elements of a data input vector not used for the rows of the selected 3&#xd7;3 matrix, in this example, two elements, are filled with additional padding elements. In various embodiments, zero-value elements are used as padding elements. A padding element with a value of zero allows the vector unit to perform multiply and addition vector operations with no impact on a resulting vector sum.</p><p id="p-0066" num="0065">In various embodiments, the formatted weight input mask is an input vector that is broadcasted to multiple vector units of a matrix processor unit. For example, a weight input vector is used to store the prepared weight input mask in a linearized one-dimensional vector format. The weight input mask is then broadcasted to each appropriate vector unit (e.g., each vector unit of a vector unit group) as an input vector operand. For example, a single weight input mask can be prepared and utilized by all the vector units of a matrix processor unit or all the vector units of a vector unit group of a matrix processor unit. In some embodiments, the row padding elements are utilized to allow the weight input mask to be shifted to realign the elements of the weight matrix with different columns of a data matrix as referenced in a data input vector. In some embodiments, the weight input mask is created by extracting weight elements from a combined weight vector. The combined weight vector may include weight elements from multiple weight matrices.</p><p id="p-0067" num="0066">At <b>509</b>, vector unit operations are performed. Utilizing the input vectors loaded from data input vectors and the broadcasted weight input mask, the corresponding vector units of a matrix processor unit perform vector unit operations. In some embodiments, the vector unit operations include vector multiply and addition operations. For example, each element from a data input vector is multiplied by its corresponding element from the weight input mask. The result is a vector of multiplication results. In some embodiments, the vector multiplication operation is performed by a vector multiply unit of a vector unit. Using the vector multiply result, a vector sum result is calculated by adding each of the elements from the vector of multiplication results. In some embodiments, the sum is determined using a vector adder unit of the vector unit. For example, a vector adder unit using an adder tree can compute the sum of the vector elements. In some embodiments, the matrix processor unit includes an accumulator for adding the vector adder result with previous vector adder results. For example, intermediate or partial results from each iteration can be accumulated to determine a running accumulated sum using an accumulator. The accumulated sum allows the vector sum result from one iteration (or pass) to be added into the result of a subsequent iteration (or pass). In various embodiments, the zero-padded elements prepared for the weight input mask (and/or data input vector) result in a zero multiplication result and have no impact on the vector addition result. In some embodiments, each vector unit of a matrix processor unit performs a dot product operation using its corresponding loaded data input vector and the broadcasted weight input mask. The dot product result may be accumulated with the results from previous iterations (or passes) and/or stored to be added to the results of future iterations.</p><p id="p-0068" num="0067">At <b>511</b>, vector results are outputted. For example, the vector result determined by performing vector unit operations at <b>509</b> is outputted from the matrix processor unit. In some embodiments, the vector results are outputted as an output vector result, for example, to an output vector unit such as output vector unit <b>151</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. The output vector unit may be used to write the output vector result to memory. In some embodiments, the results are outputted and used as an argument to a subsequent matrix operation.</p><p id="p-0069" num="0068"><figref idref="DRAWINGS">FIG. <b>6</b>A</figref> is a flow chart illustrating an embodiment of a process for performing a two-dimensional convolution operation using a matrix processor unit and vector unit operations. For example, using a data input matrix and a data weight matrix, matrix multiply and add operations are performed to compute at least a partial result for the two-dimensional convolution operation. The input matrices are unrolled, linearized, and fed as input vectors to vector units of a matrix processor unit. In some embodiments, the vector units are selected based on a vector unit group associated with a particular convolution operation. Weight input matrices that do not fit the size of an input vector are partially unrolled across different iterations. To further increase the throughput and efficiency of the matrix computations, additional passes are performed by shifting the unrolled input weight mask to realign the elements of the weight mask with different elements (and corresponding columns) of loaded data input vectors. By reusing prepared data input vectors with realigned weight masks, the impact on performance related to data transfers, especially from loading elements from a data input matrix to the matrix processor unit, is significantly reduced. For example, multiple passes are performed on each data input vector for each iteration of an input weight mask by only modifying the input weight mask while keeping the loaded data input vectors unchanged. In some embodiments, the process of <figref idref="DRAWINGS">FIG. <b>6</b>A</figref> is performed using the process of <figref idref="DRAWINGS">FIG. <b>5</b></figref>. For example, in some embodiments, the steps <b>605</b>, <b>607</b>, and/or <b>609</b> may be performed at <b>509</b> of <figref idref="DRAWINGS">FIG. <b>5</b></figref>. In some embodiments, the process of <figref idref="DRAWINGS">FIG. <b>6</b>A</figref> is performed using matrix processor unit <b>107</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref> and/or matrix processor unit <b>201</b> of <figref idref="DRAWINGS">FIG. <b>2</b>A</figref>.</p><p id="p-0070" num="0069">At <b>601</b>, data input vectors are prepared and loaded into a matrix processor unit. In some embodiments, the data input vectors are prepared and loaded as described with respect to steps <b>501</b> and <b>503</b> of <figref idref="DRAWINGS">FIG. <b>5</b></figref>. For example, the data input vectors are loaded to be compatible with the corresponding rows of a weight input vector. In some embodiments, the data input vectors include padding elements such as zero-value elements to prevent loading partial columns of elements. As an example, using a 3&#xd7;3 weight input matrix and a 32-element data input vector, a fully unrolled weight input matrix references three rows. Correspondingly, three rows of data elements are loaded into a data input vector. The number of three-row columns depends on the available number of elements from the data input vector. In the example, ten three-row columns are loaded for a total of 30 elements. The two remaining elements of the data input vector are unused and may be zeroed out with zero-value elements. The next data input vector can be loaded starting with the next corresponding row from the data matrix. In this manner, data input vectors from different (but possibly overlapping) slices of a data matrix are loaded into different vector units of the matrix processor unit. As another example, using a 7&#xd7;7 weight input matrix and a 32-element data input vector, a partially unrolled weight input matrix references two rows for each of the first three iterations and a single final row for the fourth iteration. Correspondingly, two rows of data elements are loaded into a data input vector for the iterations with two weight rows and one row of data elements is loaded into a data input vector for the final iteration using the last (and seventh) weight row. The number of two-row columns depends on the available number of elements from the data input vector. In the example, sixteen two-row columns are loaded for a total of 32 elements for the first three iterations with no padding elements needed. For the fourth iteration, sixteen elements from a single row are loaded and the sixteen remaining elements of the data input vector are unused and may be zeroed out with zero-value elements. Similar to the 3&#xd7;3 weight matrix example, within each iteration, the next data input vector can be loaded starting with the next corresponding row from the data matrix. In the 7&#xd7;7 weight input matrix example, data input vectors from different (but possibly overlapping) slices of a data matrix are loaded into different vector units of the matrix processor unit either two rows (for the first three iterations) or one row (for the final and fourth iteration) at a time.</p><p id="p-0071" num="0070">At <b>603</b>, a weight input mask is prepared and broadcasted to one or more vector units of the matrix processor unit. In some embodiments, the weight input mask is prepared and broadcasted as described with respect to steps <b>505</b> and <b>507</b> of <figref idref="DRAWINGS">FIG. <b>5</b></figref>. For example, for a fully unrolled weight matrix, each row of the weight matrix is unrolled and linearized into an input vector. To improve the efficiency of the matrix operations, zero padded elements are used to evenly space out the rows of the weight matrix within the input vector. As described above, the zero-padded elements allow the weight input vector to act as a weight input mask. Shifting the weight elements realigns the weight input mask to associate the weight elements with different corresponding columns from the data matrix. In some scenarios, the weight mask is padded to account for incomplete corresponding data columns. Once loaded into a weight input vector, the weight input mask is broadcasted to one or more applicable vector units of the matrix processor unit. For example, the weight input mask can be broadcasted to every vector unit of a vector unit group corresponding to an assigned convolution operation for the matrix processor unit.</p><p id="p-0072" num="0071">In some embodiments, a weight matrix is only partially unrolled. Over multiple iterations, all the rows of the weight matrix are unrolled. For a particular iteration, the selected rows are unrolled and padded with zero-value elements to create a partial weight mask associated with the selected rows. Subsequent iterations (or iterations performed in parallel) are used to unroll the remaining weight rows. For example, a 7&#xd7;7 weight matrix (with 49 elements) cannot be fully unrolled into a 32-element weight input vector. Only the unrolled rows are identified for the current iteration. If at most two rows are unrolled, then four iterations are needed to fully unroll a 7&#xd7;7 weight matrix. In some embodiments, different numbers of rows are selected for partial unrolling. For example, two, three, or more rows may be selected for unrolling as appropriate based on the weight matrix dimensions and the vector argument size of a vector unit.</p><p id="p-0073" num="0072">At <b>605</b>, matrix multiply and add operations are performed. In some embodiments, the matrix operations are described with respect to step <b>509</b> of <figref idref="DRAWINGS">FIG. <b>5</b></figref>. Utilizing the input vectors loaded from data input vectors and the broadcasted weight input mask, the corresponding vector units of a matrix processor unit perform vector unit operations including vector multiply and add operations. Each vector unit may perform a vector matrix multiply using the data input vector and the weight input mask. Unmasked elements result in multiplying the weight matrix elements against data matrix elements while masked out elements result in a zero value result. In various embodiments, the multiplication results are added using a vector adder to compute a resulting sum. For example, a 32-element vector unit receives two 32-element input vectors (a data input vector and a weight input mask) and performs a vector multiply to compute 32 multiplication results. A vector add operation is performed to add all 32 multiplication results to compute a single result sum. In some embodiments, the resulting sum is an intermediate result and is added to a previously computed result sum. For example, an accumulator may be used to store the resulting sum and on successive iterations the intermediate result is added to the currently computed result sum to keep a running sum across multiple iterations.</p><p id="p-0074" num="0073">In some embodiments, each vector unit performs its vector operations in parallel. For example, a matrix processor unit with 32 vector units can compute 32 results corresponding to 32 result sums. In various embodiments, each vector unit of a matrix processor unit performs a dot product operation using its corresponding loaded data input vector and a broadcasted weight input mask. The dot product result may be accumulated with the results from previous iterations (or passes) and/or stored to be added to the results of future iterations. In some embodiments, each vector unit group independently determines the results associated with its assigned convolution operation in parallel with the other vector units of other vector unit groups.</p><p id="p-0075" num="0074">At <b>607</b>, a determination is made whether additional columns of the data input matrix remain to be processed. In the event additional columns of the data input matrix remain to be processed, processing proceeds to <b>609</b>. In the event no additional columns of the data input matrix remain to be processed, processing proceeds to <b>611</b>.</p><p id="p-0076" num="0075">At <b>609</b>, the weights corresponding to each weight input vector are shifted. For example, the elements of a vector input mask are shifted to realign the weight elements with different data elements from data input vectors. For example, existing data input vectors loaded at <b>601</b> are used in an additional pass with a new weight input vector. A new weight input vector is prepared by shifting the weight elements, for example, by shifting each weight element to the right by one element. The shift realigns the weight elements with data elements corresponding to the next column. For example, a weight input mask corresponding to a 3&#xd7;3 weight matrix may be loaded into a vector unit along with a data input vector corresponding to a 3&#xd7;10 slice of the data matrix. Shifting the weight elements effectively slides the weight input mask to associate the weight matrix with a different three columns from the 3&#xd7;10 slice. With a 3&#xd7;3 weight matrix, eight passes (corresponding to seven shifts) can be performed before reaching the end of the data slice. As another example, using a 7&#xd7;7 weight matrix with two unrolled weight rows, each data input vector references 16 columns. Ten passes (corresponding to nine shifts) can be performed before reaching the end of the data slice. By spacing out the weight elements with padding elements in the weight input vector, the number of padding elements determines the maximum number of shifts (and passes) that can be performed with the loaded data input vectors.</p><p id="p-0077" num="0076">In various embodiments, once a weight input vector is shifted, the newly prepared weight input vector is broadcasted to each applicable vector unit. Processing proceeds to <b>605</b> where matrix operations are performed using a realigned weight input mask and a previously loaded data input vector.</p><p id="p-0078" num="0077">At <b>611</b>, a determination is made whether additional rows of a weight input matrix remain to be processed. In the event additional rows of a weight input matrix remain to be processed, processing proceeds to <b>613</b>. For example, partially unrolled matrices may have additional rows that need to be unrolled and processed. In contrast, a fully unrolled weight matrix will not have additional weight rows for processing. In the event no additional rows of a weight input matrix remain to be processed, processing proceeds to <b>615</b>.</p><p id="p-0079" num="0078">At <b>613</b>, data input and weight rows are advanced. For example, for a partially unrolled weight (and corresponding data) matrix, the identified rows are advanced to select the next set of rows for unrolling. Both the weight and data matrices are advanced together in order to associate the correct weight and data elements together. Using a 7&#xd7;7 weight matrix as an example and unrolling at most two rows each iteration, the first iteration selects rows 1 and 2. At <b>611</b>, additional weight input rows remain to be processed so at step <b>613</b>, the selected rows are advanced to select rows 3 and 4. A subsequent iteration selects rows 5 and 6. A final iteration selects row 7. Processing then proceeds to <b>601</b>.</p><p id="p-0080" num="0079">At <b>615</b>, results are outputted. In some embodiments, the results are outputted as described with respect to step <b>511</b> of <figref idref="DRAWINGS">FIG. <b>5</b></figref>. For example, the vector result determined by performing the matrix multiply and add operations at <b>605</b> is outputted from the matrix processor unit. In various embodiments, the vector results are outputted as an output vector result, for example, to an output vector unit such as output vector unit <b>151</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. The output vector unit may be used to write the output vector result to memory. In some embodiments, the results are outputted and used as an argument to a subsequent matrix operation.</p><p id="p-0081" num="0080"><figref idref="DRAWINGS">FIG. <b>6</b>B</figref> is a flow chart illustrating an embodiment of a process for preparing weight input operands for performing two-dimensional convolution operations using a matrix processor unit and vector unit operations. For example, using a combined weight vector, two or more weight input masks are created and broadcasted to the appropriate vector units of a matrix processor unit. Each vector unit receives an appropriate weight input mask associated with its assigned convolution operation for computing at least a partial result of a two-dimensional convolution operation. The combined weight vector allows multiple weight matrices to be read from memory using a minimal number of memory reads. Once a combined weight vector is read from memory, the weight elements associated with a two-dimensional weight matrix are extracted and formatted into weight input masks that are broadcasted to the appropriate vector units. In some embodiments, the process of <figref idref="DRAWINGS">FIG. <b>6</b>B</figref> is performed at <b>307</b> of <figref idref="DRAWINGS">FIG. <b>3</b>, <b>403</b></figref> of <figref idref="DRAWINGS">FIGS. <b>4</b>, <b>505</b> and/or <b>507</b></figref> of <figref idref="DRAWINGS">FIG. <b>5</b></figref>, and/or <b>603</b> of <figref idref="DRAWINGS">FIG. <b>6</b>A</figref>. In some embodiments, the process of <figref idref="DRAWINGS">FIG. <b>6</b>B</figref> is performed by an input vector unit such as weight input vector unit <b>105</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref> and/or weight input vector unit <b>205</b> of <figref idref="DRAWINGS">FIG. <b>2</b>A</figref>.</p><p id="p-0082" num="0081">At <b>651</b>, a combined weight vector is retrieved. For example, a combined weight vector is read from memory, such as memory <b>161</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, using a single read. By combining multiple weight matrices into a combined weight vector, a single read is sufficient to retrieve multiple weight matrices. For example, a 3&#xd7;3 weight matrix can be represented by 9 weight elements. Each weight matrix is a two-dimensional input weight operand for a convolution operation. Using a 32-element read, up to three weight matrices can be read in a single combined weight vector by linearizing each weight matrix and concatenating the weight elements together into a single 27-element vector. The remaining five elements may be padding elements or additional metadata used to describe the combined weight vector. In some embodiments, only two weight matrices are combined into a single combined weight vector. For example, using a 3&#xd7;3 weight matrix, 9 weight elements from each matrix are stored in a combined weight vector. In various embodiments, two or more combined weight vectors may be read over multiple reads to accommodate larger sized or a larger number of weight matrices.</p><p id="p-0083" num="0082">At <b>653</b>, weight elements for each two-dimensional weight input operand are extracted. Using the combined weight vector retrieved at <b>651</b>, weight elements corresponding to a two-dimensional weight matrix are extracted in preparation for creating one or more weight input masks. Each set of extracted weight elements corresponds to a two-dimensional weight input operand for a matrix operation such as a convolution operation. In various embodiments, the elements are extracted for each weight matrix stored in the combined weight vector. For example, two or more weight matrices are extracted from the same combined weight vector to prepare different weight input masks corresponding to different weight input operands. In some embodiments, the elements are extracted and stored using a temporary memory location such as a register.</p><p id="p-0084" num="0083">At <b>655</b>, weight input masks using the extracted weight elements are prepared. For example, a separate weight input mask is prepared for each weight matrix using the extracted elements. In some embodiments, each weight input mask is prepared and stored in a memory location such as a register. The register used may be a register such as weight input vector registers <b>207</b> or <b>209</b> of <figref idref="DRAWINGS">FIG. <b>2</b>A</figref>. In various embodiments, the weight input mask is an unrolled weight matrix with the appropriate number of zero padded elements used to evenly space out the rows of the weight matrix within the input vector. As described above, the zero-padded elements allow the input vector to act as a weight input mask. Shifting the weight elements realigns the weight input mask to associate the weight elements with different corresponding columns from a data matrix. In some scenarios, the weight mask is padded to account for incomplete corresponding data columns. For example, using a 32-element vector and a 3&#xd7;3 weight matrix, at step <b>653</b>, nine elements of a weight matrix are extracted. At step <b>655</b>, the extracted elements are formatted into a weight input mask using an additional 23 padding elements. In some embodiments, 30 elements are used for the three rows of the selected 3&#xd7;3 weight matrix. Each row includes three elements from a row followed by seven padding elements. The remaining two elements are filled with additional padding elements. In various embodiments, zero-value elements are used as padding elements. A padding element with a value of zero allows the vector unit to perform multiply and addition vector operations with no impact on a resulting vector sum.</p><p id="p-0085" num="0084">At <b>657</b>, weight input masks are broadcasted to assigned vector units. For example, each vector unit of a vector unit group receives its associated weight input mask. Different vector units corresponding to different vector unit groups receive the weight input mask associated with the convolution operation assigned to the group. In some embodiments, the vector unit groups are vector unit groups <b>211</b> and <b>221</b> of <figref idref="DRAWINGS">FIG. <b>2</b>A</figref> and/or vector unit groups <b>253</b> and <b>255</b> of <figref idref="DRAWINGS">FIG. <b>2</b>B</figref>. The weight input masks may be stored in corresponding weight input vector registers such as weight input vector registers <b>207</b> and <b>209</b> of <figref idref="DRAWINGS">FIG. <b>2</b>A</figref>.</p><p id="p-0086" num="0085"><figref idref="DRAWINGS">FIGS. <b>7</b>A and <b>7</b>B</figref> are diagrams illustrating example matrix operands for performing depthwise convolution. In <figref idref="DRAWINGS">FIG. <b>7</b>A</figref>, weight matrix <b>701</b> represents an exemplar 3&#xd7;3 matrix of weight elements. Other dimensions for a weight matrix may be appropriate as well, such as 1&#xd7;1, 5&#xd7;5, 7&#xd7;7, 9&#xd7;9, etc. In the example shown, the subscripts associated with each weight element use a row and column notation. For the first row of weight matrix <b>701</b>, W<sub>1,1 </sub>is the weight element located at column 1, W<sub>1,2 </sub>is the weight element located at column 2, and W<sub>1,3 </sub>is the weight element located at column 3. In <figref idref="DRAWINGS">FIG. <b>7</b>B</figref>, data matrix <b>703</b> represents an exemplar data matrix of data elements. The dimensions of data matrix <b>703</b> are larger than weight matrix <b>701</b>. In the example of <figref idref="DRAWINGS">FIG. <b>7</b>B</figref>, only rows 1-4 and 32-34 of data matrix <b>703</b> are shown. The width of data matrix <b>703</b> can extend past 11 columns. Similarly, the height of data matrix <b>703</b> can extend past 34 rows (not shown). The height of data matrix <b>703</b> may also be smaller than the number of vector units. For example, a matrix processor unit may have 32 vector units but a data matrix (not shown) may only have 18 rows. In <figref idref="DRAWINGS">FIG. <b>7</b>B</figref>, data matrix <b>703</b> is shown with 34 rows to make it compatible with 3&#xd7;3 weight matrix <b>701</b> and a matrix processor unit with 32 vector units where each vector unit is utilized to solve matrix operations. In the event a data matrix has fewer rows than there are vector units (e.g., 18 rows for a 32 vector unit matrix processor unit), multiple matrix operations corresponding to different pairs of matrices can be processed in parallel. In some embodiments, weight matrix <b>701</b> and data matrix <b>703</b> are input matrices for performing convolution operations using the techniques described herein. In some embodiments, the convolution operations, such as a depthwise convolution, are performed on weight matrix <b>701</b> and data matrix <b>703</b> using matrix processor unit <b>107</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref> and/or matrix processor unit <b>201</b> of <figref idref="DRAWINGS">FIG. <b>2</b>A</figref> and/or the processes of <figref idref="DRAWINGS">FIGS. <b>3</b>-<b>6</b>B</figref>. For example, the convolution operation instruction received at <b>301</b> of <figref idref="DRAWINGS">FIG. <b>3</b></figref> may specify a weight matrix such as weight matrix <b>701</b> and a data matrix such as data matrix <b>703</b>.</p><p id="p-0087" num="0086"><figref idref="DRAWINGS">FIGS. <b>8</b>A and <b>8</b>B</figref> are diagrams illustrating an example of an unrolled data matrix for performing depthwise convolution. <figref idref="DRAWINGS">FIGS. <b>8</b>A and <b>8</b>B</figref> include index labels <b>801</b> and <b>802</b> that indicate the location of a data element in a 32-element data input vector. <figref idref="DRAWINGS">FIGS. <b>8</b>A</figref> and <b>8</b>B include seven example data input vectors <b>803</b>/<b>804</b>, <b>805</b>/<b>806</b>, <b>807</b>/<b>808</b>, <b>809</b>/<b>810</b>, <b>811</b>/<b>812</b>, <b>813</b>/<b>814</b>, and <b>815</b>/<b>816</b>. The first half of each data input vector is shown in <figref idref="DRAWINGS">FIG. <b>8</b>A</figref> and the corresponding second half of each input vector is shown in <figref idref="DRAWINGS">FIG. <b>8</b>B</figref>. Due to the large size of the vectors, for ease of illustration, the data input vectors are illustrated as vector pairs and split across <figref idref="DRAWINGS">FIGS. <b>8</b>A and <b>8</b>B</figref>. For example, the seven 32-element data input vectors include 16-element vector pairs <b>803</b>/<b>804</b>, <b>805</b>/<b>806</b>, <b>807</b>/<b>808</b>, <b>809</b>/<b>810</b>, <b>811</b>/<b>812</b>, <b>813</b>/<b>814</b>, and <b>815</b>/<b>816</b>.</p><p id="p-0088" num="0087">In some embodiments, the data input vectors shown in <figref idref="DRAWINGS">FIGS. <b>8</b>A and <b>8</b>B</figref> are data input vectors unrolled from a sub-matrix of data matrix <b>703</b> of <figref idref="DRAWINGS">FIG. <b>7</b>B</figref> or a data matrix with 18 rows. For example, data input vector <b>803</b>/<b>804</b> corresponds to elements from the first three rows of data matrix <b>703</b> of <figref idref="DRAWINGS">FIG. <b>7</b>B</figref> unrolled into a 1-dimensional vector and includes data elements from rows 1-3 and columns 1-10 of data matrix <b>703</b>. Similarly, referencing elements from columns 1-10 of data matrix <b>703</b> of <figref idref="DRAWINGS">FIG. <b>7</b>B</figref>, data input vector <b>805</b>/<b>806</b> corresponds to elements from rows 2-4, data input vector <b>807</b>/<b>808</b> corresponds to elements from rows 3-5, data input vector <b>809</b>/<b>810</b> corresponds to elements from rows 4-6, data input vector <b>811</b>/<b>812</b> corresponds to elements from rows 5-7, data input vector <b>813</b>/<b>814</b> corresponds to elements from rows 6-8, and data input vector <b>815</b>/<b>816</b> corresponds to elements from rows 16-18. Data elements associated with different 3&#xd7;10 slices of the data matrix are loaded into each of data input vectors <b>803</b>/<b>804</b>, <b>805</b>/<b>806</b>, <b>807</b>/<b>808</b>, <b>809</b>/<b>810</b>, <b>811</b>/<b>812</b>, <b>813</b>/<b>814</b>, and <b>815</b>/<b>816</b>. Elements at locations 30 and 31 (the 31st and 32nd elements) of each of data input vectors <b>803</b>/<b>804</b>, <b>805</b>/<b>806</b>, <b>807</b>/<b>808</b>, <b>809</b>/<b>810</b>, <b>811</b>/<b>812</b>, <b>813</b>/<b>814</b>, and <b>815</b>/<b>816</b> are zero-value elements. In various embodiments, elements at locations 30 and 31 are padding elements.</p><p id="p-0089" num="0088">In some embodiments, each of the data input vectors of <figref idref="DRAWINGS">FIGS. <b>8</b>A and <b>8</b>B</figref> are loaded into separate vector units of a matrix processor unit. For a matrix processor unit with 32 vector units, only 16 data input vectors are loaded and each may be prepared by starting with a different row. In the example shown, data input vectors <b>803</b>/<b>804</b>, <b>805</b>/<b>806</b>, <b>807</b>/<b>808</b>, <b>809</b>/<b>810</b>, <b>811</b>/<b>812</b>, and <b>813</b>/<b>814</b> are loaded into the first six vector units and data input vector <b>815</b>/<b>816</b> is loaded into the 16th vector unit. Although not shown, vector units <b>7</b>-<b>15</b> are loaded with corresponding data input vectors. The vector units <b>1</b>-<b>16</b> may correspond to a vector unit group. The vector units <b>17</b>-<b>32</b> may correspond to a different vector unit group and may be configured to receive data input vectors corresponding to a different data matrix. In some embodiments, data input vectors <b>803</b>/<b>804</b>, <b>805</b>/<b>806</b>, <b>807</b>/<b>808</b>, <b>809</b>/<b>810</b>, <b>811</b>/<b>812</b>, <b>813</b>/<b>814</b>, and <b>815</b>/<b>816</b> are generated by and loaded into a matrix processor unit, such as matrix processor unit <b>107</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, by a data input vector unit such as data input vector unit <b>103</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. In some embodiments, the unrolling process to create data input vectors <b>803</b>/<b>804</b>, <b>805</b>/<b>806</b>, <b>807</b>/<b>808</b>, <b>809</b>/<b>810</b>, <b>811</b>/<b>812</b>, <b>813</b>/<b>814</b>, and <b>815</b>/<b>816</b> is performed at <b>305</b> of <figref idref="DRAWINGS">FIG. <b>3</b></figref>, at <b>401</b> and/or <b>403</b> of <figref idref="DRAWINGS">FIG. <b>4</b></figref>, at <b>501</b> and/or <b>503</b> of <figref idref="DRAWINGS">FIG. <b>5</b></figref>, and/or at <b>601</b> of <figref idref="DRAWINGS">FIG. <b>6</b>A</figref>. In some embodiments, the data input vectors of <figref idref="DRAWINGS">FIGS. <b>8</b>A and <b>8</b>B</figref> represent a partial set of data input vectors prepared for one iteration of an unrolling process and are formatted to be aligned with a fully unrolled 3&#xd7;3 weight matrix such as weight matrix <b>701</b> of <figref idref="DRAWINGS">FIG. <b>7</b>A</figref>.</p><p id="p-0090" num="0089"><figref idref="DRAWINGS">FIGS. <b>9</b>A and <b>9</b>B</figref> are diagrams illustrating an example of an unrolled weight matrix for performing depthwise convolution. <figref idref="DRAWINGS">FIGS. <b>9</b>A and <b>9</b>B</figref> include index labels <b>901</b> and <b>902</b> that indicate the location of a weight element in a 32-element weight input vector. <figref idref="DRAWINGS">FIGS. <b>9</b>A and <b>9</b>B</figref> include eight example weight input vectors <b>903</b>/<b>904</b>, <b>905</b>/<b>906</b>, <b>907</b>/<b>908</b>, <b>909</b>/<b>910</b>, <b>911</b>/<b>912</b>, <b>913</b>/<b>914</b>, <b>915</b>/<b>916</b>, and <b>917</b>/<b>918</b>. The first half of each weight input vector is shown in <figref idref="DRAWINGS">FIG. <b>9</b>A</figref> and the corresponding second half of each input vector is shown in <figref idref="DRAWINGS">FIG. <b>9</b>B</figref>. Due to the large size of the vectors, for ease of illustration, the weight input vectors are illustrated as vector pairs and split across <figref idref="DRAWINGS">FIGS. <b>9</b>A and <b>9</b>B</figref>. For example, the eight 32-element weight input vectors include 16-element vector pairs <b>903</b>/<b>904</b>, <b>905</b>/<b>906</b>, <b>907</b>/<b>908</b>, <b>909</b>/<b>910</b>, <b>911</b>/<b>912</b>, <b>913</b>/<b>914</b>, <b>915</b>/<b>916</b>, and <b>917</b>/<b>918</b>. The weight input vectors represent eight different weight input vectors that are broadcasted to the vector units of a matrix processor unit over eight passes. Examples of corresponding data input vectors are shown in <figref idref="DRAWINGS">FIGS. <b>8</b>A and <b>8</b>B</figref> and may remain unchanged for the entire eight passes as the weight input vectors change.</p><p id="p-0091" num="0090">In some embodiments, the weight input vectors shown in <figref idref="DRAWINGS">FIGS. <b>9</b>A and <b>9</b>B</figref> are weight input vectors unrolled from weight matrix <b>701</b> of <figref idref="DRAWINGS">FIG. <b>7</b>A</figref>. For example, each of weight input vectors <b>903</b>/<b>904</b>, <b>905</b>/<b>906</b>, <b>907</b>/<b>908</b>, <b>909</b>/<b>910</b>, <b>911</b>/<b>912</b>, <b>913</b>/<b>914</b>, <b>915</b>/<b>916</b>, and <b>917</b>/<b>918</b> corresponds to elements from weight matrix <b>701</b> of <figref idref="DRAWINGS">FIG. <b>7</b>A</figref> unrolled into and spaced out over a 1-dimensional vector. The weight elements and rows are prepared at different locations to align the weight input vector with different columns of a corresponding data input vector. Zero-value padded elements are included between the rows and at the end of the vectors at locations 30 and 31. For example, weight input vector <b>903</b>/<b>904</b> includes row 1 of weight matrix <b>701</b> of <figref idref="DRAWINGS">FIG. <b>7</b>A</figref> at element locations 0-2, row 2 at element locations 10-12, and row 3 at element locations 20-22. Weight input vector <b>905</b>/<b>906</b> may be prepared by shifting the elements of weight input vector <b>903</b>/<b>904</b> to the right by one location. Similarly, weight input vectors <b>907</b>/<b>908</b>, <b>909</b>/<b>910</b>, <b>911</b>/<b>912</b>, <b>913</b>/<b>914</b>, <b>915</b>/<b>916</b>, and <b>917</b>/<b>918</b> are created by shifting the elements of weight input vectors <b>905</b>/<b>906</b>, <b>907</b>/<b>908</b>, <b>909</b>/<b>910</b>, <b>911</b>/<b>912</b>, <b>913</b>/<b>914</b>, and <b>915</b>/<b>916</b>, respectively. In some embodiments, as the weight input vectors are shifted to the right, zero-value padding elements are introduced to the front of the weight input vectors.</p><p id="p-0092" num="0091">In some embodiments, each of the weight input vectors of <figref idref="DRAWINGS">FIGS. <b>9</b>A and <b>9</b>B</figref> is broadcasted into appropriate vector units of a matrix processor unit at a different pass of the corresponding data input vectors. For a matrix processor unit with multiple vector units, each vector unit of a vector unit group is loaded with the same weight input vector for each pass. For example, weight input vector <b>903</b>/<b>904</b> is broadcasted to each assigned vector unit for pass one, weight input vector <b>905</b>/<b>906</b> is broadcasted to each assigned vector unit for pass two, weight input vector <b>907</b>/<b>908</b> is broadcasted to each assigned vector unit for pass three, and so forth, until weight input vector <b>917</b>/<b>918</b> is broadcasted to each assigned vector unit for the eighth pass. In various embodiments, the vector units assigned to a group each receive the same weight input vector, and each vector unit of the group is associated with the same convolution operation. Vector units of different groups receive weight input vectors corresponding to the appropriate weight matrix for the assigned convolution operation.</p><p id="p-0093" num="0092">In some embodiments, weight input vectors <b>903</b>/<b>904</b>, <b>905</b>/<b>906</b>, <b>907</b>/<b>908</b>, <b>909</b>/<b>910</b>, <b>911</b>/<b>912</b>, <b>913</b>/<b>914</b>, <b>915</b>/<b>916</b>, and <b>917</b>/<b>918</b> are generated and/or loaded into a matrix processor unit, such as matrix processor unit <b>107</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, by a weight input vector unit such as weight input vector unit <b>105</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. In some embodiments, the unrolling process to create weight input vectors <b>903</b>/<b>904</b>, <b>905</b>/<b>906</b>, <b>907</b>/<b>908</b>, <b>909</b>/<b>910</b>, <b>911</b>/<b>912</b>, <b>913</b>/<b>914</b>, <b>915</b>/<b>916</b>, and <b>917</b>/<b>918</b> is performed at <b>307</b> of <figref idref="DRAWINGS">FIG. <b>3</b></figref>, at <b>401</b> and/or <b>403</b> of <figref idref="DRAWINGS">FIG. <b>4</b></figref>, at <b>505</b> and/or <b>507</b> of <figref idref="DRAWINGS">FIG. <b>5</b></figref>, and/or at <b>603</b>, <b>607</b>, and/or <b>609</b> of <figref idref="DRAWINGS">FIG. <b>6</b>A</figref>. In some embodiments, the different weight input vectors of <figref idref="DRAWINGS">FIGS. <b>9</b>A and <b>9</b>B</figref> represent different weight input masks prepared for one iteration of an unrolling process that includes eight passes. Each of the weight input masks is a fully unrolled 3&#xd7;3 weight matrix such as weight matrix <b>701</b> of <figref idref="DRAWINGS">FIG. <b>7</b>A</figref> and is formatted to be aligned with different 3&#xd7;3 slices of a data matrix, such as data matrix <b>703</b> of <figref idref="DRAWINGS">FIG. <b>7</b>B</figref>. In various embodiments, different weight input masks can be broadcasted to different vector unit groups of a matrix processor unit.</p><p id="p-0094" num="0093"><figref idref="DRAWINGS">FIGS. <b>10</b>A and <b>10</b>B</figref> are diagrams illustrating an example of vector computations for performing depthwise convolution. <figref idref="DRAWINGS">FIGS. <b>10</b>A and <b>10</b>B</figref> include index labels <b>1001</b> and <b>1002</b> that indicate the location of weight and data elements in 32-element weight input vector <b>1003</b>/<b>1004</b> and data input vector <b>1005</b>/<b>1006</b>, respectively. In some embodiments, weight input vector <b>1003</b>/<b>1004</b> is weight input vector <b>903</b>/<b>904</b> of <figref idref="DRAWINGS">FIGS. <b>9</b>A and <b>9</b>B</figref> and data input vector <b>1005</b>/<b>1006</b> is data input vector <b>803</b>/<b>804</b> of <figref idref="DRAWINGS">FIGS. <b>8</b>A and <b>8</b>B</figref>. In some embodiments, weight input vector <b>1003</b>/<b>1004</b> and data input vector <b>1005</b>/<b>1006</b> are examples of two input vectors loaded into a vector unit for performing vector operations. In various embodiments, each of the vector units of a matrix processor unit is loaded with a corresponding pair of input vectors associated with its assigned convolution operation and vector unit group.</p><p id="p-0095" num="0094">In some embodiments, cell <b>1011</b> illustrates the equivalent vector computations performed by a vector unit of a matrix processor unit on input vectors of weight input vector <b>1003</b>/<b>1004</b> and data input vector <b>1005</b>/<b>1006</b>. The vector computation result shown in cell <b>1011</b> is the result determined by multiplying each element of weight input vector <b>1003</b>/<b>1004</b> against a corresponding element of data input vector <b>1005</b>/<b>1006</b>. The 32-elements from weight input vector <b>1003</b>/<b>1004</b> are multiplied against 32 elements of data input vector <b>1005</b>/<b>1006</b> to determine 32 multiplication results. In the example shown, cell <b>1011</b> includes only nine multiplication terms instead of 32. The nine multiplication terms correspond to the nine weight elements from weight input vector <b>1003</b>/<b>1004</b> and their corresponding data elements from data input vector <b>1005</b>/<b>1006</b>. The zero-value elements of weight input vector <b>1003</b>/<b>1004</b> function as a weight mask that results in reducing the number of multiplication terms to nine from a possible 32. In some embodiments, the multiplication is performed using a vector multiply unit such as vector multiply unit <b>271</b>, <b>275</b>, <b>291</b>, or <b>295</b> of <figref idref="DRAWINGS">FIG. <b>2</b>B</figref>. In some embodiments, the multiplication results are fed as a vector into a vector adder unit to compute the sum of the multiplication results. The vector sum may be performed using a vector adder unit such as vector adder unit <b>273</b>, <b>277</b>, <b>293</b>, or <b>297</b> of <figref idref="DRAWINGS">FIG. <b>2</b>B</figref>. In the example shown, the result of the vector operations performed is a single result sum. In some embodiments, the result sum is a partial or intermediate result sum and may be stored in an accumulator. In some embodiments, the result sum is a dot product computed using weight input vector <b>1003</b>/<b>1004</b> and data input vector <b>1005</b>/<b>1006</b>. The result sum may be outputted as one element of a vector result and written to an output vector unit such as output vector unit <b>151</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. In some embodiments, the equivalent of the vector computation result shown in cell <b>1011</b> is performed using matrix processor unit <b>107</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref> and/or the processes of <figref idref="DRAWINGS">FIGS. <b>3</b>-<b>6</b>B</figref>. In some embodiments, the vector computations are performed at <b>309</b> of <figref idref="DRAWINGS">FIG. <b>3</b></figref>, at <b>403</b> of <figref idref="DRAWINGS">FIG. <b>4</b></figref>, at <b>509</b> of <figref idref="DRAWINGS">FIG. <b>5</b></figref>, and/or at <b>605</b> of <figref idref="DRAWINGS">FIG. <b>6</b>B</figref>.</p><p id="p-0096" num="0095"><figref idref="DRAWINGS">FIGS. <b>11</b>A and <b>11</b>B</figref> are diagrams illustrating an example of a combined weight vector used for performing multiple depthwise convolution operations in parallel. <figref idref="DRAWINGS">FIGS. <b>11</b>A and <b>11</b>B</figref> include index labels <b>1101</b> and <b>1102</b> that indicate the location of a weight element in a 32-element combined weight vector. <figref idref="DRAWINGS">FIGS. <b>11</b>A and <b>11</b>B</figref> include combined weight vector <b>1103</b>/<b>1104</b>. The first half of combined weight vector <b>1103</b>/<b>1104</b> is shown in <figref idref="DRAWINGS">FIG. <b>9</b>A</figref> and the corresponding second half of combined weight vector <b>1103</b>/<b>1104</b> is shown in <figref idref="DRAWINGS">FIG. <b>9</b>B</figref>. Due to the large size of the vector, for ease of illustration, combined weight vector <b>1103</b>/<b>1104</b> is illustrated as a vector pair and split across <figref idref="DRAWINGS">FIGS. <b>11</b>A and <b>11</b>B</figref>. Combined weight vector <b>1103</b>/<b>1104</b> stores two weight matrices, each corresponding to a different convolution operation. The first weight matrix includes the nine weight elements from elements group <b>1105</b>. The second weight matrix is split across <figref idref="DRAWINGS">FIGS. <b>11</b>A and <b>11</b>B</figref> and includes the nine weight elements from elements groups <b>1107</b> and <b>1109</b>. The represented weight matrices are each two-dimensional 3&#xd7;3 weight matrices. In some embodiments, the weight matrices are a two-dimensional weight matrix such as weight matrix <b>701</b> of <figref idref="DRAWINGS">FIG. <b>7</b>A</figref>.</p><p id="p-0097" num="0096">In the example shown, the two weight matrices represented by the nine weight elements from elements group <b>1105</b> and the nine weight elements from elements groups <b>1107</b> and <b>1109</b> are two different weight matrices and each corresponds to a different convolution operation. The subscripts associated with each weight element use a row and column notation. For the first row, W<sub>1,1 </sub>is the weight element located at column 1, W<sub>1,2 </sub>is the weight element located at column 2, and W<sub>1,3 </sub>is the weight element located at column 3. In the example shown, weight elements from elements group <b>1105</b> represent a linearized two-dimensional matrix with three rows and three columns. Similarly, the weight elements from elements groups <b>1107</b> and <b>1109</b> represent a different linearized two-dimensional matrix with three rows and three columns. For each weight matrix, the corresponding elements of the linearized two-dimensional matrix can be extracted and used to create a weight input mask. In some embodiments, the locations 18-31 of combined weight vector <b>1103</b>/<b>1104</b> are unused. In some embodiments, the extra locations are filled with padding elements or additional metadata used to describe the combined weight vector. In various embodiments, the specific locations and offsets for each weight matrix stored in combined weight vector <b>1103</b>/<b>1104</b> can vary as appropriate. In some embodiments, an additional three or more weight matrices may be stored in a combined weight vector. For example, a 32-element combined weight vector can store three 3&#xd7;3 matrices using 27 weight elements.</p><p id="p-0098" num="0097">Although the foregoing embodiments have been described in some detail for purposes of clarity of understanding, the invention is not limited to the details provided. There are many alternative ways of implementing the invention. The disclosed embodiments are illustrative and not restrictive.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A system, comprising:<claim-text>a data input vector unit configured to receive elements of a plurality of different rows of a first data matrix and a second data matrix;</claim-text><claim-text>a weight input vector unit configured to:<claim-text>receive a combined weight vector, wherein the combined weight vector includes weight elements of a first weight matrix and weight elements of a second weight matrix, and the first weight matrix and the second weight matrix are different matrices combined in the combined weight vector; and</claim-text><claim-text>at least in part concurrently provide extracted weight elements from the first weight matrix to a first group of one or more calculation units for the first data matrix and provide extracted weight elements from the second weight matrix to a second group of one or more calculation units for the second data matrix;</claim-text></claim-text><claim-text>at least one calculation unit included in the first group of one or more calculation units configured to use provided elements of the first data matrix from the data input vector unit and provided corresponding elements of the first weight matrix from the weight input vector unit to at least in part determine a corresponding element in a first convolution result matrix; and</claim-text><claim-text>at least one calculation unit included in the second group of one or more calculation units configured to use provided elements of the second data matrix from the data input vector unit and provided corresponding elements of the second weight matrix from the weight input vector unit to at least in part determine a corresponding element in a second convolution result matrix.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein each calculation unit included in the first group of one or more calculation units and the second group of one or more calculation units is a different vector calculation unit.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The system of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein each vector calculation unit includes a vector multiply unit and a vector adder unit.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The system of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the vector adder unit includes an adder tree.</claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the first group of one or more calculation units or the second group of one or more calculation units includes one or more vector accumulators.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The system of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein at least one of the one or more vector accumulators is configured to store a vector of intermediate results corresponding to partial results of convoluting the first weight matrix with the first data matrix.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the first weight matrix and the second weight matrix are different machine learning weight matrices and the first and second data matrices store data for machine learning.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the first and second data matrices correspond to different channels of a three-dimensional machine learning data matrix.</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the first and second weight matrices are each a 3&#xd7;3 matrix.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the weight input vector unit includes a first register for storing extracted weight elements of the first weight matrix and a second register for storing extracted weight elements of the second weight matrix, and wherein the first register and second register are different.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The system of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the weight input vector unit includes a shifting circuit configured to shift each of the extracted weight elements within the first register and each of the extracted weight elements within the second register.</claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the weight input vector unit is further configured to format the extracted weight elements of the first weight matrix into a first weight input mask and to format the extracted weight elements of the second weight matrix into a second weight input mask.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The system of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the first weight input mask is stored in a first register of the weight input vector unit and the second weight input mask is stored in a second register of the weight input vector unit, and wherein the first register and second register are different.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The system of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein each of the first and second weight input masks includes zero-value padding elements.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the combined weight vector is a 32-byte vector stored in a memory unit and includes zero-value padding elements.</claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the combined weight vector includes weight elements of three or more different weight matrices.</claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. A method, comprising:<claim-text>receiving at a processing element an instruction specifying a first data matrix, a second data matrix, and a combined weight vector, wherein the first data matrix is associated with a first convolution operation and the second data matrix is associated with a second convolution operation, and wherein the combined weight vector includes weight elements of a first weight matrix associated with the first convolution operation and weight elements of a second weight matrix associated with the second convolution operation, and the first weight matrix and the second weight matrix are different matrices combined in the combined weight vector;</claim-text><claim-text>assigning a plurality of calculation units of a matrix processor unit to a first group of one or more calculation units and a different plurality of calculation units to a second group of one or more calculation units;</claim-text><claim-text>creating a first weight input mask associated with the first convolution operation from the combined weight vector; and</claim-text><claim-text>creating a second weight input mask associated with the second convolution operation from the combined weight vector.</claim-text></claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The method of <claim-ref idref="CLM-00017">claim 17</claim-ref>, further comprising:<claim-text>broadcasting the first weight input mask to each calculation unit of the first group of one or more calculation units;</claim-text><claim-text>broadcasting the first weight input mask to each calculation unit of the second group of one or more calculation units;</claim-text><claim-text>providing each calculation unit of the first group of one or more calculation units elements of a plurality of different rows of the first data matrix;</claim-text><claim-text>providing each calculation unit of the second group of one or more calculation units elements of a plurality of different rows of the second data matrix; and</claim-text><claim-text>at least in part concurrently performing vector operations using the first and second groups of one or more calculation units using a broadcasted first or second weight input and provided data elements from the first or second data matrix.</claim-text></claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. A method, comprising:<claim-text>receiving at a data input vector unit elements of a plurality of different rows of a first data matrix and a second data matrix;</claim-text><claim-text>receiving at a weight input vector unit a combined weight vector, wherein the combined weight vector includes weight elements of a first weight matrix and weight elements of a second weight matrix, and the first weight matrix and the second weight matrix are different matrices combined in the combined weight vector;</claim-text><claim-text>at least in part concurrently providing extracted weight elements from the first weight matrix to a first group of one or more calculation units and providing extracted weight elements from the second weight matrix to a second group of one or more calculation units; and</claim-text><claim-text>at least in part concurrently providing the elements of the plurality of the different rows of the first data matrix first to the first group of the one or more calculation units for the first data matrix and providing the elements of the plurality of the different rows of the second data matrix first to the second group of the one or more calculation units for the second data matrix.</claim-text></claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The method of <claim-ref idref="CLM-00019">claim 19</claim-ref>, further comprising:<claim-text>at least in part concurrently multiplying the provided elements of the first data matrix from the data input vector unit with the provided corresponding elements of the first weight matrix from the weight input vector unit and multiplying the provided elements of the second data matrix from the data input vector unit with the provided corresponding elements of the second weight matrix from the weight input vector unit; and</claim-text><claim-text>at least in part concurrently summing together multiplication results to at least in part determine a corresponding element in a first convolution result matrix and summing together multiplication results to at least in part determine a corresponding element in a second convolution result matrix.</claim-text></claim-text></claim></claims></us-patent-application>