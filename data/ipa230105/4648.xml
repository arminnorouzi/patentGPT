<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004649A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004649</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17365847</doc-number><date>20210701</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>21</main-group><subgroup>57</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>11</main-group><subgroup>10</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>L</subclass><main-group>9</main-group><subgroup>32</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>21</main-group><subgroup>575</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>11</main-group><subgroup>1068</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>L</subclass><main-group>9</main-group><subgroup>3239</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">MEMORY DEVICE HAVING SAFETY BOOT CAPABILITY</invention-title><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>MACRONIX INTERNATIONAL CO., LTD.</orgname><address><city>HSINCHU</city><country>TW</country></address></addressbook><residence><country>TW</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>SU</last-name><first-name>Chun-Lien</first-name><address><city>Taichung</city><country>TW</country></address></addressbook></inventor></inventors></us-parties><assignees><assignee><addressbook><orgname>MACRONIX INTERNATIONAL CO., LTD.</orgname><role>03</role><address><city>HSINCHU</city><country>TW</country></address></addressbook></assignee></assignees></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A method provides the capability to maintain integrity of a data image stored by computing a hash value (&#x201c;digest&#x201d;) of the data image and comparing the hash value computed for the data image with a hash value computed for the data image and kept in a non-volatile area of memory. Bit flips in the data image that are a result of memory hardware errors reveal themselves as differences in the digest computed for the data image and the computed digest for the data.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="52.24mm" wi="158.75mm" file="US20230004649A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="237.15mm" wi="195.83mm" orientation="landscape" file="US20230004649A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="210.14mm" wi="147.66mm" orientation="landscape" file="US20230004649A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="240.88mm" wi="167.47mm" file="US20230004649A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="244.60mm" wi="191.69mm" orientation="landscape" file="US20230004649A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="245.28mm" wi="191.77mm" orientation="landscape" file="US20230004649A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="226.91mm" wi="187.20mm" orientation="landscape" file="US20230004649A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="244.86mm" wi="190.92mm" orientation="landscape" file="US20230004649A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="236.39mm" wi="189.74mm" orientation="landscape" file="US20230004649A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="243.59mm" wi="118.11mm" file="US20230004649A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="237.49mm" wi="185.76mm" orientation="landscape" file="US20230004649A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">BACKGROUND</heading><heading id="h-0002" level="1">Field</heading><p id="p-0002" num="0001">The present invention relates to improved data integrity in the storage, retrieval and loading operations of semiconductor memory, and specifically to semiconductor memory operations integrity related to stored critical use data requiring an integrity level to be maintained, such as stored boot instructions.</p><heading id="h-0003" level="1">Description of Related Art</heading><p id="p-0003" num="0002">In many modern computer systems, the system is booted by copying code located in external flash memory into local RAM and then executing the instructions as copied from RAM.</p><p id="p-0004" num="0003">While there are perceived advantages to this approach, one issue that can arise is that a system will not boot successfully if any integrity issue exists with the code stored in the external flash. Computer memory however is subject to failure like all hardware. Such failures, even if relatively infrequent, can pose potentially adverse results in critical operations such as boot strap loading a computer, as well as other computing operations requiring high data integrity from memory.</p><p id="p-0005" num="0004">It is desirable to provide improved integrity in the storage, retrieval and loading operations of semiconductor memory, especially semiconductor memory operations related to boot code stored in memory.</p><heading id="h-0004" level="1">SUMMARY</heading><p id="p-0006" num="0005">The disclosed technology provides methods for maintaining integrity of a data image during operations of semiconductor memory and memory devices embodying these methods. In general, by way of overview and in implementations, there is provided the capability to maintain integrity of a stored data image (i.e., copy of the data) of a working dataset by computing, using a secure algorithm, a secure hash value (&#x201c;digest&#x201d;) of the data image and comparing the hash value computed for the data image with prior hash value(s) computed for original copies of the data image(s). Original copies of the data can be kept in a non-volatile area of memory. Bit flips in the data image that are a result of memory hardware errors will reveal themselves as differences in the prior digest computed for the data image and the digest computed for the original copy of the data. When device logic encounters a difference between the computed hash value and the prior digest, the device logic determines an integrity fault has occurred with the data image corresponding to the computed hash value. Remedial action taken in implementations can include alerting a host via output signal or interrupt, swapping data read from a stored redundant data image of the dataset or combinations thereof. The redundant data image can be the same as, or different from first data image, e.g., the redundant data image can store a redundant copy boot code that can be the same as, or different from, the first copy boot code. Examination can be triggered at power on or reset time, and/or in some implementations responsive to receiving a command.</p><p id="p-0007" num="0006">One implementation of our technology is a memory device with safety boot capability. The memory device, typically a flash but our technology is applicable to a broader range of devices, comprises a plurality of non-volatile registers that store address information of boot code and at least one redundant copy of boot code stored in a memory array. A non-volatile storage area that keeps a hash digest. An input/output interface enables posting internal status register states to I/O data units connecting to a host and/or other components external to the memory device. Data path circuits connect between non-volatile registers, the memory array, the non-volatile storage area, and the interface. Logic circuitry examines integrity of the boot code stored in the memory array by comparing a hash calculation of the boot code and a stored hash calculation that was determined and stored in the non-volatile storage area holding the hash digest kept and to provide as output boot code or redundant boot code in accordance with an integrity examination result. Variants include embedded operation, in which the device performs the integrity checking on power up without further command or input; on-the-fly operation, in which the device integrity checks boot code being read out by a host or other device as it is being read. Error correcting code (ECC) circuitry can provide a first tier check of integrity, and a messaging hash algorithm can provide a second tier check. Some implementations include the ECC correcting errors in the boot code. Some implementations swap out portions of boot code with boot code from redundant copy(ies) when errors are encountered. Some implementations keep the hash computed for the boot code in an encrypted digest, ensuring that only hosts providing the correct key can access a proper copy of the boot code hash. Some implementations store boot code and redundant data images in different memory banks to take advantage of concurrency, speeding operation.</p><p id="p-0008" num="0007">One method for maintaining integrity for a data image of boot instructions during operations of semiconductor memory includes detecting by a semiconductor memory a power on reset condition responsive to a power on event, or a reset instruction or reset signal from a host. A semiconductor memory embodying our method can automatically examine integrity of boot instructions for the host. For example, by conducting a hash calculation of a first data image comprising boot instructions for the host; and comparing the hash calculation with a stored hash calculation determined for the first data image. The host can be alerted that the first data image experienced an integrity examination fault whenever a discrepancy between the hash calculation and the stored hash calculation determined for the first data image is detected. Remedial action taken in implementations can include alerting a host via output signal or interrupt, swapping data read from a stored redundant data image of the dataset or combinations thereof.</p><p id="p-0009" num="0008">In another implementation, upon detecting any of a power on reset condition or a reset instruction or signal by a host, the host is started by execution of ROM stored code, or code from embedded flash memory, to configure hardware and prepare to load into RAM either a bootloader or an application residing in external flash (i.e., the memory device embodying our method). As a data image of this code is read out of memory, a semiconductor memory embodying our method can detect the power on reset condition, or reset instruction or reset signal from the host or receive a command indicating boot code is being read out of memory. The semiconductor memory embodying our method can automatically conduct an on-the-fly examination of the integrity of the boot code data image as it is being read by the host. In a mode called &#x201c;shadowing&#x201d;, as the host reads one or more bytes of boot code from a stored data image, our method examines bytes requested by the host and updates a hash calculation for the data image based upon the bytes read each time. When no further bytes are to be read from the data image, the resulting hash calculation is compared with a stored hash calculation determined for the boot code data image. The host can be alerted that the data image experienced an integrity examination fault whenever a discrepancy between the hash calculation and the stored hash calculation determined for the data image is detected. Remedial action taken in implementations can include alerting a host via output signal or interrupt, swapping data read from a stored redundant data image of the dataset or combinations thereof.</p><p id="p-0010" num="0009">In a further implementation, a method for maintaining integrity in a data image during operations of semiconductor memory includes detecting that a read request received from a host is to read data from a data image stored in a memory array of a semiconductor memory. The method further includes conducting a first tier integrity check using ECC and a second tier integrity check using a hash calculation of the data read from the data image. The ECC may be able to correct some errors arising in the boot code. The hash calculation is compared with a stored hash calculation determined for the data image and stored as a digest. The host can be alerted that the data image experienced an integrity examination fault whenever a discrepancy between the hash calculation and the stored hash calculation determined for the data image is detected.</p><p id="p-0011" num="0010">In a representative implementation, a memory device comprises a memory array including a plurality of memory locations arranged into banks of memory locations, such as a first memory bank and a second memory bank for example, an input/output interface for I/O data units, data path circuits connected between the memory array and the interface, a non-volatile storage area that keeps a digest, a command decoder circuit that, responsive to commands received at the input/output interface to read and write to memory locations in the plurality of memory locations, directs read and write operations to blocks of storage locations interleaved among at least the first memory bank and the second memory bank, and hash engine logic circuitry that examines integrity of a data image stored in the memory array by comparing a hash calculation of a data image stored in at least one of the first memory bank and the second memory bank and a stored hash calculation determined and stored with the digest kept and report an integrity examination result by changing a state of a status register or a pin to signal the pass or fail.</p><p id="p-0012" num="0011">The technology disclosed is applicable to all types of memory having command interfaces. Example embodiments are described in which a memory array comprises a flash, however, the technologies described herein can be applied to other types of memory devices as well. Some embodiments implement our redundancy mechanism in a NOR flash memory. Other embodiments implement the redundancy mechanism in a NAND flash memory. Still other embodiments implement redundancy mechanism in a memory that is not a flash memory. Further, while discussed with reference to example implementations used in applications for storing and providing instructions to boot load a computer (i.e., &#x201c;boot code&#x201d;), our disclosed technology is applicable in a wide variety of other applications in which integrity of memory devices is needed.</p><p id="p-0013" num="0012">Other aspects and advantages of the present invention can be seen on review of the drawings, the detailed description and the claims, which follow.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a simplified block diagram of an integrated circuit memory device suitable for embodying a mechanism for maintaining integrity in a data image during memory device operations.</p><p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a simplified logic diagram of logic circuitry implementing a swap table and selecting from among memory banks in an integrated circuit memory array suitable for use with a mechanism for maintaining integrity in a data image during memory device operations like that of <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. <b>3</b>A</figref> is a state diagram illustrating an embedded integrity checking without ECC hashing operation for an embodiment of an integrated circuit memory device having an integrity maintenance mechanism like that of <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>3</b>B</figref> is a state diagram illustrating an embedded integrity checking with ECC hashing operation for an embodiment of an integrated circuit memory device having an integrity maintenance mechanism like that of <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>3</b>C</figref> is a state diagram illustrating another implementation of an embedded integrity checking with ECC hashing operation for an embodiment of an integrated circuit memory device having an integrity maintenance mechanism like that of <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>4</b>A</figref> is a state diagram illustrating an on-the-fly integrity checking without ECC hashing operation for an embodiment of an integrated circuit memory device having an integrity maintenance mechanism like that of <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>4</b>B</figref> is a state diagram illustrating an on-the-fly integrity checking without ECC hashing operation for an embodiment of an integrated circuit memory device having an integrity maintenance mechanism like that of <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a state diagram illustrating an on-the-fly integrity checking without ECC hashing operation using encrypted digests for an embodiment of an integrated circuit memory device having an integrity maintenance mechanism like that of <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a flowchart illustrating an integrity verification operation of an integrated circuit memory device having an integrity maintenance mechanism like that of <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a state diagram illustrating an example secure hashing algorithm usable in an integrated circuit memory device having an integrity maintenance mechanism like that of <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0006" level="1">DETAILED DESCRIPTION</heading><p id="p-0024" num="0023">A detailed description of embodiments implementing the disclosed technology is provided with reference to the <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>7</b></figref>.</p><p id="p-0025" num="0024">Hardware failures can occur and there are even standards promulgated by regulatory bodies concerning them. Functional safety standards define safety integrity using defined levels with each level denoting more stringent safety levels and less probability of failures. For example, methods of how to apply, design, deploy and maintain automatic protection systems called safety-related systems by IEC 61508 standard. The safety integrity level (SIL) provides a target to attain for each safety function. A risk assessment effort yields a target SIL for each safety function. In another example, ISO 26262 standard defines different criterions of probabilistic metric for random hardware faults (PMHF) for different Automotive Safety Integrity Level (ASIL) levels. Semiconductor memories are not exception.</p><p id="p-0026" num="0025">In general, by way of overview and in implementations, there is provided the capability to maintain integrity of a data image stored by computing using a secure algorithm a hash value (&#x201c;digest&#x201d;) of the data image and comparing the hash value computed for the data image of a working dataset (i.e., copy of the data) with a hash values computed for the working dataset stored as a digest and kept in a non-volatile area of memory. Bit flips in the data image that are a result of memory hardware errors will reveal themselves as differences (i.e., an integrity fault) in the digest computed for the data image and the digest computed for the data and stored. When device logic encounters a difference between the computed hash value and a stored digest, the device logic determines an integrity fault has occurred. Remedial action taken in implementations can include alerting a host via output signal or interrupt, swapping data read from a stored redundant data image of the dataset or combinations thereof.</p><p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a simplified block diagram of a memory system including a flash memory device implemented on an integrated circuit suitable for embodying a mechanism for maintaining integrity in a data image during memory device operations as described herein. The memory device can be implemented on a single integrated circuit chip, on a multichip module, or on a plurality of chips configured as suits a particular need. This diagram is merely an example, which should not unduly limit the scope of the claims herein. One of ordinary skill in the art would recognize other variations, modifications, and alternatives.</p><p id="p-0028" num="0027">As shown, integrated circuit device <b>100</b> (also referred to as memory device, memory chip, flash device, etc.) includes a mechanism for checking the integrity of stored copies of data images that includes Secure safety boot logic <b>111</b> embedded logic circuitry that coordinates the actions of hash engine <b>115</b>, Nonvolatile memory (NVM) Secret area <b>113</b> and swap table <b>112</b> to examine the integrity of a data image of a dataset comprising boot code (i.e. instructions to a processor to be executed at startup by the processor in order to initialize the operating system) whenever a power on reset condition or a reset instruction or signal is detected. If an integrity fault is detected by the hash engine <b>115</b> working in conjunction with stored digests from NVM secret area <b>113</b>, the secure safety boot logic <b>111</b> can signal to the host <b>97</b>A being booted that an integrity fault has occurred in the boot code and have the host to check the status registers for details. Signaling can be by output pin, interrupt, or combinations thereof. Further, in some implementations security safety boot logic <b>111</b> can modify entries in swap table <b>112</b> corresponding to a block or blocks of memory array <b>160</b> that store the data image that experienced the integrity fault in order to &#x201c;swap&#x201d; in corresponding blocks of code from a redundant copy of the boot code. In one implementation, this examination can be triggered by a host &#x201c;on demand&#x201d; by exchange of commands.</p><p id="p-0029" num="0028">Integrated circuit memory device <b>100</b> includes a memory array <b>160</b> including single-level cells or multiple-level cells that store two or more bits of data per cell, on an integrated circuit substrate. The memory array <b>160</b> can be a flash memory implemented using two-dimensional or three-dimensional array technology. One implementation of memory array <b>160</b> stores data at an address corresponding to a location in memory array <b>160</b>. The address is decoded by X-decoder <b>141</b> and Y-decoder <b>143</b>. In some integrity maintaining memory embodiments, memory array <b>160</b>, x-decoder <b>141</b>, y-decoder <b>143</b> and address generator <b>14</b> implement storage blocks of memory interleaved among different memory banks <b>160</b>A, <b>160</b>B. It results in an area of multiple blocks distributed into different banks. Interleaved blocks of memory locations in different banks enables embodiments to conduct swapping operation and even later recovering operation in memory devices in which read while write is implemented. In some implementations, a page buffer (not shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref> for clarity sake) can be coupled to memory array <b>160</b> to provide temporary storage for memory operations. In a read operation, the data is transferred from memory array <b>160</b> through sense amplifiers/buffers <b>171</b>A, <b>171</b>B. For write operation, data is transferred from data cache <b>91</b>, to sense amplifiers/buffers <b>171</b>A, <b>171</b>B, and then written into memory array <b>160</b> in either memory bank 0 <b>160</b>A or memory bank 1 <b>160</b>B in accordance with the input address. (A read operation, by contrast, will not only check the input address but also the swap table.) For high voltage operation, e.g., for a write operation, high voltage generator <b>17</b> is activated. Some implementations may omit separate memory banks, relying instead on a uniform array. On the other hand, some implementations may include more than two memory banks depicted by <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0030" num="0029">Control logic <b>110</b>, working in conjunction with Hash engine <b>115</b> (and in some implementations with ECC engine <b>114</b>), examines the integrity of the designated data image stored in memory array <b>160</b> by comparing results of originally checked copies of the data (e.g., original data images), stored in the digests kept along with the original data images stored in the memory array, with results of a current hash calculated by Hash engine <b>115</b> (and in some implementations with ECC engine <b>114</b>) for a currently requested copy of the data image (e.g., current data image or the data image). The hash digest of the designated data image is calculated, maybe externally by users or by the hash engine <b>115</b> internally, and then stored to the NVM secret along with the data image stored in the memory array. The secret is non-volatile and in one implementation is allocated a reserved portion of the memory array, not accessible to users, to implement persistent storage against power loss. The configuration and status register, <b>81</b>, can also be implemented in similar approach. That is the non-volatile registers are also from the reserved portion of the memory array. Some implementations maintain two data images of the same dataset, first copy and a redundant second copy; enabling the system to switch, using swap table <b>112</b>, to the redundant copy if an integrity fault is detected with the first copy. The data image is preferably boot instructions for booting a host <b>97</b> coupled to device <b>100</b>, but can be practically any type of dataset in other applications for which high data integrity is desired (e.g., systems used in space travel, aircraft, nuclear power station controllers, and many other important applications).</p><p id="p-0031" num="0030">In one implementation, ECC engine <b>114</b> can also be used as an integrity checking mechanism. It is not only competent to detect errors but also able to correct errors within its capability according to the ECC scheme employed. ECC engine <b>114</b> can be implemented in page-based hashing to provide proactive error detection and correction if the number of error bits is within its designed capability before reading out the whole boot code in its entirety. Once ECC correction fails, control logic <b>110</b> will resort to the corresponding redundant area. However, ECC can only protect a page rather than whole boot code/image. Hash engine <b>115</b> could implement any widely used message digest algorithm such as MD5, SHA256 or the like. SHA256 is a member of the Secure Hash Algorithm 2 (SHA2) family of cryptographic hash functions designed by the US National Security Agency (NSA). For further discussion and further detail of the SHA2 family of algorithms, reference by the skilled person can be had to &#x201c;<i>Federal Information Processing Standards </i>(<i>FIPS</i>) <i>PUB </i>180-4&#x201d; (csrc.nist.gov/publications/detail/fips/180/4/final), the entirety of which is incorporated herein by reference for all purposes. In the embodiment illustrated by <figref idref="DRAWINGS">FIG. <b>1</b></figref>, SHA256 is used to implement the Hash engine <b>115</b>. Of course other implementations will embody different members of the SHA-2 family, which presently consists of six hash functions with digests (hash values) that are 224, 256, 384 or 512 bits: SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, SHA-512/256. Of these, SHA-256 and SHA-512 are novel hash functions computed with 32-bit and 64-bit words, respectively.</p><p id="p-0032" num="0031">A non-volatile <b>113</b> area is provided to keep the digest <b>116</b>. In some implementations, these NVM secret <b>113</b> and/or NVM configuration registers can be a reserved part in the flash array <b>160</b>. An output of 256 bits from hash engine <b>115</b> is stored in a Non-volatile memory (NVM) Secret area <b>113</b>. Optionally, in some implementations a hash result can be encrypted by a secret key, either symmetric or asymmetric. Preferably, asymmetric encryption is used in implementations in which authentication is imposed. The key is used to encrypt the digest <b>116</b>. If the wrong key is provided by host, an erroneous decryption result for the digest <b>116</b> would be obtained, and the comparison will never pass. For embedded embodiments, the memory chip may not output any data if this comparison fails (e.g., authentication failed and no data output). Keys can be provided to hosts <b>97</b>A-<b>97</b>N using Diffie-Hellman Key Exchange, pre-installed by manufacturer, locally generated from random number generator, combinations of these, and other key exchange protocols. For background information about one particular variant of Diffie-Hellman Key Exchange, reference can be had to Internet Engineering Task Force IETF RFC 2631 (//tools.ietforg/html/rfc2631); the entirety of which are incorporated herein by reference for all purposes.</p><p id="p-0033" num="0032">Accordingly, the integrity check performed by Hash engine <b>115</b> will fail if either: (i) any bit flip is detected; or (ii) authentication failed.</p><p id="p-0034" num="0033">A swap table <b>112</b> is used to swap between copies of a same data image. Such a swap can be triggered when the hash engine <b>115</b> determines that a fault exists with one copy of the data. If the data image is boot code, a finding of a fault in a copy of the boot code (ie., an integrity fault) can be detected by the secure safety boot <b>111</b> logic. An example of logic circuitry implementing Swap table <b>112</b> is depicted in <figref idref="DRAWINGS">FIG. <b>2</b></figref>, a simplified logic diagram of logic circuitry implementing a swap table and selecting from among memory banks in an integrated circuit memory array suitable for use with a mechanism for maintaining integrity in a data image during memory device operations like that of <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0035" num="0034">As shown in <figref idref="DRAWINGS">FIG. <b>2</b></figref>, an example swap table <b>200</b> comprises a set of registers <b>202</b> used to indicate which address bit(s) are swapped, and a set <b>204</b> of exclusive OR gates is used to flip address bits. In <figref idref="DRAWINGS">FIG. <b>2</b></figref>, a representative address &#x201c;X&#x201d;, for example A<b>20</b>-A<b>10</b>, is input to exclusive OR gates <b>204</b> along with the content of swap table <b>112</b> and the result is applied to address generator <b>14</b> and decoders <b>141</b>, <b>143</b> of device <b>100</b>. In this example, bits S<b>15</b> and S<b>14</b> of registers <b>202</b> are flagged and corresponding bits A<b>15</b> and A<b>14</b> of address X are swapped accordingly.</p><p id="p-0036" num="0035">With renewed reference to <figref idref="DRAWINGS">FIG. <b>1</b></figref>, input/output is performed by interface <b>105</b> comprising several input blocks coupled to respective input/output pins to provide connectivity to a host, such as host <b>97</b>A. In one embodiment, the interface <b>105</b> is a serial interface including a set of I/O ports <b>195</b> through which commands, addresses and data are communicated. The serial interface can be based on or compliant with a Serial Peripheral Interface (SPI) bus specification in which the command channel shares the I/O pins used by address and data. For example, the integrated circuit memory device <b>100</b> can include input/output ports using pins for receiving and transmitting SPI bus signals. One pin can be connected to an input data line carrying serial input data/address signal SI, usable for commands as well. Another pin, or multiple other pins, can be connected to an output data line or output data lines carrying serial output data signal SO. Another pin can be connected to a clock line carrying serial clock signal SCLK that is coupled to Clock Generator <b>15</b>, which in turn is coupled to command decoder <b>108</b> and control logic <b>110</b>. Control logic <b>110</b> is operably coupled to receive a chip select signal CS # on a CS # input terminal of interface <b>105</b>. Commands or instructions may be input through input SI/SIO<b>0</b> block, for example, and then transferred to control logic <b>110</b>. Control logic <b>110</b>, in combination with state machine <b>11</b>, interprets and executes the command such as a read, erase, or program operation. In an embodiment, control logic <b>110</b> also receives a signal from WP #/ACC block of interface <b>105</b> to perform a write protect function, and a signal from HOLD # block of interface <b>105</b> to keep a clock signal from entering the state machine <b>11</b>. Data may be input through SI/SIO<b>0</b> block, SO/SIO<b>1</b> block, WP #/ACC block, and HOLD # block, which are coupled to data cache <b>91</b>. Data may be output through SI/SIO<b>0</b> block, SO/SIO<b>1</b> block, WP #/ACC block, and HOLD # block, which are coupled the output buffer <b>91</b>. Other types of interfaces, including parallel interfaces can be used as well. The I/O ports <b>195</b> on a particular integrated circuit memory device <b>100</b> can be configured to provide output data with an I/O data width, which can be, for some examples, 1, 4, 8, 16, 32 or more bits in parallel per interface clock (e.g. SCLK) cycle. The I/O interface <b>105</b> can include a FIFO buffer, a shift register buffer or other supporting circuits along with a transmitter for transmitting data received at the interface on ports at a port clock rate, such as an SCLK rate for an SPI interface.</p><p id="p-0037" num="0036">The memory array <b>160</b> can comprise floating gate memory cells or dielectric charge trapping memory cells configured to store single bit or multiple bits per cell, by the establishment of multiple program levels that correspond to amounts of charge stored, which in turn establish memory cell threshold voltages VT. The description herein is based on the use of charge trapping memory cells, such as floating gate flash memory and dielectric charge trapping flash memory. The technology can be used with other memory cell technologies. In other examples, the memory cells may comprise programmable resistance memory cells, configured for multiple bits per cell, by the establishment of multiple program levels that correspond to amounts of resistance. Memory devices as described herein can be implemented using multichip modules, stacked chips and other configurations as well. The memory device can be implemented on a single integrated circuit chip, on a multichip module that includes one or more integrated circuits in a common package, or on a plurality of chips configured to suit a particular need.</p><p id="p-0038" num="0037">In the example shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, control logic <b>110</b> includes circuits implementing a bias arrangement state machine, or machines, which controls, or control, the application of supply voltages generated or provided through the voltage supply or supplies (not shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref> for clarity sake), such as read, verify and program voltages for a set of selectable program and read operations used in the MLC operating methods described herein. The control logic <b>110</b> are coupled to the cache circuits <b>91</b> and the memory array <b>160</b> and other elements of the integrated circuit as needed. The circuitry in the control logic <b>110</b> include logic to control multiple-level program operations described in more detail below. The control logic <b>110</b> can include modules implemented using special-purpose logic circuitry as known in the art. In alternative embodiments, the control logic <b>110</b> can include modules implemented using a general-purpose processor, which can be implemented on the same integrated circuit, which executes a computer program to control the operations of the memory device <b>100</b>. In yet other embodiments, a combination of special-purpose logic circuitry and a general-purpose processor can be utilized for implementation of modules in control logic <b>110</b>.</p><p id="p-0039" num="0038">In the illustrated embodiment, NVM Secret <b>113</b> can be used to store digest <b>116</b>. In some implementations, these NVM secret <b>113</b> and/or NVM configuration registers can be a reserved part in the flash array <b>160</b>. Information from the NVM reserved section can be read out from the flash array <b>160</b> at power on. Address, length, redundancy, and other boot information, are part of configuration and status registers <b>81</b>, specifically of non-volatile type <b>81</b>B, and coupled to control logic <b>110</b>. The configuration and status registers <b>81</b> include volatile <b>81</b>A and non-volatile <b>81</b>B areas that can store parameters for a plurality of selectable program operations and a plurality of selectable read operations, according to the processes described herein.</p><p id="p-0040" num="0039">In implementations, the host <b>97</b>A can comprise a general purpose processor, a special purpose processor, a processor configured as a memory controller, or other processor that uses the memory device <b>100</b>. All or part of the host <b>97</b>A can be implemented on the same integrated circuit as the memory. Although the above has been shown using a selected group of components for the integrated circuit device, there can be many alternatives, modifications, and variations. For example, some of the components may be expanded and/or combined. Other components may be inserted to those noted above. Depending upon the embodiment, the arrangement of components may be interchanged with others replaced. Further details of these components are found throughout the present specification and more particularly below.</p><p id="p-0041" num="0040">Having described an example integrity maintenance architecture for a storage memory, next examples of boot operations conducted using integrity verification mechanisms like that of <figref idref="DRAWINGS">FIGS. <b>1</b> and <b>2</b></figref> will be described with reference to state diagrams of <figref idref="DRAWINGS">FIGS. <b>3</b>A, <b>4</b>A, and <b>5</b></figref>, illustrating example embodiments without ECC implemented integrity checking and <figref idref="DRAWINGS">FIGS. <b>3</b>B, <b>3</b>C, and <b>4</b>B</figref>, illustrating example embodiments with ECC implemented integrity checking and flowchart of <figref idref="DRAWINGS">FIGS. <b>6</b>-<b>7</b></figref>. <figref idref="DRAWINGS">FIG. <b>3</b>A</figref> is a state diagram illustrating an embedded integrity checking without ECC hashing operation for an embodiment of an integrated circuit memory device <b>100</b> having an integrity maintenance mechanism like that of <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0042" num="0000">Embedded Integrity Verification without ECC Hashing Operations</p><p id="p-0043" num="0041">Now with reference to state diagram <b>300</b>A of <figref idref="DRAWINGS">FIG. <b>3</b>A</figref>, an example of an embedded integrity checking without ECC hashing operation for a boot code data image will be described. <figref idref="DRAWINGS">FIG. <b>3</b>A</figref> depicts a state diagram <b>300</b>A illustrating an embedded integrity checking without ECC hashing operation for an embodiment of an integrated circuit memory device <b>100</b> having an integrity maintenance mechanism like that of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. In <figref idref="DRAWINGS">FIG. <b>3</b>A</figref>, secure safety boot <b>111</b> of device <b>100</b> embeds a secure safety boot logic <b>301</b>, which is preferably implemented in logic circuitry. If the embedded integrity examination option is set to &#x201c;on&#x201d;, then the secure safety boot logic <b>111</b> of device <b>100</b> will commence automatically at power on or receiving or detecting a reset instruction or signal from a host, examining default boot code integrity and changing to a redundant boot code copy by modifying swap table if an integrity fault is detected.</p><p id="p-0044" num="0042">In a state <b>302</b> a power on reset condition or a reset instruction or signal of the host <b>97</b>A to force the memory device <b>100</b> to reset as if it had experienced a power on event but without any actual power interruption having occurred, is detected and a start safety boot process is triggered.</p><p id="p-0045" num="0043">In a state <b>306</b>, the control logic <b>110</b> invokes the hash engine <b>115</b> to examine a current copy of the boot code in memory bank 0 <b>160</b>A of the memory array <b>160</b> and calculate a digest.</p><p id="p-0046" num="0044">In a state <b>324</b>, the control logic <b>110</b> locates a digest <b>116</b> that was determined for the boot code in NVM Secret area <b>113</b>, and compares the digest calculated for the current copy of the boot code in memory bank 0 <b>160</b>A of the memory array <b>160</b> with the digest <b>116</b> that was determined for the boot code retrieved from the NVM Secret area <b>113</b>. Then the control logic <b>110</b> will determine whether the current copy of the boot code in memory bank 0 <b>160</b>A of the memory array <b>160</b> passes integrity verification based upon a result of the compare.</p><p id="p-0047" num="0045">If the digest for the current copy and the digest <b>116</b> that was determined for the boot code retrieved from the NVM Secret area <b>113</b> do not match (e.g., are not equivalent), then in a state <b>334</b>, the swap table <b>112</b> is modified to direct the system to obtain boot code from a redundant boot code copy of the boot code in memory bank 1 <b>160</b>B of the memory array <b>160</b>.</p><p id="p-0048" num="0046">Further, in a state <b>336</b>, the swap event is signaled to the host <b>97</b>A using a status register, signal and/or interrupt so that the host can recover. The difference between status register and signal, like interrupt or else, is: (i) for status registers, the host actively checks the status registers for every read or other operations; because registers are inside memory device <b>100</b> and only can accessed by host <b>97</b>A through a command operation; (ii) for signals, instead a pin is used to physically connect the host to the memory device <b>100</b>; the memory device <b>100</b> will change the state of the signal to notify the host accordingly; and (iii) for interrupt signals, the signal will trigger hardware interrupt and force main control unit or central processing unit (MCU/CPU) to execute the interrupt routine accordingly. In this technology, a major intention is to make host <b>97</b>A aware of the event happened inside the memory device <b>100</b>. The host <b>97</b>A can cope correctly and properly with the event, e.g., apply recovery for the concerned boot code at a convenient time.</p><p id="p-0049" num="0047">In a state <b>328</b>, a data image is readied for request from a host; the data image comprising blocks from the current copy of the boot code in memory bank 0 <b>160</b>A of the memory array <b>160</b> if the integrity check passed and/or blocks from the redundant boot code copy of the boot code in memory bank 1 <b>160</b>B of the memory array <b>160</b>, if swapping was necessary to maintain integrity (e.g., obtain a data image having a digest equivalently comparing with a stored digest, during power on reset before responding any requests/commands from the host. Of course, the status register of configuration and a status registers <b>81</b> is flagged if a swap event is applied during power on. In embodiments, no response is still a response from the point of view of host <b>97</b>A if the first operation of host <b>97</b>A is just trying to read boot code from memory device <b>100</b> without checking the status first, e.g., by reading ID or else contents of registers of configuration and a status registers <b>81</b>. In such case, one implementation of the memory device <b>100</b> outputs a NOP (No Operation which is defined by users through configuring memory device <b>100</b> at first use or during programming stage.), e.g., all 0 is one common form of NOP. This output of a NOP merely makes CPU/MCU run a dummy instruction cycle as a wait cycle. Thus, one implementation of the memory device <b>100</b> outputs a default NOP, e.g. all 0, at power on till internal reset and integrity check completes.</p><p id="p-0050" num="0048">Having described with reference to <figref idref="DRAWINGS">FIG. <b>3</b>A</figref> an example of an embedded automatically executing integrity verification without ECC hashing operation conducted using integrity mechanisms like that of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, next, two additional embodiments for embedded automatically executing integrity verification in which ECC is incorporated for the secure safety boot will next be described with reference to <figref idref="DRAWINGS">FIG. <b>3</b>B</figref> and <figref idref="DRAWINGS">FIG. <b>3</b>C</figref>.</p><p id="p-0051" num="0000">Embedded Integrity Verification with ECC Hashing Operations</p><p id="p-0052" num="0049"><figref idref="DRAWINGS">FIG. <b>3</b>B</figref> is a state diagram <b>300</b>B illustrating an embedded integrity checking with ECC hashing operation for an embodiment of an integrated circuit memory device having an integrity maintenance mechanism like that of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. In <figref idref="DRAWINGS">FIG. <b>3</b>B</figref>, any error detected in each ECC check unit, here is a page of 2k bytes or subpage of 512 bytes, will be corrected by ECC parity information first. If any error uncorrectable, the error will propagate to the hash calculation and results in a mismatched hash digest and then triggers a start over with the address swapped to point to another boot code in memory array <b>160</b>.</p><p id="p-0053" num="0050">In a state <b>302</b> a power on reset condition or a reset instruction or signal of the host <b>97</b>A to force the memory device <b>100</b> to reset as if it had experienced a power on event but without any actual power interruption having occurred, is detected and a start safety boot process is triggered.</p><p id="p-0054" num="0051">In a state <b>304</b>, the control logic <b>110</b> obtains a 2 Kbyte page of a current copy of the boot code in memory bank 0 <b>160</b>A of the memory array <b>160</b>.</p><p id="p-0055" num="0052">In a state <b>306</b>, the control logic <b>110</b> invokes ECC engine <b>114</b> to check for errors.</p><p id="p-0056" num="0053">In a state <b>308</b>, if an error is detected, then in a state <b>310</b> determine if the error is correctable. Otherwise, if there is no error, control passes to state <b>320</b> below.</p><p id="p-0057" num="0054">In a state <b>318</b> a status bit appropriate to correctable or non-correctable is set in a status register of configuration and a status register. The error event can be signaled to the host <b>97</b>A using the status register, signal and/or interrupt enabling the host can recover.</p><p id="p-0058" num="0055">In a state <b>320</b> the control logic <b>110</b> invokes the hash engine <b>115</b> to calculate a digest for the current copy of the boot code as read out so far.</p><p id="p-0059" num="0056">In a state <b>322</b>, a check is performed to see if the last page of the boot code has been read out. If not, control passes back to state <b>304</b> to read another page. Otherwise control passes to state <b>324</b>.</p><p id="p-0060" num="0057">In a state <b>324</b>, the control logic <b>110</b> locates a digest <b>116</b> that was determined for the boot code in NVM Secret area <b>113</b>, and compares the digest calculated for the current copy of the boot code in memory bank 0 <b>160</b>A of the memory array <b>160</b> with the digest <b>116</b> that was determined for the boot code retrieved from the NVM Secret area <b>113</b>. If the digest for the current copy and the digest <b>116</b> that was determined for the boot code retrieved from the NVM Secret area <b>113</b> do not match (e.g., are not equivalent), then control passes to state <b>326</b>. Otherwise, in a state <b>328</b>, a data image is readied for response to the host. In some implementations, no response is still a response from the point of view of host <b>97</b>A if the first operation of host <b>97</b>A is just trying to read boot code from memory device <b>100</b> without checking the status first, e.g., by reading ID or else contents of registers of configuration and a status registers <b>81</b>. In such case, one implementation of the memory device <b>100</b> outputs a NOP (No Operation which is defined by users through configuring memory device <b>100</b> at first use or during programming stage.), e.g., all 0 is one common form of NOP. This output of a NOP merely makes CPU/MCU run a dummy instruction cycle as a wait cycle. Thus, one implementation of the memory device <b>100</b> outputs a default NOP, e.g. all 0, at power on till internal reset and integrity check completes.</p><p id="p-0061" num="0058">In a state <b>326</b>, a check is performed to see if a boot images have been swapped. If so, then in a state <b>330</b> the error and the swap are signaled to the host <b>97</b>A via the status register and in state <b>332</b> a timeout condition is signaled to the host. Otherwise, if no swap has occurred, control passes to state <b>334</b>.</p><p id="p-0062" num="0059">In a state <b>334</b>, the swap table <b>112</b> is modified to direct the system to obtain boot code from a redundant boot code copy of the boot code in memory bank 1 <b>160</b>B of the memory array <b>160</b>. Further, in a state <b>336</b>, the swap event can be signaled to the host <b>97</b>A using a status register, signal and/or interrupt so that the host can recover. Then, in a state <b>338</b>, the safety boot processes starts over with the swapped boot code by passing control to state <b>302</b>.</p><p id="p-0063" num="0060">Having described with reference to <figref idref="DRAWINGS">FIG. <b>3</b>B</figref> an example of an embedded automatically executing integrity verification with ECC hashing operation conducted using integrity mechanisms like that of <figref idref="DRAWINGS">FIG. <b>1</b></figref> next, an additional embodiment for embedded automatically executing integrity verification in which ECC is incorporated for the secure safety boot will next be described with reference to <figref idref="DRAWINGS">FIG. <b>3</b>C</figref>.</p><p id="p-0064" num="0000">Embedded Integrity Verification with ECC Hashing and Redundant Pages Bitmap Operations</p><p id="p-0065" num="0061"><figref idref="DRAWINGS">FIG. <b>3</b>C</figref> is a state diagram <b>300</b>C illustrating another implementation of an embedded integrity checking with ECC hashing operation for an embodiment of an integrated circuit memory device having an integrity maintenance mechanism like that of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. In <figref idref="DRAWINGS">FIG. <b>3</b>C</figref>, an alternative approach for the uncorrectable pages or subpages is depicted. It will resort to redundant ones immediately with a bitmap record of the error page. This bitmap is used to indicate whether a redundant page is being visited or not. The host <b>97</b>A can further leverage this bitmap to know the pages for recovery.</p><p id="p-0066" num="0062">In a state <b>302</b> a power on reset condition or a reset instruction or signal of the host <b>97</b>A to force the memory device <b>100</b> to reset as if it had experienced a power on event but without any actual power interruption having occurred, is detected and a start safety boot process is triggered.</p><p id="p-0067" num="0063">In a state <b>304</b>, the control logic <b>110</b> obtains a 2 Kbyte page of a current copy of the boot code in memory bank 0 <b>160</b>A of the memory array <b>160</b>.</p><p id="p-0068" num="0064">In a state <b>306</b>, the control logic <b>110</b> invokes ECC engine <b>114</b> to check for errors.</p><p id="p-0069" num="0065">In a state <b>308</b>, if an error is detected, then in a state <b>310</b> the ECC engine <b>114</b> determines if the error is correctable. If the error is not correctable, then in a state <b>312</b>, status bits appropriate to the condition are set in a status register of configuration and status register <b>81</b>. The error event can be signaled to the host <b>97</b>A using the status register, signal and/or interrupt enabling the host can recover. Then in a step <b>314</b>, a bitmap is marked to record the uncorrectable pages. In a state <b>316</b>, a redundant page is read out and control passes back to state <b>306</b> to apply the ECC to the redundant page just read.</p><p id="p-0070" num="0066">In a state <b>318</b> a status bit appropriate to correctable is set in a status register of configuration and status register <b>81</b>. The error event can be signaled to the host <b>97</b>A using the status register, signal and/or interrupt enabling the host can recover.</p><p id="p-0071" num="0067">In a state <b>320</b> the control logic <b>110</b> invokes the hash engine <b>115</b> to calculate a digest for the current copy of the boot code as read out so far.</p><p id="p-0072" num="0068">In a state <b>322</b>, a check is performed to see if the last page of the boot code has been read out. If not, control passes back to state <b>304</b> to read another page. Otherwise control passes to state <b>324</b>.</p><p id="p-0073" num="0069">In a state <b>324</b>, the control logic <b>110</b> locates a digest <b>116</b> that was determined for the boot code in NVM Secret area <b>113</b>, and compares the digest calculated for the current copy of the boot code in memory bank 0 <b>160</b>A of the memory array <b>160</b> with the digest <b>116</b> that was determined for the boot code retrieved from the NVM Secret area <b>113</b>. If the digest for the current copy and the digest <b>116</b> that was determined for the boot code retrieved from the NVM Secret area <b>113</b> do not match (e.g., are not equivalent, or are not similar within a tolerance), then control passes to state <b>326</b>. Otherwise, in a state <b>328</b>, a data image is readied for response to the host. In some implementations, no response is still a response from the point of view of host <b>97</b>A if the first operation of host <b>97</b>A is just trying to read boot code from memory device <b>100</b> without checking the status first, e.g., by reading ID or else contents of registers of configuration and a status registers <b>81</b>. In such case, one implementation of the memory device <b>100</b> outputs a NOP (No Operation which is defined by users through configuring memory device <b>100</b> at first use or during programming stage.), e.g., all 0 is one common form of NOP. This output of a NOP merely makes CPU/MCU run a dummy instruction cycle as a wait cycle. Thus, one implementation of the memory device <b>100</b> outputs a default NOP, e.g. all 0, at power on till internal reset and integrity check completes.</p><p id="p-0074" num="0070">In a state <b>326</b>, a decision is performed to see if a boot images have been swapped. If so, then in a state <b>330</b> the error and the swap are signaled to the host <b>97</b>A via the status register and in state <b>332</b> a timeout condition is signaled to the host. No output is returned in this case. Otherwise, control passes to state <b>334</b>.</p><p id="p-0075" num="0071">In a state <b>334</b>, the swap table <b>112</b> is modified to direct the system to obtain boot code from a redundant boot code copy of the boot code in memory bank 1 <b>160</b>B of the memory array <b>160</b>. Further, in a state <b>336</b>, the swap event can be signaled to the host <b>97</b>A using a status register, signal and/or interrupt so that the host can recover. Then, in a state <b>338</b>, the safety boot processes starts over with the swapped boot code by resetting the bitmap and passing control to state <b>302</b>.</p><p id="p-0076" num="0072">Having described with reference to <figref idref="DRAWINGS">FIG. <b>3</b>C</figref> an example of an embedded automatically executing integrity verification with ECC hashing operation and redundant bitmap conducted using integrity mechanisms like that of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, next, an on-the-fly integrity verification without ECC hashing operation conducted using like security mechanisms will be described with reference to state diagram of <figref idref="DRAWINGS">FIG. <b>4</b>A</figref>.</p><p id="p-0077" num="0000">On-the-Fly Integrity Verification without ECC Hashing Operations</p><p id="p-0078" num="0073">Now with reference to state diagram <b>400</b>A of <figref idref="DRAWINGS">FIG. <b>4</b>A</figref>, an example of an on-the-fly integrity checking without ECC hashing operation for a boot code data image will be described. <figref idref="DRAWINGS">FIG. <b>4</b>A</figref> depicts a state diagram <b>400</b>A illustrating an on-the-fly integrity checking without ECC hashing operation for an embodiment of an integrated circuit memory device <b>100</b> having an integrity maintenance mechanism like that of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. In <figref idref="DRAWINGS">FIG. <b>4</b>A</figref>, secure safety boot <b>111</b> of device <b>100</b> comprises an on-the-fly secure safety boot logic <b>401</b>, which is preferably implemented in logic circuitry. In a typical scenario, the host/system <b>97</b>A is started by execution of ROM stored code, e.g., &#x201c;first stage boot code&#x201d;, or code from embedded flash memory, to configure hardware and prepare to load into RAM on the system (rather than on the memory chip <b>100</b>) either bootloader, e.g., &#x201c;second stage boot code&#x201d;, or application residing in external flash (e.g., memory device <b>100</b>). The RAM on system may be the on-chip RAM of the host SoC (System on Chip, i.e., a group of processing units separately packaged, now brought together on a single chip) or external standalone RAM or DRAM chips on the system. As used herein, the &#x201c;embedded flash&#x201d; is flash memory inside the host SoC chip. As used herein, the &#x201c;external flash&#x201d; is an implementation of memory device <b>100</b> embodying the present technology. Some SoC or MCU chips are equipped with embedded flash for boot code or application(s). However, some employ ROM (Read Only Memory) as first stage boot code which is used to access the external second stage boot code or application resided in the external flash.</p><p id="p-0079" num="0074">In the case of on-the-fly examining of a boot code data image, the flash memory device <b>100</b> is about to feed the read data to the hash engine <b>115</b> only when host <b>97</b>A accesses the boot code and goes through entire boot code contiguously. If the flash memory device <b>100</b> detects any unexpectedly incontiguous access, it will reset the hash engine <b>115</b> and skip the comparison step.</p><p id="p-0080" num="0075">Therefore, users will configure the area in which the boot code is stored and then flash memory device <b>100</b> relies on this configuration to indicate where the boot code is stored and abort hash engine <b>115</b> if any access from outside the boot code area occurs. That means boot code area is contiguously accessed and copied from flash memory device <b>100</b> to the on-chip RAM or system RAM/DRAM of the host <b>97</b>A. Any other operations or accesses outside the boot code area will abort the hash comparison or just fail in integrity check.</p><p id="p-0081" num="0076">If the flash memory device <b>100</b> is accessed by host <b>97</b>A from the start of boot code, every portion of data read out will also be fed into the hash engine <b>115</b> for digest calculation until the end of the boot code is reached. Flash memory device <b>100</b> stores the length and area of boot code and redundant ones through users configuring the non-volatile registers <b>81</b>B. In some implementations, the host can check an integrity report from the memory device <b>100</b> via a status register or a signal pin after copying code to RAM but before executing. As described above, the host can either check the status registers regularly for each read operation or responsive to a physical signal. If a physical signal used to notify an event happened, the host can check the status by reading status registers. Of course, if the physical signal is an interrupt signal known by host hardware, any event on the interrupt signal will trigger an interrupt routine accordingly. If the integrity check has failed, in this implementation the operation to copy the boot code will start over copying the redundant boot code.</p><p id="p-0082" num="0077">In this implementation, the shadowing boot scenario is described. Typically, embodiments will follow a general shadowing boot flow comprising: (i) the host is booted from either ROM or embedded flash. This is the first boot stage. The purpose of first boot stage is to initialize host SoC/MCU internal registers and status, major hardware modules like flash interface controller, reset internal RAM, SRAM/DRAM controller, interrupt controller and so on; (ii) once the second stage boot code or application is copied from the flash memory device <b>100</b> to RAM, CPU/MCU will start to execute the program (boot code or application) from the RAM.</p><p id="p-0083" num="0078">In a state <b>402</b> a power on reset condition of the host <b>97</b>A or a request from host <b>97</b>A is detected/received and an on-the-fly secure safety boot process commences with as boot code begins to be copied (&#x201c;shadowed&#x201d;) from the flash memory device <b>100</b> to RAM memory of the host <b>97</b>A.</p><p id="p-0084" num="0079">In states <b>404</b> and <b>405</b>, responsive to the host <b>97</b>A requesting to read out boot code, one or more bytes (or words or blocks) of boot code from the current copy of the boot code is shadowed from memory bank 0 <b>160</b>A of the memory array <b>160</b> to the of the host <b>97</b>A.</p><p id="p-0085" num="0080">In a state <b>406</b>, hash engine <b>115</b> examines the bytes requested by the host in state <b>404</b>, updates a calculation of a digest, and outputs the bytes to the host responsive to the host's request. As shown in <figref idref="DRAWINGS">FIG. <b>7</b></figref>, in one implementation, every 512 bits (64 bytes) are fed into a compression function till the end of boot code with padded bits.</p><p id="p-0086" num="0081">In a state <b>422</b>, if additional read requests are received for boot code from the current copy of the boot code in memory bank 0 <b>160</b>A of the memory array <b>160</b> then control is passed back to state <b>404</b>. Otherwise, if no further boot code is requested to be read, control passes to state <b>424</b>.</p><p id="p-0087" num="0082">In a state <b>424</b>, the control logic <b>110</b> locates a digest for the boot code in NVM Secret area <b>113</b>, and compares the digest calculated for the current copy of the boot code in memory bank 0 <b>160</b>A of the memory array <b>160</b> with the digest for the boot code retrieved from the NVM Secret area <b>113</b>. The control logic <b>110</b> will determine that the current copy of the boot code in memory bank 0 <b>160</b>A of the memory array <b>160</b> passes integrity verification based upon a result of the compare. If the digest for the current copy and the digest for the boot code retrieved match (e.g., equivalent), then in a state <b>426</b>, copying and providing the data image of the that the current copy of the boot code in memory bank 0 <b>160</b>A of the memory array <b>160</b> is complete and in a state <b>428</b> the host executes the copy in RAM.</p><p id="p-0088" num="0083">Otherwise, if calculated and stored hash values do not match in state <b>424</b>, in a state <b>434</b>, the swap table <b>112</b> is modified to direct the addressing to obtain boot code from a redundant boot code copy of the boot code in memory bank 1 <b>160</b>B of the memory array <b>160</b>. Further, in a state <b>436</b>, the swap event is signaled to the host <b>97</b>A using a status register, signal and/or interrupt so that the host can recover. As described above, the host can either check the status registers regularly for each read operation or be signaled by an interrupt. If a physical signal used to notify the host that an event happened, the host can check the status by reading status registers. Of course, if the physical signal is an interrupt signal known by the host's hardware, any event on the interrupt signal will trigger an interrupt routine accordingly.</p><p id="p-0089" num="0084">In a state <b>438</b> the host receives the signal raised in state <b>436</b> and detects that an integrity failure has occurred. The host is aware of integrity check failure by <b>436</b> and in a state <b>440</b> restarts whole shadowing operation by reading again. But this time the address will be swapped and directed to redundant boot code because of state <b>434</b> where swap table is modified. The swap table could be volatile or non-volatile. For volatile swap table, there is a default area of boot code because the swap table is fixed once. For the non-volatile swap table, the default area of boot code is dependent on the swap table at the time. That means, the roles of default boot code and the redundant are not fixed and dependent on the swap table. And the modification operation is actually toggling the swap bit of swap table <b>202</b>, S<b>20</b>-S<b>10</b>, for example.</p><p id="p-0090" num="0085">Having described with reference to <figref idref="DRAWINGS">FIG. <b>4</b>A</figref> an example of an on-the-fly integrity checking without ECC hashing operation for a boot code data image implemented in mechanisms like that of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, next, an on-the-fly integrity checking with ECC hashing incorporated will next be described with reference to <figref idref="DRAWINGS">FIG. <b>4</b>B</figref>.</p><p id="p-0091" num="0000">On-the-Fly Integrity Verification with ECC Hashing Operations</p><p id="p-0092" num="0086">Now with reference to state diagram <b>400</b>B of <figref idref="DRAWINGS">FIG. <b>4</b>B</figref>, an example of an on-the-fly integrity checking with ECC hashing operation for a boot code data image will be described. <figref idref="DRAWINGS">FIG. <b>4</b>B</figref> depicts a state diagram <b>400</b>B illustrating an on-the-fly integrity checking with ECC hashing operation for an embodiment of an integrated circuit memory device <b>100</b> having an integrity maintenance mechanism like that of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. In <figref idref="DRAWINGS">FIG. <b>4</b>B</figref>, secure safety boot <b>111</b> of device <b>100</b> comprises an on-the-fly secure safety boot logic <b>401</b>, which is preferably implemented in logic circuitry. In a typical scenario, the host/system <b>97</b>A is started by execution of ROM stored code, or code from embedded flash memory, to configure hardware and prepare to load into RAM on the system (rather than on the memory chip <b>100</b>) either a bootloader or application residing in external flash (e.g., memory device <b>100</b>).</p><p id="p-0093" num="0087">In a state <b>402</b> a power on reset condition of the host <b>97</b>A or a request from host <b>97</b>A is detected/received and an on-the-fly secure safety boot process commences as boot code begins to be copied (&#x201c;shadowed&#x201d;) from the flash memory device <b>100</b> to RAM memory of the host <b>97</b>A.</p><p id="p-0094" num="0088">In states <b>404</b> and <b>405</b>, responsive to the host <b>97</b>A requesting to read out boot code, one or more bytes (or words or blocks) of boot code from the current copy of the boot code is shadowed from memory bank 0 <b>160</b>A of the memory array <b>160</b> to the of the host <b>97</b>A.</p><p id="p-0095" num="0089">In a state <b>406</b>, the control logic <b>110</b> invokes ECC engine <b>114</b> to check for errors. In a state <b>406</b>, ECC engine <b>114</b> examines the bytes requested by the host in state <b>404</b> for errors, corrects any errors that are correctable, and outputs the bytes to the host responsive to the host's request. As shown in <figref idref="DRAWINGS">FIG. <b>7</b></figref>, in one implementation, every 512 bits (64 bytes) are fed into a compression function till the end of boot code with padded bits.</p><p id="p-0096" num="0090">In a state <b>408</b>, if an error is detected, then in a state <b>410</b> the ECC engine <b>114</b> determines if the error is correctable. If the error is not correctable, then in a state <b>411</b> a decision is made whether the boot code is being read from a redundant page. If not, then in a state <b>412</b>, status bits appropriate to the condition are set in a status register of configuration and status register <b>81</b>. The error event can be signaled to the host <b>97</b>A using the status register, signal and/or interrupt enabling the host can recover. Then in a state <b>414</b>, a bitmap is marked to record the uncorrectable pages. In a state <b>416</b>, a redundant page is read out and control passes back to state <b>406</b> to apply the ECC to the redundant page just read. Otherwise, if the boot code is already being read from a redundant page in state <b>411</b>, then in a state <b>430</b> the error and the swap are signaled to the host <b>97</b>A via the status register and in state <b>432</b> a timeout condition is signaled to the host. No output is returned in this case.</p><p id="p-0097" num="0091">Otherwise, if the error is correctable in state <b>410</b>, control passes to a state <b>418</b>, in which a status bit appropriate to correctable is set in a status register of configuration and status register <b>81</b>. The error event can be signaled to the host <b>97</b>A using the status register, signal and/or interrupt enabling the host can recover.</p><p id="p-0098" num="0092">If there is no error in state <b>408</b>, or if there is an error but it is correctable in state <b>410</b>, then in a state <b>420</b> the control logic <b>110</b> invokes the hash engine <b>115</b> to calculate a digest for the current copy of the boot code as read out so far.</p><p id="p-0099" num="0093">In a state <b>422</b>, if additional read requests are received for boot code from the current copy of the boot code in memory bank 0 <b>160</b>A of the memory array <b>160</b> then control is passed back to state <b>404</b>. Otherwise, if no further boot code is requested to be read, control passes to state <b>424</b>.</p><p id="p-0100" num="0094">In a state <b>424</b>, the control logic <b>110</b> locates a digest for the boot code in NVM Secret area <b>113</b>, and compares the digest calculated for the current copy of the boot code in memory bank 0 <b>160</b>A of the memory array <b>160</b> with the digest for the boot code retrieved from the NVM Secret area <b>113</b>. The control logic <b>110</b> will determine that the current copy of the boot code in memory bank 0 <b>160</b>A of the memory array <b>160</b> passes integrity verification based upon a result of the compare. If the digest for the current copy and the digest for the boot code retrieved match (e.g., equivalent), then in a state <b>426</b>, copying and providing the data image of the that the current copy of the boot code in memory bank 0 <b>160</b>A of the memory array <b>160</b> is complete and in a state <b>428</b> the host executes the copy in RAM.</p><p id="p-0101" num="0095">Otherwise, if calculated and stored hash values do not match in state <b>424</b>, in a state <b>434</b>, the swap table <b>112</b> is modified to direct addressing to obtain boot code from a redundant boot code copy of the boot code in memory bank 1 <b>160</b>B of the memory array <b>160</b>. Further, in a state <b>436</b>, the swap event is signaled to the host <b>97</b>A using a status register, signal and/or interrupt so that the host can recover. As described above, the host can either check the status registers regularly for each read operation or be signaled by an interrupt. If a physical signal used to notify the host that an event happened, the host can check the status by reading status registers. Of course, if the physical signal is an interrupt signal known by the host's hardware, any event on the interrupt signal will trigger an interrupt routine accordingly.</p><p id="p-0102" num="0096">In a state <b>438</b> the host receives the signal raised in state <b>436</b> and detects that an integrity failure has occurred. The host is aware of integrity check failure by <b>436</b> and in a state <b>440</b> resets the bitmap and control passes to state <b>402</b> to restart the whole shadowing operation by reading again. But this time the address will have been swapped in state <b>434</b> where swap table is modified, so the read is directed to a redundant boot code copy.</p><p id="p-0103" num="0097">Having described with reference to <figref idref="DRAWINGS">FIG. <b>4</b>B</figref> an example of an on-the-fly integrity checking with ECC hashing operation for a boot code data image implemented in mechanisms like that of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, next, an on-the-fly integrity checking without ECC hashing using encrypted digests will next be described with reference to <figref idref="DRAWINGS">FIG. <b>5</b></figref>.</p><p id="p-0104" num="0000">On-the-Fly Integrity Verification with Encrypted Digests, without ECC Hashing Operations</p><p id="p-0105" num="0098">Now with reference to state diagram <b>500</b> of <figref idref="DRAWINGS">FIG. <b>5</b></figref>, <figref idref="DRAWINGS">FIG. <b>5</b></figref> is a state diagram illustrating an on-the-fly integrity checking operation without ECC using encrypted digests for an embodiment of an integrated circuit memory device <b>100</b> having an integrity maintenance mechanism like that of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. <figref idref="DRAWINGS">FIG. <b>5</b></figref> depicts a state diagram <b>500</b> illustrating an on-the-fly integrity checking operation, similar to the scenario depicted by <figref idref="DRAWINGS">FIG. <b>4</b></figref>. In <figref idref="DRAWINGS">FIG. <b>5</b></figref>, however, the flash memory receives an encryption key from the host, uses it to decrypt the stored hash digest for comparing the computed hash value when determining whether an integrity fault has been experienced. If the digest decrypts correctly, with only the correct key. That means the host is authenticated by providing the correct key. Here asymmetric key (public and private key pair) scheme can be used. The digest is encrypted by a public key when programming code into flash memory device <b>100</b>. And a private key is sent to flash memory device <b>100</b> for authentication through correctly decrypting the digest for integrity check before accessing boot code.</p><p id="p-0106" num="0099">In <figref idref="DRAWINGS">FIG. <b>5</b></figref>, secure safety boot <b>111</b> of device <b>100</b> comprises an on-the-fly secure safety boot logic <b>501</b>, which is preferably implemented in logic circuitry. In a typical scenario, the host/system <b>97</b>A is started by execution of ROM stored code, or code from embedded flash memory, to configure hardware and prepare to load either bootloader or application residing in external flash.</p><p id="p-0107" num="0100">In a state <b>501</b><i>a</i>, a decryption key is sent to the device <b>100</b> (e.g., a flash memory holding boot code) from host <b>97</b>A. In a state <b>501</b><i>b</i>, the memory device <b>100</b> uses the received key to decrypt the hash value in the digest and only the correct key will get the correct digest and then pass the comparison. Therefore, the memory device <b>100</b> authenticates host by digest comparison rather than checking the key received. Control passes to state <b>502</b>.</p><p id="p-0108" num="0101">In a state <b>502</b> a power on reset condition of the host <b>97</b>A or a request from host <b>97</b>A is detected/received and a boot code is copied (&#x201c;shadowed&#x201d;) to RAM memory of the host <b>97</b>A, external to the memory device <b>100</b>.</p><p id="p-0109" num="0102">In a state <b>504</b>, the host <b>97</b>A requests to read one or more bytes (or words or blocks) of boot code from the current copy of the boot code in memory bank 0 <b>160</b>A of the memory array <b>160</b> In a state <b>506</b>, hash engine <b>115</b> examines the bytes requested by the host in state <b>504</b>, updates a calculation of a digest, and outputs the bytes to the host responsive to the host's request. As shown in <figref idref="DRAWINGS">FIG. <b>7</b></figref>, in one implementation, every 512 bits (64 bytes) are fed into a compression function till the end of boot code with padded bits.</p><p id="p-0110" num="0103">In a state <b>508</b>, if additional read requests are received for boot code from the current copy of the boot code in memory bank 0 <b>160</b>A of the memory array <b>160</b> (RAM) then control is passed back to state <b>504</b>. Otherwise, if no further boot code is requested to be read, control passes to state <b>510</b>.</p><p id="p-0111" num="0104">In a state <b>510</b>, the control logic <b>110</b> compares the digest calculated for the current copy of the boot code in memory bank 0 <b>160</b>A of the memory array <b>160</b> with the decrypted digest for the boot code retrieved from the NVM Secret area <b>113</b>. The control logic <b>110</b> will determine that the current copy of the boot code in memory bank 0 <b>160</b>A of the memory array <b>160</b> passes integrity verification based upon a result of the compare. If the digest for the current copy and the decrypted digest for the boot code retrieved match (e.g., equivalent, or similar within a tolerance), then in a state <b>512</b>, copying and providing the data image of the that the current copy of the boot code in memory bank 0 <b>160</b>A of the memory array <b>160</b> is complete and in a state <b>514</b> the host executes the copy shadowed in the host's RAM.</p><p id="p-0112" num="0105">Otherwise, in a state <b>516</b>, the swap table <b>112</b> is modified to direct the addressing to obtain boot code from a redundant boot code copy of the boot code in memory bank 1 <b>160</b>B of the memory array <b>160</b>. Further, in a state <b>518</b>, the swap event is signaled to the host <b>97</b>A using a status register, signal and/or interrupt so that the host can recover. In a state <b>520</b> the host receives the signal raised in state <b>518</b> and detects that an integrity failure has occurred. In a state <b>522</b>, the redundant boot code copy of the boot code in memory bank 1 <b>160</b>B of the memory array <b>160</b> will be copied to the host's RAM and the next state is again state <b>502</b> to re-commence the process using the redundant boot code copy of the boot code in memory bank 1 <b>160</b>B of the memory array <b>160</b>.</p><heading id="h-0007" level="2">Other Integrity Verification Operations</heading><p id="p-0113" num="0106"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a flowchart illustrating maintaining integrity in a data image during operations of semiconductor memory like that of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. The device is not necessarily part of the method.</p><p id="p-0114" num="0107">In a block <b>602</b>, a read request is detected. The read request received from a host is to read a data image stored in a memory array of a semiconductor memory.</p><p id="p-0115" num="0108">In a block <b>604</b>, a hash calculation of the data image is conducted.</p><p id="p-0116" num="0109">In a block <b>606</b>, the hash calculation is compared with a stored hash calculation determined for the data image.</p><p id="p-0117" num="0110">In a block <b>610</b>, the host is alerted that the data image experienced an integrity examination fault whenever a discrepancy between the hash calculation and the stored hash calculation determined for the data image is detected.</p><p id="p-0118" num="0111">Optionally, in a block <b>608</b>, a second data image is swapped for the data image readout by the host, thereby further facilitating recovery from a detected integrity verification fault at a convenient time after booting successfully.</p><p id="p-0119" num="0112">Other implementations of the method described in this section can include a non-transitory computer readable storage medium storing instructions executable by a processor to perform any of the methods described above. Yet another implementation of the method described in this section can include a system including memory and one or more processors operable to execute instructions, stored in the memory, to perform any of the methods described above.</p><p id="p-0120" num="0113"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a state diagram illustrating an example secure hashing algorithm usable in an integrated circuit memory device having an integrity maintenance mechanism like that of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. In a typical scenario, responsive to a power on reset or a command by host/system <b>97</b>A, control logic <b>110</b> of memory device <b>100</b>, in the embedded flow of <figref idref="DRAWINGS">FIGS. <b>3</b>A-<b>3</b>B</figref> or conducted by the host in the on-the-fly flow of <figref idref="DRAWINGS">FIGS. <b>4</b>A-<b>4</b>B</figref> and <figref idref="DRAWINGS">FIG. <b>5</b></figref>, automatically commences reading data (<b>701</b> in <figref idref="DRAWINGS">FIG. <b>7</b></figref>) from a stored data image of boot instructions (or other valuable data) out of memory array <b>160</b>, computing a hash value <b>707</b> using a secure hashing algorithm, such as SHA2-256 (32 byte implementation), shown schematically by <figref idref="DRAWINGS">FIG. <b>7</b></figref>, or SHA2-512 (64 byte implementation).</p><p id="p-0121" num="0114">In a state <b>702</b> the input message <b>701</b> is padded with a 1 followed by a number of 0s in order to create a padded message <b>703</b> that fits into an integer number of blocks <b>705</b><i>a </i>. . . <b>705</b><i>n. </i></p><p id="p-0122" num="0115">Next, in states <b>708</b><i>a </i>. . . <b>708</b><i>n</i>, compression functions are applied to the blocks <b>705</b><i>a </i>. . . <b>705</b><i>n</i>. Each of states <b>708</b><i>b </i>. . . <b>708</b><i>n </i>takes as an input a result of a state <b>708</b><sub>(n-1)</sub>.</p><p id="p-0123" num="0116">State <b>708</b><i>a </i>takes as input an Initial hash value <b>703</b> as a &#x201c;seed&#x201d; value. Each of states <b>708</b><i>a </i>. . . <b>708</b><i>n </i>also takes a 512-bit message block from message blocks <b>705</b><i>a </i>. . . <b>705</b><i>n</i>. Each of states <b>708</b><i>a </i>. . . <b>708</b><i>n </i>applies algorithmic shuffling of hash values computed by a state <b>708</b><sub>(n-1) </sub>and a message block <b>705</b><i>a </i>. . . <b>705</b><i>n </i>and compressing the results to produce a 256 bit hash value as output for that state. The hash value output by the final state is returned as an output message <b>707</b>, comprising the hash value computed for the data image by the hash engine <b>112</b>. The digest may be calculated externally and also encrypted by a key (public key or a shared secret key). The boot code and the digest are then programmed into the memory device at the first use of the memory device in tandem with other configurations like boot area information, boot code length, embedded mode or on-the-fly mode, and generic setup. Of course, other sizes of blocks can be employed as well as other types of secure hashing algorithms as will be evident to those of skill in the art.</p><p id="p-0124" num="0117">Any data structures and code described or referenced above are stored according to many implementations on a computer-readable storage medium, which may be any device or medium that can store code and/or data for use by a computer system. This includes, but is not limited to, volatile memory, non-volatile memory, application-specific integrated circuits (ASICs), field-programmable gate arrays (FPGAs), magnetic and optical storage devices such as disk drives, magnetic tape, CDs (compact discs), DVDs (digital versatile discs or digital video discs), or other media capable of storing computer-readable media now known or later developed.</p><p id="p-0125" num="0118">A byte is a basic storage unit used in many integrated circuit logic and memory circuits, and consists of eight bits. Basic storage unit can have other sizes, including for example one bit, two bits, four bits, 16 bits and so on. Thus, the description of a hash logic circuitry and method set out above, and in other examples described herein utilizing the term byte, applies generally to circuits using different sizes of storage units, as would be described by replacing the term byte or set of bytes, with storage unit or set of storage units. Also, in some embodiments different sizes of storage units can be used in a single command sequence, such as one or more four bit storage units combined with eight bit storage units.</p><p id="p-0126" num="0119">A number of flowcharts illustrating logic executed by a memory controller or by memory device are described herein. The logic can be implemented using processors programmed using computer programs stored in memory accessible to the computer systems and executable by the processors, by dedicated logic hardware, including field programmable integrated circuits, and by combinations of dedicated logic hardware and computer programs. With all flowcharts herein, it will be appreciated that many of the steps can be combined, performed in parallel or performed in a different sequence without affecting the functions achieved. In some cases, as the reader will appreciate, a re-arrangement of steps will achieve the same results only if certain other changes are made as well. In other cases, as the reader will appreciate, a re-arrangement of steps will achieve the same results only if certain conditions are satisfied. Furthermore, it will be appreciated that the flow charts herein show only steps that are pertinent to an understanding of the invention, and it will be understood that numerous additional steps for accomplishing other functions can be performed before, after and between those shown.</p><p id="p-0127" num="0120">As used herein, a network node, including network nodes referred to as client side nodes and a server side nodes, is an active electronic device that is attached to a network, and is capable of sending, receiving, or forwarding information in support of computer programs such as servers and clients, over a physical media for a communications channel on the network, and having for example media access control addresses and protocol stacks that support higher network layers. A network can include the networks using Internet Protocol addresses, or other type of network layer addresses. In some embodiments the network comprises the Internet. Examples of electronic devices which can be deployed as network nodes, include all varieties of computers, workstations, laptop and desktop computers, hand-held computers and smart phones, and execute computer programs.</p><p id="p-0128" num="0121">A device having a controller logic circuitry, and a method responsive to any one of a reset command, a power on reset, and a command sequence including a memory read command, are described herein.</p><p id="p-0129" num="0122">A device having a controller logic circuitry, and a method responsive to any one of a reset command, a power on reset, and a command sequence including a memory read command, are described, including responsively examining integrity of a data image.</p><p id="p-0130" num="0123">A device having a controller logic circuitry, and a method responsive to any one of a reset command, a power on reset, and a command sequence including a memory read command, are described, including responsively examining integrity of a data image by conducting a hash calculation of the data image, comparing the hash calculation with a stored hash calculation determined for the data image and alerting a host that the data image experienced an integrity examination fault whenever a discrepancy between the hash calculation and the stored hash calculation determined for the data image is detected.</p><p id="p-0131" num="0124">A device having a controller logic circuitry, and a method responsive to any one of a reset command, a power on reset, and a command sequence including a memory read command, are described, including responsively examining integrity of a data image of boot instructions for a host by conducting a hash calculation of a first data image comprising boot instructions for the host; and comparing the hash calculation with a stored hash calculation determined for the first data image; and alerting the host that the first data image experienced an integrity examination fault whenever a discrepancy between the hash calculation and the stored hash calculation determined for the first data image is detected.</p><p id="p-0132" num="0125">A device having a controller logic circuitry, and a method responsive to any one of a reset command, a power on reset, and a command sequence including a memory read command, are described, including responsively examining integrity of a data image of boot instructions for a host by conducting a hash calculation of a first data image comprising boot instructions for the host; and comparing the hash calculation with a stored hash calculation determined for the first data image; and alerting the host that the first data image experienced an integrity examination fault whenever a discrepancy between the hash calculation and the stored hash calculation determined for the first data image is detected; and either (i) in an embedded flow, swapping a data image comprising a redundant copy of the data image stored in the second bank for the data image in the first memory bank whenever a discrepancy between the hash calculation and a stored hash calculation determined for the data image is detected; or (ii) in an on-the-fly-flow, the host issuing a read operation to access the boot code again from the beginning for the swapped data image comprising a redundant copy of the data image stored in the second bank for the data image if a discrepancy of hash is detected. It is not necessary to store the redundant copy or second data image in the second bank. That means both first and second can be either in the same bank or in different banks. Of course, implementations can achieve benefits in performance and circuit implementation for using different banks.</p><p id="p-0133" num="0126">A device having a controller logic circuitry, and a method responsive to any one of a reset command, a power on reset, and a command sequence including a memory read command, are described, including responsively examining integrity of a data image of boot instructions for a host by conducting a hash calculation of a first data image comprising boot instructions for the host; and comparing the hash calculation with a stored hash calculation determined for the first data image; and alerting the host that the first data image experienced an integrity examination fault whenever a discrepancy between the hash calculation and the stored hash calculation determined for the first data image is detected; and either (i) in an embedded flow, swapping a second data image stored in a second memory bank for the first data image in the first memory bank whenever a discrepancy between the hash calculation and a stored hash calculation determined for the first data image is detected; or (ii) in an on-the-fly-flow, the host issuing a read operation to access the boot code again from the beginning for the swapped data image comprising a redundant copy of the data image stored in the second bank for the data image if a discrepancy of hash is detected. It is not necessary to store the redundant copy or second data image in the second bank. That means both first and second can be either in the same bank or in different banks. Of course, implementations can achieve benefits in performance and circuit implementation for using different banks.</p><p id="p-0134" num="0127">While the present invention is disclosed by reference to the preferred embodiments and examples detailed above, it is to be understood that these examples are intended in an illustrative rather than in a limiting sense. It is contemplated that modifications and combinations will readily occur to those skilled in the art, which modifications and combinations will be within the spirit of the invention and the scope of the following claims.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A memory device, comprising:<claim-text>a plurality of non-volatile registers storing address information for a first copy boot code and at least one redundant copy boot code stored in a memory array;</claim-text><claim-text>a non-volatile storage area that keeps a hash digest;</claim-text><claim-text>an input/output interface for posting internal status register states to I/O data units;</claim-text><claim-text>data path circuits connected between non-volatile registers, the memory array, the non-volatile storage area, and the input/output interface; and</claim-text><claim-text>logic circuitry that examines integrity of the first copy boot code stored in the memory array by comparing a hash calculation of the first copy boot code and a stored hash calculation determined and stored in the non-volatile storage area holding the hash digest kept and to provide as output one selected from the first copy boot code or the redundant copy boot code in accordance with an integrity examination result.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The memory device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further including an error correcting code (ECC) circuit, and wherein the logic circuitry implements a first tier hash comprising a page-based or a sub-page based ECC determining an initial integrity of the first copy boot code.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The memory device of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the logic circuitry further implements swapping the at least one redundant copy boot code whenever the ECC indicates a failed integrity of the first copy boot code; and<claim-text>notifying a host by at least one of an interrupt and a status register.</claim-text></claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The memory device of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein logic circuitry implements a second tier hash using a message digest algorithm for integrity checking an entirety of the first copy boot code.</claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The memory device of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein logic circuitry implements a second tier hash, the logic circuitry further implementing starting over from the at least one redundant copy boot code when errors are found within the first copy boot code.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The memory device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further including logic circuitry that conducts an embedded flow at power on reset command or reset signal received and prior to responding any requests or commands, wherein the embedded flow includes responsive to a power on reset command or reset signal, checking integrity of the first copy boot code and swapping, whenever a failed integrity check is detected, to at least one redundant copy boot code.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The memory device of <claim-ref idref="CLM-00006">claim 6</claim-ref>, further including an error correcting code (ECC) circuit, and wherein the logic circuitry further implements a first tier hash comprising a page-based or a sub-page based ECC determining an initial integrity of the first copy boot code.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The memory device of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the logic circuitry further implements marking a bitmap for an error encountered in a page of the first copy boot code and swapping a corresponding one of the at least one redundant copy boot code whenever the ECC indicates a failed integrity of the first copy boot code.</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The memory device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further including logic circuitry that conducts an on-the-fly flow at power on reset command or reset signal received in response to requests or commands, wherein the on-the-fly flow includes responsive to a read request, checking integrity of the first copy boot code and swapping, whenever a failed integrity check is detected, to at least one redundant copy boot code.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The memory device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further including a swap table maintained in non-volatile storage; and wherein the logic circuitry uses the swap table to determine a default first copy boot code to load.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The memory device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further including a bitmap maintained in storage; and wherein the logic circuitry uses the bitmap to track swapped pages swapped from the at least one redundant copy boot code and the first copy boot code.</claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The memory device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further including logic circuitry to decrypt the hash digest prior to integrity checking by:<claim-text>receiving a key from a host;</claim-text><claim-text>decrypting the hash digest using the key received; and</claim-text><claim-text>failing the hash digest whenever a wrong key is provided.</claim-text></claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The memory device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further including logic circuitry that provides an interrupt signal notifying a host to check status registers for status updates within the memory device.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The memory device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further including the logic circuitry dividing the first copy boot code into parts and for each part maintaining a separate hash digest only for that part.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The memory device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further including storing the first copy boot code and the at least one redundant copy boot code into different banks, each with its own Sense Amplifier and Buffer; thereby enabling each to operate at least partially concurrently with one another.</claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The memory device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further including the logic circuitry implementing responsive to receiving a command, conducting integrity checking of one or more of the first copy boot code and the at least one redundant copy boot code.</claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The memory device of <claim-ref idref="CLM-00002">claim 2</claim-ref>, further including the error correcting code (ECC) correcting some errors, and further including logic circuitry that checks whether the errors are correctable; and swaps redundant copy boot code portions only when errors are not correctable.</claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The memory device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further including logic circuitry that alerts a host that the first copy boot code or the redundant copy boot code experienced an integrity examination fault whenever a discrepancy between the hash calculation and the stored hash calculation is detected.</claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The memory device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein redundant copy boot code is different from the first copy boot code.</claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. A method for maintaining integrity in a data image during operations of semiconductor memory, the method comprising:<claim-text>storing in a plurality of non-volatile registers, address information of a first copy boot code and at least one redundant copy boot code stored in a memory array;</claim-text><claim-text>keeping in a non-volatile storage area, a plurality of hash digests for the first copy boot code and at least one redundant copy boot code;</claim-text><claim-text>posting to an input/output interface to an I/O data unit, internal status register states; and</claim-text><claim-text>examining by logic circuitry integrity of the first copy boot code stored in the memory array by:<claim-text>comparing a hash calculation of the first copy boot code and a stored hash calculation as determined and as stored in the non-volatile storage area holding the plurality of hash digests as kept; and</claim-text><claim-text>providing as output one selected from the first copy boot code and the redundant copy boot code in accordance with an integrity examination result; and</claim-text></claim-text><claim-text>alerting a host that the first copy boot code or the redundant copy boot code as selected experienced an integrity examination fault whenever a discrepancy between the hash calculation and the stored hash calculation is detected.</claim-text></claim-text></claim><claim id="CLM-00021" num="00021"><claim-text><b>21</b>. The method of <claim-ref idref="CLM-00020">claim 20</claim-ref>, wherein examining by logic circuitry integrity of the first copy boot code stored further includes making a first tier integrity check using an error correcting code (ECC) and a second tier integrity check using a message hashing algorithm.</claim-text></claim></claims></us-patent-application>