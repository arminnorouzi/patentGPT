<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004442A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004442</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17903084</doc-number><date>20220906</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>50</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20160101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0815</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20180101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>38</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20180101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>455</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>5061</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0815</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>3877</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>45545</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>5044</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>45558</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>2009</main-group><subgroup>4557</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">CACHE COHERENT ACCELERATION FUNCTION VIRTUALIZATION</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>16582958</doc-number><date>20190925</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11474871</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17903084</doc-number></document-id></child-doc></relation></continuation></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>XILINX, INC.</orgname><address><city>San Jose</city><state>CA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>MITTAL</last-name><first-name>Millind</first-name><address><city>Saratoga</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>DASTIDAR</last-name><first-name>Jaideep</first-name><address><city>San Jose</city><state>CA</state><country>US</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">The embodiments herein describe a virtualization framework for cache coherent accelerators where the framework incorporates a layered approach for accelerators in their interactions between a cache coherent protocol layer and the functions performed by the accelerator. In one embodiment, the virtualization framework includes a first layer containing the different instances of accelerator functions (AFs), a second layer containing accelerator function engines (AFE) in each of the AFs, and a third layer containing accelerator function threads (AFTs) in each of the AFEs. Partitioning the hardware circuitry using multiple layers in the virtualization framework allows the accelerator to be quickly re-provisioned in response to requests made by guest operation systems or virtual machines executing in a host. Further, using the layers to partition the hardware permits the host to re-provision sub-portions of the accelerator while the remaining portions of the accelerator continue to operate as normal.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="136.65mm" wi="158.75mm" file="US20230004442A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="215.31mm" wi="148.93mm" orientation="landscape" file="US20230004442A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="215.31mm" wi="148.93mm" orientation="landscape" file="US20230004442A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="239.86mm" wi="134.45mm" orientation="landscape" file="US20230004442A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="111.17mm" wi="118.45mm" file="US20230004442A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="160.78mm" wi="161.63mm" file="US20230004442A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="155.36mm" wi="149.27mm" file="US20230004442A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="217.00mm" wi="148.76mm" file="US20230004442A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">CROSS REFERENCE TO RELATED APPLICATION</heading><p id="p-0002" num="0001">This application is a continuation of U.S. Non-Provisional application Ser. No. 16/582,958, filed on Sep. 25, 2019 of which is incorporated herein by reference in its entirety.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">TECHNICAL FIELD</heading><p id="p-0003" num="0002">Examples of the present disclosure generally relate to provisioning an accelerator into hierarchical layers for performing virtualization.</p><heading id="h-0003" level="1">BACKGROUND</heading><p id="p-0004" num="0003">Server CPU-Accelerator systems, such as those enabled by the Compute eXpress Link (CXL), Cache Coherent Interconnect for Accelerators (CCIX), QuickPath Interconnect/Ultra Path Interconnect (QPI/UPI), Infinity Fabric, NVLink&#x2122;, and Open Coherent Accelerator Processor Interface (OpenCAPI) connected SoCs are all hardware cache coherent systems&#x2014;i.e. the hardware maintains a universal, coherent view of accessed, modified, and cached data. Virtualization has subdivided resources in the server CPU side of these systems (e.g., hosts) into progressively smaller resources (e.g., virtual machines (VMs), guest operating systems (OSs), and containers) which may exist for shorter durations. For example, a VM may have a life span at least two to four orders of magnitude longer than the life span of a container, e.g., a VM can have a lifespan of several hours to months versus only several seconds for a container. Furthermore, guest operating systems (OSs) in a VM may have a boot time four to six orders of magnitude longer than the startup time of a container, e.g., several minutes of OS boot time versus only a few milliseconds of a container's start time.</p><p id="p-0005" num="0004">Accelerators, such as graphics processing units (GPUs) or field programmable gate array (FPGAs) cards can be virtualized and provisioned in a time-division multiplexed manner to a guest OS or VM executing in a host. In prior techniques, accelerators are also presented with a singular accelerator function capability, e.g., a GPU or FPGA with a fixed bitstream corresponding to that singular acceleration function. The disadvantage is that the SPU or FPGA accelerator must be re-provisioned to represent a different accelerator function. Re-provisioning can take several minutes. When the life of some virtual components in the host are several seconds and their startup time is measured in milliseconds, spending several minutes to re-provision the accelerator so the accelerator can be used by the virtual component is not practical.</p><heading id="h-0004" level="1">SUMMARY</heading><p id="p-0006" num="0005">Techniques for performing virtualization using an accelerator. One example is a method that includes binding a plurality of accelerator functions (AFs) in the accelerator to one or more request agents (RAs) where the plurality of functions is in an AF layer and the one or more RAs are in a cache coherent protocol layer. The method also includes assigning the plurality of AFs to a hypervisor executing in a host, assigning a plurality of guest operating systems (OSs) to AF engines (AFEs) in the plurality of AFs, wherein the AFEs are in an AFE layer, and assigning AF threads (AFTs) in the AFEs to application threads executing in the plurality of guest OSs where the AFTs are in an AFT layer and the AF layer, the AFE layer, and the AFT layer hierarchically partition hardware circuitry in the accelerator.</p><p id="p-0007" num="0006">Another example is an accelerator that includes one or more RAs configured to permit the accelerator to communicate with a cache coherent network and hardware circuitry partitioned into hierarchical layers that includes an AF layer, an AFE layer, and an AFT layer Further, the AF layer includes a plurality of AFs bound to the one or more RAs, the AFE layer includes AFEs in the plurality of AFs, and the AFT layer includes AFTs in the AFEs. Further, the plurality of AFs and AFEs are assignable to guest OSs executing in a host that is separate from the accelerator, and the AFTs are assignable to application threads executing in the guest OSs.</p><p id="p-0008" num="0007">Another example is a cache coherent system that includes a host that includes a hypervisor and a plurality of VMs. The system also includes an accelerator that includes one or more RAs configured to permit the accelerator to communicate with a cache coherent network and hardware circuitry partitioned into a plurality of AFs, a plurality of AFEs in each of the plurality of AFs, and a plurality of AFTs in each of the plurality of AFEs where the plurality of AFs is bound to the one or more RAs. Further, the plurality of AFs and AFEs are assignable to the plurality of VMs, and the AFTs are assignable to application threads executing in the plurality of VMs.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0005" level="1">BRIEF DESCRIPTION OF DRAWINGS</heading><p id="p-0009" num="0008">So that the manner in which the above recited features can be understood in detail, a more particular description, briefly summarized above, may be had by reference to example implementations, some of which are illustrated in the appended drawings. It is to be noted, however, that the appended drawings illustrate only typical example implementations and are therefore not to be considered limiting of its scope.</p><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIGS. <b>1</b>A and <b>1</b>B</figref> are block diagrams of cache coherent systems where an accelerator is divided into hierarchical layers, according to an example.</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates the hierarchical layers partitioning the accelerator, according to an example.</p><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a flowchart for partitioning an accelerator into hierarchical layers, according to an example.</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a flowchart for assigning virtual components executing in a host to the hierarchical layers in an accelerator, according to an example.</p><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a flowchart for re-provisioning the hierarchical layers in an accelerator, according to an example.</p><p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a default configuration of an accelerator, according to an example.</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIGS. <b>7</b>A-<b>7</b>C</figref> illustrate re-provisioning the default configuration illustrated in <figref idref="DRAWINGS">FIG. <b>6</b></figref>, according to several examples.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0006" level="1">DETAILED DESCRIPTION</heading><p id="p-0017" num="0016">Various features are described hereinafter with reference to the figures. It should be noted that the figures may or may not be drawn to scale and that the elements of similar structures or functions are represented by like reference numerals throughout the figures. It should be noted that the figures are only intended to facilitate the description of the various features. They are not intended as an exhaustive description or as a limitation on the scope of the claims. In addition, an illustrated example need not have all the aspects or advantages shown. An aspect or an advantage described in conjunction with a particular example is not necessarily limited to that example and can be practiced in any other examples even if not so illustrated, or if not so explicitly described.</p><p id="p-0018" num="0017">The embodiments herein describe a virtualization framework for cache coherent accelerators where the framework incorporates a layered approach for accelerators in their interactions between a cache coherent protocol layer (or interface) and the functions performed by the accelerator. In one embodiment, the virtualization framework includes a first layer containing different instances of accelerator functions (AFs), a second layer containing accelerator function engines (AFE) in each of the AFs, and a third layer containing accelerator function threads (AFTs) in each of the AFEs. Partitioning the hardware circuitry using multiple layers in the virtualization framework allows the accelerator to be quickly re-provisioned (within milliseconds) in response to requests made by guest OSs or VMs executing in a host. Further, using the layers to partition the hardware permits the host to re-provision sub-portions of the accelerator while the remaining portions of the accelerator can operate as normal&#x2014;e.g., without interruption.</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>1</b>A</figref> is a block diagram of a cache coherent system <b>100</b> where an accelerator <b>150</b> is divided into hierarchical layers, according to an example. As shown, the cache coherent system <b>100</b> includes a host <b>105</b> (e.g., a server or other computing device) that is communicatively coupled to the accelerator <b>150</b>. In one embodiment, the cache coherent system <b>100</b> uses a cache coherent protocol such as CXL, CCIX, QPI/UPI, AMD Infinity Fabric, NVLink, and OpenCAPI so that the hardware maintains a universal, coherent view of accessed, modified, and cached data in the host <b>105</b> and the accelerator <b>150</b>.</p><p id="p-0020" num="0019">The host <b>105</b> includes a processor <b>110</b> and memory <b>115</b>. The processor <b>110</b> represents any number of processing elements (e.g., CPUs) that can include any number of processing cores. The memory <b>115</b> can include volatile memory elements, non-volatile memory elements, and combinations thereof. In this example, the memory <b>115</b> stores several virtual components that are created as part of performing virtualization&#x2014;e.g., where the physical hardware in the host <b>105</b> is subdivided and assigned to several virtual components such as guest OS <b>125</b>. The memory <b>115</b> also includes a hypervisor <b>120</b> that serves as an interface between the virtual components and the hardware in the host <b>105</b>. The hypervisor <b>120</b> can create, schedule, manage, boot, and launch the guest OSs <b>125</b> (which can also be referred to as VMs).</p><p id="p-0021" num="0020">The guest OS <b>125</b> includes the applications <b>135</b>. That is, the host <b>105</b> is virtualized such that the resources in the host <b>105</b> can be subdivided among a plurality of guest OS <b>125</b> (e.g., VMs)</p><p id="p-0022" num="0021">The accelerator <b>150</b> includes hardware circuitry <b>155</b> which is partitioned (or subdivided) by hierarchical layers that include an acceleration function (AF) layer <b>165</b> that includes an AF engine (AFE) layer <b>170</b> that in turn includes an AF thread (AFT) layer <b>175</b>. In one embodiment, if the accelerator <b>150</b> is a FPGA, the hardware circuitry <b>155</b> may include programmable logic (e.g., look-up tables and configuration blocks). However, the hardware circuitry <b>155</b> may also include a combination of hardened circuitry and programmable logic. If the accelerator <b>150</b> is a GPU or other type of accelerator, the hardware circuitry <b>155</b> may include only hardened circuitry. Further, while the embodiments herein describe using the hierarchical layers to partition hardware, firmware and software associated with the hardware circuitry <b>155</b> may also be partitioned into the layers.</p><p id="p-0023" num="0022">The AF layer <b>165</b> includes one or more AFs that describe a high-level function performed by the accelerator. For example, an FPGA can perform multiple different types of functions simultaneously (e.g., data compression, encryption/decryption, security authentication, network acceleration, and the like). The functions can each by categorized as a different AF being performed by the accelerator <b>150</b>. Moreover, even if an accelerator <b>150</b> does only one type of function, the AF layer <b>165</b> can include different instances of that AF&#x2014;e.g., the AF layer <b>165</b> can include three AFs that perform image processing in a GPU. As described in more detail below, the various AFs in the AF layer <b>165</b> can be assigned to different guest OSs <b>125</b> in the host <b>105</b>. In one embodiment, each AF may be assigned to only one guest OS <b>125</b>, while in other examples, multiple guest OSs <b>125</b> are assigned to the same AF in the layer <b>165</b>.</p><p id="p-0024" num="0023">The AFE layer <b>170</b> contains multiple AFEs that are assigned to the different AFs in the AF layer <b>165</b>. The AFEs represent portions of the hardware circuitry <b>155</b> that are assigned to do a specific AF. For example, a compression AF may have four AFEs that can perform compression operations in parallel. That is, the AFEs can operate independent of each other. In one embodiment, an AFE is assigned to only one guest OS <b>125</b>. That is, unlike in the AF layer <b>165</b> where multiple OSs <b>125</b> can be assigned to the same AF, in the AFE layer <b>170</b> only one guest OS <b>125</b> can be assigned to a particular AFE. This restriction may be desired in order to increase security, privacy, and reliability between guest OSs <b>125</b>. That is, if one AFE fails, it does not affect other guest OSs <b>125</b>. Further, assigning the guest OSs <b>125</b> to different AFEs can facilitate keeping data for applications <b>135</b> executed by different guest OSs <b>125</b> separate.</p><p id="p-0025" num="0024">The AFT layer <b>175</b> includes threads that execute on the AFEs. For example, the AFEs may execute up to 32 threads. Further, the number of threads may vary depending on the AF. For example, an AFE in a compression AF may be able to execute more threads than an AFE in a security AF. In one embodiment, a guest OS <b>125</b> assigns the threads to different threads of the application <b>135</b>. For example, the guest OS <b>125</b> may assign an application thread to a thread from the AFT layer <b>175</b>. In one embodiment, each AFE can execute one thread at a time. For example, a scheduler in the accelerator <b>150</b> can perform time multiplexing to determine which of the <b>32</b> threads the AFE executes.</p><p id="p-0026" num="0025">In this manner, the resources in the accelerator <b>150</b> (e.g., the hardware circuitry <b>155</b>) can be subdivided and assigned to virtual components in the host <b>105</b>. As discussed in more detail below, partitioning the resources in the accelerator <b>150</b> into hierarchical layers can reduce the time delay when re-provisioning the accelerator <b>150</b> to satisfy requests made by the guest OSs <b>125</b>.</p><p id="p-0027" num="0026">The accelerator <b>150</b> also includes a request agent (RA) <b>160</b> which is part of a cache coherent protocol layer that interfaces with the AF layer <b>165</b>. In one embodiment, the RA <b>160</b> acts in behalf of the AFs in the AF layer <b>165</b> when communicating with a cache coherent network. The accelerator <b>150</b> can include any number of RAs <b>160</b>. If the hardware circuitry <b>155</b> includes programmable logic, the accelerator <b>150</b> can be reconfigured dynamically to change the number of RAs <b>160</b>.</p><p id="p-0028" num="0027">In one embodiment, the accelerator <b>150</b> includes one or more integrated circuits (ICs). If the IC contains programmable logic, the IC is referred to as a programmable IC (e.g., an FPGA). In other examples, the accelerator <b>150</b> can include a system on a chip (SoC). The SoC can also include programmable logic as well as hardened circuitry.</p><p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. <b>1</b>B</figref> is similar to <figref idref="DRAWINGS">FIG. <b>1</b>A</figref> except that the virtualization framework includes a local OS <b>180</b> and containers <b>190</b> rather than a hypervisor and guest OSs. The OS <b>180</b> manages the physical resources in the system <b>100</b>. The memory <b>115</b> also includes a container manager <b>185</b> that creates, schedules, manages, and launches the containers <b>190</b>.</p><p id="p-0030" num="0029">In one embodiment, the containers <b>190</b> are predefined packages of resources in the host <b>105</b> such as a certain number of compute cycles of the processor <b>110</b> and a portion of the memory <b>115</b>. The container manager <b>185</b> can assign these containers <b>10</b> to the applications <b>135</b> so the applications <b>135</b> can execute on the host <b>105</b>. That is, the host <b>105</b> is virtualized such that the resources in the host <b>105</b> can be subdivided among a plurality of containers <b>190</b>. The container manager <b>185</b> can assign threads of the applications <b>135</b> (i.e., application threads) to the containers <b>190</b> for execution.</p><p id="p-0031" num="0030">Like the guest OSs in <figref idref="DRAWINGS">FIG. <b>1</b>A</figref>, the containers <b>190</b> can be assigned to different AFEs. The containers <b>190</b> can then assign the threads in the corresponding AFT layer <b>175</b> to different application threads. In this manner, the resources in the accelerator <b>150</b> (e.g., the hardware circuitry <b>155</b>) can be subdivided and assigned to virtual components in the host <b>105</b>.</p><p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates the hierarchical layers partitioning the accelerator, according to an example. <figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates the AF layer <b>165</b>, the AFE layer <b>170</b>, and the AFT layer <b>175</b> in a particular configuration. As shown, the AF layer <b>165</b> includes 1-X number of AFs <b>210</b>&#x2014;i.e., AF0, AF1, . . . , AFX. The AF0 in turn includes 1-X number of AFEs <b>215</b>&#x2014;i.e., AFE0, AFE1, . . . , AFEX. While only the AFEs in AF0 are shown, AF1-AFX can also have any number of AFEs (which may the same number or a different number than the AFEs in the other AFs).</p><p id="p-0033" num="0032">Each AFE0-AFEX includes 1-X number of AFTs <b>220</b>&#x2014;i.e., AFT0, AFT1, . . . AFTX. Each of the AFEs can have the same number of AFTs or a different number of threads. Thus, <figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates how the underlying hardware in the accelerator can be partitioned to form the AFs <b>210</b>, AFEs <b>215</b>, and AFTs <b>220</b> in the layers <b>165</b>, <b>170</b>, and <b>175</b>. As discussed in more detail below, the numbers of AFs <b>210</b>, AFEs <b>215</b>, and AFTs <b>220</b> and can be dynamically re-provisioned in response to requests made by the guest OSs (and the applications being executed on the guest OSs). Advantageously, this re-provisioning can occur in milliseconds rather than minutes when using prior virtualization techniques.</p><p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. <b>2</b></figref> also includes a cache coherent protocol layer <b>205</b> which interfaces with the AF layer <b>165</b>. The cache coherent protocol layer <b>205</b> includes the RAs <b>160</b> in the accelerator. In one embodiment, the RAs <b>160</b> are bound to the AFs <b>210</b> and permit the AFs (and the remaining upper layers in the hierarchy) to communicate with other computing systems in the cache coherent system. Thus, in one embodiment, the AF layer <b>165</b> is an interface between the cache coherent protocol layer <b>205</b> and the AFE layer <b>170</b>. The AFE layer <b>170</b> is in turn an interface between the AF layer <b>165</b> and the AFT layer <b>175</b>.</p><p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a flowchart of a method <b>300</b> for partitioning an accelerator into hierarchical layers, according to an example. At block <b>305</b>, the accelerator <b>150</b> binds the AFs in the accelerator to one or more RAs. As mentioned above, the AFs can represent different acceleration functions (e.g., data compression, data encryption/decryption, security authentication, machine learning algorithms, and the like) or different instances of the same function. The AFs in the AF layer in the accelerator can use the RAs in the cache coherent protocol layer to communicate with other computing systems in the same cache coherent protocol network, such as the host. In one embodiment, multiples AFs are bound to the same RA. Alternatively, each AF can be bound to a respective one of the RAs in the accelerator. In either case, the RA represents (or acts in behalf of) the AF(s) in the cache coherent protocol network.</p><p id="p-0036" num="0035">In one embodiment, the hierarchical layers in the accelerator are established using single root input/output virtualization (SR-IOV) as a framework. SR-IOV is a specification that allows the isolation of PCIe resources to improve manageability and performance. A single physical PCIe connection can be shared in a virtual environment using SR-IOV so that different guest OSs (VMs) can share a single PCIe hardware interface. In SR-IOV, the RAs and the AFs in the accelerator are both physical functions (PFs). In one embodiment, the hypervisor (or a container manager as is the case in <figref idref="DRAWINGS">FIG. <b>1</b>B</figref>) tracks the RAs and the AFs as PFs and is informed what RAs are bound to what AFs. Once the virtualization framework within the SR-IOV framework is established, the data can flow in the accelerator function virtualization framework established by the hierarchical layers. However, SR-IOV is just one example of an underlying framework that can be used to establish the hierarchical layers in the virtualization framework described herein. The hierarchical layers can be established using other communication frameworks using different communication protocols than PCIe.</p><p id="p-0037" num="0036">At block <b>310</b>, a bitstream loaded into the accelerator, that defines the function performed by the AFs, is assigned to the hypervisor or the container manager depending on whether the virtualization framework in <figref idref="DRAWINGS">FIG. <b>1</b>A</figref> or <figref idref="DRAWINGS">FIG. <b>1</b>B</figref> is used. In one embodiment, assuming SR-IOV is used, the hypervisor/container manager tracks the RAs and the AFs as PFs and is informed what RAs are bound to what AFs. Because AF is a PF, the hypervisor or container manager can assign the different AFs to guest OSs or containers it manages in the host. For example, each guest OS can be assigned a respective one of the AFs. Alternatively, multiple guest OSs can be assigned to the same AF.</p><p id="p-0038" num="0037">In one embodiment, the hypervisor or container manager manages the global resources and functions of the AFs. The AFs can include respective acceleration function global management states that are set by the hypervisor. Each AF is defined by this state in addition to the number and types of AFEs it contains. In one embodiment, the hypervisor or container manager has AF global controls that can, for example, enable or disable an AF, change the power states of the AFs reduce its power consumption), and change the AF to RA bindings (e.g., to increase or reduce either of the Acceleration Function or Cache Coherent Protocol Layer capabilities).</p><p id="p-0039" num="0038">At block <b>315</b>, the hypervisor or container manager assigns guest OSs or containers to AFEs in the AFs. The guest OSs or containers manage each resources and functions of the assigned AFEs. The AFEs are defined by respective AFE management states (which are controlled by the assigned guest OS or container) in addition to the one or more AFTs supported by the AFE. In one embodiment, only one guest OS or container is assigned to an AFE, but this may be done for security and reliability reasons and is not a requirement. Further, each AFE can have a unique AFE ID, which if PCIe is used as the underlying framework, may be a unique BDF (Bus, Device, Function number). In one embodiment, the guest OSs can use AFE controls to enable or disable assigned AFEs, change the power state of the AFEs, and change the AFE to AF assignments.</p><p id="p-0040" num="0039">In one embodiment, one AFE in each AF is assigned to a driver owned by the hypervisor rather than to a guest OS. That is, AFE0 may be assigned to the driver in the hypervisor while the remaining AFEs in the AF AFE1-AFEX) are assigned to guest OSs. The AFE assigned to the driver in the hypervisor may be considered as a PF in SR-IOV while the AFEs assigned to the guest OSs are virtual functions (VFs).</p><p id="p-0041" num="0040">Moreover, the embodiments herein can be applied to a non-virtualized environment. In such an example, one AFE (e.g., AFE0) can be assigned to a driver owned by an OS in the non-virtualized environment white the remaining AFEs in the AF can be assigned or owned by application processes in the non-virtualized environment.</p><p id="p-0042" num="0041">At block <b>320</b>, the guest OSs or containers assign the AFTs in their assigned AFE(s) to application threads executing in the guest OSs or containers. In one embodiment, the guest OSs/containers indicate compute resources that can be used to execute an application (or an application thread). These compute resources can include one or more AFTs. Thus, when a guest OS or container assigns compute resources to an application thread, the application thread is also assigned any AFTs in those compute resources. In this manner, the application thread can use the AFTs to execute its functions.</p><p id="p-0043" num="0042">In one embodiment, the AFT is an execution thread and includes execution context. Each AFT can have a unique thread ID, where in PCIe, the thread ID can be a PASID, If an AFE has only one AFT, the PASID is optional. Further, in SR-IOV, the AFTs are VFs which are assignable to the application threads in the corresponding guest OSs. The application thread can manage the resources and functions of the assigned AFTs. That is, the application thread can control a state of the AFT using an address of the AFT, thread ID of the AFT, signaling to application thread (using message signaled interrupts (MSI or MSI-X)), signaling from application thread to AFT, and changing the AFT to AFE assignments.</p><p id="p-0044" num="0043"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a flowchart of a method <b>400</b> for assigning virtual components executing in a host to the hierarchical layers in an accelerator, according to an example. In one embodiment, the method <b>400</b> can be used by the host (or more specifically, the hypervisor) to assign hardware resources in the accelerator to the virtual components in the host&#x2014;e.g., the guest OSs and containers.</p><p id="p-0045" num="0044">At block <b>405</b>, a bitstream provisions the accelerator in a default configuration for virtualization. That is, the accelerator may be initially loaded with a bitstream that configures the AF, AFE, and AFT layers for the accelerator. For example, an FPGA accelerator may have a default configuration of four AFs that perform four different accelerator functions (e.g., compression, encryption, security, and network acceleration) where each AF has eight AFEs, and each AFE can support <b>32</b> AFTs. However, this is just one example of a default configuration. A CPU may have a different default configuration&#x2014;e.g., two AFs (which may be two instances of the same image processing function) that each have four AFEs that support <b>16</b> AFTs.</p><p id="p-0046" num="0045">In one embodiment, the accelerator is configured into the default configuration when being powered one. In another embodiment, the bitstream defining the default configuration may be sent to the accelerator after being powered on.</p><p id="p-0047" num="0046">At block <b>410</b>, the hypervisor receives requests from guest OSs to use the accelerator. For example, a guest OS may request to use the accelerator to perform one or more of the AFs (e.g., compression, encryption, security, graphics processing, etc.). As part of the request, the guest OS may also inform the hypervisor how many AFEs it wants. For example, each AFE may be able to process one gigabit of data per second. The guest OS may state it wants two AFEs that process data at one gigabit per second (for two different application threads) or one AFE that processes data at two gigabit per second.</p><p id="p-0048" num="0047">At block <b>415</b>, the hypervisor determines whether the current configuration of the accelerator&#x2014;i.e., the current configuration of the hierarchical layers&#x2014;is sufficient to satisfy the requests made by the guest OSs. For instance, if a guest OS wants to use the same functions as the AFs currently established on the accelerator, then the current configuration may be sufficient. However, if the guest OS wants to use a searching function but the AFs currently on the accelerator are for compression and encryption, then the configuration is not sufficient. In another example, if the guest OS wants to use two AFEs that process data at 1 gigabits/sec and the corresponding AF has two AFEs available, then the current configuration is sufficient. However, if the guest OS wants an AFE that processes data at 2 gigabits/sec and the corresponding AF has only AFEs that process data at 1 gigabits/sec, then the current configuration is insufficient.</p><p id="p-0049" num="0048">If the current configuration is sufficient, the method <b>400</b> proceeds to block <b>420</b> where the hypervisor assigns the guest OSs to the AFs and AFEs as discussed above in the method <b>300</b>. The guest OSs and containers can then assign applications or application threads to AFTs in the assigned AFEs. In this manner, the guest OSs, containers, and applications can use the resources in the accelerator to perform their respective tasks.</p><p id="p-0050" num="0049">However, if the current configuration is not sufficient, the method <b>400</b> proceeds to block <b>425</b> where the accelerator is re-provisioned, Re-provisioning the accelerator means changing at least one of the hierarchical layers. For example, re-provisioning can include changing the number and types of the AFs, changing the number of AFEs in each AF, and altering the number of threads. Re-provisioning the hierarchical layers also reallocates or repartitions the underlying hardware circuitry in the accelerator. However, re-provisioning may affect only a part of the accelerator which means the unaffected parts (e.g., layers that are not changed) can operate without interruption during re-provisioning. Further, re-provisioning the hierarchical layers can take milliseconds rather than prior techniques which can take several minutes. The details for re-provisioning an accelerator alone with accompanying examples are provided in <figref idref="DRAWINGS">FIGS. <b>5</b>-<b>7</b>C</figref>.</p><p id="p-0051" num="0050"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a flowchart of a method <b>500</b> for re-provisioning the hierarchical layers in an accelerator, according to an example. The method <b>500</b> assumes that the accelerator is already in a default configuration and the hypervisor has determined that the current configuration of the hierarchical layers is not sufficient to satisfy the requests made by the guest OSs. As such, the accelerator is re-provisioned.</p><p id="p-0052" num="0051">For ease in explanation, the method <b>500</b> is explained in parallel with <figref idref="DRAWINGS">FIG. <b>6</b></figref> which illustrates a default configuration <b>600</b> of an accelerator, according to an example. In the default configuration <b>600</b>, the accelerator has four AFs (AF0-AF3) where each AF has eight AFEs (AFE0-AFE7). The AFEs can include any number of AFTs.</p><p id="p-0053" num="0052">At block <b>505</b>, the hypervisor determines whether only AFEs are affected by the re-provisioning. Stated differently, the current configuration of the AFs may be sufficient to satisfy the requests made by the guest OSs, but the AFEs within the AFs are not. In that case, the method <b>500</b> proceeds to block <b>510</b> where the hypervisor re-provisions the hierarchical layers by merging or splitting the AFEs in one or more AFs.</p><p id="p-0054" num="0053"><figref idref="DRAWINGS">FIGS. <b>7</b>A-<b>7</b>C</figref> illustrate re-provisioning the default configuration illustrated in <figref idref="DRAWINGS">FIG. <b>6</b></figref>, according to several examples. Specifically, <figref idref="DRAWINGS">FIG. <b>7</b>A</figref> illustrates re-provisioning the hierarchical layers where only the AFEs are changed but the AFs are not as described at block <b>510</b> in the method <b>500</b>. For example, a guest OS may want an AFE that can process data at four times the speed of the AFEs illustrated in the default configuration <b>600</b> in <figref idref="DRAWINGS">FIG. <b>6</b></figref>. In response, at block <b>510</b>, the hypervisor merges AFE0-AFE3 to form AFE8 which has four times the processing power as the remaining AFEs&#x2014;i.e., AFE4-AFE7. That is, the hardware circuitry in the accelerator previously assigned to AFE0-AFE3 has been merged to form AFE8. When performing the merge, only the guest OS(S) that were assigned AFE0-AFE3 are affected. The guest OS(s) assigned AFE4-AFE7 can continue to use these AFEs as normal, without any interruption in operation. Further, merging the AFEs into one AFE is a sub-second operation. For example, any programmable logic can be reconfigured dynamically from four independent AFEs to a single AFE which is then assigned to a requesting guest OS.</p><p id="p-0055" num="0054">Although not shown in <figref idref="DRAWINGS">FIG. <b>7</b>A</figref>, a spat operation can also be performed. For example, sixteen guest OSs may want to use the AFEs in AF0. So long as the processing constraints are satisfied, the hypervisor could reconfigure the AF0 to include sixteen AFEs that process data at half the speed of the AFEs in the default configuration <b>600</b>. Each one of the sixteen AFEs could be provided to one of the guest OSs.</p><p id="p-0056" num="0055">Returning to the method <b>500</b>, if more than just the AFEs are affected by re-provisioning, the method <b>500</b> proceeds to block <b>515</b> where the hypervisor determines whether only one AF is affected. If so, the method proceeds to block <b>520</b> where the hypervisor alters the AF while the remaining AFs in the accelerator can continue to function as normal, without interruption.</p><p id="p-0057" num="0056"><figref idref="DRAWINGS">FIG. <b>7</b>B</figref> illustrates altering the AF0 to form AF4, while the remaining AFs in the accelerator&#x2014;i.e., AF1-AF3&#x2014;remain unchanged. For example, AF0 may have been a compression function; however, no guest OSs (or only a small number of guest OSs) may currently request to use this function. Instead, a guest OS may request a function that is not currently performed by any of the functions AF0-AF3. In response, the hypervisor can reconfigure AF0 to perform a new function AF4. As shown, AF4 has only one AFE: AFE8. Put differently, the hardware previously partitioned into AF0 has now been re-provisioned into AF4. This hardware that was previously configured into eight AFEs that performed the accelerator function AF0 is now assigned (and configured) to execute one AFE that performs the accelerator function AF4. The other AFs (and their corresponding AFEs) are unaffected by this re-provisioning action and can continue to operate as normal. However, if any guest OSs were previously assigned an AFE in AF0, these guest OSs would be quiesced before AF0 is disabled and AF4 is enabled. Further, as part of enabling AF4, the hypervisor may bind AF4 to a RA and terminate the RA binding for AF0.</p><p id="p-0058" num="0057">Returning to the method <b>500</b>, if re-provisioning affects multiple AFs, at block <b>525</b> the hypervisor alters multiple AFs, which may include quiescing any quest OSs assigned AFEs in the AFs that are being altered.</p><p id="p-0059" num="0058"><figref idref="DRAWINGS">FIG. <b>7</b>C</figref> illustrates altering multiple AFs when re-provisioning the accelerator. Comparing <figref idref="DRAWINGS">FIG. <b>7</b>C</figref> to the default configuration <b>600</b> in <figref idref="DRAWINGS">FIG. <b>6</b></figref>, the hierarchical layers now includes only two AFs&#x2014;i.e., AF0 and AF1. In this example, the hardware that was previously assigned to AF2 and AF3 has been re-provisioned for use by AF0 and AF1. That is, both AF0 and AF1 now have sixteen AFEs rather than eight as shown in the default configuration <b>600</b>. For example, the guest OSs may not currently want to use the functions performed by AF2 and AF3 (or only a few guest OSs may want to use these functions). Further, AF0 and AF1 may not have sufficient AFEs to satisfy the requests from the guest OSs. Thus, the hypervisor can disable AF2 and AF3 so the hardware previously allocated to those functions can instead be allocated to AF0 and AF1 to form eight additional AFEs in each AF. When doing so, any guest OSs that were previously assigned to AF2 and AF3 may be quiesced. However, any guest OSs that were using AFE0-AFE7 in AF0 and AF1 can continue to operate as normal as the additional AFEs are added to these AFs.</p><p id="p-0060" num="0059">Thus, <figref idref="DRAWINGS">FIGS. <b>5</b>-<b>7</b>C</figref> illustrate re-provisioning the AFs and AFEs in the hierarchical layers to satisfy requests made by the guest OSs. Because the hierarchical layer partition the hardware into smaller chunks, re-provisioning can occur quickly and with minimal or no interruption to the AFs and AFEs that are unaffected by the re-provisioning action (e.g., the hypervisor does not need to quiesce all guest OSs). Moreover, the accelerator can pre-fetch bitstreams so they are ready to be swapped out during re-provisioning.</p><p id="p-0061" num="0060">In addition to dynamically re-provisioning the AFs and AFEs, the hypervisor can also dynamically re-provision the RA and AF bindings. For example, the accelerator may have two RAs and four AFs where each RA is bound to two of the AFs. If one AF is substantially busier than the other AFs, the hypervisor can re-provision this binding so that one RA is bound to the busy AF while the other RA is bound to the remaining three AFs. Alternatively, if the accelerator includes programmable logic, the hypervisor could add another RA or combine multiple RAs (to form a more powerful RA) to service the busy AF.</p><p id="p-0062" num="0061">In the preceding, reference is made to embodiments of the disclosure. However, the disclosure is not limited to specific described embodiments. Instead, any combination of the preceding features and elements, whether related to different embodiments or not, is contemplated to implement and practice the disclosure. Furthermore, although embodiments of the disclosure may achieve advantages over other possible solutions and/or over the prior art, whether or not a particular advantage is achieved by a given embodiment is not limiting of the disclosure. Thus, the preceding aspects, features, embodiments, and advantages are merely illustrative and are not considered elements or limitations of the appended claims except where explicitly recited in a claim(s). Likewise, reference to &#x201c;the disclosure&#x201d; shall not be construed as a generalization of any inventive subject matter disclosed herein and shall not be considered to be an element or limitation of the appended claims except where explicitly recited in a claim(s).</p><p id="p-0063" num="0062">Aspects of the present disclosure may be embodied as a system, method, or computer program product. Accordingly, aspects of the present disclosure may take the form of an entirely hardware embodiment, an entirely software embodiment (including firmware, resident software, micro-code, etc.) or an embodiment combining software and hardware aspects that may all generally be referred to herein as a &#x201c;circuit,&#x201d; &#x201c;module,&#x201d; or &#x201c;system.&#x201d; Furthermore, aspects of the present disclosure may take the form of a computer program product embodied in one or more computer readable medium(s) having computer readable program code embodied thereon.</p><p id="p-0064" num="0063">Any combination of one or more computer readable medium(s) may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be, for example, but not limited to, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, or device, or any suitable combination of the foregoing. More specific examples (a non-exhaustive list) of the computer readable storage medium would include the following: an electrical connection having one or more wires, a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or Flash memory), an optical fiber, a portable compact disc read-only memory (CD-ROM), an optical storage device, a magnetic storage device, or any suitable combination of the foregoing. In the context of this document, a computer readable storage medium may be any tangible medium that can contain, or store a program for use by or in connection with an instruction execution system, apparatus, or device.</p><p id="p-0065" num="0064">A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein, for example, in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms, including, but not limited to, electro-magnetic, optical, or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate, propagate, or transport a program for use by or in connection with an instruction execution system, apparatus, or device.</p><p id="p-0066" num="0065">Program code embodied on a computer readable medium may be transmitted using any appropriate medium, including but not limited to wireless, wireline, optical fiber cable, RF, etc., or any suitable combination of the foregoing.</p><p id="p-0067" num="0066">Computer program code for carrying out operations for aspects of the present disclosure may be written in any combination of one or more programming languages, including an object oriented programming language such as Java, Smalltalk, C++ or the like and conventional procedural programming languages, such as the &#x201c;C&#x201d; programming language or similar programming languages. The program code may execute entirely on the user's computer, partly on the user's computer, as a stand-alone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario, the remote computer may be connected to the user's computer through any type of network, including a local area network (LAN) or a wide area network (WAN), or the connection may be made to an external computer (for example, through the Internet using an Internet Service Provider).</p><p id="p-0068" num="0067">Aspects of the present disclosure are described above with reference to flowchart illustrations and/or block diagrams of methods, apparatus (systems) and computer program products according to embodiments of the disclosure. It will be understood that each block of the flowchart illustrations and/or block diagrams, and combinations of blocks in the flowchart illustrations and/or block diagrams, can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the processor of the computer or other programmable data processing apparatus, create means for implementing the functions/acts specified in the flowchart and/or block diagram block or blocks.</p><p id="p-0069" num="0068">These computer program instructions may also be stored in a computer readable medium that can direct a computer, other programmable data processing apparatus, or other devices to function in a particular manner, such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function/act specified in the flowchart and/or block diagram block or blocks.</p><p id="p-0070" num="0069">The computer program instructions may also be loaded onto a computer, other programmable data processing apparatus, or other devices to cause a series of operational steps to be performed on the computer, other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions/acts specified in the flowchart and/or block diagram block or blocks.</p><p id="p-0071" num="0070">The flowchart and block diagrams in the Figures illustrate the architecture, functionality, and operation of possible implementations of systems, methods, and computer program products according to various embodiments of the present disclosure. In this regard, each block in the flowchart or block diagrams may represent a module, segment, or portion of code, which comprises one or more executable instructions for implementing the specified logical function(s). In some alternative implementations, the functions noted in the block may occur out of the order noted in the figures. For example, two blocks shown in succession may, in fact, be executed substantially concurrently, or the blocks may sometimes be executed in the reverse order, depending upon the functionality involved. Each block of the block diagrams and/or flowchart illustration, and combinations of blocks in the block diagrams and/or flowchart illustration, can be implemented by special-purpose hardware-based systems that perform the specified functions or acts, or combinations of special purpose hardware and computer instructions.</p><p id="p-0072" num="0071">While the foregoing is directed to embodiments of the present invention, other and further embodiments of the invention may be devised without departing from the basic scope thereof, and the scope thereof is determined by the claims that follow.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A method for performing virtualization using an accelerator, the method comprising:<claim-text>binding a plurality of accelerator functions (AFs) in the accelerator to a respective one of a plurality of request agents (RAs) in the accelerator, wherein the plurality of AFs is in an AF layer and the plurality of RAs are in a cache coherent protocol layer that is part of the accelerator;</claim-text><claim-text>assigning the plurality of AFs to at least one of a hypervisor or container manager executing in a host, wherein the at least one of a hypervisor or container manager tracks the plurality of AFs and RAs as physical functions (PFs) and is informed by the accelerator of which of the plurality of AFs are bound to which of the plurality of RAs;</claim-text><claim-text>assigning at least one of a plurality of guest operating systems (OSs) or containers executing in the host to AF engines (AFEs) in the plurality of AFs, wherein the AFEs are in an AFE layer; and</claim-text><claim-text>assigning AF threads (AFTs) in the AFEs to application threads executing in the at least one of the plurality of guest OSs or containers, wherein the AFTs are in an AFT layer, and wherein the AF layer, the AFE layer, and the AFT layer hierarchically partition hardware circuitry in the accelerator, and wherein the AFT layer is assigned to hardware circuitry within the AFE layer.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the AF layer is an interface between the cache coherent protocol layer and the AFE layer, and the AFE layer is an interface between the AF layer and the AFT layer.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the host and the accelerator are part of a cache coherent system.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>receiving requests from the at least one of the plurality of guest OSs or containers to use the hardware circuitry in the accelerator; and</claim-text><claim-text>upon determining a current configuration of the AF, AFE, and AFT layers is insufficient to satisfy the requests, re-provisioning the accelerator to alter at least one AF in the AF layer or at least one AFE in the AFE layer where, during the re-provisioning of the accelerator, another AF in the AF layer or another AFE in the AFE layer continues to operate.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the re-provisioning the accelerator comprises:<claim-text>at least one of merging or splitting a subportion of the AFEs in a first AF of the plurality of AFs, wherein remaining AFEs in the first AF continue to operate while the subportion of the AFEs is merged or split.</claim-text></claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the re-provisioning the accelerator comprises:<claim-text>reconfiguring the first AF of the plurality of AFs to perform a different accelerator function, wherein any of the plurality of guest OSs or containers previously assigned an AFE in the first AF are quiesced before reconfiguring the first AF.</claim-text></claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the re-provisioning the accelerator comprises:<claim-text>disabling the first AF of the plurality of AFs; and</claim-text><claim-text>creating a new AF in the accelerator, wherein a portion of the hardware circuitry in the accelerator previously assigned to the first AF is now assigned to the new AF.</claim-text></claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. An accelerator, comprising:<claim-text>a plurality of request agents (RAs) configured to permit the accelerator to communicate with a cache coherent network; and</claim-text><claim-text>hardware circuitry partitioned into hierarchical layers comprising an accelerator function (AF) layer, an AF engine (AFE) layer, and an AF thread (AFT) layer, wherein the AF layer comprises a plurality of AFs bound to a respective one of the plurality of RAs, wherein the AFE layer comprises AFEs in the plurality of AFs, wherein the AFT layer comprises AFTs in the AFEs, and wherein the AFT layer is assigned to hardware circuitry within the AFE layer,</claim-text><claim-text>wherein the plurality of AFs and AFEs are assignable to at least one of guest operating systems (OSs) or containers executing in a host that is separate from the accelerator, and the AFTs are assignable to application threads executing in the at least one guest OSs or containers,</claim-text><claim-text>wherein the host is configured to track the plurality of AFs and RAs as physical functions (PFs) and is informed by the accelerator of which of the plurality of AFs are bound to which of the plurality of RAs.</claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The accelerator of <claim-ref idref="CLM-00008">claim 8</claim-ref>, further comprising at least one of:<claim-text>a field programmable gate array (FPGA); or</claim-text><claim-text>graphics processing unit (GPU).</claim-text></claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The accelerator of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the AF layer is an interface between a cache coherent protocol layer containing the plurality of RAs and the AFE layer, and the AFE layer is an interface between the AF layer and the AFT layer.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The accelerator of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the host and the accelerator are part of a cache coherent system.</claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The accelerator of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the accelerator is configured to re-provision the hierarchical layers in response to requests from the at least one of guest OSs or containers.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The accelerator of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the accelerator is configured to re-provision the hierarchal layers by:<claim-text>at least one of merging or splitting a subportion of the AFEs in a first AF of the plurality of AFs, wherein remaining AFEs in the first AF continue to operate while the subportion of the AFEs is merged or split.</claim-text></claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The accelerator of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the accelerator is configured to re-provision the hierarchal layers by:<claim-text>reconfiguring a first AF of the plurality of AFs to perform a different accelerator function, wherein any of the at least one of guest OSs or containers previously assigned an AFE in the first AF are quiesced before reconfiguring the first AF.</claim-text></claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The accelerator of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the accelerator is configured to re-provision the hierarchal layers by:<claim-text>disabling a first AF of the plurality of AFs; and</claim-text><claim-text>creating a new AF in the accelerator, wherein a portion of the hardware circuitry in the accelerator previously assigned to the first AF is now assigned to the new AF.</claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. A cache coherent system, comprising:<claim-text>a host, comprising:<claim-text>a hypervisor; and</claim-text><claim-text>a plurality of virtual machines (VMs); and</claim-text></claim-text><claim-text>an accelerator, comprising:<claim-text>a plurality of request agents (RAs) configured to permit the accelerator to communicate with a cache coherent network; and</claim-text><claim-text>hardware circuitry partitioned into a plurality of accelerator functions (AFs), a plurality of AF engines (AFEs) in each of the plurality of AFs, and a plurality of AF threads (AFTs) in each of the plurality of AFEs, wherein the plurality of AFs is bound to a respective one of the plurality of RAs, wherein the AFT layer is assigned to hardware circuitry within the AFE layer,</claim-text><claim-text>wherein the plurality of AFs and AFEs are assignable to the plurality of VMs, and the AFTs are assignable to application threads executing in the plurality of VMs,</claim-text><claim-text>wherein the hypervisor is configured to track the plurality of AFs and RAs as physical functions (PFs) and is informed by the accelerator of which of the plurality of AFs are bound to which of the plurality of RAs.</claim-text></claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The cache coherent system of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the plurality of AFs each perform different functions using the hardware circuitry.</claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The cache coherent system of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein at least one of the plurality of AFs has a different number of AFEs than another one of the plurality of AFs.</claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The cache coherent system of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the hypervisor is configured to re-provision the accelerator in response to requests from the plurality of VMs.</claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The cache coherent system of <claim-ref idref="CLM-00019">claim 19</claim-ref>, wherein re-provisioning the accelerator includes at least one of:<claim-text>changing a function performed by at least one of the plurality of AFs;</claim-text><claim-text>disabling at least one of the plurality of AFs;</claim-text><claim-text>creating a new AF; or</claim-text><claim-text>changing the number of the plurality of AFEs in at least one of the plurality of AFs.</claim-text></claim-text></claim></claims></us-patent-application>