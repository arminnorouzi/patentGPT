<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004574A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004574</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17781190</doc-number><date>20201203</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><priority-claims><priority-claim sequence="01" kind="national"><country>CN</country><doc-number>PCT/CN2019/122588</doc-number><date>20191203</date></priority-claim><priority-claim sequence="02" kind="regional"><country>EP</country><doc-number>20168225.9</doc-number><date>20200406</date></priority-claim></priority-claims><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>25</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>8</main-group><subgroup>41</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>254</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>8</main-group><subgroup>433</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e79">A SYSTEM AND METHOD FOR ETL PIPELINE PROCESSING</invention-title><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>KONINKLIJKE PHILIPS N.V.</orgname><address><city>EINDHOVEN</city><country>NL</country></address></addressbook><residence><country>NL</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>HU</last-name><first-name>Yiyi</first-name><address><city>SUZHOU</city><country>CN</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>OUYANG</last-name><first-name>En</first-name><address><city>SHANGHAI</city><country>CN</country></address></addressbook></inventor></inventors></us-parties><pct-or-regional-filing-data><document-id><country>WO</country><doc-number>PCT/EP2020/084346</doc-number><date>20201203</date></document-id><us-371c12-date><date>20220531</date></us-371c12-date></pct-or-regional-filing-data></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">The invention provides an ETL pipeline system including an interface configured to obtain a plurality of graph configuration components. Each graph configuration component includes information representative of one or more computational logic rules. The system further includes a computation graph generator configured to generate a computation graph based on the obtained graph configuration components. The generated computation graph includes a node for each graph configuration component and one or more links representative of relationships between the nodes. The system further includes a computation graph adaptor configured to receive, from an external source, external information relating to the graph configuration components, and to adapt the generated computation graph based on the external information. The system further includes a computation graph runner configured to run the adapted computation graph.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="100.25mm" wi="148.67mm" file="US20230004574A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="113.54mm" wi="150.71mm" file="US20230004574A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="98.72mm" wi="166.96mm" file="US20230004574A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="127.59mm" wi="155.11mm" file="US20230004574A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="140.04mm" wi="146.64mm" file="US20230004574A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="106.34mm" wi="56.98mm" file="US20230004574A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="126.15mm" wi="163.41mm" file="US20230004574A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="122.85mm" wi="154.01mm" file="US20230004574A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="103.63mm" wi="128.52mm" file="US20230004574A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">FIELD OF THE INVENTION</heading><p id="p-0002" num="0001">The invention relates to the field of data processing, and in particular the field of extract, transform, and load (ETL) pipeline processing</p><heading id="h-0002" level="1">BACKGROUND OF THE INVENTION</heading><p id="p-0003" num="0002">Extract, transform, and load (ETL) is a pipeline (i.e. a set of processes) utilized by data processing and analytics systems to collect data from various sources, transform the data according to business requirements, and load it into a destination data store. In ETL systems, the transformation takes place in a specialized engine, where staging tables are usually used to temporarily hold data as it is being transformed and ultimately loaded to a destination. There are many traditional operations involved during the process of data transformation, such as filtering, sorting, aggregating, joining, cleaning, deduplication, and validating.</p><p id="p-0004" num="0003">For medical data applications, complex data transformations may need to be performed to generate meaningful insights. Nevertheless, these transformations must first depend on data being structured into a table of phenotypes (i.e. data elements) before they can be utilized for more advanced processing. Therefore, in traditional medical data processing systems, the extraction step involves abstracting useful phenotypes. Transformation refers to computation and derivation performed based on extracted phenotypes. Transformation outputs can be new phenotypes that are derived from existing phenotypes or computational results of decision rules, such as diagnosis or treatment selection.</p><p id="p-0005" num="0004">However, in existing ETL systems, although natural language processing (NLP) techniques are widely employed for phenotype extraction, there is very limited architecture to support knowledge driven computations during the transformation phase. Separate systems or applications are usually implemented to handle advanced computations after the ETL has completed, which results in loss of coherency and introduces more overheads.</p><p id="p-0006" num="0005">Data extraction is traditionally handled by independent NLP modules. Consequently, phenotype extractors are often separated with the secondary usage (such as data aggregation) of extracted data. This results in having to compare performance of multiple phenotype extraction algorithms, reducing efficiency.</p><p id="p-0007" num="0006">Graph structure is traditionally used to encode clinical knowledge, since it is capable of capturing complex relationships among medical concepts, which benefits many applications. However, the graph representation itself is non-computable. In a conventional ETL pipeline, there is no paradigm to enable beneficial usage of knowledge to drive computations. This is typically achieved by hard-coding programming rules during data transformation. As a result, the method lacks flexibility in coping with changes (e.g. change of input data types, algorithms and decision logics).</p><heading id="h-0003" level="1">SUMMARY OF THE INVENTION</heading><p id="p-0008" num="0007">The invention is defined by the claims.</p><p id="p-0009" num="0008">According to examples in accordance with an aspect of the invention, there is provided an ETL pipeline system including an interface configured to obtain a plurality of graph configuration components. Each graph configuration component includes information representative of one or more computational logic rules. The system further includes a computation graph generator configured to generate a computation graph based on the obtained graph configuration components. The generated computation graph includes a node for each graph configuration component and one or more links representative of relationships between the nodes. The system further includes a computation graph adaptor configured to receive, from an external source, external information relating to the graph configuration components, and to adapt the generated computation graph based on the external information. The system further includes a computation graph runner configured to run the adapted computation graph.</p><p id="p-0010" num="0009">Proposed are concepts for an ETL architecture that may be particularly beneficial for medical data processing, where phenotyping and clinical knowledge computing are embedded coherently in a single architecture. Such concepts may allow for clinical knowledge to be configured independently from actual clinical data. However, during running time, the clinical data can flow though the structure, where database operations, phenotyping algorithms and decision logics are applied to the data flow, resulting in targeted computation outcomes.</p><p id="p-0011" num="0010">It is proposed to provide a graph configuration file (such as a DSL) to construct a computing graph intuitively. It is further proposed to provide a graph driver to parse, construct, and execute a computation graph. It is further proposed to provide an information modelling technique to encode a relationship between a phenotype and a clinical document. A proposed backend graph data structure can be integrated with facts-based knowledge graph and data-based knowledge graphs in order to benefit downstream application. Further, the application of multi-layered computation, local re-computation and adaptive computation are proposed for application in the ETL pipeline system.</p><p id="p-0012" num="0011">Proposed are concepts for an ETL architecture that may be particularly beneficial for medical data processing. In particular, the claimed invention provides an ETL pipeline system including an interface configured to obtain a plurality of graph configuration components. Each graph configuration component includes information representative of one or more computational logic rules. The proposed invention generates a computation graph based on the obtained graph configuration components, wherein the generated computation graph includes a node for each graph configuration component and one or more links representative of relationships between the nodes. External information (such as a user-defined graph configuration component and/or prior knowledge) relating to the graph configuration components is then employed to adapt the generated computation graph.</p><p id="p-0013" num="0012">In an embodiment, each graph configuration component may comprise at least one of a database connection, a document, a data element, an algorithm, and a computational logic rule.</p><p id="p-0014" num="0013">In an embodiment, the algorithm may comprise a computational decision rule and/or the computational logic rule may comprise a computational decision rule.</p><p id="p-0015" num="0014">In an embodiment, the external information may comprise at least one of a user-defined graph configuration component and external knowledge from an external knowledge database. By way of example, the external knowledge may comprise a previous/prior computation graph stored in a database. Such a previous/prior computation graph may be added to the generated computation graph to form the adapted computation graph. That is, the generated computation graph may be adapted by incorporation of a previous/prior computation graph. By way of further example, the user-defined graph configuration component may comprise graph configuration components that are configured to redefine or amend a computation graph.</p><p id="p-0016" num="0015">In an embodiment, the interface may comprise at least one of a user interface and an application programming interface.</p><p id="p-0017" num="0016">In an embodiment, the system further comprises a graph configuration file and the user-defined graph configuration component comprises redefining the graph configuration file or dependency information indicative of dependency relationships among different graph configuration components.</p><p id="p-0018" num="0017">In an embodiment, the system further comprises a computation graph parser configured to: receive the graph configuration components from the interface; and establish one or more links between different graph configuration components based on the component information and dependency information indicative of dependency relationships among different graph configuration components.</p><p id="p-0019" num="0018">In an embodiment, the computation graph parser may further be configured to establish a link between the data element and the document based on data items associated with the data element and/or the document.</p><p id="p-0020" num="0019">In an embodiment, the data items may comprise at least one of an identifier, a timestamp, a content item, a context item, and an encoding object.</p><p id="p-0021" num="0020">In an embodiment, the computation graph runner may further be configured to run the adapted computation graph in an adaptive high-throughput computation.</p><p id="p-0022" num="0021">According to examples in accordance with an aspect of the invention, there is provided a medical data processing system comprising the ETL pipeline system described above.</p><p id="p-0023" num="0022">According to examples in accordance with an aspect of the invention, there is provided a method for ETL pipeline processing. The method comprises obtaining a plurality of graph configuration components, each graph configuration component comprising information representative of one or more computational logic rules. The method further comprises generating a computation graph based on the obtained graph configuration components, the generated computation graph comprising: a node for each graph configuration component; and one or more links representative of relationships between the nodes. The method further comprises receiving, from an external source, external information relating to the graph configuration components. The method then comprises adapting the generated computation graph based on the external information and running the adapted computation graph.</p><p id="p-0024" num="0023">According to examples in accordance with an aspect of the invention, there is provided a computer program product for ETL pipeline processing, wherein the computer program product comprise a computer readable storage medium having program instructions embodied therewith, the program instructions executable by a processing unit to cause the processing unit to perform a method. The method comprises obtaining a plurality of graph configuration components, each graph configuration component comprising information representative of one or more computational logic rules. The method further comprises generating a computation graph based on the obtained graph configuration components, the generated computation graph comprising: a node for each graph configuration component; and one or more links representative of relationships between the nodes. The method further comprises receiving, from an external source, external information relating to the graph configuration components. The method then comprises adapting the generated computation graph based on the external information and running the adapted computation graph. According to examples in accordance with an aspect of the invention, there is provided a processing system comprising at least one processor and the computer program product described above, wherein the at least one processor is adapted to execute the computer program code of said computer program product.</p><p id="p-0025" num="0024">These and other aspects of the invention will be apparent from and elucidated with reference to the embodiment(s) described hereinafter.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0026" num="0025">For a better understanding of the invention, and to show more clearly how it may be carried into effect, reference will now be made, by way of example only, to the accompanying drawings, in which:</p><p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a simplified block diagram of an ETL pipeline system;</p><p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. <b>2</b></figref> shows a simplified block diagram of a state transition flow in an ETL pipeline system;</p><p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. <b>3</b></figref> shows a dependency relationship among different graph configuration components;</p><p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. <b>4</b></figref> shows an example of a generated computation graph;</p><p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a simplified flow diagram of a method for ETL pipeline processing according to an embodiment;</p><p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. <b>6</b></figref> shows a simplified block diagram of a knowledge computing structure, specifically an adaptive computing structure, implemented in an ETL pipeline system;</p><p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. <b>7</b></figref> shows a simplified block diagram of a knowledge computing structure, specifically a multi-layered computer structure, implemented in an ETL pipeline system; and</p><p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. <b>8</b></figref> illustrates an example of a computer for implementing a controller or processor according to an embodiment.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0005" level="1">DETAILED DESCRIPTION OF THE EMBODIMENTS</heading><p id="p-0035" num="0034">The invention will be described with reference to the Figures.</p><p id="p-0036" num="0035">It should be understood that the detailed description and specific examples, while indicating exemplary embodiments of the apparatus, systems and methods, are intended for purposes of illustration only and are not intended to limit the scope of the invention. These and other features, aspects, and advantages of the apparatus, systems and methods of the present invention will become better understood from the following description, appended claims, and accompanying drawings. It should be understood that the Figures are merely schematic and are not drawn to scale. It should also be understood that the same reference numerals are used throughout the Figures to indicate the same or similar parts.</p><p id="p-0037" num="0036">The invention provides an ETL pipeline system including an interface configured to obtain a plurality of graph configuration components. Each graph configuration component includes information representative of one or more computational logic rules. The system further includes a computation graph generator configured to generate a computation graph based on the obtained graph configuration components. The generated computation graph includes a node for each graph configuration component and one or more links representative of relationships between the nodes. The system further includes a computation graph adaptor configured to receive, from an external source, external information relating to the graph configuration components, and to adapt the generated computation graph based on the external information. The system further includes a computation graph runner configured to run the adapted computation graph.</p><p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. <b>1</b></figref> shows an ETL pipeline system according to an embodiment. The system comprises an interface <b>11</b>, <b>12</b> for user interactions with the system. This assists the user in creating (high level) computable knowledge representations according to their specific requirements. The system of <figref idref="DRAWINGS">FIG. <b>1</b></figref> includes two interfaces <b>11</b>, <b>12</b>. Interface <b>12</b> is a user interface (UI) and enables &#x201c;drag-and-drop&#x201d; of key components at the system front-end, resulting in faster computation graph creation. Interface <b>11</b> is an application programming interface (API) that serves the same purpose as the user interface <b>12</b> but interacts at a programming level. The API <b>11</b> predominantly supports three actions. First, submission of specially designed graph configuration files (GCFs) <b>13</b>, which are to be transformed later into a computable graph. Second, submission and saving/loading of user-defined (UDF) algorithms <b>14</b> regarding database transactions, data computations, and NLP phenotyping to a central function repository. Third, communicating with a common graph database <b>15</b>, which can either save the created graph structure into the graph database <b>15</b> or load existing graphs from the graph database <b>15</b> into the system.</p><p id="p-0039" num="0038">There exist state transitions flows in between the abovementioned components. Graph configurations (both via UI and API) are converted into underlying data structure of directed-acyclic-graph (DAG). DAG can be converted back-and-forth to data structures in a common graph database (e.g. Neo4j, GraphDB, and Cayley). To this point, DAG is a static graph structure that encodes necessary information for running. It is further converted into a runnable graph which can be executed at run time.</p><p id="p-0040" num="0039">A Graph Configuration File (GCF) <b>13</b> is a container for a graph structure that performs both data extraction and decision rule computation tasks. By following a specially designed paradigm by us, users are allowed to declare-or-define a set of key components, i.e. database connections, documents, phenotypes, algorithms and computational logics and organize them into a group of GCFs <b>13</b>, to fulfil certain computation task. GCFs <b>13</b> can be created as human-readable textual files in the format of JSON and YAML. In each file, user defines structures that include key components to represent a single node in graph. Multiple and nested nodes are allowed to be defined within a same file or distributed into several files in a same folder. Previously-defined GC nodes either in the same file or in external files in the same folder can be referenced by name during parsing.</p><p id="p-0041" num="0040">The GCF <b>13</b> is configured to absorb existing knowledge into the common graph structure supported by our system at programming level. This is sometimes difficult and/or time-consuming for human to curate via a UI. For instance, BCLC and Child-Pugh scoring systems can be persisted into our system via GCFs and be computed at running time to derive staging a Child-Pugh score for liver cancer patient.</p><p id="p-0042" num="0041">The graph configuration UI <b>12</b> serves as an alternative to a GCF <b>13</b> to allow construction of graph representation of clinical knowledge and decision rules intuitively. A UI adapter <b>16</b> is responsible for transforming front-end input into the underlying data structure (DAG). In the UI, users are allowed to construct a graph by creating nodes and links. For each node, a user can specify algorithms to process data flow travelling through that node or implement decision logics that takes input from parent nodes of current node.</p><p id="p-0043" num="0042">A graph driver <b>10</b> sits at the core of the system. It is responsible for constructing a computational graph that is able to take data flow and making the graph run to deliver desired results for user. Graph driver <b>10</b> comprises three main components of: GCF Parser (GCFP) <b>17</b>, Graph Constructor (GST) <b>18</b>, graph runner (GRN) <b>19</b> and two adapters <b>16</b>, <b>20</b>. Implementation of a graph driver is not limited to specific programming language; however, developers follow the same philosophy as well as common interfaces in each system component to realize language specific drivers.</p><p id="p-0044" num="0043">Taking configuration files <b>13</b> as input (formatted in JSON, YAML or XML), the GCFP <b>17</b> transforms the graph definition in files <b>13</b> into individual components (e.g. database connections, documents, phenotypes, algorithms and computational logics) under corresponding namespaces and then links namespaces together as linked objects to prepare for graph construction.</p><p id="p-0045" num="0044">More specifically, each GCF <b>13</b> may comprise definitions for different graph configuration components, By way of example, <figref idref="DRAWINGS">FIG. <b>3</b></figref> defines an exemplary se of dependency relationships between different graph configuration components in relation to various namespace components. More specifically, the solid line labelled &#x201c;A&#x201d; defines the dependency between database and document, the solid line labelled &#x201c;B&#x201d; defines the dependency between algorithm and logic. The solid line labelled &#x201c;C&#x201d; defines the dependency between document and logic. The solid line labelled &#x201c;D&#x201d; defines the dependency between phenotype and logic Such dependency relationships may be defined by a user.</p><p id="p-0046" num="0045">The GCFP <b>17</b> receives the graph configuration components from the interface <b>11</b>, and then establishes a link between different graph configuration components based on the component information and dependency information indicative of dependency relationships among different graph configuration components.</p><p id="p-0047" num="0046">The GST <b>18</b> can then translate the linked components into graph nodes and relations. That is the GST <b>18</b> takes the linked namespace objects and constructs an underlying data representation, where linked components are translated into graph nodes and relations among nodes in the form of DAG. In addition, during the construction process, the GST <b>18</b> frequently interacts with graph configuration API to load/save components from/to a function repository (database that keeps all functional objects). If a specified component in GCF <b>13</b> already exists in this repository, the component reference is directly fetched from the repository. Otherwise, the specified component is new, and the GST <b>18</b> then saves it to function repository for re-use.</p><p id="p-0048" num="0047">The GRN <b>19</b> first serves as an injector that injects all necessary information to run the graph, for example, code objects and recursively defined GC components. In the meantime, graph runner <b>19</b> is a connector that takes the graph to existing implementations of graphs-based parallel execution systems. As an example, <figref idref="DRAWINGS">FIG. <b>4</b></figref> shows an example of a generated computation graph. The generated computation graph may be output via the interface(s) <b>11</b> or <b>12</b>. The generated computation graph includes a node <b>36</b> for each graph configuration component and one or more links <b>37</b> representative of relationships between nodes <b>37</b>.</p><p id="p-0049" num="0048">The two adapters, namely graph database adapter <b>20</b> and UI adapter <b>16</b> are included in the driver <b>10</b>. The UI adapter is responsible for converting front-end input into DAG structure and vice versa, presenting a constructed DAG to front-end user. Also, the graph DB adapter harmonizes data structure used by our system and existing graph DB systems.</p><p id="p-0050" num="0049">Referring to <figref idref="DRAWINGS">FIG. <b>2</b></figref>, there is depicted an illustration of state transition flow among system components according to an embodiment. From a GCF <b>13</b> and graph configuration <b>33</b> provided via a user interface, a DAG <b>32</b> is constructed. The DAG <b>32</b> can be converted back-and-forth to data structures in knowledge graph <b>34</b>. The DAG <b>32</b> is further converted into a runnable graph <b>35</b> which can be executed at run time.</p><p id="p-0051" num="0050">Referring now to <figref idref="DRAWINGS">FIG. <b>5</b></figref>, there is depicted a simplified flow diagram of a method for ETL pipeline processing according to an embodiment. The method begins with step <b>21</b> of obtaining a plurality of graph configuration components. Here, each graph configuration component comprises information representative of one or more computational logic rules. Next, in step <b>22</b>, a computation graph is generated based on the obtained graph configuration components. The generated computation graph comprises: a node for each graph configuration component; and one or more links representative of relationships between the nodes. Subsequently, in step <b>23</b>, external information relating to the graph configuration components is received from an external source. Step <b>24</b> then comprises adapting the generated computation graph based on the external information. Finally, in step <b>25</b>, the adapted computation graph is run.</p><p id="p-0052" num="0051">More specifically, the external information comprises at least one of a user-defined graph configuration component and external knowledge from an external knowledge database. In one embodiment, the external knowledge comprises prior computation graph stored in a database and the prior computation graph is added to the generated computation graph and forms the adapted computation graph. In another embodiment, user-defined graph configuration component comprises redefining or amending graph configuration components via the interface.</p><p id="p-0053" num="0052">A subject may redefine the graph configuration components or the links between the graph configuration components of the generated computation graph using a graphical user interface. For instance, such redefinition may be achieved by dragging the nodes, removing the links or re-connecting the links between different nodes in an interactive visual representation of a computation graph (as illustrated in <figref idref="DRAWINGS">FIG. <b>4</b></figref> for example).</p><p id="p-0054" num="0053">In another embodiment, a user-defined graph configuration component comprises one or more definitions for redefining the graph configuration file and/or the dependency relationships among different graph configuration components. More specifically, the subject can define a different logic (by changing @logic), defining a different algorithm (by changing @algorithm), or adding new components, i.e. the subject dependency.</p><p id="p-0055" num="0054">By way of further explanation, we will firstly describe GCF grammar and GCF parsing, which converts configuration files <b>13</b> into linked namespace components. For parsing, we introduce each building blocks. For graph construction, we discuss details of forming a DAG. Data model design will then be explained detail, which deals with the relationship between phenotype and document during graph construction process. It will then be explained how existing knowledge graphs can be combined with proposed embodiments to acquire meaningful results. Finally, details on how embodiments may be employed for efficient computations will be provided.</p><p id="p-0056" num="0055">GCF Grammar</p><p id="p-0057" num="0056">GCF grammar supports declare and definition of key components, which start with a &#x201c;@&#x201d; notation followed by component category. Key components fall into five different categories, namely: database; phenotype; document; algorithm; and logic. Each serve different purposes and can be organized into independent structures. Detailed discussion on the five components is provided below in the next section of the description. The difference between declaration and definition depends on whether a component has already being created. To declare a component, just the component name is needed, followed after &#x201c;@&#x201d;.</p><p id="p-0058" num="0057">To define a component, &#x201c;@def&#x201d; keyword must be put inside the body of a component. To save a defined component, a name must be specified using keyword &#x201c;@name&#x201d;, and a &#x201c;@save&#x201d; keyword should be added with value set to &#x2018;True&#x2019;. A user attaches function implementations as a value to &#x201c;@dd&#x201d;, and the function definitions will be persisted into a central repository. Then, the saved component can be declared as mentioned above. GCF grammar supports nested definition of components, but is constrained by namespace dependencies.</p><p id="p-0059" num="0058">The below example shows a task of detecting malignant tumor given radiology report data clusters and tumor biomarkers.</p><p id="p-0060" num="0059">An exemplary GCF that fulfils a task of detecting malignant tumours:</p><p id="p-0061" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="28pt" align="left"/><colspec colname="1" colwidth="189pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>&#x201c;@Document&#x201d;: input_data</entry></row><row><entry/><entry>&#x201c;@Document&#x201d;: tumor_markers</entry></row><row><entry/><entry>&#x201c;@Phenotype#1&#x201d;: tumor_mention</entry></row><row><entry/><entry>&#x201c;@Phenotype#2&#x201d;: report_time</entry></row><row><entry/><entry>&#x201c;@Phenotype#3&#x201d;: AFP</entry></row><row><entry/><entry>&#x201c;@Algorithm&#x201d;: is_MT</entry></row><row><entry/><entry>&#x201c;@Algorithm&#x201d;: select_marker</entry></row><row><entry/><entry>&#x201c;@Logic&#x201d;:</entry></row><row><entry/><entry>&#x2003;&#x201c;@name&#x201d;: detect_radiology_reports,</entry></row><row><entry/><entry>&#x2003;&#x201c;@def&#x201d;: |</entry></row><row><entry/><entry>&#x2003;&#x2003;for cluster, _in input_data:</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;evidence_list = [</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;x for x in cluster</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;if is_MT(x.tumor_mention)</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;]</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;if len(evidence_list) &#x3e;=2:</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;yield (True, cluster[0].report_time)</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;elif len(evidence_list) ==1:</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;markers=select_marker(tumor_markers)</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;if markers.AFP &#x3e; 20:</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;yield (True, cluster[0].report_time)</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;else:</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;yield (False, None)</entry></row><row><entry/><entry>&#x2003;&#x201c;@save&#x201d;: True</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0062" num="0060">The target is to tell if there is malignant tumor (MT) found inside each radiology report cluster. The decision rule says if more than two radiology reports in a cluster contain malignant tumor mentions, then return true. In another case (less than 2 radiology supports), if there is abnormal AFP (tumor biomarker) found, also return true. Otherwise, return false. In the above example, &#x201c;@Document: input_data&#x201d; represents a list of clusters of radiology reports (reports within two month clustered together). &#x201c;@Document: tumor_markers&#x201d; injects documents with tumor biomarker information. With imported documents, according to our document-phenotype relation model, &#x201c;@Phenotype: tumor_mention&#x201d; and &#x201c;@Phenotype: report_time&#x201d; will be retrieved from corresponding document objects. &#x201c;@Algorithm: is_MT&#x201d; and &#x201c;@Algorithm: select_marker&#x201d; will trigger the two decision functions to be imported from the repository during graph construction. &#x201c;select_marker&#x201d; is the algorithm to choose most recent biomarker data recorded to those radiology reports inside a cluster. &#x201c;is_MT&#x201d; is an algorithm to determine according to the &#x201c;@phenotype: tumor_mention&#x201d; whether the tumor is malignant. The decision rule is implemented with within &#x201c;@def&#x201d; of &#x201c;@Logic&#x201d; block. &#x201c;@save&#x201d; indicates that this logic will be saved to the function repository with the name &#x201c;detect_radiology_reports&#x201d;. Next time, this saved function can be imported directly via declaring &#x201c;@Algorithm: detect_radiology_reports&#x201d;. However, all the imports and code defined so far will not be performed until the graph is constructed and converted as runnable graph and being executed.</p><p id="p-0063" num="0061">Namespace Components</p><p id="p-0064" num="0062">Corresponding to the five key items defined by GCF grammar, there are five functional component objects. Database component is responsible for handling database operations, database connections and transactions such as data query. Phenotype is key-value entities which are meaningful for certain decision rule computation task. Document represents clinical reports that contains a set of phenotypes. Algorithms are special functions that process inputs to acquire outputs. For instance, data extraction algorithms extract concerned phenotype value from clinical narrative data. Logics are also functions like algorithms. However, the difference is that a logic is responsible for making transitions between different nodes.</p><p id="p-0065" num="0063">The inventors have created a bidirectional relation model to represent phenotype and document. Each phenotype and document contains mandatory data items of name/ID, timestamp, content and optional data items of context and encoding. However, content and context has different meanings for phenotype and document respectively. For a document, the content represents the content of report either in narrative form or in structured/semi-structured form. For a phenotype, content is the phenotype value. For a phenotype, the context is the content of the document that contains it. For a timestamp, it is assumed that phenotype timestamp is equal to document timestamp although in some cases they are not. Encoding represents a standardized code which is associated. Usually, this code indicates a category of a phenotype or document entity.</p><p id="p-0066" num="0064">DAG</p><p id="p-0067" num="0065">Taking the exemplary GCF provided above, phenotypes are fetched by NLP phenotyping algorithms which models the phenotyping outcomes using the relational information model discussed above for phenotype and document. In the exemplary GCF above, the NLP algorithm is not explicitly declared. It is assumed that this is done by some pre-configurations. In the example, it is shown explicitly that phenotypes are extracted from documents with NLP algorithms as function nodes in the DAG. Again, this DAG representation is static and nothing is computed until the graph is turned into a runnable graph and executed.</p><p id="p-0068" num="0066">Connection with Knowledge/Ontologies</p><p id="p-0069" num="0067">Here, the connection between the graph structures and graph data in external knowledge graph databases is detailed. Two types of knowledge graphs databases can be connected, i.e. knowledge base with fasts and knowledge base with data. Connection with knowledge has the potential to expand graph processing results to a larger scope by linking entities in a graph with entities outside. This is useful when building intelligent search or question and answering systems (QA).</p><p id="p-0070" num="0068">Knowledgebase with Facts</p><p id="p-0071" num="0069">Facts graphs are existing knowledge graphs and ontologies, such as SNOMED-CT, LOINC, MeSH, Drugbank and so forth. By connecting data nodes in our DAG to such external graphs and ontologies, a key benefit is that concept standardization can be performed and internal and external graphs may be bridged to achieve knowledge expansion automatically. This facilitates the development of processing systems that behave as meaning of the biomedicine and health language is understood.</p><p id="p-0072" num="0070">Knowledgebase with Data</p><p id="p-0073" num="0071">Fast health interoperability resource (FHIR) is a medical standard that defines a set of data resources and so aims to facilitate fast data exchange between medical systems. A FHIR database is essentially a knowledge base with different data resources that can be linked together as graphs. FHIR supports Turtle format, which can be used to store data as RDF triples.</p><p id="p-0074" num="0072">Knowledge Computation</p><p id="p-0075" num="0073">Details of knowledge computing strategies will now be provided. Proposed embodiments may employ the following: (i) adaptively selecting best computation strategy according to data dependency between two nodes in a graph to increase efficiency; (ii) organizing accumulative data and knowledge and into a multi-layer structure that is efficient to compute and easier to track for users; and (iii) local re-computations that allow replaceable graph components into existing computational graphs to optimize system performance efficiently.</p><p id="p-0076" num="0074">Adaptive Computing Structure</p><p id="p-0077" num="0075">A runnable graph is fed into a parallel execution component. The key concept of this component is transforming tree-shaped sequential computation to high-throughput synchronous computation and sequence detection and following decision-making. After the generation of DAG, how to process it efficiently remains a challenge, especially for complex DAG and large-scale data. A computation strategy is proposed that transforms the sequential decision graph computation problem to node status detection and node status sequence mapping. An illustration of this concept is provided in <figref idref="DRAWINGS">FIG. <b>6</b></figref>.</p><p id="p-0078" num="0076">In particular, <figref idref="DRAWINGS">FIG. <b>6</b></figref> illustrates a proposed adaptive computation strategy according to an embodiment. Here, sequential graph computing is transformed to high-throughput synchronous status detection and status sequence mapping. In &#x201c;A&#x201d;, all nodes <b>42</b> in the DAG have no data transfer, then every node <b>42</b> will be transformed into a status in status sequence <b>43</b>; In &#x201c;B&#x201d;, data transfer exists between some nodes <b>42</b>, those nodes <b>42</b> are transformed into one status in status sequence <b>43</b>.</p><p id="p-0079" num="0077">Firstly, according to a defined GCF, a status sequence list <b>44</b> is generated, which enumerates all probable status sequences <b>43</b> and its corresponding results. The relationship between status sequence <b>43</b> and result can be many-to-one.</p><p id="p-0080" num="0078">As detailed above (in the section entitled &#x201c;DAG&#x201d;), an adaptive strategy is employed in the transform process to boost efficiency. In the first situation &#x201c;A&#x201d;, there is no intermediate data being transferred between two nodes (i.e. no dependency between nodes). Therefore, it can be regarded as an independent decision node, and transformed into a single status in a status sequence. In the second situation &#x201c;B&#x201d;, where there is data transfer between two nodes (i.e. dependency between nodes) in the DAG, those nodes are merged as a node group, and then transformed to a status in the sequence (as illustrated by the dashed boxes surrounding the nodes that are merged).</p><p id="p-0081" num="0079">There are two key aspects that contribute to efficiency improvement during the process of DAG computation: (a) paralleled node status detection, instead of sequential decision to derive each node status; and (b) status sequence mapping. When large-scale data is fed into the graph, decision status will be generated for every decision node or decision node group. After that, all status will be concatenated to a status sequence in pre-defined order. Then, the system conducts sequence mapping against sequence list to get result. For instance, in a clinical practice to conduct decision-making, the GCF define three nodes (A, B, C), and every node is a binary choice (0 for false, 1 for true), the status sequence &#x201c;100&#x201d; representing A is true, B is false, and C is false, the result is &#x201c;Having disease&#x201d;, meanwhile, the result of &#x201c;001&#x201d; can be &#x201c;Having no disease&#x201d;. All those sequences form a list of status sequences.<ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0080">Multi-Layer Computation</li>    </ul>    </li></ul></p><p id="p-0082" num="0081">Multi-layer computation deals with the situation when both data and the number of clinical knowledge graphs being injected are increasing, which is usually the case. Longitudinal data (phenotypes) changes by time, with new data keep coming in, meanwhile, new clinical knowledge continuously being injected into the system. With more data, some computations in stored graphs can be continued. With more completed knowledge, new computations using existing data in the system can be activated to derive new data. For instance, suppose there is a knowledge graph injected that monitors if a patient has relapsed tumour. When there is only one radiology report that supports cancer recurrence, according to clinical knowledge, no judgement can be made. However, when there is one plus radiology support or tumour biomarker support that comes into the system, the computation can be carried on to derive a new data variable on tumour relapse. If accumulated data and knowledge are not well organized, users will never be able to track the process of each computation results.</p><p id="p-0083" num="0082">A proposed system periodically re-runs ETL to take in new data from EMR and carries out computation as described. Here, the data variables created during initial ETL are referred to as base data layer. Newly derived data is placed into new data layers on top of base layer recursively. In particular, after injecting a new knowledge graph, each node in the graph is mapped to a standardized and unique system code via concept encoding. Such encoding is used to build an inverted index of all graph nodes, each associated with graph structures that contain the node as well as the layer number. New input data, based on its data type, is assigned with a concept code via the same encoding process. The concept code is searched with the inverted index to get all graphs that contain a node with the same encoding. This is a very fast look up process. Normally, the node encoding can be covered by already injected graphs, the data is added as a graph node to a matched sequence for further processing. However, for those not covered, it is added as a node to an un-matched sequence. For nodes inside matched sequence, they are added to the system and to active graph computation in deriving new data. The algorithm is described as follows.</p><p id="p-0084" num="0083">The new node is copied and added to all those layers where there exist graph structures in the index that include this node. If the added node can work with other nodes in the same layer to derive a new data value in some graphs, then, either a new layer is created to include this newly derived data node or the new node is added to an existing upper layer. To decide, the algorithm again matches against all graphs only in the upper layers that contains the newly derived node. If there exists an upper layer that contains the node, then the node is added to that layer. If not, a new upper layer parallel to other upper layers is created. In such new layer, all the graph structures that include the newly derived node will be associate with the new layer number.</p><p id="p-0085" num="0084">Initially, there is only one layer called base layer at the bottom. For the nodes in un-matched sequence, there is currently no graph structures in the system that covered them. These data nodes may, or never, be covered by new knowledge graphs injected into the system in the future. Therefore, when new knowledge being injected, the algorithms always checks if nodes from un-matched sequence can be added. If not, these data nodes serves just normal data points in our system.</p><p id="p-0086" num="0085">By way of further description, an example is illustrated in <figref idref="DRAWINGS">FIG. <b>7</b></figref>. More specifically, <figref idref="DRAWINGS">FIG. <b>7</b></figref> illustrates an example of multi-layered computation and data organization according to a proposed embodiment. A and B of a first base layer <b>53</b> can derive E of a Layer 1.1 group <b>55</b>. E and F further derives H of a Layer 2.1 group <b>57</b>. However, C and D are not covered by any graphs in A and B's group <b>53</b>. So a second, parallel base layer <b>54</b> is created to include C and D. C and D derives G of a Layer 1.2 group <b>56</b>. Also, because G is not covered by graphs in E and F in Layer 1.1, and is included by both Layer 1.2 group <b>56</b> and Layer 2.1 group <b>57</b>, G is copied to both layers <b>56</b>, <b>57</b>.</p><p id="p-0087" num="0086">The benefit of multi-layer computation is that it is based on fast graph look up and paralleled graph computation. Therefore, it is overall very efficient. Furthermore, a user can clearly shown (by layered organization of information) when data are added and how these data is interacting with existing data by precious ETLs in deriving new data items. The effect such a proposed technique is that, in a same layer, old nodes that contributes to a new node tend to cluster together and also, graph structures that shared same nodes tends to cluster together. This can be leveraged to design a layered information management system, which provides a nice archive of related data and knowledge. With that, a user need not to traverse discrete knowledge graphs to locate each node of their interests. A user can easily check what data elements are missed in order to derive more advanced data nodes (in the upper layer).</p><p id="p-0088" num="0087">Local Re-Computation</p><p id="p-0089" num="0088">A user can reconfigure parts in the graph and specify a node to be re-computed. For example, a user may want to try out a cutting-edge classification algorithm that identifies if a radiology report has indicated relapsed tumour. The user replaces an old algorithm node in the graph and re-runs the graph. However, the re-run will not affect other nodes, only related ones. Similarly, the user can replace any functional nodes in the graph. For instance, the user redefined query transaction of a clinical document from database, making it faster. The proposed system propagates re-computation flows to all downstream nodes that are related to this transaction.</p><p id="p-0090" num="0089">Applications of the Invention</p><p id="p-0091" num="0090">A primary application of the proposed invention is information extraction and ETL. The proposed architecture allows the Extract-step and Transform-step to become easily configurable and more coherently, reducing overheads. Another category of applications falls into knowledge computing and management for decision support. Although examples have been shown above based on rule-based decision making, every function node is replaceable, so that automated algorithms can be plugged and validated within a graph structure. Because the proposed techniques connect medical database with computational knowledge and external knowledgebase, they can contribute to search and QA applications, e.g. medical search engines or Chat-bots. Also, because the proposed system deals with gradually increased data, it can be useful for event monitoring, e.g. recurrence early detection, adverse drug reaction, etc.</p><p id="p-0092" num="0091"><figref idref="DRAWINGS">FIG. <b>8</b></figref> illustrates an example of a computer <b>60</b> for implementing an embodiment of a system as described above.</p><p id="p-0093" num="0092">The computer <b>60</b> includes, but is not limited to, PCs, workstations, laptops, PDAs, palm devices, servers, storages, and the like. Generally, in terms of hardware architecture, the computer <b>60</b> may include one or more processors <b>61</b>, memory <b>62</b>, and one or more I/O devices <b>63</b> that are communicatively coupled via a local interface (not shown). The local interface can be, for example but not limited to, one or more buses or other wired or wireless connections, as is known in the art. The local interface may have additional elements, such as controllers, buffers (caches), drivers, repeaters, and receivers, to enable communications. Further, the local interface may include address, control, and/or data connections to enable appropriate communications among the aforementioned components.</p><p id="p-0094" num="0093">The processor <b>61</b> is a hardware device for executing software that can be stored in the memory <b>62</b>. The processor <b>61</b> can be virtually any custom made or commercially available processor, a central processing unit (CPU), a digital signal processor (DSP), or an auxiliary processor among several processors associated with the computer <b>60</b>, and the processor <b>61</b> may be a semiconductor based microprocessor (in the form of a microchip) or a microprocessor.</p><p id="p-0095" num="0094">The memory <b>62</b> can include any one or combination of volatile memory elements (e.g., random access memory (RAM), such as dynamic random access memory (DRAM), static random access memory (SRAM), etc.) and non-volatile memory elements (e.g., ROM, erasable programmable read only memory (EPROM), electronically erasable programmable read only memory (EEPROM), programmable read only memory (PROM), tape, compact disc read only memory (CD-ROM), disk, diskette, cartridge, cassette or the like, etc.). Moreover, the memory <b>62</b> may incorporate electronic, magnetic, optical, and/or other types of storage media. Note that the memory <b>62</b> can have a distributed architecture, where various components are situated remote from one another, but can be accessed by the processor <b>61</b>.</p><p id="p-0096" num="0095">The software in the memory <b>62</b> may include one or more separate programs, each of which comprises an ordered listing of executable instructions for implementing logical functions. The software in the memory <b>62</b> includes a suitable operating system (O/S) <b>64</b>, compiler <b>65</b>, source code <b>66</b>, and one or more applications <b>67</b> in accordance with exemplary embodiments.</p><p id="p-0097" num="0096">The application <b>67</b> comprises numerous functional components such as computational units, logic, functional units, processes, operations, virtual entities, and/or modules.</p><p id="p-0098" num="0097">The operating system <b>64</b> controls the execution of computer programs, and provides scheduling, input-output control, file and data management, memory management, and communication control and related services.</p><p id="p-0099" num="0098">Application <b>67</b> may be a source program, executable program (object code), script, or any other entity comprising a set of instructions to be performed. When a source program, then the program is usually translated via a compiler (such as the compiler <b>65</b>), assembler, interpreter, or the like, which may or may not be included within the memory <b>62</b>, so as to operate properly in connection with the operating system <b>64</b>. Furthermore, the application <b>67</b> can be written as an object oriented programming language, which has classes of data and methods, or a procedure programming language, which has routines, subroutines, and/or functions, for example but not limited to, C, C++, C#, Pascal, BASIC, API calls, HTML, XHTML, XML, ASP scripts, JavaScript, FORTRAN, COBOL, Perl, Java, ADA, .NET, and the like.</p><p id="p-0100" num="0099">The I/O devices <b>63</b> may include input devices such as, for example but not limited to, a mouse, keyboard, scanner, microphone, camera, etc. Furthermore, the I/O devices <b>63</b> may also include output devices, for example but not limited to a printer, display, etc. Finally, the I/O devices <b>63</b> may further include devices that communicate both inputs and outputs, for instance but not limited to, a network interface controller (NIC) or modulator/demodulator (for accessing remote devices, other files, devices, systems, or a network), a radio frequency (RF) or other transceiver, a telephonic interface, a bridge, a router, etc. The I/O devices <b>63</b> also include components for communicating over various networks, such as the Internet or intranet.</p><p id="p-0101" num="0100">When the computer <b>60</b> is in operation, the processor <b>61</b> is configured to execute software stored within the memory <b>62</b>, to communicate data to and from the memory <b>62</b>, and to generally control operations of the computer <b>60</b> pursuant to the software. The application <b>67</b> and the operating system <b>64</b> are read, in whole or in part, by the processor <b>61</b>, perhaps buffered within the processor <b>61</b>, and then executed.</p><p id="p-0102" num="0101">When the application <b>67</b> is implemented in software it should be noted that the application <b>67</b> can be stored on virtually any computer readable medium for use by or in connection with any computer related system or method. In the context of this document, a computer readable medium may be an electronic, magnetic, optical, or other physical device or means that can contain or store a computer program for use by or in connection with a computer related system or method.</p><p id="p-0103" num="0102">Other variations to the disclosed embodiments can be understood and effected by those skilled in the art in practicing the claimed invention, from a study of the drawings, the disclosure, and the appended claims. In the claims, the word &#x201c;comprising&#x201d; does not exclude other elements or steps, and the indefinite article &#x201c;a&#x201d; or &#x201c;an&#x201d; does not exclude a plurality. The mere fact that certain measures are recited in mutually different dependent claims does not indicate that a combination of these measured cannot be used to advantage. Any reference signs in the claims should not be construed as limiting the scope.</p><p id="p-0104" num="0103">Variations to the disclosed embodiments can be understood and effected by those skilled in the art in practicing the claimed invention, from a study of the drawings, the disclosure and the appended claims. In the claims, the word &#x201c;comprising&#x201d; does not exclude other elements or steps, and the indefinite article &#x201c;a&#x201d; or &#x201c;an&#x201d; does not exclude a plurality. A single processor or other unit may fulfill the functions of several items recited in the claims. The mere fact that certain measures are recited in mutually different dependent claims does not indicate that a combination of these measures cannot be used to advantage. If a computer program is discussed above, it may be stored/distributed on a suitable medium, such as an optical storage medium or a solid-state medium supplied together with or as part of other hardware, but may also be distributed in other forms, such as via the Internet or other wired or wireless telecommunication systems. If the term &#x201c;adapted to&#x201d; is used in the claims or description, it is noted the term &#x201c;adapted to&#x201d; is intended to be equivalent to the term &#x201c;configured to&#x201d;. Any reference signs in the claims should not be construed as limiting the scope.</p><?detailed-description description="Detailed Description" end="tail"?></description><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. An ETL pipeline system comprising:<claim-text>an interface configured to obtain a plurality of graph configuration components, each graph configuration component comprising information representative of one or more computational logic rules;</claim-text><claim-text>a computation graph generator configured to generate a computation graph based on the obtained graph configuration components, the generated computation graph comprising: a node for each graph configuration component; and one or more links representative of relationships between the nodes;</claim-text><claim-text>a computation graph adaptor configured to receive, from an external source, external information relating to the graph configuration components, and to adapt the generated computation graph based on the external information; and</claim-text><claim-text>a computation graph runner configured to run the adapted computation graph.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein each graph configuration component comprises at least one of:<claim-text>a database connection;</claim-text><claim-text>a document;</claim-text><claim-text>a data element;</claim-text><claim-text>an algorithm; and</claim-text><claim-text>a computational logic rule.</claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The system of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the algorithm comprises a computational a data extraction rule and/or the computational logic rule comprises a computational decision rule.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the external information comprises at least one of:<claim-text>a user-defined graph configuration component; and</claim-text><claim-text>external knowledge from an external knowledge database.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The system of any of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the external knowledge comprises prior computation graph stored in a database, and whereon the prior computation graph is added to the generated computation graph to generate the adapted computation graph.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The system of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the user-defined graph configuration component comprises information redefining and/or amending one or more graph configuration components.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The system of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein a configuration component comprises a graph configuration file, and wherein the system is configured to redefine the graph configuration file or dependency information indicative of dependency relationships among different graph configuration components based on the user-defined graph configuration component.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the system further comprises a computation graph parser configured to:<claim-text>receive the graph configuration components from the interface; and</claim-text><claim-text>establish a link between different graph configuration components based on the component information and dependency information indicative of dependency relationships among different graph configuration components.</claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The system of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the computation graph parser is further configured to establish a link between the data element and the document based on data items associated with the data element and/or the document.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The system of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the data items comprise at least one of:<claim-text>an identifier;</claim-text><claim-text>a timestamp;</claim-text><claim-text>a content item;</claim-text><claim-text>a context item; and</claim-text><claim-text>an encoding object.</claim-text></claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the computation graph runner is further configured to run the adapted computation graph in an adaptive high-throughput computation.</claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. A medical data processing system comprising an ETL pipeline system according to <claim-ref idref="CLM-00001">claim 1</claim-ref>.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. A method for ETL pipeline processing, the method comprising:<claim-text>obtaining a plurality of graph configuration components, each graph configuration component comprising information representative of one or more computational logic rules;</claim-text><claim-text>generating a computation graph based on the obtained graph configuration components, the generated computation graph comprising: a node for each graph configuration component; and one or more links representative of relationships between the nodes;</claim-text><claim-text>receiving, from an external source, external information relating to the graph configuration components;</claim-text><claim-text>adapting the generated computation graph based on the external information; and</claim-text><claim-text>running the adapted computation graph.</claim-text></claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. A computer program product for ETL pipeline processing, wherein the computer program product comprise a computer readable storage medium having program instructions embodied therewith, the program instructions executable by a processing unit to cause the processing unit to perform a method comprising:<claim-text>obtaining a plurality of graph configuration components, each graph configuration component comprising information representative of one or more computational logic rules;</claim-text><claim-text>generating a computation graph based on the obtained graph configuration components, the generated computation graph comprising: a node for each graph configuration component; and one or more links representative of relationships between the nodes;</claim-text><claim-text>receiving, from an external source, external information relating to the graph configuration components;</claim-text><claim-text>adapting the generated computation graph based on the external information; and</claim-text><claim-text>running the adapted computation graph.</claim-text></claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. A processing system comprising at least one processor and the computer program product of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the at least one processor is adapted to execute the computer program code of said computer program product.</claim-text></claim></claims></us-patent-application>