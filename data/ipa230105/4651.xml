<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004652A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004652</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17664011</doc-number><date>20220518</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>21</main-group><subgroup>57</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>21</main-group><subgroup>56</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>21</main-group><subgroup>577</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>21</main-group><subgroup>562</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>21</main-group><subgroup>566</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>2221</main-group><subgroup>033</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">Quantification of Cyber Risk in Application Workloads</invention-title><us-related-documents><us-provisional-application><document-id><country>US</country><doc-number>63190099</doc-number><date>20210518</date></document-id></us-provisional-application><us-provisional-application><document-id><country>US</country><doc-number>63190100</doc-number><date>20210518</date></document-id></us-provisional-application></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Virsec Systems, Inc.</orgname><address><city>San Jose</city><state>CA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Gupta</last-name><first-name>Satya V.</first-name><address><city>Dublin</city><state>CA</state><country>US</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">Embodiments assess security vulnerability of an application. An embodiment identifies one or more executables associated with an application and identifies one or more libraries associated with the application. In turn, based on the identified one or more executables and identified one or more libraries, static vulnerability of the application and dynamic vulnerability of the application are determined. Then, an indication of security vulnerability of the application is generated based on the determined static vulnerability and the determined dynamic vulnerability.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="99.57mm" wi="158.75mm" file="US20230004652A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="243.16mm" wi="167.81mm" orientation="landscape" file="US20230004652A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="243.16mm" wi="167.81mm" orientation="landscape" file="US20230004652A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="234.53mm" wi="170.43mm" file="US20230004652A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="243.50mm" wi="170.69mm" orientation="landscape" file="US20230004652A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="152.40mm" wi="150.62mm" file="US20230004652A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="249.94mm" wi="166.45mm" orientation="landscape" file="US20230004652A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="141.14mm" wi="145.12mm" orientation="landscape" file="US20230004652A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="173.82mm" wi="139.53mm" orientation="landscape" file="US20230004652A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">RELATED APPLICATIONS</heading><p id="p-0002" num="0001">This application claims the benefit of U.S. Provisional Application No. 63/190,100, filed on May 18, 2021 and U.S. Provisional Application No. 63/190,099 filed on May 18, 2021. The entire teachings of the above applications are incorporated herein by reference.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">BACKGROUND</heading><p id="p-0003" num="0002">With each passing day, cyber-attacks are becoming increasingly sophisticated. Attacks are often targeted to exploit specific vulnerabilities. Various methods and tools exist for identifying these vulnerabilities, but these existing methods and tools are inadequate.</p><heading id="h-0003" level="1">SUMMARY</heading><p id="p-0004" num="0003">Embodiments provide functionality to assess security vulnerability of applications.</p><p id="p-0005" num="0004">The present disclosure provides a method that first, identifies one or more executables associated with an application and identifies one or more libraries associated with the application. In turn, based on the identified one or more executables and identified one or more libraries, the method determines (i) static vulnerability of the application and (ii) determines dynamic vulnerability of the application. An indication of security vulnerability of the application is then generated based on the determined static vulnerability and the determined dynamic vulnerability.</p><p id="p-0006" num="0005">According to an aspect, identifying one or more executables associated with the application and identifying one or more libraries associated with the application includes searching one or more storage volumes associated with one or more workloads implementing the application to identify one or more packages on the one or more storage volumes. An example implementation identifies the one or more executables and the one or more libraries by evaluating the identified one or more packages.</p><p id="p-0007" num="0006">In another aspect, determining the static vulnerability of the application includes identifying at least one of an application name, package name, and version associated with the identified one or more executables and identified one or more libraries. Such an embodiment searches a database for a vulnerability entry matching the identified at least one application name, package name, and version and determines the static vulnerability to be a vulnerability score associated with the matching vulnerability entry.</p><p id="p-0008" num="0007">In yet another aspect, determining the dynamic vulnerability of the application includes extracting a command line of a process spawned in response to a request to run the application. From among the identified one or more executables and identified one or more libraries associated with the application, one or more active executables and one or more active libraries are determined from the extracted command line. An implementation may determine the dynamic vulnerability by searching a database for a vulnerability entry matching the determined one or more active executables and one or more active libraries and determining the dynamic vulnerability to be a vulnerability score associated with the matching vulnerability entry.</p><p id="p-0009" num="0008">According to an aspect, determining the static vulnerability of the application and determining the dynamic vulnerability of the application includes (i) determining a static application vulnerability score and (ii) determining a dynamic application vulnerability score. Determining the dynamic application vulnerability score may include determining a respective dynamic vulnerability score by evaluating application code loaded into memory utilized by each of one or more workloads implementing the application at runtime and, in turn, aggregating the determined respective dynamic vulnerability scores to determine the dynamic application vulnerability score. Determining the static application vulnerability score may include determining a respective static vulnerability score by evaluating application code stored on memory utilized by each of one or more workloads implementing the application. The determined respective static vulnerability scores may be aggregated to determine the static application vulnerability score.</p><p id="p-0010" num="0009">Generating an indication of security vulnerability of the application based on the determined static vulnerability and the determined dynamic vulnerability may include aggregating the determined static application vulnerability score and the determined dynamic application vulnerability score.</p><p id="p-0011" num="0010">Determining the static vulnerability of the application and determining the dynamic vulnerability of the application may include searching a vulnerability database for one or more vulnerability entries matching the identified one or more executables and the identified one or more libraries. Another aspect of the disclosure creates the vulnerability database by: (i) obtaining vulnerability entries from a plurality of sources, (ii) normalizing the obtained vulnerability entries, and (iii) storing the normalized vulnerability entries in the vulnerability database.</p><p id="p-0012" num="0011">One or more actions may be taken using, or based upon, the generated indication of security vulnerability. In one aspect, the generated indication of security vulnerability is displayed. In another aspect, an alarm is generated in response to the generated indication of security vulnerability being above a threshold. In yet another aspect, at least one of an at risk executable and an at risk library is indicated to a user based on the generated indication of security vulnerability.</p><p id="p-0013" num="0012">The identifying one or more executables, the identifying one or more libraries, the determining static vulnerability, the determining dynamic vulnerability, and the generating may be performed in response to a request to run the application.</p><p id="p-0014" num="0013">The disclosure also provides a system to assess security vulnerability of applications. The system includes a processor and a memory with computer code instructions stored thereon. The processor and the memory, with the computer code instructions, are configured to cause the system to implement any embodiments or combination of embodiments described herein.</p><p id="p-0015" num="0014">Further still, the disclosure provides a computer program product for assessing security vulnerability of applications. The computer program product comprises one or more non-transitory computer-readable storage devices and program instructions stored on at least one of the one or more storage devices. The program instructions, when loaded and executed by a processor, cause an apparatus associated with the processor to assess security vulnerability of applications as described herein.</p><p id="p-0016" num="0015">It is noted that embodiments of the method, system, and computer program product may be configured to implement any embodiments or combination of embodiments described herein.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0017" num="0016">The foregoing will be apparent from the following more particular description of example embodiments, as illustrated in the accompanying drawings in which like reference characters refer to the same parts throughout the different views. The drawings are not necessarily to scale, emphasis instead being placed upon illustrating embodiments.</p><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram illustrating a legacy or monolith service web application that may be analyzed using embodiments.</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a block diagram illustrating a cloud native or microservice web application that may be analyzed using embodiments.</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a schematic block diagram representation of an example software infrastructure subject to embodiments.</p><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a block diagram showing an example workload subject to embodiments.</p><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a flowchart of a method for assessing security vulnerability of an application according to an embodiment.</p><p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a simplified block diagram of a system for assessing static and dynamic cyber risk in a workload according to an embodiment.</p><p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. <b>7</b></figref> illustrates a computer network or similar digital processing environment in which embodiments may be implemented.</p><p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a diagram illustrating an example internal structure of a computer in the environment of <figref idref="DRAWINGS">FIG. <b>7</b></figref>.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0005" level="1">DETAILED DESCRIPTION</heading><p id="p-0026" num="0025">A description of example embodiments follows.</p><p id="p-0027" num="0026">Every day, scores of new vulnerabilities in commonly used software get reported into various vulnerability databases such as the National Vulnerability Database. As a result, a production application that was not vulnerable yesterday could easily be considered vulnerable today. With thousands of applications being hosted in production environments, it is difficult to quantify, monitor, and report changes in cyber risk in an enterprise's software infrastructure.</p><p id="p-0028" num="0027">Currently, enterprise information technology uses their favorite vulnerability assessment tools, e.g., scanners, that can leverage agents installed on workloads to look for known vulnerable code installed on the workloads. Unfortunately, this mechanism suffers from several drawbacks. First, existing scanners cannot provide the real cyber risk at runtime. In particular, not all vulnerable code on a workload is running at any given time. Further, existing scanners cannot track risk even as vulnerable processes start and terminate. Also, existing scanners do not have a sense of an application's full geometry. This is particularly true if the application's workloads are spread across several clouds, data centers, and subnets. It is also problematic that existing vulnerability assessment tools need to be run manually and/or on a calendar-based trigger instead of on a continuous basis. Problematically, existing scanners leverage vulnerability databases that can lag real vulnerabilities by as much as ten-days. Existing methods also generate false positives when similar sounding package names cause the wrong application to be picked for vulnerability quantification. In addition to generating false positives, gaps in existing risk scanner technology and the absence of a complete database result in existing functionality providing false negatives.</p><p id="p-0029" num="0028">The foregoing factors undermine the real risk posture that an enterprise is exposed to. Embodiments described herein address the abovementioned shortcomings and allow users to easily quantify the cyber risk of an enterprise on a continuous basis even as a tsunami of new third-party vulnerabilities get disclosed into vulnerability databases every day.</p><p id="p-0030" num="0029">Legacy And Cloud Native Applications</p><p id="p-0031" num="0030">Users have been slowly migrating from legacy or monolith applications to cloud native or microservices-based applications. Under the hoods, as the name suggests, instead of deploying a large monolith application, cloud native, i.e., microservices-based applications, disaggregate the overall functionality of monolith applications into smaller, modular chunks. This disaggregation allows microservices-based applications to be upgraded and patched without deploying the full application all over again. Another advantage of microservices based applications is that a hot microservice can scale independently of the other microservices that are not invoked as much. Scaling the entire monolith application is also not desirable.</p><p id="p-0032" num="0031">A legacy, i.e., monolith, application <b>100</b> is represented in <figref idref="DRAWINGS">FIG. <b>1</b></figref>. In this monolith application <b>100</b> represented in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, all individual functionality (operations <b>102</b><i>a</i>, access <b>102</b><i>b</i>, node manager <b>102</b><i>c</i>, messenger <b>102</b><i>d</i>, distributed tracing <b>102</b><i>e</i>, and topology <b>102</b><i>f</i>) is packaged in one monolith workload <b>103</b>. This common functionality <b>102</b><i>a</i>-<i>f </i>shares a local or remote common database <b>104</b> workload as well. As such, each individual function <b>102</b><i>a</i>-<i>d </i>sends respective data <b>105</b><i>a</i>, <b>105</b><i>b</i>, <b>105</b><i>ca</i>, <b>105</b><i>cb</i>, and <b>105</b><i>d </i>to the common database <b>104</b>. Intercommunication between discrete functionality <b>102</b><i>a</i>-<i>d </i>in the monolith application <b>100</b> is typically performed via a very fast inter-process communication (IPC) mechanism such as shared memory or pipes/fifos. This is possible since the entire functionality <b>102</b><i>a</i>-<i>f </i>of the workload <b>103</b> lives on one host <b>106</b>.</p><p id="p-0033" num="0032">In operation, the application <b>100</b> is accessed by the client applications which include a mobile application <b>101</b><i>a</i>, traditional web application <b>101</b><i>b</i>, and single-page web application <b>101</b><i>c</i>. The mobile application <b>101</b><i>a </i>and single-page web application <b>101</b><i>c </i>access the functionality <b>102</b><i>a</i>-<i>f </i>of the application <b>100</b> via the application programming interface (API) gateway <b>107</b>. The traditional web application <b>101</b><i>b </i>accesses the application <b>100</b> via the web application service <b>108</b> and API gateway <b>107</b>.</p><p id="p-0034" num="0033">The monolith application <b>100</b> runs on top of operating system (OS) provided runtime processes and services. In addition, the application <b>100</b> may leverage third party binary and interpreted code (executables and libraries) as well as first party code (executables and libraries). All this code, i.e., third party binary code, third party interpreted code, and first party code, may contain vulnerabilities, some of which are known, and others that may be latent or unknown at a given moment in time.</p><p id="p-0035" num="0034">The application <b>100</b> can be delivered as a microservices based-application. <figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates an example application <b>220</b>, which is a microservices based version of the application <b>100</b>. As can be seen, the functionality <b>102</b><i>a</i>-<i>f </i>of the monolith application <b>100</b> is broken into individual services <b>222</b><i>a</i>-<i>f </i>(aka containers) with individual databases <b>224</b><i>a</i>-<i>d </i>and web connections <b>229</b><i>a</i>-<i>b</i>. Such web connections <b>229</b><i>a</i>-<i>b </i>may permit a service <b>222</b><i>e</i>-<i>f </i>to forward a request to a remote database or to another service via the Internet or other such network connections. Each functionality <b>222</b><i>a</i>-<i>f </i>can live on one or more host <b>226</b> or workload <b>223</b><i>a</i>-<i>f</i>. The communication between individual microservices <b>222</b><i>a</i>-<i>f </i>is via messages <b>225</b><i>a</i>-<i>f </i>that are brokered by an event bus <b>230</b>. Individual user transactions weave through one or more microservices <b>222</b><i>a</i>-<i>f </i>and when the full transaction is completed successfully, each service involved in the transaction synchronizes its respective database <b>224</b>-<i>d </i>atomically. Conversely, if the transaction fails, changes to the individual databases <b>224</b><i>a</i>-<i>d </i>are not committed.</p><p id="p-0036" num="0035">Similar to the application <b>100</b>, in operation the application <b>220</b> is accessed by the client applications, which include a mobile application <b>101</b><i>a</i>, traditional web application <b>101</b><i>b</i>, and single-page web application <b>101</b><i>c</i>. The mobile application <b>101</b><i>a </i>and single-page web application <b>101</b><i>c </i>access the functionality <b>222</b><i>a</i>-<i>f </i>of the application <b>220</b> via the application programming interface (API) gateway <b>107</b>. The traditional web application <b>101</b><i>b </i>accesses the application <b>220</b> via the web application service <b>108</b> and API gateway <b>107</b>.</p><p id="p-0037" num="0036">How to Evaluate Cyber Risk of an Application?</p><p id="p-0038" num="0037">Software infrastructure, e.g., the software infrastructure utilized by an organization, can be visualized as being segmented at different tiers such as on a per Business Unit basis, per application within that business unit, per private/public cloud provider or data center. The application's infrastructure may further be segmented based on a location within the data center and a subnet in the said data center. Workloads themselves can be individual workloads or a high-availability or load balanced cluster of identical workloads.</p><p id="p-0039" num="0038">An example of such a visualization is shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref>. Particularly, <figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates software application infrastructure environment <b>330</b> of an enterprise in which embodiments for determining application vulnerability as described herein may be employed.</p><p id="p-0040" num="0039">In the environment <b>330</b>, a workload may include a monolith (e.g., <b>100</b>) or microservices-based (e.g., <b>220</b>) software application. Such an application may be installed at additional workloads deployed across a network.</p><p id="p-0041" num="0040">In <figref idref="DRAWINGS">FIG. <b>3</b></figref>, applications <b>331</b><i>a </i>and <b>331</b><i>n</i>, locations <b>332</b><i>a </i>and <b>332</b><i>n</i>, demilitarized zone (DMZ) <b>333</b>, subnet zone <b>335</b><i>a </i>and subnet zone <b>335</b><i>n</i>, services <b>336</b><i>a</i>-<i>c</i>, load balancer <b>337</b>, and workloads <b>338</b><i>a</i>, <b>338</b><i>b</i>, <b>338</b><i>c</i>, and <b>338</b><i>n </i>represent network topology of an aspect of the workloads <b>338</b><i>a</i>, <b>338</b><i>b</i>, <b>338</b><i>c</i>, and <b>338</b><i>n</i>, such as an application. Depicted in the lowest layer of the network topology are individual workloads <b>338</b><i>a</i>, <b>338</b><i>b</i>, <b>338</b><i>c</i>, and <b>338</b><i>n </i>that provide the application functionality. Such individual workloads <b>338</b><i>a</i>, <b>338</b><i>b</i>, <b>338</b><i>c</i>, and <b>338</b><i>n </i>may comprise three layers, including an infrastructure layer, a virtualization layer, and a service layer as described hereinbelow in relation to <figref idref="DRAWINGS">FIG. <b>4</b></figref>. In such an embodiment, code used within a given workload <b>338</b><i>a</i>, <b>338</b><i>b</i>, <b>338</b><i>c</i>, and <b>338</b><i>n </i>can be resident in either the file system or in memory. The network environment <b>330</b> may include an intranet <b>339</b> connected to the Internet <b>340</b> and as such may be accessed by an end-user <b>341</b>. In some cases, the end-user <b>341</b> may be a malicious attacker.</p><p id="p-0042" num="0041">Continuing with respect to <figref idref="DRAWINGS">FIG. <b>3</b></figref>, deployed upon the intranet <b>339</b> is business logic for respective business units, which may include a first business unit <b>342</b><i>a </i>and other business units up to and including a Tth business unit <b>342</b><i>n</i>. Such business units <b>342</b><i>a </i>and <b>342</b><i>n </i>may also be referred to as tenants. Within the business logic for the business units <b>342</b><i>a</i>, <b>342</b><i>n </i>are software applications <b>331</b><i>a</i>, <b>331</b><i>n</i>. While only a first application <b>331</b><i>a </i>and second application <b>331</b><i>n </i>are depicted, the business units <b>342</b><i>a </i>and <b>342</b><i>n </i>may utilize any number of applications. Each such application <b>331</b><i>a</i>, <b>331</b><i>n </i>is deployed on at least one location <b>332</b><i>a</i>, <b>332</b><i>n</i>, which may be a cloud location, on premises location, or other such location known in the art. Within the locations <b>331</b><i>a</i>, <b>331</b><i>n </i>is deployed a demilitarized zone <b>334</b>, beyond which are deployed at least one subnet from a first subnet zone <b>335</b><i>a </i>to a Zth subnet zone <b>335</b><i>n</i>. Various services <b>336</b><i>a</i>-<i>c </i>are deployed within the subnets <b>335</b><i>a</i>, <b>335</b><i>n</i>. In particular, services <b>336</b><i>a </i>and <b>336</b><i>b </i>are deployed on subnet zone <b>335</b><i>a </i>and service <b>336</b><i>c </i>is deployed on subnet zone <b>335</b><i>n</i>. Within each service <b>336</b><i>a</i>-<i>c</i>, are deployed workloads <b>338</b><i>a</i>-<i>n</i>. The service <b>336</b><i>a </i>is implemented using the workload <b>338</b><i>a </i>and the service <b>336</b><i>b </i>is implemented using the workload <b>338</b><i>b</i>. Likewise, the service <b>336</b><i>c </i>is deployed using both the workloads <b>338</b><i>c </i>and <b>338</b><i>n </i>and the load balancer <b>337</b>. Upon each workload <b>338</b><i>a</i>-<i>n</i>, one or more application service instance (not shown) may be deployed. Each application service instance includes an infrastructure hardware layer, a virtualization layer, and a service, which may include operating system runtime packages, compatible precompiled binary packages, and compatible byte code packages.</p><p id="p-0043" num="0042">Individual workloads, e.g., the workloads <b>338</b><i>a</i>, <b>338</b><i>b</i>, <b>338</b><i>c</i>, and <b>338</b><i>n </i>are composed of three layers as shown by the example workload <b>440</b> in <figref idref="DRAWINGS">FIG. <b>4</b></figref>. <figref idref="DRAWINGS">FIG. <b>4</b></figref> illustrates an individual workload <b>440</b> that may be deployed upon a network to enable functionality of software such as an application. Such a workload <b>440</b> includes an infrastructure layer <b>441</b>, a virtualization layer <b>448</b>, and a service layer <b>459</b>. So configured, such a workload <b>440</b> may be referred to as an application service instance (ASI). The infrastructure layer <b>441</b> defines attributes such as compute, storage, and host operating system (OS) attributes. This layer can be provided and managed by either a 1<sup>st </sup>or 3<sup>rd </sup>party cloud provider or a private data center provider. The ASI shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref> includes a collection of components comprising a monolith service or a microservice <b>470</b>. Such a collection <b>470</b> includes virtual machines <b>449</b><i>a</i>, containers <b>449</b><i>b</i>, and serverless functions <b>449</b><i>c</i>. The ASI shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref> encompasses a workload <b>440</b> deployed on a server.</p><p id="p-0044" num="0043">The lowest layer of the workload <b>440</b> is called the compute or infrastructure layer <b>441</b>. The infrastructure layer <b>441</b> includes physical hardware <b>442</b>, persistent storage <b>443</b> available on the network, a host device <b>444</b> with a processor and memory, a physical network interface card <b>445</b>, local storage <b>446</b>, and a host operating system <b>447</b>. As such, the layer <b>441</b> is composed of not only the compute <b>442</b>, memory <b>444</b>, networking <b>445</b>, and storage (local <b>446</b> and remote <b>443</b>) components, but also the host operating system <b>447</b>.</p><p id="p-0045" num="0044">The layer in the center of the workload <b>440</b> is called the virtualization layer <b>448</b>. This layer <b>448</b> allows users to specify the virtualization technology that isolates the application's business logic from the underlying infrastructure layer <b>441</b>. There are three virtualization options&#x2014;the virtual machine <b>449</b><i>a</i>, the container <b>449</b><i>b</i>, and the serverless option <b>449</b><i>c. </i></p><p id="p-0046" num="0045">The virtualization layer <b>448</b> may include a hypervisor <b>450</b> and a guest entity <b>451</b> that may include a virtual processor and memory. The virtual layer <b>448</b> may also include a virtual network interface card <b>452</b>, a virtual disk <b>453</b>, and may have an operating system <b>454</b> installed thereupon. The virtual layer <b>448</b> also includes, for container applications <b>449</b><i>b</i>, container mounts <b>455</b>, container runtime components <b>456</b>, and network plugin <b>457</b>. The virtualization layer <b>448</b> may also include a serverless <b>449</b><i>c </i>function handler <b>458</b>.</p><p id="p-0047" num="0046">The workload's virtualization layer <b>448</b> defines attributes such as a virtualization type, which may be implemented as a bare metal instance, a virtual machine instance <b>449</b><i>a</i>, a container instance <b>449</b><i>b</i>, or a serverless function <b>449</b><i>c</i>. This layer <b>448</b> can be provided and managed by either the 1<sup>st </sup>party (where the application and infrastructure are owned and operated by the same entity) or by 3<sup>rd </sup>parties (where the application and infrastructure are owned and operated by different entities).</p><p id="p-0048" num="0047">The top layer of the workload <b>440</b> is the service layer <b>459</b>. In operation, the hypervisor <b>450</b> of the virtual layer <b>448</b> may, through the operating system <b>454</b>, connect to one or more virtual machines <b>449</b><i>a </i>that are part of the service layer <b>459</b>. Such virtual machines <b>449</b><i>a </i>may include handlers <b>460</b><i>a</i>, <b>460</b><i>b</i>, <b>460</b><i>c</i>, <b>460</b><i>d</i>, application programming interface (API) or web logic or databases <b>461</b><i>a</i>, <b>461</b><i>b</i>, third-party binaries <b>462</b><i>a</i>, operating system runtime binaries <b>463</b>, web frameworks <b>464</b><i>a</i>, <b>464</b><i>b</i>, binary framework <b>465</b><i>a</i>, operating system services <b>466</b>, and process name spaces <b>467</b><i>a</i>, <b>467</b><i>b</i>, <b>467</b><i>c. </i></p><p id="p-0049" num="0048">In embodiments operating upon software configured as containers <b>449</b><i>b</i>, the service layer <b>459</b> includes handlers <b>460</b><i>e</i>, <b>460</b><i>f</i>, API or web logic or database <b>461</b><i>c</i>, web frameworks <b>464</b><i>c</i>, process namespace <b>467</b><i>d</i>, <b>467</b><i>e</i>, third-party binaries <b>462</b><i>b</i>, and binary frameworks <b>465</b><i>b. </i></p><p id="p-0050" num="0049">In serverless configurations <b>449</b><i>c</i>, a serverless function handler <b>458</b> interfaces with handles <b>460</b><i>g</i>, <b>460</b><i>h</i>, respectively through APIs or web or business logic functions <b>468</b>, and binary functions <b>469</b>.</p><p id="p-0051" num="0050">The service layer <b>459</b> describes the logical part of the application implemented used the monolith or microservice collection <b>470</b> implemented using the workload <b>440</b>. As can be seen in <figref idref="DRAWINGS">FIG. <b>4</b></figref>, the memory subsystem is indicated by a collection of processes <b>467</b><i>a</i>-<i>e </i>that execute code <b>461</b><i>a</i>-<i>c</i>, <b>462</b><i>a</i>-<i>b</i>, <b>463</b>, <b>468</b>, and <b>469</b> that may be from one or more packages or frameworks <b>464</b><i>a</i>-<i>c</i>, <b>465</b><i>a</i>-<i>b</i>, <b>466</b>. These frameworks could be web (or API Frameworks) <b>464</b><i>a</i>-<i>c</i>, Binary <b>465</b><i>a</i>-<i>b</i>, or OS Runtime services (aka Host Framework) <b>466</b>. The processes <b>467</b><i>a</i>-<i>e </i>from the one or more frameworks <b>464</b><i>a</i>-<i>c</i>, <b>465</b><i>a</i>-<i>b</i>, and <b>466</b> described above not only load code but also open handles <b>460</b><i>a</i>-<i>h </i>on non-code files such as configuration files, log files, content files etc. Processes <b>467</b><i>a</i>-<i>e </i>can also have handles open on other workloads that form part of the overall end user application.</p><p id="p-0052" num="0051">The service layer <b>459</b> contains active code that provides the application's observable functionality. The service layer <b>459</b> can be powered by a mixture of OS and OS-provided runtime services (e.g., a host framework), one or more 1<sup>st </sup>or 3<sup>rd </sup>party precompiled executables and libraries (e.g., binary frameworks), and one or more 1<sup>st </sup>or 3<sup>rd </sup>party interpreted code files (e.g., interpreted frameworks).</p><heading id="h-0006" level="2">Automatic and On-Demand Evaluation</heading><p id="p-0053" num="0052">In current application implementations, such as those described hereinabove in relation to <figref idref="DRAWINGS">FIG. <b>3</b></figref> and <figref idref="DRAWINGS">FIG. <b>4</b></figref>, evaluating cyber risk entails determining the risk from individual workloads. For instance, quantifying the cyber risk for the application <b>331</b><i>a </i>entails aggregating the cyber risk from individual workloads <b>338</b><i>a</i>, <b>338</b><i>b</i>, <b>338</b><i>c</i>, and <b>338</b><i>n</i>. Vulnerability databases leverage a common metric called the Common Vulnerability Security Score (CVSS). A CVSS score between 9.0 and 10.0 is considered Critical. A score between 7.0 to 8.9 is considered High. A score between 4.0 and 6.9 is considered Medium. Attacks that are conducted from remote networks are considered more lethal than attacks that are conducted from local networks because it is typically more difficult to conduct the attack from inside the enterprise for fear of being caught. Similarly, attacks that require privileges are considered harder to mount since such attacks involve stealing a specific user's credentials.</p><p id="p-0054" num="0053">Embodiments provide a solution that evaluates both the static and dynamic risk associated with code present on the disk and in the memory subsystems of a workload. <figref idref="DRAWINGS">FIG. <b>5</b></figref> is a flow diagram of a method <b>550</b> for determining the risk of an application according to an embodiment. Amongst other examples, the method <b>550</b> may be used to determine the risk of: the application <b>100</b> described hereinabove in relation to <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the application <b>220</b> described hereinabove in relation to <figref idref="DRAWINGS">FIG. <b>2</b></figref>, the applications <b>331</b><i>a </i>and <b>331</b><i>n </i>described hereinabove in relation to <figref idref="DRAWINGS">FIG. <b>3</b></figref>, the ASI <b>470</b> described hereinabove in relations to <figref idref="DRAWINGS">FIG. <b>4</b></figref>, and a collection of ASIs.</p><p id="p-0055" num="0054">The method <b>550</b> is computer implemented and, as such, may be implemented using any computing device, or combination of computing devices known in the art. Further, the method <b>550</b> may be implemented by the risk computation engine <b>666</b> described hereinbelow in relation to <figref idref="DRAWINGS">FIG. <b>6</b></figref>.</p><p id="p-0056" num="0055">The method <b>550</b> begins, at step <b>551</b>, by first identifying one or more executables associated with an application and, at step <b>552</b>, identifying one or more libraries associated with the application. In turn, at step <b>553</b> the method <b>550</b> determines static vulnerability of the application and determines dynamic vulnerability of the application. In such an embodiment, the static and dynamic vulnerability is determined based on the identified one or more executables (from step <b>551</b>) and identified one or more libraries (from step <b>552</b>). The static vulnerability represents the vulnerability of the application by simply being stored, i.e., in a static state or a vulnerability stored on a file system that has not been turned into a process, and the dynamic vulnerability represents the vulnerability at execution. At step <b>554</b> an indication of security vulnerability of the application is generated based on the determined static vulnerability and the determined dynamic vulnerability.</p><p id="p-0057" num="0056">According to an embodiment, identifying one or more executables associated with the application at step <b>551</b> and identifying one or more libraries associated with the application at step <b>552</b> includes searching one or more storage volumes associated with one or more workloads implementing the application to identify one or more packages on the one or more storage volumes. Such an embodiment identifies the one or more executables and the one or more libraries by evaluating the identified one or more packages. The aforementioned searching may identify multiple packages of the application and, then, from amongst the multiple packages, an embodiment examines packages known to have a vulnerability. Libraries and executables may be identified from the vulnerable packages. In an example embodiment, a package of an application known to have a vulnerability may be analyzed by comparing the package with a vulnerability to a package of the application that does not have a vulnerability. These two packages may be compared to identify the differences between the libraries and executables of the two packages. For example, the libraries and executables can be compared to identify the changed libraries and/or executables so as to identify the library or executables where the vulnerability occurred. According to an embodiment, the searched one or more storage volumes may be at any location that is communicatively coupled, or capable of being communicatively coupled to a computing device implementing the method <b>550</b>. Moreover, the storage volumes can be network based or non-network based.</p><p id="p-0058" num="0057">In an embodiment, determining the static vulnerability of the application at step <b>553</b> includes identifying at least one of an application name, package name, and version associated with the identified one or more executables and identified one or more libraries. Such an embodiment searches a database for a vulnerability entry matching the identified at least one application name, package name, and version and determines the static vulnerability to be a vulnerability score associated with the matching vulnerability entry.</p><p id="p-0059" num="0058">In an embodiment, determining the dynamic vulnerability of the application at step <b>553</b> includes extracting a command line of a process spawned in response to a request to run the application. From among the identified one or more executables and identified one or more libraries associated with the application, one or more active executables and one or more active libraries are determined from the extracted command line. These active executables and active libraries are the executables and libraries actually being used. The active executables and libraries are in contrast to executables and libraries that are part of an application, but that are not being used as part of a specific execution. To illustrate, consider an example of an application that includes executables A and B. At a specific point in time, only executable A is being used and, in such an implementation, executable A is considered the active executable. In such an example, vulnerabilities associated with executable A are considered in determining the dynamic vulnerability. However, executables associated with executable B are not considered when determining the dynamic vulnerability because executable B is not being employed. In contrast, vulnerabilities associated with both executable A and B are considered when determining static vulnerability.</p><p id="p-0060" num="0059">An implementation of the method <b>550</b> may determine the dynamic vulnerability at step <b>553</b> by searching a database for a vulnerability entry matching the determined one or more active executables and one or more active libraries and determining the dynamic vulnerability to be a vulnerability score associated with the matching vulnerability entry.</p><p id="p-0061" num="0060">In another embodiment, determining the static vulnerability of the application and determining the dynamic vulnerability of the application at step <b>553</b> includes (i) determining a static application vulnerability score and (ii) determining a dynamic application vulnerability score. Determining the dynamic application vulnerability score may include determining a respective dynamic vulnerability score by evaluating application code loaded into memory utilized by each of one or more workloads implementing the application at runtime and, in turn, aggregating the determined respective dynamic vulnerability scores to determine the dynamic application vulnerability score. Determining the static application vulnerability score may include determining a respective static vulnerability score by evaluating application code stored on memory utilized by each of one or more workloads implementing the application. The determined respective static vulnerability scores may be aggregated to determine the static application vulnerability score. In this way, embodiments can aggregate the risk across workloads.</p><p id="p-0062" num="0061">Determining the static vulnerability of the application and determining the dynamic vulnerability of the application at step <b>553</b> may also include searching a vulnerability database for one or more vulnerability entries matching the identified one or more executables and the identified one or more libraries. An embodiment of the method <b>550</b> does a rigid searching where all characteristics, e.g., name, version, etc., match an entry in the database. This rigid searching helps to eliminate false positives.</p><p id="p-0063" num="0062">Another embodiment of the method <b>550</b> creates the vulnerability database used for determining the vulnerability at step <b>553</b>. An example embodiment creates the vulnerability database by: (i) obtaining vulnerability entries from a plurality of sources, (ii) normalizing the obtained vulnerability entries, and (iii) storing the normalized vulnerability entries in the vulnerability database.</p><p id="p-0064" num="0063">Generating an indication of security vulnerability of the application based on the determined static vulnerability and the determined dynamic vulnerability at step <b>554</b> may include aggregating the determined static application vulnerability score and the determined dynamic application vulnerability score. Embodiments of the method <b>550</b> may also take one or more actions using, or based upon, the generated indication of security vulnerability. For example, one such embodiment of the method <b>550</b> displays the generated indication of security vulnerability. Another embodiment of the method <b>550</b> generates an alarm in response to the generated indication of security vulnerability being above a threshold. In yet another embodiment, at least one of an at risk executable and an at risk library is indicated to a user based on the generated indication of security vulnerability. Further, embodiments may provide a ranking of the at risk executables and libraries. For example, such an embodiment may provide a listing from most risky to least risky, so that users can prioritize addressing the at risk executables and libraries.</p><p id="p-0065" num="0064">Embodiments of the method <b>550</b> may be also be repeated for multiple applications associated with a user, e.g., a business. When repeated for multiple applications, an embodiment may provide a report highlighting the user's most at risk applications along with the most at risk executables and libraries associated with those applications.</p><p id="p-0066" num="0065">Embodiments of the method <b>550</b> may run continuously so as to provide a live indication of security vulnerability. Such a live indication may change as, for instance, an application is being used or not being used. When this occurs, for example, the dynamic vulnerability is nothing when the application is not being used, but when the application is being used the dynamic vulnerability, may for instance, increase. In another embodiment, the method <b>550</b>, e.g., the identifying one or more executables, the identifying one or more libraries, the determining static vulnerability, the determining dynamic vulnerability, and the generating may be performed in response to a request to run the application.</p><p id="p-0067" num="0066">The step <b>553</b> determined static vulnerability and dynamic vulnerability and step <b>554</b> generated indication may include a determination/indication for each of multiple vulnerabilities of the application. Embodiments of the method <b>550</b> may provide a prioritized list of the vulnerabilities to a user. Further, embodiments of the method <b>550</b> may modify the step <b>553</b> determined vulnerabilities and step <b>554</b> generated indication based on the nature of the vulnerability or vulnerabilities of the application. For example, embodiments may consider a vulnerability that accepts user input to be riskier. An embodiment may also consider a vulnerability that is Internet or intranet facing to be riskier. Similarly, an embodiment may consider a vulnerability to be riskier if exploit code for the vulnerability is known. Further, if a vulnerability is tied to an operating system, the vulnerability may be considered to be riskier because the vulnerability is likely widespread. An embodiment, may also determine if an operating system vulnerability exists, i.e., is installed and/or used. Similarly, an embodiment may also consider the size of the user base. Such an embodiment may treat a vulnerability in an application with a large user base to be riskier than a similar vulnerability in an application with a smaller user base.</p><p id="p-0068" num="0067">As noted above, embodiments of the method <b>550</b> may be implemented using any computing device or combination of computing devices known in the art. Further, embodiments can be implemented in an agent-based or agent-less implementation. In an agent-less implementation, embodiments are executed on one or more computing device communicatively coupled, e.g., via an API, to workloads implementing an application. As such, in an agent-less implementation, the one or more computing device executing the method <b>550</b> does not need to be installed on the workloads themselves. Instead, a processing device implementing the method <b>550</b> can connect to workloads via APIs to implement the functionality described herein. Agentless implementations allow embodiments to quickly assess vulnerability when, for example, a new device is brought online to allow a user to implement an application. An agentless implementation will have already assessed the vulnerability of the one or more workloads implementing the application and the new device simply inherits the risk of the one or more workloads. Thus, such an embodiment can utilize the previously determined vulnerability of the workloads as the vulnerability of the device.</p><p id="p-0069" num="0068"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a block diagram of an example system <b>660</b> for evaluating risk according to an embodiment. In the system <b>660</b>, the overall cyber risk for a workload is considered to be composed of two parts (i) static risk (evaluated from code resident on disk of the workload) and (ii) dynamic risk (evaluated from the risk associated with code loaded in runtime memory).</p><p id="p-0070" num="0069">Static Risk Evaluation</p><p id="p-0071" num="0070">The National Vulnerability Database (NVD) and similar vulnerability databases can be queried with specific application and version information to retrieve individual vulnerabilities, i.e., CVEs associated with the queried application and version. Software including an operating system (OS) kernel and its runtime libraries are delivered as packages such as RPMs, TARs, SEAs, and MSIs, amongst other examples. Each package contains one or more executables and libraries. Each executable and/or library in the package has a unique version associated with it. By extracting executable and library names and associated versions from one or more software packages present on a given workload, it is possible to query a vulnerability database and determine details of any vulnerabilities present in said executable/library.</p><p id="p-0072" num="0071">The system <b>660</b> implements executable, library, and associated version querying to evaluate the vulnerability of applications. To implement this functionality, the system <b>660</b> provider API <b>661</b> obtains, via internet <b>662</b>, vulnerability information from diverse external third-party common vulnerability databases (ETPCVDBs) <b>663</b><i>a</i>-<i>b</i>. The provider API <b>661</b> normalizes the data obtained from the diverse ETPCVDBs <b>663</b><i>a</i>-<i>b </i>into a common format and downloads, via the intranet <b>664</b>, the normalized data into the local third-party common vulnerability database (LTPCVDB) <b>665</b>. Later, as the static and dynamic risk computation engine <b>666</b> in each workload <b>667</b> parses individual packages present on the workload <b>667</b>, the system <b>660</b> starts associating vulnerabilities with packages. The determined relationships between packages and vulnerabilities are captured in the local third-party package common vulnerability database (LTPKCVDB) <b>668</b>.</p><p id="p-0073" num="0072">The provider <b>669</b> can also preemptively follow a similar process and update the provider third-party package common vulnerability database (PTPCVDB) <b>670</b> with any packages the provider <b>669</b> can parse with its own resources. The provider <b>669</b> can also provide their own vulnerabilities and store those vulnerabilities in the provider third party common vulnerability database (PTPCVDB) <b>677</b>. Provider API(s) <b>661</b> can leverage this information (data stored on the PTPCVDB <b>670</b> and PTPCVDB <b>677</b>) and can synchronize LTPCVDBs, e.g., <b>665</b>, in individual enterprises.</p><p id="p-0074" num="0073">The presence of the LTPKCVDB <b>668</b> makes the job of the static and dynamic risk computation engine <b>666</b> significantly easier since the process of culling out the common product names and then searching the database for corresponding vulnerabilities gets done once and then this data can be shared across the entire enterprise.</p><p id="p-0075" num="0074">Each vulnerability extracted as above has a CVSS associated with it. By aggregating CVSSs for the packages present on the workload <b>667</b>, it is possible to enumerate the static risk score for the workload <b>667</b> and further aggregate risk scores from all workloads in applications used by an enterprise. This allows the system <b>660</b> to compute the overall risk associated with an application. An enterprise can choose to discontinue use of an application that exceeds a risk threshold.</p><p id="p-0076" num="0075">To evaluate the static risk, the static and dynamic risk computation engine (SDRCE) <b>666</b> examines the one or more volumes (local and remote <b>671</b>) associated with the workload <b>667</b> and extracts all the packages present on the disk <b>671</b>. The SDRCE <b>666</b> then decomposes the application name from the executable and package name and version to search through the LTPCVDB <b>665</b>.</p><p id="p-0077" num="0076">The SDRCE <b>666</b> also informs the CMS <b>672</b> of the current static risk score even as an end-user <b>673</b> updates code on a workstation. When the end-user <b>673</b> performs patching, the score may decrease on account of the older vulnerable package being removed. The static risk score can also increase if the patched product or additional code added by the end user <b>673</b> has vulnerabilities associated with it.</p><p id="p-0078" num="0077">Dynamic Risk Evaluation</p><p id="p-0079" num="0078">Not all the executables and libraries present in the workload's <b>667</b> disk <b>671</b> may be loaded in memory and executing at any given moment of time. As such, the vulnerability of an application may vary depending on the code that is loaded and executing. The system <b>660</b> accounts for this variation by determining dynamic risk. To determine dynamic risk, the endpoint process monitoring client (EPMC) <b>674</b> extracts the command line, provided by the endpoint process monitoring driver (EPMD) <b>675</b> of a process as the process is launched by the operating system <b>676</b>. In turn, the EPMC <b>674</b> identifies the main executable from the extracted command line. The EPMC <b>674</b> then queries the LPKCVDB <b>668</b> using the main executable to determine the runtime risk associated with the workload <b>667</b>.</p><p id="p-0080" num="0079">Some vulnerabilities are associated with libraries and not the main executable. To account for this, the endpoint process monitoring client <b>674</b> also monitors the one or more libraries that load into or unload from process memory at runtime. It is therefore possible for the EPMC <b>674</b> to signal the SDRCE <b>666</b> to quantify and update the risk associated with the said library dynamically.</p><p id="p-0081" num="0080">From time to time, upon computing the aggregate dynamic risk of the workload, the SDRCE <b>666</b> informs the CMS <b>672</b> of the determined risk. The CMS <b>672</b> can take one or more actions depending on the dynamic risk. For instance, the CMS <b>672</b> can display the dynamic risk score and/or generate an alarm if the risk score crosses a threshold.</p><p id="p-0082" num="0081">In embodiments of the system <b>660</b>, the SDRCE <b>666</b> may implement a prioritized methodology for assessing vulnerability. For example, the SDRCE <b>666</b> may first check local storage databases, e.g., LPKCVDB <b>668</b> and LTPCVDB <b>665</b>, to determine vulnerability and, if no vulnerability is identified using the local resources, the SDRCE <b>666</b> may then check the provider databases PTPPKDB <b>670</b> and PTPCVDB <b>677</b>, before finally checking, external third-party databases ETPCVDB <b>663</b><i>a</i>-<i>b. </i></p><p id="p-0083" num="0082">Advantages</p><p id="p-0084" num="0083">Embodiments have numerous advantages over existing methods for assessing vulnerability. Unlike conventional vulnerability scanners that can simply display a risk score, embodiments can pinpoint packages with the most vulnerabilities in addition to being able to display a risk score. This allows end-users to prioritize addressing risks and patching. Further, existing scanners cannot provide the real cyber risk at runtime. Not all vulnerable code on the workload is running at any given time. Embodiments allow end-users to track vulnerabilities that matter and not vulnerabilities that are dormant.</p><p id="p-0085" num="0084">Existing methods cannot track risk even as vulnerable processes start and terminate. Embodiments can track and monitor the risk at run time and, thus, provide a dynamic vulnerability assessment. Embodiments facilitate tracking and monitoring such risk and thereby empower end-users who can now seek a better deal on their corporate cyber insurance. Also problematically, existing vulnerability assessment scanners do not have a sense for an application's full geometry. This is especially true if the application's workloads are spread across several clouds, data centers, and subnets. Embodiments assess risk based on a full view of an application across its topology. This allows enterprises to evaluate and prioritize remedial action on those applications with increased risk.</p><p id="p-0086" num="0085">Unlike scanners that need to be run manually on a calendar-based trigger instead of on a continuous basis, embodiments can run continuously even as new code is installed or removed or even as processes start and libraries get loaded or unloaded into individual processes. Unlike individual scanners that leverage a vulnerability database that can lag real vulnerabilities by as much as ten-days, embodiments de-risk that by normalizing data from multiple feeds.</p><p id="p-0087" num="0086">Scanners generate false positives when similar sounding package names cause the wrong application to be picked for vulnerability quantification. Embodiments allow local package to CVE databases to be updated and remove any inconsistencies. Further, with individual databases, there may be gaps in the scanner's ability to determine the actual risk. This will cause false negatives in the process of vulnerability enumeration. By sourcing data from multiple vulnerability databases, embodiments reduce or eliminate the cyber risk faced by enterprises.</p><p id="p-0088" num="0087">Computer Support</p><p id="p-0089" num="0088"><figref idref="DRAWINGS">FIG. <b>7</b></figref> illustrates a computer network or similar digital processing environment in which embodiments of the present disclosure may be implemented.</p><p id="p-0090" num="0089">Client computer(s)/devices <b>50</b> and server computer(s) <b>60</b> provide processing, storage, and input/output devices executing application programs and the like. The client computer(s)/devices <b>50</b> can also be linked through communications network <b>70</b> to other computing devices, including other client devices/processes <b>50</b> and server computer(s) <b>60</b>. The communications network <b>70</b> can be part of a remote access network, a global network (e.g., the Internet), a worldwide collection of computers, local area or wide area networks, and gateways that currently use respective protocols (TCP/IP, Bluetooth&#xae;, etc.) to communicate with one another. Other electronic device/computer network architectures are suitable.</p><p id="p-0091" num="0090">Client computers/devices <b>50</b> and/or servers <b>60</b> may be configured, alone or in combination, to implement the embodiments described herein, e.g., the method <b>550</b>, amongst other examples. The server computers <b>60</b> may not be separate server computers but part of cloud network <b>70</b>.</p><p id="p-0092" num="0091"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a diagram of an example internal structure of a computer (e.g., client processor/device <b>50</b> or server computers <b>60</b>) in the computer system of <figref idref="DRAWINGS">FIG. <b>7</b></figref>. Each computer <b>50</b>, <b>60</b> contains a system bus <b>79</b>, where a bus is a set of hardware lines used for data transfer among the components of a computer or processing system. The system bus <b>79</b> is essentially a shared conduit that connects different elements of a computer system (e.g., processor, disk storage, memory, input/output ports, network ports, etc.) that enables the transfer of information between the elements. Attached to the system bus <b>79</b> is an input/output (I/O) device interface <b>82</b> for connecting various input and output devices (e.g., keyboard, mouse, displays, printers, speakers, etc.) to the computer <b>50</b>, <b>60</b>. A network interface <b>86</b> allows the computer to connect to various other devices attached to a network (e.g., network <b>70</b> of <figref idref="DRAWINGS">FIG. <b>7</b></figref>). Memory <b>90</b> provides volatile storage for computer software instructions <b>92</b> and data <b>94</b> used to implement an embodiment of the present disclosure (e.g., the method <b>550</b>, amongst others). Disk storage <b>95</b> provides non-volatile storage for computer software instructions <b>92</b> and data <b>94</b> used to implement an embodiment of the present disclosure. A central processor unit <b>84</b> is also attached to the system bus <b>79</b> and provides for the execution of computer instructions.</p><p id="p-0093" num="0092">Embodiments or aspects thereof may be implemented in the form of hardware including but not limited to hardware circuitry, firmware, or software. If implemented in software, the software may be stored on any non-transient computer readable medium that is configured to enable a processor to load the software or subsets of instructions thereof. The processor then executes the instructions and is configured to operate or cause an apparatus to operate in a manner as described herein.</p><p id="p-0094" num="0093">Further, hardware, firmware, software, routines, or instructions may be described herein as performing certain actions and/or functions of the data processors. However, it should be appreciated that such descriptions contained herein are merely for convenience and that such actions in fact result from computing devices, processors, controllers, or other devices executing the firmware, software, routines, instructions, etc.</p><p id="p-0095" num="0094">It should be understood that the flow diagrams, block diagrams, and network diagrams may include more or fewer elements, be arranged differently, or be represented differently. But it further should be understood that certain implementations may dictate the block and network diagrams and the number of block and network diagrams illustrating the execution of the embodiments be implemented in a particular way.</p><p id="p-0096" num="0095">Accordingly, further embodiments may also be implemented in a variety of computer architectures, physical, virtual, cloud computers, and/or some combination thereof, and, thus, the data processors described herein are intended for purposes of illustration only and not as a limitation of the embodiments.</p><p id="p-0097" num="0096">The teachings of all patents, published applications and references cited herein are incorporated by reference in their entirety.</p><p id="p-0098" num="0097">While example embodiments have been particularly shown and described, it will be understood by those skilled in the art that various changes in form and details may be made therein without departing from the scope of the embodiments encompassed by the appended claims.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A computer-implemented method of assessing security vulnerability of an application, the method comprising:<claim-text>identifying one or more executables associated with an application;</claim-text><claim-text>identifying one or more libraries associated with the application;</claim-text><claim-text>based on the identified one or more executables and identified one or more libraries: (i) determining static vulnerability of the application and (ii) determining dynamic vulnerability of the application; and</claim-text><claim-text>generating an indication of security vulnerability of the application based on the determined static vulnerability and the determined dynamic vulnerability.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein identifying one or more executables associated with the application and identifying one or more libraries associated with the application includes:<claim-text>searching one or more storage volumes associated with one or more workloads implementing the application to identify one or more packages on the one or more storage volumes; and</claim-text><claim-text>identifying the one or more executables and the one or more libraries by evaluating the identified one or more packages.</claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein determining the static vulnerability of the application includes:<claim-text>identifying at least one of an application name, package name, and version associated with the identified one or more executables and identified one or more libraries;</claim-text><claim-text>searching a database for a vulnerability entry matching the identified at least one application name, package name, and version; and</claim-text><claim-text>determining the static vulnerability to be a vulnerability score associated with the matching vulnerability entry.</claim-text></claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein determining the dynamic vulnerability of the application includes:<claim-text>extracting a command line of a process spawned in response to a request to run the application; and</claim-text><claim-text>from among the identified one or more executables and identified one or more libraries associated with the application, determining one or more active executables and one or more active libraries from the extracted command line.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref> wherein determining the dynamic vulnerability comprises:<claim-text>searching a database for a vulnerability entry matching the determined one or more active executables and one or more active libraries; and</claim-text><claim-text>determining the dynamic vulnerability to be a vulnerability score associated with the matching vulnerability entry.</claim-text></claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein determining the static vulnerability of the application and determining the dynamic vulnerability of the application includes:<claim-text>determining a static application vulnerability score; and</claim-text><claim-text>determining a dynamic application vulnerability score.</claim-text></claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref> wherein determining the dynamic application vulnerability score comprises:<claim-text>determining a respective dynamic vulnerability score by evaluating application code loaded into memory utilized by each of one or more workloads implementing the application at runtime; and</claim-text><claim-text>aggregating the determined respective dynamic vulnerability scores to determine the dynamic application vulnerability score.</claim-text></claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref> wherein determining the static application vulnerability score includes:<claim-text>determining a respective static vulnerability score by evaluating application code stored on memory utilized by each of one or more workloads implementing the application; and</claim-text><claim-text>aggregating the determined respective static vulnerability scores to determine the static application vulnerability score.</claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref> wherein generating an indication of security vulnerability of the application based on the determined static vulnerability and the determined dynamic vulnerability includes:<claim-text>aggregating the determined static application vulnerability score and the determined dynamic application vulnerability score.</claim-text></claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein determining the static vulnerability of the application and determining the dynamic vulnerability of the application includes:<claim-text>searching a vulnerability database for one or more vulnerability entries matching the identified one or more executables and the identified one or more libraries.</claim-text></claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref> further comprising:<claim-text>creating the vulnerability database by: (i) obtaining vulnerability entries from a plurality of sources, (ii) normalizing the obtained vulnerability entries, and (iii) storing the normalized vulnerability entries in the vulnerability database.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprising at least one of:<claim-text>displaying the generated indication of security vulnerability;</claim-text><claim-text>generating an alarm in response to the generated indication of security vulnerability being above a threshold; and</claim-text><claim-text>indicating at least one of an at risk executable and an at risk library to a user based on the generated indication of security vulnerability.</claim-text></claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the identifying one or more executables, the identifying one or more libraries, the determining static vulnerability, the determining dynamic vulnerability, and the generating is performed in response to a request to run the application.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. A system for assessing security vulnerability of an application, the system comprising:<claim-text>a processor; and</claim-text><claim-text>a memory with computer code instructions stored thereon, the processor and the memory, with the computer code instructions, being configured to cause the system to:<claim-text>identify one or more executables associated with an application;</claim-text><claim-text>identify one or more libraries associated with the application;</claim-text><claim-text>based on the identified one or more executables and identified one or more libraries: (i) determine static vulnerability of the application and (ii) determine dynamic vulnerability of the application; and</claim-text><claim-text>generate an indication of security vulnerability of the application based on the determined static vulnerability and the determined dynamic vulnerability.</claim-text></claim-text></claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The system of <claim-ref idref="CLM-00014">claim 14</claim-ref> wherein, in identifying one or more executables associated with the application and identifying one or more libraries associated with the application, the processor and the memory, with the computer code instructions, are configured to cause the system to:<claim-text>search one or more storage volumes associated with one or more workloads implementing the application to identify one or more packages on the one or more storage volumes; and</claim-text><claim-text>identify the one or more executables and the one or more libraries by evaluating the identified one or more packages.</claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The system of <claim-ref idref="CLM-00014">claim 14</claim-ref> wherein, in determining the static vulnerability of the application, the processor and the memory, with the computer code instructions, are configured to cause the system to:<claim-text>identify at least one of an application name, package name, and version associated with the identified one or more executables and identified one or more libraries;</claim-text><claim-text>search a database for a vulnerability entry matching the identified at least one application name, package name, and version; and</claim-text><claim-text>determine the static vulnerability to be a vulnerability score associated with the matching vulnerability entry.</claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein, in determining the dynamic vulnerability of the application, the processor and the memory, with the computer code instructions, are configured to cause the system to:<claim-text>extract a command line of a process spawned in response to a request to run the application;</claim-text><claim-text>from among the identified one or more executables and identified one or more libraries associated with the application, determine one or more active executables and one or more active libraries from the extracted command line;</claim-text><claim-text>search a database for a vulnerability entry matching the determined one or more active executables and one or more active libraries; and</claim-text><claim-text>determine the dynamic vulnerability to be a vulnerability score associated with the matching vulnerability entry.</claim-text></claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The system of <claim-ref idref="CLM-00014">claim 14</claim-ref> wherein, in determining the static vulnerability of the application and determining the dynamic vulnerability of the application, the processor and the memory, with the computer code instructions, are configured to cause the system to:<claim-text>search a vulnerability database for one or more vulnerability entries matching the identified one or more executables and the identified one or more libraries.</claim-text></claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The system of <claim-ref idref="CLM-00018">claim 18</claim-ref> wherein the processor and the memory, with the computer code instructions, are further configured to cause they system to:<claim-text>create the vulnerability database by: (i) obtaining vulnerability entries from a plurality of sources, (ii) normalizing the obtained vulnerability entries, and (iii) storing the normalized vulnerability entries in the vulnerability database.</claim-text></claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. A computer program product for assessing security vulnerability of an application, the computer program product comprising:<claim-text>one or more non-transitory computer-readable storage devices and program instructions stored on at least one of the one or more storage devices, the program instructions, when loaded and executed by a processor, cause an apparatus associated with the processor to:<claim-text>identify one or more executables associated with an application;</claim-text><claim-text>identify one or more libraries associated with the application;</claim-text><claim-text>based on the identified one or more executables and identified one or more libraries: (i) determine static vulnerability of the application and (ii) determine dynamic vulnerability of the application; and</claim-text><claim-text>generate an indication of security vulnerability of the application based on the determined static vulnerability and the determined dynamic vulnerability.</claim-text></claim-text></claim-text></claim></claims></us-patent-application>