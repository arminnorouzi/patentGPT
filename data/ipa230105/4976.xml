<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004977A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004977</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17363515</doc-number><date>20210630</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>Q</subclass><main-group>20</main-group><subgroup>40</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>Q</subclass><main-group>30</main-group><subgroup>00</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>Q</subclass><main-group>20</main-group><subgroup>4016</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>Q</subclass><main-group>30</main-group><subgroup>018</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">EXPLOITING GRAPH STRUCTURE TO IMPROVE RESULTS OF ENTITY RESOLUTION</invention-title><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Oracle International Corporation</orgname><address><city>Redwood Shores</city><state>CA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Cepek</last-name><first-name>Miroslav</first-name><address><city>Prague</city><country>CZ</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Psaroudakis</last-name><first-name>Iraklis</first-name><address><city>Zurich</city><country>CH</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>Benz</last-name><first-name>Nina Corvelo</first-name><address><city>Kaiserslautern</city><country>DE</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">In an embodiment, a computer stores a bipartite graph that consists of a source subgraph and a target subgraph. Each vertex in the bipartite graph represents an entity. The source subgraph and the target subgraph are connected by many similarity edges. Each similarity edge indicates an original amount of similarity between the entity of a source vertex in the source subgraph and the entity of a target vertex in the target subgraph. For each similarity edge, the computer determines: a set of neighbor source vertices that are reachable from the source vertex of the similarity edge by traversing at most a source radius count of source edges in the source subgraph, a set of neighbor target vertices that are reachable from the target vertex of the similarity edge by traversing at most a target radius count of target edges in the target subgraph, and various amounts based on graph topology. For each similarity edge, the computer calculates a new amount of similarity based on those various amounts.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="113.03mm" wi="156.72mm" file="US20230004977A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="235.97mm" wi="169.67mm" orientation="landscape" file="US20230004977A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="233.43mm" wi="141.31mm" orientation="landscape" file="US20230004977A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="230.12mm" wi="179.07mm" orientation="landscape" file="US20230004977A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="238.17mm" wi="112.69mm" orientation="landscape" file="US20230004977A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="237.74mm" wi="116.08mm" orientation="landscape" file="US20230004977A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="231.82mm" wi="168.99mm" orientation="landscape" file="US20230004977A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="236.47mm" wi="152.32mm" orientation="landscape" file="US20230004977A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="236.90mm" wi="142.32mm" orientation="landscape" file="US20230004977A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="236.30mm" wi="129.37mm" orientation="landscape" file="US20230004977A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="236.14mm" wi="103.55mm" orientation="landscape" file="US20230004977A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="222.76mm" wi="132.76mm" orientation="landscape" file="US20230004977A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="222.50mm" wi="98.38mm" orientation="landscape" file="US20230004977A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="233.09mm" wi="156.72mm" orientation="landscape" file="US20230004977A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00014" num="00014"><img id="EMI-D00014" he="205.82mm" wi="171.87mm" orientation="landscape" file="US20230004977A1-20230105-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">FIELD OF THE INVENTION</heading><p id="p-0002" num="0001">The present invention relates to entity resolution. Herein are acceleration techniques for recognizing duplicate entities based on a topology of a bipartite graph.</p><heading id="h-0002" level="1">BACKGROUND</heading><p id="p-0003" num="0002">Accuracy of data science and analytics may be limited by the quality of underlying data. Because a single data source may provide somewhat incomplete data, multiple data sources may be used to provide somewhat overlapping data that can be merge to generate a more complete data store. Each data source may provide a different and partial record that logically represents a same entity such as a person, organization, location, or other real world object. Thus, a best representation of an entity may entail combining somewhat similar records from different data sources.</p><p id="p-0004" num="0003">Entity resolution entails deciding whether two records in a database or two vertices in a property graph represent a same entity based on information directly associated with those entities. State of the art approaches for entity resolution may examine information associated with entities, including demographic details such as name, phone number, email address, and postal address and, based on a metric of similarity, decide whether the two records represent a same entity such as a same person. Efficient entity resolution engines may operate in two phases. A first phase is fuzzy (i.e. inexact) and consists of a fast, high-recall (i.e. prone to false positives but not prone to false negatives) search technique for discovering near-duplicates that are candidates for merging. A second phase applies a more thorough comparison of candidates' attributes for high precision matching and merging.</p><p id="p-0005" num="0004">Existing approaches are limited by only examining individual entities. There was no approach that incorporated relationships between entities into entity resolution calculation. Standard entity resolution approaches rely only on finding similarities between entities based on associated demographic information such as name, address, and phone number. The entity relationships are not taken into consideration during entity resolution even though in many use-cases the relationship information between entities is available and could contribute to accuracy of entity resolution. By ignoring entity relationships, accuracy achieved by a fixed processing duration is decreased and a processing duration needed to achieve a fixed accuracy is increased.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0006" num="0005">In the drawings:</p><p id="p-0007" num="0006"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram that depicts an example computer that accelerates recognizing duplicate entities based on the topology of a bipartite graph;</p><p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a flow diagram that depicts an example computer process that accelerates recognizing duplicate entities based on the topology of a bipartite graph;</p><p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. <b>3</b></figref> depicts pseudocode of step <b>1</b> of an example unweighted neighbor counting algorithm;</p><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. <b>4</b></figref> depicts pseudocode of step <b>2</b> of an example unweighted neighbor counting algorithm;</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a dataflow diagram that depicts example inputs, outputs, and intermediate data for the example unweighted algorithm;</p><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a flow diagram that depicts an example computer process that adjusts amounts of similarity of similarity edges;</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIGS. <b>7</b>-<b>8</b></figref> depict pseudocode of step <b>1</b> of an example weighted neighbor counting algorithm;</p><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. <b>9</b></figref> depicts pseudocode of step <b>2</b> of an example weighted neighbor counting algorithm;</p><p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a dataflow diagram that depicts example inputs, outputs, and intermediate data for the example weighted algorithm;</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. <b>11</b></figref> is a flow diagram that depicts an example computer process that adjusts amounts of similarity of similarity edges based on weights of all vertices in a bipartite graph;</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>12</b></figref> is a flow diagram that depicts an example PageRank process that adjusts amounts of similarity of similarity edges based on weights of all vertices in a bipartite graph;</p><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>13</b></figref> is a block diagram that illustrates a computer system upon which an embodiment of the invention may be implemented;</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>14</b></figref> is a block diagram that illustrates a basic software system that may be employed for controlling the operation of a computing system.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0004" level="1">DETAILED DESCRIPTION</heading><p id="p-0020" num="0019">In the following description, for the purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent, however, that the present invention may be practiced without these specific details. In other instances, well-known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.</p><heading id="h-0005" level="1">GENERAL OVERVIEW</heading><p id="p-0021" num="0020">Entity resolution decides whether two records or vertices represent a same entity based on information directly assigned to those entities. Techniques herein increase the accuracy and speed of entity resolution by exploring relationships between entities and neighboring entities. In a database embodiment, entity relationships may occur as foreign key relationships. In a graph embodiment, entity relationships may occur as edges that interconnect vertices. Techniques herein are agnostic to the system performing entity resolution, and build on top of already identified matches, as long as there are relationships between entities captured in the underlying data. In an embodiment, techniques herein operate as a post processor that takes existing entity resolution results provided by opaque legacy software and increases the accuracy of those results in various ways such as refining similarity scores of merge candidate entities, erasing false similarities, and creating new similarities.</p><p id="p-0022" num="0021">For regulatory compliance, accurate entity resolution herein may be applied to various important domains such as fraud detection, anti-money laundering, and terrorism finance tracing. Taking entity relationships into account brings additional accuracy, which in turn means more accurate identification of identical entities. For example in financial crime detection, it means that an investigation of a suspicious case can be concluded faster and more accurately.</p><p id="p-0023" num="0022">In a property graph embodiment, the input graph is bipartite such that two vertices respectively in two subgraphs may already be resolved as a same entity as indicated by a synthetic similarity edge was added by a legacy entity resolver to join the two subgraphs by connecting the two vertices. By iteratively expanding a radius of a neighborhood of vertices that surround a vertex that has a similarity edge, entity similarity and relationship information transitively propagates throughout the neighborhood. Thus, information is shared within the neighborhood without explicit graph traversal such depth first or breadth first that entail expensive and/or sequential activities such as accumulating traversal paths or backtracking.</p><p id="p-0024" num="0023">In an unweighted embodiment, a minimum count of entities in one subgraph that are merge candidates with vertices in the other subgraph is detected. In a weighted embodiment, the count is not an integer and is additionally based on weighting coefficients. Various embodiments may derive various metadata such as:<ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0024">a similarity score for each similarity edge</li>        <li id="ul0002-0002" num="0025">an indication of which similarity edges have similarity scores that exceed a confidence threshold</li>        <li id="ul0002-0003" num="0026">an indication of which of multiple similarity edges connected to a same vertex has a highest or lowest similarity score.</li>    </ul>    </li></ul></p><p id="p-0025" num="0027">To count mergeable entities, each vertex has an expanding set of vertices that have similarity edges in the vertex's neighborhood. Initially the set contains only vertices of similarity edges that are connected to the vertex. In each iteration, each vertex merges its set with that of its neighbors. After a number of specified iterations is finished, how many vertices are in the intersection of source and target sets of each similarity edge are counted.</p><p id="p-0026" num="0028">In a weighted embodiment, each vertex is assigned a vertex weight that does not change. Vertex weights may be computed by undirected PageRank and then transformed into normalized vertex weights. For each vertex, an edge weight that is not a similarity score is assigned to each similarity edge in its neighborhood. In each iteration, each vertex merges its edge weight information with that of its neighbors using a weighted sum.</p><p id="p-0027" num="0029">In a weighted or unweighted embodiment, a computer stores a bipartite graph that consists of a source subgraph and a target subgraph. Each vertex in the bipartite graph represents an entity. The source subgraph and the target subgraph are connected by many similarity edges. Each similarity edge indicates an original amount of similarity between the entity of a source vertex in the source subgraph and the entity of a target vertex in the target subgraph. For each similarity edge, the computer determines:<ul id="ul0003" list-style="none">    <li id="ul0003-0001" num="0000">    <ul id="ul0004" list-style="none">        <li id="ul0004-0001" num="0030">a) a set of neighbor source vertices that are reachable from the source vertex of the similarity edge by traversing at most a source radius count of source edges in the source subgraph</li>        <li id="ul0004-0002" num="0031">b) a set of neighbor target vertices that are reachable from the target vertex of the similarity edge by traversing at most a target radius count of target edges in the target subgraph</li>        <li id="ul0004-0003" num="0032">c) a source amount of vertices in the neighbor source vertices that are connected to any vertex in the neighbor target vertices by any similarity edge</li>        <li id="ul0004-0004" num="0033">d) a target amount of vertices in the neighbor target vertices that are connected to any vertex in the neighbor source vertices by any similarity edge</li>        <li id="ul0004-0005" num="0034">e) a lesser amount of vertices that is a minimum of the source amount of vertices and the target amount of vertices.</li>    </ul>    </li></ul></p><p id="p-0028" num="0035">In the above enumerated determinations are various amounts of vertices that are integer counts in an unweighted embodiment and, instead, are real numbers in a weighted embodiment. For each similarity edge, the computer calculates a new amount of similarity based on the above lesser amount.</p><heading id="h-0006" level="1">1.0 EXAMPLE COMPUTER</heading><p id="p-0029" num="0036"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram that depicts an example computer <b>100</b>, in an embodiment. Computer <b>100</b> accelerates recognizing duplicate entities based on the topology of bipartite graph <b>110</b>. Computer <b>100</b> may be one or more of a rack server such as a blade, a personal computer, a mainframe, a virtual computer, or other computing device.</p><p id="p-0030" num="0037">Computer <b>100</b> may receive content from multiple data sources (not shown) such as databases, web services, software applications, and filesystems. Each data source may provide structured or unstructured data such as records, documents, spreadsheets, and files that describe entities (not shown). An entity may be a real-world object such as a person, a corporation, a geographic location, an account such as a bank account or a computer account, or a vehicle. Each data source may provide descriptions of associations between entities. Associations may be more or less long-lived, such as which person owns which car, or transactional such as which corporation paid which other corporation.</p><p id="p-0031" num="0038">Although entities are distinct in the real world, universal identifiers of entities may be non-existent or not pervasively used. For example, two data sources may disagree on how a same entity is identified. In some cases, a data source may use an identifier that is not unique. For example, many people may share a same full name. Likewise, a same person may at various times be identified by a full name that variously has a middle name, a middle initial, or neither. Thus, there may be ambiguity as to whether two entities provided by a same or different data source are actually a same entity in the real word.</p><heading id="h-0007" level="1">1.1 EXAMPLE GRAPH</heading><p id="p-0032" num="0039">To facilitate entity analytics such as recognition of duplicate entities that actually are a same entity, computer <b>100</b> stores and uses bipartite graph <b>110</b> that contains vertices <b>131</b>-<b>135</b> and <b>141</b>-<b>144</b> that each represents a distinct or duplicate entity. Bipartite graph <b>110</b> also contains directed or undirected edges that interconnect vertices and that represent associations between entities. For demonstration, such edges are shown as undirected solid lines, although some edges may actually be directed. For example, source vertex <b>132</b> is connected by respective edges to source vertices <b>133</b>-<b>134</b>.</p><p id="p-0033" num="0040">Graph <b>110</b> is bipartite, which means that it consists of two subgraphs <b>120</b> and <b>130</b>. As discussed below, subgraphs may or may not share data sources. For example, source subgraph <b>120</b> may receive descriptions of entities and associations from one set of data source(s), and target subgraph <b>130</b> receives descriptions of entities and associations from a disjoint different set of data source(s).</p><heading id="h-0008" level="1">1.2 SIMILARITY EDGE</heading><p id="p-0034" num="0041">Computer <b>100</b> may perform initial entity resolution such as in known ways to detect that some target vertices in target subgraph <b>130</b> are potential duplicates of some source vertices in source subgraph <b>120</b>. For example, computer <b>100</b> may detect that source vertex <b>131</b> and target vertex <b>141</b> each represents a person that has a same full name, which may or may not mean that vertices <b>131</b> and <b>141</b> represent a same person. When computer <b>100</b> detects that a source vertex and a target vertex are potential duplicates that potentially represent a same entity, a similarity edge that connects those two vertices is added to bipartite graph <b>110</b>.</p><p id="p-0035" num="0042">For demonstration, similarity edges are shown as directed dashed lines, although similarity edges may actually lack direction. For example, designation of subgraph <b>120</b> as source and subgraph <b>130</b> as target may or may not be somewhat arbitrary. In an embodiment, source subgraph <b>120</b> represents content that is natively managed by computer <b>100</b>, such as when computer <b>100</b> is itself a data source, and target subgraph <b>130</b> represents content that is provided to computer <b>100</b> from an external data source such as a remote system. In an embodiment, source subgraph <b>120</b> represents content from a data source in one field such as government or public records, and target subgraph <b>130</b> represents content from a data source in a different field such as banking. In an embodiment, source subgraph <b>120</b> represents content computer <b>100</b> previously acquired, and target subgraph <b>130</b> represents content that is newly acquired from a same or different data source.</p><p id="p-0036" num="0043">In any case, vertices <b>131</b> and <b>141</b> are connected by a similarity edge as shown. As explained above, similarity edges are synthetic and do not represent associations provided by data sources. In an embodiment, similarity edges are stored together with other edges such as in a same database table that stores edges. In an embodiment, similarity edges are instead stored separately from other edges such as in separate tables in a same or different database. For example, target vertex <b>141</b> has one similarity edge and one other edge that may or may not be comingled in storage.</p><p id="p-0037" num="0044">As explained above, generation of similarity edges is based on initial entity resolution that detects potential duplicates. Because similarity is only a potentiality, a similarity edge may be more or less uncertain. Such uncertainty may be quantified such as with a numeric score such as a probability such as a percent or unit-normalized amount in a range from zero to one. Thus, initial entity resolution may assign each similarity edge a respective original amount of similarity (not shown).</p><p id="p-0038" num="0045">A vertex may have multiple similarity edges when potentially duplicative of multiple other vertices. For example, source vertex <b>131</b> is connected to target vertices <b>141</b>-<b>142</b> by multiple similarity edges. Likewise, target vertex <b>142</b> is connected to source vertices <b>131</b>-<b>132</b> by multiple similarity edges. In various embodiments when summed together, original amounts of similarity of multiple similarity edges of a same vertex variously can or cannot exceed one or 100%. For example in an embodiment, the two similarity edges of source vertex <b>131</b> may have original amounts of similarity of 60% and 70% respectively, which together exceed 100%.</p><heading id="h-0009" level="1">1.3 GRAPH STORAGE</heading><p id="p-0039" num="0046">Various embodiments may store logical objects such as entities, associations, vertices, and edges in various ways using various data structures in volatile or nonvolatile storage. In various embodiments, some or all of those kinds of logical objects may variously be stored in array(s), database table(s), or linked list(s). In various embodiments, instances of some or all of those kinds of logical objects may variously be references by an offset of an element in an array, by an offset or row identifier of a row in a database table, or by a pointer such as a memory address.</p><p id="p-0040" num="0047">For example, a vertex or edge may contain a reference to a corresponding entity or association. Likewise, an edge may contain references to two connected vertices. In any case, some or all of those kinds of logical objects may contain additional data fields such as application-specific attributes such as a timestamp, a quantity, a code, a type, or other detail. For example, entity resolution and entity analytics may read or write fields. Accelerated entity deduplication based on similarity edges is discussed later herein.</p><heading id="h-0010" level="1">2.0 EXAMPLE SIMILARITY MEASUREMENT PROCESS</heading><p id="p-0041" num="0048"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a flow diagram that depicts an example process that an embodiment of computer <b>100</b> may perform to accelerate recognizing duplicate entities based on the topology of bipartite graph <b>110</b>. <figref idref="DRAWINGS">FIG. <b>2</b></figref> is discussed with reference to <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0042" num="0049">Step <b>201</b> stores bipartite graph <b>110</b> that consists of source subgraph <b>120</b> and target subgraph <b>130</b>. Step <b>201</b> includes generating and/or storing similarity edges in bipartite graph <b>110</b>.</p><p id="p-0043" num="0050">For each similarity edge in bipartite graph <b>110</b>, step <b>202</b> makes various determinations as follows. As explained earlier herein, a similarity edge connects a vertex in source subgraph <b>120</b> to a vertex in target subgraph <b>130</b>. Step <b>202</b> determines a neighborhood of vertices that surround each of the similarity edge's two vertices. For example as shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, source vertex <b>132</b> and target vertex <b>142</b> are connected by similarity edge <b>173</b>. Also as shown, source vertex <b>132</b> has neighbor source vertices <b>150</b> that includes source vertices <b>133</b>-<b>135</b>. Likewise, target vertex <b>142</b> has neighbor target vertices <b>160</b> that includes target vertex <b>143</b>.</p><p id="p-0044" num="0051">Step <b>202</b> determines the neighborhood of a vertex as follows. All neighbor vertices in a neighborhood are connected to the vertex by a respective traversal path that is a sequence of ordinary edges. A neighborhood has a radius count of edges in those paths that connect neighbor vertices to the vertex. In an embodiment as discussed later herein, a neighborhood contains vertices that are, at most, the radius count of edges away from the vertex.</p><p id="p-0045" num="0052">The respective radius count of edges for the source neighborhood and target neighborhood may be same or different amounts. In the shown example, both radius counts are one edge, which means that only vertices directly connected by an ordinary edge to the vertex are included in the vertex's neighborhood. For example, if the source radius count of edges were instead two, then the source neighborhood of source vertex <b>132</b> would additionally include source vertex <b>135</b> that is not directly connected to source vertex <b>132</b>.</p><p id="p-0046" num="0053">In any case, step <b>202</b> determines: a) a source amount (iii below) of source vertices in neighbor source vertices <b>150</b> that are connected to target vertices in neighbor target vertices <b>160</b>, and b) a target amount (iv below) of target vertices in neighbor target vertices <b>160</b> that are connected to source vertices in neighbor source vertices <b>150</b>. In various embodiments as discussed later herein, those two amounts (iii-iv) of connected vertices are counts of vertices that are or are not based on weights. For example if weights are real numbers such as coefficients, then those two amounts (iii-iv) of connected vertices are not integers.</p><p id="p-0047" num="0054">Although based on same similarity edges <b>174</b>-<b>175</b>, both of those amounts (iii-iv) of connected vertices for respective neighborhoods <b>150</b> and <b>160</b> may be the same or different. For example as shown those amounts (iii-iv) are different because neighbor target vertices <b>160</b> are connected to two source vertices <b>133</b>-<b>134</b> in neighbor source vertices <b>150</b>, but neighbor source vertices <b>150</b> is connected to only one target vertex <b>143</b> in neighbor target vertices <b>160</b>.</p><p id="p-0048" num="0055">In summary for similarity edge <b>173</b>, step <b>202</b> determines the following:<ul id="ul0005" list-style="none">    <li id="ul0005-0001" num="0000">    <ul id="ul0006" list-style="none">        <li id="ul0006-0001" num="0056">i. neighbor source vertices <b>133</b>-<b>135</b> in neighbor source vertices <b>150</b></li>        <li id="ul0006-0002" num="0057">ii. neighbor target vertex <b>143</b> in neighbor target vertices <b>160</b></li>        <li id="ul0006-0003" num="0058">iii. a source amount of two connected source neighbor vertices <b>133</b>-<b>134</b></li>        <li id="ul0006-0004" num="0059">iv. a target amount of one connected target neighbor vertex <b>143</b></li>        <li id="ul0006-0005" num="0060">v. lesser amount of one connected vertex that is the minimum of the source amount (iii) and the target amount (iv)</li>    </ul>    </li></ul></p><p id="p-0049" num="0061">As explained earlier herein, each of similarity edges <b>171</b>-<b>176</b> has an original amount of similarity that may be assigned during initial entity resolution. For each similarity edge <b>171</b>-<b>176</b>, step <b>203</b> calculates a respective new amount of similarity based on respective lesser amount (v). Mathematics and additional terms for calculating the new amounts of similarity are presented later herein.</p><p id="p-0050" num="0062">For similarity edge <b>173</b>, the new amount of similarity may be more or less than the original amount of similarity. In an embodiment, the new amount of similarity replaces the original amount of similarity. In an embodiment if the new amount of similarity falls below a removal threshold, similarity edge <b>173</b> is removed from bipartite graph <b>110</b>, in which case vertices <b>132</b> and <b>142</b> are no longer considered potential duplicates of each other and are no longer candidates for merging with each other. However, none, one, or both of vertices <b>132</b> and <b>142</b> may have other similarity edges that connect to other vertices for other potential merges.</p><p id="p-0051" num="0063">For example due to similarity edges <b>172</b>-<b>173</b>, initially it may be unclear whether target vertex <b>142</b> represents a same entity as source vertex <b>131</b> or <b>132</b>. Removal of similarity edge <b>173</b> may cause computer <b>100</b> to detect that vertices <b>131</b> and <b>142</b> represent a same entity. For example, computer <b>100</b> may decide that vertices <b>131</b> and <b>142</b> are duplicates and merge them and merge their entities to become one vertex that represents one entity, thus accomplishing deduplication. In another example, removal of similarity edge <b>172</b> may cause computer <b>100</b> to detect that: a) vertices <b>131</b> and <b>142</b> do not represent a same entity, and b) vertices <b>132</b> and <b>142</b> represent a same entity.</p><p id="p-0052" num="0064">Likewise if amounts of similarity of similarity edges <b>172</b>-<b>173</b> are instead increased and both exceed a confidence threshold, then computer <b>100</b> may detect that a) source vertices <b>131</b>-<b>132</b>, orb) vertices <b>131</b>-<b>132</b> and <b>142</b>, represent a same entity and should be merged for deduplication. Thus, the process of <figref idref="DRAWINGS">FIG. <b>2</b></figref> may cause entities to be resolved and cause bipartite graph <b>110</b> to evolve.</p><p id="p-0053" num="0065">In an embodiment discussed later herein, the process of <figref idref="DRAWINGS">FIG. <b>2</b></figref> may be iteratively repeated such that each iteration makes another analytic pass over bipartite graph <b>110</b> and further resolves entities and further adjusts bipartite graph <b>110</b>. For example, the radius of both neighborhoods may be increased in each iteration.</p><p id="p-0054" num="0066">Techniques herein provide acceleration for entity resolution in various ways, thereby accelerating the operation of computer <b>100</b> itself as an entity resolution computer. For example as explained earlier herein, subgraphs <b>120</b> and <b>130</b> may be based on content provided by different data sources. Such content retrieval may be expensive in terms of time, space, and/or money such that there may be a natural incentive to minimize how many data sources are used and/or how often content is refreshed from those data sources.</p><p id="p-0055" num="0067">In other words, computer <b>100</b> may be intentionally designed to perform entity resolution with as few content retrievals as possible and only perform additional content retrievals from same or different data sources when previous iterations of the process of <figref idref="DRAWINGS">FIG. <b>2</b></figref> achieved insufficient entity resolution. For example as discussed earlier herein, source subgraph <b>120</b> may contain old content and target subgraph <b>130</b> may contain new content. For example between process iterations, target subgraph <b>130</b> may be merged into source subgraph <b>120</b> and newly retrieved content from same or different data source(s) may be used to create a new target subgraph <b>130</b>.</p><p id="p-0056" num="0068">In an embodiment, subgraphs <b>120</b> and <b>130</b> are based on contents provided by respective sets of data sources that include additional data source(s) between process iterations. For example, source subgraph <b>120</b> may use one data source during a first iteration, two data sources during a second iteration, and so on until iteration terminates based on an entity resolution sufficiency condition.</p><p id="p-0057" num="0069">Thus, entity resolution may be based on process iterations that consume time for communicating with data sources and time for analytic processing. The more iterations, the more time and other resources are needed. With techniques herein, computer <b>100</b> achieves a same amount of entity resolution with fewer iterations and less corroborative content from fewer data source retrievals. Thus, the performance of computer <b>100</b> itself is improved by acceleration and decreased resource consumption to achieve a same amount of entity resolution. This improved performance of computer <b>100</b> is provided by novel analytics herein based on similarity edges for faster and more confident entity resolution in a less resource intensive way.</p><p id="p-0058" num="0070">In an embodiment, graph <b>110</b> is not bipartite, but instead is multipartite such that subgraphs <b>120</b> and <b>130</b> are not the only subgraphs of graph <b>110</b>. For example, each data source may have its own subgraph in graph <b>110</b>. In an embodiment, graph <b>110</b> is bipartite in a first iteration, tripartite in a second iteration, and so on until satisfying an entity resolution sufficiency condition. For example, the process of <figref idref="DRAWINGS">FIG. <b>2</b></figref> may be repeated for each distinct pair of subgraphs in each iteration.</p><heading id="h-0011" level="1">3.0 PSEUDOCODE OF STEP 1 OF EXAMPLE UNWEIGHTED ALGORITHM</heading><p id="p-0059" num="0071"><figref idref="DRAWINGS">FIGS. <b>3</b>-<b>4</b></figref> respectively depict pseudocode for unweighted steps <b>1</b>-<b>2</b> of an example unweighted neighbor counting algorithm that computer <b>100</b> may implement in an embodiment. <figref idref="DRAWINGS">FIGS. <b>3</b>-<b>4</b></figref> are discussed with reference to <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>2</b></figref>. Weight is discussed later herein.</p><p id="p-0060" num="0072">As discussed below, portions of the pseudocode may be implementations of steps in <figref idref="DRAWINGS">FIG. <b>2</b></figref>. Unweighted steps <b>1</b>-<b>2</b> of <figref idref="DRAWINGS">FIGS. <b>3</b>-<b>4</b></figref> include a sequence of iterative control flow loops <b>1</b>-<b>6</b> that operate as follows. In the pseudocode, a loop is declared with a &#x201c;for&#x201d; keyword such as &#x201c;for each&#x201d; or &#x201c;for 1 to&#x201d;.</p><p id="p-0061" num="0073">As explained earlier herein, each similarity edge has two neighborhoods respectively in both subgraphs <b>120</b> and <b>130</b>. Unweighted step <b>1</b> respectively counts vertices in both neighborhoods that are connected to the opposite neighborhood. For example, unweighted step <b>1</b> may be an implementation of step <b>202</b> in <figref idref="DRAWINGS">FIG. <b>2</b></figref>.</p><p id="p-0062" num="0074">The following are inputs that unweighted step <b>1</b> accepts as shown.<ul id="ul0007" list-style="none">    <li id="ul0007-0001" num="0000">    <ul id="ul0008" list-style="none">        <li id="ul0008-0001" num="0075">Hop number is the maximum radius count of edges for source subgraph <b>120</b>.</li>        <li id="ul0008-0002" num="0076">External hop number is the maximum radius count of edges for target subgraph <b>130</b>.</li>        <li id="ul0008-0003" num="0077">Labels to identify similarity edges and vertices in target subgraph <b>130</b>.</li>    </ul>    </li></ul></p><p id="p-0063" num="0078">In the above inputs, the source radius and target radius may be different hop counts.</p><p id="p-0064" num="0079">As shown, unweighted step <b>1</b> contains loops <b>1</b>-<b>4</b>. Loops <b>1</b>-<b>3</b> cooperate to identify neighborhoods of vertices with similarity edges between source subgraph <b>120</b> and target subgraph <b>130</b>. Loop <b>1</b> initializes the search. Loop <b>2</b>: a) starts in a vertex v in source subgraph <b>120</b>, b) in an increasing neighborhood, detects vertices with similarity edges between source subgraph <b>120</b> and target subgraph <b>130</b>, and c) records the identifiers of such vertices. Loop <b>2</b> inspects each vertex in the source subgraph <b>120</b>. Similarly, loop <b>3</b> performs the search in target subgraph <b>130</b>. Loops <b>1</b>-<b>3</b> cooperate to detect which neighbor vertices in neighborhoods of which other vertices have similarity edges. Loop <b>1</b> detects similarity vertices, which herein are vertices that have similarity edges. Loops <b>2</b>-<b>3</b> cooperate to detect which neighborhoods contain which similarity vertices.</p><p id="p-0065" num="0080">Loop <b>1</b>: a) iterates over all vertices <b>131</b>-<b>136</b> and <b>141</b>-<b>144</b> of bipartite graph <b>110</b>, b) discovers all similarity edges <b>171</b>-<b>176</b> in bipartite graph <b>110</b>, and c) if there is a similarity edge connected to the vertex, each of the similarity edge's two vertices is recorded into a respective set of vertices.</p><p id="p-0066" num="0081">Loop <b>2</b> processes one vertex at time and searches a radius-n neighborhood, with increasing n and vertices only from source subgraph <b>120</b>, for vertices with similarity edges connecting subgraphs <b>120</b> and <b>130</b>. When a vertex with a similarity edge is found, the identifier of the source and target vertices are recorded in respective sets of vertices.</p><p id="p-0067" num="0082">Loop <b>3</b> has the same pattern as Loop <b>2</b>. A difference is that loop <b>3</b> iterates over vertices and searches for neighbors from target subgraph <b>130</b>. The effect of loops <b>2</b>-<b>3</b> is that each processed vertex contains a set of vertices in the neighborhood connected to similarity edges.</p><p id="p-0068" num="0083">A counterintuitive effect of merging expanding neighborhoods is that the horizon of merged information may be a distance from current vertex v that exceeds the current radius count of edges. That is because the horizon distance may be twice the radius count of edges because two neighborhoods participate in one merge. For example when the radius count of edges is two, vertices v and w in loop <b>2</b> may be separated by a path of two edges, and w may be separated from a similarity vertex in vertex w's neighborhood by another path of two edges, which means that a path from vertex v to the similarity vertex may instead be a concatenated path of 2+2=four edges. Thus, the horizon of merged information for a neighborhood expands faster than the neighborhood itself expands, which is counterintuitive.</p><p id="p-0069" num="0084">An optimization in loops <b>1</b>-<b>3</b> avoids tracking which vertices are in which expanding neighborhoods. Instead, only which similarity vertices are in which neighborhoods is tracked by maps simSourceIds and simTargetIds. However every vertex, having a similarity edge or not, has its own neighborhood, which is why loop <b>2</b> says &#x201c;for each vertex v&#x201d;.</p><p id="p-0070" num="0085">Thus, merging (i.e. union) neighborhoods entails only merging sets of similarity vertices. Loop <b>2</b> says &#x201c;add&#x201d; that merges the identifiers of the similarity vertices of neighborhoods of vertices that are in the neighborhood of a current vertex. Loop <b>2</b> is an outer loop that is repeated to increment the radius count of edges, which causes neighborhoods to iteratively expand.</p><p id="p-0071" num="0086">Although, only vertices with similarity edges contribute to simSourceIds and simTargetIds, the remaining vertices within source graph <b>120</b> still: a) track which similarity vertices are in the vertex's expanding neighborhood and b) propagate the information of (a) to other vertices within source graph <b>120</b>. For example, a first vertex that has a similarity edge and a third vertex may be separated by a second vertex that lacks a similarity edge such that the first vertex and the third vertex both are immediately adjacent to the second vertex, but the first vertex and the third vertex are not immediately adjacent to each other.</p><p id="p-0072" num="0087">In a first iteration of loop <b>2</b>, merging of neighborhoods of the first vertex and the second vertex causes accounting of the similarity edge to be propagated to the second vertex. In a second iteration of loop <b>2</b>, merging of neighborhoods of the second vertex and the third vertex causes accounting of the similarity edge to be propagated to the third vertex. Thus, the first vertex and the third vertex may eventually account each other's similarity edges even though the first vertex and the third vertex are not immediately adjacent, and even though knowledge of the existence of the similarity edge must propagate through the second vertex that has no similarity edge. Thus, accounting of similarity edges may transitively propagate through portions of source subgraph <b>120</b>, including to and from vertices that lack similarity edges.</p><p id="p-0073" num="0088">Although loop <b>2</b> is coalescing neighborhoods of source subgraph <b>120</b>, loop <b>2</b> is not traversing subgraph <b>120</b>, because neighborhood expansion by coalescing does not entail subgraph traversal, which necessarily would require traversal paths. Graph traversal with paths is stateful, because a path records a sequence of previous states. Whereas techniques herein are not stateful and do not record visiting some vertices before other vertices. That is because all vertices have their own neighborhoods that are simultaneously expanding to merge with each other. Information propagates by merging neighborhoods, which is stateless, and not by traversing stateful paths. For example, when an identifier of a similarity vertex is propagated from neighborhood information of one vertex into a neighborhood information of another vertex, there is no record of a traversal path that could reach the similarity vertex.</p><p id="p-0074" num="0089">Loops <b>2</b>-<b>3</b> say &#x201c;For 1 to hop number&#x201d; that does not declare an iteration counter variable. In other words and counterintuitively, the operation of each iteration of loop <b>2</b> or <b>3</b> is the same without regard for which is the current iteration, which is more or less stateless. Thus, computer <b>100</b> need not generate graph traversal paths. Thus, neither loops <b>2</b>-<b>3</b> nor any of <figref idref="DRAWINGS">FIGS. <b>3</b>-<b>4</b></figref> performs a breadth first search (BFS) nor a depth first search (DFS).</p><p id="p-0075" num="0090">Loop <b>4</b> iterates over all similarity edges <b>171</b>-<b>176</b> in bipartite graph <b>110</b>. Each similarity edge has a source vertex and a target vertex and, thus, two neighborhoods. Per step <b>202</b> of <figref idref="DRAWINGS">FIG. <b>2</b></figref>, only neighboring vertices that have a similarity edge that connects both neighborhoods should be counted, which is why loop <b>4</b> says &#x201c;intersection&#x201d;.</p><heading id="h-0012" level="1">4.0 PSEUDOCODE OF STEP 2 OF EXAMPLE UNWEIGHTED ALGORITHM</heading><p id="p-0076" num="0091">Unweighted step <b>2</b> in <figref idref="DRAWINGS">FIG. <b>4</b></figref> calculates statistics based on counts generated by unweighted step <b>1</b>. Unweighted step <b>2</b> includes loops <b>5</b>-<b>6</b>. Loop <b>4</b> already respectively counted similarity vertices in each of two neighborhoods. Loop <b>5</b> measures a similarity score, or an increment to a previous similarity score, for a similarity edge by detecting the lesser of both counts, which is why loop <b>5</b> says &#x201c;min&#x201d;.</p><p id="p-0077" num="0092">As explained earlier herein, source subgraph <b>120</b> may be an application's internal or native graph, and target subgraph <b>130</b> may be provided by an external data source for corroboration and/or enrichment of subgraph <b>120</b>. For example in an embodiment, target subgraph <b>130</b> may be temporally useful as a basis for updating source subgraph <b>120</b> after which target subgraph <b>130</b> may be discarded such as after merging target vertices into respective similar source vertices based on similarity scores of similarity edges. Thus over a longer term, only source subgraph <b>130</b> is retained, and some statistics need only be calculated for source vertices and not target vertices. Thus, loop <b>6</b> says &#x201c;source vertex&#x201d; but does not refer to a target vertex.</p><p id="p-0078" num="0093">Loop <b>6</b> calculates statistics that may be used as discussed later herein. Loop <b>6</b> also detects duplicate vertices as needed for entity resolution and deduplication. If the similarity score exceeds a confidence threshold, then loop <b>6</b> marks the similarity edge as connecting two duplicate vertices, which is why loop <b>6</b> says &#x201c;threshold flag&#x201d;.</p><heading id="h-0013" level="1">5.0 EXAMPLE UNWEIGHTED DATAFLOW</heading><p id="p-0079" num="0094"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a dataflow diagram that depicts example inputs, outputs, and intermediate data for the example unweighted neighbor counting algorithm in <figref idref="DRAWINGS">FIGS. <b>3</b>-<b>4</b></figref>, in an embodiment. <figref idref="DRAWINGS">FIG. <b>5</b></figref> is discussed with reference to <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0080" num="0095">As shown in <figref idref="DRAWINGS">FIG. <b>5</b></figref>, the input contains bipartite graph <b>110</b>, including similarity edges <b>171</b>-<b>176</b> and express subgraphs <b>120</b> and <b>130</b>. The input also contains a respective maximum neighborhood radius for both subgraphs <b>120</b> and <b>130</b>.</p><p id="p-0081" num="0096">Shown inside the example unweighted neighbor counting algorithm in <figref idref="DRAWINGS">FIG. <b>5</b></figref> are left and right sides that respectively are unweighted steps <b>1</b>-<b>2</b> of respective <figref idref="DRAWINGS">FIGS. <b>3</b>-<b>4</b></figref>. The output shown in <figref idref="DRAWINGS">FIG. <b>5</b></figref> contains a vertical sequence of three bullet items that are the result of unweighted step <b>2</b>. The top bullet is the result of loop <b>4</b>. The middle bullet is the result of loop <b>5</b>. The bottom bullet is the result of loop <b>6</b>.</p><heading id="h-0014" level="1">6.0 EXAMPLE SIMILARITY ADJUSTMENT</heading><p id="p-0082" num="0097"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a flow diagram that depicts an example process that an embodiment of computer <b>100</b> may perform to adjust amounts of similarity of similarity edges <b>171</b>-<b>176</b>. <figref idref="DRAWINGS">FIG. <b>6</b></figref> is discussed with reference to <figref idref="DRAWINGS">FIGS. <b>1</b> and <b>3</b>-<b>4</b></figref>.</p><p id="p-0083" num="0098">Each time the radius count of edges is incremented to expand neighborhoods, step <b>601</b> is repeated for each similarity vertex in each of subgraphs <b>120</b> and <b>130</b>. To neighbor vertices of a given vertex, step <b>601</b> adds neighbor vertices of each neighbor vertex. In an embodiment, step <b>601</b> is implemented as loops <b>2</b>-<b>3</b> of <figref idref="DRAWINGS">FIG. <b>3</b></figref> respectively for subgraphs <b>120</b> and <b>130</b>.</p><p id="p-0084" num="0099">As explained earlier herein, loop <b>5</b> measures an increment to an existing similarity score for a similarity edge. Because the increment is always non-negative, the increment always causes a new similarity score to be greater than or equal to the previous similarity score of the similarity edge. In other words, the calculation is biased toward monotonically increasing scores, which may be somewhat unrealistic. Thus, score normalization may be beneficial to keep scores in a predefined range such as a probability from zero to one or a percentage from zero to a hundred. Step <b>602</b> normalizes similarity scores as follows.</p><p id="p-0085" num="0100">As explained earlier herein, target subgraph <b>130</b> may be temporally useful as a basis for updating source subgraph <b>120</b> after which target subgraph <b>130</b> may be discarded such as after merging target vertices into respective similar source vertices based on similarity scores of similarity edges in an embodiment. Thus over a longer term, only source subgraph <b>120</b> is retained, and some statistics need only be calculated based on source vertices and not target vertices. As follows, normalization of similarity scores may be based on source vertices and not target vertices.</p><p id="p-0086" num="0101">As explained earlier herein, the score increment calculated by loop <b>5</b> is the lesser of a source count and a target count for a similarity edge. Step <b>602</b> is repeated for each source vertex that has a similarity edge. Into a summed amount, step <b>602</b> sums lesser amounts of vertices of each similarity edge that is connected to the source vertex. In other words, step <b>602</b> sums the score increments of all similarity edges of a same source vertex. For example, similarity edges <b>171</b>-<b>172</b> are connected to same source vertex <b>131</b>.</p><p id="p-0087" num="0102">For each similarity edge of that same source vertex, step <b>603</b> calculates a new amount of similarity based on the summed amount that was accumulated by step <b>602</b>. For example, the score increment may be based on the summed amount. For example, the score increment may be normalized by the summed amount. In an embodiment, a normalized increment is a ratio of the raw increment of step <b>602</b> divided by the summed amount. In that way, the normalized increment may be unit normalized into a unit range from zero to one or a percent range from zero to a hundred.</p><p id="p-0088" num="0103">Step <b>604</b> calculates a new amount of similarity based on an original (i.e. previous) amount of similarity. For example, the new score may be the sum of the old score and the score increment. For example, if the old score is 95%, and the normalized increment is 10%, then the new score is 95+10=105%, which may be somewhat unrealistic. New scores may be (e.g. further) normalized as a ratio of new score divided by a highest new score of all similarity edges connected to that same source vertex.</p><p id="p-0089" num="0104">For example, if the new score of a similarity edge is 105% but the highest new score in the graph is 150%, then the finally normalized new score of the similarity vertex is 105/150=70%. In other words, even though the score increment is never negative, a similarity score may decrease due to normalization. In an embodiment, the old score is retained if the new score would decrease. In other words, only new scores that actually increase are accepted.</p><p id="p-0090" num="0105">As explained earlier herein, the score increment calculated by loop <b>5</b> is the lesser of a source count and a target count for a similarity edge. In an embodiment, the score increment is set to zero if the score increment does not exceed an increment threshold. In other words, step <b>605</b> increases the new amount of similarity only if the lesser amount of vertices exceeds the increment threshold.</p><p id="p-0091" num="0106">Step <b>606</b> normalizes the new amount of similarity regardless of whether or not the lesser amount of vertices exceeds the increment threshold. For example as explained above for step <b>604</b>, normalization may cause the new amount of similarity for a similarity edge to be less than the original amount of similarity. Thus, similarity scores of some similarity edges may increase while others in a same graph may decrease.</p><heading id="h-0015" level="1">7.0 PSEUDOCODE OF STEP 1 OF EXAMPLE WEIGHTED ALGORITHM</heading><p id="p-0092" num="0107">The unweighted neighbor counting algorithm in <figref idref="DRAWINGS">FIGS. <b>3</b>-<b>4</b></figref> treats all vertices as equal, which means that the unweighted neighbor counting algorithm may ignore semantics of bipartite graph <b>110</b> that are not shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>. A software application may have semantics such that vertices individually have respective weight so that some vertices have more impact on entity resolution than others.</p><p id="p-0093" num="0108"><figref idref="DRAWINGS">FIGS. <b>7</b>-<b>9</b></figref> depict pseudocode for weighted steps <b>1</b>-<b>2</b> that are respective replacements for unweighted steps <b>1</b>-<b>2</b> of <figref idref="DRAWINGS">FIGS. <b>3</b>-<b>4</b></figref>. <figref idref="DRAWINGS">FIGS. <b>7</b>-<b>8</b></figref> depict respective halves of weighted step <b>1</b>. Vertex weights for weighted step <b>1</b> are provided by a software application. In weighted step <b>1</b>, vertex weights are used to calculate connection weights. A vertex weight is different from a connection weight as follows.</p><p id="p-0094" num="0109">Each vertex has its own vertex weight, regardless of whether or not the vertex has a similarity edge. Thus, there is a one-to-one correspondence between a vertex weight and a vertex, which is a graph element. There is no one-to-one correspondence between a connection weight and a graph element, such as a vertex or an edge. Each vertex has as many connection weights as similarity vertices in the neighborhood of the vertex.</p><p id="p-0095" num="0110">Vertex weight represent how important a vertex is for measuring similarity of two vertices. The intuition behind vertex weight is that the more connected by ordinary edges those vertices are to other vertices, the less important those vertices are for measuring similarity, while the less connected vertices are, the more important those vertices are for similarity. The reason is that an account with many connections means very little for any two vertices connected to the account. A real world example may be an utility company's account receiving monthly payments from many customers. The fact that two entities are connected via this account means very little other than they are customers of the same company and maybe are located in the same sales region. Conversely, if two entities are connected through an account that transacts only with those two entities, that is strong signal that the two entities have close ties.</p><p id="p-0096" num="0111">Connection weights are counter intuitive because they regard vertices that are connected by ordinary edges, whereas similarity scoring instead involves similarity edges that are not ordinary edges. Connection weights are novel for two reasons. First, state of the art entity resolution did not involve ordinary edges nor an expanding neighborhood of a vertex. Second, connection weights are computed (i.e. derived) and based on subgraph topology instead of being provided by application semantics. For example, techniques herein may post process results of a known entity resolution approach as explained earlier herein, and connection weights may be calculated after the known approach finishes. Indeed, the known entity resolution approach may be unaware of vertex weights and connection weights.</p><p id="p-0097" num="0112">As shown, weighted step <b>1</b> accepts an additional input, vertex property weight, that is the respective numeric vertex weight of each vertex and may be read only. As shown, weighted step <b>1</b> also accepts all of the inputs that unweighted step <b>1</b> accepts as explained earlier herein.</p><p id="p-0098" num="0113">Each vertex has an immutable vertex weight that is provided as input. Vertex weight has application specific semantics that connote importance. For example, PageRank is a known algorithm that discovers vertex weights of vertices. In a classic PageRank embodiment, each vertex represents a hypertext markup language (HTML) webpage and each ordinary edge represents a hyperlink in a source webpage that references a target webpage.</p><p id="p-0099" num="0114">Each vertex also has a respective connection weight for each similarity vertex in the expanding neighborhood of the vertex that weighted step <b>1</b> iteratively calculates by accumulation as discussed later herein. Different vertices may have different respective counts of connection weights because vertices may have different respective counts of similarity vertices within their respective neighborhoods, and those respective counts may or may not increase as the neighborhoods expand.</p><p id="p-0100" num="0115">In an embodiment, each vertex has an aggregation, such as an associative array or other map, of connection weights. For example, a connection weight map of a vertex may operate as a lookup table that accepts a similarity vertex as a lookup key and returns a respective connection weight between the vertex and the similarity vertex.</p><p id="p-0101" num="0116">Connection weights occur in pairs because connection weights represent influence by two vertices upon each other. However, connection weights are not symmetric because different vertices have different vertex weights and, although two vertices are involved, only the vertex weight of the opposite vertex u contributes to the connection weight for the current vertex v as loop <b>8</b> shows. Thus, a pair of vertex weights may have different values.</p><p id="p-0102" num="0117">Connection weights are iteratively revised as loop <b>8</b> iterates. As neighborhoods expand, more vertices share their information with each other, which may have some counterintuitive effects. For example, a vertex with a high vertex weight may inflate the connection weight in the connection weight arrays of opposite vertices. However due to transitive propagation of neighborhood information through multiple vertices, the value of a given connection weight may be more a result of distant vertices than near vertices, depending on the subgraph topology.</p><p id="p-0103" num="0118">A counterbalancing influence is that loop <b>8</b> increases the impact of near vertices by accounting for them in more iterations. For example, the vertex weight of a vertex u that is included into the neighborhood of a given vertex v only in the last iteration is directly used only once to calculate a given connection weight. Whereas, the vertex weight of a different vertex u that is immediately adjacent to the given vertex is directly and repeatedly used the most times for calculating the given connection weight. That is because a vertex does not directly contribute vertex weight for a given neighborhood until the vertex is included into the expanding neighborhood but, once included in the neighborhood, the vertex weight of the vertex is directly used in each subsequent iteration. Thus, different vertices directly contribute weight in different respective counts of iterations for a same neighborhood. Likewise, a same vertex directly contribute weight in different respective counts of iterations for different neighborhoods.</p><p id="p-0104" num="0119">In any case, all connection weights are initially zero. Weighted step <b>1</b> includes loops <b>7</b>-<b>11</b>. Even though unweighted step <b>1</b> of <figref idref="DRAWINGS">FIG. <b>3</b></figref> has separate respective loops for subgraphs <b>120</b> and <b>130</b>, those separate loops were similar so that subgraphs <b>120</b> and <b>130</b> are processed in a same way. Weighted step <b>1</b> instead may conditionally process target subgraph <b>130</b> as weighted or unweighted, which makes explanation of the loops of weighted step <b>1</b> more involved as follows.</p><p id="p-0105" num="0120">Loops <b>7</b>-<b>8</b> process source subgraph <b>120</b>. Loop <b>7</b> detects pairs of vertices connected by a same similarity edge and sets the connection weights for the ordinary edges of those two vertices to one. Thus initially, only vertices that have a similarity edge have non-zero connection weights. As explained earlier herein, by iteratively expanding a radius of a neighborhood of vertices that surround a vertex that has a similarity edge, entity similarity and relationship information transitively propagates throughout the neighborhood. Thus, connection weights may eventually become non-zero for vertices that lack a similarity edge, such as iteratively as follows.</p><p id="p-0106" num="0121">Loop <b>8</b> processes vertices, not similarity edges. Loop <b>8</b> has four vertex variables as follows. Vertex v is each vertex in source subgraph <b>120</b>. Vertex neigh is each vertex in the expanding neighborhood of vertex v, which is each source vertex that is connected to vertex v by a sufficient count of ordinary edges, which depends on the current radius of the expanding neighborhood. Vertex u has two phases (i.e. loops). In the first phase, vertex u is all of the source vertices in the expanding source neighborhood of vertex neigh. In the second phase, vertex u instead is all of the target vertices in the expanding target neighborhood of the similarity edge of vertex neigh.</p><p id="p-0107" num="0122">Transitive propagation of accounting of similarity edges to, from, and through vertices that lack similarity edges occurs in a way that is more or less the same as explained earlier herein for loop <b>2</b>. For example in both loops <b>2</b> and <b>8</b>, a vertex that initially accounts for no similarity edges may eventually receive such information from other vertices. For example, loop <b>8</b>'s simSourceVal of a vertex may be an initially empty associative array (i.e. map) but, after iteration(s), may accumulate similarity vertex identifiers and connection weights based on similarity edges that eventually are included into the expanding neighborhood of the vertex.</p><p id="p-0108" num="0123">Both of the weighted and unweighted neighbor counting algorithms coalesce smaller neighborhoods to generate bigger neighborhoods. As explained earlier herein, the unweighted neighbor counting algorithm merges neighborhoods by merging sets of vertices. Loop <b>8</b> of the weighted neighbor counting algorithm instead merges neighborhoods by monotonically increasing respective connection weights in connection weight arrays by iterative accumulation.</p><p id="p-0109" num="0124">Although not shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the unweighted neighbor counting algorithm ignores redundant edges when multiple ordinary edges connect a same two vertices. Accumulation is why loop <b>8</b> says &#x201c;+=&#x201d; that iteratively sums multiplicative products, which is why loop <b>8</b> says &#x201c;*&#x201d;. Given a vertex neigh that is in the expanding neighborhood of the current vertex v, the multiplicative product in any iteration multiplies: a) the vertex weight of vertex neigh times b) a count of redundant edges (which is why loop <b>8</b> says &#x201c;num_edges&#x201d;) that connect the current vertex to vertex neigh times c) the connection weight of the current vertex in the connection weight array of vertex neigh. In that way, loop <b>8</b> uses iterative summation to monotonically increase the connection weight of vertex neigh in the connection weight array of the current vertex.</p><p id="p-0110" num="0125">Weighted step <b>1</b> instead may conditionally process target subgraph <b>130</b> as weighted as discussed above or unweighted as discussed earlier herein. Loop <b>9</b> processes target subgraph <b>130</b> as unweighted. For example as discussed earlier herein, target subgraph <b>130</b> may represent data retrieved from a separate data source that lacks weights. Loop <b>10</b> instead processes target subgraph <b>130</b> as weighted.</p><p id="p-0111" num="0126">As explained earlier herein, each similarity edge connects two vertices and thus has two neighborhoods. Loop <b>11</b> detects which vertices in either neighborhood is connected by the same or other similarity edge to the other neighborhood, which is why loop <b>11</b> says &#x201c;commonSource&#x201d; and &#x201c;commonTarget&#x201d;.</p><p id="p-0112" num="0127">As explained above, loops <b>8</b> and <b>10</b> calculate values in connection weight arrays. Loop <b>11</b> integrates connection weights to measure a similarity score of a similarity edge. Loop <b>11</b> measures a similarity score by summing multiplicative products. For a given vertex of the similarity edge and a given common vertex (i.e. in commonSource or commonTarget), the multiplicative product is: a) the value for the common vertex in the connection weight array of the similarity vertex times b) the value for the common vertex in the connection weight array of the other vertex of the similarity edge.</p><heading id="h-0016" level="1">8.0 PSEUDOCODE OF STEP 2 OF EXAMPLE WEIGHTED ALGORITHM</heading><p id="p-0113" num="0128"><figref idref="DRAWINGS">FIG. <b>9</b></figref> depicts pseudocode for weighted step <b>2</b> that operates in substantially the same way as unweighted step <b>2</b> as discussed earlier herein.</p><p id="p-0114" num="0129">9.0 EXAMPLE WEIGHTED DATAFLOW</p><p id="p-0115" num="0130"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a dataflow diagram that depicts an example inputs, outputs, and intermediate data for the example weighted neighbor counting algorithm in <figref idref="DRAWINGS">FIGS. <b>6</b>-<b>8</b></figref>, in an embodiment. <figref idref="DRAWINGS">FIG. <b>10</b></figref> is discussed with reference to <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0116" num="0131">As shown in <figref idref="DRAWINGS">FIG. <b>10</b></figref>, the inputs are the same as discussed for unweighted <figref idref="DRAWINGS">FIG. <b>5</b></figref>. As shown, vertex weights are measured by PageRank as discussed earlier herein. Shown inside the example weighted neighbor counting algorithm in <figref idref="DRAWINGS">FIG. <b>10</b></figref> are details that are the same as discussed for unweighted <figref idref="DRAWINGS">FIG. <b>5</b></figref>. The outputs shown in <figref idref="DRAWINGS">FIG. <b>10</b></figref> are the same as discussed for unweighted <figref idref="DRAWINGS">FIG. <b>5</b></figref>, except that the similarity score for each similarity edge is a weighted real number measurement instead of an unweighted integer count.</p><heading id="h-0017" level="1">10.0 EXAMPLE WEIGHTED SIMILARITY ADJUSTMENT</heading><p id="p-0117" num="0132"><figref idref="DRAWINGS">FIG. <b>11</b></figref> is a flow diagram that depicts an example process that an embodiment of computer <b>100</b> may perform to adjust amounts of similarity of similarity edges <b>171</b>-<b>176</b> based on vertex weights and connection weights of vertices in bipartite graph <b>110</b>. <figref idref="DRAWINGS">FIG. <b>11</b></figref> is discussed with reference to <figref idref="DRAWINGS">FIGS. <b>1</b> and <b>6</b>-<b>8</b></figref>.</p><p id="p-0118" num="0133">As a preface to weighted step <b>1</b>, step <b>1101</b> assigns a respective vertex weight to each vertex in bipartite graph <b>110</b>. For example as discussed elsewhere herein, a weight assignment algorithm such as PageRank may be used for step <b>1101</b>.</p><p id="p-0119" num="0134">For each similarity edge, step <b>1102</b> determines a respective source amount of vertices for a similarity edge based on weights of vertices in neighbor source vertices. Due to weighting arithmetic, the source amount of vertices need not be an integer. In other words and unlike the unweighted algorithm, the source amount of vertices is not a count of vertices. Loop <b>8</b> may be an implementation of step <b>1102</b>.</p><p id="p-0120" num="0135">Similar to as explained earlier herein for unweighted loops <b>2</b>-<b>3</b>, loops <b>8</b>-<b>10</b> say &#x201c;for 1 to hop number&#x201d; without declaring an iteration counter. Thus, loops <b>8</b>-<b>10</b> may operate without regard for which is the current iteration number.</p><p id="p-0121" num="0136">As explained earlier herein, weighted step <b>1</b> processes source subgraph <b>120</b> and may or may not conditionally process target subgraph <b>130</b> as weighted or unweighted. For example, weighted step <b>1</b> may process both subgraphs <b>120</b> and <b>130</b> as weighted. In that case, step <b>1102</b> that calculates a source amount of vertices based on neighbor source vertices may be accompanied by a similar step that calculates target amounts of vertices based on vertices in neighbor target source vertices, which may be implemented as loop <b>10</b>.</p><p id="p-0122" num="0137">As explained above, loops <b>8</b> and <b>10</b> calculate values in connection weight arrays based on more or less complicated arithmetic that entails summation and weighting coefficients. For example, step <b>1102</b> that performs loop <b>8</b> may entail steps <b>1103</b>-<b>1104</b> as sub-steps that cooperate to calculate a same connection weight.</p><p id="p-0123" num="0138">Step <b>1103</b> determines the source amount of vertices for a similarity edge based on source amounts of vertices in neighbor source vertices. As explained earlier herein, loop <b>8</b> of the weighted neighbor counting algorithm merges neighborhoods by monotonically increasing respective connection weights in connection weight arrays by iterative accumulation. Loop <b>8</b> may be an implementation of step <b>1103</b>.</p><p id="p-0124" num="0139">As explained earlier herein, loop <b>8</b> uses iterative summation to monotonically increase the connection weight of a vertex in the connection weight array of the current vertex, which is based on a count of redundant edges that connect the current vertex to the vertex. Step <b>1104</b> determines the source amount of vertices for a similarity edge based on respective counts of redundant edges connecting the source vertex of the similarity edge to neighbor source vertices. Redundant edges are explained earlier herein. Loop <b>8</b> may be an implementation of step <b>1104</b>.</p><heading id="h-0018" level="1">11.0 EXAMPLE PAGERANK PROCESS</heading><p id="p-0125" num="0140"><figref idref="DRAWINGS">FIG. <b>12</b></figref> is a flow diagram that depicts an example PageRank process that an embodiment of computer <b>100</b> may perform to measure the vertex weight of a vertex. <figref idref="DRAWINGS">FIG. <b>12</b></figref> is discussed with reference to <figref idref="DRAWINGS">FIGS. <b>1</b> and <b>11</b></figref>.</p><p id="p-0126" num="0141">Steps <b>1201</b>-<b>1203</b> may cooperate to measure the vertex weight of a vertex. In an embodiment, steps <b>1201</b>-<b>1203</b> are sub-steps of step <b>1101</b> of <figref idref="DRAWINGS">FIG. <b>11</b></figref>.</p><p id="p-0127" num="0142">As explained earlier herein, classic PageRank uses an ordinary edge to represent a hyperlink. Hyperlinks are naturally directed such that two webpages cross referencing each other needs two hyperlinks, which is one in each of both directions. Step <b>1201</b> calculates an undirected PageRank of a vertex. Thus, edge direction is ignored, and an ordinary edge may increase the vertex weights of both vertices that the edge interconnects, although not necessarily by a same amount of increase. Whereas with classic directed PageRank, an edge would only contribute to the vertex weight of one vertex.</p><p id="p-0128" num="0143">Steps <b>1202</b>-<b>1203</b> may cooperate to calculate an vertex weight of a vertex by normalizing an undirected PageRank of the vertex that was calculated by step <b>1201</b>. Step <b>1202</b> calculates the vertex weight as a negative exponent that is based on the undirected PageRank of the vertex such as e<sup>&#x2212;n</sup>, where e is Euler's natural number and n is based on the undirected PageRank of the vertex.</p><p id="p-0129" num="0144">Step <b>1203</b> calculates the vertex weight as a negative exponent based on undirected PageRanks of other vertices in bipartite graph <b>110</b> such as e<sup>&#x2212;n </sup>where n is the ratio of the undirected PageRank of the vertex divided by the average undirected PageRank of all vertices in the graph. Thus, zero is a lower bound on the vertex weight of the vertex as calculated by step <b>1203</b> if the undirected PageRank of the vertex approaches zero. Likewise, a vertex whose undirected PageRank coincidentally is the same as the average undirected PageRank should have an vertex weight of 1/e. The vertex weight of a vertex need not have an upper bound because PageRank does not have an upper bound. The reason for a negative exponent transformation of the undirected PageRank value is as explained earlier herein. For example, the PageRank value is higher for more connected vertices, but the significance of such vertices for similarity may be very low. In contrast the less connected vertices, with low PageRank value, may be very important for measuring similarity.</p><heading id="h-0019" level="1">HARDWARE OVERVIEW</heading><p id="p-0130" num="0145">According to one embodiment, the techniques described herein are implemented by one or more special-purpose computing devices. The special-purpose computing devices may be hard-wired to perform the techniques, or may include digital electronic devices such as one or more application-specific integrated circuits (ASICs) or field programmable gate arrays (FPGAs) that are persistently programmed to perform the techniques, or may include one or more general purpose hardware processors programmed to perform the techniques pursuant to program instructions in firmware, memory, other storage, or a combination. Such special-purpose computing devices may also combine custom hard-wired logic, ASICs, or FPGAs with custom programming to accomplish the techniques. The special-purpose computing devices may be desktop computer systems, portable computer systems, handheld devices, networking devices or any other device that incorporates hard-wired and/or program logic to implement the techniques.</p><p id="p-0131" num="0146">For example, <figref idref="DRAWINGS">FIG. <b>13</b></figref> is a block diagram that illustrates a computer system <b>1300</b> upon which an embodiment of the invention may be implemented. Computer system <b>1300</b> includes a bus <b>1302</b> or other communication mechanism for communicating information, and a hardware processor <b>1304</b> coupled with bus <b>1302</b> for processing information. Hardware processor <b>1304</b> may be, for example, a general purpose microprocessor.</p><p id="p-0132" num="0147">Computer system <b>1300</b> also includes a main memory <b>1306</b>, such as a random access memory (RAM) or other dynamic storage device, coupled to bus <b>1302</b> for storing information and instructions to be executed by processor <b>1304</b>. Main memory <b>1306</b> also may be used for storing temporary variables or other intermediate information during execution of instructions to be executed by processor <b>1304</b>. Such instructions, when stored in non-transitory storage media accessible to processor <b>1304</b>, render computer system <b>1300</b> into a special-purpose machine that is customized to perform the operations specified in the instructions.</p><p id="p-0133" num="0148">Computer system <b>1300</b> further includes a read only memory (ROM) <b>1308</b> or other static storage device coupled to bus <b>1302</b> for storing static information and instructions for processor <b>1304</b>. A storage device <b>1310</b>, such as a magnetic disk, optical disk, or solid-state drive is provided and coupled to bus <b>1302</b> for storing information and instructions.</p><p id="p-0134" num="0149">Computer system <b>1300</b> may be coupled via bus <b>1302</b> to a display <b>1312</b>, such as a cathode ray tube (CRT), for displaying information to a computer user. An input device <b>1314</b>, including alphanumeric and other keys, is coupled to bus <b>1302</b> for communicating information and command selections to processor <b>1304</b>. Another type of user input device is cursor control <b>1316</b>, such as a mouse, a trackball, or cursor direction keys for communicating direction information and command selections to processor <b>1304</b> and for controlling cursor movement on display <b>1312</b>. This input device typically has two degrees of freedom in two axes, a first axis (e.g., x) and a second axis (e.g., y), that allows the device to specify positions in a plane.</p><p id="p-0135" num="0150">Computer system <b>1300</b> may implement the techniques described herein using customized hard-wired logic, one or more ASICs or FPGAs, firmware and/or program logic which in combination with the computer system causes or programs computer system <b>1300</b> to be a special-purpose machine. According to one embodiment, the techniques herein are performed by computer system <b>1300</b> in response to processor <b>1304</b> executing one or more sequences of one or more instructions contained in main memory <b>1306</b>. Such instructions may be read into main memory <b>1306</b> from another storage medium, such as storage device <b>1310</b>. Execution of the sequences of instructions contained in main memory <b>1306</b> causes processor <b>1304</b> to perform the process steps described herein. In alternative embodiments, hard-wired circuitry may be used in place of or in combination with software instructions.</p><p id="p-0136" num="0151">The term &#x201c;storage media&#x201d; as used herein refers to any non-transitory media that store data and/or instructions that cause a machine to operate in a specific fashion. Such storage media may comprise non-volatile media and/or volatile media. Non-volatile media includes, for example, optical disks, magnetic disks, or solid-state drives, such as storage device <b>1310</b>. Volatile media includes dynamic memory, such as main memory <b>1306</b>. Common forms of storage media include, for example, a floppy disk, a flexible disk, hard disk, solid-state drive, magnetic tape, or any other magnetic data storage medium, a CD-ROM, any other optical data storage medium, any physical medium with patterns of holes, a RAM, a PROM, and EPROM, a FLASH-EPROM, NVRAM, any other memory chip or cartridge.</p><p id="p-0137" num="0152">Storage media is distinct from but may be used in conjunction with transmission media. Transmission media participates in transferring information between storage media. For example, transmission media includes coaxial cables, copper wire and fiber optics, including the wires that comprise bus <b>1302</b>. Transmission media can also take the form of acoustic or light waves, such as those generated during radio-wave and infra-red data communications.</p><p id="p-0138" num="0153">Various forms of media may be involved in carrying one or more sequences of one or more instructions to processor <b>1304</b> for execution. For example, the instructions may initially be carried on a magnetic disk or solid-state drive of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system <b>1300</b> can receive the data on the telephone line and use an infra-red transmitter to convert the data to an infra-red signal. An infra-red detector can receive the data carried in the infra-red signal and appropriate circuitry can place the data on bus <b>1302</b>. Bus <b>1302</b> carries the data to main memory <b>1306</b>, from which processor <b>1304</b> retrieves and executes the instructions. The instructions received by main memory <b>1306</b> may optionally be stored on storage device <b>1310</b> either before or after execution by processor <b>1304</b>.</p><p id="p-0139" num="0154">Computer system <b>1300</b> also includes a communication interface <b>1318</b> coupled to bus <b>1302</b>. Communication interface <b>1318</b> provides a two-way data communication coupling to a network link <b>1320</b> that is connected to a local network <b>1322</b>. For example, communication interface <b>1318</b> may be an integrated services digital network (ISDN) card, cable modem, satellite modem, or a modem to provide a data communication connection to a corresponding type of telephone line. As another example, communication interface <b>1318</b> may be a local area network (LAN) card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation, communication interface <b>1318</b> sends and receives electrical, electromagnetic or optical signals that carry digital data streams representing various types of information.</p><p id="p-0140" num="0155">Network link <b>1320</b> typically provides data communication through one or more networks to other data devices. For example, network link <b>1320</b> may provide a connection through local network <b>1322</b> to a host computer <b>1324</b> or to data equipment operated by an Internet Service Provider (ISP) <b>1326</b>. ISP <b>1326</b> in turn provides data communication services through the world wide packet data communication network now commonly referred to as the &#x201c;Internet&#x201d; <b>1328</b>. Local network <b>1322</b> and Internet <b>1328</b> both use electrical, electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link <b>1320</b> and through communication interface <b>1318</b>, which carry the digital data to and from computer system <b>1300</b>, are example forms of transmission media.</p><p id="p-0141" num="0156">Computer system <b>1300</b> can send messages and receive data, including program code, through the network(s), network link <b>1320</b> and communication interface <b>1318</b>. In the Internet example, a server <b>1330</b> might transmit a requested code for an application program through Internet <b>1328</b>, ISP <b>1326</b>, local network <b>1322</b> and communication interface <b>1318</b>.</p><p id="p-0142" num="0157">The received code may be executed by processor <b>1304</b> as it is received, and/or stored in storage device <b>1310</b>, or other non-volatile storage for later execution.</p><heading id="h-0020" level="1">SOFTWARE OVERVIEW</heading><p id="p-0143" num="0158"><figref idref="DRAWINGS">FIG. <b>14</b></figref> is a block diagram of a basic software system <b>1400</b> that may be employed for controlling the operation of computing system <b>1300</b>. Software system <b>1400</b> and its components, including their connections, relationships, and functions, is meant to be exemplary only, and not meant to limit implementations of the example embodiment(s). Other software systems suitable for implementing the example embodiment(s) may have different components, including components with different connections, relationships, and functions.</p><p id="p-0144" num="0159">Software system <b>1400</b> is provided for directing the operation of computing system <b>1300</b>. Software system <b>1400</b>, which may be stored in system memory (RAM) <b>1306</b> and on fixed storage (e.g., hard disk or flash memory) <b>1310</b>, includes a kernel or operating system (OS) <b>1410</b>.</p><p id="p-0145" num="0160">The OS <b>1410</b> manages low-level aspects of computer operation, including managing execution of processes, memory allocation, file input and output (I/O), and device I/O. One or more application programs, represented as <b>1402</b>A, <b>1402</b>B, <b>1402</b>C . . . <b>1402</b>N, may be &#x201c;loaded&#x201d; (e.g., transferred from fixed storage <b>1310</b> into memory <b>1306</b>) for execution by the system <b>1400</b>. The applications or other software intended for use on computer system <b>1300</b> may also be stored as a set of downloadable computer-executable instructions, for example, for downloading and installation from an Internet location (e.g., a Web server, an app store, or other online service).</p><p id="p-0146" num="0161">Software system <b>1400</b> includes a graphical user interface (GUI) <b>1415</b>, for receiving user commands and data in a graphical (e.g., &#x201c;point-and-click&#x201d; or &#x201c;touch gesture&#x201d;) fashion. These inputs, in turn, may be acted upon by the system <b>1400</b> in accordance with instructions from operating system <b>1410</b> and/or application(s) <b>1402</b>. The GUI <b>1415</b> also serves to display the results of operation from the OS <b>1410</b> and application(s) <b>1402</b>, whereupon the user may supply additional inputs or terminate the session (e.g., log off).</p><p id="p-0147" num="0162">OS <b>1410</b> can execute directly on the bare hardware <b>1420</b> (e.g., processor(s) <b>1304</b>) of computer system <b>1300</b>. Alternatively, a hypervisor or virtual machine monitor (VMM) <b>1430</b> may be interposed between the bare hardware <b>1420</b> and the OS <b>1410</b>. In this configuration, VMM <b>1430</b> acts as a software &#x201c;cushion&#x201d; or virtualization layer between the OS <b>1410</b> and the bare hardware <b>1420</b> of the computer system <b>1300</b>.</p><p id="p-0148" num="0163">VMM <b>1430</b> instantiates and runs one or more virtual machine instances (&#x201c;guest machines&#x201d;). Each guest machine comprises a &#x201c;guest&#x201d; operating system, such as OS <b>1410</b>, and one or more applications, such as application(s) <b>1402</b>, designed to execute on the guest operating system. The VMM <b>1430</b> presents the guest operating systems with a virtual operating platform and manages the execution of the guest operating systems.</p><p id="p-0149" num="0164">In some instances, the VMM <b>1430</b> may allow a guest operating system to run as if it is running on the bare hardware <b>1420</b> of computer system <b>1300</b> directly. In these instances, the same version of the guest operating system configured to execute on the bare hardware <b>1420</b> directly may also execute on VMM <b>1430</b> without modification or reconfiguration. In other words, VMM <b>1430</b> may provide full hardware and CPU virtualization to a guest operating system in some instances.</p><p id="p-0150" num="0165">In other instances, a guest operating system may be specially designed or configured to execute on VMM <b>1430</b> for efficiency. In these instances, the guest operating system is &#x201c;aware&#x201d; that it executes on a virtual machine monitor. In other words, VMM <b>1430</b> may provide para-virtualization to a guest operating system in some instances.</p><p id="p-0151" num="0166">A computer system process comprises an allotment of hardware processor time, and an allotment of memory (physical and/or virtual), the allotment of memory being for storing instructions executed by the hardware processor, for storing data generated by the hardware processor executing the instructions, and/or for storing the hardware processor state (e.g. content of registers) between allotments of the hardware processor time when the computer system process is not running. Computer system processes run under the control of an operating system, and may run under the control of other programs being executed on the computer system.</p><heading id="h-0021" level="1">CLOUD COMPUTING</heading><p id="p-0152" num="0167">The term &#x201c;cloud computing&#x201d; is generally used herein to describe a computing model which enables on-demand access to a shared pool of computing resources, such as computer networks, servers, software applications, and services, and which allows for rapid provisioning and release of resources with minimal management effort or service provider interaction.</p><p id="p-0153" num="0168">A cloud computing environment (sometimes referred to as a cloud environment, or a cloud) can be implemented in a variety of different ways to best suit different requirements. For example, in a public cloud environment, the underlying computing infrastructure is owned by an organization that makes its cloud services available to other organizations or to the general public. In contrast, a private cloud environment is generally intended solely for use by, or within, a single organization. A community cloud is intended to be shared by several organizations within a community; while a hybrid cloud comprise two or more types of cloud (e.g., private, community, or public) that are bound together by data and application portability.</p><p id="p-0154" num="0169">Generally, a cloud computing model enables some of those responsibilities which previously may have been provided by an organization's own information technology department, to instead be delivered as service layers within a cloud environment, for use by consumers (either within or external to the organization, according to the cloud's public/private nature). Depending on the particular implementation, the precise definition of components or features provided by or within each cloud service layer can vary, but common examples include: Software as a Service (SaaS), in which consumers use software applications that are running upon a cloud infrastructure, while a SaaS provider manages or controls the underlying cloud infrastructure and applications. Platform as a Service (PaaS), in which consumers can use software programming languages and development tools supported by a PaaS provider to develop, deploy, and otherwise control their own applications, while the PaaS provider manages or controls other aspects of the cloud environment (i.e., everything below the run-time execution environment). Infrastructure as a Service (IaaS), in which consumers can deploy and run arbitrary software applications, and/or provision processing, storage, networks, and other fundamental computing resources, while an IaaS provider manages or controls the underlying physical cloud infrastructure (i.e., everything below the operating system layer). Database as a Service (DBaaS) in which consumers use a database server or Database Management System that is running upon a cloud infrastructure, while a DbaaS provider manages or controls the underlying cloud infrastructure and applications.</p><p id="p-0155" num="0170">The above-described basic computer hardware and software and cloud computing environment presented for purpose of illustrating the basic underlying computer components that may be employed for implementing the example embodiment(s). The example embodiment(s), however, are not necessarily limited to any particular computing environment or computing device configuration. Instead, the example embodiment(s) may be implemented in any type of system architecture or processing environment that one skilled in the art, in light of this disclosure, would understand as capable of supporting the features and functions of the example embodiment(s) presented herein.</p><p id="p-0156" num="0171">In the foregoing specification, embodiments of the invention have been described with reference to numerous specific details that may vary from implementation to implementation. The specification and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense. The sole and exclusive indicator of the scope of the invention, and what is intended by the applicants to be the scope of the invention, is the literal and equivalent scope of the set of claims that issue from this application, in the specific form in which such claims issue, including any subsequent correction.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A method comprising:<claim-text>storing, by a computer, a bipartite graph that consists of a source subgraph and a target subgraph,<claim-text>wherein:</claim-text><claim-text>each vertex in the bipartite graph represents an entity,</claim-text><claim-text>the source subgraph and the target subgraph are connected by a plurality of similarity edges, and</claim-text><claim-text>each similarity edge of the plurality of similarity edges indicates an original amount of similarity between:<claim-text>the entity of a source vertex of a plurality of source vertices in the source subgraph, and</claim-text><claim-text>the entity of a target vertex of a plurality of target vertices in the target subgraph;</claim-text></claim-text></claim-text><claim-text>for each similarity edge of the plurality of similarity edges, the computer determining:<claim-text>a set of neighbor source vertices in the plurality of source vertices that are reachable from the source vertex of the similarity edge by traversing at most a source radius count of source edges in the source subgraph,</claim-text><claim-text>a set of neighbor target vertices in the plurality of target vertices that are reachable from the target vertex of the similarity edge by traversing at most a target radius count of target edges in the target subgraph,</claim-text><claim-text>a source amount of vertices in the set of neighbor source vertices that are connected to a vertex in the set of neighbor target vertices by a similarity edge,</claim-text><claim-text>a target amount of vertices in the set of neighbor target vertices that are connected to a vertex in the set of neighbor source vertices by a similarity edge, and</claim-text><claim-text>a lesser amount of vertices that is a minimum of the source amount of vertices and the target amount of vertices;</claim-text></claim-text><claim-text>for each similarity edge of the plurality of similarity edges, the computer calculating a new amount of similarity based on said lesser amount.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein said calculating said new amount of similarity is further based on said original amount of similarity.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein:<claim-text>the method further comprises summing, into a summed amount, the lesser amount of vertices of each similarity edge that is connected to a same source vertex of the plurality of source vertices;</claim-text><claim-text>said calculating said new amount of similarity is further based on said summed amount.</claim-text></claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprising:<claim-text>adding, to said set of neighbor source vertices, the set of neighbor source vertices of each neighbor source vertex in said set of neighbor source vertices;</claim-text><claim-text>adding, to said set of neighbor target vertices, the set of neighbor target vertices of each neighbor target vertex in said set of neighbor target vertices.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> further comprising repeating:<claim-text>said determining the set of neighbor source vertices with an increased value of said source radius count;</claim-text><claim-text>said determining the set of neighbor target vertices with an increased value of said target radius count.</claim-text></claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref> wherein said repeating comprises repeating:<claim-text>said determining said source amount of vertices;</claim-text><claim-text>said determining said target amount of vertices.</claim-text></claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref> wherein:<claim-text>the method further comprises assigning a weight to each vertex in the bipartite graph,</claim-text><claim-text>said determining said source amount of vertices is based on at least one selected from the group consisting of:<claim-text>the weights of vertices in the set of neighbor source vertices,</claim-text><claim-text>the source amounts of vertices in the set of neighbor source vertices, and</claim-text><claim-text>counts of edges connecting the source vertex of the similarity edge to vertices of the set of neighbor source vertices;</claim-text></claim-text><claim-text>said determining said target amount of vertices is based on at least one selected from the group consisting of:<claim-text>the weights of vertices in the set of neighbor target vertices,</claim-text><claim-text>the target amounts of vertices in the set of neighbor target vertices, and</claim-text><claim-text>counts of edges connecting the target vertex of the similarity edge to vertices of the set of neighbor target vertices.</claim-text></claim-text></claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The method of <claim-ref idref="CLM-00007">claim 7</claim-ref> wherein said assigning the weight to each vertex in the bipartite graph comprises calculating an undirected PageRank of the vertex.</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref> wherein said calculating the undirected PageRank of the vertex comprises calculating a negative exponent based on the undirected PageRank of the vertex.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref> wherein said calculating the negative exponent is further based on undirected PageRanks of the vertices in the bipartite graph.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein said calculating said new amount of similarity of each similarity edge of the plurality of similarity edges comprises normalizing said new amount of similarity based on the source vertex of said similarity edge and not based on other vertices of the bipartite graph.</claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref> wherein said normalizing said new amount of similarity based on the source vertex of said similarity edge comprises normalizing said new amount of similarity based solely on similarity edges connected to the source vertex of said similarity edge.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein said calculating said new amount of similarity comprises not increasing said new amount of similarity unless said lesser amount of vertices exceeds a threshold.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The method of <claim-ref idref="CLM-00013">claim 13</claim-ref> wherein said calculating said new amount of similarity of each similarity edge of the plurality of similarity edges comprises normalizing said new amount of similarity regardless of whether said lesser amount of vertices exceeds said threshold.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein said source radius count of source edges in the source subgraph exceeds said target radius count of target edges in the target subgraph.</claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. One or more non-transitory computer-readable media storing instruction that, when executed by one or more processors, cause:<claim-text>storing a bipartite graph that consists of a source subgraph and a target subgraph, wherein:<claim-text>each vertex in the bipartite graph represents an entity,</claim-text><claim-text>the source subgraph and the target subgraph are connected by a plurality of similarity edges, and</claim-text><claim-text>each similarity edge of the plurality of similarity edges indicates an original amount of similarity between:<claim-text>the entity of a source vertex of a plurality of source vertices in the source subgraph, and</claim-text><claim-text>the entity of a target vertex of a plurality of target vertices in the target subgraph;</claim-text></claim-text></claim-text><claim-text>for each similarity edge of the plurality of similarity edges, determining:<claim-text>a set of neighbor source vertices in the plurality of source vertices that are reachable from the source vertex of the similarity edge by traversing at most a source radius count of source edges in the source subgraph,</claim-text><claim-text>a set of neighbor target vertices in the plurality of target vertices that are reachable from the target vertex of the similarity edge by traversing at most a target radius count of target edges in the target subgraph,</claim-text><claim-text>a source amount of vertices in the set of neighbor source vertices that are connected to a vertex in the set of neighbor target vertices by a similarity edge,</claim-text><claim-text>a target amount of vertices in the set of neighbor target vertices that are connected to a vertex in the set of neighbor source vertices by a similarity edge, and</claim-text><claim-text>a lesser amount of vertices that is a minimum of the source amount of vertices and the target amount of vertices;</claim-text></claim-text><claim-text>for each similarity edge of the plurality of similarity edges, the computer calculating a new amount of similarity based on said lesser amount.</claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The one or more non-transitory computer-readable media of <claim-ref idref="CLM-00016">claim 16</claim-ref> wherein said calculating said new amount of similarity is further based on said original amount of similarity.</claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The one or more non-transitory computer-readable media of <claim-ref idref="CLM-00016">claim 16</claim-ref> wherein:<claim-text>the instructions further cause summing, into a summed amount, the lesser amount of vertices of each similarity edge that is connected to a same source vertex of the plurality of source vertices;</claim-text><claim-text>said calculating said new amount of similarity is further based on said summed amount.</claim-text></claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The one or more non-transitory computer-readable media of <claim-ref idref="CLM-00016">claim 16</claim-ref> wherein the instructions further cause:<claim-text>adding, to said set of neighbor source vertices, the set of neighbor source vertices of each neighbor source vertex in said set of neighbor source vertices;</claim-text><claim-text>adding, to said set of neighbor target vertices, the set of neighbor target vertices of each neighbor target vertex in said set of neighbor target vertices.</claim-text></claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The one or more non-transitory computer-readable media of <claim-ref idref="CLM-00016">claim 16</claim-ref> wherein the instructions further cause:<claim-text>said determining the set of neighbor source vertices with an increased value of said source radius count;</claim-text><claim-text>said determining the set of neighbor target vertices with an increased value of said target radius count.</claim-text></claim-text></claim></claims></us-patent-application>