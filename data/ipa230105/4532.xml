<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004533A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004533</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17365774</doc-number><date>20210701</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>174</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>03</class><subclass>M</subclass><main-group>7</main-group><subgroup>30</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>1744</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>03</class><subclass>M</subclass><main-group>7</main-group><subgroup>3064</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>03</class><subclass>M</subclass><main-group>7</main-group><subgroup>3066</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>03</class><subclass>M</subclass><main-group>7</main-group><subgroup>6064</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">HYBRID INTERMEDIATE STREAM FORMAT</invention-title><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Microsoft Technology Licensing, LLC</orgname><address><city>Redmond</city><state>WA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>VALIULLIN</last-name><first-name>Renat</first-name><address><city>Redmond</city><state>WA</state><country>US</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">Systems and methods providing a hybrid intermediate stream format are provided. The method includes compressing a vertex into a first data block via a first compression method, compressing the vertex into a second data block via a second compression method, determining a smaller file of the first data block and the second data block, finalizing compression of the vertex via a compression method, selected from the first compression method and the second compression method, corresponding to the determined smaller file of the first data block and the second data block, and transferring the compressed vertex.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="192.11mm" wi="134.79mm" file="US20230004533A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="219.79mm" wi="136.82mm" file="US20230004533A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="216.58mm" wi="147.83mm" file="US20230004533A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="206.59mm" wi="167.39mm" file="US20230004533A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="220.81mm" wi="168.49mm" file="US20230004533A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="227.16mm" wi="173.23mm" file="US20230004533A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="212.85mm" wi="152.32mm" file="US20230004533A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="225.13mm" wi="161.37mm" file="US20230004533A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="151.21mm" wi="103.21mm" file="US20230004533A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="211.41mm" wi="166.79mm" file="US20230004533A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">BACKGROUND</heading><p id="p-0002" num="0001">Data is stored in vertices comprising numerous rows and columns. Transferring the data stored in a vertex is accomplished by transferring the data column-by-column and row-by-row using temporary storage, such as a disc. To reduce the time and resources required to transfer the data stored in the vertex, the data can be compressed. However, due to the different methods of compressing data contained in a vertex, at times an inefficient method of compressing the data can be executed, leading to wasted time and resources.</p><heading id="h-0002" level="1">SUMMARY</heading><p id="p-0003" num="0002">This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used as an aid in determining the scope of the claimed subject matter.</p><p id="p-0004" num="0003">Examples and implementations disclosed herein are directed to systems and methods that provide a hybrid intermediate stream format. The method includes compressing a vertex into a first data block via a first compression method, compressing the vertex into a second data block via a second compression method, determining a smaller file of the first data block and the second data block, finalizing compression of the vertex via a compression method, selected from the first compression method and the second compression method, corresponding to the determined smaller file of the first data block and the second data block, and transferring the compressed vertex.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0005" num="0004">The present description will be better understood from the following detailed description read in light of the accompanying drawings, wherein:</p><p id="p-0006" num="0005"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram illustrating an example computing device for implementing various examples of the present disclosure;</p><p id="p-0007" num="0006"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a block diagram illustrating a fragment of a simple scope job according to examples of the present disclosure;</p><p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a block diagram illustrating an example vertex of data according to examples of the present disclosure;</p><p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a block diagram illustrating a sequence of single row blocks according to examples of the present disclosure;</p><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a block diagram illustrating an intermediate buffer according to examples of the present disclosure;</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a block diagram illustrating a column chunk block according to examples of the present disclosure;</p><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a computerized method for writing a row to an intermediate buffer according to examples of the present disclosure;</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a computerized method for flushing the intermediate buffer according to examples of the present disclosure;</p><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a computerized method for generating block type 0/column chunk block according to examples of the present disclosure;</p><p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a computerized method for generating block type 1/row in v1 format according to examples of the present disclosure; and</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. <b>11</b></figref> is a computerized method for compressing and transferring data according to examples of the present disclosure.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><p id="p-0017" num="0016">Corresponding reference characters indicate corresponding parts throughout the drawings. In <figref idref="DRAWINGS">FIGS. <b>1</b> to <b>11</b></figref>, the systems are illustrated as schematic drawings. The drawings may not be to scale.</p><heading id="h-0004" level="1">DETAILED DESCRIPTION</heading><p id="p-0018" num="0017">The various implementations and examples will be described in detail with reference to the accompanying drawings. Wherever possible, the same reference numbers will be used throughout the drawings to refer to the same or like parts. References made throughout this disclosure relating to specific examples and implementations are provided solely for illustrative purposes but, unless indicated to the contrary, are not meant to limit all examples.</p><p id="p-0019" num="0018">As described above, conventional methods of transferring the data stored in a vertex is accomplished by transferring the data column-by-column and row-by-row using temporary storage. Various compression methods are available to make the transfer process more efficient, i.e., utilize less time and less resources. For example, the vertex is compressed into a smaller file size to be transferred, which requires less memory space to complete the data transfer.</p><p id="p-0020" num="0019">Memory space for transferring data in instances where a stream has a hard limit for required memory. When transferring data, an intermediate stream can be used to transfer data between execution nodes in large data processing job, such as Cosmos/ADL analytics. For example, one or more data inputs are input into an execution node which outputs one or more data outputs. The intermediate stream is conventionally implemented as a stream in a compressed data structure format that includes rows and columns of data and works using double buffering. Because an execution node can have several input or output streams, such as in the case of a joiner or a splitter, an outputter or extractor for a stream can have a hard limit for the required memory.</p><p id="p-0021" num="0020">However, current solutions fail to accurately identify the most efficient compression method. In particular, due to the differences in compression methods, some methods can improve the efficiency of transferring particular data or types of data more than other methods. For example, data stored in rows and columns can be compressed and transferred either row-by-row or column-by-column. However, whether row-by-row or column-by-column is the more efficient method of compression and transfer can depend on the data itself. Current solutions fail to effectively determine which type of compression and transfer is more efficient, taking into account the speed of the compression and transfer, the amount of resources, such as memory, required for the compression and transfer, and so forth.</p><p id="p-0022" num="0021">Various examples of the present disclosure address the above-identified challenges by analyzing the data to be compressed and transferred and, based on the analysis, determining the most efficient method of compression. For example, the data included in a vertex can be compressed into an intermediate stream using both a row-by-row method and a column-by-column method. A codec is executed to estimate a size of each data block resulting from the intermediate streams of both the row-by-row and column-by-column methods of compression. Based at least in part on the results of the estimation by the codec, the more cost-effective data block resulting from compression is selected to complete the data transfer from an intermediate stream to a single row data block, which is then transmitted to the new data location.</p><p id="p-0023" num="0022">Aspects of the present disclosure provide a computer-implemented method and system for a hybrid intermediate stream format. The method includes compressing a vertex into a first data block via a first compression method, compressing the vertex into a second data block via a second compression method, determining a smaller file of the first data block and the second data block, finalizing compression of the vertex via a compression method, selected from the first compression method and the second compression method, corresponding to the determined smaller file of the first data block and the second data block, and transferring the compressed vertex.</p><p id="p-0024" num="0023">Accordingly, the system provided in the present disclosure operates in an unconventional manner by selecting a compression method for compressing and transferring data based on an intermediate stream of the data to be transferred. In particular, compressing a vertex into two different intermediate streams, generated by different methods of compression, in order to estimate a cost for transferring the data improves the compression ratio, utilizes limited memory usage, and utilizes relatively little memory and CPU overhead compared to previous solutions. More specifically, the examples provided herein enable a preliminary determination to be made without utilizing additional resources to fully compress the data via either method. Further, the selection of a compression method is made based on the intermediate stream generated by the initial compression, rather than based on external factors.</p><p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram illustrating an example computing device <b>100</b> for implementing aspects disclosed herein and is designated generally as computing device <b>100</b>. Computing device <b>100</b> is but one example of a suitable computing environment and is not intended to suggest any limitation as to the scope of use or functionality of the examples disclosed herein. Neither should the computing device <b>100</b> be interpreted as having any dependency or requirement relating to any one or combination of components/modules illustrated.</p><p id="p-0026" num="0025">The examples disclosed herein may be described in the general context of computer code or machine- or computer-executable instructions, such as program components, being executed by a computer or other machine. Program components include routines, programs, objects, components, data structures, and the like that refer to code, performs particular tasks, or implement particular abstract data types. The disclosed examples may be practiced in a variety of system configurations, including servers, personal computers, laptops, smart phones, servers, VMs, mobile tablets, hand-held devices, consumer electronics, specialty computing devices, etc. The disclosed examples may also be practiced in distributed computing environments when tasks are performed by remote-processing devices that are linked through a communications network.</p><p id="p-0027" num="0026">The computing device <b>100</b> includes a bus <b>110</b> that directly or indirectly couples the following devices: computer-storage memory <b>112</b>, one or more processors <b>114</b>, one or more presentation components <b>116</b>, I/O ports <b>118</b>, I/O components <b>120</b>, a power supply <b>122</b>, and a network component <b>124</b>. While the computing device <b>100</b> is depicted as a seemingly single device, multiple computing devices <b>100</b> may work together and share the depicted device resources. For example, memory <b>112</b> is distributed across multiple devices, and processor(s) <b>114</b> is housed with different devices. Bus <b>110</b> represents what may be one or more busses (such as an address bus, data bus, or a combination thereof). Although the various blocks of <figref idref="DRAWINGS">FIG. <b>1</b></figref> are shown with lines for the sake of clarity, delineating various components may be accomplished with alternative representations. For example, a presentation component such as a display device is an I/O component in some examples, and some examples of processors have their own memory. Distinction is not made between such categories as &#x201c;workstation,&#x201d; &#x201c;server,&#x201d; &#x201c;laptop,&#x201d; &#x201c;hand-held device,&#x201d; etc., as all are contemplated within the scope of <figref idref="DRAWINGS">FIG. <b>1</b></figref> and the references herein to a &#x201c;computing device.&#x201d;</p><p id="p-0028" num="0027">Memory <b>112</b> may take the form of the computer-storage memory device referenced below and operatively provide storage of computer-readable instructions, data structures, program modules and other data for the computing device <b>100</b>. In some examples, memory <b>112</b> stores one or more of an operating system (OS), a universal application platform, or other program modules and program data. Memory <b>112</b> is thus able to store and access data <b>112</b><i>a </i>and instructions <b>112</b><i>b </i>that are executable by processor <b>114</b> and configured to carry out the various operations disclosed herein. In some examples, memory <b>112</b> stores executable computer instructions for an OS and various software applications. The OS may be any OS designed to the control the functionality of the computing device <b>100</b>, including, for example but without limitation: WINDOWS&#xae; developed by the MICROSOFT CORPORATION&#xae;, MAC OS&#xae; developed by APPLE, INC.&#xae; of Cupertino, Calif., ANDROID&#x2122; developed by GOOGLE, INC.&#xae; of Mountain View, Calif., open-source LINUX&#xae;, and the like.</p><p id="p-0029" num="0028">By way of example and not limitation, computer readable media comprise computer-storage memory devices and communication media. Computer-storage memory devices may include volatile, nonvolatile, removable, non-removable, or other memory implemented in any method or technology for storage of information such as computer-readable instructions, data structures, program modules, or the like. Computer-storage memory devices are tangible and mutually exclusive to communication media. Computer-storage memory devices are implemented in hardware and exclude carrier waves and propagated signals. Computer-storage memory devices for purposes of this disclosure are not signals per se. Example computer-storage memory devices include hard disks, flash drives, solid state memory, phase change random-access memory (PRAM), static random-access memory (SRAM), dynamic random-access memory (DRAM), other types of random-access memory (RAM), read-only memory (ROM), electrically erasable programmable read-only memory (EEPROM), flash memory or other memory technology, compact disk read-only memory (CD-ROM), digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other non-transmission medium that may be used to store information for access by a computing device. In contrast, communication media typically embody computer readable instructions, data structures, program modules, or the like in a modulated data signal such as a carrier wave or other transport mechanism and include any information delivery media.</p><p id="p-0030" num="0029">The computer-executable instructions may be organized into one or more computer-executable components or modules. Generally, program modules include, but are not limited to, routines, programs, objects, components, and data structures that perform particular tasks or implement particular abstract data types. Aspects of the disclosure may be implemented with any number an organization of such components or modules. For example, aspects of the disclosure are not limited to the specific computer-executable instructions or the specific components or modules illustrated in the figures and described herein. Other examples of the disclosure may include different computer-executable instructions or components having more or less functionality than illustrated and described herein. In examples involving a general-purpose computer, aspects of the disclosure transform the general-purpose computer into a special-purpose computing device, CPU, GPU, ASIC, system on chip (SoC), or the like for provisioning new VMs when configured to execute the instructions described herein.</p><p id="p-0031" num="0030">Processor(s) <b>114</b> may include any quantity of processing units that read data from various entities, such as memory <b>112</b> or I/O components <b>120</b>. Specifically, processor(s) <b>114</b> are programmed to execute computer-executable instructions for implementing aspects of the disclosure. The instructions may be performed by the processor <b>114</b>, by multiple processors <b>114</b> within the computing device <b>100</b>, or by a processor external to the client computing device <b>100</b>. In some examples, the processor(s) <b>114</b> are programmed to execute instructions such as those illustrated in the flow charts discussed below and depicted in the accompanying figures. Moreover, in some examples, the processor(s) <b>114</b> represent an implementation of analog techniques to perform the operations described herein. For example, the operations are performed by an analog client computing device <b>100</b> and/or a digital client computing device <b>100</b>.</p><p id="p-0032" num="0031">Presentation component(s) <b>116</b> present data indications to a user or other device. Example presentation components include a display device, speaker, printing component, vibrating component, etc. One skilled in the art will understand and appreciate that computer data may be presented in a number of ways, such as visually in a graphical user interface (GUI), audibly through speakers, wirelessly between computing devices <b>100</b>, across a wired connection, or in other ways. I/O ports <b>118</b> allow computing device <b>100</b> to be logically coupled to other devices including I/O components <b>120</b>, some of which may be built in. Example I/O components <b>120</b> include, for example but without limitation, a microphone, joystick, game pad, satellite dish, scanner, printer, wireless device, etc.</p><p id="p-0033" num="0032">The computing device <b>100</b> may communicate over a network <b>130</b> via network component <b>124</b> using logical connections to one or more remote computers. In some examples, the network component <b>124</b> includes a network interface card and/or computer-executable instructions (e.g., a driver) for operating the network interface card. Communication between the computing device <b>100</b> and other devices may occur using any protocol or mechanism over any wired or wireless connection. In some examples, network component <b>124</b> is operable to communicate data over public, private, or hybrid (public and private) using a transfer protocol, between devices wirelessly using short range communication technologies (e.g., near-field communication (NFC), Bluetooth&#x2122; branded communications, or the like), or a combination thereof. Network component <b>124</b> communicates over wireless communication link <b>126</b> and/or a wired communication link <b>126</b><i>a </i>across network <b>130</b> to a cloud environment <b>128</b>, such as one or more of the cloud-computing environments depicted in <figref idref="DRAWINGS">FIGS. <b>2</b>-<b>10</b></figref>. Various different examples of communication links <b>126</b> and <b>126</b><i>a </i>include a wireless connection, a wired connection, and/or a dedicated link, and in some examples, at least a portion is routed through the Internet.</p><p id="p-0034" num="0033">The network <b>130</b> may include any computer network or combination thereof. Examples of computer networks configurable to operate as network <b>130</b> include, without limitation, a wireless network; landline; cable line; digital subscriber line (DSL): fiber-optic line; cellular network (e.g., 3G, 4G, 5G, etc.); local area network (LAN); wide area network (WAN); metropolitan area network (MAN); or the like. The network <b>130</b> is not limited, however, to connections coupling separate computer units. Rather, the network <b>130</b> may also include subsystems that transfer data between servers or computing devices. For example, the network <b>130</b> may also include a point-to-point connection, the Internet, an Ethernet, an electrical bus, a neural network, or other internal system. Such networking architectures are well known and need not be discussed at depth herein.</p><p id="p-0035" num="0034">In some examples, the computing device <b>100</b> compresses data and transfers the compresses data to another device. For example, the computing device <b>100</b> compresses data and transfers the compressed data to a vertex stored by the cloud environment <b>128</b> via the network <b>130</b>. However, various examples are possible. The computing device <b>100</b> can transfer the data to an external computing device or store the compressed data for future transfer without departing from the scope of the present disclosure. Furthermore, the present disclosure contemplates various examples of compressing data for transfer, based at least in part on the format of the original data and the format of the data received by the cloud environment.</p><p id="p-0036" num="0035">In one particular example, the computing device <b>100</b> receives a data packet. The processor <b>114</b> extracts data from the packet and converts the data into a vertex comprising rows and columns. In some examples, the extracted data from the packet is in binary form. In other words, the data is provided within the vertex as a 0, 1, or null. An example vertex including one row and five columns is provided in Table 1 below.</p><p id="p-0037" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="35pt" align="center"/><colspec colname="2" colwidth="42pt" align="center"/><colspec colname="3" colwidth="35pt" align="center"/><colspec colname="4" colwidth="35pt" align="center"/><colspec colname="5" colwidth="35pt" align="center"/><thead><row><entry/><entry namest="offset" nameend="5" rowsep="1">TABLE 1</entry></row><row><entry/><entry namest="offset" nameend="5" align="center" rowsep="1"/></row><row><entry/><entry>Column 1</entry><entry>Column 2</entry><entry>Column 3</entry><entry>Column 4</entry><entry>Column 5</entry></row><row><entry/><entry namest="offset" nameend="5" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="35pt" align="center"/><colspec colname="2" colwidth="35pt" align="center"/><colspec colname="3" colwidth="42pt" align="center"/><colspec colname="4" colwidth="35pt" align="center"/><colspec colname="5" colwidth="35pt" align="center"/><colspec colname="6" colwidth="35pt" align="center"/><tbody valign="top"><row><entry>Row 1</entry><entry>Null</entry><entry>0</entry><entry>1</entry><entry>1</entry><entry>Null</entry></row><row><entry namest="1" nameend="6" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0038" num="0036">A vertex, for example but not limited to the vertex illustrated in Table 1, can be serialized into a buffer stream using at least two different methods, row-by-row serialization and column chunk serialization. For example, as illustrated in <figref idref="DRAWINGS">FIG. <b>3</b></figref> below, row-by-row serialization results in a stream, such as [row0.column0 . . . row0.columnK] [row1.column0 . . . row1.columnK] and so forth until each row has been serialized. As another example, as illustrated in <figref idref="DRAWINGS">FIG. <b>5</b></figref> below, column chunk serialization results in a stream, such as [row0.column0 . . . rowN.column0] [row0.column1 . . . rowN.column1] and so forth until each column chunk has been serialized. Row-by-row serialization and column chunk serialization each have advantages and disadvantages as methods for compressing and transferring the data extracted from the packet.</p><p id="p-0039" num="0037">The column-chunk format typically compresses data into a smaller file size because same kind values are typically grouped together. Accordingly, compressing data into a smaller file size can be advantageous when transferring the file. However, column-chunk format is less flexible and more expensive. Each chunk utilizes its own buffer, leading to an increase in memory usage to write the file. For example, each row block is in the memory and has a recommended size for widespread parquet/orc. Hundreds of Mb can be required to sufficiently work with a large number of columns and rows. Similarly, the same size buffer is typically required for reading. The row-by-row format enables column values to be written and/or read one-by-one using only a fixed size IO buffer.</p><p id="p-0040" num="0038">Accordingly, examples of the present disclosure provide an intermediate stream format with an improved compression ratio, in some examples several times better, when compared to row-by-row formats, limited memory usage of approximately an IO buffer size, and relatively low memory and CPU overhead requirements. Memory usage can be limited even for rows that contain data numbering in the hundreds of Mb. The stream format is provided as [magic number: &#x201c;BIN2&#x201d;] [data block] . . . [data block]. The data block can refer to either a single row data block or a column-chunk block.</p><p id="p-0041" num="0039">A single row data block is provided as [byte: <b>1</b>] [nulls bitmap] [column0 . . . columnK]. In a single row data block, null values are skipped and not included, but the corresponding bit is set in nulls bitmap. The variable size values (string/binaries) prepends using prefix (uleb128) encoded size. A column-chunk block is provided as [byte: <b>0</b>, unit 32 block-size, rows count] [nulls bitmaps] [column-chunks] [columns offsets table]. In the column-chunk block, nulls bitmap and column values are serialized in the same manner as the single row block but are instead grouped into column-chunks. Column 0 to column K represent all serialized non-null values in the particular columns while compressing out the null values.</p><p id="p-0042" num="0040">As referenced herein, a block size refers to a size, expressed in bytes, of the data block. In other words, the block size determines the amount of data in the data block. Nulls bitmap refers to how much data is included in a data block. For example, Table 1 illustrates five columns, two of which are null values and three of which are non-null values. Accordingly, the nulls bitmap value for Table 1 is three. The byte value of Table 1 is 1, because the data block has one row. Columns-chunk refers to the data included in the particular column or row. The columns offset table is offset to the start of each column chunk table. For example, if there are two columns in the vertex, the columns offset table contains two values.</p><p id="p-0043" num="0041">Accordingly, various examples of the present disclosure provide an improved intermediate schema. For example, the computing device <b>101</b> skips the nulls bitmap block where the stream schema contains only non-nullable columns. In another example, nulls bitmap is compacted for rows without nulls using an extra bit in the bitmap. In yet another example, schema is sorted by column types, to group same type values, that provides at least a 0.5% gain over real data.</p><p id="p-0044" num="0042">In some examples, the computing device <b>101</b> converts the data to the intermediate format. As the computing device <b>101</b> writes a row into the intermediate stream, the outputter estimates the size of the row and ignores the nulls. In examples where the row size exceeds the rest of the intermediate buffer, the buffer is flushed. In examples where the row size exceeds the buffer size, the row size is written as a single-row data block. In examples where the computing device <b>101</b> determines the buffer includes sufficient space for the corresponding column chunks, the column values and nulls bitmap are written into the corresponding column chunks. In some examples, the computing device implements an intermediate buffer as an auto-resizable buffer as [column0.chunk0] . . . [columnK.chunk0] [nulls.chunk0]. For example, the auto-resizable buffer is reserved virtual space including maximum possible overhead. As referenced herein, column chunk refers to fixed size data and four bytes that are offset to the next chunk, or zero if the last.</p><p id="p-0045" num="0043">In examples where the column chunk is full, a new chunk, of the same size, is allocated at the end of the buffer. In some examples, the physical memory page may be committed at that time. In some examples, data size for fixed size columns, for example numeric types, bool, char, and so forth, is 128 multiplied by the size of the type. Accordingly, 2 Kb can be the maximum data size for fixed size columns. In some examples, the data size for variable size columns, for example string and binary columns, can be 2 Kb. Therefore, the maximum memory overhead is approximately 1 Mb where the maximum column count in a row is limited by 512. For example, 512 columns multiplied by 2 Kb maximum data size provides approximately 1 Mb.</p><p id="p-0046" num="0044">In some examples, the computing device <b>101</b> generates a flush buffer. In some examples, the intermediate buffer is converted to the final column store block format with minimal complexity, such as via a memcpy function. For example, the conversion from the intermediate buffer illustrated in <figref idref="DRAWINGS">FIG. <b>4</b></figref> to the final intermediate block illustrated in <figref idref="DRAWINGS">FIG. <b>5</b></figref> is executed by copying an amount of bytes in the column-chunk format one by one. In examples where the buffer holds only one row, the buffer is serialized as a single-row data block. In other words, a header and/or tail is not needed for where the buffer holds only one row.</p><p id="p-0047" num="0045">In some examples, the column-chunk format can output less desirable results following compression. In this example, the compression of the first data block can be estimated in both row-by-row and column-chunk formats to determine which is more cost-effective and use that particular format to finish the compression and transfer. In one example, a first data block of the stream, which includes approximately 4 MB of data, is stored in an intermediate buffer, as illustrated in <figref idref="DRAWINGS">FIG. <b>4</b></figref> below. The first data block is converted into both the row-by-row format and the column-chunk format. As described below, <figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates the sequence of 1 row blocks, i.e., a V1 block, and <figref idref="DRAWINGS">FIG. <b>5</b></figref> illustrates a column-chunk block, i.e., a V0 block. The generated row-by-row blocks and the column-chunk blocks are compressed. The respective sizes of the blocks in the row-by-row format and the column chunk format are compared to determine the smaller size. The format that is determined to be smaller is then used for the rest of the stream.</p><p id="p-0048" num="0046">In some examples, the computing device <b>101</b> reads the block header to determine the size of the compressed block rather than reading the data itself. For example, if a block is a single row, column values are read one by one. Column stored blocks are read into the buffer completely, column iterators are initialized using the offsets table, and the values are read from the buffer with respect to the nulls bitmaps.</p><p id="p-0049" num="0047"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a block diagram illustrating a fragment of a simple scope job according to examples of the present disclosure. The block diagram <b>200</b> illustrated in <figref idref="DRAWINGS">FIG. <b>2</b></figref> is provided for illustration only. Other examples of the block diagram <b>200</b> can be used without departing from the scope of the present disclosure. It should be understood that the example data included in <figref idref="DRAWINGS">FIG. <b>2</b></figref> is for illustration only and should not be construed as limiting. Various examples of number of vertices, size of rows, time to read, and amounts of data read and written are possible without departing from the scope of the present disclosure.</p><p id="p-0050" num="0048">As shown in <figref idref="DRAWINGS">FIG. <b>2</b></figref>, SV1, SV2, SV3, SV4, and SV5 are respective stages of the simple scope job. In SV1, input data is read. In other words, in SV1, data is extracted, such as from external storage. The extracted data can include two partitions, one input and one output for each vertex. In SV1 illustrated in <figref idref="DRAWINGS">FIG. <b>2</b></figref>, the input data includes two vertices, 26,481 rows, the input data was read in 5.84 seconds/vertex, 799.77 MB of data was read, and 800.29 MB of data was written. In SV2, the input data is aggregated, i.e., compressed, into one vertex that includes 249 rows in 0.67 seconds/vertex. In SV3, the data is split into two vertices according to a new partition schema that includes one input and 250 outputs for each vertex. The new partition schema includes 26, 481 rows. In SV4, an aggregate split is performed to join the data from both initial partitions. In other words, SV4 has 2 inputs that are joined into a single output. In SV5, the output of SV4 is aggregated into one vertex.</p><p id="p-0051" num="0049">It should be appreciated that the data illustrated in <figref idref="DRAWINGS">FIG. <b>2</b></figref> is significantly compressed from SV1 to SV5. For example, SV1 reads 799.77 MB of data and writes 800.29 MB of data. In contrast, by the SV5 stage, only 6.50 MB of data is read and 81.93 KB is written.</p><p id="p-0052" num="0050"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a block diagram illustrating an example vertex of data according to examples of the present disclosure. The vertex <b>300</b> is provided for illustration only. Other examples of the vertex <b>300</b> can be used without departing from the scope of the present disclosure. As shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, the vertex <b>300</b> includes three columns, Column A, Column B, and Column C, and three rows. As described herein, the nulls bitmap size for the vertex <b>300</b> is 2 bits. Column B&#x2014;bit <b>0</b> and Column C&#x2014;bit #<b>1</b>. The bitmap size of the vertex <b>300</b> is aligned to 1 byte in order to simplify encoding.</p><p id="p-0053" num="0051"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a block diagram illustrating a sequence of single row blocks according to examples of the present disclosure. The single row block <b>400</b> is provided for illustration only. Other examples of the single row block <b>400</b> can be used without departing from the scope of the present disclosure. The single row block <b>400</b> is generated from the vertex <b>300</b> illustrated in <figref idref="DRAWINGS">FIG. <b>3</b></figref>. Generating a single row block such as the single row block <b>400</b> has the advantage of requiring minimal memory overhead. For example, the single row block <b>400</b> can be generated even if some column values exceed the buffer size.</p><p id="p-0054" num="0052"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a block diagram illustrating an intermediate buffer according to examples of the present disclosure. The intermediate buffer <b>500</b> is provided for illustration only. Other examples of the intermediate buffer <b>500</b> can be used without departing from the scope of the present disclosure. The intermediate buffer <b>500</b> illustrated in <figref idref="DRAWINGS">FIG. <b>5</b></figref> is generated from the vertex <b>300</b>. The intermediate buffer <b>500</b> accumulates data utilizing a relatively small memory overhead and simplifies conversion of the data to a column chunk block, for example the column chunk block <b>600</b> illustrated in <figref idref="DRAWINGS">FIG. <b>6</b></figref>. The intermediate buffer <b>500</b> has a part size of six bytes, with an actual size of 2 Kb.</p><p id="p-0055" num="0053"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a block diagram illustrating a column chunk block according to examples of the present disclosure. The column chunk block <b>600</b> is provided for illustration only. Other examples of the column chunk block <b>600</b> can be used without departing from the scope of the present disclosure. The column chunk block <b>600</b> is generated from the intermediate buffer <b>500</b> illustrated in <figref idref="DRAWINGS">FIG. <b>5</b></figref>. In some examples, the column chunk block <b>600</b> provides improved compression over the single row block <b>400</b>, but is only able to store rows smaller than the size of the block.</p><p id="p-0056" num="0054"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a computerized method for writing a row to an intermediate buffer according to examples of the present disclosure. The method <b>700</b> is provided for illustration only. Other examples of the method <b>700</b> can be used without departing from the scope of the present disclosure. In some examples, the method <b>700</b> can be implemented by the computing device <b>100</b>.</p><p id="p-0057" num="0055">The method <b>700</b> begins by the computing device <b>100</b> determining whether a value in a vertex of data is null in operation <b>701</b>. Where a value is determined not to be null, in operation <b>703</b> the computing device <b>100</b> adds a size of the value to the estimated size of the vertex. Where a value is determined to be null, in operation <b>705</b>, the computing device <b>100</b> sets a corresponding bit in the nulls bitmap.</p><p id="p-0058" num="0056">In operation <b>707</b>, the computing device <b>100</b> determines whether an intermediate buffer can fit a new row. In some examples, determining whether the intermediate buffer can fit a new row includes determining whether the intermediate buffer has sufficient space available to store a new row of data. In examples where the computing device <b>100</b> determines an intermediate buffer cannot fit a new row, the computing device <b>100</b> proceeds to operation <b>709</b>. In examples where the computing device <b>100</b> determines an intermediate buffer can fit a new row, the computing device <b>100</b> proceeds to operation <b>715</b>.</p><p id="p-0059" num="0057">In operation <b>709</b>, based on determining the buffer cannot fit a new row, the computing device <b>100</b> determines whether the buffer is empty. In examples where the computing device <b>100</b> determines the buffer is empty, in operation <b>711</b> the computing device <b>100</b> flushes the row as a one row block. In examples where the computing device <b>100</b> determines the buffer is not empty, in operation <b>713</b> the computing device <b>100</b> flushes the intermediate buffer. The process of flushing the intermediate buffer is described in greater detail below in the description of <figref idref="DRAWINGS">FIG. <b>8</b></figref>. Following the flushing of the intermediate buffer in operation <b>713</b>, the computing device <b>100</b> returns to operation <b>707</b> and determines whether the buffer can fit a new row.</p><p id="p-0060" num="0058">Based on a determination that the buffer cannot fit a new row in operation <b>707</b>, in operation <b>715</b> the computing device <b>100</b> determines, for each non-null column value and nulls bitmap, whether a chunk is allocated and can fit the particular non-null column value. In examples where a particular chunk is not allocated and/or cannot fit the value, in operation <b>717</b> the computing device <b>100</b> writes part of the value to the rest of the chunk and allocates a new chunk at the end of the buffer. The computing device <b>100</b> then returns to operation <b>715</b> and repeats the determination of whether a chunk is allocated and can fit the particular non-null column value for the next non-null column value and nulls bitmap. In examples where, in operation <b>715</b>, the computing device <b>100</b> determines the chunk is allocated and can fit the value, in operation <b>717</b> the computing device <b>100</b> writes the value to the chunk.</p><p id="p-0061" num="0059"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a computerized method for flushing the intermediate buffer according to examples of the present disclosure. The method <b>800</b> is provided for illustration only. Other examples of the method <b>800</b> can be used without departing from the scope of the present disclosure. In some examples, the method <b>800</b> can be implemented by the computing device <b>100</b>. In some examples, the method <b>800</b> for flushing the intermediate buffer is an example of flushing the buffer previously described in operation <b>713</b> of the method <b>700</b>.</p><p id="p-0062" num="0060">The method <b>800</b> begins by the computing device <b>100</b> determining whether the buffer. i.e., the intermediate buffer, contains more than one row in operation <b>801</b>. In examples where the computing device <b>100</b> determines the buffer does not contain more than one row, in operation <b>803</b> the computing device <b>100</b> writes the one row block. In examples where the computing device <b>100</b> determines the buffer does contain more than one row, in operation <b>805</b> the computing device <b>100</b> determines where the stream format to be used is determined. Various examples described herein recognize and take into account that, in many instances, column-chunk format is a default stream format. Accordingly, in examples where, in operation <b>805</b>, the computing device <b>100</b> determines the stream format to be used is determined to use the default, column-chunk format, the computing device <b>100</b> proceeds to operation <b>815</b>.</p><p id="p-0063" num="0061">In examples where, in operation <b>805</b>, the computing device <b>100</b> does not determine the stream format to be used is determined, in operation <b>807</b> the computing device <b>100</b> generates a representation of data in the column-chunk format and row-by-row format. For example, as described herein, to generate the representation of the data, the computing device <b>100</b> compresses generated row-by-row blocks and generated column-chunk blocks including headers for respective blocks.</p><p id="p-0064" num="0062">In operation <b>809</b>, the computing device <b>100</b> determines whether column-chunk format is preferred. In some examples, determining whether the column-chunk format or the row-by-row format is preferred includes determines which format is more cost-effective. Whether a method is cost-effective can be determined based on memory usage, CPU usage, and so forth required to compress and transfer the data. In examples where the column-chunk format is not determined to be preferred, i.e., the row-by-row format is preferred, in operation <b>811</b> the computing device <b>100</b> writes the block and the rest of the stream, and completes the transfer, by utilizing the row-by-row format. In examples where the column-chunk format is determined to be preferred, in operation <b>813</b> the computing device <b>100</b> sets the stream format as determined. For example, by setting the stream format as determined, the computing device <b>100</b> can determine, in a future iteration of operation <b>805</b>, that column-chunk is the preferred format and save time and computing resources by avoiding additional analysis.</p><p id="p-0065" num="0063">In operation <b>815</b>, the computing device <b>100</b> writes the block using the column-chunk format. As illustrated in <figref idref="DRAWINGS">FIG. <b>8</b></figref>, in some examples, the computing device <b>100</b> writes the block using the column-chunk format based on the stream format being determined in operation <b>805</b> and in some examples, the computing device <b>100</b> writes the block using the column-chunk format based on the column-chunk format being determined to be the preferred format. In some examples, the transfer is completing by transferring data from the intermediate data format to an external format for long-term storage, such as a data unit or partition stream, to provide gains in compressed and non-compressed form.</p><p id="p-0066" num="0064">Accordingly, various examples of the present disclosure utilizes an intermediate data format to provide temporary storage between vertices during vertex execution using smaller page 4 MB blocks. The present disclosure further provides a new binary format in order to write offsets in front of pages without reversing 250 MB buffer for strings. The new binary format is adaptive and is capable of switching between long row data representation and short row data representation. The new binary format holds small row data in the intermediate data format while the long data is stored in a traditional binary format. Accordingly, data can be transferred, or flushed, into the disk as the data is consumed, such as the implementation of the binary writer we have today. This reduces memory pressure while leaving all the advantages of the columnar store for intermediate vertex data storage.</p><p id="p-0067" num="0065">In some examples, the CPU utilization of the new intermediate block writer is smaller than structured stream formats designed for permanent storage. It should be understood that various examples described herein will not require an index or data key predicate manipulation. In some examples, the stream metadata and/or tail are omitted.</p><p id="p-0068" num="0066"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a computerized method for generating column chunk block according to examples of the present disclosure. The method <b>900</b> is provided for illustration only. Other examples of the method <b>900</b> can be used without departing from the scope of the present disclosure. In some examples, the method <b>900</b> can be implemented by the computing device <b>100</b>. In some examples, the column chunk block is referred to as a block type 0.</p><p id="p-0069" num="0067">The method <b>900</b> begins by the computing device <b>100</b> generating a header in operation <b>901</b>. The header includes the size of the block and the number of rows in the block. The block size and number of rows are calculated when the rows are accumulated in the intermediate buffer. In operation <b>903</b>, the computing device <b>100</b> generates the column values. The column values span from column0, the first column, to columnN, which represents the last column. The block can include any suitable number of columns without departing from the scope of the present disclosure. In operation <b>905</b>, the computing device <b>100</b> determines the nulls bitmaps for the block. As described herein, nulls bitmap refers to how much data is included in a data block. In operation <b>907</b>, the computing device <b>100</b> generates column offsets. As described herein, the columns offset table is offset to the start of each column chunk table. For example, if there are two columns in the vertex, the columns offset table value is two.</p><p id="p-0070" num="0068">In operation <b>909</b>, the computing device writes the first column chunk. In operation <b>911</b>, the computing device <b>100</b> determines whether the offset of the written first column chunk is zero. In examples where the offset is not zero, in operation <b>913</b> the computing device <b>100</b> proceeds to write the next chunk and returns to operation <b>911</b> to determine whether the offset is zero. The loop created by operations <b>911</b> and <b>913</b> continues until, in operation <b>911</b>, the computing device <b>100</b> determines the offset is zero. Based on the offset being determined to be zero, in operation <b>915</b>, the computing device <b>100</b> writes the table at the end of the block.</p><p id="p-0071" num="0069"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a computerized method for generating block type 1/row in v1 format according to examples of the present disclosure. The method <b>1000</b> is provided for illustration only. Other examples of the method <b>1000</b> can be used without departing from the scope of the present disclosure. In some examples, the method <b>1000</b> can be implemented by the computing device <b>100</b>.</p><p id="p-0072" num="0070">The method <b>1000</b> begins by the computing device <b>100</b> generating a nulls bitmap for the row in operation <b>1001</b>. As described herein, nulls bitmap refers to how much data is included in a data block. In some examples, the nulls bitmap is calculated and written first, i.e., prior to the data of a column being available, in order for the computing device <b>100</b> to determine whether the actual value is present or null. In operation <b>1003</b>, the computing device <b>100</b> generates column values for column0 through columnN. The column values span from column0, the first column, to columnN, which represents the last column.</p><p id="p-0073" num="0071"><figref idref="DRAWINGS">FIG. <b>11</b></figref> is a computerized method for compressing and transferring data according to examples of the present disclosure. The method <b>1100</b> is provided for illustration only. Other examples of the method <b>1100</b> can be used without departing from the scope of the present disclosure. In some examples, the method <b>1100</b> can be implemented by the computing device <b>100</b>.</p><p id="p-0074" num="0072">The method begins by the computing device <b>100</b> compressing a vertex into a first data block via a first compression method in operation <b>1101</b>. In some examples, the first compression method is a column-chunk compression format as described herein. In operation <b>1103</b>, the computing device <b>100</b> compresses the vertex into a second data block via a second compression method. In some examples, the second compression method is a row-by-row compression format as described herein.</p><p id="p-0075" num="0073">In operation <b>1105</b>, the computing device <b>100</b> determines a smaller file of the first data block and the second data block. For example, each of the first data block and the second data block include a header. In other words, the first data block includes a first header and the second data block includes a second header. Each header includes the size of the respective block and the number of rows in the respective block. The computing device <b>100</b> reads the first header and the second header to determine which file of the first data block and the second data block is smaller.</p><p id="p-0076" num="0074">In some examples, the computing device <b>100</b> determines at least one of the first data block or the second data block includes more than one row of data. Based at least in part on the determination, the computing device <b>100</b> determines the smaller file of the first data block and the second data block.</p><p id="p-0077" num="0075">In operation <b>1107</b>, the computing device <b>100</b> finalizes compression of the vertex via the compression method corresponding to the determined smaller file of the first data block and the second data block. In other words, in operation <b>1107</b>, based on the determined smaller file being the first data block, the computing device <b>100</b> finalizes compression of the vertex using the first compression method, i.e., the column-chunk compression method. In operation <b>1109</b>, based on the determined smaller file being the second data block, the computing device <b>100</b> finalizes compression of the vertex using the second compression method, i.e., the row-by-row compression method.</p><p id="p-0078" num="0076">In operation <b>1111</b>, the computing device <b>100</b> transfers the compressed vertex to an external format for long-term storage. For example, a long-term storage location includes, but is not limited to, a data unit, a partition stream, and so forth. In some examples, transferring the compressed vertex to an external format provides gains in both compressed and non-compressed form.</p><p id="p-0079" num="0077">In some examples, the computing device <b>100</b> sets the selected compression method as a default compression method for future transfers of the vertex. For example, where the selected compression method is the column-chunk compression method, the computing device <b>100</b> sets, i.e., saves, the column-chunk compression method as the default format for transferring the vertex. In some examples, the computing device <b>100</b> further sets the column-chunk compression method as the default format for transferring vertices similar to the vertex. A vertex can be determined to be similar based on having a header that includes similar size, number of rows, and so forth as the vertex.</p><heading id="h-0005" level="2">Additional Examples</heading><p id="p-0080" num="0078">Some examples herein are directed to a method of transferring a vertex including data using a hybrid intermediate stream format, as illustrated by the method <b>1100</b>. The method includes compressing (<b>1101</b>) a vertex into a first data block via a first compression method, compressing (<b>1103</b>) the vertex into a second data block via a second compression method, determining (<b>1105</b>) a smaller file of the first data block and the second data block, finalizing (<b>1107</b>, <b>1109</b>) compression of the vertex via a compression method, selected from the first compression method and the second compression method, corresponding to the determined smaller file of the first data block and the second data block, and transferring (<b>1111</b>) the compressed vertex.</p><p id="p-0081" num="0079">In some examples, the first data block includes a first header and the second data block includes a second header. The first header is a representation of data contained in the first data block and includes a size of the first data block and a number of rows in the first data bloc. The second header is a representation of data contained in the second data block and includes a size of the second data block and a number of rows in the second data block. The method further includes determining the smaller file of the first data block and the second data block includes reading the first header and the second header.</p><p id="p-0082" num="0080">In some examples, determining the smaller file of the first data block and the second data block includes determining the smaller file is a lower resource cost to compress and transfer than a comparatively larger file.</p><p id="p-0083" num="0081">In some examples, transferring the compressed vertex includes transferring the compressed vertex to a long-term storage location.</p><p id="p-0084" num="0082">In some examples, the method further includes setting the selected compression method as a default compression method.</p><p id="p-0085" num="0083">In some examples, the method further includes determining at least one of the first data block or the second data block includes more than one row of data; and based on least in part on the determination, determining the smaller file of the first data block and the second data block.</p><p id="p-0086" num="0084">Although described in connection with an example computing device <b>100</b>, examples of the disclosure are capable of implementation with numerous other general-purpose or special-purpose computing system environments, configurations, or devices. Examples of well-known computing systems, environments, and/or configurations that may be suitable for use with aspects of the disclosure include, but are not limited to, smart phones, mobile tablets, mobile computing devices, personal computers, server computers, hand-held or laptop devices, multiprocessor systems, gaming consoles, microprocessor-based systems, set top boxes, programmable consumer electronics, mobile telephones, mobile computing and/or communication devices in wearable or accessory form factors (e.g., watches, glasses, headsets, or earphones), network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, virtual reality (VR) devices, augmented reality (AR) devices, mixed reality (MR) devices, holographic device, and the like. Such systems or devices may accept input from the user in any way, including from input devices such as a keyboard or pointing device, via gesture input, proximity input (such as by hovering), and/or via voice input.</p><p id="p-0087" num="0085">Examples of the disclosure may be described in the general context of computer-executable instructions, such as program modules, executed by one or more computers or other devices in software, firmware, hardware, or a combination thereof. The computer-executable instructions may be organized into one or more computer-executable components or modules. Generally, program modules include, but are not limited to, routines, programs, objects, components, and data structures that perform particular tasks or implement particular abstract data types. Aspects of the disclosure may be implemented with any number and organization of such components or modules. For example, aspects of the disclosure are not limited to the specific computer-executable instructions or the specific components or modules illustrated in the figures and described herein. Other examples of the disclosure may include different computer-executable instructions or components having more or less functionality than illustrated and described herein. In examples involving a general-purpose computer, aspects of the disclosure transform the general-purpose computer into a special-purpose computing device when configured to execute the instructions described herein.</p><p id="p-0088" num="0086">By way of example and not limitation, computer readable media comprise computer storage media and communication media. Computer storage media include volatile and nonvolatile, removable, and non-removable memory implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules, or the like. Computer storage media are tangible and mutually exclusive to communication media. Computer storage media are implemented in hardware and exclude carrier waves and propagated signals. Computer storage media for purposes of this disclosure are not signals per se. Exemplary computer storage media include hard disks, flash drives, solid-state memory, phase change random-access memory (PRAM), static random-access memory (SRAM), dynamic random-access memory (DRAM), other types of random-access memory (RAM), read-only memory (ROM), electrically erasable programmable read-only memory (EEPROM), flash memory or other memory technology, compact disk read-only memory (CD-ROM), digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other non-transmission medium that can be used to store information for access by a computing device. In contrast, communication media typically embody computer readable instructions, data structures, program modules, or the like in a modulated data signal such as a carrier wave or other transport mechanism and include any information delivery media.</p><p id="p-0089" num="0087">The order of execution or performance of the operations in examples of the disclosure illustrated and described herein is not essential and may be performed in different sequential manners in various examples. For example, it is contemplated that executing or performing a particular operation before, contemporaneously with, or after another operation is within the scope of aspects of the disclosure. When introducing elements of aspects of the disclosure or the examples thereof, the articles &#x201c;a,&#x201d; &#x201c;an,&#x201d; &#x201c;the,&#x201d; and &#x201c;said&#x201d; are intended to mean that there are one or more of the elements. The terms &#x201c;comprising,&#x201d; &#x201c;including,&#x201d; and &#x201c;having&#x201d; are intended to be inclusive and mean that there may be additional elements other than the listed elements. The term &#x201c;exemplary&#x201d; is intended to mean &#x201c;an example of.&#x201d; The phrase &#x201c;one or more of the following: A, B, and C&#x201d; means &#x201c;at least one of A and/or at least one of B and/or at least one of C.&#x201d;</p><p id="p-0090" num="0088">Having described aspects of the disclosure in detail, it will be apparent that modifications and variations are possible without departing from the scope of aspects of the disclosure as defined in the appended claims. As various changes could be made in the above constructions, products, and methods without departing from the scope of aspects of the disclosure, it is intended that all matter contained in the above description and shown in the accompanying drawings shall be interpreted as illustrative and not in a limiting sense.</p><p id="p-0091" num="0089">While no personally identifiable information is tracked by aspects of the disclosure, examples have been described with reference to data monitored and/or collected from the users. In some examples, notice may be provided to the users of the collection of the data (e.g., via a dialog box or preference setting) and users are given the opportunity to give or deny consent for the monitoring and/or collection. The consent may take the form of opt-in consent or opt-out consent.</p><p id="p-0092" num="0090">Although the subject matter has been described in language specific to structural features and/or methodological acts, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather, the specific features and acts described above are disclosed as example forms of implementing the claims.</p><p id="p-0093" num="0091">It will be understood that the benefits and advantages described above may relate to one example or may relate to several examples. The examples are not limited to those that solve any or all of the stated problems or those that have any or all of the stated benefits and advantages. It will further be understood that reference to &#x2018;an&#x2019; item refers to one or more of those items.</p><p id="p-0094" num="0092">The term &#x201c;comprising&#x201d; is used in this specification to mean including the feature(s) or act(s) followed thereafter, without excluding the presence of one or more additional features or acts.</p><p id="p-0095" num="0093">In some examples, the operations illustrated in the figures may be implemented as software instructions encoded on a computer readable medium, in hardware programmed or designed to perform the operations, or both. For example, aspects of the disclosure may be implemented as a system on a chip or other circuitry including a plurality of interconnected, electrically conductive elements.</p><p id="p-0096" num="0094">The order of execution or performance of the operations in examples of the disclosure illustrated and described herein is not essential, unless otherwise specified. That is, the operations may be performed in any order, unless otherwise specified, and examples of the disclosure may include additional or fewer operations than those disclosed herein. For example, it is contemplated that executing or performing a particular operation before, contemporaneously with, or after another operation is within the scope of aspects of the disclosure.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A computer-implemented method, the method comprising:<claim-text>compressing a vertex into a first data block via a first compression method;</claim-text><claim-text>compressing the vertex into a second data block via a second compression method;</claim-text><claim-text>determining a smaller file of the first data block and the second data block;</claim-text><claim-text>finalizing compression of the vertex via a compression method, selected from the first compression method and the second compression method, corresponding to the determined smaller file of the first data block and the second data block; and</claim-text><claim-text>transferring the compressed vertex.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The computer-implemented method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein:<claim-text>the first data block includes a first header,</claim-text><claim-text>the second data block includes a second header, and</claim-text><claim-text>determining the smaller file of the first data block and the second data block includes reading the first header and the second header.</claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The computer-implemented method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein:<claim-text>the first header is a representation of data contained in the first data block, and</claim-text><claim-text>the second header is a representation of data contained in the second data block.</claim-text></claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The computer-implemented method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein:<claim-text>the first header includes a size of the first data block and a number of rows in the first data block, and</claim-text><claim-text>the second header includes a size of the second data block and a number of rows in the second data block.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The computer-implemented method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein determining the smaller file of the first data block and the second data block includes determining the smaller file is a lower resource cost to compress and transfer than a comparatively larger file.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The computer-implemented method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein transferring the compressed vertex includes transferring the compressed vertex to a long-term storage location.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The computer-implemented method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising setting the selected compression method as a default compression method.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The computer-implemented method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>determining at least one of the first data block or the second data block includes more than one row of data; and</claim-text><claim-text>based on least in part on the determination, determining the smaller file of the first data block and the second data block.</claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. One or more servers, each of the one or more servers comprising:<claim-text>a processor; and</claim-text><claim-text>a computer-readable medium storing instructions that, when executed by the processor, cause the processor to:<claim-text>compress a vertex into a first data block via a first compression method, the first data block including a first header;</claim-text><claim-text>compress the vertex into a second data block via a second compression method, the second data block including a second header;</claim-text><claim-text>read the first header and the second header;</claim-text><claim-text>based at least in part on the reading of the first header and the second header, determine a smaller file of the first data block and the second data block;</claim-text><claim-text>finalize compression of the vertex via a compression method, selected from the first compression method and the second compression method, corresponding to the determined smaller file of the first data block and the second data block; and</claim-text><claim-text>transfer the compressed vertex.</claim-text></claim-text></claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The one or more servers of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein:<claim-text>the first header is a representation of data contained in the first data block, and</claim-text><claim-text>the second header is a representation of data contained in the second data block.</claim-text></claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The one or more servers of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein:<claim-text>the first header includes a size of the first data block and a number of rows in the first data block, and</claim-text><claim-text>the second header includes a size of the second data block and a number of rows in the second data block.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The one or more servers of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the computer-readable medium further stores instructions that, when executed by the processor, causes the processor to, to determine the smaller file of the first data block and the second data block, determine the smaller file is a lower resource cost to compress and transfer than a comparatively larger file.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The one or more servers of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the computer-readable medium further stores instructions that, when executed by the processor, causes the processor to, to transfer the compressed vertex, transfer the compressed vertex to a long-term storage location.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The one or more servers of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the computer-readable medium further stores instructions that, when executed by the processor, causes the processor to set the selected compression method as a default compression method.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The one or more servers of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the computer-readable medium further stores instructions that, when executed by the processor, causes the processor to:<claim-text>determine at least one of the first data block or the second data block includes more than one row of data; and</claim-text><claim-text>based on least in part on the determination, determine the smaller file of the first data block and the second data block.</claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. One or more computer-storage memory devices embodied with executable operations that, when executed by a processor, cause the processor to:<claim-text>compress a vertex into a first data block via a first compression method;</claim-text><claim-text>compress the vertex into a second data block via a second compression method;</claim-text><claim-text>determine a smaller file of the first data block and the second data block;</claim-text><claim-text>finalize compression of the vertex via a compression method, selected from the first compression method and the second compression method, corresponding to the determined smaller file of the first data block and the second data block; and</claim-text><claim-text>transfer the compressed vertex.</claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The one or more computer-storage memory devices of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein:<claim-text>the first data block includes a first header that is a representation of data contained in the first data block, the first header including a size of the first data block and a number of rows in the first data block,</claim-text><claim-text>the second data block includes a second header that is a representation of data contained in the second data block, the second header including a size of the second data block and a number of rows in the second data block,</claim-text><claim-text>the one or more computer-storage memory devices are further embodied with executable operations that, when executed by a processor, cause the processor to:<claim-text>to determine the smaller file of the first data block and the second data block, read the first header and the second header</claim-text></claim-text></claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The one or more computer-storage memory devices of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the one or more computer-storage memory devices are further embodied with executable operations that, when executed by a processor, cause the processor to:<claim-text>to determine the smaller file of the first data block and the second data block, determine the smaller file is a lower resource cost to compress and transfer than a comparatively larger file.</claim-text></claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The one or more computer-storage memory devices of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the one or more computer-storage memory devices are further embodied with executable operations that, when executed by a processor, cause the processor to:<claim-text>set the selected compression method as a default compression method.</claim-text></claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The one or more computer-storage memory devices of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the one or more computer-storage memory devices are further embodied with executable operations that, when executed by a processor, cause the processor to:<claim-text>determine at least one of the first data block or the second data block includes more than one row of data; and</claim-text><claim-text>based on least in part on the determination, determine the smaller file of the first data block and the second data block.</claim-text></claim-text></claim></claims></us-patent-application>