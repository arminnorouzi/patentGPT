<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004491A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004491</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17364854</doc-number><date>20210630</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>084</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0811</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0862</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>02</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>084</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0811</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0862</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0238</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">APPROACH FOR REDUCING SIDE EFFECTS OF COMPUTATION OFFLOAD TO MEMORY</invention-title><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Advanced Micro Devices, Inc.</orgname><address><city>Santa Clara</city><state>CA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Aga</last-name><first-name>Shaizeen</first-name><address><city>Santa Clara</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Jayasena</last-name><first-name>Nuwan</first-name><address><city>Santa Clara</city><state>CA</state><country>US</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A technical solution to the technical problem of how to reduce the undesirable side effects of offloading computations to memory uses read hints to preload results of memory-side processing into a processor-side cache. A cache controller, in response to identifying a read hint in a memory-side processing instruction, causes results of the memory-side processing to be preloaded into a processor-side cache. Implementations include, without limitation, enabling or disabling the preloading based upon cache thrashing levels, preloading results, or portions of results, of memory-side processing to particular destination caches, preloading results based upon priority and/or degree of confidence, and/or during periods of low data bus and/or command bus utilization, last stores considerations, and enforcing an ordering constraint to ensure that preloading occurs after memory-side processing results are complete.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="140.38mm" wi="110.24mm" file="US20230004491A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="144.70mm" wi="112.27mm" file="US20230004491A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="100.25mm" wi="117.69mm" file="US20230004491A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="166.88mm" wi="124.88mm" file="US20230004491A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">BACKGROUND</heading><p id="p-0002" num="0001">The approaches described in this section are approaches that could be pursued, but not necessarily approaches that have been previously conceived or pursued. Therefore, unless otherwise indicated, it should not be assumed that any of the approaches described in this section qualify as prior art merely by virtue of their inclusion in this section. Further, it should not be assumed that any of the approaches described in this section are well-understood, routine, or conventional merely by virtue of their inclusion in this section.</p><p id="p-0003" num="0002">As computing throughput scales faster than memory bandwidth, various techniques have been developed to keep the growing computing capacity fed with data. Processing In Memory (PIM) incorporates processing capability within memory modules so that tasks can be processed directly within the memory modules. In the context of Dynamic Random-Access Memory (DRAM), an example PIM configuration includes vector compute elements and local registers that allow some computations to be performed locally to memory, such as arithmetic computations. This allows a memory controller to trigger local computations at multiple memory modules in parallel without requiring data movement across the memory module interface, which can greatly improve performance, particularly for data-intensive workloads.</p><p id="p-0004" num="0003">One of the technical problems of offloading computations to memory, for example using PIM technology, is that while it reduces data bus traffic and computational burdens on processors, there can be undesirable side effects. These include increased costs in the form of an increased number of cache flushes and cache misses when processor-side computations need to use the results of PIM-based computations that are stored in memory that would otherwise, at least in some situations, be available in processor-side caches had the PIM-based computations instead been performed by the processor.</p><p id="p-0005" num="0004">Consider the example of a first processor-side computation, followed by a PIM-based computation that uses the results of the first processor-side computation, followed by a second processor-side computation that uses the results of the PIM-based computation. The results of the first processor-side computation must be flushed to memory so that they are available to the PIM elements performing the PIM-based computation. Conversely, the results of the PIM-based computation that are needed for the second processor-side computation are stored in memory, which leads to cache misses. In this example, the costs of the additional cache flush and cache misses reduce or offset the performance benefits of offloading computations to PIM elements.</p><p id="p-0006" num="0005">One technical solution to this problem is to preload the results of PIM-based computations from memory to processor-side caches, for example by launching a prefetch function/kernel in the Graphics Processing Unit (GPU) context or issuing prefetch instructions in the Central Processing Unit (CPU) context. This solution has the disadvantages, however, of incurring increased latency attributable to an additional kernel launch in the GPU context and prefetches in the CPU context, and serialization of the preloading on the critical processor path. There is, therefore, a need for a technical solution to the technical problem of how to reduce the undesirable side effects of offloading computations to memory.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0002" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0007" num="0006">Implementations are depicted by way of example, and not by way of limitation, in the figures of the accompanying drawings and in which like reference numerals refer to similar elements.</p><p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. <b>1</b></figref> depicts an example cache architecture that includes a microprocessor and a processing-enabled memory.</p><p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. <b>2</b>A</figref> depicts instructions for performing a set of computations on a host processor.</p><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. <b>2</b>B</figref> depicts instructions for performing the same set of calculations as in <figref idref="DRAWINGS">FIG. <b>2</b>A</figref>, except the scalar sum calculation has been offloaded to memory.</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. <b>2</b>C</figref> depicts instructions for performing the same set of calculations as in <figref idref="DRAWINGS">FIG. <b>2</b>B</figref> with the scalar sum calculation offloaded to memory, except a read hint is used to reduce cache misses incurred by offloading the scalar sum calculation to memory.</p><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>3</b></figref> depicts an example table of memory-side processing results.</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a flow diagram that depicts an approach for reducing side effects of memory-based processing using read hints.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0003" level="1">DETAILED DESCRIPTION</heading><p id="p-0014" num="0013">In the following description, for the purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the implementations. It will be apparent, however, to one skilled in the art that the implementations may be practiced without these specific details. In other instances, well-known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the implementations.<ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0014">I. Overview</li>        <li id="ul0002-0002" num="0015">II. Cache Architecture</li>        <li id="ul0002-0003" num="0016">III. Read Hints        <ul id="ul0003" list-style="none">            <li id="ul0003-0001" num="0017">A. Introduction</li>            <li id="ul0003-0002" num="0018">B. Using Read Hints to Preload Results of Memory-Side Processing</li>            <li id="ul0003-0003" num="0019">C. Refinements and Extensions            <ul id="ul0004" list-style="none">                <li id="ul0004-0001" num="0020">1. Preloading to a Particular Target Cache</li>                <li id="ul0004-0002" num="0021">2. Selective Preloading of Memory-Side Computation Results</li>                <li id="ul0004-0003" num="0022">3. Priority and Degree of Confidence</li>                <li id="ul0004-0004" num="0023">4. Optional Preloading Based Upon Cache Thrashing</li>                <li id="ul0004-0005" num="0024">5. Fine-Grained Read Hints and Last Stores Considerations</li>            </ul>            </li>        </ul>        </li>    </ul>    </li></ul></p><heading id="h-0004" level="2">I. Overview</heading><p id="p-0015" num="0025">A technical solution to the technical problem of how to reduce the undesirable side effects of offloading computations to memory uses read hints to preload results of memory-side processing into a processor-side cache. As used herein and described in more detail hereinafter, the term &#x201c;read hint&#x201d; refers to an indication in a memory-side processing instruction that the results generated by the corresponding memory-side processing will be read by a processor. A cache controller, in response to identifying a read hint in a memory-side processing instruction, causes results of the memory-side processing to be preloaded into a processor-side cache.</p><p id="p-0016" num="0026">The technical solution provides the technical benefits of allowing data intensive computations to be offloaded to memory, but with reduced cache misses that would normally be incurred when offloading computations to memory. In addition, the technical solution does not suffer from the disadvantages of prior solutions, namely, increased latency attributable to additional kernel launches in the GPU context and prefetches in the CPU context, and serialization of the preloading on the critical processor path. Implementations include, without limitation, enabling or disabling the preloading based upon cache thrashing levels, preloading results of memory-side processing to particular destination caches, preloading particular portions of memory-side processing results, preloading results based upon priority and/or degree of confidence, preloading results during periods of low data bus and/or command bus utilization, last stores considerations, and enforcing an ordering constraint to ensure that preloading occurs after memory-side processing results are complete.</p><heading id="h-0005" level="2">II. Cache Architecture</heading><p id="p-0017" num="0027"><figref idref="DRAWINGS">FIG. <b>1</b></figref> depicts an example cache architecture <b>100</b> that includes a microprocessor <b>110</b> and a processing-enabled memory <b>120</b>. The example cache architecture <b>100</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref> is depicted and described in the context of a microprocessor, but implementations are not limited to this context and are applicable to the GPU context. The cache architecture <b>100</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref> can include fewer or additional elements, depending upon a particular implementation.</p><p id="p-0018" num="0028">The microprocessor <b>110</b> includes two cores, identified in <figref idref="DRAWINGS">FIG. <b>1</b></figref> as &#x201c;Core <b>1</b>&#x201d; and &#x201c;Core <b>2</b>&#x201d; for purposes of explanation, but implementations are not limited to implementations with two cores and are applicable to implementations with a single core or more than two cores. Each core includes a private level 1 (L1) and level 2 (L2) cache, and the two cores also share a level 3 (L3) cache, which in this example is the last level cache. Each of the caches L1, L2, L3 includes a cache controller that is not depicted in the figures for purposes of explanation. Implementations are not limited to the cache structure depicted in <figref idref="DRAWINGS">FIG. <b>1</b></figref> and are applicable to any type of cache structure including, for example, cache structures with fewer or additional caches of any type. In addition, although multi-core microprocessors are commonly implemented with the same cache structure, i.e., the same type and size of L1 and L2 cache, implementations are not limited to this context and are applicable to cores have different cache structures. The microprocessor <b>110</b> can include other elements that are not depicted in the figures or described herein for purposes of explanation, such as a memory controller, an Arithmetic and Logical Unit (ALU), buffers, data, address, control buses, etc., depending upon a particular implementation.</p><p id="p-0019" num="0029">The processing-enabled memory <b>120</b> is memory that includes one or more processing elements and, optionally, local storage for performing memory-side processing. One non-limiting example of the processing-enabled memory <b>120</b> is one or more Processor-In-Memory (PIM)-enabled Dynamic Random-Access Memory (DRAM) memory modules. Implementations are described hereinafter in the context of PIM-enabled memory for purposes of explanation, but implementations are not limited to this example and are applicable to any type of processing-enabled memory.</p><heading id="h-0006" level="2">III. Read Hints</heading><p id="p-0020" num="0030">A. Introduction</p><p id="p-0021" num="0031"><figref idref="DRAWINGS">FIGS. <b>2</b>A-<b>2</b>C</figref> depict example pseudo code in which read hints are used to reduce the side effects of offloading computations to memory. <figref idref="DRAWINGS">FIG. <b>2</b>A</figref> depicts instructions for performing a set of computations on a host processor. The computations include a first convolution calculation (&#x201c;Cony&#x201d;), a scalar sum calculation (&#x201c;Scalar-sum&#x201d;), and a second convolution calculation. These particular calculations are used for explanation purposes and implementations are applicable to any type and any number of functions or calculations.</p><p id="p-0022" num="0032">As depicted in <figref idref="DRAWINGS">FIG. <b>2</b>A</figref>, the results of the first convolution calculation are stored in array B and used in the scalar sum calculation. Similarly, the results of the scalar sum calculation are stored in array D and used in the second convolution calculation. The results of the second convolution calculation are stored in array E. It is normally expected, although not guaranteed, that at least a portion of arrays B, D, and E are stored in a processor-side cache, such as L1, L2 and/or L3 caches of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. The portions of these arrays that are stored in cache depend upon a variety of factors, such as the size of arrays B, D, and E, the size of the available cache, the particular eviction algorithm used, e.g., least recently used, least frequently used, first-in-first-out, etc. In this example it is presumed that at least a portion of arrays B and D are stored in processor-side cache and that the scalar sum and second convolution calculations have at least some cache hits when accessing the results stored in arrays B and D.</p><p id="p-0023" num="0033">The first and second convolution calculations are computationally intensive, but the scalar sum calculation is data intensive, meaning that a large amount of memory bandwidth is required to perform the scalar sum calculation. While all three of the computations can be performed by host processors, such as GPUs, CPUs, etc., doing so is inefficient because of the high memory bandwidth required to perform the scalar sum calculation at the processor can become a bottleneck.</p><p id="p-0024" num="0034"><figref idref="DRAWINGS">FIG. <b>2</b>B</figref> depicts instructions for performing the same set of calculations as in <figref idref="DRAWINGS">FIG. <b>2</b>A</figref>, except the scalar sum calculation has been offloaded to memory, i.e., the scalar sum calculation is performed by memory-side processing elements, such as PIM. Performing the scalar sum calculation in memory avails the computation of higher memory bandwidth that PIM can provide than is available to the processor when the scalar-sum calculation is performed by the processor, as in <figref idref="DRAWINGS">FIG. <b>2</b>A</figref>. As previously mentioned, however, there are some disadvantages with offloading calculations to memory.</p><p id="p-0025" num="0035">As depicted in <figref idref="DRAWINGS">FIG. <b>2</b>B</figref>, the results of the first convolution calculation that are stored in array B must be flushed to memory so that they are available to the memory-side processing elements to perform the scalar sum calculation. In addition, presuming that a subset of array D is also in processor caches, array D must also be flushed to memory so that the host caches do not store stale data when array D is updated by memory-side processing elements, such as PIM. This leads to the significant disadvantage that the second convolution calculation is guaranteed to incur a cache miss on array D, since array D is stored in memory and not in any processor-side caches. More specifically, array D must be loaded from memory into processor-side caches for performing the second convolution calculation. This at least partially offsets the performance benefits provided by performing the scalar sum calculation in memory.</p><p id="p-0026" num="0036">B. Using Read Hints to Preload Results of Memory-Side Processing</p><p id="p-0027" num="0037"><figref idref="DRAWINGS">FIG. <b>2</b>C</figref> depicts instructions for performing the same set of calculations as in <figref idref="DRAWINGS">FIG. <b>2</b>B</figref> with the scalar sum calculation offloaded to memory, except a read hint is used to reduce cache misses incurred by offloading the scalar sum calculation to memory. According to an implementation, the instruction to offload the scalar sum calculation to memory, i.e., &#x201c;PIM+: Scalar-sum (B+C&#x2192;D),&#x201d; includes a read hint that indicates that the results of the scalar sum calculation will be read by the host processor, e.g., to perform the second convolution calculation &#x201c;Cony (D, w2&#x2192;E),&#x201d; where the &#x201c;+&#x201d; in the pseudo code indicates that the PIM instruction includes a read hint.</p><p id="p-0028" num="0038">Read hints are invoked by any operation that indicates to a cache controller that the results of a calculation performed in memory will be read by a host processor. According to an implementation, a read hint is represented by one or more newly added bits, a previously unused bit value, a previously unused bit, or any combination of newly added bits and previously unused bit values and unused bits in the encoding of an operation. For example, it is not uncommon for command protocols to include extra or unused bits. A system with memory-side processing elements uses one of the previously extra or unused bits to specify a read hint. The particular unused bit values and/or bits used to indicate a read hint can be specified at processor design time, by preconfigured policies and/or runtime conditions.</p><p id="p-0029" num="0039">According to an implementation, command processing logic in a processor-side cache controller is configured to examine memory-side processing commands in the memory pipeline to determine whether certain bit values indicate a read hint. For example, a cache controller determines that a PIM command includes a read hint by examination, applying a bit mask, etc. Once a cache controller determines that a memory-side processing command includes a read hint, the cache controller causes the results of the memory-side processing to be preloaded into one or more processor-side caches. In the general case, a last level cache controller detects the read hint and causes the results of the memory-side processing to be preloaded into the last level cache. Alternately, as described in more detail hereinafter, other cache controllers cause results of memory-side processing to be preloaded into other caches. Having a cache controller instead of a GPU or a CPU perform preloading of results of memory-side processing as described herein avoids increasing latency attributable to additional kernel launches in the GPU context and prefetches in the CPU context, and serialization of the preloading on the critical processor path.</p><p id="p-0030" num="0040">According to an implementation, in the GPU context where a GPU is performing a computation subsequent to the memory-side computation, such as the second convolution calculation in <figref idref="DRAWINGS">FIG. <b>2</b>C</figref>, a cache controller in the GPU causes the results of the memory-side processing to be preloaded into a GPU cache. For example, a cache controller in the GPU causes array D, or a portion thereof, to be loaded into a GPU cache. Assuming, for example, that the data in array D occupies 1000 cache blocks, a cache controller performs <b>1000</b> loads to read array D from the processing-enabled memory <b>120</b> into the GPU cache.</p><p id="p-0031" num="0041">According to another implementation, in the CPU context where a processor or core is performing a computation subsequent to the memory-side processing computation, a processor-side cache controller preloads data from memory. In the prior example, the cache controller for the L3 cache preloads the 1000 values of array D from the processing-enabled memory <b>120</b> into the L3 cache. This makes the results of the memory-side processing that are stored in array D available in a processor-side cache for the second convolution computation. This provides the technical benefit of reducing the likelihood of cache misses, depending upon the size of the available cache, the size of array D, and the particular algorithms that are used to manage caches, without increasing core latency attributable to additional kernel launches in the GPU context and prefetches in the CPU context, or serialization of the preloading on the critical processor path, since a cache controller handles the preloading of the memory-side processing results. The approach can be implemented by any processor-side cache controller or a memory controller.</p><p id="p-0032" num="0042">This approach provides fine-grained control to software developers and compilers to mark specific memory-side processing instructions with read hints to reduce cache misses normally associated with memory-side processing. There may be situations where such fine-grained control is not necessary, i.e., on an instruction-by-instruction basis. According to an implementation, a cache controller or a memory controller is programmed with one or more address ranges for which preloading of memory-side processing results is desired. The cache controller or memory controller preloads results of memory-side processing for addresses within the programmed one or more address ranges.</p><p id="p-0033" num="0043">According to an implementation, the cache controller (or memory controller) performing the preloading of memory-side processing results enforces an ordering constraint to ensure that the preloading is performed after the memory-side processing results are complete. This can be accomplished using a variety of mechanisms. One such mechanism is the use of memory centric ordering primitives as described in U.S. patent application Ser. No. 16/808,346 entitled &#x201c;Lightweight Memory Ordering Primitives,&#x201d; filed on Mar. 3, 2020, the entire contents of which is incorporated herein by reference in its entirety for all purposes. Using ordering primitives ensures that the preloading of any portion of array D occurs after the memory-side computation on that portion of array D has been completed and the results stored to memory.</p><p id="p-0034" num="0044">According to an implementation, cache controllers store commands to perform preloading, such as prefetch commands, in queues to allow the cache controllers to manage issuance of the commands in a manner that reduces interference with other memory-side processing instructions or memory load/store operations. As one example, a cache controller issues prefetch commands from queues during idle periods, i.e., during periods of low data bus and/or command bus utilization to reduce interference with other memory-side processing or load/store instructions. Prefetch commands in queues can also be managed based upon priority and degree of confidence, as described in more detail hereinafter.</p><p id="p-0035" num="0045">C. Refinements and Extensions</p><p id="p-0036" num="0046">The approach described herein for reducing the undesirable side effects of offloading computations to memory using read hints includes various refinements and extensions that provide additional technical benefits.</p><p id="p-0037" num="0047">1. Preloading to a Particular Target Cache</p><p id="p-0038" num="0048">While in the general case previously described herein a last level cache controller causes the results of memory-side computations to be preloaded into a last level cache, implementations are not limited to this case. According to an implementation, results of memory-side computations are preloaded to any cache, including caches that do not directly correspond to the cache controller or memory controller performing the preloading.</p><p id="p-0039" num="0049">In this implementation, the memory-side processing instruction specifies a target cache, i.e., a destination cache, where the results of the memory-side processing will be stored. For example, newly added bits, unused bit values and/or unused bits in a memory-side processing instruction are used to specify the destination cache for the results of the memory-side processing. In this example, the cache controller corresponding to the destination cache specified in the memory-side processing instruction performs the preloading. Bit values and/or bits specify, without limitation, a compute unit ID of a GPU, a core ID of a CPU, or a cache ID, etc. If the memory-side processing instruction specifies a compute unit ID of a GPU or a core ID of a CPU, then the corresponding cache controller causes the results of the memory-side processing to be preloaded into a private cache of the corresponding GPU or CPU, e.g., the L1 and/or L2 cache of Core <b>1</b> or Core <b>2</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref>. According to an implementation, a last level cache, such as the L3 cache in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, is a default destination for the results of memory-side processing, unless a different destination is specified by the memory-side processing instruction. In this implementation, memory-side processing results are preloaded into the last level cache, regardless of which cache controller or memory controller performs the preloading.</p><p id="p-0040" num="0050">This approach provides the additional technical benefit of preloading the results of memory-side processing to a location that will be the most beneficial to the consumer of the results. For example, suppose that in <figref idref="DRAWINGS">FIG. <b>2</b>C</figref> the host instructions are performed by Core <b>1</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref>. The programmer specifies Core <b>1</b> as the destination for the results of the &#x201c;PIM+: Scalar-sum (B+C&#x2192;D)&#x201d; instruction so that they are available in cache for the second convolution instruction. The results of this memory-side computation are then preloaded into the L1 and/or L2 cache for Core <b>1</b>.</p><p id="p-0041" num="0051">2. Selective Preloading of Memory-Side Computation Results</p><p id="p-0042" num="0052">It is not uncommon for memory-side processing commands to be broadcast to multiple memory modules to process larger amounts of data in parallel. The result is that sometimes the results of memory-side processing span multiple cache blocks. Since not all of the cache blocks necessarily carry data that is needed in a subsequent processor-side computation, preloading all of the data can be inefficient and possibly increase cache misses. Additionally, the result of a memory-side computation may exceed the size of caches, making it wasteful to attempt to preload the entire output of a memory-side computation.</p><p id="p-0043" num="0053">According to an implementation, a memory-side processing instruction specifies one or more portions of memory-side processing results to be preloaded. The portions of results are be specified by one or more address ranges, one or more bit values to which a bit mask is applied, or data that specifies a particular address or memory-side processing element, such as a bank ID in the context of PIM-enabled DRAM. For example, a memory side processing instruction includes one or more bit values that correspond to one or more portions of memory-side processing results to be preloaded. This approach provides the additional technical benefit of improved efficiency and reduced likelihood of cache misses by focusing the preloading on the most relevant memory-side processing results. It also reduces the number of prefetch instructions stored in the cache controller queues. Policies that specify data regions to be preloaded can be preconfigured at the memory controller, via the operating system, or via application instructions by a programmer on a per-application basis.</p><p id="p-0044" num="0054">3. Priority and Degree of Confidence</p><p id="p-0045" num="0055">As previously mentioned herein, a cache controller can issue prefetch commands from queues during periods of low data bus and/or command bus utilization to reduce interference with other memory-side processing instructions and other memory requests from the processor. According to an implementation, a cache controller manages prefetch commands in queues based upon priority and degree of confidence. With respect to priority, memory-side processing commands, for which preloading of the corresponding memory-side processing results is to be used, specify a priority via, for example, one or more newly added or previously unused bit values or bits. The cache controller uses the priority specified in the memory-side processing command to decide when to issue the corresponding prefetch commands relative to other commands, i.e., in which order to issue commands. For example, prefetch commands are issued after all commands having a higher priority have been processed.</p><p id="p-0046" num="0056">&#x201c;Degree of confidence&#x201d; as used herein refers to the likelihood that the results of memory-side computations will be read by the same processor that issued the memory-side processing command. There may be situations where it is known, or with a very high level of confidence, that the same processor that issued the memory-side processing command will read the results of the memory-side processing. In this situation, the degree of confidence is high. In other situations, it may not be known with a high degree of confidence that the results of memory-side processing will be read by the same processor that issued the corresponding memory-side processing command. For example, the results of memory-side processing may be used in a subsequent calculation by a different CPU (or core) or GPU than the CPU or GPU that issued the memory-side processing command. In addition, in some cases, it may not be known what other computations may be executed by the same processor that issued the memory-side processing command prior to consuming the result of the memory-side computation, which can cause preloaded values to be evicted from caches before they are used. In these cases, the degree of confidence is low. As with priority, the degree of confidence can be specified in newly added bits or previously unused bit values and/or bits of a memory-side processing command.</p><p id="p-0047" num="0057">According to an implementation, a cache controller uses the degree of confidence to decide whether to invoke preloading of memory-side processing results. For example, if the degree of confidence specified for a memory-side processing command satisfies a specified level, then preloading of the results of the memory-side processing command is enabled and the results are preloaded into a processor-side cache. On the other hand, if the degree of confidence does not satisfy the specified level, e.g., is less than the specified level, the preloading is only used if the memory system shows idleness above a threshold or preloading is not used at all for that memory-side processing command. The ability to specify a priority and/or a degree of confidence in a memory-side processing command provides additional flexibility to software developers to control how cache controllers manage the new prefetch instructions that are generated to perform the preloading.</p><p id="p-0048" num="0058">4. Optional Preloading Based Upon Cache Thrashing</p><p id="p-0049" num="0059">In some situations, cached data is evicted from cache before it is used, known as &#x201c;cache thrashing,&#x201d; which can increase the number of cache misses and degrade performance. For example, a computing architecture implements a Least Recently Used (LRU) eviction policy that results in the LRU data in cache being evicted as additional data is brought into the cache. When the evicted data is eventually needed, it has to be reloaded from memory into cache, which adversely affects performance. This may also occur with memory-side processing results that have been preloaded into a cache using the approach described herein, i.e., cached memory-side processing results that were preloaded into cache using read hints are evicted from cache before they are used in a subsequent processor-side computation.</p><p id="p-0050" num="0060">According to an implementation, this technical problem is addressed by a technical solution that uses a cache thrashing threshold to enable or disable preloading of memory-side processing results using read hints. In a simple case, a cache controller detects whether cache thrashing exists and if so, disables preloading of memory-side processing results to avoid evicting existing useful data from cache. Alternatively, a cache controller monitors the level of cache thrashing and enables or disables preloading of memory-side processing results based upon the level of cache thrashing compared to the cache thrashing threshold. For example, if the current level of cache thrashing satisfies the cache thrashing threshold, i.e., is equal to or less than the cache thrashing threshold, then the current level of cache thrashing is either non-existent or low enough to enable preloading of memory-side processing results. In this situation it is presumed that preloading memory-side processing results into cache will not cause existing useful data to be evicted from cache. On the other hand, if the current level of cache thrashing does not satisfy the cache thrashing threshold, i.e., is greater than the cache thrashing threshold, then the current level of cache thrashing is too high, and preloading of memory-side processing results is disabled to prevent existing useful data from being evicted from cache.</p><p id="p-0051" num="0061">The current level of cache thrashing can be tracked by a counter that counts the number of cached data blocks that are evicted before being read by the processor. The counter counts evictions over a specified period of time and then be reset. Alternatively, the counter is incremented on evictions of data blocks that have not been used and decremented on preloaded data blocks that are used. The current count is compared to the cache thrashing threshold and if the counter is less than or equal to the cache thrashing threshold, then preloading of memory-side processing results is enabled. If the current count is greater than the cache thrashing threshold then preloading is disabled. The comparison of the current count to the cache thrashing threshold can be performed at specified times, periodically, or at specified events. The cache thrashing threshold and the criteria that determine when the cache thrashing check is performed can be preconfigured at the memory controller or via the operating system by a programmer on a per-application basis.</p><p id="p-0052" num="0062">According to an implementation, an address-based approach is used to enable or disable preloading of memory-side processing results based upon a current level of cache thrashing. In this implementation, a cache controller monitors the level of cache thrashing by address, i.e., by tracking whether cached data for specified addresses or address ranges are being evicted before being used. The cache controller then enables or disables preloading of memory-side processing results for the specified addresses or address ranges based upon the threshold. The selective enabling or disabling of preloading memory-side processing results using read hints based upon cache thrashing levels provides the technical benefit of using preloading when it is useful and will not degrade system performance below acceptable levels and not using preloading when current cache thrashing is high and enabling preloading is not likely to be useful and/or likely to degrade system performance below acceptable levels.</p><p id="p-0053" num="0063">5. Fine-Grained Read Hints and Last Stores Considerations</p><p id="p-0054" num="0064">There are situations where it is beneficial to selectively disable the use of read hints for particular portions of memory-side processing results. <figref idref="DRAWINGS">FIG. <b>3</b></figref> depicts an example table <b>300</b> of memory-side processing results. In this example, the memory-side processing results represent the results of the memory-side scalar sum computation of <figref idref="DRAWINGS">FIG. <b>2</b>C</figref> stored in array D and occupy 16 units of space, such as blocks. Suppose that in a particular implementation there is only sufficient available cache to store one of the 16 blocks. If all 16 blocks of memory-side processing results were successively preloaded into the cache, then after completion of the preload operations, only block 15 will be stored in the cache because starting with block 0, each successive block will have overwritten the prior block. If the second convolution operation starts with block 0 (head) and proceeds to block 15 (tail), then there will be cache misses for blocks 0 through 14, because only block 15 is stored in cache. In addition, the computational resources used for preloading blocks 0 through 14 are wasted.</p><p id="p-0055" num="0065">According to an implementation, this technical problem is addressed by the ability for memory-side processing instructions to specify the last N number of blocks of memory-side processing results that are to be preloaded. In the present example, the memory-side scalar sum command of <figref idref="DRAWINGS">FIG. <b>2</b>C</figref> specifies that the last block, i.e., block 15, of array D should be preloaded. The software developer or compiler, knowing the size of available cache and the size of memory-side processing results, specifies the last N number of blocks (or any other data unit) in the memory-side processing instruction. The last N number of blocks is specified, for example, by block ID or other information that identifies the portions of memory-side processing results that are to be preloaded. In addition, the software developer or compiler specifies that the next computation, e.g., the second convolution computation, is to be performed in reverse order, i.e., from block 15 (tail) to block 0 (head). This technical solution avoids wasting computational resources that are used to preload memory-side processing results that are evicted from cache before being used. The solution also increases the likelihood that cache hits will be realized for the memory-side processing results that are preloaded into cache. Although implementations are described in the context of preloading the last N number of portions of memory-side processing results, implementations are not limited to this example. A &#x201c;most-often-used&#x201d; data computation model can be used to identify portions of memory-side processing results that are most beneficial to preload for subsequent computations and then memory-side processing instructions are augmented with a read hint that specifies the identified portions of memory-side processing results. Referring again to <figref idref="DRAWINGS">FIG. <b>3</b></figref>, a memory-side processing command indicates that blocks 5-7 should be preloaded.</p><p id="p-0056" num="0066">As previously described herein, cache or memory controllers can be programmed with one or more address ranges for which preloading of memory-side processing results is desired. The cache controller or memory controller preloads results of memory-side processing for addresses within the programmed one or more address ranges. In situations where multiple memory-side processing instructions will store processing results to the programmed address range, the cache or memory controller would not know when to preload data from the programmed address range. To address this issue, a software developer or a compiler specifies that preloading of cache results is to be used for the last memory-side processing instruction that stores memory-side processing results to the programmed address range.</p><p id="p-0057" num="0067">The above-described refinements and extensions can be used individually or in any combination. For example, entire memory-side processing results can be preloaded to a default cache, such as a last level cache, or a particular target cache, and then managed by a cache controller using priority, degree of confidence, or both priority and degree of confidence. As another example, portions of memory-side processing results, as specified for example by address, last stores, etc., can be preloaded to a default cache, such as a last level cache, or a particular target cache and then managed by a cache controller using priority, degree of confidence, or both priority and degree of confidence.</p><p id="p-0058" num="0068"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a flow diagram <b>400</b> that depicts an approach for reducing side effects of memory-based processing using read hints. In this example, it is presumed that the optional preloading based upon cache thrashing is enabled, although it can be reevaluated at any time during this process.</p><p id="p-0059" num="0069">In step <b>402</b>, a memory-side processing command is issued. For example, processing of the &#x201c;PIM+: Scalar-sum (B+C&#x2192;D)&#x201d; instruction of <figref idref="DRAWINGS">FIG. <b>2</b>C</figref> causes a memory-side processing command to be issued into the memory pipeline and received by the cache controller for the L3 cache of <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0060" num="0070">In step <b>404</b>, a determination is made whether the memory-side processing command includes a read hint. For example, a cache controller or a memory controller, such as the cache controller for the L3 cache, i.e., the last level cache controller, examines and/or applies a bit mask to one or more bits in the memory-side processing command and the result indicates whether the memory-side processing command includes a read hint. Alternatively, if the cache controller or a memory controller is programmed with one or more address ranges for which preloading of memory-side processing results is desired, then the cache controller or memory controller determines whether the memory-side processing command specifies an address within the programmed address range(s). For example, the L3 cache controller determines whether all or a subset of array D in the PIM command of <figref idref="DRAWINGS">FIG. <b>2</b>C</figref> is within the preloads results of memory-side processing for addresses within the programmed one or more address ranges.</p><p id="p-0061" num="0071">In step <b>406</b>, one or more commands are generated to preload memory-side processing results. For example, a cache controller generates prefetch commands to load array D into the processor-side cache. The prefetch commands can specify a particular target cache for storing the memory-side processing results and/or can specify one or more portions of memory-side processing results.</p><p id="p-0062" num="0072">In step <b>408</b>, the commands are stored in one or more queues. Continuing the prior example, the cache controller that generated the 1000 prefetch commands stores them in one or more local queues managed by the cache controller.</p><p id="p-0063" num="0073">In step <b>410</b>, the cache controller manages and issues the commands stored in the queues. For example, the cache controller manages and issues the commands based upon priority, degree of confidence, or both priority and degree of confidence, as specified by the memory-side processing command. This is performed commensurate with enforcement of an ordering constraint to ensure that the memory-side computations are complete before the commands are issued to prefetch the memory-side processing results.</p><p id="p-0064" num="0074">In step <b>412</b>, the commands are processed, and the memory-side processing results are preloaded into a processor-side cache. For example, the prefetch commands are processed and the memory-side processing results, or a portion thereof, are loaded into a processor-side cache, such as a last level cache or a particular target cache specified in the memory-side processing command.</p><p id="p-0065" num="0075">The approach described herein for using read hints to reduce the undesirable side effects of offloading computations to memory can be implemented by any cache controller and any number of cache controllers. For example, a last level cache controller is configured with the functionality to recognize read hints in memory-side processing commands and cause the results, or a portion thereof, of memory-side processing results to be preloaded into a cache, including a last level cache that corresponds to the last level cache controller, or other caches. Alternatively, one or more other cache controllers, or all cache controllers, are configured with the preloading functionality. In the case where multiple cache controllers are configured with the preloading functionality, conflicts and/or duplication is avoided by designating a particular destination cache in memory-side processing instructions so that only the corresponding cache controller will perform the prefetching. This provides a fine-grained capability for software developers and compilers to decide where and how preloading is implemented. For example, suppose that the cache controller for the L1 cache of Core <b>1</b> and the cache controller for the last level cache L3 are configured with the preloading functionality. If a memory-side processing instruction includes a read hint but does not specify a destination cache for the memory-side processing results, then the cache controller for the L1 cache of Core <b>1</b> does not perform preloading and instead the cache controller for the last level cache L3 performs the preloading. In this example, the last level cache controller is the default for performing preloading. If the memory-side processing instruction specifies the L1 cache of Core <b>1</b> or a core ID for Core <b>1</b>, then the cache controller for the L1 cache of Core <b>1</b> performs the preloading and the cache controller for the last level cache L3 does not perform the preloading.</p><?detailed-description description="Detailed Description" end="tail"?></description><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A cache controller comprising:<claim-text>processing logic configured to, in response to determining that at least a portion of memory-side processing results will be read by a processor, cause the at least a portion of the memory-side processing results to be loaded into a processor-side cache.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The cache controller of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the processing logic is further configured to cause the at least a portion of the memory-side processing results to be loaded into a particular processor-side cache that is specified by a memory-side processing command.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The cache controller of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein:<claim-text>the at least a portion of the memory-side processing results is a subset of the memory-side processing results, and</claim-text><claim-text>the subset of the memory-side processing results is specified by a memory-side processing command.</claim-text></claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The cache controller of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the memory-side processing command specifies the subset of the memory-side processing results by one or more of:<claim-text>one or more addresses, a last N number of units of data, or data that identifies one or more memory-side processing units.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The cache controller of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the processing logic is further configured to determine that at least the portion of the memory-side processing results will be read by a processor based upon the at least the portion of the memory-side processing results being in an address range programmed in the cache controller and a memory-side processing command specifying that the at least the portion of the memory-side processing results should be loaded into the processor-side cache.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The cache controller of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the processing logic is further configured to:<claim-text>generate and store one or more prefetch commands for loading the at least a portion of the memory-side processing results into the processor-side cache, and</claim-text><claim-text>issue the one or more prefetch commands during times of low data bus utilization or low command bus utilization.</claim-text></claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The cache controller of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the processing logic is further configured to:<claim-text>generate and store one or more prefetch commands for loading the at least a portion of the memory-side processing results into the processor-side cache, and</claim-text><claim-text>issue the one or more prefetch commands based upon one or more of a priority or a degree of confidence specified by a memory-side processing command.</claim-text></claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The cache controller of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the processing logic is further configured to perform one or more of:<claim-text>detect whether cache thrashing currently exists and if cache thrashing does not currently exist, cause the at least a portion of the memory-side processing results to be loaded into the processor-side cache, or</claim-text><claim-text>determine a current level of cache thrashing for the processor-side cache and cause the at least a portion of the memory-side processing results to be loaded into the processor-side cache in response to the current level of cache thrashing for the processor-side cache being below a cache thrashing threshold.</claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The cache controller of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the processing logic is further configured to enforce an ordering constraint to ensure that the at least a portion of the memory-side processing results are loaded into the processor-side cache after the at least a portion of the memory-side processing results have been completed and stored to memory.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. A memory controller comprising:<claim-text>processing logic configured to, in response to determining that at least a portion of memory-side processing results will be read by a processor, cause the at least a portion of the memory-side processing results to be loaded into a processor-side cache.</claim-text></claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The memory controller of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the processing logic is further configured to cause the at least a portion of the memory-side processing results to be loaded into a particular processor-side cache that is specified by a memory-side processing command.</claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The memory controller of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein:<claim-text>the at least a portion of the memory-side processing results is a subset of the memory-side processing results, and</claim-text><claim-text>the subset of the memory-side processing results is specified by a memory-side processing command.</claim-text></claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The memory controller of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the memory-side processing command specifies the subset of the memory-side processing results by one or more of:<claim-text>one or more addresses, a last N number of units of data, or data that identifies one or more memory-side processing units.</claim-text></claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The memory controller of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the processing logic is further configured to determine that at least the portion of the memory-side processing results will be read by a processor based upon the at least the portion of the memory-side processing results being in an address range programmed in the memory controller and a memory-side processing command specifying that the at least the portion of the memory-side processing results should be loaded into the processor-side cache.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The memory controller of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the processing logic is further configured to:<claim-text>generate and store one or more prefetch commands for loading the at least a portion of the memory-side processing results into the processor-side cache, and</claim-text><claim-text>issue the one or more prefetch commands during times of low data bus utilization or low command bus utilization.</claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The memory controller of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the processing logic is further configured to:<claim-text>generate and store one or more prefetch commands for loading the at least a portion of the memory-side processing results into the processor-side cache, and</claim-text><claim-text>issue the one or more prefetch commands based upon one or more of a priority or a degree of confidence specified by a memory-side processing command.</claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The memory controller of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the processing logic is further configured to perform one or more of:<claim-text>detect whether cache thrashing currently exists and if cache thrashing does not currently exist, cause the at least a portion of the memory-side processing results to be loaded into the processor-side cache, or</claim-text><claim-text>determine a current level of cache thrashing for the processor-side cache and cause the at least a portion of the memory-side processing results to be loaded into the processor-side cache in response to the current level of cache thrashing for the processor-side cache being below a cache thrashing threshold.</claim-text></claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The memory controller of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein the processing logic is further configured to enforce an ordering constraint to ensure that the at least a portion of the memory-side processing results are loaded into the processor-side cache after the at least a portion of the memory-side processing results have been completed and stored to memory.</claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. A method comprising:<claim-text>causing, by a cache controller, at least a portion of memory-side processing results to be loaded into a processor-side cache in response to determining that the at least a portion of the memory-side processing results will be read by a processor.</claim-text></claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The method of <claim-ref idref="CLM-00019">claim 19</claim-ref>, further comprising causing, by the cache controller, the at least a portion of the memory-side processing results to be loaded into a particular processor-side cache that is specified by a memory-side processing command.</claim-text></claim></claims></us-patent-application>