<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004561A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004561</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17940069</doc-number><date>20220908</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>2458</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>N</subclass><main-group>20</main-group><subgroup>00</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>N</subclass><main-group>5</main-group><subgroup>04</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>2455</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>N</subclass><main-group>5</main-group><subgroup>02</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>2462</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>N</subclass><main-group>20</main-group><subgroup>00</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>N</subclass><main-group>5</main-group><subgroup>04</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>24553</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>N</subclass><main-group>5</main-group><subgroup>022</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">CONFIGURABLE APPROXIMATE SEARCH OF CHARACTER STRINGS</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>16732165</doc-number><date>20191231</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11468074</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17940069</doc-number></document-id></child-doc></relation></continuation></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="obligated-assignee"><addressbook><orgname>Rapid7, Inc.</orgname><address><city>Boston</city><state>MA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Holub</last-name><first-name>Viliam</first-name><address><city>Prague</city><country>CZ</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Shanley</last-name><first-name>Eoin</first-name><address><city>Dublin</city><country>IE</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>Parsons</last-name><first-name>Trevor</first-name><address><city>Boston</city><state>MA</state><country>US</country></address></addressbook></inventor></inventors></us-parties><assignees><assignee><addressbook><orgname>Rapid7, Inc.</orgname><role>02</role><address><city>Boston</city><state>MA</state><country>US</country></address></addressbook></assignee></assignees></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">Systems and methods are disclosed for an approximate string searching technique to search for match results that have character differences with the search string. A cost is computed to measure the amount of character differences, and a match is recognized if the cost is below a threshold. The match is determined based on an inferred state machine, whose states are iteratively generated in computer memory for successive characters in the input text. States are added to represent modifications to the string needed to account for character differences and track the costs of the modifications. States are removed when their costs become excessive. Advantageously, the search process never generates the full state machine in memory, retaining only a selected set of best states to continue with the approximate match process. The technique thus enables a practicable implementation of approximate searching that can tolerate an arbitrary number of character deviations.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="223.60mm" wi="152.15mm" file="US20230004561A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="235.80mm" wi="154.18mm" file="US20230004561A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="237.74mm" wi="167.22mm" file="US20230004561A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="207.01mm" wi="149.10mm" orientation="landscape" file="US20230004561A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="226.14mm" wi="150.79mm" file="US20230004561A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="226.14mm" wi="154.18mm" file="US20230004561A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="226.06mm" wi="134.45mm" file="US20230004561A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="233.60mm" wi="147.49mm" file="US20230004561A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="218.95mm" wi="174.92mm" orientation="landscape" file="US20230004561A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="218.95mm" wi="174.92mm" orientation="landscape" file="US20230004561A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="218.95mm" wi="174.92mm" orientation="landscape" file="US20230004561A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="218.95mm" wi="174.92mm" orientation="landscape" file="US20230004561A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="232.07mm" wi="154.18mm" file="US20230004561A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="238.08mm" wi="154.18mm" file="US20230004561A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00014" num="00014"><img id="EMI-D00014" he="238.08mm" wi="160.61mm" file="US20230004561A1-20230105-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00015" num="00015"><img id="EMI-D00015" he="238.08mm" wi="150.79mm" file="US20230004561A1-20230105-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00016" num="00016"><img id="EMI-D00016" he="232.07mm" wi="154.18mm" file="US20230004561A1-20230105-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">BACKGROUND</heading><p id="p-0002" num="0001">Many companies operate private computer networks that are connected to public networks such as the Internet. While such connections allow company users to easily access resources on the public networks, they also create vulnerabilities in the company network. For example, company users may unwittingly download malicious content (e.g. data, files, applications, programs, etc.) onto the company network from untrusted sources on the Internet. As another example, interactions of company users with the public network may provide opportunities for malicious actors to attack the company network. A malicious actor can plant spyware, viruses, or other types of malicious software in a company's private network though a variety of interactive means, in order to steal sensitive information from the company or even gain control of the company's computing systems. As a result, enterprise security management systems have become increasingly important to protect company networks against these types of vulnerabilities.</p><p id="p-0003" num="0002">Some enterprise security management systems may analyze a company's network using different types of event log data collected from computing resources in the network, to detect conditions such as security vulnerabilities, network attacks, or network breaches. Such analysis typically relies on text searches performed over a large volume of collected log data. However, the use of standard text searching in this context has significant limitations. Small changes to the spelling of a text string make the text string virtually invisible to the analysis software. Attackers can easily evade detection by making small changes to names and identifiers, for example, changing an executable name from &#x201c;svchost&#x201d; to &#x201c;svchOst.&#x201d; As another example, brute force attacks that generate variations of a name or password are notoriously difficult to detect through standard searching. Even when it is known that an attack has occurred, it can be extremely difficult to find traces of the attack in the log data, because the searcher does not know what string variations to search for. More powerful searching techniques are needed to permit searching of variations of text strings that contain unknown misspellings.</p><heading id="h-0002" level="1">SUMMARY OF EMBODIMENTS</heading><p id="p-0004" num="0003">The systems and methods described herein may be employed in various combinations and in embodiments to implement an approximate string searching technique to search for match results in input texts that have character differences with the search string. In embodiments, a cost is computed to measure the amount of character differences, and a match is recognized if the cost is below a threshold. In embodiments, the match is determined based on an inferred state machine, whose states are iteratively generated in computer memory for successive characters in the text. During each iteration, states may be added to represent modifications to the search string needed to account for character differences and track the costs of the modifications. States may be removed when their costs become excessive. Advantageously, the approximate matching process never generates the full state machine in memory, retaining only a selected set of best states to continue with the approximate match process. Accordingly, the disclosed technique enables a practicable computer implementation of approximate string searching that can tolerate an arbitrary number of character deviations.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0005" num="0004"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram illustrating an example approximate search system that searches for variations of a search string, according to some embodiments.</p><p id="p-0006" num="0005"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a block diagram illustrating a machine monitoring service implemented in a platform-as-a-service provider network that uses approximate searching, according to some embodiments.</p><p id="p-0007" num="0006"><figref idref="DRAWINGS">FIGS. <b>3</b>A and <b>3</b>B</figref> illustrate stages of a string traversal graph generated by an approximate search system for a search string, according to some embodiments.</p><p id="p-0008" num="0007"><figref idref="DRAWINGS">FIGS. <b>4</b>A to <b>4</b>D</figref> illustrate different types of states transitions that can occur during an approximate match process of a search string and a text, according to some embodiments.</p><p id="p-0009" num="0008"><figref idref="DRAWINGS">FIGS. <b>5</b>A to <b>5</b>D</figref> illustrate different types of conditions for pruning states during an approximate match process of a search string and a text, according to some embodiments.</p><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. <b>6</b></figref> illustrates an example user interface used to configure parameters of an approximate search system, according to some embodiments.</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIGS. <b>7</b>A to <b>7</b>C</figref> illustrate different user interfaces for invoking and viewing results of an approximate search, according to some embodiments.</p><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>8</b></figref> illustrates an input data scanner that outputs approximate matches of search terms to be added to a library of search terms, according to some embodiments.</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIGS. <b>9</b>A to <b>9</b>C</figref> are flowcharts illustrating aspects of an approximate search process performed by an approximate search system, according to some embodiments.</p><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a block diagram illustrating an example computer system that can be used to implement one or more portions of an approximate search system, according to some embodiments.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><p id="p-0015" num="0014">While embodiments are described herein by way of example for several embodiments and illustrative drawings, those skilled in the art will recognize that embodiments are not limited to the embodiments or drawings described. It should be understood, that the drawings and detailed description thereto are not intended to limit embodiments to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope as defined by the appended claims. As used throughout this application, the word &#x201c;may&#x201d; is used in a permissive sense (i.e., meaning having the potential to), rather than the mandatory sense (i.e., meaning must). Similarly, the words &#x201c;include,&#x201d; &#x201c;including,&#x201d; and &#x201c;includes&#x201d; mean including, but not limited to.</p><heading id="h-0004" level="1">DETAILED DESCRIPTION OF EMBODIMENTS</heading><p id="p-0016" num="0015">Enterprise security management systems may analyze a company's network based on event log data collected from computing resources in the network, to detect conditions such as security vulnerabilities, network attacks, or network breaches. Such analysis typically relies on text searches performed over a large volume of collected log data. However, standard text searching in this context has significant limitations. In particular, small changes in the spelling of a text string make the text string virtually invisible to the standard searches. A number of attacker tactics have evolved to take advantage of this weakness. For example, attackers may obfuscate certain names by varying the spelling of the names (e.g., from &#x201c;svchost&#x201d; to &#x201c;svchOst&#x201d;). Phishing attacks may deliberately embed misspellings in the web addresses they use to evade detection. Some types of attacks such as brute force attacks that use variations of common usernames or passwords are notoriously difficult to detect through standard searching. Additionally, in many situations, misspellings may be introduced through routine data processing (e.g., to inject escape characters into strings) or by unintentional human errors (e.g., misspelled parameter names). These types of misspellings of text strings make programmatic detection of the strings nearly impossible. Worse, even when it is known that some variation of a string exists in the data, finding the actual record that contains the string variation can be extremely difficult.</p><p id="p-0017" num="0016">Accordingly, embodiments of an approximate search system and technique are disclosed herein, which can be used to perform efficient searching of variations of text strings in large volumes of data. The approximate search system can produce results that are approximate matches for a given search string, with some amount of character differences such as character substitutions, deletions, or insertions, up to an adjustable error limit.</p><p id="p-0018" num="0017">In some embodiments, the approximate search system may be used to search for approximate matches of a search string in a repository of many data records or texts. For each given text or data record, the approximate search system will attempt to find in the given text a minimal substring of the pattern *(X SUB DEL INS)*, where X represents a character in the search string, SUB represents a substitution of a character in the string, INS represents an insertion of a character to the string, and DEL represents a deletion of a character from the string. For example, an approximate match for the string &#x201c;mailman&#x201d; may be found in the variation &#x201c;madman,&#x201d; which is matched based on the pattern &#x201c;ma[SUB][DEL]man&#x201d;.</p><p id="p-0019" num="0018">In some embodiments, each match pattern is assigned a price or cost to quantify the pattern's deviation from, or modification of, the original search string. In some embodiments, each type of deviation or modification operation (e.g., SUB, INS, or DEL) may be assigned an operation cost, and the cost of the pattern may be computed by summing the costs of all individual operations in the pattern. In some embodiments, the cost of operation ACCEPT (i.e. an acceptance operation that matches the current character in the text with a character in the search string) may be set so that it is less than the cost of the any other operation SUB, INS, or DEL. In some embodiments, the cost of operation ACCEPT may be set to zero. In some embodiments, the cost of the SUB operation may be set so that it is less than the sum of the costs of INS and DEL. As may be understood, this setting will cause the approximate matching process to prefer a SUB operation over an equivalent pair of INS and DEL operations. In some embodiments, the modification operation costs and the formula for calculating the overall cost of a match may be configurable by the user.</p><p id="p-0020" num="0019">In some embodiments, the approximate match process may construct a traversal graph to represent the search string. The graph may include a path of nodes that correspond to successive characters in the search string. The graph may start with an initial node that corresponds to a zero position before the first character position of the string, and end with a last node that correspond to the last character position of the string. During the approximate match process, the graph is traversed in steps based on the characters in the text, to track the current match position in the search string. Reaching the last position in the graph means that an approximate match has been found.</p><p id="p-0021" num="0020">In some embodiments, the traversal graph is augmented to add failure transitions. A failure transition is a transition that is taken if the match process cannot continue in the graph to the next position for the current character in the text. A failure transition may point backwards, to a node at a lower position than the current node. The failure transition may be generated so that it indicates the longest beginning portion of the search string that matches a processed portion of the text including the current character.</p><p id="p-0022" num="0021">In some embodiments, the augmented graph is generated once for the search string, and used repeatedly to match many texts against the search string. The approximate match process for each individual text is performed based on a state machine inferred from the graph. In some embodiments, the inferred state machine may be implemented as a type of pushdown automaton. Each state in the state machine may indicate a current match position in the search string, a last operation (e.g. one of ACCEPT, SUB, INS, or DEL) performed to arrive at that state, and an accumulated cost expended to reach that state.</p><p id="p-0023" num="0022">The approximate match process may proceed in iterations, where each iteration consumes one character from the text and transitions states in the state machine. However, at any given iteration, the approximate match process only maintains some subset of states of the state machine in computer memory, without holding all possible states in memory. At each iteration, a set of new states may be generated for the state machine from existing states of the state machine (e.g. those states that were retained after the previous iteration). Further, a pruning of the states is performed to remove those states that are duplicative, too costly, inferior to other states, etc., or for other reasons. In some embodiments, the pruning process will also remove end states (i.e. states that have reached the last match position in the traversal graph), since they do not need to be processed in subsequent iterations.</p><p id="p-0024" num="0023">As may be understood, the state machines inferred by the approximate match process can be extremely large. The size of these state machines can grow exponentially with the length of the search string or the length of text being searched. These state machines typically cannot fit within the memory of current computing systems. However, by maintaining only a subset of the states in memory at any given iteration, the disclosed approximate match process limits the amount of memory and processing power that is needed to execute the state machine, thus enabling the state machine to be practically implemented using current computers.</p><p id="p-0025" num="0024">In some embodiments, the approximate match process will constrain the types of new states that can be generated, to further reduce the amount of states that are produced in memory. In some embodiments, a SUB type state (a state that has SUB as its last operation) can be generated only if its preceding state is of type ACCEPT or SUB. In some embodiments, an INS type state is only generated if its preceding state is of type ACCEPT, SUB, or INS. In some embodiments, a DEL type state is only generated if its preceding state is of type, ACCEPT, SUB, or DEL. In some embodiments, a single iteration may generate a sequence of DEL states to remove multiple unmatched characters in the string. In some embodiments, these constraints will cause the match process to produce approximate matches in the form (X SUB*(INS*|DEL*))*. As may be understood, use of these constraints will remove certain match results obtained from combinations of equivalent modification operations.</p><p id="p-0026" num="0025">In some embodiments, if the approximate match process reaches an end state with a cost that does not exceed a cost limit for the search, that end state may be provided as the match result. On the other hand, if the approximate match process ends without reaching an acceptable end state, this means that the text does not contain an approximate match of the search string. In some embodiments, the approximate match process may continue to scan through the entire text even after an acceptable end state has been found. The match process may find multiple acceptable end states for the text, and output the end state with the lowest cost as the match result. In some embodiments, the cost associated with the match result is also included in the output. In some embodiments, if an end state of zero cost is reached, that end state will be outputted immediately, and the match process will be stopped without further examination of additional characters in the text.</p><p id="p-0027" num="0026">The approximate search system may be implemented in many different types of computer systems. In some embodiments, approximate searching may be implemented in a database system that is configured to process queries for approximate searches specified in a type of query language. In some embodiments, the approximate search system may be used to search through log records, such as records of events generated from other computers. In some embodiments, the approximate search system may be used to detect close variations for a library of search terms used for a periodic scan, and report the detected variations to an administrator to be reviewed and added to the library for future scans.</p><p id="p-0028" num="0027">Moreover, the approximate search system may be exposed via many different types of user interfaces. In some embodiments, the search interface may be a graphical user interface (GUI) that provides users the option (e.g. via a checkbox) to perform a string search as an approximate search. The GUI may provide approximate match results in a sorted order, sorted according to their respective match costs. In some embodiments, the user interface may be a command line interface or a query interface. In some embodiments, the approximate search system may be accessed via a programmatic interface such as a web service interface or application programming interface (API).</p><p id="p-0029" num="0028">In some embodiments, a user interface may allow a user to perform an exact search of a search term, and if no results or too few results are found, prompt the user to run the search again using an approximate search. In some embodiments, approximate searching may be enabled by default for every search, and the user interface may provide results of an exact search, along with an indication that additional approximate match results were found using an approximate search.</p><p id="p-0030" num="0029">In some embodiments, the user interface may allow users to specify the cost limit for the search as a parameter of the search request. In some embodiments, the cost limit may be programmatically calculated by the approximate search system, for example, based on the length of the search term, the size of the dataset to be searched, the type or language of the search term, etc. In some embodiments, the cost limit may be dynamically adjusted based on the amount of match results produced by previous searches.</p><p id="p-0031" num="0030">As will be appreciated by those skilled in the art, the disclosed features the approximate search system improve upon current text searching systems in the state of the art to enhance the functioning of these systems. These and other features and benefits of the approximate search system are described in further detail below, in connection with the figures.</p><p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram illustrating an example approximate search system that searches for variations of a search string, according to some embodiments.</p><p id="p-0033" num="0032">As shown, the depicted approximate search system <b>130</b> in this example is configured to accept input <b>110</b> and produce output <b>120</b>. The input <b>110</b> may include a text dataset to be searched <b>112</b> and a search string <b>114</b> to look for in the text dataset. The text dataset <b>112</b> may be a dataset maintained in any manner that can be accessed by the search system <b>130</b>. For example, the text dataset may be stored as data records in a database or a log file. As another example, the text dataset may be received as a stream of data records, possibly from an external computer system. The text dataset may include a large number of individual texts or records to be searched. In some embodiments, the texts or records may be event records of machine events that were collected from remote machines, which may be sorted by an event timestamp. The records in the text dataset may include searchable fields that can be matched against the search string <b>114</b>.</p><p id="p-0034" num="0033">The search string <b>114</b> is the text string that the approximate search system <b>130</b> will look for in the text dataset <b>112</b>. The search string <b>114</b> may be obtained via a variety of means, such as from user input, programmatic input, or from a data store. In some embodiments, the search string <b>114</b> may be specified as part of a user query, may include an indication to perform a search of the string <b>114</b> using approximate search. In some embodiments, the search string <b>114</b> may be received via a graphical user interface (GUI).</p><p id="p-0035" num="0034">The approximate search system <b>130</b> may perform the approximate search by attempting to match individual texts or records in the text dataset <b>112</b> to the search string <b>114</b>. Those texts and records that are deemed to be approximate matches to the string will be included in match results <b>122</b> of the output <b>120</b>. In some embodiments, the output <b>120</b> may also include the match costs <b>124</b> associated with each approximate match result <b>122</b>. In some embodiments, the output <b>120</b> may be provided in a sorted order, based on the match costs of the match results. For example, the output may indicate match results with match costs in an ascending order, to show closer matches before farther matches. The output <b>120</b> may be provided in a variety of ways, for example, via a GUI or via a programmatic interface (e.g. as a response to a service request or API call).</p><p id="p-0036" num="0035">As shown in this example, the approximate search system <b>130</b> will construct two data structures <b>170</b> and <b>180</b> to perform the approximate match process for an individual text. In some embodiments, these data structures may be loaded into the main memory of a computer system during execution of the approximate search system <b>130</b>. In some embodiments, a traversal graph generator component <b>140</b> is used to generate <b>145</b> a string traversal graph <b>170</b>. The string traversal graph <b>170</b> is constructed as a representation of the search string <b>114</b>, and it may be reused for each text record in the text dataset <b>112</b>. In some embodiments, the string traversal graph <b>170</b> may be implemented as a graph or an array of indexes, where the nodes represent individual character positions in the search string, and the edges indicate possible transitions among the positions. In some embodiments, the graph <b>170</b> may include failure transitions that are backwards pointing, so that a character mismatch at a current position will cause the position to transition back to an earlier position. This graph <b>170</b> will be used to determine the current match position of an individual text record during the approximate matching process for the text record, and may be used to infer the state machine <b>180</b>.</p><p id="p-0037" num="0036">The state machine <b>180</b> is inferred from the string traversal graph <b>170</b>. The state machine will be inferred for each text record and used for the approximate match process for each text record. The state machine will include a set of states (e.g. states <b>182</b>, <b>184</b>, <b>186</b>, and <b>190</b>). A state may be generated for each successive character in the text, and each state in the inferred state machine <b>180</b> corresponds a state of the approximate match process after observation of a next character in the text. At each given character or iteration, the search system will generate a subset of states of the state machine. However, the search system will not generate the full set of states for the inferred state machine <b>180</b> in memory, because the full state machine will be prohibitively large for most computing systems. Rather, the approximate match process will perform an iterative process, to repeatedly generate new states and prune existing states for each successive character in the text. In some cases, an existing state in the state machine may generate multiple successive states in one iteration. The match process will continue to generate new states in this fashion, possibly for all characters in the text. If an acceptable end state (e.g. a state that reaches the last match position of the search string with acceptable cost) is generated during the match process, the search system will report that an approximate match has been found.</p><p id="p-0038" num="0037">Individual states of the inferred state machine <b>180</b> will include a number of attributes. As shown, machine state <b>190</b> in this example includes three attributes <b>192</b>, <b>194</b>, and <b>196</b>. The string match position <b>192</b> indicates the current match position in the search string achieved at the state <b>190</b>. This match position <b>192</b> may be determined based on the string traversal graph <b>170</b>. The last operation <b>194</b> indicates an operation that was last performed by the state machine to reach the state <b>190</b>. In some embodiments, the last operation may be one of ACCEPT, SUB, INS, or DEL, where ACCEPT indicates a match of a last text character in the text to a search string character at the match position, SUB indicates a substitution of the search string character with the text character, INS indicates an insertion of the text character before the search string character, and DEL indicates a deletion of the search string character. In some embodiments, the last operation attribute <b>194</b> is used to constrain the type of new states that are generated during the match process. The accumulated cost attribute <b>196</b> indicates an accumulated cost that is expended by previous transitions to reach the state <b>190</b>. For example, if state <b>190</b> required multiple modification operations to the search string, the costs of all these modifications are incorporated into the accumulated cost <b>196</b>. In some embodiments, the cost <b>196</b> is used to prune states at each iteration of the match process.</p><p id="p-0039" num="0038">As shown, the iterative match process may be performed using components <b>150</b> and <b>160</b>, which implement a loop body that is executed repeatedly for each next text character <b>169</b>. During each iteration, the state transitioning component <b>150</b> will update <b>155</b> a subset of states of the inferred state machine <b>180</b> that is maintained in memory. The state transitioning component <b>150</b> may generate new states for the inferred state machine <b>180</b>. The generation may be performed by inferring new states from the existing states of the inferred state machine in memory, the next text character <b>169</b>, and the string traversal graph <b>170</b>. The string traversal graph <b>170</b> is used to determine the match position <b>192</b> of newly generated states.</p><p id="p-0040" num="0039">In some embodiments, the state transitioning component <b>150</b> may also implement a pruning of states in the inferred state machine <b>180</b>. Once a state is pruned, it is no longer maintained as part of the inferred state machine <b>180</b> in memory, and subsequent iterations will not generate new states from the pruned state. In effect, the match process will abandon that particular search path for further character matching. The pruning is performed according to a set of rules, which may define pruning criteria for the states. In some embodiments, states that exceed the cost limit for the search will be pruned. In some embodiments, a state that is duplicative to another state (e.g. having the same attribute values) will be pruned. In some embodiments, a state that is inferior to another state (e.g. has a higher cost and/or lower match position) will be pruned. In some embodiments, any generated end state will be pruned, because the end state does not need to be processed during later iterations. It is noted that in some embodiments, the generation and pruning of a particular state may occur within a single iteration of the match process, so that the new state is never added to the inferred state machine <b>180</b> in memory. In other embodiments, the state transitioning component <b>150</b> will explicitly modify the set of states in memory to add the particular new state, and then explicitly remove the newly added state, all within one iteration of the match process.</p><p id="p-0041" num="0040">As shown, the character loop then proceeds to an end state evaluator <b>160</b> to examine <b>165</b> any end states that are generated during that iteration. As discussed, an end state is one where the state indicates the final position of the search string as its match position. If there are one or more end states generated, the end state evaluator <b>160</b> may check the end states to determine whether their costs are acceptable (e.g. below a cost limit for the approximate search). If so, the evaluator <b>160</b> may add that end state to a collection of acceptable end states seen during the match process. The match process will then continue to look for other (potentially cheaper) end states. On or after the last iteration of the match process, the end state evaluator <b>160</b> may examine all acceptable end states recorded, and report <b>169</b> the end state with the lowest cost as the match result along with the lowest cost. In some embodiments, if an end state with zero cost is detected by the evaluator <b>160</b>, the evaluator may report <b>169</b> the zero-cost end state immediate as the match result, and stop the match process without examining further text characters. As may be understood, a zero-cost end state is the best end state that can be achieved during the match process, and once it is generated, there is no need to look for better end states.</p><p id="p-0042" num="0041"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a block diagram illustrating a machine monitoring service implemented in a platform-as-a-service provider network that uses approximate searching, according to some embodiments.</p><p id="p-0043" num="0042">As shown, in some embodiments, approximate searching <b>252</b> as implemented using the approximate search system <b>130</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref> may be employed in a machine monitoring service <b>230</b>. In some embodiments, the machine monitoring service <b>230</b> may be implemented in the cloud and within a platform-as-a-service (PaaS) provider network. As shown, the machine monitoring service <b>230</b> may be configured to communicate with many agents <b>216</b><i>a</i>-<i>d </i>deployed on remote machines <b>214</b><i>a</i>-<i>d </i>over one or more networks <b>220</b>. In some embodiments, the agents may be configured to collect or generate machine events <b>225</b> about the remote machines, and transmit the machine events to the machine monitoring service <b>230</b>. In some embodiments, the machine monitoring service <b>230</b> may be configured to receive machine events from many different clients (e.g. different entities, companies, organizations, groups, geographic locations, networks, etc.), and perform remote monitoring of the computing resources of these different clients. In some embodiments, distinct clients <b>210</b> and <b>212</b> may be associated with a different user account of the machine monitoring service <b>230</b>.</p><p id="p-0044" num="0043">As shown, the clients in this example may own different types of computing resources, such as a workstation <b>214</b><i>a</i>, a server <b>214</b><i>b</i>, a mobile device <b>214</b><i>c</i>, and a virtual machine <b>214</b><i>d</i>. The virtual machine <b>214</b><i>d </i>may be an instance of an emulated computer and operating system that is hosted on a physical virtual machine host. The virtual machine host may implement virtualization hardware and/or software (e.g. hypervisors) to execute and manage multiple instances of guest operating systems. Example implementations of such virtualization technologies include VMWARE ESX/ESXI, MICROSOFT HYPERV, AMAZON WEB SERVICES, and MICROSOFT AZURE. As another example, another type of virtualized execution environment may be a container, which provides a portable and isolated execution environment over a host operating system of a physical host. Example implementations of container technologies include DOCKER, GOOGLE KUBERNETES, AMAZON WEB SERVICES, and MICROSOFT AZURE. Depending on the embodiment, the agents <b>216</b> may be deployed on other types of computing systems, including embedded systems, networking devices, storage devices, Internet-of-Things (IoT) devices, vehicles, and the like.</p><p id="p-0045" num="0044">In various embodiments, the network <b>220</b> may encompass any suitable combination of networking hardware and protocols necessary to establish communications between the agents <b>216</b> and the machine monitoring service <b>230</b>. In some embodiments, the remote machines <b>214</b> may execute in a private network of a company, behind a company firewall, and the network <b>220</b> may include a public network such as the Internet, which lies outside the firewall. The network <b>220</b> may encompass the different telecommunications networks and service providers that collectively implement the Internet. In some embodiments, the network <b>220</b> may also include private networks such as private local area networks (LANs), private wide area networks (WANs), or private wireless networks. The network <b>220</b> may be implemented using different hardware (e.g., modems, routers, switches, load balancers, proxy servers, etc.) and software (e.g., protocol stacks, accounting software, firewall/security software, etc.) for establishing networking links between the remote machines <b>214</b> and the machine monitoring service <b>230</b>. In some embodiments, the agents <b>216</b> may transmit the machine events <b>225</b> to the machine monitoring service <b>230</b> over the network <b>220</b> using secure communication channels such as transport layer security (TLS) connections.</p><p id="p-0046" num="0045">As shown in this example, the machine monitoring service <b>230</b> is implemented as a number of services <b>240</b>, <b>260</b>, and <b>270</b>, and a data repository <b>250</b> (which may also be a service), hosted within a PaaS service provider network. The agents <b>216</b> and other clients of the machine monitoring service <b>230</b> may convey services requests to and receive responses from PaaS provider network via network <b>220</b>. In some embodiments, the service request and responses may be web services requests and responses and formatted as JSON documents. The machine assessment service <b>230</b> may support REST-style or document-based (e.g., SOAP-based) types of web services requests. In some embodiments, the machine assessment service <b>230</b> may implement service interfaces using other types of remote procedure calling protocols, such as CORBA, GOOGLE PROTOCOL BUFFERS or PROTOBUF. The PaaS provider network may provide the hardware and/or software needed to implement service endpoints, such that a request directed to that endpoint is properly received and processed.</p><p id="p-0047" num="0046">As shown, the PaaS provider network may provide different types of computing resources <b>280</b>, which can be leased by service customers to implement custom hosted services. As shown, the PaaS provider may provide resource services such as compute resource service <b>282</b>, storage resource service <b>284</b>, networking resources service <b>286</b>, orchestration service <b>288</b>, and resource metrics service <b>289</b>. The services of the machine monitoring service <b>230</b> may be built using these underlying resource services provided by the PaaS provider. In some embodiments, the PaaS resources <b>280</b> may implement features such as load balancing of incoming service requests and/or dynamic management and scaling of service node pools. In some embodiments, each of the services <b>240</b>, <b>250</b>, <b>260</b>, and <b>270</b> may be implemented using a pool of service nodes provided by the PaaS provider, which may be individual instances of virtual machines. In some embodiments, the PaaS provider may be a provider such as AMAZON WEB SERVICES or MICROSOFT AZURE.</p><p id="p-0048" num="0047">In some embodiments, the machine monitoring service <b>230</b> may be configured to monitor, analyze, and take action on security-related incidents that are detected on the remote machines <b>214</b> or entire remote company networks. For example, the machine monitoring service <b>230</b> may be configured to monitor user emails to detect phishing attempts. As another example, the service may monitor machine processes or machine event logs to detect the presence of malware. As another example, the service may monitor user activity on remote machines to detect suspicious activity. As another example, the service may monitor inbound connections or password attempts to detect attempted attacks, compromised credentials, or network intrusions.</p><p id="p-0049" num="0048">Additionally, in some embodiments, the machine monitoring service <b>230</b> may host machine event data received about the remote machines and allow clients to view, analyze, and receive alerts and/or reports about the event data. For example, the service may allow users to run queries about the collected events for their machines. As another example, the service may provide sophisticated analysis and reporting capabilities to provide users information about their networks. As another example, the service may generate alerts to network owners when a security breach is detected. Depending on the embodiment, the machine monitoring service <b>230</b> may be configured to provide a variety of other types of monitoring, analysis, and reporting functions for its clients.</p><p id="p-0050" num="0049">As shown, in some embodiments, monitored machines events <b>225</b> may be reported by the agents <b>216</b> and received by an event collection service <b>240</b>. The event collection service <b>240</b> may be configured to normalize and preprocess the incoming event data, and store the event data in the event log repository <b>250</b>. In some embodiments, the event repository <b>250</b> may be implemented as one or more hosted database instances provided by the PaaS service provider. In some embodiments, the event data may be stored in a chronological order according to their event timestamps. In some embodiments, the stored data may be encrypted so that different clients are prevented from accessing the events of other clients. In some embodiments, the event data may be stored for a limited amount of time (e.g. one year) before it is removed.</p><p id="p-0051" num="0050">In some embodiments, the event log repository <b>250</b> may provide a query interface that allows its data records to be searched using a query language, an API, or a query. In some embodiments, the approximate search system <b>130</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref> may be implemented as component within the repository service <b>250</b> to provide approximate searching functionality <b>252</b> for queries directed to the repository. In other embodiments, the approximate search system <b>130</b> may be implemented as a client-side component external to the repository <b>250</b>.</p><p id="p-0052" num="0051">As shown, the machine monitoring service <b>230</b> may implement a set of user interfaces <b>260</b>, which may be implemented as GUIs or web interfaces viewable using a web browser. In some embodiments, these user interfaces <b>260</b> may be implemented by client-side applications. As shown, the user interfaces may include an interface to issue search queries <b>262</b>. In some embodiments, some of the functionality of the approximate search system <b>130</b> described herein may be implemented by the user interface. For example, the query interface <b>262</b> may be configured to receive or generate requests for approximate searches <b>252</b>, which may be specified in a particular query language. For example, the query language may specify to perform an approximate search by indicating a query operator or a particular function, such as &#x201c;approx(mailman, 5)&#x201d;. If the query interface <b>262</b> is a command line interface, a command parameter may be used to specify an approximate search, for example, &#x201c;search-approx mailman-maxcost 5&#x201d;. If the query interface <b>262</b> is a GUI, one or more user controls (e.g. a checkbox) may be used to specify an approximate search.</p><p id="p-0053" num="0052">In some embodiments, the user interfaces <b>260</b> may also implement a configuration interface <b>264</b>. The configuration interface <b>264</b> may be used to configure various aspects of the machine monitoring service <b>230</b>, including the query interface <b>262</b>. For example, the configuration interface <b>264</b> may be used to specify a default behavior for when approximate searches are to be performed. In some embodiments, the service may be configured to automatically perform an approximate search when results returned for an exact search returns no matches or too few matches. In some embodiments, the service may be configured to dynamically adjust the cost limit for an approximate search based on the amount of results returned for previous runs of the search. As another example, the configuration interface <b>260</b> may be used to configure parameters that control the behavior of the approximate search. In some embodiments, the configuration interface can be used to set the costs of operations used during the approximate match process. In some embodiments, the configuration interface may be used to specify the maximum cost limit for approximate searches, or a formula to dynamically determine the cost limit for approximate searches. As shown, the configuration interface <b>264</b> may be used to configure other aspects of the machine monitoring service <b>230</b>, including any approximate searching functionality used in the reporting and alert interface <b>266</b> and various components of the event data analysis service <b>270</b>.</p><p id="p-0054" num="0053">As shown, the event data analysis service <b>270</b> may also employ approximate searches <b>252</b> in its various components <b>272</b>, <b>274</b>, and <b>276</b>. For example, the malware detection module <b>272</b> may perform approximate searches in the event log repository to find machine processes that loaded a known malware executable. The approximate search <b>252</b> may be used to find variations of the malware executable name that are not yet known. As another example, a phishing detection module <b>274</b> may use approximate searches <b>252</b> to find variations of email addresses, web addresses, or email content that are associated with known phishing attacks. As yet another example, an intrusion detection module <b>276</b> may use approximate searching <b>252</b> to detect variations of a known attacker packet signature. These detected variations may be added to existing protection measures of a network (e.g. SPAM filters, firewalls, network scans, etc.) to guard against the newly detected variations.</p><p id="p-0055" num="0054"><figref idref="DRAWINGS">FIGS. <b>3</b>A and <b>3</b>B</figref> illustrate stages of a string traversal graph generated by an approximate search system for a search string, according to some embodiments. In some embodiments, the shown string traversal graph <b>310</b> may be the string traversal graph <b>170</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0056" num="0055"><figref idref="DRAWINGS">FIG. <b>3</b>A</figref> shows the string traversal graph <b>310</b> at a first stage. As shown, the traversal graph is generated for the search string &#x201c;mailman.&#x201d; The graph <b>310</b> includes eight character match positions 0 to 7, where position 0 is the first initial position and each subsequent position 1-7 corresponds to a next character in the search string. The graph <b>310</b> also includes a number of graph transitions among the match positions, which indicate how the match position changes in response to certain input characters.</p><p id="p-0057" num="0056">As discussed previously, the traversal graph <b>310</b> is generated to allow the approximate search system to determine possible next positions in the search string during an approximate match process. For example, if a state of the state machine during a match process reaches position 3, this indicates that the match process has already seen characters at positions 1 (&#x201c;M&#x201d;), 2 (&#x201c;A&#x201d;), and 3 (&#x201c;I&#x201d;). As indicated by the traversal graph <b>310</b>, if the next character in the text is an &#x201c;L,&#x201d; the new state generated for the next character can advance to position 4. However, the traversal graph at the first stage does not include failure transitions for cases when characters in the text and search string do not match.</p><p id="p-0058" num="0057"><figref idref="DRAWINGS">FIG. <b>3</b>B</figref> shows the string traversal graph <b>310</b> at a second stage. At this stage, two failure transitions <b>320</b> and <b>325</b> have been added to the traversal graph. A failure transition indicates a next possible search string position when there is a mismatch of the next text character to the current search string position. In most cases, the only possible failure transition will point back to position 0 (as shown by graph transition <b>320</b>), indicating to start the matching process from beginning of the search string. However, in some cases, a more limited failure transition may be added that points back to some position after position 0. This can occur when some portion of the text including the newly seen character can be matched to a shorter beginning portion of the search string. For example, failure transition <b>325</b> can be added at position 6, where the match process has seen &#x201c;MAILMA.&#x201d; If the next character is an &#x201c;I,&#x201d; a valid graph transition can occur from position 6 to position 3. This is because a portion of the text, including the next character &#x201c;I,&#x201d; matches a shorter beginning portion of the search string (&#x201c;MAI&#x201d;). In this case, the match process can pick up the match process from position 3 for subsequent characters in the text.</p><p id="p-0059" num="0058">As may be understood, in practice, all possible failure transitions may be generated for every position in the search string. The fully generated traversal graph may be retained in memory and used by the approximate match process to easily determine next match positions for newly generated states.</p><p id="p-0060" num="0059"><figref idref="DRAWINGS">FIGS. <b>4</b>A to <b>4</b>D</figref> illustrate different types of states transitions that can occur during an approximate match process of a search string and a text, according to some embodiments. In some embodiments, the states shown in these figures may be the states of the inferred state machine <b>180</b>, as discussed in connection with <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0061" num="0060"><figref idref="DRAWINGS">FIG. <b>4</b>A</figref> shows a first type of state transition that can occur when there is character mismatch between a next character in the text and the next match position in the search string. In this case, there is a failure transition indicated in the string traversal graph (e.g. traversal graph <b>310</b> of <figref idref="DRAWINGS">FIG. <b>3</b></figref>) for the next character. The example in <figref idref="DRAWINGS">FIG. <b>4</b>A</figref> follows the failure transition example discussed in <figref idref="DRAWINGS">FIG. <b>3</b>B</figref>. As shown, at previous state <b>410</b>, the approximate match process has seen &#x201c;MAILMA,&#x201d; which puts the match position of the previous state at position 6. However, the next text character is I, which prevents a new state to be generated for position 7. However, because there is a failure transition in the traversal graph pointing to position 3, a new state <b>420</b> is generated with match position 3, as shown. As a result, approximate match process can generate the new state <b>420</b> via state transition <b>415</b> according to the failure transition of the traversal graph.</p><p id="p-0062" num="0061">As shown, the states <b>410</b> and <b>420</b> also include other attributes such as last operation a cost. In this example, the last operation of both states is ACCEPT, which means that the state resulted from a matched character between the text and the search string. In this example, both states indicate a cost of 0, which means that no modifications (e.g. SUB, INS, or DEL) have been performed on the search string to reach these states.</p><p id="p-0063" num="0062"><figref idref="DRAWINGS">FIG. <b>4</b>B</figref> shows another type of state transition that can occur when there is character mismatch between a next character in the text and the next match position in the search string. This case illustrates a SUB operation <b>432</b> performed at a state transition, where the newly generated state <b>440</b> results from a substation of a character in the search string. As shown, when this occurs, the match position is advanced in the new state <b>440</b> to skip over the mismatched character in the search string. However, the cost of the new state <b>440</b> is incremented by a SUB cost, here <b>5</b>. This accumulated cost will be retained by all subsequent states generated from new state <b>440</b>.</p><p id="p-0064" num="0063">Additionally, as shown, the last operation of the new state <b>440</b> is specified to be SUB. This last operation indicator, which may be referred to as a state &#x201c;type&#x201d; of the new state <b>440</b>, indicates the type of operation (ACCEPT, SUB, INS, or DEL) that was performed on the search string at the last transition to the state. In some embodiments, this last operation attribute is used to constrain what new states can be generated from a parent state. As shown in this example, the approximate search system may implement a rule <b>434</b>, which only allows SUB type states to be generated when the previous state <b>430</b> is of type ACCEPT or SUB. In this case, since the previous state is an ACCEPT state, new SUB state <b>440</b> can be generated. As may be understood, the rule is imposed so that SUB states can never be generated from an INS or DEL state. Thus, in this example, any deviation sequence in the text from the search string must begin with a SUB operation, or not include a SUB operation at all. As discussed, this rule <b>434</b> may be implemented in some embodiments to limit the matching sequence in the text to a pattern (X SUB*(INS*|DEL*))*. Among other benefits, these rules reduce the search space for finding approximate matches, and reduce the amount of memory and processing power needed to perform approximate searches.</p><p id="p-0065" num="0064"><figref idref="DRAWINGS">FIG. <b>4</b>C</figref> shows another type of state transition that can occur when there is character mismatch between a next character in the text and the next match position in the search string. This case illustrates an INS operation <b>452</b> performed at a state transition, where a new state <b>460</b> is generated from a previous state <b>450</b> as a result of an insertion of a character in the search string. As shown, as a result of this transition, the match position of the new state <b>460</b> remains the same as the previous state <b>450</b> because the match process still has not seen the string character at the next match position. However, the text character is consumed. As shown, the new state <b>460</b> will also specify its last operation as INS, and add an INS cost (e.g. <b>2</b>) to its accumulated cost.</p><p id="p-0066" num="0065">As with the SUB operations, in some embodiments, generation of an INS state may be limited by a rule <b>454</b> based on the state type of the previous state <b>450</b>. In some embodiments, an INS state can be generated if the previous state <b>450</b> is an ACCEPT, SUB, or INS state. Accordingly, the approximate match process will never attempt to generate a match sequence that performs an INS operation after a DEL operation.</p><p id="p-0067" num="0066"><figref idref="DRAWINGS">FIG. <b>4</b>D</figref> shows yet another type of state transition that can occur when there is character mismatch between a next character in the text and the next match position in the search string. This case illustrates a number of DEL operations, including operations <b>472</b> and <b>482</b>, performed at a sequence of state transitions. As shown, each DEL operation generates a new state (e.g. state <b>480</b>) from a previous state (e.g. state <b>470</b>), and each new state with DEL as last operation (a DEL state) will increment the match position (because a character in the search string is consumed by the DEL operation), and add a cost of DEL operation (e.g. <b>2</b>) to the accumulated cost. It is noted that in some embodiments, the sequence of DEL operations may be represented as one state that results from a single DEL operation that deletes multiple characters from the search string. The DEL operations will delete all characters in the search string after the match position of the previous state <b>470</b> until a match for the next text character is found. In some embodiments, the match process will then generate an additional ACCEPT state (e.g. state <b>490</b>) via an ACCEPT transition <b>492</b>, to match the text character with the matching character in the search string. Depending the cost that is spent to perform the DEL operations, the generated DEL states may be retained for a next iteration for further matching, or pruned so that it is abandoned by the match process.</p><p id="p-0068" num="0067">As shown, with the SUB and INS operations, in some embodiments, generation of a DEL state may be limited a rule <b>474</b> based on the state type of the previous state <b>470</b>. In some embodiments, a DEL state can be generated if the previous state <b>470</b> is an ACCEPT, SUB, or DEL state. Accordingly, the approximate match process will never attempt to generate a match sequence that performs a DEL operation after an INS operation.</p><p id="p-0069" num="0068"><figref idref="DRAWINGS">FIGS. <b>5</b>A to <b>5</b>D</figref> illustrate different types of conditions for pruning states during an approximate match process of a search string and a text, according to some embodiments. In some embodiments, the states shown in these figures may be the states of the inferred state machine <b>180</b>, as discussed in connection with <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0070" num="0069"><figref idref="DRAWINGS">FIG. <b>5</b>A</figref> shows one type of state pruning that can be made during an approximate match process, for example, by the state transitioning component <b>150</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. In this example, a new state <b>512</b> is generated from a previous state <b>510</b>. The new state <b>512</b> advances the match position, but also adds to the accumulated cost of the match due to a modification operation performed on the search string (a SUB operation). In this case, the new cost exceeds a cost limit <b>520</b> for the search. In some embodiments, when this occurs, the new state <b>512</b> will be pruned <b>522</b>, so that no further matching will occur on this match path. Depending on the embodiment, the pruning can occur immediately, in the iteration that the new state is generated, or in a subsequent iteration after the generation iteration. In some embodiments, as the match process proceeds, older states from previous iterations are systematically pruned based on other pruning criterion, as will be discussed below.</p><p id="p-0071" num="0070">Depending on the embodiment, the cost limit <b>520</b> may be obtained in a variety of ways. In some embodiments, the maximum cost limit may be a user-specified value, either as an input parameter specified in the approximate search request, or as a configuration parameter for the approximate search system in general. In some embodiments, the approximate search system may be configured to automatically or programmatically determine the maximum cost limit. For example, the cost limit may be determined based on the length of the search string (e.g. based on a function of the length), so that shorter search strings can tolerate less character deviations. In some embodiments, the cost limit may be determined based on the length of the text record. In some embodiments, the cost limit may be determined based on the size of the text dataset, so that searches on larger datasets may require more precise matching. In some embodiments, the cost limit may depend on the type of text records or search term used in the approximate search. For example, searches performed on text records in a particular language where the average word length is longer (e.g. German) may tolerate larger amounts of deviations. In some embodiments where a particular approximate search is performed repeatedly (e.g. as part of a periodic data scan), the cost limit may be automatically tuned based on the amount of results that are returned by previous searches. Depending on the embodiment, any combination of these factors may be used in a formula or a rule set to calculate the cost limit for a particular search.</p><p id="p-0072" num="0071"><figref idref="DRAWINGS">FIG. <b>5</b>B</figref> shows another type of state pruning that can be performed during an approximate match process. In this example, two duplicate state <b>530</b> and <b>532</b> are generated for the inferred state machine in memory. The two duplicate state have the same state attributes (e.g. the same values for their respective match positions, last operations, and costs). In some embodiments, when this situation occurs, one of the two duplicate state (here state <b>534</b>) will be pruned <b>534</b>. As may be understood, there is no reason maintain two duplicate states because they will generate the same match paths in subsequent iterations of the match process. In some embodiments, the two duplicate states may have been generated in different iterations.</p><p id="p-0073" num="0072"><figref idref="DRAWINGS">FIG. <b>5</b>C</figref> shows another type of state pruning that can be performed during an approximate match process. In this example, a most costly state <b>546</b> is detected with respect to another state <b>542</b> of the state machine. As shown, the less costly state is a DEL state <b>542</b> that has reached the same match position as the more costly SUB state <b>546</b>, but with less cost. In some embodiments, the more costly state <b>546</b> will be pruned <b>548</b>. In some embodiments, a state will be deemed to be more costly when its position is equal to or greater than another state, and its cost is greater than the other state.</p><p id="p-0074" num="0073"><figref idref="DRAWINGS">FIG. <b>5</b>D</figref> shows two additional types of state pruning that can be performed during an approximate match process. In this example, state <b>550</b> is an end state. As shown, this state has reached a match position that is the final position of the search string. In some embodiments, all end states are pruned <b>560</b> by the approximate match process, because they will not be processed any further in subsequent iterations of the match process. However, in some embodiments, the match process may retain some information about all of the end states that are found, so that at the end of the match process, the search system may compare all of the end state to select a best (e.g. lowest cost) end state to report as the match result. In some embodiments, this tracking of end states may be performed by the end state evaluator <b>160</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0075" num="0074">Additionally, in this example, state <b>552</b> is determined to be an inferior state to the end state <b>550</b>. In particular, state <b>552</b> has not yet reached the final position of the search string, but has already accumulated a cost that is equal to the end state <b>550</b>. In some embodiments, a state will be deemed to be inferior to an end state if it not itself an end state, and has a cost that is equal to or greater than an end state. In some embodiments, these types of inferior states will be pruned <b>554</b> by the match process, as shown. It is noted that the pruning criteria discussed in connection with <figref idref="DRAWINGS">FIGS. <b>5</b>A to <b>5</b>D</figref> may vary depending on the embodiment. In some embodiments, the pruning criteria used by the approximate search system may be configurable via a configuration interface, such as the configuration interface <b>264</b> of <figref idref="DRAWINGS">FIG. <b>2</b></figref>.</p><p id="p-0076" num="0075"><figref idref="DRAWINGS">FIG. <b>6</b></figref> illustrates an example user interface used to configure parameters of an approximate search system, according to some embodiments. In some embodiments, the configuration interface <b>600</b> shown in the figure may be a part of the configuration interface <b>264</b> of <figref idref="DRAWINGS">FIG. <b>2</b></figref>.</p><p id="p-0077" num="0076">As shown, the configuration interface <b>600</b> is a graphical user interface that allows a user to configure the behavior for an approximate search system. In some embodiments, this GUI may be provided as a web interface, which may be provided as a webpage by a web server and displayed on a web browser.</p><p id="p-0078" num="0077">In this example, the GUI <b>600</b> provides a section <b>610</b>, which allows a user to specify the costs that are used during the approximate match process for text records. The user may specify costs for the different types of character deviations that can be tolerated from the search string during the approximate search. These character deviations may correspond to the character modification operations that are performed by state transitions during the approximate match process. In this example, the GUI <b>600</b> also allows the user to specify a formula or function to calculate the total cost of an approximate match. In some embodiments, the user may specify a set of rules (e.g. rules with if-then logic) to determine the cost of an approximate match. In some embodiments, the configuration interface may place certain constraints on the configuration settings, for example, to limit the cost of a SUB deviation to be no more than the sum of the costs of an INS and a DEL deviation.</p><p id="p-0079" num="0078">As shown, the GUI <b>600</b> also provides a section <b>620</b> that allows the users to configure how the cost limit of the approximate search is determined. In this example, the GUI allows the user to a static default cost limit, which may be overridden by an explicit cost limit specified with particular search requests. In this example, the GUI also allows the user to specify one or more rules to programmatically compute the cost limit of approximate searches. In this case, the cost limit is calculated based on the length of the search term, so that a search term of 10 letters will have a cost limit of no more than 8.</p><p id="p-0080" num="0079">As shown, the GUI <b>600</b> may also provide other configuration settings under section <b>630</b>, which may allow the user to control additional aspects of approximate searches. In this example, the user has specified that an approximate match result must match the search string on the first two characters. Under this configuration, the approximate match system may not allow any character modification states (e.g. SUB, INS, or DEL states) to be generated for the first two characters of the search string, which significantly reduces the search space needed for text records.</p><p id="p-0081" num="0080"><figref idref="DRAWINGS">FIGS. <b>7</b>A to <b>7</b>C</figref> illustrate different user interfaces for invoking and viewing results of an approximate search, according to some embodiments. In some embodiments, these interfaces may be implemented as parts of the search query interface <b>262</b>, as discussed in connection with <figref idref="DRAWINGS">FIG. <b>2</b></figref>.</p><p id="p-0082" num="0081"><figref idref="DRAWINGS">FIG. <b>7</b>A</figref> shows a search records interface <b>700</b> which, like the configuration interface <b>600</b> of <figref idref="DRAWINGS">FIG. <b>6</b></figref>, is a graphical interface and can be provided as a web interface, in some embodiments. As shown, the GUI <b>700</b> allows users to perform search terms in records of emails. The user can specify to user approximate searching to perform the search by checking the checkbox <b>715</b>. The GUI may also provide a user control (e.g. a text field or a number selection control) to specify the cost limit for the approximate search. In this case, the user has indicated an exact search for the search term &#x201c;phishing@website23.com,&#x201d; without using approximate search. The results of the exact search are indicated in the search results section <b>720</b>. As shown, the exact search returned only one result.</p><p id="p-0083" num="0082">As shown, when the exact search results are displayed, the GUI <b>700</b> may asks <b>730</b> the user whether the search should be performed again using approximate searching. The GUI may provide a search button to perform the approximate searching based on a user-specified cost limit. In some embodiments, the option <b>730</b> to perform the approximate search may be triggered based on results returned by the exact search. For example, if the exact search returned no results or only a small number of results that is below a threshold, the option for approximate searching may be presented. In some embodiments, the option for approximate searching may be provided when the number of returned results is below a fraction of the number of searched records.</p><p id="p-0084" num="0083"><figref idref="DRAWINGS">FIG. <b>7</b>B</figref> shows another search records interface <b>740</b>. In this example, the GUI <b>740</b> is used to search through event records of computers for a particular executable name. For example, an event may be generated when a process is launched on a computer. The captured event record may indicate the executable that is loaded into memory for the process. In this case, the search specifies to search <b>750</b> for the executable name &#x201c;svchost.exe.&#x201d; As shown in the results section <b>760</b>, only one result is found in the event records.</p><p id="p-0085" num="0084">As shown, with the search records, the GUI <b>740</b> further provides an option <b>770</b> to show additional results that were found using an approximate search of the same search term. In some embodiments, the approximate search is automatically performed along with the exact search, so that approximate match results are generated for viewing along with the exact search results. In this example, if the user clicks on the show button, the GUI <b>740</b> will be updated to display the approximate match results, as shown in <figref idref="DRAWINGS">FIG. <b>7</b>C</figref>.</p><p id="p-0086" num="0085">As shown in <figref idref="DRAWINGS">FIG. <b>7</b>C</figref>, three additional approximate match results <b>780</b> of the search term are provided in the results section <b>760</b>. The approximate search results may be provided in a sorted order according to their respective match costs, which may indicate how far they deviate from the specified search term. In some embodiments, the search results section <b>760</b> may include a user control to allow the user to adjust a cost limit that limits how many approximate search results are displayed.</p><p id="p-0087" num="0086"><figref idref="DRAWINGS">FIG. <b>8</b></figref> illustrates an input data scanner that outputs approximate matches of search terms to be added to a library of search terms, according to some embodiments.</p><p id="p-0088" num="0087">As shown, the figure depicts an input data scanner <b>820</b> configured to consume an input stream <b>810</b> of data records. In some embodiments, this input stream may be a stream of event records generated by agents (e.g. the agents <b>216</b> of <figref idref="DRAWINGS">FIG. <b>2</b></figref>), and the input scanner <b>820</b> may implement one or more functions of the event data analysis service <b>270</b> of <figref idref="DRAWINGS">FIG. <b>2</b></figref>. As shown, the input data scanner <b>820</b> may implement an exact search module <b>822</b>. The exact search module <b>822</b> may use exact searching to search for a set of search terms <b>825</b>, which may be obtained from a search term repository <b>830</b>. For example, the exact search module <b>822</b> may be configured to search for a list of malware executable names, or blacklisted URLs or email addresses, etc. Any detected matches from the exact search is output as periodic scan results <b>840</b>.</p><p id="p-0089" num="0088">Additionally, the input data scanner <b>820</b> in this example also implements an approximate search module <b>824</b>, which may be an embodiment of the approximate search system <b>130</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. The approximate search module <b>824</b> may be executed along with the exact search module <b>822</b> to detect any approximate matches of the search terms <b>850</b> in the input data stream <b>810</b>. For example, the approximate matches may indicate one or more variations of the known malware executable names or blacklisted URLs or email addresses found in the input data stream. These variations may represent an attempt by attackers to vary these names or identifiers to avoid detection. As shown, these approximate matches of the search terms <b>850</b> may be provided to a review interface <b>860</b> to be reviewed by an administrator <b>870</b>. The administrator <b>870</b> may then add selected approximate matches <b>865</b> to the search term library <b>830</b>, to augment the set of search terms to search for in future scans. In this manner, the input data scanner <b>820</b> can be quickly adapted to minor changes in names or identifiers employed by the attackers.</p><p id="p-0090" num="0089"><figref idref="DRAWINGS">FIGS. <b>9</b>A to <b>9</b>C</figref> are flowcharts illustrating aspects of an approximate search process performed by an approximate search system, according to some embodiments. In some embodiments, the processes shown in these figures may be performed by the approximate search system <b>130</b>, as discussed in connection with <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0091" num="0090">The process of <figref idref="DRAWINGS">FIG. <b>9</b>A</figref> begins with operation <b>910</b>, where a request to perform an approximate search of a string with a text set. The request may be received via an interface, such as the search query interface <b>262</b> of <figref idref="DRAWINGS">FIG. <b>2</b></figref>. In some embodiments, the request may be a query specified in a query language, which may include an indication (e.g. &#x201c;approx(mailman, 2)&#x201d;) that indicates to perform an approximate search. In some embodiments, the request may be a user request received via an interactive interface such as a GUI or a command line tool. In some embodiments, the request may be a programmatic request received from another software component. The request may include input parameters that the search string (e.g. search string <b>114</b>) to be used for the approximate search, and the text set (e.g. text dataset <b>112</b>) to be searched. In some embodiments, the request may also indicate search parameters such as a cost limit to be used for the approximate search. In some embodiments, the cost limit may be programmatically determined based on the length of the search string or the size of the text set.</p><p id="p-0092" num="0091">In some embodiments, the text set may include a large number of text records to be searched. The text records may be logged events generated by remote machines, which may include searchable text fields such as URLs, other types of web addresses, email addresses, executable names, usernames, passwords, among other types of data. Depending on the embodiment, the text records may be stored in a data repository or a text file, or received from another computing system in a stream.</p><p id="p-0093" num="0092">As shown, operations <b>921</b> to <b>926</b> in the depicted process is performed as part of an approximate match process <b>920</b>, which may be performed for each individual text record in the text set. At operation <b>921</b>, a string traversal graph is generated for the string. This string traversal graph may be the string traversal graph <b>170</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, or graphs <b>310</b> and <b>320</b> of <figref idref="DRAWINGS">FIGS. <b>3</b>A and <b>3</b>B</figref>. The generated string traversal graph may be implemented as a data structure (e.g. an array of indexes), and specify one match position per character in the string. The graph may also indicate graph transitions among the match positions based on input characters. In some embodiments, the graph transitions may include failure transitions (e.g. transition <b>320</b> and <b>325</b>), which transitions backward to a position before the current match position. As discussed, the traversal graph will be used to infer a state machine to carry out the approximate match process for individual text records, and may be reused for multiple text records.</p><p id="p-0094" num="0093">At operation <b>922</b>, a subset of states of the inferred state machine is maintained in a computer memory (e.g. on the computer that implements the approximate search system). The state machine is inferred from the string traversal graph and may contain states that include attributes such as (a) a match position in the string traversal graph, (b) a last operation (e.g. an ACCEPT, SUB, INS, or DEL operation) performed at a last transition to the state, and (c) a cost accumulated for previous operations performed on the string to arrive at the state. The states may include, for example, attributes of the machine state <b>190</b> as discussed in connection with <figref idref="DRAWINGS">FIG. <b>1</b></figref>. As shown, other operations of the approximate match process <b>920</b> are performed iteratively for successive characters for the individual text records being matched to the search string.</p><p id="p-0095" num="0094">At operation <b>923</b>, the subset of states in memory are modified for each individual text character. The modification of the in-memory states may be performed by, for example, the state transitioning component <b>150</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. The modification may include adding or generating new states in the subset, or pruning existing states from the subset, or both. New states are generated based on previous states in the subset and the next character in the text. The match position of the new state may be determined based on a string traversal graph constructed for the search string (e.g. traversal graph <b>170</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>). The newly generated states may include modification operations performed on the search string when the text character does not match the search string character at the current match position. These types of states (e.g. SUB, INS, and DEL type states) are discussed in connection with <figref idref="DRAWINGS">FIGS. <b>4</b>B to <b>4</b>D</figref>.</p><p id="p-0096" num="0095">In some embodiments, in-memory states may be pruned based on a number of pruning criteria, as discussed in connection with <figref idref="DRAWINGS">FIGS. <b>5</b>A to <b>5</b>D</figref>. Pruning a state may remove the state from the computer memory, so that the pruned state can no longer be used to generate further states of a match path in subsequent iterations. The pruning rules or criteria may be specified so that states that are duplicative, too costly, or otherwise inferior to other seen states are abandoned by the matching process. In some embodiments, end states that reach the final match position of the search string are also pruned. By pruning states of the state machine in this fashion, the approximate match process avoids having to construct the full states machine in memory, which is impractical for most current computer systems. The pruning process generally reduces memory usage and processing power usage, and improves the speed and overall performance of the approximate search.</p><p id="p-0097" num="0096">At operation <b>924</b>, a determination is made whether a match process has reached an end state with an acceptable cost. An end state may be deemed a state that has a match position at the final position of the search string. An acceptable cost may be a cost that does not exceed cost limit of the search. In some embodiments, the determination of operation <b>924</b> may be performed by the end state evaluator <b>160</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. As shown, in some embodiments, if the cost of an end state is zero (e.g. because no modifications were performed on the search string for the match), the match process may terminate and proceed directly to operation <b>926</b> to output the zero-cost end state a match. However, if the end state is not a zero-cost end state, the end state evaluator may track it as one possible end state for approximate match process, and continue with the match process to find other potentially better end states.</p><p id="p-0098" num="0097">At operation <b>925</b>, a determination is made whether there are any further characters remaining in the text record being examined. If so, the match process continues to the next character. If not, the match process is at an end, and proceeds to operation <b>926</b>.</p><p id="p-0099" num="0098">At operation <b>926</b>, an output is generated for the approximate match process. If there were not acceptable end states found during the match process, no match will be reported. However, if there was at least one end state found during the match process, an end state with the lowest match cost will be reported as the approximate match. In some embodiments, the output may also include the lowest match cost.</p><p id="p-0100" num="0099">At operation <b>930</b>, after the approximate match process is performed on all text records in the text set, the approximate match results of the search string are outputted. The output may be provided via an interface such as the search query interface <b>262</b> of <figref idref="DRAWINGS">FIG. <b>2</b></figref>, or the GUIs <b>700</b> and <b>740</b> shown in <figref idref="DRAWINGS">FIGS. <b>7</b>A to <b>7</b>C</figref>. In some embodiments, the results may be provided in a sorted order, ordered according to the respective costs of the approximate matches. In some embodiments, these costs may represent a quantitative measure of how close each approximate match is, and sorting the results in this fashion allows users to easily see the relative closeness of individual approximate match results.</p><p id="p-0101" num="0100"><figref idref="DRAWINGS">FIG. <b>9</b>B</figref> illustrates a process of generating new states during an approximate match process, as discussed in connection with <figref idref="DRAWINGS">FIG. <b>9</b>A</figref>. In some embodiments, the illustrated operations in this figure may be performed as part of operation <b>923</b> of <figref idref="DRAWINGS">FIG. <b>9</b>A</figref>.</p><p id="p-0102" num="0101">At operation <b>940</b>, a determination is made whether a next text character in an individual text record matches a next string character in the search string. The next text character is an individual character in the text record being examined in an iteration of the approximate match process, and the next string character is the character in the search string at the current match position for the iteration.</p><p id="p-0103" num="0102">If the text character matches the search string character, the approximate match process proceeds to operation <b>942</b>, where an ACCEPT state is to advance the match position with no added cost. In some embodiments, this may be the only new state generated in the iteration if there is a match of the text character and the string character. However, if the text character and the search character do not match, a number of other new states may be generated.</p><p id="p-0104" num="0103">At operation <b>944</b>, an ACCEPT state is generated with a lower match position than the match position of the previous state in the state machine. The generation of this type of ACCEPT state is discussed in connection with <figref idref="DRAWINGS">FIG. <b>4</b>A</figref>. As discussed, in some embodiments, the approximate match process may revert back to an earlier position in the search string to continue to match process. The lower match position of the new ACCEPT state will indicate the longest beginning portion of the search string that matches a portion of the text record ending in the next text character. No additional costs will be added for this type of ACCEPT state. The process then proceeds to operation <b>950</b> to generate one or more modification states that modify the search string.</p><p id="p-0105" num="0104">At operation <b>950</b>, a determination is made whether the preceding state is and ACCEPT or SUB state. If so, in this example, the process proceeds to operations <b>952</b> and <b>954</b> to generate a new SUB state and a sequence of one or more DEL states, as discussed in connection with <figref idref="DRAWINGS">FIGS. <b>4</b>B and <b>4</b>D</figref>. The SUB and DEL states will represent two different match paths for match process going forward. As discussed, in some embodiments, the generation of new string modification states may be constrained by the type of their parent state. In some embodiments, the approximate match process may be constrained to generated, in a single sequence of modifications, all SUB states (if any) before all INS and DEL states (if any). Moreover, the approximate match process may implement rules to generate either INS or DEL states in a single modification sequence, but not both. Accordingly, a SUB state at operation <b>952</b> is only generated if the preceding state is an ACCEPT state or SUB state (and not an INS or DEL state), and the sequence of DEL states at operation <b>954</b> is only generated if the preceding state is an ACCEPT state or SUB state (and not an INS state).</p><p id="p-0106" num="0105">At operation <b>952</b>, the new SUB state is generated from the preceding state. In some embodiments, the SUB state will the next character in the search string with the text character, and add a substitution cost. This operation may be performed in similar fashion as discussed in connection with <figref idref="DRAWINGS">FIG. <b>4</b>B</figref>.</p><p id="p-0107" num="0106">At operation <b>954</b>, the sequence of DEL states is generated from the preceding state. In some embodiments, the DEL states will delete one or more characters from the search string staring at the current match position until a string character that matches the text character. The DEL state(s) will each increment the match position from its preceding state, and add a deletion cost to the state. If there is a matching string character at the end of the sequence of DEL states, a last ACCEPT state may be generated to consume that string character. If there is no matching string character at the end of the DEL states (e.g. if the DEL sequences deletes all remaining characters of the search string), there will be no ACCEPT state. In that case, the last DEL state in the sequence will be an end state.</p><p id="p-0108" num="0107">At operation <b>960</b>, a determination is made whether the preceding states is an INS state. If so, (that is, if the preceding state is an ACCEPT, SUB, or INS state), the process proceeds to operation <b>962</b> to generate a new insert state from the preceding state, which represents yet another different match path from the preceding state.</p><p id="p-0109" num="0108">At operation <b>962</b>, the new INS state is generated from the preceding state. The INS state will insert the text character to the search string before the current match position, not advance the match position, and add an insertion cost to the cost of the new INS state. In some embodiments, the generation of the INS state will be performed in similar fashion as discussed in connection with <figref idref="DRAWINGS">FIG. <b>4</b>C</figref>. As discussed, some of these newly generated states may be immediately pruned based on various pruning rules, and the approximate match process will continue with the remaining states into the next iteration to generate additional states.</p><p id="p-0110" num="0109"><figref idref="DRAWINGS">FIG. <b>9</b>C</figref> illustrates a process of pruning machine states during an approximate match process, as discussed in connection with <figref idref="DRAWINGS">FIG. <b>9</b>A</figref>. In some embodiments, the illustrated operations in this figure may be performed as part of operation <b>923</b> of <figref idref="DRAWINGS">FIG. <b>9</b>A</figref>.</p><p id="p-0111" num="0110">At operation <b>970</b>, an examination is made of an existing state in the in-memory states of the inferred state machine during the approximate match process of a text record and a search string. The existing state may be a state that has been just generated in the current iteration or an older state that was generated in an earlier iteration.</p><p id="p-0112" num="0111">At operation <b>980</b>, a determination is made whether the existing state is a duplicate of another state generated for the state machine. If so, one of the duplicate states (e.g. the existing state) is pruned at operation <b>992</b>. In some cases, the other duplicate state may be a state that has already been pruned previously. However, because a duplicate state has already been seen by the match process, there is no reason to re-explore the match path twice. The pruning criterion of this operation is discussed previously in connection with <figref idref="DRAWINGS">FIG. <b>5</b>B</figref>.</p><p id="p-0113" num="0112">At operation <b>982</b>, a determination is made whether the existing state is an end state. In some embodiments, an end state may be a state having a match position that is at the final position of the search string. If the existing state is an end state, it will be pruned, because there is no further exploration that needs to be done for the end state in subsequent iterations. This pruning criterion is discussed previously in connection with <figref idref="DRAWINGS">FIG. <b>5</b>D</figref>.</p><p id="p-0114" num="0113">At operation <b>984</b>, a determination is made whether the existing state has a cost that exceeds a cost limit. The cost limit may be a limit that was explicitly indicated in the search request or by a configuration setting, or computed based on factors such as the length of the search string or the size of the text dataset. If the existing state has a cost that is greater than the cost limit, in some embodiments, the state will be immediately pruned because it cannot lead to an end state with acceptable cost. This pruning criterion is discussed previously in connection with <figref idref="DRAWINGS">FIG. <b>5</b>A</figref>.</p><p id="p-0115" num="0114">At operation <b>986</b>, a determination is made whether the existing state has a cost that is greater than or equal to another state, but a match position that is less than the other state. In some embodiments, the other state may be a state that was previously seen by the match process, but one that has already been pruned. In some embodiments, the other state must be a &#x201c;live&#x201d; state that is currently maintained in memory. If this condition is satisfied, the existing state may be deemed to be an inferior state to the other state, and pruned from state machine. This pruning criterion is discussed previously in connection with <figref idref="DRAWINGS">FIG. <b>5</b>C</figref>.</p><p id="p-0116" num="0115">At operation <b>988</b>, a determination is made whether the existing state has a cost that is greater than or equal an end state seen by the match process, where the existing state is not itself be an end state. In some embodiments, this condition indicates that the existing state cannot achieve a better match (e.g. lower cost match) than the end state, and the existing will be pruned for this reason. This pruning criterion is discussed previously in connection with <figref idref="DRAWINGS">FIG. <b>5</b>D</figref>.</p><p id="p-0117" num="0116">If any of the pruning criteria discussed previously applies to the existing state, the existing state will be pruned at operation <b>992</b>, where it is removed from the in-memory state machine so that no subsequent states will be generated from the pruned state. In effect, the match process will abandon the match path ending in the pruned state. At the next iteration of match process, new states from be generated from the surviving states of the previous iteration.</p><p id="p-0118" num="0117"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a block diagram illustrating an example computer system that can be used to implement one or more portions of an approximate search system, according to some embodiments. For example, the computer system <b>1000</b> may be a server that implements one or more components of the approximate search system <b>130</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0119" num="0118">Computer system <b>1000</b> may be implemented using a variety of computing devices, such as a personal computer system, desktop computer, laptop or notebook computer, mainframe computer system, handheld computer, workstation, network computer, a consumer device, application server, mobile telephone, or some other type of computing device.</p><p id="p-0120" num="0119">As shown, computer system <b>1000</b> includes one or more processors <b>1010</b>, which may include multiple cores coupled to a system memory <b>1020</b> via an input/output (I/O) interface <b>1030</b>. Computer system <b>1000</b> further includes a network interface <b>1040</b> coupled to I/O interface <b>1030</b>. In some embodiments, computer system <b>1000</b> may be a uniprocessor system including one processor <b>1010</b>, or a multiprocessor system including several processors <b>1010</b><i>a</i>-<i>n</i>, as shown. The processors <b>1010</b> may be any suitable processors capable of executing instructions. For example, in various embodiments, processors <b>1010</b> may implement one of a number of instruction set architectures (ISAs), such as the x86, PowerPC, SPARC, or MIPS ISA.</p><p id="p-0121" num="0120">As shown, the computer system <b>1000</b> may also include one or more network communication devices (e.g., network interface <b>1040</b>) for communicating with other systems and/or components over a communications network. For example, an instance of an application executing on computer system <b>1000</b> may use network interface <b>1040</b> to communicate with another server application executing on another computer system, as described herein.</p><p id="p-0122" num="0121">As shown, computer system <b>1000</b> may use its network interface <b>1040</b> to communicate with one or more other devices <b>1060</b>, such as persistent storage devices and/or one or more I/O devices. In some embodiments, these some of these other devices may be implemented locally on the computer system <b>1000</b>, accessible via the I/O interface <b>1030</b>. In various embodiments, persistent storage devices may include to disk drives, tape drives, solid state memory, other mass storage devices, or any other persistent storage device. The computer system <b>1000</b> may store instructions and/or data in persistent storage devices, and retrieve the stored instruction and/or data as needed.</p><p id="p-0123" num="0122">As shown, the computer system <b>1000</b> may include one or more system memories <b>1020</b> that store instructions and data accessible by processor(s) <b>1010</b>. In various embodiments, system memories <b>1020</b> may be implemented using any suitable memory technology, (e.g., one or more of cache, static random-access memory (SRAM), DRAM, RDRAM, EDO RAM, DDR 10 RAM, synchronous dynamic RAM (SDRAM), EEPROM, non-volatile/Flash-type memory, etc.). The system memory <b>1020</b> may be used to store code <b>1025</b> or executable instructions to implement the methods and techniques described herein. For example, the executable instructions may include instructions to implement executable modules of the approximate search system <b>130</b>, as discussed. The system memory <b>1020</b> may also be used to store data <b>1026</b> needed by the executable instructions. For example, the in-memory data <b>1026</b> may include portions of the inferred state machine <b>180</b>, as discussed.</p><p id="p-0124" num="0123">In some embodiments, some of the code <b>1025</b> or executable instructions may be persistently stored on the computer system <b>1000</b> and may have been loaded from external storage media. The persistent storage of the computer system <b>1000</b> and the external media are examples of non-transitory computer-readable storage media, which may be used to store program instructions to be executed by the computer system <b>1000</b>. A non-transitory computer-readable storage medium may provide the capability to store information in a form readable by a machine (e.g., computer system <b>1000</b>). Non-transitory computer-readable media may include storage media such as magnetic or optical media, disk or DVD/CD-ROM devices, archival tapes, network-attached storage systems, or other computer systems.</p><p id="p-0125" num="0124">In some embodiments, the I/O interface <b>1030</b> may be configured to coordinate I/O traffic between processor <b>1010</b>, system memory <b>1020</b> and any peripheral devices in the system, including through network interface <b>1040</b> or other peripheral interfaces. In some embodiments, I/O interface <b>1030</b> may perform any necessary protocol, timing or other data transformations to convert data signals from one component (e.g., system memory <b>1020</b>) into a format suitable for use by another component (e.g., processor <b>1010</b>). In some embodiments, I/O interface <b>1030</b> may include support for devices attached through various types of peripheral buses, such as a variant of the Peripheral Component Interconnect (PCI) bus standard or the Universal Serial Bus (USB) standard, for example. In some embodiments, the function of I/O interface <b>1030</b> may be split into two or more separate components, such as a north bridge and a south bridge, for example. Also, in some embodiments, some or all of the functionality of I/O interface <b>1030</b>, such as an interface to system memory <b>1020</b>, may be incorporated directly into processor <b>1010</b>.</p><p id="p-0126" num="0125">In some embodiments, the network interface <b>1040</b> may allow data to be exchanged between computer system <b>1000</b> and other devices attached to a network. The network interface <b>1040</b> may also allow communication between computer system <b>1000</b> and various I/O devices and/or remote storage systems. Input/output devices may, in some embodiments, include one or more display terminals, keyboards, keypads, touchpads, scanning devices, voice or optical recognition devices, or any other devices suitable for entering or retrieving data by one or more computer systems <b>1000</b>. Multiple input/output devices may be present in computer system <b>1000</b> or may be distributed on various nodes of a distributed system that includes computer system <b>1000</b>. In some embodiments, similar input/output devices may be separate from computer system <b>1000</b> and may interact with one or more nodes of a distributed system that includes computer system <b>1000</b> through a wired or wireless connection, such as over network interface <b>1050</b>. Network interface <b>1040</b> may commonly support one or more wireless networking protocols (e.g., Wi-Fi/IEEE 802.11, or another wireless networking standard). In some embodiments, the network interface <b>1040</b> may support communication via telecommunications/telephony networks such as analog voice networks or digital fiber communications networks, via storage area networks such as Fibre Channel SANs, or via any other suitable type of network and/or protocol.</p><p id="p-0127" num="0126">Although the embodiments above have been described in considerable detail, numerous variations and modifications may become apparent to those skilled in the art once the disclosed inventive concepts are fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications, and the above description to be regarded in an illustrative rather than a restrictive sense.</p><?detailed-description description="Detailed Description" end="tail"?></description><claims id="claims"><claim id="CLM-01-20" num="01-20"><claim-text><b>1</b>.-<b>20</b>. (canceled)</claim-text></claim><claim id="CLM-00021" num="00021"><claim-text><b>21</b>. A method comprising:<claim-text>performing, by an approximate search system implemented by one or more hardware processors with associated memory:</claim-text><claim-text>receiving, via a configuration interface of the approximate search system, configuration information for executing an approximate search of a string in a text, wherein the configuration information specifies:<claim-text>(a) deviation operations permitted on the string during the approximate search,</claim-text><claim-text>(b) respective costs of the deviation operations, and</claim-text><claim-text>(c) a cost limit for the approximate search;</claim-text></claim-text><claim-text>executing the approximate search according to the configuration information, comprising:<claim-text>maintaining in memory a subset of states of a state machine generated during the approximate search, wherein individual ones of the states specify:<claim-text>(a) a match position in the string achieved at the individual state,</claim-text><claim-text>(b) a last deviation operation performed on the string to achieve the individual state, and</claim-text><claim-text>(c) a cost accumulated for any deviation operations performed on the string to achieve the individual state;</claim-text></claim-text></claim-text><claim-text>modifying the subset of states in memory for individual characters in the text, comprising:<claim-text>generating one or more new states from a preceding state of the state machine based at least in part on the individual character and a last deviation operation indicated by the preceding state, and</claim-text><claim-text>pruning one or more existing states of the state machine based at least in part on respective costs of the one or more existing states;</claim-text></claim-text><claim-text>determining an approximate match of the string in the text in response to reaching an end state of the state machine, wherein a match position of end state equals a final match position of the string, and a cost of the end state is below the cost limit for the approximate search; and</claim-text><claim-text>outputting the approximate match of the string.</claim-text></claim-text></claim><claim id="CLM-00022" num="00022"><claim-text><b>22</b>. The method of claim <b>1</b>, further comprising the approximate search system:<claim-text>generating a string traversal graph for the string, wherein the string traversal graph is used to generate the one or more new states from the preceding state of the state machine.</claim-text></claim-text></claim><claim id="CLM-00023" num="00023"><claim-text><b>23</b>. The method of claim <b>1</b>, wherein the configuration interface is configured to receive a cost function for calculating the costs accumulated in individual ones of the states.</claim-text></claim><claim id="CLM-00024" num="00024"><claim-text><b>24</b>. The method of claim <b>1</b>, wherein the cost limit is specified based at least in part on a length of the string.</claim-text></claim><claim id="CLM-00025" num="00025"><claim-text><b>25</b>. The method of claim <b>1</b>, wherein the configuration interface is configured to receive one or more rules that control execution of the approximate search, comprising:<claim-text>a rule that requires that the approximate match to match a specified number of first characters of the string;</claim-text><claim-text>a rule that permits character case to be ignored during the approximate search; or</claim-text><claim-text>a rule that permits multiple whitespaces in the text to be treated as a single whitespace during the approximate search.</claim-text></claim-text></claim><claim id="CLM-00026" num="00026"><claim-text><b>26</b>. The method of claim <b>1</b>, wherein the deviation operations comprise two or more of:<claim-text>inserting a character in the string,</claim-text><claim-text>deleting a character from the string, and</claim-text><claim-text>substituting a character in the string with another character.</claim-text></claim-text></claim><claim id="CLM-00027" num="00027"><claim-text><b>27</b>. The method of claim <b>1</b>, wherein<claim-text>the approximate search is executed in response to a search request received via a graphical user interface (GUI) of the approximate search system, and</claim-text><claim-text>the approximate match of the string is outputted via the GUI.</claim-text></claim-text></claim><claim id="CLM-00028" num="00028"><claim-text><b>28</b>. The method of claim <b>1</b>, further comprising the approximate search system:<claim-text>generating multiple end states from the approximate search; and</claim-text><claim-text>selecting one of the multiple end states as the approximate match, wherein the selected end state has a lowest cost among the multiple end states.</claim-text></claim-text></claim><claim id="CLM-00029" num="00029"><claim-text><b>29</b>. The method of claim <b>1</b>, further comprising the approximate search system:<claim-text>generating multiple end states from the approximate search; and</claim-text><claim-text>outputting the multiple end states as approximate matches for the text, wherein the multiple end states are sorted based at least in part on their respective costs.</claim-text></claim-text></claim><claim id="CLM-00030" num="00030"><claim-text><b>30</b>. The method of claim <b>1</b>, further comprising the approximate search system:<claim-text>in response to a determination that the end state indicates a cost of zero, outputting the approximate match without examining further characters in the text.</claim-text></claim-text></claim><claim id="CLM-00031" num="00031"><claim-text><b>31</b>. A system comprising:<claim-text>one or more hardware processors with associated memory that implement an approximate search system, configured to:</claim-text><claim-text>receive, via a configuration interface of the approximate search system, configuration information for executing an approximate search of a string in a text, wherein the configuration information specifies:<claim-text>(a) deviation operations permitted on the string during the approximate search,</claim-text><claim-text>(b) respective costs of the deviation operations, and</claim-text><claim-text>(c) a cost limit for the approximate search;</claim-text></claim-text><claim-text>execute the approximate search according to the configuration information, including to:<claim-text>maintain in memory a subset of states of a state machine generated during the approximate search, wherein individual ones of the states specify:<claim-text>(a) a match position in the string achieved at the individual state,</claim-text><claim-text>(b) a last deviation operation performed on the string to achieve the individual state, and</claim-text><claim-text>(c) a cost accumulated for any deviation operations performed on the string to achieve the individual state;</claim-text></claim-text></claim-text><claim-text>modify the subset of states in memory for individual characters in the text, including to:<claim-text>generate one or more new states from a preceding state of the state machine based at least in part on the individual character and a last deviation operation indicated by the preceding state, and</claim-text><claim-text>prune one or more existing states of the state machine based at least in part on respective costs of the one or more existing states;</claim-text></claim-text><claim-text>determine an approximate match of the string in the text in response to reaching an end state of the state machine, wherein a match position of end state equals a final match position of the string, and a cost of the end state is below the cost limit for the approximate search; and</claim-text><claim-text>output the approximate match of the string.</claim-text></claim-text></claim><claim id="CLM-00032" num="00032"><claim-text><b>32</b>. The system of claim <b>11</b>, wherein the configuration interface is configured to receive a cost function for calculating the costs accumulated in individual ones of the states.</claim-text></claim><claim id="CLM-00033" num="00033"><claim-text><b>33</b>. The system of claim <b>11</b>, wherein the cost limit is specified based at least in part on a length of the string.</claim-text></claim><claim id="CLM-00034" num="00034"><claim-text><b>34</b>. The system of claim <b>11</b>, wherein the configuration interface is configured to receive one or more rules that control execution of the approximate search, comprising:<claim-text>a rule that requires that the approximate match to match a specified number of first characters of the string;</claim-text><claim-text>a rule that permits character case to be ignored during the approximate search; or</claim-text><claim-text>a rule that permits multiple whitespaces in the text to be treated as a single whitespace during the approximate search.</claim-text></claim-text></claim><claim id="CLM-00035" num="00035"><claim-text><b>35</b>. The system of claim <b>11</b>, wherein the deviation operations comprises two or more of:<claim-text>inserting a character in the string,</claim-text><claim-text>deleting a character from the string, and</claim-text><claim-text>substituting a character in the string with another character.</claim-text></claim-text></claim><claim id="CLM-00036" num="00036"><claim-text><b>36</b>. The system of claim <b>11</b>, wherein<claim-text>the approximate search is executed in response to a search request received via a graphical user interface (GUI) of the approximate search system, and</claim-text><claim-text>the approximate match of the string is outputted via the GUI.</claim-text></claim-text></claim><claim id="CLM-00037" num="00037"><claim-text><b>37</b>. The system of claim <b>16</b>, wherein the approximate search system is configured to:<claim-text>output exact matches of the string in the text via the GUI,</claim-text><claim-text>determine that a number of the exact matches falls below a threshold, and</claim-text><claim-text>provide an option on the GUI to search for the string again using the approximate search.</claim-text></claim-text></claim><claim id="CLM-00038" num="00038"><claim-text><b>38</b>. The system of claim <b>11</b>, wherein the approximate string search system is configured to:<claim-text>scan event records captured from a group of computers; and</claim-text><claim-text>wherein the approximate search is used to scan the event records for one of more types of text fields, including one or more of:<claim-text>(a) an executable name,</claim-text><claim-text>(b) an email address,</claim-text><claim-text>(c) a web address, and</claim-text><claim-text>(d) a user name.</claim-text></claim-text></claim-text></claim><claim id="CLM-00039" num="00039"><claim-text><b>39</b>. The system of claim <b>18</b>, the approximate string search system is configured to:<claim-text>store the string as a search term in a library, wherein search terms in the library are used to scan the event records; and</claim-text><claim-text>add the approximate match to the library as an additional search term to use for future scans.</claim-text></claim-text></claim><claim id="CLM-00040" num="00040"><claim-text><b>40</b>. One or more non-transitory computer readable media storing program instructions that when executed on one or more processors implement an approximate search system and cause the approximate search system to:<claim-text>receive, via a configuration interface of the approximate search system, configuration information for executing an approximate search of a string in a text, wherein the configuration information specifies:<claim-text>(a) deviation operations permitted on the string during the approximate search,</claim-text><claim-text>(b) respective costs of the deviation operations, and</claim-text><claim-text>(c) a cost limit for the approximate search;</claim-text></claim-text><claim-text>execute the approximate search according to the configuration information, including to:<claim-text>maintain in memory a subset of states of a state machine generated during the approximate search, wherein individual ones of the states specify:<claim-text>(a) a match position in the string achieved at the individual state,</claim-text><claim-text>(b) a last deviation operation performed on the string to achieve the individual state, and</claim-text><claim-text>(c) a cost accumulated for any deviation operations performed on the string to achieve the individual state;</claim-text></claim-text></claim-text><claim-text>modify the subset of states in memory for individual characters in the text, including to:<claim-text>generate one or more new states from a preceding state of the state machine based at least in part on the individual character and a last deviation operation indicated by the preceding state, and</claim-text><claim-text>prune one or more existing states of the state machine based at least in part on respective costs of the one or more existing states;</claim-text></claim-text><claim-text>determine an approximate match of the string in the text in response to reaching an end state of the state machine, wherein a match position of end state equals a final match position of the string, and a cost of the end state is below the cost limit for the approximate search; and</claim-text><claim-text>output the approximate match of the string.</claim-text></claim-text></claim></claims></us-patent-application>