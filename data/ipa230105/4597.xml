<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004598A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004598</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17930318</doc-number><date>20220907</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>84</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>835</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>83</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>21</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>86</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>835</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>83</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>213</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>33</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">STORING SEMI-STRUCTURED DATA</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>17039880</doc-number><date>20200930</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11461394</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17930318</doc-number></document-id></child-doc></relation></continuation><continuation><relation><parent-doc><document-id><country>US</country><doc-number>15669603</doc-number><date>20170804</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>10817487</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17039880</doc-number></document-id></child-doc></relation></continuation><continuation><relation><parent-doc><document-id><country>US</country><doc-number>14507690</doc-number><date>20141006</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>9754048</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>15669603</doc-number></document-id></child-doc></relation></continuation></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Google LLC</orgname><address><city>Mountain View</city><state>CA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Probst</last-name><first-name>Martin</first-name><address><city>Munich</city><country>DE</country></address></addressbook></inventor></inventors></us-parties><assignees><assignee><addressbook><orgname>Google LLC</orgname><role>02</role><address><city>Mountain View</city><state>CA</state><country>US</country></address></addressbook></assignee></assignees></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">Methods, systems, and apparatus, including computer programs encoded on computer storage media, for storing semi-structured data. One of the methods includes maintaining a plurality of schemas; receiving a first semi-structured data item; determining that the first semi-structured data item does not match any of the schemas in the plurality of schemas; and in response to determining that the first semi-structured data item does not match any of the schemas in the plurality of schemas: generating a new schema, encoding the first semi-structured data item in the first data format to generate the first new encoded data item in accordance with the new schema, storing the first new encoded data item in the data item repository, and associating the first new encoded data item with the new schema.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="136.06mm" wi="131.15mm" file="US20230004598A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="206.25mm" wi="120.40mm" file="US20230004598A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="229.70mm" wi="159.77mm" file="US20230004598A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="173.40mm" wi="133.18mm" file="US20230004598A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="180.09mm" wi="133.27mm" file="US20230004598A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="125.73mm" wi="133.10mm" file="US20230004598A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading><p id="p-0002" num="0001">This U.S. patent application is a continuation of, and claims priority under 35 U.S.C. &#xa7; 120 from, U.S. patent application Ser. No. 17/039,880, filed on Sep. 30, 2020, which is a continuation of U.S. patent application Ser. No. 15/669,603, filed on Aug. 4, 2017, which is a continuation of U.S. patent application Ser. No. 14/507,690, filed on Oct. 6, 2014. The disclosures of these prior applications are considered part of the disclosure of this application and are hereby incorporated by reference in their entireties.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">BACKGROUND</heading><p id="p-0003" num="0002">This specification relates to storing semi-structured data.</p><p id="p-0004" num="0003">Semi-structured data is self-describing data that does not conform to a static, predefined format. For example, one semi-structured data format is JavaScript Object Notation (JSON). A JSON data item generally includes one or more JSON objects, i.e., one or more unordered sets of key/value pairs. Another example semi-structured data format is Extensible Markup Language (XML). An XML data item generally includes one or more XML elements that define values for one or more keys.</p><heading id="h-0003" level="1">SUMMARY</heading><p id="p-0005" num="0004">In general, this specification describes techniques for extracting facts from collections of documents.</p><p id="p-0006" num="0005">In general, one innovative aspect of the subject matter described in this specification can be embodied in methods that include the actions of maintaining a plurality of schemas, wherein each schema is associated with one or more encoded data items stored in a first data format in a data item repository, wherein each encoded data item stores a respective value at each of one or more locations in the encoded data item, and wherein each schema maps each of the locations in the data items associated with the schema to a respective key to which the value stored at the location in the data items associated with the schema corresponds; receiving a first semi-structured data item, wherein the first semi-structured data item is in a semi-structured data format, and wherein the first semi-structured data item includes one or more first key/value pairs; determining that the first semi-structured data item does not match any of the schemas in the plurality of schemas; and in response to determining that the first semi-structured data item does not match any of the schemas in the plurality of schemas: generating a new schema, wherein the new schema maps each of the locations in a first new encoded data item to a respective key to which the value that is stored at the location in the first new encoded data item corresponds, encoding the first semi-structured data item in the first data format to generate the first new encoded data item by storing values corresponding to values from the first key/value pairs at respective locations in the first new encoded data item in accordance with the new schema, storing the first new encoded data item in the data item repository, and associating the first new encoded data item with the new schema.</p><p id="p-0007" num="0006">Other embodiments of this aspect include corresponding computer systems, apparatus, and computer programs recorded on one or more computer storage devices, each configured to perform the actions of the methods. For a system of one or more computers to be configured to perform particular operations or actions means that the system has installed on it software, firmware, hardware, or a combination of them that in operation cause the system to perform the operations or actions. For one or more computer programs to be configured to perform particular operations or actions means that the one or more programs include instructions that, when executed by data processing apparatus, cause the apparatus to perform the operations or actions.</p><p id="p-0008" num="0007">These and other aspects can optionally include one or more of the following features. Determining that the first semi-structured data item does not match any of the schemas in the plurality of schemas includes determining that the keys from the first key/value pairs do not match the keys mapped to by any of the plurality of schemas. The first schema of the plurality of schemas maps each of the keys from the first key/value pairs to locations and identifies requirements for values of one or more of the keys from the first key/value pairs, and determining that the first semi-structured data item does not match any of the schemas in the plurality of schemas includes determining that the values from the first key/value pairs do not satisfy the requirements identified in the first schema.</p><p id="p-0009" num="0008">The aspect further includes the actions of receiving a second semi-structured data item, wherein the second semi-structured data item includes one or more second key/value pairs; determining that the second semi-structured data item matches a second schema from the plurality of schemas; and in response to determining that the second semi-structured data item matches the second schema: encoding the second semi-structured data item in the first data format to generate a second new encoded data item by storing values corresponding to the values from the second key/value pairs at respective locations in the second new encoded data item in accordance with the second schema, storing the second new encoded data item in the data item repository, and associating the second new encoded data item with the second schema. Determining that the second semi-structured data item matches the second schema from the plurality of schemas includes determining that the keys mapped to locations by the second schema match the keys from the second key/value pairs. The second schema identifies requirements for values of one or more of the keys mapped to locations by the second schema. Determining that the second semi-structured data item matches the second schema from the plurality of schemas includes determining that the values from the second key/value pairs satisfy the requirements identified in the second schema.</p><p id="p-0010" num="0009">The aspect further includes receiving a query for semi-structured data items, wherein the query specifies requirements for values for one or more keys; identifying schemas from the plurality of schemas that identify locations for values corresponding to each of the one or more keys; for each identified schema, searching the encoded data items associated with the schema to identify encoded data items that satisfy the query; and providing data identifying values from the encoded data items that satisfy the query in response to the query. Searching the encoded data items associated with the schema includes: searching, for each encoded data item associated with the schema, the locations in the encoded data item identified by the schema as storing values for the specified keys to identify whether the encoded data item stores values for the specified keys that satisfy the requirements specified in the query.</p><p id="p-0011" num="0010">Particular embodiments of the subject matter described in this specification can be implemented so as to realize one or more of the following advantages. By dynamically generating schemas for received semi-structured data items, semi-structured data can be stored in an efficient data format without requiring a schema for the semi-structured data to be specified in advance. Queries for data items stored in the efficient data format can be processed efficiently. Using the dynamically generated schemas, users can easily and effectively analyze the semi-structured data that has been stored by an application in a data item repository. For example, users can easily identify potential data quality issues, e.g., by querying for data items that don't follow an expected schema or schemas that match very few data items. As another example, users can easily identify data items that share common properties or particularly popular schemas, i.e., schemas that are associated with large numbers of data items. As another example, because the schemas are generated when encoded data items are converted, users can precisely determine which schemas are being maintained by a semi-structured data storage system at any given point in time. As another example, application developers developing applications that interact with a semi-structured data storage system can more easily develop applications by being provided an understanding of the schemas being maintained by the semi-structured data storage system.</p><p id="p-0012" num="0011">The details of one or more embodiments of the subject matter of this specification are set forth in the accompanying drawings and the description below. Other features, aspects, and advantages of the subject matter will become apparent from the description, the drawings, and the claims.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. <b>1</b></figref> shows an example semi-structured data storage system.</p><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. <b>2</b></figref> shows an example semi-structured data item, an example encoded data item generated from the example semi-structured data item, and an example schema associated with the encoded data item.</p><p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a flow diagram of an example process for storing a semi-structured data item in an efficient data format.</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a flow diagram of another example process for storing a semi-structured data item in an efficient data format.</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a flow diagram of an example process for processing a received query.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><p id="p-0018" num="0017">Like reference numbers and designations in the various drawings indicate like elements.</p><heading id="h-0005" level="1">DETAILED DESCRIPTION</heading><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>1</b></figref> shows an example semi-structured data storage system <b>100</b>. The semi-structured data storage system <b>100</b> is an example of a system implemented as computer programs on one or more computers in one or more locations, in which the systems, components, and techniques described below can be implemented.</p><p id="p-0020" num="0019">The semi-structured data storage system <b>100</b> receives input data items <b>102</b> to be stored in a data item repository <b>106</b>. In particular, the input data items <b>102</b> are instances of semi-structured data that each include one or more key/value pairs. Generally, semi-structured data is self-describing data that does not conform to a static, predefined format. For example, the input data items can be JavaScript Object Notation (JSON) data items that include one or more JSON objects, i.e., one or more unordered sets of key/value pairs. In a JSON object, the key/value pairs are expressed as: {key1: value1, key2: value2, . . . }, where key1/value1 and key2/value2 are each key/value pairs. As another example, the input data items can be Extensible Markup Language (XML) data items that include one or more XML elements that define values for one or more keys. The key/value pairs in a received data item may be unordered, i.e., so that two received data items having the same key/value pairs in a different order are logically equivalent, or ordered, i.e., so that two received data items having the same key/value pairs in a different order are not logically equivalent. The values from the key/value pairs can be any of many different kinds of values, e.g., explicit values or nested key/value pairs.</p><p id="p-0021" num="0020">The semi-structured data storage system <b>100</b> encodes each received input data item in a data storage format and stores the encoded data item in the data item repository <b>106</b>. Generally, the data storage format is an efficient data storage format, i.e., a data format that is defined such that encoding a received data item in the efficient data storage format and storing the encoded data item in the data item repository <b>106</b> requires less storage space than storing the received data item directly in the semi-structured data format in which the data item was received. This improves the technological field of data storage and management by utilizing storage resources more efficiently.</p><p id="p-0022" num="0021">In particular, the efficient data storage format is a format that stores values corresponding to the values from each key/value pair, e.g., the value itself or a compressed representation of the value, in a received semi-structured data item without storing the corresponding keys from the key/value pairs. For example, the efficient data storage format can specify that the values be stored as a sequence of bytes or as a sequence of elements, e.g., as an ordered list of values, without storing the corresponding keys from the key/value pairs. However, other efficient data storage formats are possible.</p><p id="p-0023" num="0022">Once the semi-structured data storage system <b>100</b> has stored an encoded data item in the data item repository <b>106</b>, the semi-structured data storage system <b>100</b> associates the encoded data item with a schema stored in a schema repository <b>104</b>. In particular, the semi-structured data storage system <b>100</b> generates a given encoded data item by encoding a received semi-structured data item into the efficient data format in accordance with a schema from the schema and then associates the encoded data item with the schema. Each schema in the schema repository <b>104</b> contains sufficient information to decode the encoded data items associated with the schema. In particular, each schema in the schema repository <b>104</b> maps each location in an encoded data item associated with the schema to a respective key to which the value stored at that location corresponds, i.e., the key from the same key/value pair as the value that corresponds to the value that is stored at that location.</p><p id="p-0024" num="0023">Optionally, each of the schemas can also specify requirements for the values of one or more of the keys mapped to by the schema. For example, in some implementations, the schema specifies a required data type for some or all of the values, e.g., number, string, Boolean, and so on. As another example, in some implementations, the schema specifies size limits for some or all of the values, e.g., that a certain value is a string that does not exceed one hundred bytes. Example schemas are described in more detail below with reference to <figref idref="DRAWINGS">FIG. <b>2</b></figref>.</p><p id="p-0025" num="0024">In order to associate data items with schemas, when the semi-structured data storage system <b>100</b> receives an input data item <b>102</b> to be stored in the data item repository <b>106</b>, the semi-structured data storage system <b>100</b> determines whether any of the schemas in the schema repository <b>104</b> match the input data item and, if so, the semi-structured data storage system <b>100</b> associates the matching schema with the encoded data item generated from the received input data item. If none of the schemas in the schema repository <b>104</b> match the input data item, the semi-structured data storage system <b>100</b> generates a new schema for the received input data item, stores the new schema in the schema repository <b>104</b>, and associates the new schema with the encoded data item generated from the received input data item. This enables the emergence of new schemas without requiring a predefined set of rules or other data storage requirements. The dynamic emergence of new schemas also improves the technological field of data storage and management, as the semi-structured data storage system <b>100</b> can handle any type of semi-structured data and is thus very robust and less prone to experiencing processing errors than storage systems that require data that conform to a static, pre-defined format. Additionally, the semi-structured data storage system <b>100</b> is easier to use for developers and more extensible than other storage systems. Processing received data items and identifying matching schemas is described in more detail below with reference to <figref idref="DRAWINGS">FIGS. <b>3</b> and <b>4</b></figref>.</p><p id="p-0026" num="0025">Additionally, the semi-structured data storage system <b>100</b> may receive queries for data items that satisfy requirements specified in the query. For example, the semi-structured data storage system <b>100</b> may receive queries that specify one or more keys and, for each of the one or more keys, requirements for values for the key. The semi-structured data storage system <b>100</b> can identify encoded data items in the data item repository <b>106</b> that satisfy the requirements in the query using the schemas in the schema repository <b>104</b>. Processing a received query to identify encoded data items that satisfy the query is described in more detail below with reference to <figref idref="DRAWINGS">FIG. <b>5</b></figref>.</p><p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. <b>2</b></figref> shows an example semi-structured data item <b>202</b>, an example encoded data item <b>210</b> generated from the example semi-structured data item <b>202</b>, and an example schema <b>212</b> associated with the encoded data item <b>210</b>.</p><p id="p-0028" num="0027">The example semi-structured data item <b>202</b> is an example JSON object named &#x201c;Example JSON Data Item.&#x201d; The JSON object includes three key/value pairs <b>204</b>, <b>206</b>, and <b>208</b>. In particular, the key/value pair <b>204</b> indicates that the value of an &#x201c;author&#x201d; key is &#x201c;Ernest Hemingway,&#x201d; the key/value pair <b>206</b> indicates that the value of a &#x201c;title&#x201d; key is &#x201c;The Old Man and the Sea,&#x201d; and the key/value pair <b>208</b> indicates that the value of a &#x201c;year published&#x201d; key is &#x201c;1952.&#x201d;</p><p id="p-0029" num="0028">The encoded data item <b>210</b> is generated by encoding the semi-structured data item <b>202</b> into an efficient data format. In the example of <figref idref="DRAWINGS">FIG. <b>2</b></figref>, the efficient data format specifies that a JSON object be encoded into an ordered list of the values from the key/values pairs in the JSON object. Thus, the semi-structured data item <b>202</b> has been encoded into the ordered list &#x201c;Ernest Hemingway, Old Man and the Sea, 1952.&#x201d;</p><p id="p-0030" num="0029">The schema <b>212</b> that is associated with the encoded data item <b>210</b> has been assigned a unique identifier <b>214</b> (&#x201c;1234&#x201d;). For example, the encoded data item <b>210</b> can be associated with the schema <b>210</b> by storing the identifier <b>214</b> for the schema in association with the encoded data item <b>210</b> in a data item repository, e.g., the data item repository <b>106</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. The schema <b>212</b> maps the locations in the encoded data item <b>210</b> to the keys to which the values stored at the locations correspond. That is, the schema <b>212</b> identifies the locations in the encoded data item <b>210</b> that store the data representing the &#x201c;author,&#x201d; &#x201c;title, and &#x201c;year&#x201d; keys, respectively. In particular, the schema <b>212</b> identifies that the value of the &#x201c;author&#x201d; key is stored in element <b>1</b> of the encoded data item <b>210</b>, the value of the &#x201c;title&#x201d; key is stored in element <b>2</b> of the encoded data item <b>210</b>, and the value of the &#x201c;year published&#x201d; key is stored in element <b>3</b>. The example schema <b>212</b> may optionally include other information about the values for each of the keys. For example, the example schema <b>212</b> may identify a required data type for the values of one or more of the keys, e.g., that the value of the &#x201c;year&#x201d; key is required to be a number, a maximum length for the values of one or more of the keys, e.g., that the value of the &#x201c;author&#x201d; key is required to be less than 100 bytes, or both.</p><p id="p-0031" num="0030">Additionally, depending on the efficient data format that is used, the schema <b>212</b> can identify the locations of the values of the keys in the encoded data item in a different manner. For example, if the efficient data format specifies that the values of the keys from the received data item be encoded into a sequence of bytes, i.e., a sequence that does not include separators between the value, the schema <b>212</b> can identify the locations in terms of byte offsets, e.g., that the value for the &#x201c;title&#x201d; key is stored between a first byte offset value in the sequence and a second byte offset value in the sequence while the value for the &#x201c;author&#x201d; key is stored between a third byte offset value in the sequence and a fourth byte offset value in the sequence. Other techniques for identifying locations of values for particular keys in an encoded data item are possible.</p><p id="p-0032" num="0031">Additionally, instead of explicitly identifying the locations of the values in the encoded data item <b>210</b>, in some implementations, the schema <b>214</b> may instead implicitly identify some or all of the locations by including a reference to one or more other schemas in the schema repository. For example, if another schema in the schema repository identified that the value of the &#x201c;author&#x201d; key was stored in element <b>1</b>, and the value of the &#x201c;title&#x201d; key was stored in element <b>2</b>, but did not identify the location of the value for the &#x201c;year published&#x201d; key, the schema <b>214</b> could identify the &#x201c;author&#x201d; and &#x201c;title&#x201d; keys and the locations of the corresponding values by including a reference to the other schema, i.e., a unique identifier for the other schema, and then identify the &#x201c;year published&#x201d; key and the location of the value of the &#x201c;year published&#x201d; key explicitly as described in the example of <figref idref="DRAWINGS">FIG. <b>2</b></figref>.</p><p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a flow diagram of an example process <b>300</b> for storing a semi-structured data item in an efficient data format. For convenience, the process <b>300</b> will be described as being performed by a system of one or more computers located in one or more locations. For example, a semi-structured data storage system, e.g., the semi-structured data storage system <b>100</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, appropriately programmed in accordance with this specification, can perform the process <b>300</b>.</p><p id="p-0034" num="0033">The system receives a semi-structured data item that includes one or more key/value pairs to be encoded in an efficient data format and then stored in a data item repository (step <b>302</b>).</p><p id="p-0035" num="0034">The system determines that the semi-structured data item matches a schema in a schema repository, e.g., the schema repository <b>104</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref> (step <b>304</b>). As described above, each schema in the schema repository maps locations in encoded data items to keys that correspond to the values stored at the locations.</p><p id="p-0036" num="0035">In order to determine whether the semi-structured data item matches a schema from the schema repository, the system determines whether the keys from the key/value pairs in the semi-structured data item match the keys mapped to by any of the schemas in the schema repository. If the key/value pairs in the semi-structured data item are unordered, the system considers the keys mapped to by a schema to be the same as the keys from the key/value pairs in the semi-structured data item if mapped keys include each of the keys from the key/value pairs in the semi-structured data item and do not include additional keys. If the key/value pairs in the semi-structured data item are ordered, the system also requires that the order of the key/value pairs in the semi-structured data item match the order in which the keys are identified in the mapping. Additionally, if the schemas in the schema repository also identify requirements for values of any of the keys mapped to by the schema, e.g., data type requirements or size requirements, the system also requires that the corresponding values in the semi-structure data item satisfy the requirements identified in the schema.</p><p id="p-0037" num="0036">The system encodes the semi-structured data item into the efficient data format to generate an encoded data item in accordance with the matching schema (step <b>306</b>). For example, if the efficient data format encodes semi-structured data items as comma-separated ordered lists of the values from the key/value pairs in the semi-structured data items, the system can generate an encoded data item that is a comma-separated list of the values from the key/value pairs in the semi-structured data item, with the order of the values in the list being defined by the locations identified in the matching schema for the corresponding keys. As another example, if the efficient data format encodes semi-structure as a sequence of bytes, the system can generate a sequence of values from the key/value pairs, with the locations of the values in the sequence being defined by the byte offset values identified in the schema for the corresponding keys.</p><p id="p-0038" num="0037">The system stores the encoded data item in the data item repository (step <b>308</b>) and associates the matching schema with the encoded data item in the repository (step <b>310</b>). For example, the system can store the encoded data item in the data item repository in association with data identifying the matching schema, e.g., a unique identifier for the schema. As will be described in more detail below with reference to <figref idref="DRAWINGS">FIG. <b>5</b></figref>, the system can use the association between the schema and the encoded data item to retrieve key/value data from the encoded data item, e.g., in response to received queries.</p><p id="p-0039" num="0038"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a flow diagram of another example process <b>400</b> for storing a semi-structured data item in an efficient data format. For convenience, the process <b>400</b> will be described as being performed by a system of one or more computers located in one or more locations. For example, a semi-structured data storage system, e.g., the semi-structured data storage system <b>100</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, appropriately programmed in accordance with this specification, can perform the process <b>400</b>.</p><p id="p-0040" num="0039">The system receives a semi-structured data item to be encoded in an efficient data format and stored in a data item repository (step <b>402</b>).</p><p id="p-0041" num="0040">The system determines that the semi-structured data item does not match any schema in the schema repository (step <b>404</b>). That is the system, determines that either the keys from the key/value pairs in the data item are not the same as the keys mapped to by any of the schemas in the schema repository or that one or more of the values from the key/values in the data item do not satisfy the requirements for values of that key in any of the schemas in the schema repository.</p><p id="p-0042" num="0041">The system generates a new schema for the semi-structured data item (step <b>406</b>). The new schema identifies the key from each of the key/value pairs in the semi-structured data item and, for each of the keys, the location in the encoded data item to be generated from the semi-structured data item that will store the encoded value for the key. The system can use a default technique to determine which location in the encoded data item will store the value for which key, e.g., by encoding the values from the key/value pairs into a sequence of values in a default order or by encoding the values from the key/value pairs into an ordered list in a default order. Optionally, the new schema may also identify, for one or more of the keys, the data type of the value of the key and a maximum length for the values. The maximum length can be assigned to a given value based on a heuristic that is specific to the data type of the value, e.g., that strings can be of maximum 100 characters in length. The heuristic for a given data type can be predetermined or, alternately, can be tuned dynamically by the system. For example, if more than a threshold proportion of received data items have values that exceed the maximum identified by the heuristic, the system can increase the maximum length until less than the threshold proportion are above the maximum.</p><p id="p-0043" num="0042">The system encodes the semi-structured data item into an efficient data format to generate an encoded data item in accordance with the new schema (step <b>408</b>). The system encodes the semi-structured data item in accordance with the new schema as described above with reference to <figref idref="DRAWINGS">FIG. <b>3</b></figref>.</p><p id="p-0044" num="0043">The system stores the encoded data item in the data item repository (step <b>410</b>).</p><p id="p-0045" num="0044">The system stores the new schema in the schema repository and associates the new schema with the encoded data item (step <b>412</b>). For example, the system can assign a unique identifier to the new schema and store data associating the unique identifier for the new schema and the encoded data item.</p><p id="p-0046" num="0045"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a flow diagram of an example process <b>500</b> for processing a received query. For convenience, the process <b>500</b> will be described as being performed by a system of one or more computers located in one or more locations. For example, a semi-structured data storage system, e.g., the semi-structured data storage system <b>100</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, appropriately programmed in accordance with this specification, can perform the process <b>300</b>.</p><p id="p-0047" num="0046">The system receives a query (step <b>502</b>). In particular, the query is a query for semi-structured data items that satisfy specified requirements for values for one or more specified keys. For example, the query may be for semi-structured data items that have a value &#x201c;Ernest Hemingway&#x201d; for an &#x201c;author&#x201d; key. As another example, the query may be for semi-structured data items that have a value &#x201c;Ernest Hemingway&#x201d; for an &#x201c;author&#x201d; key and that have values in a range of &#x201c;1948-1952&#x201d; for a &#x201c;year published&#x201d; key.</p><p id="p-0048" num="0047">The system identifies schemas in the schema repository that include the specified keys (step <b>504</b>). That is, the system identifies schemas in the schema repository that identify, for each of the specified keys, a location of data representing the value for the key. For example, if the query is for semi-structured data items that have a value &#x201c;Ernest Hemingway&#x201d; for an &#x201c;author&#x201d; key and that have values in a range of &#x201c;1948-1952&#x201d; for a &#x201c;year published&#x201d; key, the system can identify each schema that identifies locations of values for both the &#x201c;author&#x201d; key and the &#x201c;year published&#x201d; key.</p><p id="p-0049" num="0048">For each identified schema, the system searches the encoded data items associated with the schema in the data item repository to identify encoded data items that satisfy the query (step <b>506</b>). In particular, for each encoded data item associated with a given identified schema, the system searches the locations in the encoded data item identified by the schema as storing values for the specified keys to identify encoded data items that store values for the specified keys that satisfy the requirements specified in the query. For example, if the query is for semi-structured data items that have a value &#x201c;Ernest Hemingway&#x201d; for an &#x201c;author&#x201d; key and that have values in a range of &#x201c;1948-1952&#x201d; for a &#x201c;year published&#x201d; key, the system can identify encoded data items that store a value corresponding to &#x201c;Ernest Hemingway&#x201d; in the location identified in the schema associated with the encoded data item as storing the value for the &#x201c;author&#x201d; key and that store a value in the range from &#x201c;1948-1952&#x201d; in the location identified in the schema associated with the encoded data item as storing the value for the &#x201c;year published&#x201d; key. Thus, the system can identify encoded data items that satisfy the query efficiently, i.e., without searching encoded data items that do not include values for each key specified in the received query and without searching locations in the encoded data items that are not identified as storing values for the specified keys.</p><p id="p-0050" num="0049">The system provides data identifying the values in the encoded data items that satisfy the query in response to the query (step <b>508</b>). For example, the system can provide the values stored in the encoded data items in association with their corresponding keys in accordance with a predetermined response format. As another example, for each encoded data item that satisfied the query, the system can reconstruct the semi-structured data item from which the encoded data item was generated based on the schema associated with the encoded data item and provide data identifying the reconstructed semi-structure data item in response to the query. As yet another example, in response to the query, the system may provide the encoded data items that satisfy the query, and, for each encoded data item, data identifying the schema that is associated with the query. Thus, if the system submitting the query has access to the schemas in the schema repository, the submitting system can identify the keys corresponding to the values in a given encoded data item by referring to the schema associated with the key. If the submitting system does not have access to a particular schema, the system can provide the particular schema to the submitting system, e.g., in response to a request or by providing new schemas to the submitting system at regular or irregular intervals.</p><p id="p-0051" num="0050">The system may also receive queries for other types of information. For example, the system may receive a query for schemas that satisfy certain requirements, e.g., schemas that identify a value for a particular key. In response, the system can search the schemas in the schema repository and provide data identifying the schemas that satisfy the requirements as a response to the query.</p><p id="p-0052" num="0051">In some implementations, the system can modify stored schemas in response to user inputs. For example, if a user desires to change the name of a key identified in one or more semi-structured data items, rather than modifying the encoded data items, the user can submit a request to the system to change the name of the key in all or some of the schemas that identify the location of values for the key. In response, the system can modify the keys in the schemas without needing to modify the encoded data items stored in the data repository.</p><p id="p-0053" num="0052">Embodiments of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry, in tangibly-embodied computer software or firmware, in computer hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. Embodiments of the subject matter described in this specification can be implemented as one or more computer programs, i.e., one or more modules of computer program instructions encoded on a tangible non transitory program carrier for execution by, or to control the operation of, data processing apparatus. Alternatively or in addition, the program instructions can be encoded on an artificially generated propagated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus for execution by a data processing apparatus. The computer storage medium can be a machine-readable storage device, a machine-readable storage substrate, a random or serial access memory device, or a combination of one or more of them.</p><p id="p-0054" num="0053">The term &#x201c;data processing apparatus&#x201d; encompasses all kinds of apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, or multiple processors or computers. The apparatus can include special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application specific integrated circuit). The apparatus can also include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, or a combination of one or more of them.</p><p id="p-0055" num="0054">A computer program (which may also be referred to or described as a program, software, a software application, a module, a software module, a script, or code) can be written in any form of programming language, including compiled or interpreted languages, or declarative or procedural languages, and it can be deployed in any form, including as a standalone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program may, but need not, correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data, e.g., one or more scripts stored in a markup language document, in a single file dedicated to the program in question, or in multiple coordinated files, e.g., files that store one or more modules, sub programs, or portions of code. A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.</p><p id="p-0056" num="0055">The processes and logic flows described in this specification can be performed by one or more programmable computers executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application specific integrated circuit).</p><p id="p-0057" num="0056">Computers suitable for the execution of a computer program include, by way of example, can be based on general or special purpose microprocessors or both, or any other kind of central processing unit. Generally, a central processing unit will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a central processing unit for performing or executing instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto optical disks, or optical disks. However, a computer need not have such devices. Moreover, a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device, e.g., a universal serial bus (USB) flash drive, to name just a few.</p><p id="p-0058" num="0057">Computer readable media suitable for storing computer program instructions and data include all forms of nonvolatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto optical disks; and CD ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.</p><p id="p-0059" num="0058">To provide for interaction with a user, embodiments of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input. In addition, a computer can interact with a user by sending documents to and receiving documents from a device that is used by the user; for example, by sending web pages to a web browser on a user's client device in response to requests received from the web browser.</p><p id="p-0060" num="0059">Embodiments of the subject matter described in this specification can be implemented in a computing system that includes a back end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described in this specification, or any combination of one or more such back end, middleware, or front end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (&#x201c;LAN&#x201d;) and a wide area network (&#x201c;WAN&#x201d;), e.g., the Internet.</p><p id="p-0061" num="0060">The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.</p><p id="p-0062" num="0061">While this specification contains many specific implementation details, these should not be construed as limitations on the scope of any implementations or of what may be claimed, but rather as descriptions of features that may be specific to particular embodiments of particular implementations. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.</p><p id="p-0063" num="0062">Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In certain circumstances, multitasking and parallel processing may be advantageous. Moreover, the separation of various system modules and components in the embodiments described above should not be understood as requiring such separation in all embodiments, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.</p><p id="p-0064" num="0063">Particular embodiments of the subject matter have been described. Other embodiments are within the scope of the following claims. For example, the actions recited in the claims can be performed in a different order and still achieve desirable results. As one example, the processes depicted in the accompanying figures do not necessarily require the particular order shown, or sequential order, to achieve desirable results. In certain implementations, multitasking and parallel processing may be advantageous.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A computer-implemented method when executed by data processing hardware causes the data processing hardware to perform operations comprising:<claim-text>maintaining a plurality of schemas, each schema of the plurality of schemas associated with one or more data items stored in a data format in a data item repository, each data item of the one or more data items storing a respective value, wherein each schema maps to a location of the respective value to a respective key;</claim-text><claim-text>receiving, from a user, a query for a data item stored in the data item repository, the query specifying a value requirement for a particular key;</claim-text><claim-text>identifying one or more schemas of the plurality of schemas that include the particular key;</claim-text><claim-text>for each identified schema of the one or more schemas, identifying data items of the one or more data items satisfying the value requirement specified by the query; and</claim-text><claim-text>providing, to the user, the identified data items that satisfy the value requirement of the query.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein identifying the data items of the one or more data items that satisfy the value requirement specified by the query comprises searching, for each data item associated with a respective identified schema, the location in the data item identified by the respective identified schema as storing values for the particular key to identify whether the data item stores the value for the particular key that satisfy the value requirement of the query.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the value requirement of the particular key specified by the query comprises a range of values for the particular key.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the one or more data items stored in the data format in the data item repository comprise one or more encoded data items.</claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein providing the identified data items that satisfy the value requirement specified by the query comprises providing the respective value stored in the one or more encoded data items in association with the particular keys.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein providing the identified data items that satisfy the value requirement specified by the query further comprises:<claim-text>reconstructing the one or more encoded data items based on a respective identified schema associated with the one or more encoded data items; and</claim-text><claim-text>providing data identifying the one or more reconstructed encoded data items in response to the query.</claim-text></claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein each schema of the plurality of schemas identifies requirements for values of the one or more data items.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein each schema of the plurality of schemas identifies a required data type for values of the one or more data items.</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the operations further comprise:<claim-text>receiving a modification to a key in the plurality of schemas; and</claim-text><claim-text>modifying the key in the plurality of schemas without modifying the one or more data items stored in the data item repository.</claim-text></claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the plurality of schemas are stored in a schema repository.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. A system comprising:<claim-text>data processing hardware; and</claim-text><claim-text>memory hardware in communication with the data processing hardware, the memory hardware storing instructions that when executed on the data processing hardware cause the data processing hardware to perform operations comprising:<claim-text>maintaining a plurality of schemas, each schema of the plurality of schemas associated with one or more data items stored in a data format in a data item repository, each data item of the one or more data items storing a respective value, wherein each schema maps to a location of the respective value to a respective key;</claim-text><claim-text>receiving, from a user, a query for a data item stored in the data item repository, the query specifying a value requirement for a particular key;</claim-text><claim-text>identifying one or more schemas of the plurality of schemas that include the particular key;</claim-text><claim-text>for each identified schema of the one or more schemas, identifying data items of the one or more data items satisfying the value requirement of the query; and</claim-text><claim-text>providing, to the user, the identified data items that satisfy the value requirement specified by the query.</claim-text></claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The system of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein identifying the data items of the one or more data items that satisfy the value requirement of the query comprises searching, for each data item associated with a respective identified schema, the location in the data item identified by the respective identified schema as storing values for the particular key to identify whether the data item stores the value for the particular key that satisfy the value requirement specified by the query.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The system of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the value requirement of the particular key specified by the query comprises a range of values for the particular key.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The system of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the one or more data items stored in the data format in the data item repository comprise one or more encoded data items.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The system of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein providing the identified data items that satisfy the value requirement specified by the query comprises providing the respective value stored in the one or more encoded data items in association with the particular keys.</claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The system of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein providing the identified data items that satisfy the value requirement specified by the query further comprises:<claim-text>reconstructing the one or more encoded data items based on a respective identified schema associated with the one or more encoded data items; and</claim-text><claim-text>providing data identifying the one or more reconstructed encoded data items in response to the query.</claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The system of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein each schema of the plurality of schemas identifies requirements for values of the one or more data items.</claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The system of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein each schema of the plurality of schemas identifies a required data type for values of the one or more data items.</claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The system of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the operations further comprise:<claim-text>receiving a modification to a key in the plurality of schemas; and</claim-text><claim-text>modifying the key in the plurality of schemas without modifying the one or more data items stored in the data item repository.</claim-text></claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The system of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the plurality of schemas are stored in a schema repository.</claim-text></claim></claims></us-patent-application>