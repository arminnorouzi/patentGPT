<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004390A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004390</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17359561</doc-number><date>20210626</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>30</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>7</main-group><subgroup>501</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>7</main-group><subgroup>499</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>7</main-group><subgroup>487</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>30036</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>30145</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>3001</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>30101</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>7</main-group><subgroup>501</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>7</main-group><subgroup>49947</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>7</main-group><subgroup>4876</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">APPARATUS AND METHOD FOR VECTOR PACKED DUAL COMPLEX-BY-COMPLEX AND DUAL COMPLEX-BY-COMPLEX CONJUGATE MULTIPLICATION</invention-title><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Intel Corporation</orgname><address><city>Santa Clara</city><state>CA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Madduri</last-name><first-name>Venkateswara Rao</first-name><address><city>Austin</city><state>TX</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Valentine</last-name><first-name>Robert</first-name><address><city>Kiryat Tivon</city><country>IL</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>Charney</last-name><first-name>Mark J.</first-name><address><city>Lexington</city><state>MA</state><country>US</country></address></addressbook></inventor></inventors></us-parties><assignees><assignee><addressbook><orgname>Intel Corporation</orgname><role>02</role><address><city>Santa Clara</city><state>CA</state><country>US</country></address></addressbook></assignee></assignees></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">An apparatus and method for multiplying packed real and imaginary components of complex numbers and complex conjugates. For example, one embodiment of a processor comprises: a decoder to decode a first instruction to generate a decoded instruction; a first source register to store a first plurality of packed real and imaginary data elements; a second source register to store a second plurality of packed real and imaginary data elements; and execution circuitry to execute the decoded instruction. The execution circuitry includes multiplier circuitry to multiply select real and imaginary data elements in the first and second source registers to generate a plurality of real and imaginary products; adder circuitry to add/subtract various real and imaginary products, scale the results according to an immediate of the instruction, round the scaled results; and saturation circuitry to saturate the rounded results.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="115.99mm" wi="158.75mm" file="US20230004390A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="230.12mm" wi="165.69mm" orientation="landscape" file="US20230004390A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="232.33mm" wi="164.17mm" orientation="landscape" file="US20230004390A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="234.78mm" wi="156.21mm" orientation="landscape" file="US20230004390A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="233.68mm" wi="173.82mm" orientation="landscape" file="US20230004390A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="218.86mm" wi="161.88mm" orientation="landscape" file="US20230004390A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="166.96mm" wi="129.12mm" orientation="landscape" file="US20230004390A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="181.44mm" wi="54.10mm" orientation="landscape" file="US20230004390A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="145.46mm" wi="120.14mm" file="US20230004390A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="210.06mm" wi="147.40mm" orientation="landscape" file="US20230004390A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="199.81mm" wi="136.23mm" orientation="landscape" file="US20230004390A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="188.04mm" wi="99.40mm" orientation="landscape" file="US20230004390A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="221.91mm" wi="117.18mm" orientation="landscape" file="US20230004390A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="233.51mm" wi="179.32mm" orientation="landscape" file="US20230004390A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00014" num="00014"><img id="EMI-D00014" he="212.01mm" wi="102.62mm" orientation="landscape" file="US20230004390A1-20230105-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00015" num="00015"><img id="EMI-D00015" he="238.68mm" wi="175.26mm" orientation="landscape" file="US20230004390A1-20230105-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00016" num="00016"><img id="EMI-D00016" he="241.64mm" wi="178.14mm" file="US20230004390A1-20230105-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00017" num="00017"><img id="EMI-D00017" he="241.64mm" wi="178.14mm" file="US20230004390A1-20230105-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">BACKGROUND</heading><heading id="h-0002" level="1">Field of the Invention</heading><p id="p-0002" num="0001">The embodiments of the invention relate generally to the field of computer processors. More particularly, the embodiments relate to an apparatus and method for complex by complex conjugate multiplication.</p><heading id="h-0003" level="1">Description of the Related Art</heading><p id="p-0003" num="0002">An instruction set, or instruction set architecture (ISA), is the part of the computer architecture related to programming, including the native data types, instructions, register architecture, addressing modes, memory architecture, interrupt and exception handling, and external input and output (I/O). It should be noted that the term &#x201c;instruction&#x201d; generally refers herein to macro-instructions&#x2014;that is instructions that are provided to the processor for execution&#x2014;as opposed to micro-instructions or micro-ops&#x2014;that is the result of a processor's decoder decoding macro-instructions. The micro-instructions or micro-ops can be configured to instruct an execution unit on the processor to perform operations to implement the logic associated with the macro-instruction.</p><p id="p-0004" num="0003">The ISA is distinguished from the microarchitecture, which is the set of processor design techniques used to implement the instruction set. Processors with different microarchitectures can share a common instruction set. For example, Intel&#xae; Pentium 4 processors, Intel&#xae; Core&#x2122; processors, and processors from Advanced Micro Devices, Inc. of Sunnyvale Calif. implement nearly identical versions of the x86 instruction set (with some extensions that have been added with newer versions), but have different internal designs. For example, the same register architecture of the ISA may be implemented in different ways in different microarchitectures using well-known techniques, including dedicated physical registers, one or more dynamically allocated physical registers using a register renaming mechanism (e.g., the use of a Register Alias Table (RAT), a Reorder Buffer (ROB) and a retirement register file). Unless otherwise specified, the phrases register architecture, register file, and register are used herein to refer to that which is visible to the software/programmer and the manner in which instructions specify registers. Where a distinction is required, the adjective &#x201c;logical,&#x201d; &#x201c;architectural,&#x201d; or &#x201c;software visible&#x201d; will be used to indicate registers/files in the register architecture, while different adjectives will be used to designate registers in a given microarchitecture (e.g., physical register, reorder buffer, retirement register, register pool).</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0005" num="0004">A better understanding of the present invention can be obtained from the following detailed description in conjunction with the following drawings, in which:</p><p id="p-0006" num="0005"><figref idref="DRAWINGS">FIGS. <b>1</b>A and <b>1</b>B</figref> are block diagrams illustrating a generic vector friendly instruction format and instruction templates thereof according to embodiments of the invention;</p><p id="p-0007" num="0006"><figref idref="DRAWINGS">FIGS. <b>2</b>A-C</figref> are block diagrams illustrating an exemplary VEX instruction format according to embodiments of the invention;</p><p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a block diagram of a register architecture according to one embodiment of the invention; and</p><p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. <b>4</b>A</figref> is a block diagram illustrating both an exemplary in-order fetch, decode, retire pipeline and an exemplary register renaming, out-of-order issue/execution pipeline according to embodiments of the invention;</p><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. <b>4</b>B</figref> is a block diagram illustrating both an exemplary embodiment of an in-order fetch, decode, retire core and an exemplary register renaming, out-of-order issue/execution architecture core to be included in a processor according to embodiments of the invention;</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. <b>5</b>A</figref> is a block diagram of a single processor core, along with its connection to an on-die interconnect network;</p><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>5</b>B</figref> illustrates an expanded view of part of the processor core in <figref idref="DRAWINGS">FIG. <b>5</b>A</figref> according to embodiments of the invention;</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a block diagram of a single core processor and a multicore processor with integrated memory controller and graphics according to embodiments of the invention;</p><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. <b>7</b></figref> illustrates a block diagram of a system in accordance with one embodiment of the present invention;</p><p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. <b>8</b></figref> illustrates a block diagram of a second system in accordance with an embodiment of the present invention;</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. <b>9</b></figref> illustrates a block diagram of a third system in accordance with an embodiment of the present invention;</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>10</b></figref> illustrates a block diagram of a system on a chip (SoC) in accordance with an embodiment of the present invention;</p><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>11</b></figref> illustrates a block diagram contrasting the use of a software instruction converter to convert binary instructions in a source instruction set to binary instructions in a target instruction set according to embodiments of the invention;</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>12</b></figref> illustrates a processor architecture on which embodiments of the invention may be implemented;</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>13</b></figref> illustrates a plurality of packed data elements containing real and complex values in accordance with one embodiment;</p><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. <b>14</b></figref> illustrate different architectures on which embodiments of the invention may be implemented;</p><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. <b>15</b></figref> illustrates a method in accordance with one embodiment of the invention;</p><p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. <b>16</b></figref> illustrates a method in accordance with another embodiment of the invention.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0005" level="1">DETAILED DESCRIPTION</heading><p id="p-0024" num="0023">In the following description, for the purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the embodiments of the invention described below. It will be apparent, however, to one skilled in the art that the embodiments of the invention may be practiced without some of these specific details. In other instances, well-known structures and devices are shown in block diagram form to avoid obscuring the underlying principles of the embodiments of the invention.</p><heading id="h-0006" level="2">Exemplary Processor Architectures, Instruction Formats, and Data Types</heading><p id="p-0025" num="0024">An instruction set includes one or more instruction formats. A given instruction format defines various fields (number of bits, location of bits) to specify, among other things, the operation to be performed (opcode) and the operand(s) on which that operation is to be performed. Some instruction formats are further broken down though the definition of instruction templates (or subformats). For example, the instruction templates of a given instruction format may be defined to have different subsets of the instruction format's fields (the included fields are typically in the same order, but at least some have different bit positions because there are less fields included) and/or defined to have a given field interpreted differently. Thus, each instruction of an ISA is expressed using a given instruction format (and, if defined, in a given one of the instruction templates of that instruction format) and includes fields for specifying the operation and the operands. For example, an exemplary ADD instruction has a specific opcode and an instruction format that includes an opcode field to specify that opcode and operand fields to select operands (source1/destination and source2); and an occurrence of this ADD instruction in an instruction stream will have specific contents in the operand fields that select specific operands.</p><p id="p-0026" num="0025">Embodiments of the instruction(s) described herein may be embodied in different formats. Additionally, exemplary systems, architectures, and pipelines are detailed below. Embodiments of the instruction(s) may be executed on such systems, architectures, and pipelines, but are not limited to those detailed.</p><heading id="h-0007" level="2">Generic Vector Friendly Instruction Format</heading><p id="p-0027" num="0026">A vector friendly instruction format is an instruction format that is suited for vector instructions (e.g., there are certain fields specific to vector operations). While embodiments are described in which both vector and scalar operations are supported through the vector friendly instruction format, alternative embodiments use only vector operations the vector friendly instruction format.</p><p id="p-0028" num="0027"><figref idref="DRAWINGS">FIGS. <b>1</b>A-<b>1</b>B</figref> are block diagrams illustrating a generic vector friendly instruction format and instruction templates thereof according to embodiments of the invention. <figref idref="DRAWINGS">FIG. <b>1</b>A</figref> is a block diagram illustrating a generic vector friendly instruction format and class A instruction templates thereof according to embodiments of the invention; while <figref idref="DRAWINGS">FIG. <b>1</b>B</figref> is a block diagram illustrating the generic vector friendly instruction format and class B instruction templates thereof according to embodiments of the invention. Specifically, a generic vector friendly instruction format <b>100</b> for which are defined class A and class B instruction templates, both of which include no memory access <b>105</b> instruction templates and memory access <b>120</b> instruction templates. The term generic in the context of the vector friendly instruction format refers to the instruction format not being tied to any specific instruction set.</p><p id="p-0029" num="0028">While embodiments of the invention will be described in which the vector friendly instruction format supports the following: a 64 byte vector operand length (or size) with 32 bit (4 byte) or 64 bit (8 byte) data element widths (or sizes) (and thus, a 64 byte vector consists of either 16 doubleword-size elements or alternatively, 8 quadword-size elements); a 64 byte vector operand length (or size) with 16 bit (2 byte) or 8 bit (1 byte) data element widths (or sizes); a 32 byte vector operand length (or size) with 32 bit (4 byte), 64 bit (8 byte), 16 bit (2 byte), or 8 bit (1 byte) data element widths (or sizes); and a 16 byte vector operand length (or size) with 32 bit (4 byte), 64 bit (8 byte), 16 bit (2 byte), or 8 bit (1 byte) data element widths (or sizes); alternative embodiments may support more, less and/or different vector operand sizes (e.g., 256 byte vector operands) with more, less, or different data element widths (e.g., 128 bit (16 byte) data element widths).</p><p id="p-0030" num="0029">The class A instruction templates in <figref idref="DRAWINGS">FIG. <b>1</b>A</figref> include: 1) within the no memory access <b>105</b> instruction templates there is shown a no memory access, full round control type operation <b>110</b> instruction template and a no memory access, data transform type operation <b>115</b> instruction template; and 2) within the memory access <b>120</b> instruction templates there is shown a memory access, temporal <b>125</b> instruction template and a memory access, non-temporal <b>130</b> instruction template. The class B instruction templates in <figref idref="DRAWINGS">FIG. <b>1</b>B</figref> include: 1) within the no memory access <b>105</b> instruction templates there is shown a no memory access, write mask control, partial round control type operation <b>112</b> instruction template and a no memory access, write mask control, vsize type operation <b>117</b> instruction template; and 2) within the memory access <b>120</b> instruction templates there is shown a memory access, write mask control <b>127</b> instruction template.</p><p id="p-0031" num="0030">The generic vector friendly instruction format <b>100</b> includes the following fields listed below in the order illustrated in <figref idref="DRAWINGS">FIGS. <b>1</b>A-<b>1</b>B</figref>.</p><p id="p-0032" num="0031">Format field <b>140</b>&#x2014;a specific value (an instruction format identifier value) in this field uniquely identifies the vector friendly instruction format, and thus occurrences of instructions in the vector friendly instruction format in instruction streams. As such, this field is optional in the sense that it is not needed for an instruction set that has only the generic vector friendly instruction format.</p><p id="p-0033" num="0032">Base operation field <b>142</b>&#x2014;its content distinguishes different base operations.</p><p id="p-0034" num="0033">Register index field <b>144</b>&#x2014;its content, directly or through address generation, specifies the locations of the source and destination operands, be they in registers or in memory. These include a sufficient number of bits to select N registers from a P&#xd7;Q (e.g. 32&#xd7;512, 16&#xd7;128, 32&#xd7;1024, 64&#xd7;1024) register file. While in one embodiment N may be up to three sources and one destination register, alternative embodiments may support more or less sources and destination registers (e.g., may support up to two sources where one of these sources also acts as the destination, may support up to three sources where one of these sources also acts as the destination, may support up to two sources and one destination).</p><p id="p-0035" num="0034">Modifier field <b>146</b>&#x2014;its content distinguishes occurrences of instructions in the generic vector instruction format that specify memory access from those that do not; that is, between no memory access <b>105</b> instruction templates and memory access <b>120</b> instruction templates. Memory access operations read and/or write to the memory hierarchy (in some cases specifying the source and/or destination addresses using values in registers), while non-memory access operations do not (e.g., the source and destinations are registers). While in one embodiment this field also selects between three different ways to perform memory address calculations, alternative embodiments may support more, less, or different ways to perform memory address calculations.</p><p id="p-0036" num="0035">Augmentation operation field <b>150</b>&#x2014;its content distinguishes which one of a variety of different operations to be performed in addition to the base operation. This field is context specific. In one embodiment of the invention, this field is divided into a class field <b>168</b>, an alpha field <b>152</b>, and a beta field <b>154</b>. The augmentation operation field <b>150</b> allows common groups of operations to be performed in a single instruction rather than 2, 3, or 4 instructions.</p><p id="p-0037" num="0036">Scale field <b>160</b>&#x2014;its content allows for the scaling of the index field's content for memory address generation (e.g., for address generation that uses 2<sup>scale</sup>*index+base).</p><p id="p-0038" num="0037">Displacement Field <b>162</b>A&#x2014;its content is used as part of memory address generation (e.g., for address generation that uses 2<sup>scale</sup>*index+base+displacement).</p><p id="p-0039" num="0038">Displacement Factor Field <b>1626</b> (note that the juxtaposition of displacement field <b>162</b>A directly over displacement factor field <b>162</b>B indicates one or the other is used)&#x2014;its content is used as part of address generation; it specifies a displacement factor that is to be scaled by the size of a memory access (N)&#x2014;where N is the number of bytes in the memory access (e.g., for address generation that uses 2<sup>scale</sup>*index+base+scaled displacement). Redundant low-order bits are ignored and hence, the displacement factor field's content is multiplied by the memory operands total size (N) in order to generate the final displacement to be used in calculating an effective address. The value of N is determined by the processor hardware at runtime based on the full opcode field <b>174</b> (described later herein) and the data manipulation field <b>154</b>C. The displacement field <b>162</b>A and the displacement factor field <b>162</b>B are optional in the sense that they are not used for the no memory access <b>105</b> instruction templates and/or different embodiments may implement only one or none of the two.</p><p id="p-0040" num="0039">Data element width field <b>164</b>&#x2014;its content distinguishes which one of a number of data element widths is to be used (in some embodiments for all instructions; in other embodiments for only some of the instructions). This field is optional in the sense that it is not needed if only one data element width is supported and/or data element widths are supported using some aspect of the opcodes.</p><p id="p-0041" num="0040">Write mask field <b>170</b>&#x2014;its content controls, on a per data element position basis, whether that data element position in the destination vector operand reflects the result of the base operation and augmentation operation. Class A instruction templates support merging-writemasking, while class B instruction templates support both merging- and zeroing-writemasking. When merging, vector masks allow any set of elements in the destination to be protected from updates during the execution of any operation (specified by the base operation and the augmentation operation); in other one embodiment, preserving the old value of each element of the destination where the corresponding mask bit has a 0. In contrast, when zeroing vector masks allow any set of elements in the destination to be zeroed during the execution of any operation (specified by the base operation and the augmentation operation); in one embodiment, an element of the destination is set to 0 when the corresponding mask bit has a 0 value. A subset of this functionality is the ability to control the vector length of the operation being performed (that is, the span of elements being modified, from the first to the last one); however, it is not necessary that the elements that are modified be consecutive. Thus, the write mask field <b>170</b> allows for partial vector operations, including loads, stores, arithmetic, logical, etc. While embodiments of the invention are described in which the write mask field's <b>170</b> content selects one of a number of write mask registers that contains the write mask to be used (and thus the write mask field's <b>170</b> content indirectly identifies that masking to be performed), alternative embodiments instead or additional allow the mask write field's <b>170</b> content to directly specify the masking to be performed.</p><p id="p-0042" num="0041">Immediate field <b>172</b>&#x2014;its content allows for the specification of an immediate. This field is optional in the sense that is it not present in an implementation of the generic vector friendly format that does not support immediate and it is not present in instructions that do not use an immediate.</p><p id="p-0043" num="0042">Class field <b>168</b>&#x2014;its content distinguishes between different classes of instructions. With reference to <figref idref="DRAWINGS">FIGS. <b>1</b>A-B</figref>, the contents of this field select between class A and class B instructions. In <figref idref="DRAWINGS">FIGS. <b>1</b>A-B</figref>, rounded corner squares are used to indicate a specific value is present in a field (e.g., class A <b>168</b>A and class B <b>168</b>B for the class field <b>168</b> respectively in <figref idref="DRAWINGS">FIGS. <b>1</b>A-B</figref>).</p><heading id="h-0008" level="2">Instruction Templates of Class A</heading><p id="p-0044" num="0043">In the case of the non-memory access <b>105</b> instruction templates of class A, the alpha field <b>152</b> is interpreted as an RS field <b>152</b>A, whose content distinguishes which one of the different augmentation operation types are to be performed (e.g., round <b>152</b>A.<b>1</b> and data transform <b>152</b>A.<b>2</b> are respectively specified for the no memory access, round type operation <b>110</b> and the no memory access, data transform type operation <b>115</b> instruction templates), while the beta field <b>154</b> distinguishes which of the operations of the specified type is to be performed. In the no memory access <b>105</b> instruction templates, the scale field <b>160</b>, the displacement field <b>162</b>A, and the displacement scale filed <b>162</b>B are not present.</p><heading id="h-0009" level="2">No-Memory Access Instruction Templates&#x2014;Full Round Control Type Operation</heading><p id="p-0045" num="0044">In the no memory access full round control type operation <b>110</b> instruction template, the beta field <b>154</b> is interpreted as a round control field <b>154</b>A, whose content(s) provide static rounding. While in the described embodiments of the invention the round control field <b>154</b>A includes a suppress all floating point exceptions (SAE) field <b>156</b> and a round operation control field <b>158</b>, alternative embodiments may support may encode both these concepts into the same field or only have one or the other of these concepts/fields (e.g., may have only the round operation control field <b>158</b>).</p><p id="p-0046" num="0045">SAE field <b>156</b>&#x2014;its content distinguishes whether or not to disable the exception event reporting; when the SAE field's <b>156</b> content indicates suppression is enabled, a given instruction does not report any kind of floating-point exception flag and does not raise any floating point exception handler.</p><p id="p-0047" num="0046">Round operation control field <b>158</b>&#x2014;its content distinguishes which one of a group of rounding operations to perform (e.g., Round-up, Round-down, Round-towards-zero and Round-to-nearest). Thus, the round operation control field <b>158</b> allows for the changing of the rounding mode on a per instruction basis. In one embodiment of the invention where a processor includes a control register for specifying rounding modes, the round operation control field's <b>150</b> content overrides that register value.</p><heading id="h-0010" level="2">No Memory Access Instruction Templates&#x2014;Data Transform Type Operation</heading><p id="p-0048" num="0047">In the no memory access data transform type operation <b>115</b> instruction template, the beta field <b>154</b> is interpreted as a data transform field <b>1546</b>, whose content distinguishes which one of a number of data transforms is to be performed (e.g., no data transform, swizzle, broadcast).</p><p id="p-0049" num="0048">In the case of a memory access <b>120</b> instruction template of class A, the alpha field <b>152</b> is interpreted as an eviction hint field <b>1526</b>, whose content distinguishes which one of the eviction hints is to be used (in <figref idref="DRAWINGS">FIG. <b>1</b>A</figref>, temporal <b>1526</b>.<b>1</b> and non-temporal <b>1526</b>.<b>2</b> are respectively specified for the memory access, temporal <b>125</b> instruction template and the memory access, non-temporal <b>130</b> instruction template), while the beta field <b>154</b> is interpreted as a data manipulation field <b>154</b>C, whose content distinguishes which one of a number of data manipulation operations (also known as primitives) is to be performed (e.g., no manipulation; broadcast; up conversion of a source; and down conversion of a destination). The memory access <b>120</b> instruction templates include the scale field <b>160</b>, and optionally the displacement field <b>162</b>A or the displacement scale field <b>1626</b>.</p><p id="p-0050" num="0049">Vector memory instructions perform vector loads from and vector stores to memory, with conversion support. As with regular vector instructions, vector memory instructions transfer data from/to memory in a data element-wise fashion, with the elements that are actually transferred is dictated by the contents of the vector mask that is selected as the write mask.</p><heading id="h-0011" level="2">Memory Access Instruction Templates&#x2014;Temporal</heading><p id="p-0051" num="0050">Temporal data is data likely to be reused soon enough to benefit from caching. This is, however, a hint, and different processors may implement it in different ways, including ignoring the hint entirely.</p><heading id="h-0012" level="2">Memory Access Instruction Templates&#x2014;Non-Temporal</heading><p id="p-0052" num="0051">Non-temporal data is data unlikely to be reused soon enough to benefit from caching in the 1st-level cache and should be given priority for eviction. This is, however, a hint, and different processors may implement it in different ways, including ignoring the hint entirely.</p><heading id="h-0013" level="2">Instruction Templates of Class B</heading><p id="p-0053" num="0052">In the case of the instruction templates of class B, the alpha field <b>152</b> is interpreted as a write mask control (Z) field <b>152</b>C, whose content distinguishes whether the write masking controlled by the write mask field <b>170</b> should be a merging or a zeroing.</p><p id="p-0054" num="0053">In the case of the non-memory access <b>105</b> instruction templates of class B, part of the beta field <b>154</b> is interpreted as an RL field <b>157</b>A, whose content distinguishes which one of the different augmentation operation types are to be performed (e.g., round <b>157</b>A.<b>1</b> and vector length (VSIZE) <b>157</b>A.<b>2</b> are respectively specified for the no memory access, write mask control, partial round control type operation <b>112</b> instruction template and the no memory access, write mask control, VSIZE type operation <b>117</b> instruction template), while the rest of the beta field <b>154</b> distinguishes which of the operations of the specified type is to be performed. In the no memory access <b>105</b> instruction templates, the scale field <b>160</b>, the displacement field <b>162</b>A, and the displacement scale filed <b>162</b>B are not present.</p><p id="p-0055" num="0054">In the no memory access, write mask control, partial round control type operation <b>110</b> instruction template, the rest of the beta field <b>154</b> is interpreted as a round operation field <b>159</b>A and exception event reporting is disabled (a given instruction does not report any kind of floating-point exception flag and does not raise any floating point exception handler).</p><p id="p-0056" num="0055">Round operation control field <b>159</b>A&#x2014;just as round operation control field <b>158</b>, its content distinguishes which one of a group of rounding operations to perform (e.g., Round-up, Round-down, Round-towards-zero and Round-to-nearest). Thus, the round operation control field <b>159</b>A allows for the changing of the rounding mode on a per instruction basis. In one embodiment of the invention where a processor includes a control register for specifying rounding modes, the round operation control field's <b>150</b> content overrides that register value.</p><p id="p-0057" num="0056">In the no memory access, write mask control, VSIZE type operation <b>117</b> instruction template, the rest of the beta field <b>154</b> is interpreted as a vector length field <b>159</b>B, whose content distinguishes which one of a number of data vector lengths is to be performed on (e.g., 128, 256, or 512 byte).</p><p id="p-0058" num="0057">In the case of a memory access <b>120</b> instruction template of class B, part of the beta field <b>154</b> is interpreted as a broadcast field <b>157</b>B, whose content distinguishes whether or not the broadcast type data manipulation operation is to be performed, while the rest of the beta field <b>154</b> is interpreted the vector length field <b>159</b>B. The memory access <b>120</b> instruction templates include the scale field <b>160</b>, and optionally the displacement field <b>162</b>A or the displacement scale field <b>162</b>B.</p><p id="p-0059" num="0058">With regard to the generic vector friendly instruction format <b>100</b>, a full opcode field <b>174</b> is shown including the format field <b>140</b>, the base operation field <b>142</b>, and the data element width field <b>164</b>. While one embodiment is shown where the full opcode field <b>174</b> includes all of these fields, the full opcode field <b>174</b> includes less than all of these fields in embodiments that do not support all of them. The full opcode field <b>174</b> provides the operation code (opcode).</p><p id="p-0060" num="0059">The augmentation operation field <b>150</b>, the data element width field <b>164</b>, and the write mask field <b>170</b> allow these features to be specified on a per instruction basis in the generic vector friendly instruction format.</p><p id="p-0061" num="0060">The combination of write mask field and data element width field create typed instructions in that they allow the mask to be applied based on different data element widths.</p><p id="p-0062" num="0061">The various instruction templates found within class A and class B are beneficial in different situations. In some embodiments of the invention, different processors or different cores within a processor may support only class A, only class B, or both classes. For instance, a high performance general purpose out-of-order core intended for general-purpose computing may support only class B, a core intended primarily for graphics and/or scientific (throughput) computing may support only class A, and a core intended for both may support both (of course, a core that has some mix of templates and instructions from both classes but not all templates and instructions from both classes is within the purview of the invention). Also, a single processor may include multiple cores, all of which support the same class or in which different cores support different class. For instance, in a processor with separate graphics and general purpose cores, one of the graphics cores intended primarily for graphics and/or scientific computing may support only class A, while one or more of the general purpose cores may be high performance general purpose cores with out of order execution and register renaming intended for general-purpose computing that support only class B. Another processor that does not have a separate graphics core, may include one more general purpose in-order or out-of-order cores that support both class A and class B. Of course, features from one class may also be implement in the other class in different embodiments of the invention. Programs written in a high level language would be put (e.g., just in time compiled or statically compiled) into an variety of different executable forms, including: 1) a form having only instructions of the class(es) supported by the target processor for execution; or 2) a form having alternative routines written using different combinations of the instructions of all classes and having control flow code that selects the routines to execute based on the instructions supported by the processor which is currently executing the code.</p><heading id="h-0014" level="2">VEX Instruction Format</heading><p id="p-0063" num="0062">VEX encoding allows instructions to have more than two operands, and allows SIMD vector registers to be longer than 28 bits. The use of a VEX prefix provides for three-operand (or more) syntax. For example, previous two-operand instructions performed operations such as A=A+B, which overwrites a source operand. The use of a VEX prefix enables operands to perform nondestructive operations such as A=B+C.</p><p id="p-0064" num="0063"><figref idref="DRAWINGS">FIG. <b>2</b>A</figref> illustrates an exemplary AVX instruction format including a VEX prefix <b>202</b>, real opcode field <b>230</b>, Mod R/M byte <b>240</b>, SIB byte <b>250</b>, displacement field <b>262</b>, and IMM8 <b>272</b>. <figref idref="DRAWINGS">FIG. <b>2</b>B</figref> illustrates which fields from <figref idref="DRAWINGS">FIG. <b>2</b>A</figref> make up a full opcode field <b>274</b> and a base operation field <b>241</b>. <figref idref="DRAWINGS">FIG. <b>2</b>C</figref> illustrates which fields from <figref idref="DRAWINGS">FIG. <b>2</b>A</figref> make up a register index field <b>244</b>.</p><p id="p-0065" num="0064">VEX Prefix (Bytes <b>0</b>-<b>2</b>) <b>202</b> is encoded in a three-byte form. The first byte is the Format Field <b>290</b> (VEX Byte <b>0</b>, bits [<b>7</b>:<b>0</b>]), which contains an explicit C4 byte value (the unique value used for distinguishing the C4 instruction format). The second-third bytes (VEX Bytes <b>1</b>-<b>2</b>) include a number of bit fields providing specific capability. Specifically, REX field <b>205</b> (VEX Byte <b>1</b>, bits [<b>7</b>-<b>5</b>]) consists of a VEX.R bit field (VEX Byte <b>1</b>, bit [<b>7</b>]-R), VEX.X bit field (VEX byte <b>1</b>, bit [<b>6</b>]-X), and VEX.B bit field (VEX byte <b>1</b>, bit[<b>5</b>]-B). Other fields of the instructions encode the lower three bits of the register indexes as is known in the art (rrr, xxx, and bbb), so that Rrrr, Xxxx, and Bbbb may be formed by adding VEX.R, VEX.X, and VEX.B. Opcode map field <b>215</b> (VEX byte <b>1</b>, bits [<b>4</b>:<b>0</b>]-mmmmm) includes content to encode an implied leading opcode byte. W Field <b>264</b> (VEX byte <b>2</b>, bit [<b>7</b>]-W)&#x2014;is represented by the notation VEX.W, and provides different functions depending on the instruction. The role of VEX.vvvv <b>220</b> (VEX Byte <b>2</b>, bits [<b>6</b>:<b>3</b>]-vvvv) may include the following: 1) VEX.vvvv encodes the first source register operand, specified in inverted (1s complement) form and is valid for instructions with 2 or more source operands; 2) VEX.vvvv encodes the destination register operand, specified in 1s complement form for certain vector shifts; or 3) VEX.vvvv does not encode any operand, the field is reserved and should contain <b>1111</b><i>b</i>. If VEX.L 268 Size field (VEX byte <b>2</b>, bit [<b>2</b>]-L)=0, it indicates 28 bit vector; if VEX.L=1, it indicates 256 bit vector. Prefix encoding field <b>225</b> (VEX byte <b>2</b>, bits [<b>1</b>:<b>0</b>]-pp) provides additional bits for the base operation field <b>241</b>.</p><p id="p-0066" num="0065">Real Opcode Field <b>230</b> (Byte <b>3</b>) is also known as the opcode byte. Part of the opcode is specified in this field.</p><p id="p-0067" num="0066">MOD R/M Field <b>240</b> (Byte <b>4</b>) includes MOD field <b>242</b> (bits [<b>7</b>-<b>6</b>]), Reg field <b>244</b> (bits [<b>5</b>-<b>3</b>]), and R/M field <b>246</b> (bits [<b>2</b>-<b>0</b>]). The role of Reg field <b>244</b> may include the following: encoding either the destination register operand or a source register operand (the rrr of Rrrr), or be treated as an opcode extension and not used to encode any instruction operand. The role of R/M field <b>246</b> may include the following: encoding the instruction operand that references a memory address, or encoding either the destination register operand or a source register operand.</p><p id="p-0068" num="0067">Scale, Index, Base (SIB)&#x2014;The content of Scale field <b>250</b> (Byte <b>5</b>) includes SS<b>252</b> (bits [<b>7</b>-<b>6</b>]), which is used for memory address generation. The contents of SIB.xxx <b>254</b> (bits [<b>5</b>-<b>3</b>]) and SIB.bbb <b>256</b> (bits [<b>2</b>-<b>0</b>]) have been previously referred to with regard to the register indexes Xxxx and Bbbb.</p><p id="p-0069" num="0068">The Displacement Field <b>262</b> and the immediate field (IMM8) <b>272</b> contain data.</p><heading id="h-0015" level="2">Exemplary Register Architecture</heading><p id="p-0070" num="0069"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a block diagram of a register architecture <b>300</b> according to one embodiment of the invention. In the embodiment illustrated, there are 32 vector registers <b>310</b> that are 512 bits wide; these registers are referenced as zmm0 through zmm31. The lower order 256 bits of the lower 6 zmm registers are overlaid on registers ymm0-15. The lower order 128 bits of the lower 6 zmm registers (the lower order 128 bits of the ymm registers) are overlaid on registers xmm0-15.</p><p id="p-0071" num="0070">General-purpose registers <b>325</b>&#x2014;in the embodiment illustrated, there are sixteen 64-bit general-purpose registers that are used along with the existing x86 addressing modes to address memory operands. These registers are referenced by the names RAX, RBX, RCX, RDX, RBP, RSI, RDI, RSP, and R8 through R15.</p><p id="p-0072" num="0071">Scalar floating point stack register file (x87 stack) <b>345</b>, on which is aliased the MMX packed integer flat register file <b>350</b>&#x2014;in the embodiment illustrated, the x87 stack is an eight-element stack used to perform scalar floating-point operations on 32/64/80-bit floating point data using the x87 instruction set extension; while the MMX registers are used to perform operations on 64-bit packed integer data, as well as to hold operands for some operations performed between the MMX and XMM registers.</p><p id="p-0073" num="0072">Alternative embodiments of the invention may use wider or narrower registers. Additionally, alternative embodiments of the invention may use more, less, or different register files and registers.</p><heading id="h-0016" level="2">Exemplary Core Architectures, Processors, and Computer Architectures</heading><p id="p-0074" num="0073">Processor cores may be implemented in different ways, for different purposes, and in different processors. For instance, implementations of such cores may include: 1) a general purpose in-order core intended for general-purpose computing; 2) a high performance general purpose out-of-order core intended for general-purpose computing; 3) a special purpose core intended primarily for graphics and/or scientific (throughput) computing. Implementations of different processors may include: 1) a CPU including one or more general purpose in-order cores intended for general-purpose computing and/or one or more general purpose out-of-order cores intended for general-purpose computing; and 2) a coprocessor including one or more special purpose cores intended primarily for graphics and/or scientific (throughput). Such different processors lead to different computer system architectures, which may include: 1) the coprocessor on a separate chip from the CPU; 2) the coprocessor on a separate die in the same package as a CPU; 3) the coprocessor on the same die as a CPU (in which case, such a coprocessor is sometimes referred to as special purpose logic, such as integrated graphics and/or scientific (throughput) logic, or as special purpose cores); and 4) a system on a chip that may include on the same die the described CPU (sometimes referred to as the application core(s) or application processor(s)), the above described coprocessor, and additional functionality. Exemplary core architectures are described next, followed by descriptions of exemplary processors and computer architectures. Detailed herein are circuits (units) that comprise exemplary cores, processors, etc.</p><heading id="h-0017" level="2">Exemplary Core Architectures</heading><p id="p-0075" num="0074"><figref idref="DRAWINGS">FIG. <b>4</b>A</figref> is a block diagram illustrating both an exemplary in-order pipeline and an exemplary register renaming, out-of-order issue/execution pipeline according to embodiments of the invention. <figref idref="DRAWINGS">FIG. <b>4</b>B</figref> is a block diagram illustrating both an exemplary embodiment of an in-order architecture core and an exemplary register renaming, out-of-order issue/execution architecture core to be included in a processor according to embodiments of the invention. The solid lined boxes in <figref idref="DRAWINGS">FIGS. <b>4</b>A-B</figref> illustrate the in-order pipeline and in-order core, while the optional addition of the dashed lined boxes illustrates the register renaming, out-of-order issue/execution pipeline and core. Given that the in-order aspect is a subset of the out-of-order aspect, the out-of-order aspect will be described.</p><p id="p-0076" num="0075">In <figref idref="DRAWINGS">FIG. <b>4</b>A</figref>, a processor pipeline <b>400</b> includes a fetch stage <b>402</b>, a length decode stage <b>404</b>, a decode stage <b>406</b>, an allocation stage <b>408</b>, a renaming stage <b>410</b>, a scheduling (also known as a dispatch or issue) stage <b>412</b>, a register read/memory read stage <b>414</b>, an execute stage <b>416</b>, a write back/memory write stage <b>418</b>, an exception handling stage <b>422</b>, and a commit stage <b>424</b>.</p><p id="p-0077" num="0076"><figref idref="DRAWINGS">FIG. <b>4</b>B</figref> shows processor core <b>490</b> including a front end unit <b>430</b> coupled to an execution engine unit <b>450</b>, and both are coupled to a memory unit <b>470</b>. The core <b>490</b> may be a reduced instruction set computing (RISC) core, a complex instruction set computing (CISC) core, a very long instruction word (VLIW) core, or a hybrid or alternative core type. As yet another option, the core <b>490</b> may be a special-purpose core, such as, for example, a network or communication core, compression engine, coprocessor core, general purpose computing graphics processing unit (GPGPU) core, graphics core, or the like.</p><p id="p-0078" num="0077">The front end unit <b>430</b> includes a branch prediction unit <b>432</b> coupled to an instruction cache unit <b>434</b>, which is coupled to an instruction translation lookaside buffer (TLB) <b>436</b>, which is coupled to an instruction fetch unit <b>438</b>, which is coupled to a decode unit <b>440</b>. The decode unit <b>440</b> (or decoder) may decode instructions, and generate as an output one or more micro-operations, micro-code entry points, microinstructions, other instructions, or other control signals, which are decoded from, or which otherwise reflect, or are derived from, the original instructions. The decode unit <b>440</b> may be implemented using various different mechanisms. Examples of suitable mechanisms include, but are not limited to, look-up tables, hardware implementations, programmable logic arrays (PLAs), microcode read only memories (ROMs), etc. In one embodiment, the core <b>490</b> includes a microcode ROM or other medium that stores microcode for certain macroinstructions (e.g., in decode unit <b>440</b> or otherwise within the front end unit <b>430</b>). The decode unit <b>440</b> is coupled to a rename/allocator unit <b>452</b> in the execution engine unit <b>450</b>.</p><p id="p-0079" num="0078">The execution engine unit <b>450</b> includes the rename/allocator unit <b>452</b> coupled to a retirement unit <b>454</b> and a set of one or more scheduler unit(s) <b>456</b>. The scheduler unit(s) <b>456</b> represents any number of different schedulers, including reservations stations, central instruction window, etc. The scheduler unit(s) <b>456</b> is coupled to the physical register file(s) unit(s) <b>458</b>. Each of the physical register file(s) units <b>458</b> represents one or more physical register files, different ones of which store one or more different data types, such as scalar integer, scalar floating point, packed integer, packed floating point, vector integer, vector floating point, status (e.g., an instruction pointer that is the address of the next instruction to be executed), etc. In one embodiment, the physical register file(s) unit <b>458</b> comprises a vector registers unit and a scalar registers unit. These register units may provide architectural vector registers, vector mask registers, and general purpose registers. The physical register file(s) unit(s) <b>458</b> is overlapped by the retirement unit <b>454</b> to illustrate various ways in which register renaming and out-of-order execution may be implemented (e.g., using a reorder buffer(s) and a retirement register file(s); using a future file(s), a history buffer(s), and a retirement register file(s); using a register maps and a pool of registers; etc.). The retirement unit <b>454</b> and the physical register file(s) unit(s) <b>458</b> are coupled to the execution cluster(s) <b>460</b>. The execution cluster(s) <b>460</b> includes a set of one or more execution units <b>462</b> and a set of one or more memory access units <b>464</b>. The execution units <b>462</b> may perform various operations (e.g., shifts, addition, subtraction, multiplication) and on various types of data (e.g., scalar floating point, packed integer, packed floating point, vector integer, vector floating point). While some embodiments may include a number of execution units dedicated to specific functions or sets of functions, other embodiments may include only one execution unit or multiple execution units that all perform all functions. The scheduler unit(s) <b>456</b>, physical register file(s) unit(s) <b>458</b>, and execution cluster(s) <b>460</b> are shown as being possibly plural because certain embodiments create separate pipelines for certain types of data/operations (e.g., a scalar integer pipeline, a scalar floating point/packed integer/packed floating point/vector integer/vector floating point pipeline, and/or a memory access pipeline that each have their own scheduler unit, physical register file(s) unit, and/or execution cluster&#x2014;and in the case of a separate memory access pipeline, certain embodiments are implemented in which only the execution cluster of this pipeline has the memory access unit(s) <b>464</b>). It should also be understood that where separate pipelines are used, one or more of these pipelines may be out-of-order issue/execution and the rest in-order.</p><p id="p-0080" num="0079">The set of memory access units <b>464</b> is coupled to the memory unit <b>470</b>, which includes a data TLB unit <b>472</b> coupled to a data cache unit <b>474</b> coupled to a level 2 (L2) cache unit <b>476</b>. In one exemplary embodiment, the memory access units <b>464</b> may include a load unit, a store address unit, and a store data unit, each of which is coupled to the data TLB unit <b>472</b> in the memory unit <b>470</b>. The instruction cache unit <b>434</b> is further coupled to a level 2 (L2) cache unit <b>476</b> in the memory unit <b>470</b>. The L2 cache unit <b>476</b> is coupled to one or more other levels of cache and eventually to a main memory.</p><p id="p-0081" num="0080">By way of example, the exemplary register renaming, out-of-order issue/execution core architecture may implement the pipeline <b>400</b> as follows: 1) the instruction fetch <b>438</b> performs the fetch and length decoding stages <b>402</b> and <b>404</b>; 2) the decode unit <b>440</b> performs the decode stage <b>406</b>; 3) the rename/allocator unit <b>452</b> performs the allocation stage <b>408</b> and renaming stage <b>410</b>; 4) the scheduler unit(s) <b>456</b> performs the schedule stage <b>412</b>; 5) the physical register file(s) unit(s) <b>458</b> and the memory unit <b>470</b> perform the register read/memory read stage <b>414</b>; the execution cluster <b>460</b> perform the execute stage <b>416</b>; 6) the memory unit <b>470</b> and the physical register file(s) unit(s) <b>458</b> perform the write back/memory write stage <b>418</b>; 7) various units may be involved in the exception handling stage <b>422</b>; and 8) the retirement unit <b>454</b> and the physical register file(s) unit(s) <b>458</b> perform the commit stage <b>424</b>.</p><p id="p-0082" num="0081">The core <b>490</b> may support one or more instructions sets (e.g., the x86 instruction set (with some extensions that have been added with newer versions); the MIPS instruction set of MIPS Technologies of Sunnyvale, Calif.; the ARM instruction set (with optional additional extensions such as NEON) of ARM Holdings of Sunnyvale, Calif.), including the instruction(s) described herein. In one embodiment, the core <b>490</b> includes logic to support a packed data instruction set extension (e.g., AVX1, AVX2), thereby allowing the operations used by many multimedia applications to be performed using packed data.</p><p id="p-0083" num="0082">It should be understood that the core may support multithreading (executing two or more parallel sets of operations or threads), and may do so in a variety of ways including time sliced multithreading, simultaneous multithreading (where a single physical core provides a logical core for each of the threads that physical core is simultaneously multithreading), or a combination thereof (e.g., time sliced fetching and decoding and simultaneous multithreading thereafter such as in the Intel&#xae; Hyperthreading technology).</p><p id="p-0084" num="0083">While register renaming is described in the context of out-of-order execution, it should be understood that register renaming may be used in an in-order architecture. While the illustrated embodiment of the processor also includes separate instruction and data cache units <b>434</b>/<b>474</b> and a shared L2 cache unit <b>476</b>, alternative embodiments may have a single internal cache for both instructions and data, such as, for example, a Level 1 (L1) internal cache, or multiple levels of internal cache. In some embodiments, the system may include a combination of an internal cache and an external cache that is external to the core and/or the processor. Alternatively, all of the cache may be external to the core and/or the processor.</p><heading id="h-0018" level="2">Specific Exemplary In-Order Core Architecture</heading><p id="p-0085" num="0084"><figref idref="DRAWINGS">FIGS. <b>5</b>A-B</figref> illustrate a block diagram of a more specific exemplary in-order core architecture, which core would be one of several logic blocks (including other cores of the same type and/or different types) in a chip. The logic blocks communicate through a high-bandwidth interconnect network (e.g., a ring network) with some fixed function logic, memory I/O interfaces, and other necessary I/O logic, depending on the application.</p><p id="p-0086" num="0085"><figref idref="DRAWINGS">FIG. <b>5</b>A</figref> is a block diagram of a single processor core, along with its connection to the on-die interconnect network <b>502</b> and with its local subset of the Level 2 (L2) cache <b>504</b>, according to embodiments of the invention. In one embodiment, an instruction decoder <b>500</b> supports the x86 instruction set with a packed data instruction set extension. An L1 cache <b>506</b> allows low-latency accesses to cache memory into the scalar and vector units. While in one embodiment (to simplify the design), a scalar unit <b>508</b> and a vector unit <b>510</b> use separate register sets (respectively, scalar registers <b>512</b> and vector registers <b>514</b>) and data transferred between them is written to memory and then read back in from a level 1 (L1) cache <b>506</b>, alternative embodiments of the invention may use a different approach (e.g., use a single register set or include a communication path that allow data to be transferred between the two register files without being written and read back).</p><p id="p-0087" num="0086">The local subset of the L2 cache <b>504</b> is part of a global L2 cache that is divided into separate local subsets, one per processor core. Each processor core has a direct access path to its own local subset of the L2 cache <b>504</b>. Data read by a processor core is stored in its L2 cache subset <b>504</b> and can be accessed quickly, in parallel with other processor cores accessing their own local L2 cache subsets. Data written by a processor core is stored in its own L2 cache subset <b>504</b> and is flushed from other subsets, if necessary. The ring network ensures coherency for shared data. The ring network is bi-directional to allow agents such as processor cores, L2 caches and other logic blocks to communicate with each other within the chip. Each ring data-path is 1024-bits wide per direction in some embodiments.</p><p id="p-0088" num="0087"><figref idref="DRAWINGS">FIG. <b>5</b>B</figref> is an expanded view of part of the processor core in <figref idref="DRAWINGS">FIG. <b>5</b>A</figref> according to embodiments of the invention. <figref idref="DRAWINGS">FIG. <b>5</b>B</figref> includes an L1 data cache <b>506</b>A part of the L1 cache <b>504</b>, as well as more detail regarding the vector unit <b>510</b> and the vector registers <b>514</b>. Specifically, the vector unit <b>510</b> is a 6-wide vector processing unit (VPU) (see the 16-wide ALU <b>528</b>), which executes one or more of integer, single-precision float, and double-precision float instructions. The VPU supports swizzling the register inputs with swizzle unit <b>520</b>, numeric conversion with numeric convert units <b>522</b>A-B, and replication with replication unit <b>524</b> on the memory input.</p><p id="p-0089" num="0000">Processor with Integrated Memory Controller and Graphics</p><p id="p-0090" num="0088"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a block diagram of a processor <b>600</b> that may have more than one core, may have an integrated memory controller, and may have integrated graphics according to embodiments of the invention. The solid lined boxes in <figref idref="DRAWINGS">FIG. <b>6</b></figref> illustrate a processor <b>600</b> with a single core <b>602</b>A, a system agent <b>610</b>, a set of one or more bus controller units <b>616</b>, while the optional addition of the dashed lined boxes illustrates an alternative processor <b>600</b> with multiple cores <b>602</b>A-N, a set of one or more integrated memory controller unit(s) <b>614</b> in the system agent unit <b>610</b>, and special purpose logic <b>608</b>.</p><p id="p-0091" num="0089">Thus, different implementations of the processor <b>600</b> may include: 1) a CPU with the special purpose logic <b>608</b> being integrated graphics and/or scientific (throughput) logic (which may include one or more cores), and the cores <b>602</b>A-N being one or more general purpose cores (e.g., general purpose in-order cores, general purpose out-of-order cores, a combination of the two); 2) a coprocessor with the cores <b>602</b>A-N being a large number of special purpose cores intended primarily for graphics and/or scientific (throughput); and 3) a coprocessor with the cores <b>602</b>A-N being a large number of general purpose in-order cores. Thus, the processor <b>600</b> may be a general-purpose processor, coprocessor or special-purpose processor, such as, for example, a network or communication processor, compression engine, graphics processor, GPGPU (general purpose graphics processing unit), a high-throughput many integrated core (MIC) coprocessor (including 30 or more cores), embedded processor, or the like. The processor may be implemented on one or more chips. The processor <b>600</b> may be a part of and/or may be implemented on one or more substrates using any of a number of process technologies, such as, for example, BiCMOS, CMOS, or NMOS.</p><p id="p-0092" num="0090">The memory hierarchy includes one or more levels of cache within the cores <b>604</b>A-N, a set or one or more shared cache units <b>606</b>, and external memory (not shown) coupled to the set of integrated memory controller units <b>614</b>. The set of shared cache units <b>606</b> may include one or more mid-level caches, such as level 2 (L2), level 3 (L3), level 4 (L4), or other levels of cache, a last level cache (LLC), and/or combinations thereof. While in one embodiment a ring based interconnect unit <b>612</b> interconnects the integrated graphics logic <b>608</b>, the set of shared cache units <b>606</b>, and the system agent unit <b>610</b>/integrated memory controller unit(s) <b>614</b>, alternative embodiments may use any number of well-known techniques for interconnecting such units. In one embodiment, coherency is maintained between one or more cache units <b>606</b> and cores <b>602</b>-A-N.</p><p id="p-0093" num="0091">In some embodiments, one or more of the cores <b>602</b>A-N are capable of multi-threading. The system agent <b>610</b> includes those components coordinating and operating cores <b>602</b>A-N. The system agent unit <b>610</b> may include for example a power control unit (PCU) and a display unit. The PCU may be or include logic and components needed for regulating the power state of the cores <b>602</b>A-N and the integrated graphics logic <b>608</b>. The display unit is for driving one or more externally connected displays.</p><p id="p-0094" num="0092">The cores <b>602</b>A-N may be homogenous or heterogeneous in terms of architecture instruction set; that is, two or more of the cores <b>602</b>A-N may be capable of execution the same instruction set, while others may be capable of executing only a subset of that instruction set or a different instruction set.</p><heading id="h-0019" level="2">Exemplary Computer Architectures</heading><p id="p-0095" num="0093"><figref idref="DRAWINGS">FIGS. <b>7</b>-<b>10</b></figref> are block diagrams of exemplary computer architectures. Other system designs and configurations known in the arts for laptops, desktops, handheld PCs, personal digital assistants, engineering workstations, servers, network devices, network hubs, switches, embedded processors, digital signal processors (DSPs), graphics devices, video game devices, set-top boxes, micro controllers, cell phones, portable media players, hand held devices, and various other electronic devices, are also suitable. In general, a huge variety of systems or electronic devices capable of incorporating a processor and/or other execution logic as disclosed herein are generally suitable.</p><p id="p-0096" num="0094">Referring now to <figref idref="DRAWINGS">FIG. <b>7</b></figref>, shown is a block diagram of a system <b>700</b> in accordance with one embodiment of the present invention. The system <b>700</b> may include one or more processors <b>710</b>, <b>715</b>, which are coupled to a controller hub <b>720</b>. In one embodiment, the controller hub <b>720</b> includes a graphics memory controller hub (GMCH) <b>790</b> and an Input/Output Hub (IOH) <b>750</b> (which may be on separate chips); the GMCH <b>790</b> includes memory and graphics controllers to which are coupled memory <b>740</b> and a coprocessor <b>745</b>; the IOH <b>750</b> is couples input/output (I/O) devices <b>760</b> to the GMCH <b>790</b>. Alternatively, one or both of the memory and graphics controllers are integrated within the processor (as described herein), the memory <b>740</b> and the coprocessor <b>745</b> are coupled directly to the processor <b>710</b>, and the controller hub <b>720</b> in a single chip with the IOH <b>750</b>.</p><p id="p-0097" num="0095">The optional nature of additional processors <b>715</b> is denoted in <figref idref="DRAWINGS">FIG. <b>7</b></figref> with broken lines. Each processor <b>710</b>, <b>715</b> may include one or more of the processing cores described herein and may be some version of the processor <b>600</b>.</p><p id="p-0098" num="0096">The memory <b>740</b> may be, for example, dynamic random access memory (DRAM), phase change memory (PCM), or a combination of the two. For at least one embodiment, the controller hub <b>720</b> communicates with the processor(s) <b>710</b>, <b>715</b> via a multi-drop bus, such as a frontside bus (FSB), point-to-point interface, or similar connection <b>795</b>.</p><p id="p-0099" num="0097">In one embodiment, the coprocessor <b>745</b> is a special-purpose processor, such as, for example, a high-throughput MIC processor, a network or communication processor, compression engine, graphics processor, GPGPU, embedded processor, or the like. In one embodiment, controller hub <b>720</b> may include an integrated graphics accelerator.</p><p id="p-0100" num="0098">There can be a variety of differences between the physical resources <b>710</b>, <b>7155</b> in terms of a spectrum of metrics of merit including architectural, microarchitectural, thermal, power consumption characteristics, and the like.</p><p id="p-0101" num="0099">In one embodiment, the processor <b>710</b> executes instructions that control data processing operations of a general type. Embedded within the instructions may be coprocessor instructions. The processor <b>710</b> recognizes these coprocessor instructions as being of a type that should be executed by the attached coprocessor <b>745</b>. Accordingly, the processor <b>710</b> issues these coprocessor instructions (or control signals representing coprocessor instructions) on a coprocessor bus or other interconnect, to coprocessor <b>745</b>. Coprocessor(s) <b>745</b> accept and execute the received coprocessor instructions.</p><p id="p-0102" num="0100">Referring now to <figref idref="DRAWINGS">FIG. <b>8</b></figref>, shown is a block diagram of a first more specific exemplary system <b>800</b> in accordance with an embodiment of the present invention. As shown in <figref idref="DRAWINGS">FIG. <b>8</b></figref>, multiprocessor system <b>800</b> is a point-to-point interconnect system, and includes a first processor <b>870</b> and a second processor <b>880</b> coupled via a point-to-point interconnect <b>850</b>. Each of processors <b>870</b> and <b>880</b> may be some version of the processor <b>600</b>. In one embodiment of the invention, processors <b>870</b> and <b>880</b> are respectively processors <b>710</b> and <b>715</b>, while coprocessor <b>838</b> is coprocessor <b>745</b>. In another embodiment, processors <b>870</b> and <b>880</b> are respectively processor <b>710</b> coprocessor <b>745</b>.</p><p id="p-0103" num="0101">Processors <b>870</b> and <b>880</b> are shown including integrated memory controller (IMC) units <b>872</b> and <b>882</b>, respectively. Processor <b>870</b> also includes as part of its bus controller units point-to-point (P-P) interfaces <b>876</b> and <b>878</b>; similarly, second processor <b>880</b> includes P-P interfaces <b>886</b> and <b>888</b>. Processors <b>870</b>, <b>880</b> may exchange information via a point-to-point (P-P) interface <b>850</b> using P-P interface circuits <b>878</b>, <b>888</b>. As shown in <figref idref="DRAWINGS">FIG. <b>8</b></figref>, IMCs <b>872</b> and <b>882</b> couple the processors to respective memories, namely a memory <b>832</b> and a memory <b>834</b>, which may be portions of main memory locally attached to the respective processors.</p><p id="p-0104" num="0102">Processors <b>870</b>, <b>880</b> may each exchange information with a chipset <b>890</b> via individual P-P interfaces <b>852</b>, <b>854</b> using point to point interface circuits <b>876</b>, <b>894</b>, <b>886</b>, <b>898</b>. Chipset <b>890</b> may optionally exchange information with the coprocessor <b>838</b> via a high-performance interface <b>892</b>. In one embodiment, the coprocessor <b>838</b> is a special-purpose processor, such as, for example, a high-throughput MIC processor, a network or communication processor, compression engine, graphics processor, GPGPU, embedded processor, or the like.</p><p id="p-0105" num="0103">A shared cache (not shown) may be included in either processor or outside of both processors, yet connected with the processors via P-P interconnect, such that either or both processors' local cache information may be stored in the shared cache if a processor is placed into a low power mode.</p><p id="p-0106" num="0104">Chipset <b>890</b> may be coupled to a first bus <b>816</b> via an interface <b>896</b>. In one embodiment, first bus <b>816</b> may be a Peripheral Component Interconnect (PCI) bus, or a bus such as a PCI Express bus or another I/O interconnect bus, although the scope of the present invention is not so limited.</p><p id="p-0107" num="0105">As shown in <figref idref="DRAWINGS">FIG. <b>8</b></figref>, various I/O devices <b>814</b> may be coupled to first bus <b>816</b>, along with a bus bridge <b>818</b> which couples first bus <b>816</b> to a second bus <b>820</b>. In one embodiment, one or more additional processor(s) <b>815</b>, such as coprocessors, high-throughput MIC processors, GPGPU's, accelerators (such as, e.g., graphics accelerators or digital signal processing (DSP) units), field programmable gate arrays, or any other processor, are coupled to first bus <b>816</b>. In one embodiment, second bus <b>820</b> may be a low pin count (LPC) bus. Various devices may be coupled to a second bus <b>820</b> including, for example, a keyboard and/or mouse <b>822</b>, communication devices <b>827</b> and a storage unit <b>828</b> such as a disk drive or other mass storage device which may include instructions/code and data <b>830</b>, in one embodiment. Further, an audio I/O <b>824</b> may be coupled to the second bus <b>816</b>. Note that other architectures are possible. For example, instead of the point-to-point architecture of <figref idref="DRAWINGS">FIG. <b>8</b></figref>, a system may implement a multi-drop bus or other such architecture.</p><p id="p-0108" num="0106">Referring now to <figref idref="DRAWINGS">FIG. <b>9</b></figref>, shown is a block diagram of a second more specific exemplary system <b>900</b> in accordance with an embodiment of the present invention. Like elements in <figref idref="DRAWINGS">FIGS. <b>8</b> and <b>9</b></figref> bear like reference numerals, and certain aspects of <figref idref="DRAWINGS">FIG. <b>8</b></figref> have been omitted from <figref idref="DRAWINGS">FIG. <b>9</b></figref> in order to avoid obscuring other aspects of <figref idref="DRAWINGS">FIG. <b>9</b></figref>.</p><p id="p-0109" num="0107"><figref idref="DRAWINGS">FIG. <b>9</b></figref> illustrates that the processors <b>870</b>, <b>880</b> may include integrated memory and I/O control logic (&#x201c;CL&#x201d;) <b>972</b> and <b>982</b>, respectively. Thus, the CL <b>972</b>, <b>982</b> include integrated memory controller units and include I/O control logic. <figref idref="DRAWINGS">FIG. <b>9</b></figref> illustrates that not only are the memories <b>832</b>, <b>834</b> coupled to the CL <b>872</b>, <b>882</b>, but also that I/O devices <b>914</b> are also coupled to the control logic <b>872</b>, <b>882</b>. Legacy I/O devices <b>915</b> are coupled to the chipset <b>890</b>.</p><p id="p-0110" num="0108">Referring now to <figref idref="DRAWINGS">FIG. <b>10</b></figref>, shown is a block diagram of a SoC <b>1000</b> in accordance with an embodiment of the present invention. Similar elements in <figref idref="DRAWINGS">FIG. <b>6</b></figref> bear like reference numerals. Also, dashed lined boxes are optional features on more advanced SoCs. In <figref idref="DRAWINGS">FIG. <b>10</b></figref>, an interconnect unit(s) <b>1002</b> is coupled to: an application processor <b>1010</b> which includes a set of one or more cores <b>102</b>A-N, cache units <b>604</b>A-N, and shared cache unit(s) <b>606</b>; a system agent unit <b>610</b>; a bus controller unit(s) <b>616</b>; an integrated memory controller unit(s) <b>614</b>; a set or one or more coprocessors <b>1020</b> which may include integrated graphics logic, an image processor, an audio processor, and a video processor; an static random access memory (SRAM) unit <b>1030</b>; a direct memory access (DMA) unit <b>1032</b>; and a display unit <b>1040</b> for coupling to one or more external displays. In one embodiment, the coprocessor(s) <b>1020</b> include a special-purpose processor, such as, for example, a network or communication processor, compression engine, GPGPU, a high-throughput MIC processor, embedded processor, or the like.</p><p id="p-0111" num="0109">Embodiments of the mechanisms disclosed herein may be implemented in hardware, software, firmware, or a combination of such implementation approaches. Embodiments of the invention may be implemented as computer programs or program code executing on programmable systems comprising at least one processor, a storage system (including volatile and non-volatile memory and/or storage elements), at least one input device, and at least one output device.</p><p id="p-0112" num="0110">Program code, such as code <b>830</b> illustrated in <figref idref="DRAWINGS">FIG. <b>8</b></figref>, may be applied to input instructions to perform the functions described herein and generate output information. The output information may be applied to one or more output devices, in known fashion. For purposes of this application, a processing system includes any system that has a processor, such as, for example; a digital signal processor (DSP), a microcontroller, an application specific integrated circuit (ASIC), or a microprocessor.</p><p id="p-0113" num="0111">The program code may be implemented in a high level procedural or object oriented programming language to communicate with a processing system. The program code may also be implemented in assembly or machine language, if desired. In fact, the mechanisms described herein are not limited in scope to any particular programming language. In any case, the language may be a compiled or interpreted language.</p><p id="p-0114" num="0112">One or more aspects of at least one embodiment may be implemented by representative instructions stored on a machine-readable medium which represents various logic within the processor, which when read by a machine causes the machine to fabricate logic to perform the techniques described herein. Such representations, known as &#x201c;IP cores&#x201d; may be stored on a tangible, machine readable medium and supplied to various customers or manufacturing facilities to load into the fabrication machines that actually make the logic or processor.</p><p id="p-0115" num="0113">Such machine-readable storage media may include, without limitation, non-transitory, tangible arrangements of articles manufactured or formed by a machine or device, including storage media such as hard disks, any other type of disk including floppy disks, optical disks, compact disk read-only memories (CD-ROMs), compact disk rewritable's (CD-RWs), and magneto-optical disks, semiconductor devices such as read-only memories (ROMs), random access memories (RAMs) such as dynamic random access memories (DRAMs), static random access memories (SRAMs), erasable programmable read-only memories (EPROMs), flash memories, electrically erasable programmable read-only memories (EEPROMs), phase change memory (PCM), magnetic or optical cards, or any other type of media suitable for storing electronic instructions.</p><p id="p-0116" num="0114">Accordingly, embodiments of the invention also include non-transitory, tangible machine-readable media containing instructions or containing design data, such as Hardware Description Language (HDL), which defines structures, circuits, apparatuses, processors and/or system features described herein. Such embodiments may also be referred to as program products. Emulation (including binary translation, code morphing, etc.)</p><p id="p-0117" num="0115">In some cases, an instruction converter may be used to convert an instruction from a source instruction set to a target instruction set. For example, the instruction converter may translate (e.g., using static binary translation, dynamic binary translation including dynamic compilation), morph, emulate, or otherwise convert an instruction to one or more other instructions to be processed by the core. The instruction converter may be implemented in software, hardware, firmware, or a combination thereof. The instruction converter may be on processor, off processor, or part on and part off processor.</p><p id="p-0118" num="0116"><figref idref="DRAWINGS">FIG. <b>11</b></figref> is a block diagram contrasting the use of a software instruction converter to convert binary instructions in a source instruction set to binary instructions in a target instruction set according to embodiments of the invention. In the illustrated embodiment, the instruction converter is a software instruction converter, although alternatively the instruction converter may be implemented in software, firmware, hardware, or various combinations thereof. <figref idref="DRAWINGS">FIG. <b>11</b></figref> shows a program in a high level language <b>1102</b> may be compiled using an first compiler <b>1104</b> to generate a first binary code (e.g., x86) <b>1106</b> that may be natively executed by a processor with at least one first instruction set core <b>1116</b>. In some embodiments, the processor with at least one first instruction set core <b>1116</b> represents any processor that can perform substantially the same functions as an Intel processor with at least one x86 instruction set core by compatibly executing or otherwise processing (1) a substantial portion of the instruction set of the Intel x86 instruction set core or (2) object code versions of applications or other software targeted to run on an Intel processor with at least one x86 instruction set core, in order to achieve substantially the same result as an Intel processor with at least one x86 instruction set core. The first compiler <b>1104</b> represents a compiler that is operable to generate binary code of the first instruction set <b>1106</b> (e.g., object code) that can, with or without additional linkage processing, be executed on the processor with at least one first instruction set core <b>1116</b>. Similarly, <figref idref="DRAWINGS">FIG. <b>11</b></figref> shows the program in the high level language <b>1102</b> may be compiled using an alternative instruction set compiler <b>1108</b> to generate alternative instruction set binary code <b>1110</b> that may be natively executed by a processor without at least one first instruction set core <b>1114</b> (e.g., a processor with cores that execute the MIPS instruction set of MIPS Technologies of Sunnyvale, Calif. and/or that execute the ARM instruction set of ARM Holdings of Sunnyvale, Calif.). The instruction converter <b>1112</b> is used to convert the first binary code <b>1106</b> into code that may be natively executed by the processor without an first instruction set core <b>1114</b>. This converted code is not likely to be the same as the alternative instruction set binary code <b>1110</b> because an instruction converter capable of this is difficult to make; however, the converted code will accomplish the general operation and be made up of instructions from the alternative instruction set. Thus, the instruction converter <b>1112</b> represents software, firmware, hardware, or a combination thereof that, through emulation, simulation or any other process, allows a processor or other electronic device that does not have a first instruction set processor or core to execute the first binary code <b>1106</b>.</p><heading id="h-0020" level="2">Apparatus and Method for Digital Signal Processing Instructions</heading><p id="p-0119" num="0117">Digital signal processing (DSP) instructions are described below. In one embodiment, the circuitry and logic to perform the DSP operations is integrated within the execution engine unit <b>450</b> shown in <figref idref="DRAWINGS">FIG. <b>4</b>B</figref>, within the various cores described above (see, e.g., cores <b>602</b>A-N in <figref idref="DRAWINGS">FIGS. <b>6</b> and <b>10</b></figref>), and/or within the vector unit <b>510</b> shown in <figref idref="DRAWINGS">FIG. <b>5</b>A</figref>. For example, the various source and destination registers may be SIMD registers within the physical register file unit(s) <b>458</b> in <figref idref="DRAWINGS">FIG. <b>4</b>B</figref> and/or vector registers <b>310</b> in <figref idref="DRAWINGS">FIG. <b>3</b></figref>. The multiplication circuits, adder circuits, accumulation circuits, and other circuitry described below may be integrated within the execution components of the architectures described above including, by way of example and not limitation, the execution unit(s) <b>462</b> in <figref idref="DRAWINGS">FIG. <b>4</b>B</figref>. It should be noted, however, that the underlying principles of the invention are not limited to these specific architectures.</p><p id="p-0120" num="0118">One embodiment of the invention includes circuitry and/or logic for processing digital signal processing (DSP) instructions. In particular, one embodiment comprises a multiply-accumulate (MAC) architecture with eight 16&#xd7;16-bit multipliers and two 64-bit accumulators. The instruction set architecture (ISA) described below can process various multiply and MAC operations on 128-bit packed (8-bit, 16-bit or 32-bit data elements) integer, fixed point and complex data types. In addition, certain instructions have direct support for highly efficient Fast Fourier Transform (FFT) and Finite Impulse Response (FIR) filtering, and post-processing of accumulated data by shift, round, and saturate operations.</p><p id="p-0121" num="0119">One embodiment of the new DSP instructions use a VEX.128 prefix based opcode encoding and several of the SSE/SSE2/AVX instructions that handle post-processing of data are used with the DSP ISA. The VEX-encoded 128-bit DSP instructions with memory operands may have relaxed memory alignment requirements.</p><p id="p-0122" num="0120">In one embodiment, the instructions also support a variety of integer and fixed point data types including:<ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0121">1) a Q31 data type for signals requiring analog to digital conversion (ADC) and digital to analog conversion (DAC) with greater than 16 bits;</li>        <li id="ul0002-0002" num="0122">2) a Q15 data type which is common in DSP algorithms;</li>        <li id="ul0002-0003" num="0123">3) a complex 16-bit data type; and</li>        <li id="ul0002-0004" num="0124">4) a complex 32-bit data type.</li>    </ul>    </li></ul></p><p id="p-0123" num="0125">The instruction set architecture described herein targets a wide range of standard DSP (e.g., FFT, filtering, pattern matching, correlation, polynomial evaluation, etc) and statistical operations (e.g., mean, moving average, variance, etc.).</p><p id="p-0124" num="0126">Target applications of the embodiments of the invention include sensor, audio, classification tasks for computer vision, and speech recognition. The DSP ISA described herein includes a wide range of instructions that are applicable to deep neural networks (DNN), automatic speech recognition (ASR), sensor fusion with Kalman filtering, other major DSP applications, etc. Given the sequence of weights {w<sub>1</sub>, w<sub>2</sub>, . . . w<sub>k</sub>} and the input sequence {x<sub>1</sub>, x<sub>2</sub>, x<sub>3</sub>, . . . x<sub>n</sub>} many image processing, machine learning tasks require to compute the result sequence {y<sub>1</sub>, y<sub>2</sub>, y<sub>3</sub>, . . . y<sub>n+1&#x2212;k</sub>} defined by y<sub>i</sub>=w<sub>1</sub>x<sub>i</sub>+w<sub>2</sub>x<sub>i+1</sub>+ . . . +w<sub>k</sub>x<sub>i+k&#x2212;1</sub>.</p><p id="p-0125" num="0127"><figref idref="DRAWINGS">FIG. <b>12</b></figref> illustrates an exemplary processor <b>1255</b> on which embodiments of the invention may be implemented which includes a plurality of cores 0-N for simultaneously executing a plurality of instruction threads. The illustrated embodiment includes DSP instruction decode circuitry/logic <b>1231</b> within the decoder <b>1230</b> and DSP instruction execution circuitry/logic <b>1341</b> within the execution unit <b>1240</b>. These pipeline components may perform the operations described herein responsive to the decoding and execution of the DSP instructions, such as the vector packed complex-by-complex and complex-by-complex-conjugate instructions (e.g., DVPCMULWRS, DVPCCMULWRS, etc.) described below. While details of only a single core (Core 0) are shown in <figref idref="DRAWINGS">FIG. <b>12</b></figref>, it will be understood that each of the other cores of processor <b>1255</b> may include similar components.</p><p id="p-0126" num="0128">Prior to describing specific details of the embodiments of the invention, a description of the various components of the exemplary processor <b>1255</b> are provided directly below. The plurality of cores 0-N may each include a memory management unit <b>1290</b> for performing memory operations (e.g., such as load/store operations), a set of general purpose registers (GPRs) <b>1205</b>, a set of vector registers <b>1206</b>, and a set of mask registers <b>1207</b>. In one embodiment, multiple vector data elements are packed into each vector register <b>1206</b> which may have a 512 bit width for storing two 256 bit values, four 128 bit values, eight 64 bit values, sixteen 32 bit values, etc. However, the underlying principles of the invention are not limited to any particular size/type of vector data. In one embodiment, the mask registers <b>1207</b> include eight 64-bit operand mask registers used for performing bit masking operations on the values stored in the vector registers <b>1206</b> (e.g., implemented as mask registers k0-k7 described herein). However, the underlying principles of the invention are not limited to any particular mask register size/type.</p><p id="p-0127" num="0129">Each core 0-N may include a dedicated Level 1 (L1) cache <b>1212</b> and Level 2 (L2) cache <b>1211</b> for caching instructions and data according to a specified cache management policy. The L1 cache <b>1212</b> includes a separate instruction cache <b>1220</b> for storing instructions and a separate data cache <b>1221</b> for storing data. The instructions and data stored within the various processor caches are managed at the granularity of cache lines which may be a fixed size (e.g., 64, 128, 512 Bytes in length). Each core of this exemplary embodiment has an instruction fetch unit <b>1210</b> for fetching instructions from main memory <b>1200</b> and/or a shared Level 3 (L3) cache <b>1216</b>. The instruction fetch unit <b>1210</b> includes various well known components including a next instruction pointer <b>1203</b> for storing the address of the next instruction to be fetched from memory <b>1200</b> (or one of the caches); an instruction translation look-aside buffer (ITLB) <b>1204</b> for storing a map of recently used virtual-to-physical instruction addresses to improve the speed of address translation; a branch prediction unit <b>1202</b> for speculatively predicting instruction branch addresses; and branch target buffers (BTBs) <b>1201</b> for storing branch addresses and target addresses.</p><p id="p-0128" num="0130">As mentioned, a decode unit <b>1230</b> includes DSP instruction decode circuitry/logic <b>1231</b> for decoding the DSP instructions described herein into micro-operatons or &#x201c;uops&#x201d; and the execution unit <b>1240</b> includes DSP instruction execution circuitry/logic <b>1241</b> for executing the DSP instructions. A writeback/retirement unit <b>1250</b> retires the executed instructions and writes back the results.</p><heading id="h-0021" level="2">Vector Packed Dual Complex-By-Complex and Dual Complex-by-Complex Conjugate Multiplication</heading><p id="p-0129" num="0131">In sensing and audio applications like Decimation In time (DIT) FFTs and Decimation in Frequency (DIF) FFTs that use 16-bit integer data types, complex-by-complex multiplication operations are extensively used. In sensing applications like Real FFT, angular rotation 16-bit integer data type complex-by-complex-conjugate multiplication operations are extensively used. However, to perform these complex operations with current available integer instructions, several clock cycles are required.</p><p id="p-0130" num="0132">One embodiment of the invention includes a set of vector packed instructions that implement dual complex-by-complex multiplication and dual complex-by-complex conjugate multiplication of doublewords stored in source 1 and source 2 registers. Each of the complex numbers or complex conjugates may be a doubleword (dword) and the real and imaginary components may each be a signed word. In one embodiment, the real and imaginary components are added or subtracted after the multiplication, then scaled, rounded, and/or saturated.</p><p id="p-0131" num="0133">One embodiment includes the instruction DVPCMULWRS xmm1, xmm2, xmm3/m128, imm8 (3 source, 1 destination), which performs vector packed dual complex multiply of packed 32-bit doublewords of xmm2/m128 and xmm3/m128 (each a packed data register or memory location). Each result is scaled using the immediate value imm8[<b>1</b>:<b>0</b>], rounded, and saturated, before written into packed 32-bit doubleword locations in xmm1/m128 (a packed data register or memory location).</p><p id="p-0132" num="0134">Another embodiment includes the instruction DVPCCMULWRS xmm1, xmm2, xmm3/m128, imm8 (3 source, 1 destination), which performs vector packed dual complex conjugate multiply of packed 32-bit doublewords of xmm2/m128 and xmm3/m128 (each a packed data register or memory location). Each result is scaled using the immediate value imm8[<b>1</b>:<b>0</b>], rounded, and saturated, before written into packed 32-bit doubleword locations in xmm1/m128 (a packed data register or memory location).</p><p id="p-0133" num="0135"><figref idref="DRAWINGS">FIG. <b>13</b></figref> illustrates exemplary data element and bit distributions for an exemplary source register and/or destination register (SRCx/DESTx). Data elements may be packed into the source register and/or destination register in words (16 bits), doublewords (32 bits), and/or quadwords (64 bits) as illustrated. In the implementations described herein, for example, the source and destination registers store words (illustrated as elements 16 bit data elements A-H). Other embodiments may store larger or smaller values such as doublewords (illustrated as elements B-A, D-C, F-E, and H-G) or quadwords (illustrated as a low quadword D-A and a high quadword H-E) or bytes, respectively. However, the underlying principles of the invention are not limited to any particular data sizes.</p><p id="p-0134" num="0136">One embodiment of the invention uses the architecture, including circuitry and/or logic, shown in <figref idref="DRAWINGS">FIG. <b>14</b></figref> to perform dual complex-by-complex multiply scale round and saturate (e.g., DVPCMULWRS) and dual complex-by-complex conjugate multiply scale round and saturate (e.g., DVPCCMULWRS) using packed real and imaginary data elements.</p><p id="p-0135" num="0137">As illustrated, a first vector operand containing 8 packed data elements, A-H, is stored in the first source register (SRC1) <b>1401</b> and a second vector operand containing 8 packed data elements, A-H, is stored in the second source register (SRC2) <b>1402</b>. While each data element is 16 bits in the illustrated example, the underlying principles of the invention are not limited to any particular data element sizes. For example, in another embodiment, vector data element sizes of 32 bits, 64 bits, 128 bits, etc, may be used.</p><p id="p-0136" num="0138">In one embodiment, the exemplary architecture illustrated in <figref idref="DRAWINGS">FIG. <b>14</b></figref> performs dual 16-bit comple/complex-conjugate multiplies with 16-bit output (i.e. 16&#xd7;16: Dual (16+16i)&#xd7;(16&#xb1;16i)=16+16i). In the foregoing notation, the numbers represent the number of bits used to represent real and imaginary components of each complex number (e.g., 16+16<i>i </i>means a complex number represented by a 16 bit real component and a 16 bit imaginary component).</p><p id="p-0137" num="0139">Specifically, according to an embodiment, the exemplary architecture illustrated in <figref idref="DRAWINGS">FIG. <b>14</b></figref> performs the following operations:</p><p id="p-0138" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>DEST<sub>A</sub>=SAT31(RND16(SRC2<sub>A</sub>&#xd7;SRC1<sub>A</sub>&#x2213;SRC2<sub>B</sub>&#xd7;SRC1<sub>B</sub>))[<b>31</b>:<b>16</b>]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0139" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>DEST<sub>B</sub>=SAT31(RND16(&#xb1;SRC2<sub>B</sub>&#xd7;SRC1<sub>A</sub>+SRC2<sub>A</sub>&#xd7;SRC1<sub>B</sub>))[<b>31</b>:<b>16</b>]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0140" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>DEST<sub>E</sub>=SAT31(RND16(SRC2<sub>E</sub>&#xd7;SRC1<sub>E</sub>&#x2213;SRC2<sub>F</sub>&#xd7;SRC1<sub>F</sub>))[<b>31</b>:<b>16</b>]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0141" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>DEST<sub>F</sub>=SAT31(RND16(&#xb1;SRC2<sub>F</sub>&#xd7;SRC1<sub>E</sub>+SRC2<sub>F</sub>&#xd7;SRC1<sub>E</sub>))[<b>31</b>:<b>16</b>]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0142" num="0140">Each of the SRC1x and SRC2x represent a real or imaginary components of a corresponding complex number, such that:<ul id="ul0003" list-style="none">    <li id="ul0003-0001" num="0000">    <ul id="ul0004" list-style="none">        <li id="ul0004-0001" num="0141">{Imaginary, Real}={SRC1<sub>B</sub>, SRC1<sub>A</sub>}</li>        <li id="ul0004-0002" num="0142">{Imaginary, Real}={SRC1<sub>F</sub>, SRC1<sub>E</sub>}</li>        <li id="ul0004-0003" num="0143">{Imaginary, Real}={SRC2<sub>B</sub>, SRC2<sub>A</sub>}</li>        <li id="ul0004-0004" num="0144">{Imaginary, Real}={SRC2<sub>F</sub>, SRC2<sub>E</sub>}</li>    </ul>    </li></ul></p><p id="p-0143" num="0145">These operations generate two complex number results C<sub>0 </sub>and C<sub>1 </sub>in the DEST, where:</p><p id="p-0144" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>C</i><sub>0</sub>=DEST<sub>A</sub><i>+i&#xd7;DEST</i><sub>B </sub><?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0145" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>C</i><sub>1</sub>=DEST<sub>E+i</sub>&#xd7;DEST<sub>F </sub><?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0146" num="0146">In one embodiment, the operation RND16(&#x2003;)is optional.</p><p id="p-0147" num="0147">Alternatively, or in addition to, according to some embodiments, the exemplary architecture illustrated in <figref idref="DRAWINGS">FIG. <b>14</b></figref> performs the following operations:</p><p id="p-0148" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>DEST<sub>C</sub>=SAT31(RND16(SRC2<sub>C</sub>&#xd7;SRC1<sub>C</sub>&#x2213;SRC2<sub>D</sub>&#xd7;SRC1<sub>D</sub>))[<b>31</b>:<b>16</b>]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0149" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>DEST<sub>D</sub>=SAT<sub>31</sub>(RND16(&#xb1;SRC2<sub>D</sub>&#xd7;SRC1<sub>C</sub>+SRC2<sub>C</sub>&#xd7;l SRC1<sub>D</sub>))[<b>31</b>:<b>16</b>]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0150" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>DEST<sub>G</sub>=SAT31(RND16(SRC2<sub>G</sub>&#xd7;SRC1<sub>G</sub>&#x2213;SRC2<sub>H</sub>&#xd7;SRC1<sub>H</sub>))[<b>31</b>:<b>16</b>]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0151" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>DEST<sub>H</sub>=SAT31(RND16(&#xb1;SRC2<sub>H</sub>&#xd7;SRC1<sub>G</sub>+SRC2<sub>G</sub>&#xd7;SRC1<sub>H</sub>))[<b>31</b>:<b>16</b>]<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0152" num="0148">Where,<ul id="ul0005" list-style="none">    <li id="ul0005-0001" num="0000">    <ul id="ul0006" list-style="none">        <li id="ul0006-0001" num="0149">{Imaginary, Real}={SRC1<sub>D</sub>. SRC1<sub>C</sub>}</li>        <li id="ul0006-0002" num="0150">{Imaginary, Real}={SRC1<sub>H</sub>. SRC1<sub>G</sub>}</li>        <li id="ul0006-0003" num="0151">{Imaginary, Real}={SRC2<sub>D</sub>. SRC2<sub>C</sub>}</li>        <li id="ul0006-0004" num="0152">{Imaginary, Real}={SRC2<sub>H</sub>. SRC2<sub>G</sub>}</li>    </ul>    </li></ul></p><p id="p-0153" num="0153">These operations generate two complex number results C<sub>0 </sub>and C<sub>1 </sub>in the DEST, where:</p><p id="p-0154" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>C</i><sub>0</sub>=DEST<sub>C</sub><i>+i</i>&#xd7;DEST<sub>D </sub><?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0155" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>C</i><sub>1</sub>=DEST<sub>G</sub><i>+i</i>&#xd7;DEST<sub>H </sub><?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0156" num="0154">As illustrated, the first source register SRC1 <b>1401</b> stores data elements S1A-S1H and the second source register SRC2 <b>1402</b> stores data elements S2A-S2H (S1 is used here as shorthand for SRC1 and S2 for SRC2). In one embodiment, elements A, C, E, and G in each source register are real data elements and elements B, D, F, and H in each source register are imaginary data elements. In one embodiment, real and imaginary data element pairs AB, CD, EF, and EG in each register each makes up a complex number. According to an embodiment, source register SRC1 stores the complex conjugate of each corresponding complex number in source register SRC2, or vice versa.</p><p id="p-0157" num="0155">An input MUX <b>1403</b> forwards the various data elements to a set of multipliers <b>1405</b>. The set of multipliers <b>1405</b> multiply each selected real data element in SRC1 with a corresponding real data element selected from SRC2 and multiply each selected imaginary data element in SRC1 with a corresponding imaginary data element selected from SRC2 to generate a plurality of real products. The set of multipliers <b>1405</b> further to multiply each selected real data element in SRC1 with a corresponding imaginary data element selected from SRC2 and multiply each selected imaginary data element in SRC1 with a corresponding real data element selected from SRC2 to generate a plurality of imaginary products.</p><p id="p-0158" num="0156">In one embodiment, multipliers <b>1405</b> perform the multiplications of S1A*S2A, S1B*S2B, S1E*S2E, S1F*S2F to generate the real products and the multiplications of S1A*S2B, S1B*S2A, S1E*S2F, S1F*S2E to generate the imaginary products. Alternatively, or in addition to, according to some embodiments, multipliers <b>1405</b> perform the multiplication of S1C*S2C, S1D*S2D, S1G*S2G, and S1H*S2H to generate the real products and the multiplications of S1C*S2D, S1D*S2C, S1G*S2H, S1H*S2G to generate the imaginary products. Adder networks <b>1411</b> and <b>1410</b> then add/subtract pairs of the real products to generate real results and add/subtract pairs of imaginary products to generate imaginary results. The real and imaginary results are next optionally scaled and/or optionally rounded by the adder networks <b>1411</b> and <b>1410</b>. The optionally scaled and/or rounded results are then saturated by the saturation circuitries <b>1441</b> and <b>1440</b> before being outputted by the output mux <b>1450</b> and stored in the destination register DEST.</p><p id="p-0159" num="0157">One particular embodiment decodes and executes a single instruction to perform a dual complex-by-complex multiply, scale, round, and saturate using packed real and imaginary data elements, identified herein with the mnemonic DVPCMULWRS. The following pseudo code specifies the individual operations performed in one embodiment. SRC1 and SRC2, which correspond to xmm2 and xmm3, respectively, identify the first and second set of packed real and imaginary data elements. TEMPO through TEMP<b>7</b> are registers or memory locations for storing intermediate values. DEST, which corresponds to xmm1, is a destination register. An immediate value is identified by imm8.</p><p id="p-0160" num="0000">DVPCMULWRS xmm1, xmm2, xmm3/m128, imm8<ul id="ul0007" list-style="none">    <li id="ul0007-0001" num="0000">    <ul id="ul0008" list-style="none">        <li id="ul0008-0001" num="0158">TEMP0[<b>32</b>:<b>0</b>]&#x2190;((SRC1[<b>15</b>:<b>0</b>]*SRC2[<b>15</b>:<b>0</b>])&#x2212;(SRC1[<b>31</b>:<b>16</b>]*SRC2[<b>31</b>:<b>16</b>])); (*Real Number*)</li>        <li id="ul0008-0002" num="0159">TEMP1[<b>32</b>:<b>0</b>]&#x2190;((SRC1[<b>15</b>:<b>0</b>]*SRC2[<b>31</b>:<b>16</b>])+(SRC1[31:16]*SRC2[<b>15</b>:<b>0</b>])); (*Imaginary Number*)</li>        <li id="ul0008-0003" num="0160">TEMP2[<b>32</b>:<b>0</b>]&#x2190;((SRC1[<b>79</b>:<b>64</b>]*SRC2[<b>79</b>:<b>64</b>])&#x2212;(SRC1[95:80]*SRC2[<b>95</b>:<b>80</b>])); (*Real Number*)</li>        <li id="ul0008-0004" num="0161">TEMP3[<b>32</b>:<b>0</b>]&#x2190;((SRC1[<b>79</b>:<b>64</b>]*SRC2[<b>95</b>:<b>80</b>])+(SRC1[<b>95</b>:<b>80</b>]*SRC2[<b>79</b>:<b>64</b>])); (*Imaginary Number*)</li>        <li id="ul0008-0005" num="0162">DEST[<b>15</b>:<b>0</b>]&#x2190;ScaleRoundAndSaturateToSignedWord (TEMP0[<b>32</b>:<b>0</b>], MXCSR.IRM[<b>1</b>:<b>0</b>], DEST[<b>15</b>:<b>0</b>], Imm8[<b>1</b>:<b>0</b>]);</li>        <li id="ul0008-0006" num="0163">DEST[<b>31</b>:<b>16</b>]&#x2190;ScaleRoundAndSaturateToSignedWord (TEMP1[<b>32</b>:<b>0</b>], MXCSR.IRM[<b>1</b>:<b>0</b>], DEST[<b>31</b>:<b>16</b>], Imm8[<b>1</b>:<b>0</b>]);</li>        <li id="ul0008-0007" num="0164">DEST[<b>79</b>:<b>64</b>]&#x2190;ScaleRoundAndSaturateToSignedWord (TEMP2[<b>32</b>:<b>0</b>], MXCSR.IRM[<b>1</b>:<b>0</b>], DEST[<b>79</b>:<b>64</b>], Imm8[<b>1</b>:<b>0</b>]);</li>        <li id="ul0008-0008" num="0165">DEST[<b>80</b>:<b>95</b>]&#x2190;ScaleRoundAndSaturateToSignedWord (TEMP3[<b>32</b>:<b>0</b>], MXCSR.IRM[<b>1</b>:<b>0</b>], DEST[<b>95</b>:<b>80</b>], Imm8[<b>1</b>:<b>0</b>]);</li>    </ul>    </li></ul></p><p id="p-0161" num="0166">Alternatively, or in addition to, the instruction DVPCMULWRS includes the following pseudo code to specify the individual operations performed according to an embodiment.<ul id="ul0009" list-style="none">    <li id="ul0009-0001" num="0000">    <ul id="ul0010" list-style="none">        <li id="ul0010-0001" num="0167">TEMP4[<b>32</b>:<b>0</b>]&#x2190;((SRC1[<b>47</b>:<b>32</b>]*SRC2[<b>47</b>:<b>32</b>])&#x2212;(SRC1[<b>63</b>:<b>48</b>]*SRC2[<b>63</b>:<b>48</b>])); (*Real Number*)</li>        <li id="ul0010-0002" num="0168">TEMP5[<b>32</b>:<b>0</b>]&#x2190;((SRC1[<b>47</b>:<b>32</b>]*SRC2[<b>63</b>:<b>48</b>])+(SRC1[<b>63</b>:<b>48</b>]*SRC2[<b>47</b>:<b>32</b>])); (*Imaginary Number*)</li>        <li id="ul0010-0003" num="0169">TEMP6[<b>32</b>:<b>0</b>]&#x2190;((SRC1[<b>79</b>:<b>64</b>]*SRC2[<b>79</b>:<b>64</b>])&#x2212;(SRC1[<b>95</b>:<b>80</b>]*SRC2[<b>95</b>:<b>80</b>])); (*Real Number*)</li>        <li id="ul0010-0004" num="0170">TEMP7[<b>32</b>:<b>0</b>]&#x2190;((SRC1[<b>79</b>:<b>64</b>]*SRC2[<b>95</b>:<b>80</b>])+(SRC1[<b>95</b>:<b>80</b>]*SRC2[<b>79</b>:<b>64</b>])); (*Imaginary Number*)</li>        <li id="ul0010-0005" num="0171">DEST[<b>47</b>:<b>32</b>]&#x2190;ScaleRoundAndSaturateToSignedWord (TEMP4[<b>32</b>:<b>0</b>], MXCSR.IRM[<b>1</b>:<b>0</b>], DEST[<b>47</b>:<b>32</b>], Imm8[<b>1</b>:<b>0</b>]);</li>        <li id="ul0010-0006" num="0172">DEST[<b>48</b>:<b>63</b>]&#x2190;ScaleRoundAndSaturateToSignedWord (TEMP5[<b>32</b>:<b>0</b>], MXCSR.IRM[<b>1</b>:<b>0</b>], DEST[<b>48</b>:<b>63</b>], Imm8[<b>1</b>:<b>0</b>]);</li>        <li id="ul0010-0007" num="0173">DEST[<b>111</b>:<b>96</b>]&#x2190;ScaleRoundAndSaturateToSignedWord (TEMP6[<b>32</b>:<b>0</b>], MXCSR.IRM[<b>1</b>:<b>0</b>], DEST[<b>111</b>:<b>96</b>], Imm8[<b>1</b>:<b>0</b>]);</li>        <li id="ul0010-0008" num="0174">DEST[<b>127</b>:<b>112</b>]&#x2190;ScaleRoundAndSaturateToSignedWord (TEMP7[<b>32</b>:<b>0</b>], MXCSR.IRM[<b>1</b>:<b>0</b>], DEST[<b>127</b>:<b>112</b>], Imm8[<b>1</b>:<b>0</b>]);</li>    </ul>    </li></ul></p><p id="p-0162" num="0175">The operations performed by ScaleRoundAndSaturateToSignedWord is represented by the following code sequence:<ul id="ul0011" list-style="none">    <li id="ul0011-0001" num="0000">    <ul id="ul0012" list-style="none">        <li id="ul0012-0001" num="0176">ScaleRoundAndSaturateToSignedWord(SRC[<b>32</b>:<b>0</b>], MXCSR, DEST[<b>15</b>:<b>0</b>], imm8[<b>1</b>:<b>0</b>])</li>        <li id="ul0012-0002" num="0177">IF(imm8[<b>1</b>:<b>0</b>]==2&#x2032;b11)</li>        <li id="ul0012-0003" num="0178">TEMP1[<b>32</b>:<b>0</b>]&#x2190;SRC[<b>32</b>:<b>0</b>];</li>        <li id="ul0012-0004" num="0179">ELSE        <ul id="ul0013" list-style="none">            <li id="ul0013-0001" num="0180">TEMP1[<b>32</b>:<b>0</b>]&#x2190;(SRC[<b>32</b>:<b>0</b>]&#x3e;&#x3e;imm8[<b>1</b>:<b>0</b>]); (*Arith. Shift Right by 0, 1, or 2 bit*)</li>        </ul>        </li>        <li id="ul0012-0005" num="0181">IF (MXCSR.IRM[<b>1</b>:<b>0</b>]==2&#x2032;b11) THEN (*Round Down*)        <ul id="ul0014" list-style="none">            <li id="ul0014-0001" num="0182">TEMP_RoundBit&#x2190;1&#x2032;b0</li>        </ul>        </li>        <li id="ul0012-0006" num="0183">ELSE IF (MXCSR.IRM[<b>1</b>:<b>0</b>]==2&#x2032;b10) THEN (*Halfway away from zero*)        <ul id="ul0015" list-style="none">            <li id="ul0015-0001" num="0184">IF (SRC[<b>14</b>:<b>0</b>]==0&#xd7;4000)            <ul id="ul0016" list-style="none">                <li id="ul0016-0001" num="0185">Temp_RoundBit&#x2190;if (&#x2dc;SRC[<b>31</b>]? SRC[<b>14</b>]:1&#x2032;b0); (*i.e. Round Up if positive, truncate if negative (to get higher magnitude result)*)</li>            </ul>            </li>            <li id="ul0015-0002" num="0186">ELSE            <ul id="ul0017" list-style="none">                <li id="ul0017-0001" num="0187">Temp_RoundBit&#x2190;SRC[<b>14</b>];</li>            </ul>            </li>        </ul>        </li>        <li id="ul0012-0007" num="0188">ELSE IF (MXSCR.IRM[<b>1</b>:<b>0</b>]==2&#x2032;b00) (*Convergent Rounding*)        <ul id="ul0018" list-style="none">            <li id="ul0018-0001" num="0189">Temp_RoundBit&#x2190;(SRC[<b>14</b>:<b>0</b>]==0&#xd7;4000)? SRC[<b>15</b>]:SRC[<b>14</b>];</li>        </ul>        </li>        <li id="ul0012-0008" num="0190">ELSE IF (MXSCR.IRM[<b>1</b>:<b>0</b>]==2&#x2032;b01) (*Round Half Up*)        <ul id="ul0019" list-style="none">            <li id="ul0019-0001" num="0191">Temp_RoundBit&#x2190;SRC[<b>14</b>];</li>        </ul>        </li>        <li id="ul0012-0009" num="0192">TEMP2[<b>17</b>:<b>0</b>]&#x2190;(TEMP1[<b>32</b>:<b>15</b>]+TEMP_RoundBit); (*Add Rounding bit with wrapping*)</li>        <li id="ul0012-0010" num="0193">DEST[<b>15</b>:<b>0</b>]&#x2190;SaturateToSignedWord2(Temp2[<b>17</b>:<b>0</b>], DEST[<b>15</b>,<b>0</b>]);</li>    </ul>    </li></ul></p><p id="p-0163" num="0194">Where SaturateToSignedWord2 is represented by the following code sequence:<ul id="ul0020" list-style="none">    <li id="ul0020-0001" num="0000">    <ul id="ul0021" list-style="none">        <li id="ul0021-0001" num="0195">SaturateToSignedWord2(SRC[<b>17</b>:<b>0</b>], DEST[<b>15</b>:<b>0</b>])</li>        <li id="ul0021-0002" num="0196">IF (SRC[<b>17</b>]==1&#x2032;b0) AND ((SRC[<b>16</b>]==1&#x2032;b1) OR (SRC[<b>15</b>]==1&#x2032;b1))        <ul id="ul0022" list-style="none">            <li id="ul0022-0001" num="0197">DEST[<b>15</b>:<b>0</b>]&#x2190;0&#xd7;7FFF; (*Most Positive Number*)</li>            <li id="ul0022-0002" num="0198">MXCSR.Sat&#x2190;1;</li>        </ul>        </li>        <li id="ul0021-0003" num="0199">ELSE IF (SRC[<b>17</b>]==1&#x2032;b1) AND ((SRC[<b>16</b>]==1&#x2032;b0) OR (SRC[<b>15</b>]==1&#x2032;b0))        <ul id="ul0023" list-style="none">            <li id="ul0023-0001" num="0200">DEST[<b>15</b>:<b>0</b>]&#x2190;0&#xd7;8000; (*Most Negative Number*)</li>            <li id="ul0023-0002" num="0201">MXCSR.Sat&#x2190;1;</li>        </ul>        </li>        <li id="ul0021-0004" num="0202">ELSE        <ul id="ul0024" list-style="none">            <li id="ul0024-0001" num="0203">DEST[<b>15</b>:<b>0</b>]&#x2190;SRC [<b>15</b>:<b>0</b>];</li>        </ul>        </li>    </ul>    </li></ul></p><p id="p-0164" num="0204">In the code above, the DVPCMULWRS instruction performs dual complex-by-complex multiply operations on packed data elements in the source registers SRC1 and SRC2 to generate a plurality of real and imaginary results which are stored in registers TEMP0-TEMP3 or registers TEMP4-TEMP7.</p><p id="p-0165" num="0205">In one embodiment, the real and imaginary results are then scaled in according to the immediate value (imm8[<b>1</b>:<b>0</b>]). For example, each of the real and imaginary results is arithmetically right or left shifted by a number of bits indicated by the immediate value.</p><p id="p-0166" num="0206">Next, according to an embodiment, the scaled results are rounded according to a specified rounding method. The rounding method may be specified by one or more rounding control bits stored in a register (e.g., MXCSR.IRM[<b>1</b>:<b>0</b>]), which may be a machine-specific register (MSR) or a computer-specific register (CSR). The available rounding methods may include rounding down, rounding half way away from zero, convergent rounding, and/or round half up. The rounded results are then saturated and stored into corresponding data element positions of the destination register. A saturation bit may be set to indicate whether any of the plurality of rounded results has been saturated to either the most positive signed value or the most negative signed value.</p><p id="p-0167" num="0207">Another particular embodiment decodes and executes a single instruction to perform a dual complex-by-complex conjugate multiply, scale, round, and saturate using packed real and imaginary data elements, identified herein with the mnemonic DVPCCMULWRS. The following pseudo code specifies the individual operations performed in one embodiment. SRC1 and SRC2, which correspond to xmm2 and xmm3, respectively, identify the first and second set of packed real and imaginary data elements. In one embodiment, each of the packed real and imaginary pairs in each SRC1 and SRC2 makes up a complex number. According to an embodiment, the complex numbers in SRC1 and the complex numbers in SRC2 are complex conjugates of each other. TEMPO through TEMP7 are registers or memory locations for storing intermediate values. DEST, which corresponds to xmm1, is a destination register. An immediate value is identified by imm8.</p><p id="p-0168" num="0000">DVPCCMULWRS xmm1, xmm2, xmm3/m128, imm8<ul id="ul0025" list-style="none">    <li id="ul0025-0001" num="0000">    <ul id="ul0026" list-style="none">        <li id="ul0026-0001" num="0208">TEMP0[<b>32</b>:<b>0</b>]&#x2190;((SRC1[<b>15</b>:<b>0</b>]*SRC2[<b>15</b>:<b>0</b>])+(SRC1[<b>31</b>:<b>16</b>]*SRC2[<b>31</b>:<b>16</b>])); (*Real Number*)</li>        <li id="ul0026-0002" num="0209">TEMP1[<b>32</b>:<b>0</b>]&#x2190;((SRC1[<b>15</b>:<b>0</b>]*SRC2[<b>31</b>:<b>16</b>])&#x2212;(SRC1[<b>31</b>:<b>16</b>]*SRC2[<b>15</b>:<b>0</b>])); (*Imaginary Number*)</li>        <li id="ul0026-0003" num="0210">TEMP2[<b>32</b>:<b>0</b>]&#x2190;((SRC1[<b>79</b>:<b>64</b>]*SRC2[<b>79</b>:<b>64</b>])+(SRC1[<b>95</b>:<b>80</b>]*SRC2[<b>95</b>:<b>80</b>])); (*Real Number*)</li>        <li id="ul0026-0004" num="0211">TEMP3[<b>32</b>:<b>0</b>]&#x2190;((SRC1[<b>79</b>:<b>64</b>]*SRC2[<b>95</b>:<b>80</b>])&#x2212;(SRC1[<b>95</b>:<b>80</b>]*SRC2[<b>79</b>:<b>64</b>])); (*Imaginary Number*)</li>        <li id="ul0026-0005" num="0212">DEST[<b>15</b>:<b>0</b>]&#x2190;ScaleRoundAndSaturateToSignedWord(TEMP0[<b>32</b>:<b>0</b>], MXCSR.IRM[<b>1</b>:<b>0</b>], DEST[<b>15</b>:<b>0</b>], Imm8[<b>1</b>:<b>0</b>]);</li>        <li id="ul0026-0006" num="0213">DEST[<b>31</b>:<b>16</b>]&#x2190;ScaleRoundAndSaturateToSignedWord(TEMP1[<b>32</b>:<b>0</b>], MXCSR.IRM[<b>1</b>:<b>0</b>], DEST[31:16], Imm8[<b>1</b>:<b>0</b>]);</li>        <li id="ul0026-0007" num="0214">DEST[<b>79</b>:<b>64</b>]&#x2190;ScaleRoundAndSaturateToSignedWord(TEMP2[<b>32</b>:<b>0</b>], MXCSR.IRM[<b>1</b>:<b>0</b>], DEST[<b>79</b>:<b>64</b>], Imm8[<b>1</b>:<b>0</b>]);</li>        <li id="ul0026-0008" num="0215">DEST[<b>95</b>:<b>80</b>]&#x2190;ScaleRoundAndSaturateToSignedWord(TEMP3[<b>32</b>:<b>0</b>], MXCSR.IRM[<b>1</b>:<b>0</b>], DEST[<b>95</b>:<b>80</b>], Imm8[<b>1</b>:<b>0</b>]);</li>    </ul>    </li></ul></p><p id="p-0169" num="0216">Alternative, or in addition to, the instruction DVPCCMULWRS includes the following pseudo code to specify the individual operations performed according to an embodiment.<ul id="ul0027" list-style="none">    <li id="ul0027-0001" num="0000">    <ul id="ul0028" list-style="none">        <li id="ul0028-0001" num="0217">TEMP4[<b>32</b>:<b>0</b>]&#x2190;((SRC1[<b>47</b>:<b>32</b>]*SRC2[<b>47</b>:<b>32</b>])+(SRC1[<b>63</b>:<b>48</b>]*SRC2[<b>63</b>:<b>48</b>])); (*Real Number*)</li>        <li id="ul0028-0002" num="0218">TEMPS[<b>32</b>:<b>0</b>]&#x2190;((SRC1[<b>47</b>:<b>32</b>]*SRC2[<b>63</b>:<b>48</b>])&#x2212;(SRC1[<b>63</b>:<b>48</b>]*SRC2[<b>47</b>:<b>32</b>])); (*Imaginary Number*)</li>        <li id="ul0028-0003" num="0219">TEMP6[<b>32</b>:<b>0</b>]&#x2190;((SRC1[<b>111</b>:<b>96</b>]*SRC2[<b>111</b>:<b>96</b>])+(SRC1[<b>127</b>:<b>112</b>]*SRC2[<b>127</b>:<b>112</b>])); (*Real Number*)</li>        <li id="ul0028-0004" num="0220">TEMP7[<b>32</b>:<b>0</b>]&#x2190;((SRC1[<b>111</b>:<b>96</b>]*SRC2[<b>127</b>:<b>112</b>])&#x2212;(SRC1[<b>127</b>:<b>112</b>]*SRC2[<b>111</b>:<b>96</b>])); (*Imaginary Number*)</li>        <li id="ul0028-0005" num="0221">DEST[<b>47</b>:<b>32</b>]&#x2190;ScaleRoundAndSaturateToSignedWord(TEMP4[<b>32</b>:<b>0</b>], MXCSR.IRM[<b>1</b>:<b>0</b>], DEST[<b>47</b>:<b>32</b>], Imm8[<b>1</b>:<b>0</b>]);</li>        <li id="ul0028-0006" num="0222">DEST[<b>63</b>:<b>48</b>]&#x2190;ScaleRoundAndSaturateToSignedWord(TEMP5[<b>32</b>:<b>0</b>], MXCSR.IRM[<b>1</b>:<b>0</b>], DEST[<b>63</b>:<b>48</b>], Imm8[<b>1</b>:<b>0</b>]);</li>        <li id="ul0028-0007" num="0223">DEST[<b>111</b>:<b>96</b>]&#x2190;ScaleRoundAndSaturateToSignedWord(TEMP6[<b>32</b>:<b>0</b>], MXCSR.IRM[<b>1</b>:<b>0</b>], DEST[<b>111</b>:<b>96</b>], Imm8[<b>1</b>:<b>0</b>]);</li>        <li id="ul0028-0008" num="0224">DEST[<b>127</b>:<b>112</b>]&#x2190;ScaleRoundAndSaturateToSignedWord(TEMP7[<b>32</b>:<b>0</b>], MXCSR. IRM[<b>1</b>:<b>0</b>],DEST[<b>127</b>:<b>112</b>], Imm8[<b>1</b>:<b>0</b>]);</li>    </ul>    </li></ul></p><p id="p-0170" num="0225">The operations performed by ScaleRoundAndSaturateToSignedWord is represented by the following code sequence:</p><p id="p-0171" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>ScaleRoundAndSaturateToSignedWord(SRC[32:0], MXCSR, DEST[15:0],</entry></row><row><entry>imm8[1:0])</entry></row><row><entry>IF (imm8[1:0] == 2&#x2032;b11)</entry></row><row><entry>&#x2003;TEMP1[32:0] &#x2190; SRC[32:0];</entry></row><row><entry>ELSE</entry></row><row><entry>&#x2003;TEMP1[32:0] &#x2190; (SRC[32:0] &#x3e;&#x3e; imm8[1:0]); (* Arith. Shift Right by 0 or 1 or</entry></row><row><entry>&#x2003;2 bit. *)</entry></row><row><entry>IF (MXCSR.IRM[1:0] == 2&#x2032;b11) THEN (* Round Down *)</entry></row><row><entry>&#x2003;TEMP_RoundBit &#x2190; 1&#x2032;b0;</entry></row><row><entry>ELSE IF (MXCSR.IRM[1:0] == 2&#x2032;b10) THEN (*Half way away from Zero *)</entry></row><row><entry>&#x2003;IF (SRC[14:0] == 0x4000))</entry></row><row><entry>&#x2003;&#x2003;TEMP_RoundBit &#x2190; if (~SRC[31] ? SRC[14]: 1&#x2032;b0); (* i.e. Round</entry></row><row><entry>&#x2003;&#x2003;Up if positive, truncate if negative (to get higher magnitude result) *)</entry></row><row><entry>&#x2003;ELSE</entry></row><row><entry>&#x2003;&#x2003;TEMP_RoundBit &#x2190; SRC[14];</entry></row><row><entry>ELSE IF (MXCSR.IRM[1:0] == 2&#x2032;b00) (* Convergent Rounding *)</entry></row><row><entry>&#x2003;TEMP_RoundBit &#x2190; (SRC[14:0] == 0x4000) ? SRC[15] : SRC[14];</entry></row><row><entry>ELSE IF (MXCSR.IRM[1:0] == 2&#x2032;b01) (* Round Half Up *)</entry></row><row><entry>&#x2003;&#x2003;TEMP_RoundBit &#x2190; SRC[14];</entry></row><row><entry>TEMP2[17:0] &#x2190; (TEMP1[32:15] + TEMP_RoundBit); (* Add Rounding bit with</entry></row><row><entry>wrapping *)</entry></row><row><entry>DEST[15:0] &#x2190; SaturateToSignedWord2(TEMP2[17:0], DEST[15:0]);</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0172" num="0226">Where SaturateToSignedWord2 is represented by the following code sequence:</p><p id="p-0173" num="0000"><tables id="TABLE-US-00002" num="00002"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>SaturateToSignedWord2(SRC[17:0], DEST[15:0])</entry></row><row><entry>IF (SRC[17] == 1&#x2032;b0) AND ( (SRC[16] == 1&#x2032;b1) OR (SRC[15] == 1&#x2032;b1) )</entry></row><row><entry>&#x2003;DEST[15:0] &#x2190; 0x7FFF; (* Most Positive Number *)</entry></row><row><entry>&#x2003;MXCSR.Sat &#x2190; 1;</entry></row><row><entry>ELSE IF (SRC[17] == 1&#x2032;b1) AND ( (SRC[16] == 1&#x2032;b0) OR (SRC[15] == 1&#x2032;b0) )</entry></row><row><entry>&#x2003;DEST[15:0] &#x2190; 0x8000; (* Most Negative Number *)</entry></row><row><entry>&#x2003;MXCSR.Sat &#x2190; 1;</entry></row><row><entry>ELSE</entry></row><row><entry>&#x2003;DEST[15:0] &#x2190; SRC [15:0];</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0174" num="0227">In the code above, the DVPCCMULWRS instruction performs dual complex-by-complex conjugate multiply operations on packed data elements in the source registers SRC1 and SRC2 to generate a plurality of real and imaginary results which are stored in registers TEMP0-TEMP3 or registers TEMP4-TEMP7.</p><p id="p-0175" num="0228">In one embodiment, the real and imaginary results are then scaled in according to the immediate value (imm8[<b>1</b>:<b>0</b>]). For example, each of the real and imaginary results is arithmetically right or left shifted by a number of bits indicated by the immediate value.</p><p id="p-0176" num="0229">Next, according to an embodiment, the scaled results are rounded according to a specified rounding method. The rounding method may be specified by one or more rounding control bits stored in a register (e.g., MXCSR.IRM[<b>1</b>:<b>0</b>]), which may be a MSR or CSR. The available rounding methods may include rounding down, rounding half way away from zero, convergent rounding, and/or round half up. The rounded results are then saturated and stored into corresponding data element positions of the destination register. A saturation bit may be set to indicate whether any of the plurality of rounded results has been saturated to either the most positive signed value or the most negative signed value.</p><p id="p-0177" num="0230">A method in accordance with one embodiment is illustrated in <figref idref="DRAWINGS">FIG. <b>15</b></figref>. The method <b>1500</b> may be implemented within the context of the processor architectures described herein, but is not limited to any particular processor architecture.</p><p id="p-0178" num="0231">At <b>1502</b> a first instruction is fetched having fields for operands indicating a first and a second plurality of real and imaginary data elements and an immediate value. Each pair of a real and an imaginary data element in the first plurality represents a complex number. Similarly, each pair of a real and an imaginary data element in the second plurality represents a complex number. In one embodiment, a destination register is also indicated by one of the operands.</p><p id="p-0179" num="0232">At <b>1504</b> the first instruction is decoded. At <b>1506</b>, the real and imaginary data elements associated with a first and a second source operands are stored as packed data elements in a first and a second source register, respectively. The first instruction is scheduled for execution. As mentioned, in one embodiment, the first and second source operands are stored in 128-bit packed data registers storing 16-bit packed data elements, with each packed data element comprising a real or an imaginary value.</p><p id="p-0180" num="0233">At <b>1508</b> the first decoded instruction is executed to multiply select packed real and imaginary data elements of the first plurality with select packed real and imaginary data elements of the second plurality to generate a first and a second plurality of real products and a first and a second plurality of imaginary products. In one embodiment, the first plurality of real products is generated by the operations S1A*S2A and S1E*S2E, the second plurality of real products is generated by the operations of S1B*S2B and S1F*S2F, the first plurality of imaginary products is generated by the operations of S1A*S2B and S1E*S2F, and the second plurality of imaginary products is generated by the operations S1B*S2A and S1F*S2E.</p><p id="p-0181" num="0234">Alternatively, according to an embodiment, the first plurality of real products is generated by the operations S1C*S2C and S1G*S2G, the second plurality of real products is generated by the operations of S1D*S2D and S1H*S2H, the first plurality of imaginary products is generated by the operations of S1C*S2D and S1G*S2H, and the second plurality of imaginary products is generated by the operations S1D*S2C and S1H*S2G.</p><p id="p-0182" num="0235">As describe above, S1 identifies the first source register, S2 identifies the second source register and A-H identify the packed data elements in data element positions A-H in the first and second source registers, respectively.</p><p id="p-0183" num="0236">At <b>1510</b>, for each real product of the first plurality, a corresponding real product of the second plurality is subtracted therefrom to generate a plurality of real results. In addition, each imaginary product of the first plurality is added with a corresponding imaginary product of the second plurality to generate a plurality of imaginary results. In one embodiment, the plurality of real results is generated by the operations (S1A*S2A)&#x2212;(S1B*S2B) and (S1E*S2E)&#x2212;(S1F*S2F) and the plurality of imaginary results is generated by the operations (S1A*S2B)+(S1B*S2A) and (S1E*S2F)+(S1F*S2E).</p><p id="p-0184" num="0237">Alternatively, according to an embodiment, the plurality of real results is generated by the operations (S1C*S2C)&#x2212;(S1D*S2D) and (S1G*S2G)&#x2212;(S1H*S2H) and the plurality of imaginary results is generated by the operations (S1C*S2D)+(S1D*S2C) and (S1G*S2H)+(S1H*S2G).</p><p id="p-0185" num="0238">At <b>1512</b>, each of the plurality of real and imaginary results are scaled according to the immediate value identified by the first instruction to generate a plurality of scaled results. According to an embodiment, the plurality of scaled results is generated by performing an arithmetic right or left shift of each of the real and imaginary results by a number of bits specified by the immediate value.</p><p id="p-0186" num="0239">At <b>1514</b>, each scaled result is rounded according to a rounding method to generate a plurality of rounded results. At <b>1516</b>, saturation is performed on the plurality of rounded results, if necessary, to generate a plurality of final results. At <b>1518</b>, each final result is stored in a corresponding data element position of the destination register.</p><p id="p-0187" num="0240">A method in accordance with one embodiment is illustrated in <figref idref="DRAWINGS">FIG. <b>16</b></figref>. The method <b>1600</b> may be implemented within the context of the processor architectures described herein, but is not limited to any particular processor architecture.</p><p id="p-0188" num="0241">At <b>1602</b> a first instruction is fetched having fields for operands indicating a first and a second plurality of real and imaginary data elements and an immediate value.</p><p id="p-0189" num="0242">Each pair of a real and an imaginary data element in the first plurality represents a complex number. Similarly, each pair of a real and an imaginary data element in the second plurality represents a complex number. According to an embodiment, each complex number from the second plurality of real and imaginary data elements is a complex conjugate of a corresponding complex number made up from the first plurality real and imaginary data elements. In one embodiment, a destination register is also indicated by one of the operands.</p><p id="p-0190" num="0243">At <b>1604</b> the first instruction is decoded. At <b>1606</b>, the real and imaginary data elements associated with a first and a second source operands are stored as packed data elements in a first and a second source register, respectively. The first instruction is scheduled for execution. As mentioned, in one embodiment, the first and second source operands are stored in 128-bit packed data registers storing 16-bit packed data elements, with each packed data element comprising a real or an imaginary value.</p><p id="p-0191" num="0244">At <b>1608</b> the first decoded instruction is executed to multiply select packed real and imaginary data elements of the first plurality with select packed real and imaginary data elements of the second plurality to generate a first and a second plurality of real products and a first and a second plurality of imaginary products. In one embodiment, the first plurality of real products is generated by the operations S1A*S2A and S1E*S2E, the second plurality of real products is generated by the operations of S1B*S2B and S1F*S2F, the first plurality of imaginary products is generated by the operations of S1A*S2B and S1E*S2F, and the second plurality of imaginary products is generated by the operations S1B*S2A and S1F*S2E.</p><p id="p-0192" num="0245">Alternatively, according to an embodiment, the first plurality of real products is generated by the operations S1C*S2C and S1G*S2G, the second plurality of real products is generated by the operations of S1D*S2D and S1H*S2H, the first plurality of imaginary products is generated by the operations of S1C*S2D and S1G*S2H, and the second plurality of imaginary products is generated by the operations S1D*S2C and S1H*S2G.</p><p id="p-0193" num="0246">As describe above, S1 identifies the first source register, S2 identifies the second source register and A-H identify the packed data elements in data element positions A-H in the first and second source registers, respectively.</p><p id="p-0194" num="0247">At <b>1610</b>, each real product of the first plurality is added with a corresponding real product of the second plurality to generate a plurality of real results. In addition, for each imaginary product of the first plurality, a corresponding imaginary product of the second plurality is subjected therefrom to generate a plurality of imaginary results. In one embodiment, the plurality of real results is generated by the operations (S1A*S2A)+(S1B*S2B) and (S1E*S2E)+(S1F*S2F) and the plurality of imaginary results is generated by the operations (S1A*S2B)&#x2212;(S1B*S2A) and (S1E*S2F)&#x2212;(S1F*S2E).</p><p id="p-0195" num="0248">Alternatively, according to an embodiment, the plurality of real results is generated by the operations (S1C*S2C)+(S1D*S2D) and (S1G*S2G)+(S1H*S2H) and the plurality of imaginary results is generated by the operations (S1C*S2D)&#x2212;(S1D*S2C) and (S1G*S2H)&#x2212;(S1H*S2G).</p><p id="p-0196" num="0249">At <b>1612</b>, each of the plurality of real and imaginary results are scaled according to the immediate value identified by the first instruction to generate a plurality of scaled results. According to an embodiment, the plurality of scaled results is generated by performing an arithmetic right or left shift of each of the real and imaginary results by a number of bits specified by the immediate value.</p><p id="p-0197" num="0250">At <b>1614</b>, each scaled result is rounded according to a rounding method to generate a plurality of rounded results. At <b>1616</b>, saturation is performed on the plurality of rounded results, if necessary, to generate a plurality of final results. At <b>1618</b>, each final result is stored in a corresponding data element position of the destination register.</p><heading id="h-0022" level="1">EXAMPLES</heading><p id="p-0198" num="0251">The following are example implementations of different embodiments of the invention.</p><p id="p-0199" num="0252">Example 1. A processor that includes: a decoder to decode a first instruction to generate a decoded instruction, the first instruction including operands to identify a first plurality of complex numbers including a first plurality of packed real and imaginary data elements, a second plurality of complex numbers including a second plurality of packed real and imaginary data elements, and an immediate value; a first source register to store the first plurality of complex numbers including the first plurality of packed real and imaginary data elements; a second source register to store the second plurality of complex numbers including the second plurality of packed real and imaginary data elements; execution circuitry to execute the decoded instruction, and destination register to store the results.</p><p id="p-0200" num="0253">The execution circuitry includes multiplier circuitry to multiply each of the first plurality of packed real data elements with a corresponding packed real data element of the second plurality to generate a first plurality of real products, and to multiply each of the first plurality of packed imaginary data elements with a corresponding packed imaginary data element of the second plurality to generate a second plurality of real products. The multiplier circuitry further to multiply each of the first plurality of real data elements with a corresponding packed imaginary data element of the second plurality to generate a first plurality of imaginary products, and to multiply each of the first plurality of packed imaginary data elements with a corresponding packed real data element of the second plurality to generate a second plurality of imaginary products.</p><p id="p-0201" num="0254">The execution circuitry further includes adder network to subtract, from each real product of the first plurality, a corresponding real product of the second plurality to generate a plurality of real results, and to add each imaginary product of the first plurality with a corresponding imaginary product of the second plurality to generate a plurality of imaginary results, and to scale each of the plurality of real and imaginary results according to the immediate value to generate a plurality of scaled results, round each of the plurality of scaled real results according to a rounding method to generate a plurality of rounded results. Saturation circuitry of the execution circuitry to saturate each of the plurality of rounded results to generate a plurality of final results. Each of the plurality of final results is then stored in a corresponding data element position of the destination register.</p><p id="p-0202" num="0255">Example 2. The processor of Example 1, wherein the first and second plurality of packed real and imaginary data elements are stored as 16-bit data elements in the first and second source registers, each imaginary data element being stored in a data element location adjacent to a data element location of its corresponding real data element, each combination of a real and imaginary data element represents a complex number.</p><p id="p-0203" num="0256">Example 3. The processor of Example 2, wherein the first and second source registers include 128-bit packed data registers configurable with data element positions A, B, C, D, E, F, G, and H storing data elements A, B, C, D, E, F, G, and H, respectively, and wherein data elements A, C, E, and G are real data elements and data elements B, D, F, and H are corresponding imaginary data elements.</p><p id="p-0204" num="0257">Example 4. The processor of Example 3, wherein to execute the decoded instruction, the multiplier circuitry is to perform multiplications of S1A*S2A and S1E*S2E to generate the first plurality of real products, multiplications of S1B*S2B and S1F*S2F to generate the second plurality of real products, multiplications of S1A*S2B and S1E*S2F to generate the first plurality of imaginary products, and multiplications of S1B*S2A and S1F*S2E to generate the second plurality of imaginary products, where S1 identifies the first source register, S2 identifies the second source register and A, B, E, F identify the packed data elements in data element positions A, B, E, F in the first and second source registers, respectively.</p><p id="p-0205" num="0258">Example 5. The processor of Example 3, wherein to execute the decoded instruction, the multiplier circuitry is to perform multiplications of S1C*S2C and S1G*S2G to generate the first plurality of real products, multiplications of S1D*S2D and S1H*S2H to generate the second plurality of real products, multiplications of S1C*S2D and S1G*S2H to generate the first plurality of imaginary products, and multiplications of S1D*S2C and S1H*S2G to generate the second plurality of imaginary products, where S1 identifies the first source register, S2 identifies the second source register and C, D, G, H identify the packed data elements in data element positions C, D, G, H in the first and second source registers, respectively.</p><p id="p-0206" num="0259">Example 6. The processor of Example 1, further including a plurality of temporary registers, each temporary register to store one of the plurality of real and imaginary results generated by the adder network.</p><p id="p-0207" num="0260">Example 7. The processor of Example 1, wherein the rounding method include one of rounding down, rounding halfway away from zero, convergent rounding, and rounding half up.</p><p id="p-0208" num="0261">Example 8. The processor of Example 7, further including a rounding control register to store a rounding control value for specifying the rounding method.</p><p id="p-0209" num="0262">Example 9. The processor of Example 1, further including a saturation register to store a saturation bit to indicate whether any of the plurality of rounded results has been saturated to either the most positive signed word value or the most negative signed word value by the saturation circuitry.</p><p id="p-0210" num="0263">Example 10. The processor of Example 1, wherein the adder network is to scale each of the plurality of real and imaginary results by performing an arithmetic shift by a number of bits indicated by the immediate value.</p><p id="p-0211" num="0264">Example 11. A processor that includes: a decoder to decode a first instruction to generate a decoded instruction, the first instruction including operands to identify a first plurality of complex numbers including a first plurality of packed real and imaginary data elements, a second plurality of complex numbers including a second plurality of packed real and imaginary data elements, and an immediate value; a first source register to store the first plurality of complex numbers including the first plurality of packed real and imaginary data elements; a second source register to store the second plurality of complex numbers including the second plurality of packed real and imaginary data elements, wherein each of the second plurality of complex numbers includes a complex conjugate of a corresponding complex number of the first plurality; execution circuitry to execute the decoded instruction, and destination register to store the results.</p><p id="p-0212" num="0265">The execution circuitry includes multiplier circuitry to multiply each of the first plurality of packed real data elements with a corresponding packed real data element of the second plurality to generate a first plurality of real products, and to multiply each of the first plurality of packed imaginary data elements with a corresponding packed imaginary data element of the second plurality to generate a second plurality of real products. The multiplier circuitry further to multiply each of the first plurality of real data elements with a corresponding packed imaginary data element of the second plurality to generate a first plurality of imaginary products, and to multiply each of the first plurality of packed imaginary data elements with a corresponding packed real data element of the second plurality to generate a second plurality of imaginary products.</p><p id="p-0213" num="0266">The execution circuitry further includes adder network to add each real product of the first plurality with a corresponding real product of the second plurality to generate a plurality of real results, and to subtract, from each imaginary product of the first plurality, a corresponding imaginary product of the second plurality to generate a plurality of imaginary results, and to scale each of the plurality of real and imaginary results according to the immediate value to generate a plurality of scaled results, round each of the plurality of scaled real results according to a rounding method to generate a plurality of rounded results. Saturation circuitry of the execution circuitry to saturate each of the plurality of rounded results to generate a plurality of final results. Each of the plurality of final results is then stored in a corresponding data element position of the destination register.</p><p id="p-0214" num="0267">Example 12. The processor of Example 11, wherein the first and second plurality of packed real and imaginary data elements are stored as 16-bit data elements in the first and second source registers, each imaginary data element being stored in a data element location adjacent to a data element location of its corresponding real data element, each combination of a real and imaginary data element represents a complex number.</p><p id="p-0215" num="0268">Example 13. The processor of Example 12, wherein the first and second source registers include 128-bit packed data registers configurable with data element positions A, B, C, D, E, F, G, and H storing data elements A, B, C, D, E, F, G, and H, respectively, and wherein data elements A, C, E, and G are real data elements and data elements B, D, F, and H are corresponding imaginary data elements.</p><p id="p-0216" num="0269">Example 14. The processor of Example 13, wherein to execute the decoded instruction, the multiplier circuitry is to perform multiplications of S1A*S2A and S1E*S2E to generate the first plurality of real products, multiplications of S1B*S2B and S1F*S2F to generate the second plurality of real products, multiplications of S1A*S2B and S1E*S2F to generate the first plurality of imaginary products, and multiplications of S1B*S2A and S1F*S2E to generate the second plurality of imaginary products, where S1 identifies the first source register, S2 identifies the second source register and A, B, E, F identify the packed data elements in data element positions A, B, E, F in the first and second source registers, respectively.</p><p id="p-0217" num="0270">Example 15. The processor of Example 13, wherein to execute the decoded instruction, the multiplier circuitry is to perform multiplications of S1C*S2C and S1G*S2G to generate the first plurality of real products, multiplications of S1D*S2D and S1H*S2H to generate the second plurality of real products, multiplications of S1C*S2D and S1G*S2H to generate the first plurality of imaginary products, and multiplications of S1D*S2C and S1H*S2G to generate the second plurality of imaginary products, where S1 identifies the first source register, S2 identifies the second source register and C, D, G, H identify the packed data elements in data element positions C, D, G, H in the first and second source registers, respectively.</p><p id="p-0218" num="0271">Example 16. The processor of Example 11, further including a plurality of temporary registers, each temporary register to store one of the plurality of real and imaginary results generated by the adder network.</p><p id="p-0219" num="0272">Example 17. The processor of Example 11, wherein the rounding method includes one of rounding down, rounding halfway away from zero, convergent rounding, and rounding half up.</p><p id="p-0220" num="0273">Example 18. The processor of Example 17, further including a rounding control register to store a rounding control value for specifying the rounding method.</p><p id="p-0221" num="0274">Example 19. The processor of Example 11, further including a saturation register to store a saturation bit to indicate whether any of the plurality of rounded results has been saturated to either the most positive signed word value or the most negative signed word value by the saturation circuitry.</p><p id="p-0222" num="0275">Example 20. The processor of Example 11, wherein the adder network is to scale each of the plurality of real and imaginary results by performing an arithmetic shift by a number of bits indicated by the immediate value.</p><p id="p-0223" num="0276">Example 21. A method that includes: decoding a first instruction to generate a decoded instruction, the first instruction including operands to identify a first plurality of complex numbers including a first plurality of packed real and imaginary data elements, a second plurality of complex numbers including a second plurality of packed real and imaginary data elements, and an immediate value; storing the first plurality of complex numbers including the first plurality of packed real and imaginary data elements in a first source register; storing the second plurality of complex numbers including the second plurality of packed real and imaginary data elements in a second source register; executing the decoded instruction; multiplying each of the first plurality of packed real data elements with a corresponding packed real data element of the second plurality to generate a first plurality of real products; multiplying each of the first plurality of packed imaginary data elements with a corresponding packed imaginary data element of the second plurality to generate a second plurality of real products; multiplying each of the first plurality of real data elements with a corresponding packed imaginary data element of the second plurality to generate a first plurality of imaginary products; multiplying each of the first plurality of packed imaginary data elements with a corresponding packed real data element of the second plurality to generate a second plurality of imaginary products; subtracting, from each real product of the first plurality, a corresponding real product of the second plurality to generate a plurality of real results; adding each imaginary product of the first plurality with a corresponding imaginary product of the second plurality to generate a plurality of imaginary results; scaling each of the plurality of real and imaginary results according to the immediate value to generate a plurality of scaled results; rounding each of the plurality of scaled real results according to a rounding method to generate a plurality of rounded results; saturating each of the plurality of rounded results to generate a plurality of final results; and storing each of the plurality of final results in a corresponding data element position of a destination register.</p><p id="p-0224" num="0277">Example 22. The method of Example 21, wherein the first and second plurality of packed real and imaginary data elements are stored as 16-bit data elements in the first and second source registers, each imaginary data element being stored in a data element location adjacent to a data element location of its corresponding real data element, each combination of a real and imaginary data element represents a complex number.</p><p id="p-0225" num="0278">Example 23. The method of Example 22, wherein the first and second source registers include 128-bit packed data registers configurable with data element positions A, B, C, D, E, F, G, and H storing data elements A, B, C, D, E, F, G, and H, respectively, and wherein data elements A, C, E, and G are real data elements and data elements B, D, F, and H are corresponding imaginary data elements.</p><p id="p-0226" num="0279">Example 24. The method of Example 23, wherein multiplying each of the first plurality of packed real data elements with a corresponding packed real data element of the second plurality includes performing multiplications of S1A*S2A and S1E*S2E, wherein multiplying each of the first plurality of packed imaginary data elements with a corresponding packed imaginary data element of the second plurality includes performing multiplications of S1B*S2B and S1F*S2F, wherein multiplying each of the first plurality of real data elements with a corresponding packed imaginary data element of the second plurality includes performing multiplications of S1A*S2B and S1E*S2F, and wherein multiplying each of the first plurality of packed imaginary data elements with a corresponding packed real data element of the second plurality includes performing multiplications of S1B*S2A and S1F*S2E, where S1 identifies the first source register, S2 identifies the second source register and A, B, E, F identify the packed data elements in data element positions A, B, E, F in the first and second source registers, respectively.</p><p id="p-0227" num="0280">Example 25. The method of Example 23, wherein multiplying each of the first plurality of packed real data elements with a corresponding packed real data element of the second plurality includes performing multiplications of S1C*S2C and S1G*S2G, wherein multiplying each of the first plurality of packed imaginary data elements with a corresponding packed imaginary data element of the second plurality includes performing multiplications of S1D*S2D and S1H*S2H, wherein multiplying each of the first plurality of real data elements with a corresponding packed imaginary data element of the second plurality includes performing multiplications of S1C*S2D and S1G*S2H, and wherein multiplying each of the first plurality of packed imaginary data elements with a corresponding packed real data element of the second plurality includes performing multiplications of S1D*S2C and S1H*S2G, where S1 identifies the first source register, S2 identifies the second source register and C, D, G, H identify the packed data elements in data element positions C, D, G, H in the first and second source registers, respectively.</p><p id="p-0228" num="0281">Example 26. The method of Example 21, further including storing the plurality of real and imaginary results in a plurality of temporary registers.</p><p id="p-0229" num="0282">Example 27. The method of Example 21, wherein the rounding method includes one of rounding down, rounding halfway away from zero, convergent rounding, and rounding half up.</p><p id="p-0230" num="0283">Example 28. The method of Example 27, further including storing a rounding control value for specifying the rounding method in a rounding control register.</p><p id="p-0231" num="0284">Example 29. The method of Example 21, further including storing a saturation bit in a saturation register, the saturation bit to indicate whether any of the plurality of rounded results has been saturated to either the most positive signed word value or the most negative signed word value.</p><p id="p-0232" num="0285">Example 30. The method of Example 21, wherein scaling each of the plurality of real and imaginary results includes performing an arithmetic shift by a number of bits indicated by the immediate value.</p><p id="p-0233" num="0286">Example 31. A method that includes: decoding a first instruction to generate a decoded instruction, the first instruction including operands to identify a first plurality of complex numbers including a first plurality of packed real and imaginary data elements, a second plurality of complex numbers including a second plurality of packed real and imaginary data elements, and an immediate value; storing the first plurality of complex numbers including the first plurality of packed real and imaginary data elements in a first source register; storing the second plurality of complex numbers including the second plurality of packed real and imaginary data elements in a second source register; executing the decoded instruction; multiplying each of the first plurality of packed real data elements with a corresponding packed real data element of the second plurality to generate a first plurality of real products; multiplying each of the first plurality of packed imaginary data elements with a corresponding packed imaginary data element of the second plurality to generate a second plurality of real products; multiplying each of the first plurality of real data elements with a corresponding packed imaginary data element of the second plurality to generate a first plurality of imaginary products; multiplying each of the first plurality of packed imaginary data elements with a corresponding packed real data element of the second plurality to generate a second plurality of imaginary products; adding each real product of the first plurality with a corresponding real product of the second plurality to generate a plurality of real results; subtracting, from each imaginary product of the first plurality, a corresponding imaginary product of the second plurality to generate a plurality of imaginary results; scaling each of the plurality of real and imaginary results according to the immediate value to generate a plurality of scaled results; rounding each of the plurality of scaled real results according to a rounding method to generate a plurality of rounded results; saturating each of the plurality of rounded results to generate a plurality of final results; and storing each of the plurality of final results in a corresponding data element position of a destination register.</p><p id="p-0234" num="0287">Example 32. The method of Example 31, wherein the first and second plurality of packed real and imaginary data elements are stored as 16-bit data elements in the first and second source registers, each imaginary data element being stored in a data element location adjacent to a data element location of its corresponding real data element, each combination of a real and imaginary data element represents a complex number.</p><p id="p-0235" num="0288">Example 33. The method of Example 32, wherein the first and second source registers include 128-bit packed data registers configurable with data element positions A, B, C, D, E, F, G, and H storing data elements A, B, C, D, E, F, G, and H, respectively, and wherein data elements A, C, E, and G are real data elements and data elements B, D, F, and H are corresponding imaginary data elements.</p><p id="p-0236" num="0289">Example 34. The method of Example 33, wherein multiplying each of the first plurality of packed real data elements with a corresponding packed real data element of the second plurality includes performing multiplications of S1A*S2A and S1E*S2E, wherein multiplying each of the first plurality of packed imaginary data elements with a corresponding packed imaginary data element of the second plurality includes performing multiplications of S1B*S2B and S1F*S2F, wherein multiplying each of the first plurality of real data elements with a corresponding packed imaginary data element of the second plurality includes performing multiplications of S1A*S2B and S1E*S2F, and wherein multiplying each of the first plurality of packed imaginary data elements with a corresponding packed real data element of the second plurality includes performing multiplications of S1B*S2A and S1F*S2E, where S1 identifies the first source register, S2 identifies the second source register and A, B, E, F identify the packed data elements in data element positions A, B, E, F in the first and second source registers, respectively.</p><p id="p-0237" num="0290">Example 35. The method of Example 33, wherein multiplying each of the first plurality of packed real data elements with a corresponding packed real data element of the second plurality includes performing multiplications of S1C*S2C and S1G*S2G, wherein multiplying each of the first plurality of packed imaginary data elements with a corresponding packed imaginary data element of the second plurality includes performing multiplications of S1D*S2D and S1H*S2H, wherein multiplying each of the first plurality of real data elements with a corresponding packed imaginary data element of the second plurality includes performing multiplications of S1C*S2D and S1G*S2H, and wherein multiplying each of the first plurality of packed imaginary data elements with a corresponding packed real data element of the second plurality includes performing multiplications of S1D*S2C and S1H*S2G, where S1 identifies the first source register, S2 identifies the second source register and C, D, G, H identify the packed data elements in data element positions C, D, G, H in the first and second source registers, respectively.</p><p id="p-0238" num="0291">Example 36. The method of Example 31, further including storing the plurality of real and imaginary results in a plurality of temporary registers.</p><p id="p-0239" num="0292">Example 37. The method of Example 31, wherein the rounding method includes one of rounding down, rounding halfway away from zero, convergent rounding, and rounding half up.</p><p id="p-0240" num="0293">Example 38. The method of Example 37, further including storing a rounding control value for specifying the rounding method in a rounding control register.</p><p id="p-0241" num="0294">Example 39. The method of Example 31, further including storing a saturation bit in a saturation register, the saturation bit to indicate whether any of the plurality of rounded results has been saturated to either the most positive signed word value or the most negative signed word value.</p><p id="p-0242" num="0295">Example 40. The method of Example 31, wherein scaling each of the plurality of real and imaginary results includes performing an arithmetic shift by a number of bits indicated by the immediate value.</p><p id="p-0243" num="0296">In the foregoing specification, the embodiments of invention have been described with reference to specific exemplary embodiments thereof. It will, however, be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The specification and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense.</p><p id="p-0244" num="0297">Embodiments of the invention may include various steps, which have been described above. The steps may be embodied in machine-executable instructions which may be used to cause a general-purpose or special-purpose processor to perform the steps. Alternatively, these steps may be performed by specific hardware components that contain hardwired logic for performing the steps, or by any combination of programmed computer components and custom hardware components.</p><p id="p-0245" num="0298">As described herein, instructions may refer to specific configurations of hardware such as application specific integrated circuits (ASICs) configured to perform certain operations or having a predetermined functionality or software instructions stored in memory embodied in a non-transitory computer readable medium. Thus, the techniques shown in the Figures can be implemented using code and data stored and executed on one or more electronic devices (e.g., an end station, a network element, etc.). Such electronic devices store and communicate (internally and/or with other electronic devices over a network) code and data using computer machine-readable media, such as non-transitory computer machine-readable storage media (e.g., magnetic disks; optical disks; random access memory; read only memory; flash memory devices; phase-change memory) and transitory computer machine-readable communication media (e.g., electrical, optical, acoustical or other form of propagated signals&#x2014;such as carrier waves, infrared signals, digital signals, etc.). In addition, such electronic devices typically include a set of one or more processors coupled to one or more other components, such as one or more storage devices (non-transitory machine-readable storage media), user input/output devices (e.g., a keyboard, a touchscreen, and/or a display), and network connections. The coupling of the set of processors and other components is typically through one or more busses and bridges (also termed as bus controllers). The storage device and signals carrying the network traffic respectively represent one or more machine-readable storage media and machine-readable communication media. Thus, the storage device of a given electronic device typically stores code and/or data for execution on the set of one or more processors of that electronic device. Of course, one or more parts of an embodiment of the invention may be implemented using different combinations of software, firmware, and/or hardware. Throughout this detailed description, for the purposes of explanation, numerous specific details were set forth in order to provide a thorough understanding of the present invention. It will be apparent, however, to one skilled in the art that the invention may be practiced without some of these specific details. In certain instances, well known structures and functions were not described in elaborate detail in order to avoid obscuring the subject matter of the present invention. Accordingly, the scope and spirit of the invention should be judged in terms of the claims which follow.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A processor comprising:<claim-text>a decoder to decode a first instruction to generate a decoded instruction, the first instruction including operands to identify a first plurality of complex numbers comprising a first plurality of packed real and imaginary data elements, a second plurality of complex numbers comprising a second plurality of packed real and imaginary data elements, and an immediate value;</claim-text><claim-text>a first source register to store the first plurality of complex numbers including the first plurality of packed real and imaginary data elements;</claim-text><claim-text>a second source register to store the second plurality of complex numbers including the second plurality of packed real and imaginary data elements;</claim-text><claim-text>execution circuitry to execute the decoded instruction, the execution circuitry comprising:<claim-text>multiplier circuitry to multiply each of the first plurality of packed real data elements with a corresponding packed real data element of the second plurality to generate a first plurality of real products, and to multiply each of the first plurality of packed imaginary data elements with a corresponding packed imaginary data element of the second plurality to generate a second plurality of real products,</claim-text><claim-text>the multiplier circuitry further to multiply each of the first plurality of real data elements with a corresponding packed imaginary data element of the second plurality to generate a first plurality of imaginary products, and to multiply each of the first plurality of packed imaginary data elements with a corresponding packed real data element of the second plurality to generate a second plurality of imaginary products;</claim-text><claim-text>adder network to subtract, from each real product of the first plurality, a corresponding real product of the second plurality to generate a plurality of real results, and to add each imaginary product of the first plurality with a corresponding imaginary product of the second plurality to generate a plurality of imaginary results,</claim-text><claim-text>the adder network further to scale each of the plurality of real and imaginary results according to the immediate value to generate a plurality of scaled results, round each of the plurality of scaled real results according to a rounding method to generate a plurality of rounded results; and</claim-text><claim-text>saturation circuitry to saturate each of the plurality of rounded results to generate a plurality of final results; and</claim-text></claim-text><claim-text>a destination register to store each of the plurality of final results in a corresponding data element position of the destination register.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The processor of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the first and second plurality of packed real and imaginary data elements are stored as 16-bit data elements in the first and second source registers, each imaginary data element being stored in a data element location adjacent to a data element location of its corresponding real data element, each combination of a real and imaginary data element represents a complex number.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The processor of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the first and second source registers comprise 128-bit packed data registers configurable with data element positions A, B, C, D, E, F, G, and H storing data elements A, B, C, D, E, F, G, and H, respectively, and wherein data elements A, C, E, and G are real data elements and data elements B, D, F, and H are corresponding imaginary data elements.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The processor of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein to execute the decoded instruction, the multiplier circuitry is to perform multiplications of S1A*S2A and S1E*S2E to generate the first plurality of real products, multiplications of S1B*S2B and S1F*S2F to generate the second plurality of real products, multiplications of S1A*S2B and S1E*S2F to generate the first plurality of imaginary products, and multiplications of S1B*S2A and S1F*S2E to generate the second plurality of imaginary products, where S1 identifies the first source register, S2 identifies the second source register and A, B, E, F identify the packed data elements in data element positions A, B, E, F in the first and second source registers, respectively.</claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The processor of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein to execute the decoded instruction, the multiplier circuitry is to perform multiplications of S1C*S2C and S1G*S2G to generate the first plurality of real products, multiplications of S1D*S2D and S1H*S2H to generate the second plurality of real products, multiplications of S1C*S2D and S1G*S2H to generate the first plurality of imaginary products, and multiplications of S1D*S2C and S1H*S2G to generate the second plurality of imaginary products, where S1 identifies the first source register, S2 identifies the second source register and C, D, G, H identify the packed data elements in data element positions C, D, G, H in the first and second source registers, respectively.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The processor of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising a plurality of temporary registers, each temporary register to store one of the plurality of real and imaginary results generated by the adder network.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The processor of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the rounding method comprises one of rounding down, rounding halfway away from zero, convergent rounding, and rounding half up.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The processor of <claim-ref idref="CLM-00007">claim 7</claim-ref>, further comprising a rounding control register to store a rounding control value for specifying the rounding method.</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The processor of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising a saturation register to store a saturation bit to indicate whether any of the plurality of rounded results has been saturated to either the most positive signed word value or the most negative signed word value by the saturation circuitry.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The processor of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the adder network is to scale each of the plurality of real and imaginary results by performing an arithmetic shift by a number of bits indicated by the immediate value.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. A processor comprising:<claim-text>a decoder to decode a first instruction to generate a decoded instruction, the first instruction including operands to identify a first plurality of complex numbers comprising a first plurality of packed real and imaginary data elements, a second plurality of complex numbers comprising a second plurality of packed real and imaginary data elements, and an immediate value;</claim-text><claim-text>a first source register to store the first plurality of complex numbers including the first plurality of packed real and imaginary data elements;</claim-text><claim-text>a second source register to store the second plurality of complex numbers including the second plurality of packed real and imaginary data elements, wherein each of the second plurality of complex numbers comprises a complex conjugate of a corresponding complex number of the first plurality;</claim-text><claim-text>execution circuitry to execute the decoded instruction, the execution circuitry comprising:<claim-text>multiplier circuitry to multiply each of the first plurality of packed real data elements with a corresponding packed real data element of the second plurality to generate a first plurality of real products, and to multiply each of the first plurality of packed imaginary data elements with a corresponding packed imaginary data element of the second plurality to generate a second plurality of real products,</claim-text><claim-text>the multiplier circuitry further to multiply each of the first plurality of real data elements with a corresponding packed imaginary data element of the second plurality to generate a first plurality of imaginary products, and to multiply each of the first plurality of packed imaginary data elements with a corresponding packed real data element of the second plurality to generate a second plurality of imaginary products;</claim-text><claim-text>adder network to add each real product of the first plurality with a corresponding real product of the second plurality to generate a plurality of real results, and to subtract, from each imaginary product of the first plurality, a corresponding imaginary product of the second plurality to generate a plurality of imaginary results,</claim-text><claim-text>the adder network further to scale each of the plurality of real and imaginary results according to the immediate value to generate a plurality of scaled results, round each of the plurality of scaled real results according to a rounding method to generate a plurality of rounded results; and</claim-text><claim-text>saturation circuitry to saturate each of the plurality of rounded results to generate a plurality of final results; and</claim-text></claim-text><claim-text>a destination register to store each of the plurality of final results in a corresponding data element position of the destination register.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The processor of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the first and second plurality of packed real and imaginary data elements are stored as 16-bit data elements in the first and second source registers, each imaginary data element being stored in a data element location adjacent to a data element location of its corresponding real data element, each combination of a real and imaginary data element represents a complex number.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The processor of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the first and second source registers comprise 128-bit packed data registers configurable with data element positions A, B, C, D, E, F, G, and H storing data elements A, B, C, D, E, F, G, and H, respectively, and wherein data elements A, C, E, and G are real data elements and data elements B, D, F, and H are corresponding imaginary data elements.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The processor of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein to execute the decoded instruction, the multiplier circuitry is to perform multiplications of S1A*S2A and S1E*S2E to generate the first plurality of real products, multiplications of S1B*S2B and S1F*S2F to generate the second plurality of real products, multiplications of S1A*S2B and S1E*S2F to generate the first plurality of imaginary products, and multiplications of S1B*S2A and S1F*S2E to generate the second plurality of imaginary products, where S1 identifies the first source register, S2 identifies the second source register and A, B, E, F identify the packed data elements in data element positions A, B, E, F in the first and second source registers, respectively.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The processor of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein to execute the decoded instruction, the multiplier circuitry is to perform multiplications of S1C*S2C and S1G*S2G to generate the first plurality of real products, multiplications of S1D*S2D and S1H*S2H to generate the second plurality of real products, multiplications of S1C*S2D and S1G*S2H to generate the first plurality of imaginary products, and multiplications of S1D*S2C and S1H*S2G to generate the second plurality of imaginary products, where S1 identifies the first source register, S2 identifies the second source register and C, D, G, H identify the packed data elements in data element positions C, D, G, H in the first and second source registers, respectively.</claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The processor of <claim-ref idref="CLM-00011">claim 11</claim-ref>, further comprising a plurality of temporary registers, each temporary register to store one of the plurality of real and imaginary results generated by the adder network.</claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The processor of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the rounding method comprises one of rounding down, rounding halfway away from zero, convergent rounding, and rounding half up.</claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The processor of <claim-ref idref="CLM-00017">claim 17</claim-ref>, further comprising a rounding control register to store a rounding control value for specifying the rounding method.</claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The processor of <claim-ref idref="CLM-00011">claim 11</claim-ref>, further comprising a saturation register to store a saturation bit to indicate whether any of the plurality of rounded results has been saturated to either the most positive signed word value or the most negative signed word value by the saturation circuitry.</claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The processor of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the adder network is to scale each of the plurality of real and imaginary results by performing an arithmetic shift by a number of bits indicated by the immediate value.</claim-text></claim><claim id="CLM-00021" num="00021"><claim-text><b>21</b>. A method comprising:<claim-text>decoding a first instruction to generate a decoded instruction, the first instruction including operands to identify a first plurality of complex numbers comprising a first plurality of packed real and imaginary data elements, a second plurality of complex numbers comprising a second plurality of packed real and imaginary data elements, and an immediate value;</claim-text><claim-text>storing the first plurality of complex numbers including the first plurality of packed real and imaginary data elements in a first source register;</claim-text><claim-text>storing the second plurality of complex numbers including the second plurality of packed real and imaginary data elements in a second source register;</claim-text><claim-text>executing the decoded instruction;</claim-text><claim-text>multiplying each of the first plurality of packed real data elements with a corresponding packed real data element of the second plurality to generate a first plurality of real products;</claim-text><claim-text>multiplying each of the first plurality of packed imaginary data elements with a corresponding packed imaginary data element of the second plurality to generate a second plurality of real products;</claim-text><claim-text>multiplying each of the first plurality of real data elements with a corresponding packed imaginary data element of the second plurality to generate a first plurality of imaginary products;</claim-text><claim-text>multiplying each of the first plurality of packed imaginary data elements with a corresponding packed real data element of the second plurality to generate a second plurality of imaginary products;</claim-text><claim-text>subtracting, from each real product of the first plurality, a corresponding real product of the second plurality to generate a plurality of real results;</claim-text><claim-text>adding each imaginary product of the first plurality with a corresponding imaginary product of the second plurality to generate a plurality of imaginary results;</claim-text><claim-text>scaling each of the plurality of real and imaginary results according to the immediate value to generate a plurality of scaled results;</claim-text><claim-text>rounding each of the plurality of scaled real results according to a rounding method to generate a plurality of rounded results;</claim-text><claim-text>saturating each of the plurality of rounded results to generate a plurality of final results; and</claim-text><claim-text>storing each of the plurality of final results in a corresponding data element position of a destination register.</claim-text></claim-text></claim><claim id="CLM-00022" num="00022"><claim-text><b>22</b>. The method of <claim-ref idref="CLM-00021">claim 21</claim-ref>, wherein the first and second plurality of packed real and imaginary data elements are stored as 16-bit data elements in the first and second source registers, each imaginary data element being stored in a data element location adjacent to a data element location of its corresponding real data element, each combination of a real and imaginary data element represents a complex number.</claim-text></claim><claim id="CLM-00023" num="00023"><claim-text><b>23</b>. The method of <claim-ref idref="CLM-00022">claim 22</claim-ref>, wherein the first and second source registers comprise 128-bit packed data registers configurable with data element positions A, B, C, D, E, F, G, and H storing data elements A, B, C, D, E, F, G, and H, respectively, and wherein data elements A, C, E, and G are real data elements and data elements B, D, F, and H are corresponding imaginary data elements.</claim-text></claim><claim id="CLM-00024" num="00024"><claim-text><b>24</b>. The method of <claim-ref idref="CLM-00023">claim 23</claim-ref>, wherein multiplying each of the first plurality of packed real data elements with a corresponding packed real data element of the second plurality comprises performing multiplications of S1A*S2A and S1E*S2E, wherein multiplying each of the first plurality of packed imaginary data elements with a corresponding packed imaginary data element of the second plurality comprises performing multiplications of S1B*S2B and S1F*S2F, wherein multiplying each of the first plurality of real data elements with a corresponding packed imaginary data element of the second plurality comprises performing multiplications of S1A*S2B and S1E*S2F, and wherein multiplying each of the first plurality of packed imaginary data elements with a corresponding packed real data element of the second plurality comprises performing multiplications of S1B*S2A and S1F*S2E, where S1 identifies the first source register, S2 identifies the second source register and A, B, E, F identify the packed data elements in data element positions A, B, E, F in the first and second source registers, respectively.</claim-text></claim><claim id="CLM-00025" num="00025"><claim-text><b>25</b>. The method of <claim-ref idref="CLM-00023">claim 23</claim-ref>, wherein multiplying each of the first plurality of packed real data elements with a corresponding packed real data element of the second plurality comprises performing multiplications of S1C*S2C and S1G*S2G, wherein multiplying each of the first plurality of packed imaginary data elements with a corresponding packed imaginary data element of the second plurality comprises performing multiplications of S1D*S2D and S1H*S2H, wherein multiplying each of the first plurality of real data elements with a corresponding packed imaginary data element of the second plurality comprises performing multiplications of S1C*S2D and S1G*S2H, and wherein multiplying each of the first plurality of packed imaginary data elements with a corresponding packed real data element of the second plurality comprises performing multiplications of S1D*S2C and S1H*S2G, where S1 identifies the first source register, S2 identifies the second source register and C, D, G, H identify the packed data elements in data element positions C, D, G, H in the first and second source registers, respectively.</claim-text></claim></claims></us-patent-application>