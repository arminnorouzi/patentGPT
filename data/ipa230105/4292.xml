<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004293A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004293</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17777868</doc-number><date>20201013</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><priority-claims><priority-claim sequence="01" kind="national"><country>JP</country><doc-number>2019-214713</doc-number><date>20191127</date></priority-claim></priority-claims><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>3</main-group><subgroup>06</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>3</main-group><subgroup>064</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>3</main-group><subgroup>0656</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>3</main-group><subgroup>0679</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>3</main-group><subgroup>0604</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e61">CONTROLLER, MEMORY SYSTEM, AND METHOD OF CONTROLLING MEMORY</invention-title><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>SONY SEMICONDUCTOR SOLUTIONS CORPORATION</orgname><address><city>KANAGAWA</city><country>JP</country></address></addressbook><residence><country>JP</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>OKUBO</last-name><first-name>HIDEAKI</first-name><address><city>KANAGAWA</city><country>JP</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>NAKANISHI</last-name><first-name>KENICHI</first-name><address><city>KANAGAWA</city><country>JP</country></address></addressbook></inventor></inventors></us-parties><pct-or-regional-filing-data><document-id><country>WO</country><doc-number>PCT/JP2020/038682</doc-number><date>20201013</date></document-id><us-371c12-date><date>20220518</date></us-371c12-date></pct-or-regional-filing-data></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">An object is to reduce the number of writes of information managed by a controller to a non-volatile memory. A controller according to one aspect of the present invention includes: a first interface unit connected to a non-volatile memory including a plurality of blocks of memory cells that enter into both a first state and a second state and in which a plurality of addresses is allocated to the plurality of blocks; an information holding unit that holds first information; and a control unit that reads first data from a first block of the non-volatile memory via the first interface unit, specifies the memory cell in the second state among the memory cells in the first block and writes second data for causing the specified memory cell in the second state to transition to the first state, and selects one of the first information and the first data on the basis of the address of the first block and writes the selected first information or first data to the first block.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="73.15mm" wi="153.59mm" file="US20230004293A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="229.87mm" wi="155.62mm" file="US20230004293A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="231.90mm" wi="144.53mm" file="US20230004293A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="125.65mm" wi="143.43mm" file="US20230004293A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="178.65mm" wi="152.99mm" file="US20230004293A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="214.21mm" wi="151.55mm" file="US20230004293A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="171.28mm" wi="144.36mm" file="US20230004293A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="223.27mm" wi="152.82mm" file="US20230004293A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="171.62mm" wi="144.27mm" file="US20230004293A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="213.61mm" wi="151.13mm" file="US20230004293A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="223.69mm" wi="148.67mm" file="US20230004293A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="226.48mm" wi="149.44mm" file="US20230004293A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="174.92mm" wi="100.33mm" file="US20230004293A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="201.25mm" wi="146.47mm" file="US20230004293A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00014" num="00014"><img id="EMI-D00014" he="235.97mm" wi="124.46mm" file="US20230004293A1-20230105-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00015" num="00015"><img id="EMI-D00015" he="235.54mm" wi="155.11mm" file="US20230004293A1-20230105-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00016" num="00016"><img id="EMI-D00016" he="112.69mm" wi="117.01mm" file="US20230004293A1-20230105-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00017" num="00017"><img id="EMI-D00017" he="208.79mm" wi="150.20mm" file="US20230004293A1-20230105-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00018" num="00018"><img id="EMI-D00018" he="215.98mm" wi="144.02mm" file="US20230004293A1-20230105-D00018.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00019" num="00019"><img id="EMI-D00019" he="77.98mm" wi="104.22mm" file="US20230004293A1-20230105-D00019.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00020" num="00020"><img id="EMI-D00020" he="206.08mm" wi="152.48mm" file="US20230004293A1-20230105-D00020.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">TECHNICAL FIELD</heading><p id="p-0002" num="0001">The present disclosure relates to a controller of a non-volatile memory, a memory system, and a method of controlling a memory.</p><heading id="h-0002" level="1">BACKGROUND ART</heading><p id="p-0003" num="0002">A system including a memory module and a host is generally known. The memory module includes a non-volatile memory such as a solid state drive (SSD) and a controller. There is a method in which the host determines the life of the memory module by using information indicating a state of the memory module. Examples of the information indicating the state of the memory module include a cumulative capacity of data written to the memory module and a cumulative capacity of data read from the memory module.</p><p id="p-0004" num="0003">In a case where the controller of the memory module receives a request to acquire the cumulative capacity of writes, the cumulative capacity of reads, and the like from the host, the controller needs to supply the cumulative capacities of writes and reads to the host. Therefore, the controller needs to constantly calculate the cumulative capacities of writes and reads and hold the calculated information in preparation for receiving an acquisition request from the host.</p><p id="p-0005" num="0004">When power supply to the controller from the host is momentarily interrupted, the held information is erased. Therefore, the controller needs to write the information to the non-volatile memory in preparation for the momentary interruption of the power supply. However, if the information is written to the non-volatile memory every time when the information is updated, the number of writes increases, and this accelerates deterioration of memory cells.</p><p id="p-0006" num="0005">Japanese Patent No. 6423282 proposes a method of selectively using refresh processing and check processing in accordance with a state of a non-volatile memory, for example, the number of accesses to a plurality of blocks included in the memory. The check processing is processing of determining whether to perform the refresh processing on the basis of a bit error rate of data read from the blocks. Even if this method is used, however, the number of writes of information cannot be effectively reduced.</p><heading id="h-0003" level="1">CITATION LIST</heading><heading id="h-0004" level="1">Patent Document</heading><p id="p-0007" num="0000"><ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0006">Patent Document 1: Japanese Patent No. 6423282</li></ul></p><heading id="h-0005" level="1">SUMMARY OF THE INVENTION</heading><heading id="h-0006" level="1">Problems to be Solved by the Invention</heading><p id="p-0008" num="0007">The present disclosure provides a controller, a memory system, and a method of controlling a memory capable of reducing the number of writes of information managed by the controller to a non-volatile memory.</p><heading id="h-0007" level="1">Solutions to Problems</heading><p id="p-0009" num="0008">A controller according to one aspect of the present invention includes: a first interface unit connected to a non-volatile memory including a plurality of blocks of memory cells that enter into both a first state and a second state and in which a plurality of addresses is allocated to the plurality of blocks; an information holding unit that holds first information; and a control unit that reads first data from a first block of the non-volatile memory via the first interface unit, specifies the memory cell in the second state among the memory cells in the first block and writes second data for causing the specified memory cell in the second state to transition to the first state, and selects one of the first information and the first data on the basis of the address of the first block and writes the selected first information or first data to the first block.</p><p id="p-0010" num="0009">The control unit writes the first information in a case where the address of the first block is a first address and writes the first data in a case where the address of the first block is not the first address.</p><p id="p-0011" num="0010">The memory cell includes a selector and a variable resistor connected in series,</p><p id="p-0012" num="0011">the first state and the second state are different states of the variable resistor, and</p><p id="p-0013" num="0012">the selector is turned on at a voltage equal to or higher than a threshold, and the threshold increases as time elapses after the selector is turned on.</p><p id="p-0014" num="0013">The first state is a low resistance state, and the second state is a high resistance state.</p><p id="p-0015" num="0014">The control unit determines whether the memory cells of the first block are in the first state or the second state on the basis of the first data.</p><p id="p-0016" num="0015">A buffer that holds the first data read from the first block of the non-volatile memory is provided.</p><p id="p-0017" num="0016">The first data includes an error correction code,</p><p id="p-0018" num="0017">an error correction unit that corrects an error of the first data on the basis of the error correction code is provided, and</p><p id="p-0019" num="0018">the control unit writes the first data subjected to the error correction to the first block.</p><p id="p-0020" num="0019">The first information indicates a state of the non-volatile memory, and</p><p id="p-0021" num="0020">the control unit updates the first information of the information holding unit in accordance with the state of the non-volatile memory.</p><p id="p-0022" num="0021">The first information includes a cumulative value of the number of writes or the number of reads of the non-volatile memory, and</p><p id="p-0023" num="0022">the control unit updates the first information of the information holding unit every time when the non-volatile memory is written or read.</p><p id="p-0024" num="0023">A second interface unit connected to a host system is provided,</p><p id="p-0025" num="0024">the control unit receives a write or read command from the host system via the second interface unit and performs write to or read from the non-volatile memory in response to the command,</p><p id="p-0026" num="0025">the first information includes a cumulative value of the number of executions of the command, and</p><p id="p-0027" num="0026">the control unit updates the first information of the information holding unit every time when the command is executed.</p><p id="p-0028" num="0027">The first information includes a startup time of the non-volatile memory, and</p><p id="p-0029" num="0028">the control unit updates the first information of the information holding unit as time elapses.</p><p id="p-0030" num="0029">The first state corresponds to a first value,</p><p id="p-0031" num="0030">the second state corresponds to a second value, and</p><p id="p-0032" num="0031">the control unit does not write the second data in a case where all bits of the first data have the first value.</p><p id="p-0033" num="0032">The first state corresponds to a first value,</p><p id="p-0034" num="0033">the second state corresponds to a second value, and</p><p id="p-0035" num="0034">the control unit does not write the first data in a case where the address of the first block is not the first address and all bits of the first data have the first value.</p><p id="p-0036" num="0035">The control unit does not write the first data in a case where the address of the first block is not the first address and the address of the first block is a second address.</p><p id="p-0037" num="0036">The second address is an address of an unused block among the plurality of blocks.</p><p id="p-0038" num="0037">The second address is an address of a block storing unnecessary data among the plurality of blocks.</p><p id="p-0039" num="0038">The control unit sequentially selects the plurality of blocks in the non-volatile memory, and defines the selected block as the first block.</p><p id="p-0040" num="0039">A memory system according to one aspect of the present invention includes:</p><p id="p-0041" num="0040">a non-volatile memory that includes a plurality of blocks of memory cells that enter into both a first state and a second state and in which a plurality of addresses is allocated to the plurality of blocks; and</p><p id="p-0042" num="0041">a controller including an information holding unit that holds first information and a control unit, in which:</p><p id="p-0043" num="0042">the control unit</p><p id="p-0044" num="0043">reads first data from a first block of the non-volatile memory,</p><p id="p-0045" num="0044">specifies the memory cell in the second state among the memory cells in the first block and writes second data for causing the specified memory cell in the second state to transition to the first state, and</p><p id="p-0046" num="0045">selects one of the first information and the first data on the basis of the address of the first block and writes the selected first information or first data to the first block.</p><p id="p-0047" num="0046">A method of controlling a memory according to one aspect of the present invention includes:</p><p id="p-0048" num="0047">reading first data from a first block of a non-volatile memory that includes a plurality of blocks of memory cells that enter into both a first state and a second state and in which a plurality of addresses is allocated to the plurality of blocks;</p><p id="p-0049" num="0048">specifying the memory cell in the second state among the memory cells in the first block and writing second data for causing the specified memory cell in the second state to transition to the first state; and</p><p id="p-0050" num="0049">selecting one of first information held in an information holding unit and the first data on the basis of the address of the first block and writing the selected first information or first data to the first block.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0008" level="1">BRIEF DESCRIPTION OF DRAWINGS</heading><p id="p-0051" num="0050"><figref idref="DRAWINGS">FIG. <b>1</b></figref> shows an entire configuration example of a system according to a first embodiment.</p><p id="p-0052" num="0051"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a block diagram of a non-volatile memory (NVM).</p><p id="p-0053" num="0052"><figref idref="DRAWINGS">FIG. <b>3</b></figref> shows a configuration of a buffer.</p><p id="p-0054" num="0053"><figref idref="DRAWINGS">FIG. <b>4</b></figref> shows a configuration example of one tile.</p><p id="p-0055" num="0054"><figref idref="DRAWINGS">FIG. <b>5</b></figref> shows a configuration example of a memory cell.</p><p id="p-0056" num="0055"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a state transition diagram of a memory cell.</p><p id="p-0057" num="0056"><figref idref="DRAWINGS">FIG. <b>7</b></figref> shows an example of a relationship between an LRS, an HRS, a change of a resistance state, an overset state, an overreset state, and Vread.</p><p id="p-0058" num="0057"><figref idref="DRAWINGS">FIG. <b>8</b></figref> shows an operation flow of processing performed in a case where a request processing unit receives a program request.</p><p id="p-0059" num="0058"><figref idref="DRAWINGS">FIG. <b>9</b></figref> shows an operation flow of set processing.</p><p id="p-0060" num="0059"><figref idref="DRAWINGS">FIG. <b>10</b></figref> shows an example of data held in various buffers.</p><p id="p-0061" num="0060"><figref idref="DRAWINGS">FIG. <b>11</b></figref> shows an example of data held in various buffers.</p><p id="p-0062" num="0061"><figref idref="DRAWINGS">FIG. <b>12</b></figref> shows an operation flow of reset processing.</p><p id="p-0063" num="0062"><figref idref="DRAWINGS">FIG. <b>13</b></figref> shows an example of data held in various buffers.</p><p id="p-0064" num="0063"><figref idref="DRAWINGS">FIG. <b>14</b></figref> shows an example of data held in various buffers.</p><p id="p-0065" num="0064"><figref idref="DRAWINGS">FIG. <b>15</b></figref> shows an operation flow of processing of executing an LRS transition request.</p><p id="p-0066" num="0065"><figref idref="DRAWINGS">FIG. <b>16</b></figref> shows an operation flow of processing of executing a read request.</p><p id="p-0067" num="0066"><figref idref="DRAWINGS">FIG. <b>17</b></figref> shows a configuration example of a controller.</p><p id="p-0068" num="0067"><figref idref="DRAWINGS">FIG. <b>18</b></figref> shows an example of a logical-to-physical address conversion table.</p><p id="p-0069" num="0068"><figref idref="DRAWINGS">FIG. <b>19</b></figref> shows an example of an unused physical address list.</p><p id="p-0070" num="0069"><figref idref="DRAWINGS">FIG. <b>20</b></figref> shows an example of health information.</p><p id="p-0071" num="0070"><figref idref="DRAWINGS">FIG. <b>21</b></figref> shows a configuration example of a refresh control unit.</p><p id="p-0072" num="0071"><figref idref="DRAWINGS">FIG. <b>22</b></figref> shows an example of a refresh operation reference table.</p><p id="p-0073" num="0072"><figref idref="DRAWINGS">FIG. <b>23</b></figref> shows an operation flow of refresh processing executed by a controller.</p><p id="p-0074" num="0073"><figref idref="DRAWINGS">FIG. <b>24</b></figref> shows an operation flow of processing executed when a controller receives a read command.</p><p id="p-0075" num="0074"><figref idref="DRAWINGS">FIG. <b>25</b></figref> shows an operation flow of processing executed when a controller receives a write command.</p><p id="p-0076" num="0075"><figref idref="DRAWINGS">FIG. <b>26</b></figref> shows an operation flow of processing executed when a controller receives a read command of health information.</p><p id="p-0077" num="0076"><figref idref="DRAWINGS">FIG. <b>27</b></figref> shows an operation flow of refresh processing according to Modification Example 1.</p><p id="p-0078" num="0077"><figref idref="DRAWINGS">FIG. <b>28</b></figref> shows an operation flow of refresh processing according to Modification Example 2.</p><p id="p-0079" num="0078"><figref idref="DRAWINGS">FIG. <b>29</b></figref> shows an example of a refresh operation reference table according to Modification Example 3.</p><p id="p-0080" num="0079"><figref idref="DRAWINGS">FIG. <b>30</b></figref> shows an operation flow of refresh processing according to Modification Example 3.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0009" level="1">MODE FOR CARRYING OUT THE INVENTION</heading><p id="p-0081" num="0080">Hereinafter, embodiments of the present disclosure will be described with reference to the drawings. In one or more embodiments shown in the present disclosure, elements included in each embodiment can be combined with each other, and results of the combination also form a part of the embodiments shown in the present disclosure.</p><heading id="h-0010" level="1">First Embodiment</heading><p id="p-0082" num="0081"><figref idref="DRAWINGS">FIG. <b>1</b></figref> shows an entire configuration example of a system according to a first embodiment. The system of <figref idref="DRAWINGS">FIG. <b>1</b></figref> includes a host system <b>100</b> and a memory system <b>110</b>.</p><p id="p-0083" num="0082">The memory system <b>110</b> includes a controller <b>111</b> and a non-volatile memory (NVM) <b>112</b>. The controller <b>111</b> communicates with the host system <b>100</b> and receives a write command or a read command from the host system <b>100</b>. Further, the controller <b>111</b> writes data to the NVM <b>112</b> or reads data from the NVM <b>112</b> on the basis of the received command.</p><p id="p-0084" num="0083">Upon receipt of a write command from the host system <b>100</b>, the controller <b>111</b> further receives data to be written from the host system <b>100</b>. The controller <b>111</b> issues a write request to the NVM <b>112</b> and transmits the data received from the host system <b>100</b> to the NVM <b>112</b>. The NVM <b>112</b> writes the data received from the controller <b>111</b> to an internal memory cell array.</p><p id="p-0085" num="0084">Upon receipt of a read command from the host system <b>100</b>, the controller <b>111</b> issues a read request to the NVM <b>112</b> and reads data from the NVM <b>112</b>. The controller <b>111</b> transmits the data read from the NVM <b>112</b> to the host system <b>100</b>.</p><p id="p-0086" num="0085">When generating a write command and a read command, the host system <b>100</b> designates a logical address as an address indicating a location of data to be written or read.</p><p id="p-0087" num="0086">A block indicated by one logical address is, for example, 512 bytes in size. A range of logical addresses that can be designated by the host system <b>100</b> is, for example, 0x000000 to 0xDFFFFF (7 gigabytes in size).</p><p id="p-0088" num="0087">Meanwhile, when generating a program request (write request) and a read request for the NVM <b>112</b>, the controller <b>111</b> uses a physical address as the address indicating the location of the data.</p><p id="p-0089" num="0088">A block indicated by one physical address is, for example, 525 bytes (4200 bits) in size. Among 525 bytes, 512 consecutive bytes from the head are the data to be written received from the host system, and the remaining 13 bytes are an error correction code (ECC). A range of physical addresses that can be designated by the controller <b>111</b> is, for example, 0x000000 to 0xFFFFFF (8 gigabytes in size).</p><p id="p-0090" num="0089">[Description of NVM]</p><p id="p-0091" num="0090"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a block diagram of the NVM <b>112</b>.</p><p id="p-0092" num="0091">The NVM <b>112</b> includes an interface unit (IF unit) <b>200</b>, a request processing unit <b>201</b>, a verification unit <b>202</b>, a buffer <b>203</b>, a read control unit <b>205</b>, a program control unit <b>206</b>, a voltage pulse control unit <b>207</b>, a word line control unit <b>208</b>, a bit line control unit <b>209</b>, and a memory cell array <b>210</b>.</p><p id="p-0093" num="0092"><figref idref="DRAWINGS">FIG. <b>3</b></figref> shows a configuration of the buffer <b>203</b>. The buffer <b>203</b> includes a write data buffer <b>300</b>, a read data buffer <b>301</b>, and a verification buffer <b>302</b>. The write data buffer <b>300</b>, the read data buffer <b>301</b>, and the verification buffer <b>302</b> are, for example, 4200 bits (525 bytes) in size.</p><p id="p-0094" num="0093">The interface unit <b>200</b> communicates with the controller <b>111</b>. Upon receipt of a request from the controller <b>111</b>, the interface unit <b>200</b> supplies the received request to the request processing unit <b>201</b>. Examples of the types of the request include a write request (program request) and a read request. Further, upon receipt of data to be written from the controller <b>111</b>, the interface unit <b>200</b> writes the data to the write data buffer <b>300</b> of the buffer <b>203</b>.</p><p id="p-0095" num="0094">Upon receipt of the request from the interface unit <b>200</b>, the request processing unit <b>201</b> supplies an instruction according to the type of the request to the program control unit <b>206</b> or the read control unit <b>205</b>. Specifically, in a case of the write request (program request), a write instruction is supplied to the program control unit <b>206</b>, whereas, in a case of the read request, a read instruction is supplied to the read control unit <b>205</b>.</p><p id="p-0096" num="0095">The word line control unit <b>208</b> selects a word line from a plurality of word lines in the memory cell array <b>210</b> in response to a pulse from the voltage pulse control unit <b>207</b> and applies a voltage to the selected word line. The bit line control unit <b>209</b> selects a bit line from a plurality of bit lines in the memory cell array <b>210</b> in response to a pulse from the voltage pulse control unit <b>207</b> and applies a voltage to the selected bit line.</p><p id="p-0097" num="0096">The read control unit <b>205</b> transmits a read instruction signal to the voltage pulse control unit <b>207</b> in response to the read instruction from the request processing unit <b>201</b>. In response to the instruction from the read control unit <b>205</b>, the voltage pulse control unit <b>207</b> applies a read pulse as a voltage to the memory cell array <b>210</b> via the word line control unit <b>208</b> and the bit line control unit <b>209</b>.</p><p id="p-0098" num="0097">The program control unit <b>206</b> transmits a set or reset instruction signal to the voltage pulse control unit <b>207</b> in response to the write instruction (a set instruction or a reset instruction described later) from the request processing unit <b>201</b>. The voltage pulse control unit <b>207</b> applies a set pulse or a reset pulse as a voltage to the memory cell array <b>210</b> via the word line control unit <b>208</b> and the bit line control unit <b>209</b>. As described later, in the present embodiment, the set means writing &#x201c;1&#x201d;, that is, causing a memory cell to transition to a low resistance state (LRS). The reset means writing &#x201c;0&#x201d;, that is, causing a memory cell to transition to a high resistance state (HRS). The read data buffer holds data read from the memory cell array <b>210</b>. The verification buffer holds data in which a value of a bit corresponding to a memory cell to be subjected to the set is &#x201c;1&#x201d; and a value of a bit corresponding to a memory cell not required to be subjected to the set is &#x201c;0&#x201d;.</p><p id="p-0099" num="0098">[Description of Memory Cell Array]</p><p id="p-0100" num="0099">The memory cell array <b>210</b> includes a plurality of tiles. Each tile includes a plurality of memory cells.</p><p id="p-0101" num="0100">In the present embodiment, the memory cell array <b>210</b> includes, for example, 4200 tiles. Each tile includes 4096&#xd7;4096 memory cells.</p><p id="p-0102" num="0101"><figref idref="DRAWINGS">FIG. <b>4</b></figref> shows a configuration example of one tile. Memory cells <b>401</b> are placed at intersections of 4096 bit lines and 4096 word lines. The memory cells <b>401</b> have a cross-point structure. The cross-point structure is a structure including memory cells at intersections of bit lines and word lines.</p><p id="p-0103" num="0102"><figref idref="DRAWINGS">FIG. <b>5</b></figref> shows a configuration example of the memory cell. The memory cell <b>401</b> includes a selector (switch) <b>510</b> and a variable resistor <b>520</b>. The selector <b>510</b> and the variable resistor <b>520</b> are connected in series.</p><p id="p-0104" num="0103"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a state transition diagram of the memory cell. The variable resistor <b>520</b> has one of the low resistance state (LRS) and the high resistance state (HRS) that transition to each other. The variable resistor <b>520</b> has a rewrite life that is the number of possible state transitions. The selector <b>510</b> has a selector life that is the number of times the selector can be turned on (also referred to as snapped). The low resistance state (LRS) corresponds to, for example, a first state of the memory cell, and the high resistance state (HRS) corresponds to, for example, a second state of the memory cell. The memory cell enters into both the first state (LRS) and the second state (HRS). Further, for example, the first state (LRS) corresponds to a first value, and the second state (HRS) corresponds to a second value. The first value corresponds to &#x201c;1&#x201d; and the second value corresponds to &#x201c;0&#x201d;. Alternatively, the first value may correspond to &#x201c;0&#x201d; and the second value may correspond to &#x201c;1&#x201d;. In the present embodiment, it is assumed that the LRS corresponds to &#x201c;1&#x201d; and the HRS corresponds to &#x201c;0&#x201d;, but the present disclosure is not limited thereto.</p><p id="p-0105" num="0104">When the selector <b>510</b> is not turned on for a long time, a threshold voltage Vsnap necessary to turn on the selector <b>510</b> increases (referred to as drift). When a voltage equal to or higher than the threshold voltage subjected to the drift is applied to the selector <b>510</b>, the selector <b>510</b> is turned on. When the selector <b>510</b> is turned on, the drift is eliminated. Therefore, the threshold voltage subjected to the drift returns to a voltage of an initial value.</p><p id="p-0106" num="0105">In order to read data from a memory cell <b>401</b>, pulses of voltages of &#x2212;Vread/2 and Vread/2 are applied to a word line and a bit line, respectively, connected to the selected memory cell <b>401</b>. A read pulse of a predetermined read voltage Vread (=Vread/2&#x2212;(&#x2212;Vread/2)) is applied to the selected memory cell <b>401</b>. On the basis of a current flowing through the memory cell <b>401</b>, whether a resistance state of the variable resistor <b>520</b> is the LRS or the HRS is determined. In a case where the selector <b>510</b> is turned on, a current flows through the memory cell <b>401</b>. In this case, it is determined that the resistance state of the variable resistor <b>520</b> is the LRS, and data of &#x201c;1&#x201d; is read. In a case where the selector <b>510</b> is not turned on, a current does not flow through the memory cell <b>401</b>. In this case, it is determined that the resistance state of the variable resistor <b>520</b> is the HRS, and data of &#x201c;0&#x201d; is read.</p><p id="p-0107" num="0106">In a case where the threshold voltage Vsnap is higher than the predetermined read voltage due to occurrence of the drift, the selector <b>510</b> is not turned on by the application of the predetermined read voltage even if the variable resistor <b>520</b> is in the LRS. Therefore, even if the resistance state of the variable resistor <b>520</b> is the LRS, a current necessary to determine the LRS does not flow. As a result, the state of the variable resistor <b>520</b> is erroneously determined as the HRS. That is, although the memory cell actually stores data of &#x201c;1&#x201d;, it is determined that the memory cell stores data of &#x201c;0&#x201d;.</p><p id="p-0108" num="0107">In a case where data of &#x201c;1&#x201d; is written to a memory cell (referred to as set), pulses of voltages of &#x2212;Vset/2 and Vset/2 are applied to a word line and a bit line, respectively, connected to the selected memory cell <b>401</b>. A set pulse of a predetermined set voltage Vset (=Vset/2&#x2212;(&#x2212;Vset/2)) is applied to the selected memory cell <b>401</b>. In a case where the resistance state of the variable resistor <b>520</b> is the HRS, the state transitions to the LRS. Therefore, data of &#x201c;1&#x201d; is written to the memory cell.</p><p id="p-0109" num="0108">In a case where data of &#x201c;0&#x201d; is written to a memory cell (referred to as reset), pulses of voltages of Vreset/2 and &#x2212;Vreset/2 are applied to a word line and a bit line, respectively, connected to the selected memory cell <b>401</b>. A reset pulse of a predetermined reset voltage Vrset (=Vrset/2&#x2212;(&#x2212;Vrset/2)) is applied to the selected memory cell <b>401</b>. A direction of the voltage of the reset pulse is opposite to a direction of the set pulse. In a case where the resistance state of the variable resistor <b>520</b> is the LRS, the state transitions to the HRS. Therefore, data of &#x201c;0&#x201d; is written to the memory cell.</p><p id="p-0110" num="0109">Note that, when the reset pulse is applied to the memory cell <b>401</b> while the variable resistor <b>520</b> is in the HRS, the memory cell <b>401</b> enters into an overreset state. In the overreset state, the memory cell <b>401</b> does not transition to the LRS even if the set pulse is applied to the memory cell <b>401</b>, and the memory cell <b>401</b> cannot normally store data. The memory cell <b>401</b> in the overreset state becomes a cell in a defective state (defective cell).</p><p id="p-0111" num="0110">Similarly, when the set pulse is applied to the memory cell <b>401</b> while the variable resistor <b>520</b> is in the LRS state, the memory cell <b>401</b> enters into an overset state. In the overset state, the memory cell <b>401</b> does not transition to the HRS even if the reset pulse is applied, and the memory cell <b>401</b> cannot normally store data. The memory cell <b>401</b> in the overset state becomes a defective cell.</p><p id="p-0112" num="0111">In order to keep the threshold voltage Vsnap equal to or lower than the predetermined read voltage Vread so that the selector <b>510</b> is turned on at the predetermined read voltage Vread, it is necessary to turn on the selector <b>510</b> periodically or at arbitrary intervals to eliminate the drift. When the selector <b>510</b> is turned on, the threshold voltage Vsnap returns to the voltage of the initial value lower than the predetermined read voltage. Therefore, the drift is eliminated.</p><p id="p-0113" num="0112">The controller <b>111</b> performs refresh processing of the memory cells (refresh processing of the drift) periodically or at arbitrary intervals. The refresh processing includes an operation of turning on the selectors <b>510</b> of the memory cells, and therefore the drift can be eliminated. More specifically, in the refresh processing, data (1 or 0) is temporarily read from a target memory cell and is held. A read voltage at this time is equal to or higher than a voltage obtained by adding an amount of rise caused by the drift to the predetermined read voltage. The amount of rise caused by the drift can be calculated by acquiring correspondence information in which an elapsed time from a time at which the selector <b>510</b> has been turned on and a rising voltage of the drift are associated with each other in advance by measurement or simulation. Next, in a case where the resistance state of the memory cell is the HRS (in a case where the read data is 0), the variable resistor <b>520</b> of the memory cell in the HRS is caused to transition to the LRS (1 is written). The selector <b>510</b> is turned on at this time, and thus the drift is eliminated. Thereafter, processing of returning the held data to the memory cell is performed. That is, the held data 0 is written to the memory cell, and the variable resistor <b>520</b> is caused to transition to the HRS. Meanwhile, in a case where the resistance state of the memory cell is the LRS (in a case where the read data is 1), the selector <b>510</b> is on at the time when the data is read. Thus, there is no need to perform the processing of causing the memory cell to transition to the LRS and the processing of writing back the read data. In the memory cell of the present embodiment, it is assumed that the drift is eliminated by turning on the selector <b>510</b> again within 10,000 [s] after turning on the selector <b>510</b>, and the threshold voltage Vsnap risen by the drift returns to the initial voltage.</p><p id="p-0114" num="0113"><figref idref="DRAWINGS">FIG. <b>7</b></figref> shows an example of a relationship between the LRS, the HRS, a change of the resistance state, the overset state, the overreset state, and Vread. The horizontal axis represents the voltage, and the vertical axis represents the number of cumulative memory cells. A graph of the LRS and a graph of the HRS show a cumulative distribution of the number of memory cells in the LRS and a cumulative distribution of the number of memory cells in the HRS, respectively. The graphs show, for example, states at a certain point of time.</p><p id="p-0115" num="0114"><figref idref="DRAWINGS">FIG. <b>8</b></figref> shows an operation flow of processing performed in a case where the request processing unit <b>201</b> receives a program request (write request).</p><p id="p-0116" num="0115">(S<b>1000</b>)</p><p id="p-0117" num="0116">Upon receipt of a program request and a physical address to be written from the controller <b>111</b> via the interface unit <b>200</b>, the request processing unit <b>201</b> starts program request processing in S<b>1000</b>. A block (area) indicated by one physical address includes a plurality of memory cells (e.g., memory cells corresponding to 525 bytes). Data of 4200 bits (525 bytes) necessary for the program request processing is transmitted from the interface unit <b>200</b> to the write data buffer <b>300</b> and is held in the write data buffer <b>300</b>. Bits of bit strings of 525 bytes stored in the write data buffer <b>300</b> are associated with the plurality of memory cells in the block designated by the physical address on a one-to-one basis. A memory cell corresponding to a bit of &#x201c;1&#x201d; in the bit strings is a memory cell to enter into the LRS. The physical address is transferred from the interface unit <b>200</b> to the request processing unit <b>201</b> and is held in the request processing unit <b>201</b>.</p><p id="p-0118" num="0117">(S<b>1100</b>)</p><p id="p-0119" num="0118">The request processing unit <b>201</b> executes set processing. In the set processing, a memory cell to which 1 is to be written is specified, and 1 is written to the specified memory cell. Specifically, a memory cell whose current resistance state is the HRS(0) is specified among the memory cells whose resistance state is 1 in the write data buffer <b>300</b>. This is because there is no need to write 1 to a memory cell to which 1 has already been written (a memory cell whose current resistance state is the LRS). An operation flow of the set processing is shown in <figref idref="DRAWINGS">FIG. <b>9</b></figref> described later.</p><p id="p-0120" num="0119">(S<b>1010</b>)</p><p id="p-0121" num="0120">The request processing unit <b>201</b> determines whether or not the set processing executed in step S<b>1100</b> has been normally terminated. In a case where the set processing has been normally terminated, the processing proceeds to step S<b>1200</b>. In a case where the set processing has been terminated with an error, the processing proceeds to step S<b>1040</b>.</p><p id="p-0122" num="0121">(S<b>1200</b>)</p><p id="p-0123" num="0122">The request processing unit <b>201</b> executes reset processing. In the reset processing, a memory cell to which 0 is to be written is specified, and 0 is written to the specified memory cell. Specifically, a memory cell whose current resistance state is the LRS (1) is specified among the memory cells whose resistance state is 0 in the write data buffer <b>300</b>. This is because there is no need to write 0 to a memory cell to which 0 has already been written (a memory cell whose current resistance state is the HRS). An operation flow of the reset processing is shown in <figref idref="DRAWINGS">FIG. <b>12</b></figref> described later.</p><p id="p-0124" num="0123">(S<b>1020</b>)</p><p id="p-0125" num="0124">The request processing unit <b>201</b> determines whether or not the reset processing executed in step S<b>1200</b> has been normally terminated. In a case where the reset processing has been normally terminated, the processing proceeds to step S<b>1030</b>. In a case where the reset processing has been terminated with an error, the processing proceeds to step S<b>1040</b>.</p><p id="p-0126" num="0125">(S<b>1030</b>)</p><p id="p-0127" num="0126">The request processing unit <b>201</b> notifies the controller <b>111</b> via the interface unit <b>200</b> that the program request processing has been normally terminated.</p><p id="p-0128" num="0127">(S<b>1040</b>)</p><p id="p-0129" num="0128">The request processing unit <b>201</b> notifies the controller <b>111</b> via the interface unit <b>200</b> that an error has occurred in the program request processing.</p><p id="p-0130" num="0129">(S<b>1050</b>)</p><p id="p-0131" num="0130">After step <b>1321</b> or S<b>1040</b>, the program request processing is terminated.</p><p id="p-0132" num="0131">[Description of Set Processing]</p><p id="p-0133" num="0132"><figref idref="DRAWINGS">FIG. <b>9</b></figref> shows the operation flow of the set processing executed in step S<b>1100</b> of <figref idref="DRAWINGS">FIG. <b>8</b></figref>. A data size handled in the set processing is, for example, 4200 bits (525 bytes).</p><p id="p-0134" num="0133">(S<b>1101</b>)</p><p id="p-0135" num="0134">The request processing unit <b>201</b> designates the physical address received from the controller <b>111</b> with respect to the read control unit <b>205</b> and instructs the read control unit <b>205</b> to read 4200 bits (525 bytes). The read control unit <b>205</b> reads data from the memory cell array <b>210</b> via the voltage pulse control unit <b>207</b>. The read data is transmitted to the read data buffer <b>301</b> and is held in the read data buffer <b>301</b>.</p><p id="p-0136" num="0135">(S<b>1102</b>)</p><p id="p-0137" num="0136">The request processing unit <b>201</b> instructs the verification unit <b>202</b> to compare the data held in the read data buffer <b>301</b> with the data held in the write data buffer <b>300</b>. The verification 302 unit compares the data held in the read data buffer <b>301</b> with the data held in the write data buffer <b>300</b> in units of bits. Therefore, a memory cell to which the set pulse is to be applied (a memory cell to which 1 is to be written) is specified.</p><p id="p-0138" num="0137">The memory cell to which the set pulse is to be applied is a memory cell whose value held in the write data buffer <b>300</b> is &#x201c;1&#x201d; and whose value held in the read data buffer <b>301</b> is &#x201c;0&#x201d;. This memory cell needs to change the resistance state of the memory cell corresponding to a bit from the HRS to the LRS.</p><p id="p-0139" num="0138">The verification unit <b>202</b> generates data in which a value of a bit corresponding to the memory cell to which the set pulse needs to be applied is &#x201c;1&#x201d; and a value of a bit corresponding to a memory cell to which the set pulse does not need to be applied is &#x201c;0&#x201d;. The generated data is held in the verification buffer <b>302</b>. This data corresponds to information for specifying a memory cell to which the set pulse is to be applied.</p><p id="p-0140" num="0139"><figref idref="DRAWINGS">FIG. <b>10</b></figref> shows an example of the data held in the write data buffer <b>300</b>, the read data buffer <b>301</b>, and the verification buffer <b>302</b>. <figref idref="DRAWINGS">FIG. <b>10</b></figref> shows, as a simple example, an example of specifying a cell to be subjected to the set processing by using 8-bit data. That is, 8 bits correspond to memory cells on a one-to-one basis, and memory cells of 1 in the verification buffer <b>302</b> are memory cells to which the set pulse is to be applied.</p><p id="p-0141" num="0140">(S<b>1103</b>)</p><p id="p-0142" num="0141">The request processing unit <b>201</b> sets a value of a counter provided inside the request processing unit <b>201</b> to 1. The counter indicates the number of repetitive executions of verification processing performed in step S<b>1106</b> described later.</p><p id="p-0143" num="0142">(S<b>1104</b>)</p><p id="p-0144" num="0143">The request processing unit <b>201</b> instructs the program control unit <b>206</b> to apply the set pulse to the memory cells whose bit is 1 in the data held in the verification buffer <b>302</b>. The program control unit <b>206</b> performs control to apply the set pulse to the memory cells, thereby performing processing of causing the resistance state of the memory cells to transition to the LRS.</p><p id="p-0145" num="0144">(S<b>1105</b>)</p><p id="p-0146" num="0145">The request processing unit <b>201</b> designates the physical address designated by the controller <b>111</b> with respect to the read control unit <b>205</b> and instructs the read control unit <b>205</b> to read data of 4200 bits (525 bytes). The read control unit <b>205</b> reads data from the memory cell array <b>210</b> via the voltage pulse control unit <b>207</b>. The read data is transmitted to the read data buffer <b>301</b> and is held in the read data buffer <b>301</b>.</p><p id="p-0147" num="0146">(S<b>1106</b>)</p><p id="p-0148" num="0147">The request processing unit <b>201</b> instructs the verification unit <b>202</b> to compare the data held in the read data buffer <b>301</b> in step S<b>1105</b> with the data held in the write data buffer <b>300</b>. The verification unit <b>202</b> compares both the data with each other. A bit to be compared is a bit whose value held in the write data buffer <b>300</b> is &#x201c;1&#x201d;. A bit whose value held in the write data buffer <b>300</b> is &#x201c;1&#x201d; and whose value held in the read data buffer <b>301</b> is &#x201c;0&#x201d; is a bit that has failed in the set (fail). A bit whose data value held in the write data buffer <b>300</b> is &#x201c;1&#x201d; and whose value held in the read data buffer <b>301</b> is also &#x201c;1&#x201d; is a bit that has succeeded in the set (pass). Such processing of determining whether or not the set (or reset) has been successfully performed on a bit to be compared is referred to as the verification processing.</p><p id="p-0149" num="0148">The verification unit <b>202</b> generates data in which &#x201c;1&#x201d; is set to a failure bit, &#x201c;0&#x201d; is set to a success bit, and &#x201c;0&#x201d; is set to a bit other than bits to be compared. The generated data is held in the verification buffer <b>302</b>.</p><p id="p-0150" num="0149"><figref idref="DRAWINGS">FIG. <b>11</b></figref> shows an example of the data held in the write data buffer <b>300</b>, the read data buffer <b>301</b>, and the verification buffer <b>302</b> subjected to the verification processing.</p><p id="p-0151" num="0150">(S<b>1107</b>)</p><p id="p-0152" num="0151">In a case where all the bits are &#x201c;0&#x201d; in the data held in the verification buffer <b>302</b>, the verification unit <b>202</b> notifies the request processing unit <b>201</b> that the set processing has been normally terminated, and the processing proceeds to step S<b>1110</b>. Meanwhile, in a case where at least one bit in the data held in the verification buffer <b>302</b> is &#x201c;1&#x201d;, the processing proceeds to step S<b>1108</b>.</p><p id="p-0153" num="0152">(S<b>1110</b>)</p><p id="p-0154" num="0153">The request processing unit <b>201</b> normally terminates the set processing.</p><p id="p-0155" num="0154">(S<b>1108</b>)</p><p id="p-0156" num="0155">The number of repetitions of how many times the verification processing in step S<b>1107</b> has been performed is determined on the basis of the value of the counter in the request processing unit <b>201</b>. In a case where the number of repetitions has not reached an upper limit value (e.g., four), the processing proceeds to step S<b>1109</b>. Meanwhile, in a case where the number of repetitions has reached the upper limit value, the verification unit <b>202</b> notifies the request processing unit <b>201</b> that the set processing has failed, and the processing proceeds to step S<b>1111</b>.</p><p id="p-0157" num="0156">(S<b>1109</b>)</p><p id="p-0158" num="0157">The value of the counter is incremented by 1, and the processing returns to step S<b>1104</b>. In step S<b>1104</b>, the set is executed again. In this case, a memory cell to which the pulse is to be applied is a memory cell corresponding to a bit whose value of &#x201c;1&#x201d; is held in the verification buffer.</p><p id="p-0159" num="0158">(S<b>1111</b>)</p><p id="p-0160" num="0159">The request processing unit <b>201</b> terminates the set processing with an error.</p><p id="p-0161" num="0160">[Description of Reset Processing]</p><p id="p-0162" num="0161"><figref idref="DRAWINGS">FIG. <b>12</b></figref> shows the operation flow of the reset processing executed in step S<b>1200</b> of <figref idref="DRAWINGS">FIG. <b>8</b></figref>. Steps of the processing in <figref idref="DRAWINGS">FIG. <b>12</b></figref> similar to those in <figref idref="DRAWINGS">FIG. <b>8</b></figref> are denoted by the same reference numerals. A data size handled in the reset processing is, for example, 4200 bits (525 bytes). Data held in the write data buffer <b>300</b> is the same as the data used in the set processing in S<b>1100</b>. Further, a physical address is also the same as that in the set processing in S<b>1100</b>.</p><p id="p-0163" num="0162">(S<b>1101</b>)</p><p id="p-0164" num="0163">The request processing unit <b>201</b> designates the physical address received from the controller <b>111</b> with respect to the read control unit <b>205</b> and instructs the read control unit <b>205</b> to read 4200 bits (525 bytes). The read control unit <b>205</b> reads data from the memory cell array <b>210</b> via the voltage pulse control unit <b>207</b>. The read data is transmitted to the read data buffer <b>301</b> and is held in the read data buffer <b>301</b>.</p><p id="p-0165" num="0164">(S<b>1202</b>)</p><p id="p-0166" num="0165">The request processing unit <b>201</b> instructs the verification unit <b>202</b> to compare the data held in the read data buffer <b>301</b> in step S<b>1101</b> with the data held in the write data buffer <b>300</b>. The verification 302 unit compares the data held in the read data buffer <b>301</b> with the data held in the write data buffer <b>300</b> in units of bits. Therefore, a memory cell to which the reset pulse is to be applied (a memory cell to which 0 is to be written) is specified. The memory cell to which the reset pulse is to be applied is a memory cell whose value held in the write data buffer <b>300</b> is &#x201c;0&#x201d; and whose data value held in the read data buffer <b>301</b> is &#x201c;1&#x201d;. This memory cell needs to change the resistance state from the LRS to the HRS.</p><p id="p-0167" num="0166">The verification unit <b>202</b> generates data in which a value of a bit corresponding to the memory cell to which the reset pulse needs to be applied is &#x201c;1&#x201d; and a value of a bit corresponding to a memory cell to which the reset pulse does not need to be applied is &#x201c;0&#x201d;. The generated data is held in the verification buffer <b>302</b>. This data corresponds to information for specifying a memory cell to which the reset pulse is to be applied.</p><p id="p-0168" num="0167"><figref idref="DRAWINGS">FIG. <b>13</b></figref> shows an example of the data held in the write data buffer <b>300</b>, the read data buffer <b>301</b>, and the verification buffer <b>302</b>. <figref idref="DRAWINGS">FIG. <b>13</b></figref> shows, as a simple example, an example of specifying a cell to be subjected to the reset processing by using 8-bit data. That is, 8 bits correspond to memory cells on a one-to-one basis, and memory cells of 1 in the verification buffer <b>302</b> are memory cells to which the reset pulse is to be applied.</p><p id="p-0169" num="0168">(S<b>1204</b>)</p><p id="p-0170" num="0169">The request processing unit <b>201</b> instructs the program control unit <b>206</b> to apply the reset pulse to the memory cells whose bit is 1 in the data held in the verification buffer <b>302</b>. The program control unit <b>206</b> performs control to apply the reset pulse to the memory cells, thereby performing processing of causing the resistance state of the memory cells to transition to the HRS.</p><p id="p-0171" num="0170">(S<b>1105</b>)</p><p id="p-0172" num="0171">The request processing unit <b>201</b> designates the physical address designated by the controller <b>111</b> with respect to the read control unit <b>205</b> and instructs the read control unit <b>205</b> to read data of 4200 bits (525 bytes). The read control unit <b>205</b> reads data from the memory cell array <b>210</b> via the voltage pulse control unit <b>207</b>. The read data is transmitted to the read data buffer <b>301</b> and is held in the read data buffer <b>301</b>.</p><p id="p-0173" num="0172">(S<b>1205</b>)</p><p id="p-0174" num="0173">The request processing unit <b>201</b> instructs the verification unit <b>202</b> to compare the data held in the read data buffer <b>301</b> in step S<b>1105</b> with the data held in the write data buffer <b>300</b>. The verification unit <b>202</b> performs the verification processing by comparing both the data with each other. A bit to be compared is a bit whose value held in the write data buffer <b>300</b> is &#x201c;0&#x201d;. A bit whose value held in the write data buffer <b>300</b> is &#x201c;0&#x201d; and whose value held in the read data buffer <b>301</b> is &#x201c;1&#x201d; is a bit that has failed in the reset (fail). A bit whose value held in the write data buffer <b>300</b> is &#x201c;0&#x201d; and whose value held in the read data buffer <b>301</b> is also &#x201c;0&#x201d; is a bit that has succeeded in the reset (pass).</p><p id="p-0175" num="0174">The verification unit <b>202</b> generates data in which &#x201c;1&#x201d; is set to a failure bit, &#x201c;0&#x201d; is set to a success bit, and &#x201c;0&#x201d; is set to a bit other than bits to be compared. The generated data is held in the verification buffer <b>302</b>.</p><p id="p-0176" num="0175"><figref idref="DRAWINGS">FIG. <b>14</b></figref> shows an example of the data held in the write data buffer <b>300</b>, the read data buffer <b>301</b>, and the verification buffer <b>302</b> subjected to the verification processing.</p><p id="p-0177" num="0176">(S<b>1107</b>)</p><p id="p-0178" num="0177">In a case where all the bits are &#x201c;0&#x201d; in the data held in the verification buffer <b>302</b>, the verification unit <b>202</b> notifies the request processing unit <b>201</b> that the reset processing has been normally terminated, and the processing proceeds to step S<b>1210</b>. Meanwhile, in a case where at least one bit in the data held in the verification buffer <b>302</b> is &#x201c;1&#x201d;, the processing proceeds to step S<b>1108</b>.</p><p id="p-0179" num="0178">(S<b>1210</b>)</p><p id="p-0180" num="0179">The request processing unit <b>201</b> normally terminates the reset processing.</p><p id="p-0181" num="0180">(S<b>1108</b>)</p><p id="p-0182" num="0181">The number of repetitions of how many times the verification processing in step S<b>1107</b> has been performed is determined on the basis of the value of the counter in the request processing unit <b>201</b>. In a case where the number of repetitions has not reached an upper limit value (e.g., four), the processing proceeds to step S<b>1109</b>. Meanwhile, in a case where the number of repetitions has reached the upper limit value, the verification unit <b>202</b> notifies the request processing unit <b>201</b> that the reset processing has failed, and the processing proceeds to step S<b>1211</b>.</p><p id="p-0183" num="0182">(S<b>1109</b>)</p><p id="p-0184" num="0183">The value of the counter is incremented by 1, and the processing returns to step S<b>1104</b>. In step S<b>1104</b>, the reset is executed again. In this case, a memory cell to which the pulse is to be applied is a memory cell holding &#x201c;1&#x201d; in the verification buffer.</p><p id="p-0185" num="0184">(S<b>1211</b>)</p><p id="p-0186" num="0185">The request processing unit <b>201</b> terminates the reset processing with an error.</p><p id="p-0187" num="0186">[Description of LRS Transition Request Processing]</p><p id="p-0188" num="0187"><figref idref="DRAWINGS">FIG. <b>15</b></figref> shows an operation flow of processing of executing an LRS transition request received from the controller <b>111</b>. The LRS transition request is a request for processing of causing a resistance state of a designated memory cell to transition from the HRS to the LRS. This processing is used in the refresh processing described later. The processing in <figref idref="DRAWINGS">FIG. <b>15</b></figref> is substantially the same as the set processing described with reference to <figref idref="DRAWINGS">FIG. <b>9</b></figref>, and therefore the same steps as those in <figref idref="DRAWINGS">FIG. <b>9</b></figref> are denoted by the same reference numerals, and the same description will be omitted. <figref idref="DRAWINGS">FIG. <b>15</b></figref> is different from <figref idref="DRAWINGS">FIG. <b>9</b></figref> in that step S<b>1101</b> (reading data) in <figref idref="DRAWINGS">FIG. <b>9</b></figref> does not exist and step S<b>1102</b> is replaced with step S<b>1302</b>.</p><p id="p-0189" num="0188">(S<b>1300</b>)</p><p id="p-0190" num="0189">Upon receipt of an LRS transition request and a physical address from the controller <b>111</b> via the interface unit <b>200</b>, the request processing unit <b>201</b> starts LRS transition request processing in S<b>1300</b>. Data of 4200 bits (525 bytes) necessary for the LRS transition request processing is transmitted to the write data buffer <b>300</b> via the interface unit <b>200</b> and is held in the write data buffer <b>300</b>. Further, the physical address to be subjected to the LRS transition is transmitted to the request processing unit <b>201</b> via the interface unit <b>200</b> and is held in the request processing unit <b>201</b>. The physical address to be subjected to the LRS transition corresponds to, for example, an address of a first block. The data necessary for the LRS transition request processing corresponds to, for example, second data for causing a memory cell in the second state (HRS) among memory cells in the first block to transition to the first state (LRS).</p><p id="p-0191" num="0190">(S<b>1302</b>)</p><p id="p-0192" num="0191">The request processing unit <b>201</b> specifies a memory cell corresponding to a bit having a value of &#x201c;1&#x201d; in the data held in the write data buffer <b>300</b> as a memory cell to which the set pulse is to be applied. The request processing unit <b>201</b> generates data in which a value of a bit corresponding to the memory cell to which the set pulse needs to be applied is &#x201c;1&#x201d; and a value of a bit corresponding to a memory cell to which the set pulse does not need to be applied is &#x201c;0&#x201d;. The generated data is held in the verification buffer <b>302</b>. This data corresponds to information regarding a memory cell to which the set pulse is to be applied (memory cell to be subjected to the LRS transition).</p><p id="p-0193" num="0192">The subsequent steps are similar to those in <figref idref="DRAWINGS">FIG. <b>9</b></figref>, and thus the description thereof will be omitted.</p><p id="p-0194" num="0193">[Description of Read Request Processing]</p><p id="p-0195" num="0194"><figref idref="DRAWINGS">FIG. <b>16</b></figref> shows an operation flow of processing of executing a read request received from the controller <b>111</b>.</p><p id="p-0196" num="0195">Upon receipt of a read request and a physical address to be read from the controller <b>111</b> via the interface unit <b>200</b>, the request processing unit <b>201</b> starts execution of the read request in step S<b>1400</b>. The physical address is transmitted to the request processing unit <b>201</b> via the interface unit <b>200</b> and is held in the request processing unit <b>201</b>. In the read request processing, data of 4200 bits (525 bytes) is read from a block indicated by the physical address in the memory cell array <b>210</b>, and the read data is transmitted to the controller <b>111</b>.</p><p id="p-0197" num="0196">(S<b>1401</b>)</p><p id="p-0198" num="0197">The request processing unit <b>201</b> designates the physical address designated by the controller <b>111</b> with respect to the read control unit <b>205</b> and instructs the read control unit <b>205</b> to read data of 4200 bits (525 bytes). The read control unit <b>205</b> reads data from the memory cell array <b>210</b> via the voltage pulse control unit <b>207</b>. The read data is transmitted to the read data buffer <b>301</b> and is held in the read data buffer <b>301</b>.</p><p id="p-0199" num="0198">(S<b>1402</b>)</p><p id="p-0200" num="0199">The request processing unit <b>201</b> transmits the data of 4200 bits (525 bytes) held in the read data buffer <b>301</b> to the controller <b>111</b> via the interface unit <b>200</b>.</p><p id="p-0201" num="0200">(S<b>1403</b>)</p><p id="p-0202" num="0201">After step S<b>1402</b>, the read request processing is terminated.</p><p id="p-0203" num="0202">[Description of Configuration of Controller]</p><p id="p-0204" num="0203"><figref idref="DRAWINGS">FIG. <b>17</b></figref> shows a configuration example of the controller <b>111</b>. The controller <b>111</b> includes a RAM <b>120</b>, a CPU <b>130</b>, a host interface unit <b>140</b>, an NVM interface unit <b>150</b>, a ROM <b>160</b>, a refresh control unit <b>170</b>, and an error correction unit <b>180</b>, and those elements are connected to each other via a bus <b>190</b>. The NVM interface unit <b>150</b> corresponds to, for example, a first interface unit. The host interface unit <b>140</b> corresponds to, for example, a second interface unit. The CPU <b>130</b> corresponds to a control unit that controls, for example, write to and read from the NVM <b>112</b>. The RAM <b>120</b> corresponds to an information holding unit that holds information or data.</p><p id="p-0205" num="0204">The NVM interface unit <b>150</b> communicates with the NVM <b>112</b>. For example, the NVM interface unit <b>150</b> transmits a request (write request or read request) to be executed by the NVM <b>112</b> to the NVM <b>112</b>. Further, in a case of transmitting the write request, the NVM interface unit <b>150</b> transmits data to be written to the NVM <b>112</b>. Meanwhile, in a case of transmitting the read request, the NVM interface unit <b>150</b> receives data read from the NMV <b>112</b>.</p><p id="p-0206" num="0205">The host interface unit <b>140</b> communicates with the host system <b>100</b>. For example, the host interface unit <b>140</b> receives a command (write command or read command) from the host system <b>100</b>. Further, the host interface unit <b>140</b> receives data to be written indicated by the write command from the host system <b>100</b>. The host interface unit <b>140</b> transmits data read from the NVM <b>112</b> to the host system <b>100</b> in response to the read command.</p><p id="p-0207" num="0206">The error correction unit <b>180</b> calculates an error correction code (ECC) of data to be written to the NVM <b>112</b>. Data obtained by combining the calculated ECC with the data is actually written to the NVM <b>112</b>. Further, the error correction unit <b>180</b> executes error correction of data read from the NVM <b>112</b> on the basis of an ECC included in the read data. The error correction unit <b>180</b> has, for example, a capability of correcting 8 bits. The ECC is, for example, 13 bytes in size.</p><p id="p-0208" num="0207">The ROM <b>160</b> stores software for controlling the memory system <b>110</b> (see <figref idref="DRAWINGS">FIG. <b>1</b></figref>).</p><p id="p-0209" num="0208">The CPU <b>130</b> executes the software stored in the ROM <b>160</b> by using the RAM <b>120</b> as a working memory.</p><p id="p-0210" num="0209">The RAM <b>120</b> is a volatile memory. The RAM <b>120</b> is used not only as a working memory of the CPU <b>130</b> but also for holding information or data for managing the NVM <b>112</b>. Further, the RAM <b>120</b> is also used for temporarily holding data transferred between the host system <b>100</b> and the controller <b>111</b> and for temporarily holding data transferred between the controller <b>111</b> and the NVM <b>112</b>.</p><p id="p-0211" num="0210">Further, the RAM <b>120</b> holds a logical-to-physical address conversion table <b>500</b>, an unused physical address list <b>600</b>, and health information <b>700</b>.</p><p id="p-0212" num="0211"><figref idref="DRAWINGS">FIG. <b>18</b></figref> shows an example of the logical-to-physical address conversion table <b>500</b>. The logical-to-physical address conversion table <b>500</b> associates a logical address designated by the host system <b>100</b> with a physical address of the NVM <b>112</b>. Information indicating &#x201c;unallocated&#x201d; is stored for a logical address with which no physical address is associated. A bit depth of the logical address and a bit depth of the physical address are assumed to be the same, but it is not excluded that the bit depth of the logical address and the bit depth of the physical address are different.</p><p id="p-0213" num="0212"><figref idref="DRAWINGS">FIG. <b>19</b></figref> shows an example of the unused physical address list <b>600</b>. The unused physical address list <b>600</b> stores information regarding physical addresses that are not allocated to logical addresses. The physical addresses in the unused physical address list <b>600</b> can be newly allocated to logical addresses.</p><p id="p-0214" num="0213"><figref idref="DRAWINGS">FIG. <b>20</b></figref> shows an example of the health information <b>700</b>. The health information <b>700</b> indicates a health state of the memory system <b>110</b>. The health information <b>700</b> is used to present the health state of the memory system <b>110</b> to the host. The health information <b>700</b> is, for example, self-monitoring analysis and reporting technology (SMART) information. The health information <b>700</b> is an example of information managed by the controller, such as information indicating the state of the memory system <b>110</b>, and information other than the health information may be defined as first information of the present embodiment as long as the information is managed by the controller.</p><p id="p-0215" num="0214">The health information <b>700</b> of <figref idref="DRAWINGS">FIG. <b>20</b></figref> includes the number of reads (Data Unit Read), the number of writes (Data Unit Write), the number of executions of a read command (Host Read Commands), the number of executions of a write command (Host Write Commands), and an operating time (Power On Time).</p><p id="p-0216" num="0215">The number of reads indicates a cumulative value of the number of reads of data of a unit size (e.g., 512 bytes), that is, a cumulative value of the number of executions of a read request.</p><p id="p-0217" num="0216">The number of writes indicates a cumulative value of the number of writes of data of a unit size (e.g., 512 bytes), that is, a cumulative value of the number of executions of a write request.</p><p id="p-0218" num="0217">The number of executions of a read command indicates a cumulative value of the number of receptions of a read command from the host system <b>100</b> or a cumulative value of the number of executions thereof.</p><p id="p-0219" num="0218">The number of executions of a read command indicates a cumulative value of the number of receptions of a write command from the host system <b>100</b> or a cumulative value of the number of executions thereof.</p><p id="p-0220" num="0219">The operating time indicates a time during which the memory system <b>110</b> continuously operates after a power supply is turned on.</p><p id="p-0221" num="0220">The refresh control unit <b>170</b> controls the refresh processing of refreshing memory cells of one physical address at regular time intervals in cooperation with the CPU <b>130</b>. For example, in a case where the selectors <b>510</b> of the memory cells of all the physical addresses (0x000000-0xFFFFFF) in the NVM <b>112</b> need to be turned on (snapped) within 10,000 [s] in view of characteristics of the NVM <b>112</b>, a time interval for the refresh is 596 [us]. The time interval is 596 [us] in this example.</p><p id="p-0222" num="0221"><figref idref="DRAWINGS">FIG. <b>21</b></figref> shows a configuration example of the refresh control unit <b>170</b>. The refresh control unit <b>170</b> includes a timer <b>171</b>, an address counter <b>172</b>, a refresh operation reference table <b>173</b>, and a refresh data buffer <b>174</b>.</p><p id="p-0223" num="0222">A refresh time interval is set in the timer <b>171</b>. The timer <b>171</b> outputs an interrupt signal to the CPU <b>130</b> at the set time intervals. For example, in a case where <b>596</b> [us] is set, the interrupt signal is output from the timer <b>171</b> to the CPU <b>130</b> every 596 [us]. The interrupt signal serves as a trigger signal for the refresh processing.</p><p id="p-0224" num="0223">The address counter <b>172</b> presents a value of a physical address to be refreshed. The address counter <b>172</b> increments a value in response to an instruction signal from the CPU <b>130</b>. By repeating the increment, the address counter <b>172</b> sequentially presents all the physical addresses to be refreshed to the CPU <b>130</b>.</p><p id="p-0225" num="0224">The refresh operation reference table <b>173</b> has information indicating a refresh method for each physical address.</p><p id="p-0226" num="0225"><figref idref="DRAWINGS">FIG. <b>22</b></figref> shows an example of the refresh operation reference table <b>173</b>. The refresh method includes data update refresh and normal refresh. In the normal refresh, data read from the physical address to be refreshed is subjected to error correction, and the data subjected to the error correction is written back. Note that, in some cases, the data read from the physical address to be refreshed is written back without being subjected to error correction. In the data update refresh, the first information different from the data read from the physical address to be refreshed is written to the physical address to be refreshed. In the present embodiment, health information (latest health information) in the RAM <b>120</b> is written as the first information to be written in the data update refresh. In the example of <figref idref="DRAWINGS">FIG. <b>22</b></figref>, the data update refresh is designated for &#x201c;0x012A56&#x201d;, and the normal refresh is designated for all the other physical addresses.</p><p id="p-0227" num="0226">The refresh data buffer <b>174</b> is a buffer that holds data read from the NVM <b>112</b>. Alternatively, the refresh data buffer <b>174</b> holds data obtained by performing error correction on the data read from the NVM <b>112</b> on the basis of an ECC included in the data.</p><p id="p-0228" num="0227">[Description of Refresh Processing]</p><p id="p-0229" num="0228"><figref idref="DRAWINGS">FIG. <b>23</b></figref> shows an operation flow of the refresh processing executed by the controller <b>111</b>. When an interrupt signal is input to the CPU <b>130</b> from the timer <b>171</b>, the refresh processing is started. At the start of the refresh processing, the CPU <b>130</b> counts up the value of the Power On Time of the health information <b>700</b> in accordance with an elapsed time from a previous update.</p><p id="p-0230" num="0229">(S<b>1501</b>)</p><p id="p-0231" num="0230">The CPU <b>130</b> acquires a value of the address counter <b>172</b> of the refresh control unit <b>170</b> as an address to be refreshed.</p><p id="p-0232" num="0231">(S<b>1502</b>)</p><p id="p-0233" num="0232">The CPU <b>130</b> designates the address to be refreshed with respect to the NVM <b>112</b> and issues a read request to the NVM <b>112</b>. According to the operation flow of <figref idref="DRAWINGS">FIG. <b>16</b></figref> described above, data is read from a plurality of memory cells belonging to the address to be refreshed (i.e., a plurality of memory cells included in a block indicated by the address to be refreshed) in the memory cell array <b>210</b> of the NVM <b>112</b>. The CPU <b>130</b> corrects an error of the data read from the NVM <b>112</b> by using the error correction unit <b>180</b>. The CPU <b>130</b> stores the corrected data in the refresh data buffer <b>174</b> of the refresh control unit <b>170</b>. The data read from the NVM <b>112</b> or the corrected data corresponds to, for example, first data read from the first block.</p><p id="p-0234" num="0233">(S<b>1503</b>)</p><p id="p-0235" num="0234">The CPU <b>130</b> designates the address to be refreshed with respect to the NVM <b>112</b> and issues an LRS transition request to the NVM <b>112</b>. The CPU <b>130</b> reads the data from the refresh data buffer <b>174</b>. The CPU <b>130</b> can specify whether the memory cell corresponding to each bit is in the HRS or the LRS on the basis of the read data. It is possible to specify that the memory cell corresponding to a bit of &#x201c;1&#x201d; is in the HRS and the memory cell corresponding to a bit of &#x201c;0&#x201d; is in the LRS. The CPU <b>130</b> inverts the read data. In the inverted data, the memory cell corresponding to the bit of &#x201c;1&#x201d; is a memory cell to transition to the LRS. This memory cell is a memory cell whose current resistance state is the HRS (memory cell to which 0 is written) and is also a memory cell whose selector <b>510</b> has not been turned on by the reading in S<b>1502</b>. The CPU <b>130</b> transmits the inverted data to the NVM <b>112</b> (note that the data in the refresh data buffer <b>174</b> cannot be inverted). An operation flow of the NVM <b>112</b> that has received the LRS transition request is shown in <figref idref="DRAWINGS">FIG. <b>15</b></figref> described above. The inverted data corresponds to, for example, the second data for causing a memory cell in the second state (HRS) among memory cells in the first block to transition to the first state (LRS).</p><p id="p-0236" num="0235">(S<b>1504</b>)</p><p id="p-0237" num="0236">The CPU <b>130</b> selects one of the data held in the refresh data buffer <b>174</b> and the health information on the basis of the address to be refreshed and writes the selected one to the plurality of memory cells of the address to be refreshed. More specifically, the CPU <b>130</b> first refers to the refresh operation reference table <b>173</b> and determines whether or not the address to be refreshed corresponds to a data update refresh address. The data update refresh address corresponds to, for example, a first address.</p><p id="p-0238" num="0237">(S<b>1505</b>)</p><p id="p-0239" num="0238">In a case where the address to be refreshed does not correspond to the data update refresh address, the CPU <b>130</b> designates the address to be refreshed and transmits a program request (write request) to the NVM <b>112</b>. Further, the CPU <b>130</b> transmits the data held in the refresh data buffer <b>174</b>. The transmitted data is written to the plurality of memory cells belonging to the address to be refreshed in the memory cell array <b>210</b> of the NVM <b>112</b> in accordance with the operation flow of <figref idref="DRAWINGS">FIG. <b>8</b></figref> described above. In a case where the address to be refreshed does not correspond to the data update refresh address as described above, the CPU <b>130</b> selects the data held in the refresh data buffer <b>174</b> and writes the selected data to the address to be refreshed.</p><p id="p-0240" num="0239">(S<b>1507</b>)</p><p id="p-0241" num="0240">In a case where the address to be refreshed corresponds to the data update refresh address, the CPU <b>130</b> designates the address to be refreshed with respect to the NVM <b>112</b> and transmits a program request (write request) to the NVM <b>112</b>. Further, the CPU <b>130</b> generates data by adding an ECC calculated by the error correction unit <b>180</b> to the health information stored in the RAM <b>120</b> as data to be written and transmits the generated data. The health information or the data obtained by adding the ECC to the health information corresponds to, for example, the first information. The data obtained by adding the ECC is written to the plurality of memory cells belonging to the address to be refreshed in the memory cell array <b>210</b> of the NVM <b>112</b> in accordance with the operation flow of <figref idref="DRAWINGS">FIG. <b>8</b></figref> described above. In a case where the address to be refreshed corresponds to the data update refresh address as described above, the CPU <b>130</b> selects the health information (first information) and writes the selected health information to the address to be refreshed.</p><p id="p-0242" num="0241">(S<b>1506</b>)</p><p id="p-0243" num="0242">The CPU <b>130</b> transmits an instruction signal to the refresh control unit <b>170</b> so as to increment the value of the address counter <b>172</b> (the value of the address to be refreshed). The refresh control unit <b>170</b> updates the value of the address counter <b>172</b> in response to the instruction signal from the CPU <b>130</b>.</p><p id="p-0244" num="0243">(S<b>1508</b>)</p><p id="p-0245" num="0244">After step S<b>1506</b>, the refresh processing of one physical address is terminated.</p><p id="p-0246" num="0245">[Description of Read Command Processing]</p><p id="p-0247" num="0246"><figref idref="DRAWINGS">FIG. <b>24</b></figref> shows an operation flow of processing executed when the controller <b>111</b> receives a read command from the host system <b>100</b>.</p><p id="p-0248" num="0247">(S<b>1600</b>)</p><p id="p-0249" num="0248">When receiving a read command together with information regarding a head logical address to be read and a data size via the host interface unit <b>140</b>, the CPU <b>130</b> starts read command processing.</p><p id="p-0250" num="0249">(S<b>1601</b>)</p><p id="p-0251" num="0250">The CPU <b>130</b> divides read processing in units of logical addresses (in units of logical pages). One logical address is executed in one-time processing. For example, in a case where &#x201c;0&#x201d; is designated as a head address to be read and &#x201c;1&#x201d; is designated as the data size, one-time processing is performed. Further, in a case where &#x201c;0&#x201d; is designated as the head logical address to be read and &#x201c;2&#x201d; is designated as the data size, the read processing is divided into two processes. The data size &#x201c;1&#x201d; represents an amount of data of one unit, and, for example, &#x201c;1&#x201d; is 512 bytes.</p><p id="p-0252" num="0251">(S<b>1602</b>)</p><p id="p-0253" num="0252">The CPU <b>130</b> determines logical addresses to be read. The logical addresses to be read are determined in order from the head logical address to be read. In a case where &#x201c;0&#x201d; is designated as the head address to be read and &#x201c;2&#x201d; is designated as the data size, a logical address to be subjected to the processing first is determined as &#x201c;0&#x201d;. A logical address to be subjected to the processing next is determined as &#x201c;1&#x201d;.</p><p id="p-0254" num="0253">(S<b>1603</b>)</p><p id="p-0255" num="0254">The CPU <b>130</b> converts the logical address determined as the address to be read into a physical address by using the logical-to-physical address conversion table <b>500</b> held in the RAM <b>120</b>.</p><p id="p-0256" num="0255">(S<b>1604</b>)</p><p id="p-0257" num="0256">The CPU <b>130</b> designates the physical address converted in step S<b>1603</b> with respect to the NVM <b>112</b> and transmits a read request to the NVM <b>112</b>. Data read from the NVM <b>112</b> is, for example, 4200 bits (525 bytes) including an ECC.</p><p id="p-0258" num="0257">(S<b>1605</b>)</p><p id="p-0259" num="0258">The data of 4200 bits (525 bytes) read from the NVM <b>112</b> is transmitted to the error correction unit <b>180</b>. The error correction unit <b>180</b> performs error correction by using the ECC included in the data of 4200 bits (525 bytes).</p><p id="p-0260" num="0259">(S<b>1606</b>)</p><p id="p-0261" num="0260">The CPU <b>130</b> transmits data of 512 bytes obtained by removing the ECC of 13 bytes from the data subjected to the error correction in the error correction unit <b>180</b> to the host system <b>100</b> via the host interface unit <b>140</b>.</p><p id="p-0262" num="0261">(S<b>1607</b>)</p><p id="p-0263" num="0262">The CPU <b>130</b> determines whether or not the sum total of data sizes transmitted so far to the host system <b>100</b> matches the data size designated by the read command. In a case where the sum total of the data sizes transmitted to the host system <b>100</b> matches the data size designated by the read command, the processing proceeds to step S<b>1608</b>. In a case where the sum total of the data sizes does not match the data size, the processing returns to step S<b>1602</b>.</p><p id="p-0264" num="0263">(S<b>1608</b>)</p><p id="p-0265" num="0264">The CPU <b>130</b> updates the number of reads (Data Unit Read) and the number of executions of the read command (Host Read Commands) of the health information <b>700</b> held in the RAM <b>120</b>. Specifically, a value obtained by dividing the sum total [B] of the data sizes transmitted to the host system in the read command processing by <b>512</b> [B] is added to the number of reads. Alternatively, the value of the &#x201c;data size&#x201d; designated by the host system <b>100</b> may be added to the number of reads. Further, the value of the number of executions of the read command (Host Read Commands) is incremented by 1. Therefore, the health information <b>700</b> is updated.</p><p id="p-0266" num="0265">(S<b>1609</b>)</p><p id="p-0267" num="0266">The CPU <b>130</b> notifies the host system <b>100</b> that the read command processing has been terminated.</p><p id="p-0268" num="0267">(S<b>1610</b>)</p><p id="p-0269" num="0268">After step S<b>1609</b>, the read command processing is terminated.</p><p id="p-0270" num="0269">[Description of Write Command Processing]</p><p id="p-0271" num="0270"><figref idref="DRAWINGS">FIG. <b>25</b></figref> shows an operation flow of processing executed when the controller <b>111</b> receives a write command from the host system <b>100</b>.</p><p id="p-0272" num="0271">(S<b>1700</b>)</p><p id="p-0273" num="0272">The CPU <b>130</b> receives a write command together with information regarding a head logical address to be written and a data size via the host interface unit <b>140</b>. Therefore, write command processing is started.</p><p id="p-0274" num="0273">(S<b>1701</b>)</p><p id="p-0275" num="0274">The CPU <b>130</b> divides write processing in units of logical addresses (in units of logical pages). One logical address is executed in one-time processing. For example, in a case where &#x201c;0&#x201d; is designated as a head address to be written and &#x201c;1&#x201d; is designated as the data size, one-time processing is performed. Further, in a case where &#x201c;0&#x201d; is designated as the head logical address to be read and &#x201c;2&#x201d; is designated as the data size, the write processing is divided into two processes. The data size &#x201c;1&#x201d; represents an amount of data of one unit, and, for example, &#x201c;1&#x201d; is 512 bytes.</p><p id="p-0276" num="0275">(S<b>1702</b>)</p><p id="p-0277" num="0276">The CPU <b>130</b> determines logical addresses to be written. The logical addresses to be written are determined in order from the head logical address to be written. In a case where &#x201c;0&#x201d; is designated as the head address to be written and &#x201c;2&#x201d; is designated as the data size, a logical address to be subjected to the processing first is determined as &#x201c;0&#x201d;. A logical address to be subjected to the processing next is determined as &#x201c;1&#x201d;.</p><p id="p-0278" num="0277">(S<b>1703</b>)</p><p id="p-0279" num="0278">The CPU <b>130</b> receives data to be written (herein, 512 bytes) from the host system <b>100</b> via the host interface unit <b>140</b> and transmits the received data to the error correction unit <b>180</b>. The data to be written may be received together with the write command in step S<b>1700</b>.</p><p id="p-0280" num="0279">(S<b>1704</b>)</p><p id="p-0281" num="0280">The error correction unit <b>180</b> generates an ECC (herein, 13 bytes) from the data received in step S<b>1703</b>. The received data and the ECC are combined to generate data of 525 bytes.</p><p id="p-0282" num="0281">(S<b>1705</b>)</p><p id="p-0283" num="0282">The CPU <b>130</b> determines whether or not there is a physical address allocated to the logical address determined as the address to be written by using the logical-to-physical address conversion table <b>500</b> held in the RAM <b>120</b>. In a case where there is a physical address allocated to the logical address, the physical address is acquired.</p><p id="p-0284" num="0283">(S<b>1706</b>)</p><p id="p-0285" num="0284">In a case where the physical address allocated to the logical address is acquired, the processing proceeds to step S<b>1707</b>. In a case where there is no physical address allocated to the logical address, the processing proceeds to step S<b>1708</b>.</p><p id="p-0286" num="0285">(S<b>1708</b>)</p><p id="p-0287" num="0286">The CPU <b>130</b> acquires one physical address from the unused physical address list <b>600</b> (see <figref idref="DRAWINGS">FIG. <b>19</b></figref>). The physical address may be selected by an arbitrary method. For example, one physical address may be randomly selected, the smallest or largest physical address may be selected, or the physical address may be selected on the basis of other criteria.</p><p id="p-0288" num="0287">(S<b>1709</b>)</p><p id="p-0289" num="0288">The CPU <b>130</b> designates the physical address acquired in step S<b>1708</b> with respect to the NVM <b>112</b> and transmits a program request (write request) of the data of 525 bytes generated in step S<b>1704</b> to the NVM <b>112</b>.</p><p id="p-0290" num="0289">(S<b>1710</b>)</p><p id="p-0291" num="0290">The CPU <b>130</b> adds the physical address acquired in S<b>1708</b> to the logical-to-physical address conversion table <b>500</b> in association with the logical address determined in step S<b>1702</b>.</p><p id="p-0292" num="0291">(S<b>1711</b>)</p><p id="p-0293" num="0292">The CPU <b>130</b> deletes the physical address acquired in step S<b>1708</b> from the unused physical address list.</p><p id="p-0294" num="0293">(S<b>1707</b>)</p><p id="p-0295" num="0294">The CPU <b>130</b> designates the physical address acquired in step S<b>1706</b> with respect to the NVM <b>112</b> and transmits a program request (write request) of the data of 525 bytes generated in step S<b>1704</b> to the NVM <b>112</b>.</p><p id="p-0296" num="0295">(S<b>1712</b>)</p><p id="p-0297" num="0296">The CPU <b>130</b> determines whether or not the sum total of data sizes transmitted so far to the NVM <b>112</b> (excluding the sizes of the ECCs) matches the data size designated by the write command. In a case where the sum total of the data sizes transmitted to the NVM <b>112</b> (excluding the sizes of the ECCs) matches the data size designated by the write command, the processing proceeds to step S<b>1708</b>. In a case where the sum total of the data sizes does not match the data size, the processing returns to step S<b>1702</b>.</p><p id="p-0298" num="0297">(S<b>1713</b>)</p><p id="p-0299" num="0298">The CPU <b>130</b> updates the number of writes (Data Unit Write) and the number of executions of the write command (Host Read Commands) of the health information <b>700</b> held in the RAM <b>120</b>. Specifically, a value obtained by dividing the sum total [B] of the data sizes received from the host system in the write command processing by <b>512</b> [B] is added to the number of writes. Alternatively, the value of the &#x201c;data size&#x201d; designated by the host system <b>100</b> may be added to the number of writes. Further, the value of the number of executions of the write command (Host Read Commands) is incremented by 1. Therefore, the health information <b>700</b> is updated.</p><p id="p-0300" num="0299">(S<b>1714</b>)</p><p id="p-0301" num="0300">The CPU <b>130</b> notifies the host system <b>100</b> that the write command processing has been terminated.</p><p id="p-0302" num="0301">(S<b>1715</b>)</p><p id="p-0303" num="0302">After step S<b>1714</b>, the write command processing is terminated.</p><p id="p-0304" num="0303">[Description of Health Information Reading Processing]</p><p id="p-0305" num="0304"><figref idref="DRAWINGS">FIG. <b>26</b></figref> shows an operation flow of processing executed when the controller <b>111</b> receives a read command of the health information from the host system <b>100</b>.</p><p id="p-0306" num="0305">(S<b>1800</b>)</p><p id="p-0307" num="0306">When the CPU <b>130</b> receives a read command of the health information via the host interface unit <b>140</b>, health information read processing is started.</p><p id="p-0308" num="0307">(S<b>1801</b>)</p><p id="p-0309" num="0308">The CPU <b>130</b> reads the health information held in the RAM and transmits the read health information to the host system <b>100</b>.</p><p id="p-0310" num="0309">(S<b>1802</b>)</p><p id="p-0311" num="0310">The CPU <b>130</b> notifies the host system <b>100</b> that the health information read processing has been terminated.</p><p id="p-0312" num="0311">(S<b>1803</b>)</p><p id="p-0313" num="0312">After step S<b>1802</b>, the health information read processing is terminated.</p><p id="p-0314" num="0313">The present embodiment employs memory cells having a cross-point structure in which each memory cell stores a bit depending on whether the resistance state is the HRS or the LRS, but can also employ memory cells having other structures as long as the memory cells store bits depending on the first state and the second state. For example, magnetoresistive memory cells, flash memory cells, or the like may be employed. In the magnetoresistive memory cells, bits are stored according to a state of magnetization. In the flash memory, bits are stored according to a charge accumulation state of a floating gate. Memory cells having a structure other than the structures described herein may be used.</p><p id="p-0315" num="0314">According to the present embodiment, the health information is written to the non-volatile memory at a timing of performing the refresh processing, and this eliminates the necessity of writing the health information to the non-volatile memory every time when the health information is updated. This makes it possible to reduce the number of writes to the non-volatile memory. Therefore, it is possible to suppress consumption of the rewrite life of the non-volatile memory.</p><heading id="h-0011" level="1">Modification Example 1</heading><p id="p-0316" num="0315">Modification Example 1 is a modification example of the refresh processing. In the first embodiment, the content of the refresh processing is changed depending on whether or not the address to be refreshed corresponds to the data update refresh address (see <figref idref="DRAWINGS">FIG. <b>23</b></figref>). In Modification Example 1, the content of the refresh processing is changed further depending on a value of data read from the address to be refreshed. Specifically, in a case where all bits of data read from the NVM <b>112</b> are &#x201c;1&#x201d;, there is no need to execute an LRS transition request because the selectors of all the memory cells are turned on by the reading. Therefore, in a case where all the bits of the data read from the NVM <b>112</b> are &#x201c;1&#x201d;, the LRS transition request is not transmitted to the NVM <b>112</b>.</p><p id="p-0317" num="0316"><figref idref="DRAWINGS">FIG. <b>27</b></figref> shows an operation flow of the refresh processing according to Modification Example 1. Steps similar to those in <figref idref="DRAWINGS">FIG. <b>23</b></figref> are denoted by the same reference numerals, and, in a case where there is a plurality of steps having the same content, branch numbers are added to the end of the same reference numeral. Hereinafter, only steps different from those in <figref idref="DRAWINGS">FIG. <b>23</b></figref> will be described. The steps different from those in <figref idref="DRAWINGS">FIG. <b>23</b></figref> are steps S<b>1901</b> and S<b>1902</b>.</p><p id="p-0318" num="0317">(S<b>1901</b>)</p><p id="p-0319" num="0318">In a case where the address to be refreshed is not the data update refresh address (NO in S<b>1504</b>), the CPU <b>130</b> determines whether or not all the bits of the data subjected to the error correction in step S<b>1502</b> are &#x201c;1&#x201d;. In a case where all the bits are &#x201c;1&#x201d;, the processing proceeds to step S<b>1506</b>. In this case, transmission of an LRS transition request to the address to be refreshed (S<b>1503</b>-<b>1</b>) and rewriting of data to the NVM <b>112</b> (S<b>2014</b>) are not performed. Meanwhile, in a case where at least one bit is &#x201c;0&#x201d;, the processing proceeds to step S<b>1503</b>-<b>1</b>, and similar processing to that in <figref idref="DRAWINGS">FIG. <b>23</b></figref> is performed.</p><p id="p-0320" num="0319">(S<b>1902</b>)</p><p id="p-0321" num="0320">In a case where the address to be refreshed is the data update refresh address (YES in S<b>1504</b>), the CPU <b>130</b> determines whether or not all the bits of the data subjected to the error correction in step S<b>1502</b> are &#x201c;1&#x201d;. In a case where all the bits are &#x201c;1&#x201d;, the processing proceeds to step S<b>1507</b>. In this case, transmission of an LRS transition request to the address to be refreshed (S<b>1503</b>-<b>2</b>) is not performed. Meanwhile, in a case where at least one bit is &#x201c;0&#x201d;, the processing proceeds to step S<b>1503</b>-<b>2</b>, and similar processing to that in <figref idref="DRAWINGS">FIG. <b>23</b></figref> is performed.</p><p id="p-0322" num="0321">According to Modification Example 1, in a case where all the bits of the data read from the address to be refreshed (or the data subjected to the error correction) are 1, the execution of the LRS transition request is omitted. This makes it possible to reduce a time of the refresh processing.</p><heading id="h-0012" level="1">Modification Example 2</heading><p id="p-0323" num="0322">Modification Example 2 is a modification example of the refresh processing. In the first embodiment, the content of the refresh processing is changed depending on whether or not the address to be refreshed corresponds to the data update refresh address (see <figref idref="DRAWINGS">FIG. <b>23</b></figref>). In Modification Example 2, the content of the refresh processing is changed further depending on whether or not the address to be refreshed corresponds to a physical address (unused physical address) allocated to no logical address. Specifically, in a case where the address to be refreshed is not the data update refresh address and the address to be refreshed is an unused physical address, an LRS transition request and rewriting of data to the NVM <b>112</b> are omitted. This is because no data is originally written to the unused physical address and there is no need to write back data.</p><p id="p-0324" num="0323"><figref idref="DRAWINGS">FIG. <b>28</b></figref> shows an operation flow of the refresh processing according to Modification Example 2. Steps similar to those in <figref idref="DRAWINGS">FIG. <b>23</b></figref> are denoted by the same reference numerals, and, in a case where there is a plurality of steps having the same content, branch numbers are added to the end of the same reference numeral. Hereinafter, only a step different from that in <figref idref="DRAWINGS">FIG. <b>23</b></figref> will be described. The step different from that in <figref idref="DRAWINGS">FIG. <b>23</b></figref> is step S<b>2001</b>.</p><p id="p-0325" num="0324">(S<b>2001</b>)</p><p id="p-0326" num="0325">In a case where the address to be refreshed is not the data update refresh address (NO in S<b>1504</b>), the CPU <b>130</b> determines whether or not the address to be refreshed is registered in the unused physical address list <b>600</b> on the basis of the unused physical address list <b>600</b>. The unused physical address is an address to which no data is written. In a case where the address to be refreshed is registered in the unused physical address list <b>600</b>, that is, in a case where the address to be refreshed is an unused physical address, the processing proceeds to step S<b>1506</b>. In this case, transmission of an LRS transition request to the address to be refreshed (S<b>1503</b>-<b>1</b>) and rewriting of data to the NVM <b>112</b> (S<b>2014</b>) are not performed. Meanwhile, in a case where the address to be refreshed is not registered in the unused physical address list <b>600</b>, that is, in a case where the address to be refreshed is not an unused physical address, the processing proceeds to step S<b>1503</b>-<b>1</b>, and similar processing to that in <figref idref="DRAWINGS">FIG. <b>23</b></figref> is performed.</p><p id="p-0327" num="0326">According to Modification Example 2, in a case where the address to be refreshed is an unused physical address, the execution of the LRS transition request is omitted. This makes it possible to reduce the time of the refresh processing.</p><heading id="h-0013" level="1">Modification Example 3</heading><p id="p-0328" num="0327">In Modification Example 3, data of a memory cell storing unnecessary data is erased when the refresh processing is executed. This makes it possible to omit rewriting of data.</p><p id="p-0329" num="0328">SSDs generally perform processing called wear leveling in order to prevent a specific memory cell from being concentratedly rewritten. In the wear leveling, the number of rewrites that have thus occurred is counted with a page or a plurality of pages as a unit. One page corresponds to, for example, data of one physical address (e.g., 512 bytes), but one page may correspond to a plurality of physical addresses. The number of rewrites is counted for each physical address, and data of the physical address in which rewrite frequently occurs is copied to an unused physical address. As the unused physical address, a physical address having a small number of rewrites is selected. Therefore, the number of rewrites is averaged among the physical addresses. After copying the data, the data of the physical address serving as a copy source becomes unnecessary.</p><p id="p-0330" num="0329">Further, in a case where unnecessary data is generated due to deletion or rewriting of data in an SSD, the host system notifies the controller of the memory system of a logical address in which the unnecessary data is recorded by using a trim command. The controller can handle the data in a physical address corresponding to the logical address as the unnecessary data.</p><p id="p-0331" num="0330">In Modification Example 3, regarding a physical address storing unnecessary data as in the above two examples, the data is erased and the data is not rewritten at the time of the refresh processing. Such refresh is referred to as data erasure refresh. In the refresh operation reference table, &#x201c;data erasure refresh&#x201d; is registered as the refresh method for a physical address to be subjected to the data erasure refresh. A physical address whose refresh method is the data erasure refresh is referred to as a data erasure refresh address.</p><p id="p-0332" num="0331"><figref idref="DRAWINGS">FIG. <b>29</b></figref> shows an example of the refresh operation reference table <b>173</b> according to Modification Example 3. The refresh operation reference table <b>173</b> is held in the RAM <b>120</b>. In the example of <figref idref="DRAWINGS">FIG. <b>29</b></figref>, the &#x201c;data erasure refresh&#x201d; is designated for two physical addresses. The &#x201c;data update refresh&#x201d; and the &#x201c;normal refresh&#x201d; are similar to those in the first embodiment.</p><p id="p-0333" num="0332"><figref idref="DRAWINGS">FIG. <b>30</b></figref> shows an operation flow of the refresh processing according to Modification Example 3. Steps similar to those in <figref idref="DRAWINGS">FIG. <b>23</b></figref> are denoted by the same reference numerals. Hereinafter, only a step different from that in <figref idref="DRAWINGS">FIG. <b>23</b></figref> will be described. The steps different from those in <figref idref="DRAWINGS">FIG. <b>23</b></figref> are steps S<b>2101</b>, S<b>2102</b>, and S<b>2103</b>.</p><p id="p-0334" num="0333">(S<b>2101</b>)</p><p id="p-0335" num="0334">On the basis of the refresh operation reference table <b>173</b>, the CPU <b>130</b> determines whether or not the refresh method of the address to be refreshed is the data erasure refresh, that is, whether or not the address to be refreshed corresponds to the data erasure refresh address. In a case where the address to be refreshed does not correspond to the data erasure refresh address, the processing proceeds to step S<b>1504</b>. Step S<b>1504</b> and subsequent steps are the same as those in <figref idref="DRAWINGS">FIG. <b>23</b></figref>. In a case where the address to be refreshed corresponds to the data erasure refresh address, the processing proceeds to step S<b>2102</b>.</p><p id="p-0336" num="0335">(S<b>2102</b>)</p><p id="p-0337" num="0336">In a case where the address to be refreshed corresponds to the data erasure refresh address, the CPU <b>130</b> updates the refresh method of the address to be refreshed from the data erasure refresh to the normal refresh in the refresh operation reference table <b>173</b>. That is, the address to be refreshed is updated from the data erasure refresh address to a normal refresh address. Therefore, the data of the address to be refreshed is erased.</p><p id="p-0338" num="0337">(S<b>2103</b>)</p><p id="p-0339" num="0338">The CPU <b>130</b> registers the address to be refreshed in the unused physical address list <b>600</b>. Thereafter, the processing proceeds to step S<b>1506</b>. Step S<b>1506</b> and a subsequent step are the same as those in <figref idref="DRAWINGS">FIG. <b>23</b></figref>.</p><p id="p-0340" num="0339">According to Modification Example 3, it is possible to reduce the time of the refresh processing by omitting the rewriting of unnecessary data. Further, it is also possible to suppress the consumption of the rewrite life.</p><p id="p-0341" num="0340">Note that the above-described embodiments show examples for embodying the present disclosure, and the present disclosure can be implemented in various other forms. For example, various modifications, substitutions, omissions, or combinations thereof can be made within the gist of the present disclosure. Such modifications, substitutions, omissions, and the like are also included in the scope of the present disclosure and are similarly included in the invention recited in the claims and the scope equivalent to the invention.</p><p id="p-0342" num="0341">Further, the effects of the present disclosure described in the present specification are merely examples, and other effects may be obtained.</p><p id="p-0343" num="0342">Note that the present disclosure can also have the following configurations.</p><p id="p-0344" num="0343">[Item 1]</p><p id="p-0345" num="0344">A controller according to one aspect of the present invention including:</p><p id="p-0346" num="0345">a first interface unit connected to a non-volatile memory including a plurality of blocks of memory cells that enter into both a first state and a second state and in which a plurality of addresses is allocated to the plurality of blocks;</p><p id="p-0347" num="0346">an information holding unit that holds first information; and</p><p id="p-0348" num="0347">a control unit that</p><p id="p-0349" num="0348">reads first data from a first block of the non-volatile memory via the first interface unit,</p><p id="p-0350" num="0349">specifies the memory cell in the second state among the memory cells in the first block and writes second data for causing the specified memory cell in the second state to transition to the first state, and</p><p id="p-0351" num="0350">selects one of the first information and the first data on the basis of the address of the first block and writes the selected first information or first data to the first block.</p><p id="p-0352" num="0351">[Item 2]</p><p id="p-0353" num="0352">The controller according to the item 1, in which</p><p id="p-0354" num="0353">the control unit writes the first information in a case where the address of the first block is a first address and writes the first data in a case where the address of the first block is not the first address.</p><p id="p-0355" num="0354">[Item 3]</p><p id="p-0356" num="0355">The controller according to the item 1 or 2, in which:</p><p id="p-0357" num="0356">the memory cell includes a selector and a variable resistor connected in series;</p><p id="p-0358" num="0357">the first state and the second state are different states of the variable resistor; and</p><p id="p-0359" num="0358">the selector is turned on at a voltage equal to or higher than a threshold, and the threshold increases as time elapses after the selector is turned on.</p><p id="p-0360" num="0359">[Item 4]</p><p id="p-0361" num="0360">The controller according to any one of the items 1 to 3, in which</p><p id="p-0362" num="0361">the first state is a low resistance state, and the second state is a high resistance state.</p><p id="p-0363" num="0362">[Item 5]</p><p id="p-0364" num="0363">The controller according to any one of the items 1 to 4, in which</p><p id="p-0365" num="0364">the control unit determines whether the memory cells of the first block are in the first state or the second state on the basis of the first data.</p><p id="p-0366" num="0365">[Item 6]</p><p id="p-0367" num="0366">The controller according to any one of the items 1 to 5, further including</p><p id="p-0368" num="0367">a buffer that holds the first data read from the first block of the non-volatile memory.</p><p id="p-0369" num="0368">[Item 7]</p><p id="p-0370" num="0369">The controller according to any one of the items 1 to 6, in which:</p><p id="p-0371" num="0370">the first data includes an error correction code;</p><p id="p-0372" num="0371">the controller further includes an error correction unit that corrects an error of the first data on the basis of the error correction code; and</p><p id="p-0373" num="0372">the control unit writes the first data subjected to the error correction to the first block.</p><p id="p-0374" num="0373">[Item 8]</p><p id="p-0375" num="0374">The controller according to any one of the items 1 to 7, in which:</p><p id="p-0376" num="0375">the first information indicates a state of the non-volatile memory; and</p><p id="p-0377" num="0376">the control unit updates the first information of the information holding unit in accordance with the state of the non-volatile memory.</p><p id="p-0378" num="0377">[Item 9]</p><p id="p-0379" num="0378">The controller according to the item 8, in which:</p><p id="p-0380" num="0379">the first information includes a cumulative value of the number of writes or the number of reads of the non-volatile memory; and</p><p id="p-0381" num="0380">the control unit updates the first information of the information holding unit every time when the non-volatile memory is written or read.</p><p id="p-0382" num="0381">[Item 10]</p><p id="p-0383" num="0382">The controller according to the item 8 or 9, further including</p><p id="p-0384" num="0383">a second interface unit connected to a host system, in which:</p><p id="p-0385" num="0384">the control unit receives a write or read command from the host system via the second interface unit and performs write to or read from the non-volatile memory in response to the command;</p><p id="p-0386" num="0385">the first information includes a cumulative value of the number of executions of the command; and</p><p id="p-0387" num="0386">the control unit updates the first information of the information holding unit every time when the command is executed.</p><p id="p-0388" num="0387">[Item 11]</p><p id="p-0389" num="0388">The controller according to any one of the items 8 to 10, in which:</p><p id="p-0390" num="0389">the first information includes a startup time of the non-volatile memory; and</p><p id="p-0391" num="0390">the control unit updates the first information of the information holding unit as time elapses.</p><p id="p-0392" num="0391">[Item 12]</p><p id="p-0393" num="0392">The controller according to any one of the items 1 to 11, in which:</p><p id="p-0394" num="0393">the first state corresponds to a first value;</p><p id="p-0395" num="0394">the second state corresponds to a second value; and</p><p id="p-0396" num="0395">the control unit does not write the second data in a case where all bits of the first data have the first value.</p><p id="p-0397" num="0396">[Item 13]</p><p id="p-0398" num="0397">The controller according to any one of the items 1 to 12, in which:</p><p id="p-0399" num="0398">the first state corresponds to a first value;</p><p id="p-0400" num="0399">the second state corresponds to a second value; and</p><p id="p-0401" num="0400">the control unit does not write the first data in a case where the address of the first block is not the first address and all bits of the first data have the first value.</p><p id="p-0402" num="0401">[Item 14]</p><p id="p-0403" num="0402">The controller according to any one of the items 1 to 13, in which</p><p id="p-0404" num="0403">the control unit does not write the first data in a case where the address of the first block is not the first address and the address of the first block is a second address.</p><p id="p-0405" num="0404">[Item 15]</p><p id="p-0406" num="0405">The controller according to the item 14, in which</p><p id="p-0407" num="0406">the second address is an address of an unused block among the plurality of blocks.</p><p id="p-0408" num="0407">[Item 16]</p><p id="p-0409" num="0408">The controller according to the item 14, in which</p><p id="p-0410" num="0409">the second address is an address of a block storing unnecessary data among the plurality of blocks.</p><p id="p-0411" num="0410">[Item 17]</p><p id="p-0412" num="0411">The controller according to any one of the items 1 to 16, in which</p><p id="p-0413" num="0412">the control unit sequentially selects the plurality of blocks in the non-volatile memory, and</p><p id="p-0414" num="0413">defines the selected block as the first block.</p><p id="p-0415" num="0414">[Item 18]</p><p id="p-0416" num="0415">A memory system including:</p><p id="p-0417" num="0416">a non-volatile memory that includes a plurality of blocks of memory cells that enter into both a first state and a second state and in which a plurality of addresses is allocated to the plurality of blocks; and</p><p id="p-0418" num="0417">a controller including an information holding unit that holds first information and a control unit, in which:</p><p id="p-0419" num="0418">the control unit</p><p id="p-0420" num="0419">reads first data from a first block of the non-volatile memory,</p><p id="p-0421" num="0420">specifies the memory cell in the second state among the memory cells in the first block and writes second data for causing the specified memory cell in the second state to transition to the first state, and</p><p id="p-0422" num="0421">selects one of the first information and the first data on the basis of the address of the first block and writes the selected first information or first data to the first block.</p><p id="p-0423" num="0422">[Item 19]</p><p id="p-0424" num="0423">A method of controlling a memory, the method including:</p><p id="p-0425" num="0424">reading first data from a first block of a non-volatile memory that includes a plurality of blocks of memory cells that enter into both a first state and a second state and in which a plurality of addresses is allocated to the plurality of blocks;</p><p id="p-0426" num="0425">specifying the memory cell in the second state among the memory cells in the first block and writing second data for causing the specified memory cell in the second state to transition to the first state; and</p><p id="p-0427" num="0426">selecting one of first information held in an information holding unit and the first data on the basis of the address of the first block and writing the selected first information or first data to the first block.</p><heading id="h-0014" level="1">REFERENCE SIGNS LIST</heading><p id="p-0428" num="0000"><ul id="ul0002" list-style="none">    <li id="ul0002-0001" num="0427"><b>100</b> Host system</li>    <li id="ul0002-0002" num="0428"><b>110</b> Memory system</li>    <li id="ul0002-0003" num="0429"><b>111</b> Controller</li>    <li id="ul0002-0004" num="0430"><b>112</b> Non-volatile memory</li>    <li id="ul0002-0005" num="0431"><b>200</b> Interface unit</li>    <li id="ul0002-0006" num="0432"><b>201</b> Request processing unit</li>    <li id="ul0002-0007" num="0433"><b>202</b> Verification unit</li>    <li id="ul0002-0008" num="0434"><b>203</b> Buffer</li>    <li id="ul0002-0009" num="0435"><b>205</b> Read control unit</li>    <li id="ul0002-0010" num="0436"><b>206</b> Program control unit</li>    <li id="ul0002-0011" num="0437"><b>207</b> Voltage pulse control unit</li>    <li id="ul0002-0012" num="0438"><b>208</b> Word line control unit</li>    <li id="ul0002-0013" num="0439"><b>209</b> Bit line control unit</li>    <li id="ul0002-0014" num="0440"><b>210</b> Memory cell array</li>    <li id="ul0002-0015" num="0441"><b>203</b> Buffer</li>    <li id="ul0002-0016" num="0442"><b>300</b> Write data buffer</li>    <li id="ul0002-0017" num="0443"><b>301</b> Read data buffer</li>    <li id="ul0002-0018" num="0444"><b>302</b> Verification buffer</li>    <li id="ul0002-0019" num="0445"><b>401</b> Memory cell</li>    <li id="ul0002-0020" num="0446"><b>510</b> Selector</li>    <li id="ul0002-0021" num="0447"><b>520</b> Variable resistor</li>    <li id="ul0002-0022" num="0448"><b>120</b> RAM</li>    <li id="ul0002-0023" num="0449"><b>130</b> CPU</li>    <li id="ul0002-0024" num="0450"><b>140</b> Host interface unit</li>    <li id="ul0002-0025" num="0451"><b>150</b> NVM interface unit</li>    <li id="ul0002-0026" num="0452"><b>160</b> ROM</li>    <li id="ul0002-0027" num="0453"><b>170</b> Refresh control unit</li>    <li id="ul0002-0028" num="0454"><b>180</b> Error correction unit</li>    <li id="ul0002-0029" num="0455"><b>190</b> Bus</li>    <li id="ul0002-0030" num="0456"><b>171</b> Timer</li>    <li id="ul0002-0031" num="0457"><b>172</b> Address counter</li>    <li id="ul0002-0032" num="0458"><b>173</b> Refresh operation reference table</li>    <li id="ul0002-0033" num="0459"><b>174</b> Refresh data buffer</li>    <li id="ul0002-0034" num="0460"><b>500</b> Logical-to-physical address conversion table</li>    <li id="ul0002-0035" num="0461"><b>600</b> Unused physical address list</li>    <li id="ul0002-0036" num="0462"><b>700</b> Health information</li></ul></p><?detailed-description description="Detailed Description" end="tail"?></description><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A controller comprising:<claim-text>a first interface unit connected to a non-volatile memory including a plurality of blocks of memory cells that enter into both a first state and a second state and in which a plurality of addresses is allocated to the plurality of blocks;</claim-text><claim-text>an information holding unit that holds first information; and</claim-text><claim-text>a control unit that</claim-text><claim-text>reads first data from a first block of the non-volatile memory via the first interface unit,</claim-text><claim-text>specifies the memory cell in the second state among the memory cells in the first block and writes second data for causing the specified memory cell in the second state to transition to the first state, and</claim-text><claim-text>selects one of the first information and the first data on a basis of the address of the first block and writes the selected first information or first data to the first block.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The controller according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein<claim-text>the control unit writes the first information in a case where the address of the first block is a first address and writes the first data in a case where the address of the first block is not the first address.</claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The controller according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein:<claim-text>the memory cell includes a selector and a variable resistor connected in series;</claim-text><claim-text>the first state and the second state are different states of the variable resistor; and</claim-text><claim-text>the selector is turned on at a voltage equal to or higher than a threshold, and the threshold increases as time elapses after the selector is turned on.</claim-text></claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The controller according to <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein<claim-text>the first state is a low resistance state, and the second state is a high resistance state.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The controller according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein<claim-text>the control unit determines whether the memory cells of the first block are in the first state or the second state on a basis of the first data.</claim-text></claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The controller according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising<claim-text>a buffer that holds the first data read from the first block of the non-volatile memory.</claim-text></claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The controller according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein:<claim-text>the first data includes an error correction code;</claim-text><claim-text>the controller further includes an error correction unit that corrects an error of the first data on a basis of the error correction code; and</claim-text><claim-text>the control unit writes the first data subjected to the error correction to the first block.</claim-text></claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The controller according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein:<claim-text>the first information indicates a state of the non-volatile memory; and</claim-text><claim-text>the control unit updates the first information of the information holding unit in accordance with the state of the non-volatile memory.</claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The controller according to <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein:<claim-text>the first information includes a cumulative value of the number of writes or the number of reads of the non-volatile memory; and</claim-text><claim-text>the control unit updates the first information of the information holding unit every time when the non-volatile memory is written or read.</claim-text></claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The controller according to <claim-ref idref="CLM-00008">claim 8</claim-ref>, further comprising<claim-text>a second interface unit connected to a host system, wherein:</claim-text><claim-text>the control unit receives a write or read command from the host system via the second interface unit and performs write to or read from the non-volatile memory in response to the command;</claim-text><claim-text>the first information includes a cumulative value of the number of executions of the command; and</claim-text><claim-text>the control unit updates the first information of the information holding unit every time when the command is executed.</claim-text></claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The controller according to <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein:<claim-text>the first information includes an operating time of the non-volatile memory; and</claim-text><claim-text>the control unit updates the first information of the information holding unit as time elapses.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The controller according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein:<claim-text>the first state corresponds to a first value;</claim-text><claim-text>the second state corresponds to a second value; and</claim-text><claim-text>the control unit does not write the second data in a case where all bits of the first data have the first value.</claim-text></claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The controller according to <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein:<claim-text>the first state corresponds to a first value;</claim-text><claim-text>the second state corresponds to a second value; and</claim-text><claim-text>the control unit does not write the first data in a case where the address of the first block is not the first address and all bits of the first data have the first value.</claim-text></claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The controller according to <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein<claim-text>the control unit does not write the first data in a case where the address of the first block is not the first address and the address of the first block is a second address.</claim-text></claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The controller according to <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein<claim-text>the second address is an address of an unused block among the plurality of blocks.</claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The controller according to <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein<claim-text>the second address is an address of a block storing unnecessary data among the plurality of blocks.</claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The controller according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein<claim-text>the control unit sequentially selects the plurality of blocks in the non-volatile memory, and</claim-text><claim-text>defines the selected block as the first block.</claim-text></claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. A memory system comprising:<claim-text>a non-volatile memory that includes a plurality of blocks of memory cells that enter into both a first state and a second state and in which a plurality of addresses is allocated to the plurality of blocks; and</claim-text><claim-text>a controller including an information holding unit that holds first information and a control unit, wherein:</claim-text><claim-text>the control unit</claim-text><claim-text>reads first data from a first block of the non-volatile memory,</claim-text><claim-text>specifies the memory cell in the second state among the memory cells in the first block and writes second data for causing the specified memory cell in the second state to transition to the first state, and</claim-text><claim-text>selects one of the first information and the first data on a basis of the address of the first block and writes the selected first information or first data to the first block.</claim-text></claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. A method of controlling a memory, the method comprising:<claim-text>reading first data from a first block of a non-volatile memory that includes a plurality of blocks of memory cells that enter into both a first state and a second state and in which a plurality of addresses is allocated to the plurality of blocks;</claim-text><claim-text>specifying the memory cell in the second state among the memory cells in the first block and writing second data for causing the specified memory cell in the second state to transition to the first state; and</claim-text><claim-text>selecting one of first information held in an information holding unit and the first data on a basis of the address of the first block and writing the selected first information or first data to the first block.</claim-text></claim-text></claim></claims></us-patent-application>