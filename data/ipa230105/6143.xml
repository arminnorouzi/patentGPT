<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230006144A9-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230006144</doc-number><kind>A9</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17549570</doc-number><date>20211213</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><us-publication-filing-type><us-republication-corrected/></us-publication-filing-type><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>01</class><subclass>L</subclass><main-group>51</main-group><subgroup>00</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>C</section><class>07</class><subclass>D</subclass><main-group>209</main-group><subgroup>86</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>01</class><subclass>L</subclass><main-group>51</main-group><subgroup>0072</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>C</section><class>07</class><subclass>D</subclass><main-group>209</main-group><subgroup>86</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>01</class><subclass>L</subclass><main-group>51</main-group><subgroup>0056</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>01</class><subclass>L</subclass><main-group>51</main-group><subgroup>0058</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>01</class><subclass>L</subclass><main-group>51</main-group><subgroup>5088</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">Trie-Based Indices for Databases</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>16020936</doc-number><date>20180627</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11204905</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17549570</doc-number></document-id></child-doc></relation></continuation><related-publication><document-id><country>US</country><doc-number>20220255014</doc-number><kind>A1</kind><date>20220811</date></document-id></related-publication></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only"><addressbook><orgname>DataStax, Inc.</orgname><address><city>Santa Clara</city><state>CA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Lambov</last-name><first-name>Branimir Zdravkov</first-name><address><city>Nesebar</city><country>BG</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A database system uses byte ordering for keys and a trie index to reference stored data. The keys of a database are converted into byte-comparable sequences of byte values. The trie index is generated including nodes connected by edges defining paths from a root node to leaf nodes. Each edge is associated with at least one byte value such that each path from the root node to a leaf node through one or more edges defines a unique byte prefix for a byte-comparable sequence of byte values. The leaf node of each path is associated with a database location value. A record is accessed in the database using a database location value determined from referencing the trie index using a byte-comparable sequence of byte values of the record generated from a key of the record. A trie structure and byte ordered keys may be used for partition or row indices.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="100.16mm" wi="141.14mm" file="US20230006144A9-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="168.99mm" wi="157.31mm" orientation="landscape" file="US20230006144A9-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="157.82mm" wi="163.24mm" orientation="landscape" file="US20230006144A9-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="197.19mm" wi="158.75mm" orientation="landscape" file="US20230006144A9-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="220.81mm" wi="153.08mm" orientation="landscape" file="US20230006144A9-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="139.36mm" wi="143.17mm" file="US20230006144A9-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="124.97mm" wi="143.17mm" file="US20230006144A9-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="174.67mm" wi="143.17mm" file="US20230006144A9-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="150.45mm" wi="143.17mm" file="US20230006144A9-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="224.03mm" wi="152.65mm" file="US20230006144A9-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">CROSS REFERENCE TO RELATED APPLICATIONS</heading><p id="p-0002" num="0001">This application is a continuation of co-pending U.S. application Ser. No. 16/020,936, filed Jun. 27, 2018, allowed, which is herein incorporated in its entirety by reference.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">BACKGROUND</heading><p id="p-0003" num="0002">The disclosure generally relates to managing databases, and in particular to database indexing using trie-based indices.</p><p id="p-0004" num="0003">Database systems such as Cassandra have a heavy reliance on comparisons. Comparisons are used throughout read and write paths, coordination, compaction, etc. to be able to order and merge results. Comparisons also supports a range of data types which often require the compared object to be completely in memory to order correctly, which in turn has necessitated interfaces where comparisons can only be applied if the compared objects are completely loaded.</p><p id="p-0005" num="0004">This has some negative implications on the performance of the database, both in terms of the time it takes to load, compare and garbage collect, as well as in terms of the space required to hold complete keys in on-disk indices and deserialized versions in in-memory data structures. Furthermore, the reliance on comparisons forces Cassandra to use only comparison-based structures, which can be inefficient.</p><heading id="h-0003" level="1">SUMMARY</heading><p id="p-0006" num="0005">Embodiments relate to using byte ordering for keys and a trie index for referencing a database. In some embodiments, keys of a database are converted into byte-comparable sequences of byte values. A trie index for the database is generated including nodes connected by edges defining paths from a root node to leaf nodes, each edge being associated with at least one byte value such that each path from the root node to a leaf node through one or more edges defines a unique byte prefix for a byte-comparable sequence of byte values, the leaf node of each path being associated with a database location value. To access a record, a key for the record is converted into a byte comparable sequence of byte values. The trie index is referenced using the byte-comparable sequence of byte values to determine a database location value of the record. The record is accessed using the database location value of the record.</p><p id="p-0007" num="0006">Some embodiments include a system including a database and processing circuitry. The processing circuitry converts keys of the database into byte-comparable sequences of byte values, and generates a trie index for the database. The trie index includes nodes connected by edges defining paths from a root node to leaf nodes. Each edge is associated with at least one byte value such that each path from the root node to a leaf node through one or more edges defines a unique byte prefix for a byte-comparable sequence of byte values. The leaf node of each path is associated with a database location value. The processing circuitry converts a key for a record into a byte-comparable sequence of byte values, references the trie index using the byte-comparable sequence of byte values of the record generated from the key to determine a database location value of the record, and accesses the record in the database using the database location value of the record.</p><p id="p-0008" num="0007">Some embodiments include a non-transitory computer readable medium storing instructions that when executed by a processor causes the processor to: convert keys of the database into byte-comparable sequences of byte values; generate a trie index for the database, the trie index including nodes connected by edges defining paths from a root node to leaf nodes, each edge being associated with at least one byte value such that each path from the root node to a leaf node through one or more edges defines a unique byte prefix for a byte-comparable sequence of byte values, the leaf node of each path including a database location value; convert a key for a record into a byte-comparable sequence of byte values; reference the trie index using the byte-comparable sequence of byte values of the record generated from the key to determine a database location value of the record; and access the record in the database using the database location value of the record.</p><p id="p-0009" num="0008">Other embodiments include components, devices, systems, improvements, methods, processes, applications, computer readable mediums, and other technologies related to any of the above.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a schematic block diagram of a database system, in accordance with some embodiments.</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a schematic block diagram of another database system, in accordance with some embodiments.</p><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIGS. <b>3</b>A and <b>3</b>B</figref> are examples of trie indices, in accordance with some embodiments.</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a flow chart of a process for generating a trie index for blocks of records, in accordance with some embodiments.</p><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a flow chart of a process for accessing a record using a trie index, in accordance with some embodiments.</p><p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a flow chart of a process for generating a trie row index, in accordance with some embodiments.</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a flow chart of a process for accessing a record using a trie partition index and a trie row index, in accordance with some embodiments.</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a schematic block diagram of a computer used in the database system, in accordance with some embodiments.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0005" level="1">DETAILED DESCRIPTION</heading><p id="p-0018" num="0017">Embodiments relate to applying byte ordering and trie indices to database systems. Examples of database systems may include, but are not limited to, Cassandra, DynamoDB, CosmosDB, Spanner, etc. The comparing and ordering of objects in database systems such as Cassandra is improved by byte ordering for data types used in keys. The terms &#x201c;byte order&#x201d; or &#x201c;byte-comparable&#x201d; refers to the property of being ordered via lexicographic compare on the unsigned values of the byte contents. Some of the data types in Cassandra are byte ordered (e.g. strings, blobs), but other heavily used ones (e.g. integers, uuids) are not byte ordered. As such, non-byte-comparable data types are converted to byte comparable data sequences of bytes and used to reference a trie index.</p><p id="p-0019" num="0018">The universal availability of byte ordering for all data types used for keys provides various advantages. Comparisons can be done using a single process, and core machinery for data access does not need to know how to handle the individual data types. Prefix differences are enough to define order; unique prefixes can be used instead of complete keys. Tries can be used to store, query and iterate over sets of keys, providing fast lookup and prefix compression. Merging can be performed by merging tries, significantly reducing the number of necessary comparisons.</p><p id="p-0020" num="0019">The trie index includes nodes connected by edges, with each edge being associated with one or more byte values. Each path from a root node to a leaf node through one or more edges defines a unique byte prefix for a byte-comparable sequence of byte values. A database location value is stored at each leaf node. As such, the trie index provides a mapping of keys as represented by byte-ordered sequences of byte values to database location values. In some embodiments, a database is referenced using a trie based partition index and a trie based row index.</p><heading id="h-0006" level="2">Example Database System</heading><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a schematic block diagram of a database system <b>100</b>, in accordance with some embodiments. The database system <b>100</b> includes a processor <b>104</b>, a memory <b>106</b>, a network connection <b>108</b>, and a database <b>110</b>. The memory <b>106</b> stores instructions that when executed by the processor <b>104</b>, causes the processor <b>104</b> to control operation of the database system <b>100</b>. For example, the processor <b>104</b> may service requests and manage the database <b>110</b>. The processor <b>104</b> may also update the database <b>110</b> by managing the trie index <b>112</b>, and reading and writing data files to the database <b>110</b>. The network connection <b>108</b> connects the database system <b>100</b> to a network, which may include the Internet.</p><p id="p-0022" num="0021">The database <b>110</b> includes a trie index <b>112</b> providing an index of records stored in rows <b>116</b> and columns <b>118</b> of the database <b>110</b>. Each row <b>116</b> may include a record including data stored in columns <b>118</b> of the row <b>116</b>. In some embodiments, the database <b>110</b> may include one or more trie indices <b>112</b> and partitions, with each trie index <b>112</b> being associated with a partition <b>114</b>. The trie index <b>112</b> includes a trie data structure that describes a mapping between sequences of byte values and database location values of the partition <b>114</b>. In some embodiments, the partition <b>114</b> is stored in one or more data files. Cassandra, for example, uses short string table (SSTable) data files to store partitions of a database. The database location value may indicate the position in a data file storing a row <b>116</b>.</p><p id="p-0023" num="0022">In some embodiments, the database <b>110</b> includes multiple rows <b>116</b> that operate as a main unit of data. To find a row, a primary key is used to reference the trie index <b>112</b>. Here, the trie index <b>112</b> is also referred to as a primary trie index.</p><p id="p-0024" num="0023">In embodiments where the database system <b>100</b> is part of a distributed database, such as Cassandra, there is an additional level of splitting where a database table may include multiple partitions <b>114</b>, each partition <b>114</b> being a set of rows that are placed together on the same node (e.g., machine/server). To address in these distributed database systems, a partition may be referenced by one part of a primary key, referred to as a &#x201c;partition key,&#x201d; and the individual row within a partition is addressed by the rest of the primary key, referred to as a &#x201c;clustering key&#x201d;. As discussed in greater detail below in connection with <figref idref="DRAWINGS">FIG. <b>2</b></figref>, a partition key may be used to reference a partition trie index <b>212</b>, and the clustering key may be used to reference a row trie index <b>220</b>.</p><p id="p-0025" num="0024">As such, a table contains a list of partitions split among the individual nodes of the cluster (where the partition key is used to select the individual partition and server), and each partition contains a list of rows (where the clustering key selects the individual row). The primary key is a combination of the primary and clustering keys.</p><p id="p-0026" num="0025">The trie index <b>112</b> is referenced using byte-comparable sequences of byte values as keys. For example, to access data for read or write, a key is generated to query the trie index. The key may include different data having different data types. The key is converted into the byte-comparable sequence of byte values. The conversion may include converting the different data types used for the key into byte-comparable byte values. Accordingly, byte order is available for any data type used for keys. The byte-comparable sequence of byte values is then used to traverse the trie index <b>112</b> for a database location value. The trie index <b>112</b> and byte-comparable byte values are discussed in greater detail in connection with <figref idref="DRAWINGS">FIGS. <b>3</b>A, <b>3</b>B, <b>4</b>, and <b>5</b></figref>.</p><p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a schematic block diagram of a database system <b>200</b>, in accordance with some embodiments. The database system <b>200</b> includes a database <b>210</b> including multiple partitions <b>214</b><i>a </i>through <b>214</b><i>n </i>(each referred to as partition <b>214</b>), and a partition trie index <b>212</b> of the partitions <b>214</b><i>a </i>through <b>214</b><i>n</i>. As shown for the partition <b>214</b><i>a</i>, each partition <b>214</b> may include a row trie index <b>220</b>, rows <b>215</b>, and columns <b>210</b>.</p><p id="p-0028" num="0027">The partition trie index <b>212</b> is an index that references multiple partition <b>214</b>, and thus can be used to identify a partition and the row index <b>220</b> of the partition <b>214</b>. Like the database system <b>100</b>, the database system <b>200</b> includes a processor <b>104</b>, a memory <b>106</b>, and a network connection <b>108</b>.</p><p id="p-0029" num="0028">The database system <b>200</b> is a database node of a distributed database system, such as Cassandra. A table of the database <b>210</b> may be distributed across a cluster of database nodes, each database node including one or more partitions <b>214</b> of the distributed database, and with at least a portion of the partitions <b>214</b> including an associated row trie index <b>220</b> for the rows <b>216</b> of the partition <b>214</b>. A database node may include multiple partitions <b>214</b>. Each node may use the partition trie index <b>212</b> to identify a particular partition <b>214</b>, including partitions stored in other nodes.</p><p id="p-0030" num="0029">The partition trie index <b>212</b> and row trie index <b>220</b> provide an index of records stored in the rows <b>216</b> and columns <b>218</b> of the partition <b>214</b>. The partition trie index <b>212</b> maps a specified partition key to particular partition <b>214</b> and the associated row trie index <b>220</b> for the partition <b>214</b>. The row trie index <b>220</b> is used to iterate from a given clustering key in forward or reverse direction (where exact key lookup is just a special case) along the rows <b>116</b>. The partition trie index <b>212</b> and row trie index <b>220</b> each includes a trie data structure that describes a mapping between sequences of byte values and database location values of the database <b>110</b>. For example, the partition trie index <b>212</b> maps to database location values of the row trie indices <b>220</b>, and each row trie index <b>220</b> maps to database location values of the rows. In some embodiments, each partition <b>214</b> may be stored in one or more data files. In some embodiments, a subset of the partitions <b>214</b> include a row trie index <b>220</b>.</p><heading id="h-0007" level="2">Byte Order Types</heading><p id="p-0031" num="0030">A database system may use non-byte-order-comparable data types (e.g., integers, uuids, etc.) for keys. For each data type, a conversion function can be defined that maps each possible value to a sequence of bytes, such that whenever two values are converted using this function, the result of lexicographically comparing the mappings is the same as the result of comparing the original values using the comparison function for the type.</p><p id="p-0032" num="0031">To be able to completely abstract type information away from the storage machinery, lists of typed values (e.g., the individual components of a clustering key) are flattened into single byte sequences. It is possible to also define a mapping for reversed types within a list, e.g. by flipping all bits of the encoded byte sequence. Some example data types that may be converted to byte values include Fixed length unsigned integers (murmur token, date/time), fixed-length signed integers (byte, short, int, bigint), fixed-size floating-point numbers (float, double), multi-component sequences (partition or clustering keys, tuples), bounds and nulls, variable-length byte comparables (ASCII, UTF-8 strings, blobs, InetAddress), variable-length integers (varint, RandomPartitioner token), and variable-length floating-point decimals (decimal).</p><heading id="h-0008" level="2">Tries</heading><p id="p-0033" num="0032">A trie is a data structure that describes a mapping between sequences and associated values. A trie index refers to a trie that is used for mapping byte-comparable sequences (or their unique prefixes) to database location values. Mapping refers to the process of obtaining a database location value that corresponds to a particular key (e.g., mathematically, the result of applying a function). An &#x201c;index,&#x201d; refers to a data structure that facilitates the mapping. &#x201c;Indexing&#x201d; refers to a process of creating the data structure. <figref idref="DRAWINGS">FIG. <b>3</b>A</figref> is an example of a trie index <b>300</b>, in accordance with some embodiments. The trie index <b>300</b> is an example of the trie index <b>112</b>, the partition trie index <b>212</b>, or the row trie index <b>220</b>.</p><p id="p-0034" num="0033">The trie index <b>300</b> includes nodes <b>302</b> connected by edges <b>304</b> defining paths from a root node <b>306</b> to leaf nodes <b>308</b>. Each edge <b>304</b> is associated with a byte value such that each path from the root node <b>306</b> to a leaf node <b>308</b> through one or more edges <b>304</b> defines a unique byte prefix. In the example of <figref idref="DRAWINGS">FIG. <b>3</b></figref>, the byte prefixes are represented by letters of the alphabet. The root node <b>306</b> is connected to an edge associated with the byte value &#x201c;d,&#x201d; and another edge associated with the byte value &#x201c;t.&#x201d; The words formed by traversing the edges <b>304</b> are analogous to byte-comparable sequences of bytes of a key. The leaf node <b>308</b> of each path includes a database location value <b>310</b>.</p><p id="p-0035" num="0034">A valid word in the trie index <b>300</b> is encoded by a path starting from the root node <b>306</b> of the trie where each edge <b>304</b> is labeled with the next byte value of the sequence, and ending in the leaf node <b>308</b> which contains the &#x201c;payload&#x201d; <b>310</b> associated with the sequence of bytes.</p><p id="p-0036" num="0035">This means that in a constructed trie index <b>300</b> finding the payload associated with a sequence of bytes is a matter of following the edges <b>304</b> (also called &#x201c;transitions&#x201d;) from the root node <b>306</b>, and along edges <b>304</b> labeled with the consecutive byte values (or characters, as represented in <figref idref="DRAWINGS">FIG. <b>3</b></figref>) of the word, and retrieving the payload <b>310</b> associated with the destination. For the example the partition trie index <b>212</b> and the row trie index <b>220</b>, the sequence of byte values of the partition key is used to traverse the nodes of the partition trie index <b>212</b> to identify a partition and the associated row trie index <b>220</b> of the partition. The sequence of byte values of the clustering key is used to traverse the row trie index <b>220</b> to access the row within the partition. If the traversal destination does not result at a leaf node <b>308</b>, or if at any point in the path there is no transition in the trie index <b>300</b> matching the byte value, the trie index <b>300</b> does not have an association for the byte sequence. Among other things, complexity is optimized because the complexity of lookup is thus O(len(sequence)) transitions, where the cost of taking a transition is usually constant.</p><p id="p-0037" num="0036">From a storage space perspective, an advantage of a trie index <b>300</b> as a data structure for storing a map is to avoid storing of redundant prefixes. All byte-comparable sequences of bytes that start with the same sequence are stored as a representation of that sequence only once. If prefixes are commonly shared, this can save a great deal of space. For example, the byte values represented by the words &#x201c;drag&#x201d; and &#x201c;drastic&#x201d; share byte prefixes represented by the characters &#x201c;dra.&#x201d;</p><p id="p-0038" num="0037">When the items stored in the trie index <b>300</b> are lexicographically (=byte) ordered, the trie index <b>300</b> is an ordered structure. The trie index <b>300</b> can be walked in order and it is also possible to efficiently list the items between two given keys. A trie index <b>300</b> can be constructed from sorted input, incrementally storing the data directly to disk and building an efficient read-only on-disk data structure.</p><p id="p-0039" num="0038">In some embodiments, trie index <b>300</b> is an ordered byte source to payload map that is applied to the indices of Cassandra. When writing to the index, each key is mapped into a byte-comparable sequence of bytes (also referred to as the byte ordered representation), and an on-disk trie of byte-ordered representations of keys mapping into positions in a data file is created.</p><p id="p-0040" num="0039">For an exact match for a key, a byte-ordered representation of the key is generated and used to traverse the trie. If the match is found, the data file position is known. If there is no match, then there is no data associated with the key.</p><p id="p-0041" num="0040">For a greater-than/greater-or-equal match for a key, the byte-ordered representation is used to create a path that leads to the first matching data position in the data file. The path is used to iterate the greater keys in the data file.</p><heading id="h-0009" level="2">Unique Byte Prefixes</heading><p id="p-0042" num="0041">The trie index <b>300</b> is used to find a position in a data file for a given key. It needs to be able to find the correct position for any existing key, but there is no need for it to be exact on keys that are not present in the data file&#x2014;since the data file contains a copy of the key at the start of each partition, we can simply check if the key we are searching for matches the key at the position returned by the index.</p><p id="p-0043" num="0042">This allows us to use a simple optimization: instead of storing the full key in the trie index, we can store only a prefix of the key that is unique among all indexed values. This means intermediate nodes are in the trie only if a prefix is shared by multiple keys, which normally reduces the number of nodes and transitions in the trie to about twice the number of values. With reference to <figref idref="DRAWINGS">FIG. <b>3</b></figref>, the edge <b>312</b> to the leaf node <b>314</b> is associated with multiple byte values represented by &#x201c;stic.&#x201d; The edge <b>316</b> to the leaf node <b>318</b> is associated with a single byte value represented by &#x201c;g.&#x201d; The node <b>320</b> is an intermediate node shared by multiple keys and leaf nodes.</p><p id="p-0044" num="0043">Use of unique byte prefixes in the trie index <b>300</b> rather than full byte-comparable sequences of bytes also reduces the number of edges <b>304</b> that must be traversed in the trie index <b>300</b> from the root node <b>305</b> to a leaf node <b>308</b>. In a well-balanced key set (such as the one where the byte-ordered key starts with a hash token) the lookup complexity becomes O(log n) transitions</p><heading id="h-0010" level="2">Trie Index Storage</heading><p id="p-0045" num="0044">Accessing information from non-volatile memory is usually performed in page units, where for every data access the complete disk page that contains the data is loaded. The trie index <b>300</b> may be stored across multiple disk pages. The trie index <b>300</b> may be many times larger than a disk page, and require thousands or millions of disk pages to store. The out-of-cache efficiency is low if a new disk page is read every time a new node is examined. The trie index <b>300</b> may be constructed in a &#x201c;page-packed manner&#x201d; to minimize traversal across different disk pages during lookup.</p><p id="p-0046" num="0045"><figref idref="DRAWINGS">FIG. <b>3</b>B</figref> shows the trie index <b>300</b> stored in a page-packed manner, in accordance with some embodiments. The trie index <b>300</b> is distributed across four disk pages <b>324</b>. Wide sections of the trie index <b>300</b> may be packed in each disk page <b>324</b>. As such, each time a disk page <b>324</b> is opened, several transitions between nodes <b>302</b> along edges <b>304</b> may be performed before leaving the disk page <b>324</b>.</p><p id="p-0047" num="0046">In some embodiments, the page-packed manner of storage is generated starting from the root node <b>306</b> and doing a breadth-first walk, placing the encountered nodes on a disk page <b>324</b> until the disk page <b>324</b> is filled. The target transitions of the encountered nodes from the breadth-first walk are placed in a queue, and the process is repeated to fill other disk pages <b>324</b>.</p><p id="p-0048" num="0047">In some embodiments, more suitable for database indexing because it can be done as part of an incremental construction process, is to do the packing from the bottom up&#x2014;when the incremental construction algorithm completes a node <b>304</b> it is not immediately written to a disk page <b>304</b>. Instead, the size of the branch rooted at this node is evaluated, and a node is written to disk only after the size of the branch rooted at its parent becomes larger than a page (or the data is exhausted). Performing this write reduces the size of the parent branch (as it can now refer to the positions of the children on disk) which from there on can be treated like a leaf, and the process can continue recursively until all data is exhausted.</p><p id="p-0049" num="0048">The bottom-up process has a performance benefit over the top-down: with top-down the root page is full and leaf pages take combinations of unrelated smaller branches; with bottom-up the leaf pages take as much information as possible about a branch, while the root often remains unfilled. For the best possible out-of-cache efficiency we would prefer the set of non-leaf pages to be as small as possible. Having larger leaf page branches means more of the trie data is in the leaf branches and thus the size of that intermediate node set is smaller.</p><heading id="h-0011" level="2">Trie Index Node Types</heading><p id="p-0050" num="0049">A trie index may be stored in memory, including volatile or non-volatile memory (e.g., a disk). To improve the efficiency of storing the information about the edge transitions in a node of a trie index, nodes of multiple types may be used. Node types can define the size of each pointer of the node, the number of children of the node in the trie index, or both.</p><p id="p-0051" num="0050">To maintain that the size of the structure is proportional to the number of overall transitions, the node transitions need to be stored sparsely. Typically this is done using a list of transition characters and binary searching among them to make a transition.</p><p id="p-0052" num="0051">This binary search is inefficient and it is preferable to avoid it as much as possible. To do this, and to save space, an on-disk trie index may use typed nodes. The node types may include: final with no transitions (PAYLOAD_ONLY); one transition (SINGLE), which has to store only the character and target for that transition; a binary-searched list of transitions (SPARSE), where the number of characters, each character and the targets are stored; or a consecutive range of transitions (DENSE), where the first and last character and targets are stored, possibly including some null transitions.</p><p id="p-0053" num="0052">In a well-balanced and populated trie, the nodes where lookup spends most time (the nodes closest to the root) are DENSE nodes, where finding the target for the transition is a direct calculation from the code of the character. On the other hand, most of the nodes (the ones closest to the leaves) are PAYLOAD_ONLY, SINGLE or SPARSE to avoid taking any more space than necessary.</p><p id="p-0054" num="0053">An objective for the trie storage format is to achieve the smallest possible packing (and thus smallest cache usage and disk reads), thus we choose the type that results in the smallest representation of the node. DENSE type gets chosen naturally when its encoding (which avoids storing the character list but may include null targets) is smaller than SPARSE. Nodes within a page may be of different types, and some nodes can be represented in more than one way: e.g. a node with &#x201c;a&#x201d; transition to X may be a SINGLE encoded as something like (SINGLE, &#x201c;a&#x201d;, X), SPARSE encoded as (SPARSE, <b>1</b>, &#x201c;a&#x201d;, X), or DENSE encoded as (DENSE, &#x201c;a&#x201d;, &#x201c;a&#x201d;, X), where the first one will be chosen as the smallest; a node with &#x201c;a&#x201d; transition to X and &#x201c;c&#x201d; transition to Y can be (SPARSE, <b>2</b>, &#x201c;a&#x201d;, &#x201c;c&#x201d;, X, Y) or (DENSE, &#x201c;a&#x201d;, &#x201c;c&#x201d;, X, null, Y) where the first is smallest, but a node with &#x201c;a&#x201d; transition to X and &#x201c;b&#x201d; transition to Y can be (SPARSE, <b>2</b>, &#x201c;a&#x201d;, &#x201c;b&#x201d;, X, Y) or (DENSE, &#x201c;a&#x201d;, &#x201c;b&#x201d;, X, Y) where the dense one is smallest.</p><heading id="h-0012" level="2">Pointer Sizes</heading><p id="p-0055" num="0054">Another optimization in the storage format of the trie index may be used because most nodes in the trie are in the lower levels of the tree and thus close to leaves. As such, the distance between the node and its target transitions when laid out during the construction process is small. As such, pointers are stored as distances and the node types are chosen to use the smallest size of integer which fits all its pointers.</p><p id="p-0056" num="0055">This is even more true for a page-aware layout, where all internal transitions within the page (i.e. &#x3e;99% of all transitions in the trie) can be stored using 12 bits or less.</p><p id="p-0057" num="0056">This is heavily used via further specialization of the node types: e.g. there may be INPAGE_DENSE, DENSE_16 to DENSE_40 as well as DENSE_LONG subtypes which differ in the size of pointer they use.</p><heading id="h-0013" level="2">Primary Index</heading><p id="p-0058" num="0057">In a distributed database system, the purpose of the primary index (e.g., of an sstable in Cassandra) is to be able to map a key containing a partition key and clustering key to a position in the sstable data file which holds the relevant row or the closest row with a greater key and enables iteration of rows from that point on. Partition keys are normally fully specified, while clustering keys are often given partially or via a comparison relation. They are also treated differently by all the infrastructure and conventionally have different index structures.</p><heading id="h-0014" level="2">Partition Index</heading><p id="p-0059" num="0058">The purpose of a partition index is to map a specified partition key to a row index for the partition. A partition index also needs to support iteration from a (possibly partially specified) partition position. For example, the partition trie index <b>212</b> is a partition index that supports iteration from a (possibly partially specified) partition position.</p><p id="p-0060" num="0059">In addition to wide partitions where a row index is mandatory, Cassandra is often used for tables where the partitions have only a couple of rows, including also ones where the partition key is the only component of a primary key, i.e. where row and partition are the same thing. For these situations it makes no sense to actually have a row trie index <b>220</b> and the partition trie index <b>212</b> should point directly to the data.</p><p id="p-0061" num="0060">The application of tries to a partition index may include creating a trie mapping unique byte-ordered partition key prefixes to either: a position in a row index file which contains the row index of the rows within that partition, or a position in the data file containing the relevant partition (if a row index is not necessary). A single table can have both indexed and non-indexed rows.</p><p id="p-0062" num="0061">Lookup in partition trie index <b>212</b> is accomplished by converting a partition key to its byte-ordered representation and following the transitions for its bytes. If at any point the trie does not offer a transition for the next byte but is not a leaf node, then the data file does not contain a mapping for the given key. If a leaf of the trie is reached, then the prefix of the partition key matches some content in the file, which may or may not be a full match for the partition key. The leaf node points to a place in the row trie index <b>220</b> or data file. In either case the first bytes at the specified position contain a serialization of the partition key, which we can compare to the key being mapped. If it matches, the partition is found. If not, since the stored prefixes are unique, no data for this partition exists in this data file.</p><p id="p-0063" num="0062">In some embodiments the partition trie index <b>212</b> can also store a number of bits of the hash of the partition key, which can be used as a quick filter to reject non-matching keys with high probability without needing to refer to the data file or row index to fetch the complete key. For example, each leaf node of the trie index <b>212</b> may store hash bits. To access a record, a key for the record is converted into another byte-comparable sequence of bytes. The trie index <b>212</b> is traversed from the root node to a leaf node for a unique byte prefix of the byte-comparable sequence of bytes. The hash bits of the leaf node are compared to a remaining portion of the byte-comparable sequence of bytes to determine whether the record is stored in the database. In various embodiments, the hash bits of the leaf node may be compared to a hash value computed from the original key, a hash value computed from the remaining portion of the byte-comparable sequence of bytes, or a hash value computed from the whole of the byte-comparable sequence of bytes. Here, if the given key matched a prefix associated with the leaf node but not the hash bits, the key is determined as failing to match a record in the database and can be skipped without having to reference a row trie index <b>220</b> or data file of the partition identified by the leaf node. If the hash bits match the hash value, the probability that the key matches a record in the database is high.</p><heading id="h-0015" level="2">Row Index</heading><p id="p-0064" num="0063">The row trie index <b>220</b> is a row index. Unlike the partition trie index <b>212</b>, the row index is used to iterate from a given clustering key in forward or reverse direction (where exact key lookup is just a special case).</p><p id="p-0065" num="0064">Rows are often very small (they could contain a single int or no columns at all) and thus there is a real possibility for the row indices to become bigger than the data they represent. This is not a desirable outcome, and thus blocks of rows of indexed together.</p><p id="p-0066" num="0065">The row index includes a map from clustering keys or prefixes to the data position at the start of the index block which is the earliest that could contain a key equal or greater than the given one. Additionally, if there is an active deletion at the beginning of the block, the index must specify it so that it can be taken into account when merging data from multiple data files.</p><p id="p-0067" num="0066">Each index block contains at least one key, or may include different first and last keys. The row trie index <b>220</b> indexes the positions between blocks by storing a &#x201c;separator,&#x201d; a key that is greater than the last key of the previous block and smaller than or equal to the first key of the next. Then, a given clustering is looked up, following its bytes as long as we can in the trie. As such, all blocks before the closest less-than-or-equal entry in the trie cannot contain any data that is greater than or equal to the given key.</p><p id="p-0068" num="0067">If the identified block actually doesn't contain any matching data (e.g. because the looked-up key ends up between the last key in the block and the separator), this only affects efficiency as the iteration mechanism does not expect the data position returned by the index to be guaranteed to start with elements that fit the criteria; it would only have to walk a whole block forward to find the matching key.</p><p id="p-0069" num="0068">The number of these false positives should be kept low, and at the same time the smallest possible size of the index for a given granularity is desirable. The choice of separator affects this balance. In one example, as a good tradeoff in the vein of the unique prefix approach used in the partition index, the shortest prefix of the next block's beginning key that separates it from the previous block's end key is used, and adjusted so that the last byte of it is 1 greater than that end key.</p><p id="p-0070" num="0069">For example, if block <b>2</b> covers &#x201c;something&#x201d; to &#x201c;somewhere&#x201d; and a next block <b>3</b> covers &#x201c;sorry&#x201d; to &#x201c;tease&#x201d;, then the sequence &#x201c;son&#x201d; is used as the separator between blocks <b>2</b> and <b>3</b>. This leaves things like &#x201c;sommelier&#x201d; in the area that triggers false positives, but stores and has to walk just three bytes to find the starting point for iteration.</p><heading id="h-0016" level="2">Example Trie Index Application</heading><p id="p-0071" num="0070"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a flow chart of a process <b>400</b> for generating a trie index, in accordance with some embodiments. The process <b>400</b> provides for an indexing of a database using a trie index. The process <b>400</b> may include additional or fewer steps, and steps may be performed in different orders.</p><p id="p-0072" num="0071">A database system (e.g., processor <b>104</b> of the system <b>100</b>) converts <b>405</b> keys of a database into byte-comparable sequences of byte values. A key references a record stored in a row <b>116</b> of the database <b>110</b>. The key may include data of multiple data types. Each of the data types is converted to a byte-comparable byte value to generate a byte-comparable sequence of bytes for the key. In some embodiments, each key of a database system such as Cassandra is converted into the byte-comparable sequences of byte values.</p><p id="p-0073" num="0072">The database system generates <b>410</b> a trie index for the database mapping unique byte prefixes of the byte-comparable sequences of byte values to database location values. Each of the byte-comparable sequence of bytes has a unique byte prefix. The unique byte prefix of a byte-comparable sequence of bytes may include a minimum amount of byte values needed to distinguish the byte-comparable sequence of bytes from other byte-comparable sequences of bytes of the trie index. In some embodiments, the trie index uses the full byte-comparable sequences of byte values rather the unique byte prefixes. A database location value may refer to a position in a data file, a further level of indexing (e.g., referencing a row index), or other relevant information such as filtering hash bits, tombstone/deletion information, latest timestamp, or other metadata. The database location value may be different depending on whether the trie index is a partition index or row index.</p><p id="p-0074" num="0073">The database system stores <b>415</b> the trie index. Nodes of the trie index may be stored in a memory as they are written, and periodically flushed to disk pages for more permanent storage. The manner in which the trie index is incorporated into the disk pages can improve efficiency of data access. To minimize transitions between different disk pages <b>324</b> when traversing the trie index <b>300</b>, the trie index <b>300</b> may be distributed across multiple disk pages <b>324</b> with wide sections of the trie index <b>300</b> packed in each disk page <b>324</b> as shown in <figref idref="DRAWINGS">FIG. <b>3</b>B</figref>. The trie index <b>300</b> may be stored across disk pages <b>324</b> using a bottom-up or top-down process. In some embodiments, the trie may be stored on disk in a page-packed manner, i.e. where the trie is written from the bottom up, delaying writes to disk until a branch becomes the biggest that can fit a disk page. The bottom-up process provides for incremental construction of the trie index.</p><p id="p-0075" num="0074">In some embodiments, the trie index is stored with the smallest representation of each node. Examples of node types include PAYLOAD_ONLY (final), SINGLE, SPARSE, or DENSE. Node types define the size of each pointer of the node, or the number of children of the node in the trie index. Different node types are represented by different numbers of bytes, and thus smaller node types may be used when possible. The trie index <b>300</b> is stored in manner to minimize disk usage, and thus reduces cache usage and disk reads.</p><p id="p-0076" num="0075">In some embodiments, the pointers in the nodes of the trie index are encoded using differences between a current and target position within the file.</p><p id="p-0077" num="0076"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a flow chart of a process <b>500</b> for accessing a record using a trie index, in accordance with some embodiments. The process <b>500</b> may be performed to search for a record using the trie index, such as for read or write operations. The process <b>500</b> may include additional or fewer steps, and steps may be performed in different orders.</p><p id="p-0078" num="0077">A database system (e.g., processor <b>104</b> of the system <b>100</b>) converts <b>505</b> a key for a record of a database into a byte-comparable sequence of bytes. For example, the database system may receive query including the key. The key may include data of multiple data types. Each of the data types is converted to a byte-comparable byte value to generate a byte-comparable sequence of bytes for the key. In some embodiments, the key may be a primary key including a partition key used to reference a partition index, and a clustering key used to reference a row index.</p><p id="p-0079" num="0078">The database system references <b>510</b> the trie index using the byte-comparable sequence of bytes to determine a database location value for the record. For example, the trie index <b>300</b> may be traversed from the root node <b>306</b> along edges <b>304</b>. Each edge <b>304</b> may correspond with one or more byte values, and thus the byte-comparable sequence of bytes or a corresponding unique byte prefix defines a path along one or more edges <b>304</b>. If a leaf node <b>308</b> with payload <b>310</b> is reached by traversing the trie index, the database location value is retrieved from the payload <b>310</b>.</p><p id="p-0080" num="0079">The database system accesses <b>515</b> the record in the database using the database location value. If the trie index is a partition index, the trie index maps byte-comparable sequences of bytes generated from partition keys to a position in a row index file (e.g., if the partition has enough rows to form multiple row index blocks), or directly to a position in a data file (e.g., if the partition has fewer rows). There may be one row index per partition, or no row index if the number of rows in the partition is below a row block size. The row index file contains a collection of trie row indices mapping row blocks to a position in the data file, and other relevant metadata.</p><p id="p-0081" num="0080"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a flow chart of a process <b>600</b> for generating a trie row index, in accordance with some embodiments. The process <b>600</b> may include additional or fewer steps, and steps may be performed in different orders.</p><p id="p-0082" num="0081">The database system (e.g., processor <b>104</b> of the system <b>100</b>) forms <b>605</b> blocks from groups of rows in a database. Each row in the database <b>110</b> may correspond with a record. The rows <b>116</b> of the database <b>110</b> may be small, and thus blocks of rows may be indexed together. The rows may be part of a partition.</p><p id="p-0083" num="0082">For each block, the database system converts <b>610</b> an initial key into an initial byte-comparable sequence of bytes and a final key into a final byte-comparable sequence of bytes. Each row of the block is associated with a key. The initial key refers to the key of the first row in the block, and the final key refers to the key of the final row in the block.</p><p id="p-0084" num="0083">For each consecutive pair of blocks, the database system determines <b>615</b> separator byte prefixes that are larger than the final byte-comparable sequence of bytes of a preceding block and smaller than the initial byte-comparable sequence of bytes of a succeeding block. Each pair of blocks includes a preceding and succeeding block.</p><p id="p-0085" num="0084">The database system generates <b>620</b> a trie row index for the database mapping the separator byte prefixes to positions in the database between the blocks. For example, the trie row index associates the separator byte prefix for each pair of preceding and succeeding blocks to a position in the database (e.g., a data file) between the preceding and the succeeding block. The trie row index may include nodes connected by edges, with each edge being associated with a byte value. The separator byte prefixes are defined by paths from root node to a leaf node in the trie row index along edges, and the position in the database for a separator byte prefix is stored at the leaf node of the path.</p><p id="p-0086" num="0085">The database system stores <b>625</b> the trie row index. The trie row index may be stored across disk pages <b>324</b> using a top-down or bottom-up process. The trie index may also be stored with the smallest representation of each node using node types represented by different numbers of bytes.</p><p id="p-0087" num="0086"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a flow chart of a process <b>700</b> for accessing a record using a trie partition index and a trie row index, in accordance with some embodiments. The process <b>700</b> may include additional or fewer steps, and steps may be performed in different orders.</p><p id="p-0088" num="0087">A database system (e.g., processor <b>104</b> of the system <b>100</b>) converts <b>705</b> a partition key into a first byte-comparable sequence of bytes and a clustering key into a second byte-comparable sequence of bytes. A key for a record in a database may be a primary key including the partition key that is used to reference the trie partition index <b>212</b> to identify a partition, and the clustering key that is used to reference a row trie index <b>220</b> to identify a row within the partition. For example, the database system may receive query including the primary key. The primary key may include data of multiple data types. Each of the data types is converted to a byte-comparable byte value to generate the byte-comparable sequence of bytes for the key. The byte-comparable sequence of bytes may include the first sequence of bytes for the partition key and the second sequence of bytes for the clustering key.</p><p id="p-0089" num="0088">The database system references <b>710</b> the trie partition index using the first byte-comparable sequence of bytes of the partition key to determine a partition for the record. For example, the partition trie index <b>212</b> may be traversed from the root node along edges according to the bytes of the partition key. Each edge may correspond with one or more byte values, and thus the byte-comparable sequence of bytes of the partition key, or a corresponding unique byte prefix of the byte-comparable sequence of bytes, defines a path along one or more edges. If a leaf node with payload is reached by traversing the trie index, a database location value is retrieved from the payload <b>310</b>. Here, the database location value identifies the partition and the associated trie row index of the partition. For example, the database location may include location in a row index file that includes the trie row index associated with the partition.</p><p id="p-0090" num="0089">The database system references <b>715</b> a trie row index of the partition using the second byte-comparable sequence of bytes to access the record. For example, the database location value retrieved from referencing the partition trie index <b>212</b> is used to retrieve the trie row index. The partition index may map the first byte-comparable sequences of bytes generated from the converted partition key to a position in a row index file that stores the trie row index. Next, there is an iteration using the clustering key in forward or reverse direction through the trie row index.</p><p id="p-0091" num="0090"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a schematic block diagram of a computer <b>800</b>, according to one embodiment. The computer <b>800</b> is an example of circuitry that implements components of the database system <b>100</b>. Illustrated are at least one processor <b>802</b> coupled to a chipset <b>804</b>. The chipset <b>804</b> includes a memory controller hub <b>820</b> and an input/output (I/O) controller hub <b>822</b>. A memory <b>806</b> and a graphics adapter <b>812</b> are coupled to the memory controller hub <b>820</b>, and a display device <b>818</b> is coupled to the graphics adapter <b>812</b>. A storage device <b>808</b>, keyboard <b>810</b>, pointing device <b>814</b>, and network adapter <b>816</b> are coupled to the I/O controller hub <b>822</b>. Other embodiments of the computer <b>800</b> have different architectures. For example, the memory <b>806</b> is directly coupled to the processor <b>802</b> in some embodiments.</p><p id="p-0092" num="0091">The storage device <b>808</b> includes one or more non-transitory computer-readable storage media such as a hard drive, compact disk read-only memory (CD-ROM), DVD, or a solid-state memory device. The memory <b>806</b> holds instructions and data used by the processor <b>802</b>. The pointing device <b>814</b> is used in combination with the keyboard <b>810</b> to input data into the computer system <b>800</b>. The graphics adapter <b>812</b> displays images and other information on the display device <b>818</b>. In some embodiments, the display device <b>818</b> includes a touch screen capability for receiving user input and selections. The network adapter <b>816</b> couples the computer system <b>800</b> to a network. Some embodiments of the computer <b>800</b> have different and/or other components than those shown in <figref idref="DRAWINGS">FIG. <b>8</b></figref>.</p><p id="p-0093" num="0092">The computer <b>800</b> is adapted to execute computer program modules for providing functionality described herein. For example, some embodiments may include a computing device including one or more modules configured to perform the processes <b>400</b>, <b>500</b>, <b>600</b>, and <b>700</b> shown respectively in <figref idref="DRAWINGS">FIGS. <b>4</b>, <b>5</b>, <b>6</b>, and <b>7</b></figref>. As used herein, the term &#x201c;module&#x201d; refers to computer program instructions and/or other logic used to provide the specified functionality. Thus, a module can be implemented in hardware, firmware, and/or software. In one embodiment, program modules formed of executable computer program instructions are stored on the storage device <b>808</b>, loaded into the memory <b>806</b>, and executed by the processor <b>802</b>.</p><p id="p-0094" num="0093">While particular embodiments and applications have been illustrated and described, it is to be understood that the invention is not limited to the precise construction and components disclosed herein and that various modifications, changes and variations which will be apparent to those skilled in the art may be made in the arrangement, operation and details of the method and apparatus disclosed herein without departing from the spirit and scope of the present disclosure.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A database system, comprising:<claim-text>a cluster of database nodes that stores a distributed database, each database node storing one or more partitions of the distributed database, each partition including a set of database rows, each database node including:</claim-text><claim-text>one or more processors; and</claim-text><claim-text>a memory storing instructions that, when executed by the one or more processors, configure the one or more processors to:</claim-text><claim-text>convert a key for a record into a byte-comparable sequence of byte values;</claim-text><claim-text>reference a partition trie index using the byte-comparable sequence of byte values of the record generated from the key to determine a partition of the distributed database; and</claim-text><claim-text>access the record from the partition of the distributed database.</claim-text></claim-text></claim></claims></us-patent-application>