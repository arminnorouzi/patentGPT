<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004853A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004853</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17362813</doc-number><date>20210629</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>N</subclass><main-group>20</main-group><subgroup>00</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>455</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>N</subclass><main-group>20</main-group><subgroup>00</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>45533</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">AUTOMATIC GENERATION AND ASSIGNING OF A PERSISTENT UNIQUE IDENTIFIER TO AN APPLICATION/COMPONENT GROUPING</invention-title><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="obligated-assignee"><addressbook><orgname>VMware, Inc.</orgname><address><city>Palo Alto</city><state>CA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>SINHA</last-name><first-name>Gyan</first-name><address><city>Pune</city><country>IN</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>SINGHAL</last-name><first-name>Madan</first-name><address><city>Pune</city><country>IN</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>SHARMA</last-name><first-name>Abhijit</first-name><address><city>Pune</city><country>IN</country></address></addressbook></inventor></inventors></us-parties><assignees><assignee><addressbook><orgname>VMware, Inc.</orgname><role>02</role><address><city>Palo Alto</city><state>CA</state><country>US</country></address></addressbook></assignee></assignees></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A methodology for assigning an identity to a plurality of unsupervised machine learning based applications is disclosed. In a computer-implemented method, a machine learning based discovery of a plurality of unsupervised machine learning based applications spanning across a plurality of diverse components in a computing environment is received. A persistent unique identifier is assigned to each of the plurality of unsupervised machine learning based applications. It is then determined which of the plurality of diverse components in the computing environment is operating with each of the plurality of unsupervised machine learning based applications.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="131.57mm" wi="158.75mm" file="US20230004853A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="250.53mm" wi="169.42mm" orientation="landscape" file="US20230004853A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="209.80mm" wi="170.10mm" file="US20230004853A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="214.88mm" wi="157.48mm" orientation="landscape" file="US20230004853A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="220.81mm" wi="165.61mm" file="US20230004853A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="225.13mm" wi="159.43mm" orientation="landscape" file="US20230004853A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="227.08mm" wi="169.67mm" file="US20230004853A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="254.85mm" wi="160.27mm" orientation="landscape" file="US20230004853A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="234.78mm" wi="170.69mm" orientation="landscape" file="US20230004853A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="214.88mm" wi="174.92mm" orientation="landscape" file="US20230004853A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="194.06mm" wi="142.41mm" file="US20230004853A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="227.92mm" wi="135.55mm" file="US20230004853A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="235.63mm" wi="151.21mm" file="US20230004853A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">BACKGROUND ART</heading><p id="p-0002" num="0001">Distributed computing platforms, such as in networking products (NP) provided by VMware, Inc., of Palo Alto, Calif. (VMware) include software that allocates computing tasks across group or cluster of distributed software components executed by a plurality of computing devices, enabling large data sets to be processed more quickly than is generally feasible with a single software instance or a single device. Such platforms typically utilize a distributed file system that can support an input/output intensive distributed software component running on a large quantity (e.g., thousands) of computing devices to access large quantity of data. For example, the NP distributed file system, Hadoop distributed file system (HDFS), is typically used in conjunction with NP&#x2014;a data set to be analyzed by NP may be stored in as a large file on HDFS which enables various computing devices running NP software to simultaneously process different portions of the file.</p><p id="p-0003" num="0002">Typically, distributed computing platforms such as NP are configured and provisioned in a &#x201c;native&#x201d; environment, where each &#x201c;node&#x201d; of the cluster corresponds to a physical computing device. In such native environment, where each &#x201c;node&#x201d; of the cluster corresponds to a physical computing device. In such native environments, administrators typically need to manually configure the settings for the distributed computing platform by generating and editing configuration or metadata files that, for example, specify the names and network addresses of the nodes in the cluster , as well as whether any such nodes perform specific functions for the distributed computing platform. More recently, service providers that offer cloud-based Infrastructure-as-a-Service (LaaS) offerings have begun to provide customers with NP frameworks as a &#x201c;Platform-as-a-Service&#x201d; (PaaS).</p><p id="p-0004" num="0003">Such PaaS based NP frameworks however are limited, for example, in their configuration flexibility, reliability and robustness, scalability, quality of service (QoS) and security. These platforms also have the further problem of being able to handle disparate computing endpoints with huge volume of application is a very efficient discoverable manner.</p><p id="p-0005" num="0004">Accurate and comprehensive application awareness (boundary, components, dependencies) is a pre-requisite for effectively driving many data-center operations workflows, including micro-segmentation security planning network troubleshooting, applications performance optimization, application migration.</p><p id="p-0006" num="0005">Manual classification of endpoints (e.g., virtual machines) to applications and tiers is a cumbersome and error-prone process and its quality depends on many factors including proper assignment of attributes (name, tag, etc.) to an endpoint. Besides, to validate such classification, one needs to analyze the network communication pattern among these groups. Also, with the regular influx of new endpoints in the data center, the classification needs to be continually updated. This process is not practical for an environment with thousands of applications.</p><p id="p-0007" num="0006">Automated and continuous discovery of applications (and tiers) addresses these concerns as it requires fewer manual efforts and can dynamically adapt.</p><p id="p-0008" num="0007">The complexity of application discovery increases with the diversity of applications that can exist in a data center. A data center can be comprised of simple as well as relatively complex applications that co-exist and interact with each other. The existence of common services like AD, DNS, etc., complicates the task of identifying application boundaries. <figref idref="DRAWINGS">FIG. <b>1</b></figref> is an example of a topology with applications and common services. In <figref idref="DRAWINGS">FIG. <b>1</b></figref>, each circle represents a virtual or physical endpoint. Different applications and common services groups have been grouped differently to demarcate them properly. As can be seen from the topology shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, it is very difficult to track, monitor and trace where applications exist and what their boundaries are.</p><p id="p-0009" num="0008">Current conventional discoveries to automated discovery suffer from the following drawbacks: (a) any agent-based solution that requires the installation of agents at the hypervisor or operating system level is quite intrusive in nature and can pose security challenges, (b) some of the agentless solutions require pervasive access to all servers in order to execute appropriate commands to collect information related to processes, connections, etc. This is not ideal from a security or performance perspective.</p><p id="p-0010" num="0009">It should also be noted that most computing environments, including virtual network environments are not static. That is, various machines or components are constantly being added to, or removed from, the computer environment. As such changes are made to the computing environment, it is frequently necessary to amend or change which of the various machines or components (virtual and/or physical) are registered with the security system. Further, even in a perfectly laid out network environment, the introduction of components and machines is bound to introduce segmentations and hairpins which affect the performance of the network. These performance problems are more exacerbated in the virtual computing environment with heavy network traffic.</p><p id="p-0011" num="0010">In conventional approaches to discovery and monitoring of services and applications in a computing environment, constant and difficult upgrading of agents is often required. Thus, conventional approaches for application and service discovery and monitoring are not acceptable in complex and frequently revised computing environments.</p><p id="p-0012" num="0011">Additionally, many conventional security systems require every machine or component within a computing environment be assigned to a particular scope and service group so that the intended states can be derived from the service type. As the size and complexity of computing environments increases, such a requirement may require a high-level system administrator to manually register as many as thousands (or many more) of the machines or components (such as, for example, virtual machines) with the security system.</p><p id="p-0013" num="0012">Thus, such conventionally mandated registration of the machines or components is not a trivial job. This burden of manual registration is made even more burdensome considering that the target users of many security systems are often experienced or very high-level personnel such as, for example, Chief Information Security Officers (CISOs) and their teams who already have heavy demands on their time.</p><p id="p-0014" num="0013">Furthermore, even such high-level personnel may not have full knowledge of the network topology of the computing environment or understanding of the functionality of every machine or component within the computing environment. Hence, even when possible, the time and/or person-hours necessary to perform and complete such a conventionally required configuration for a computing system can extend to days, weeks, months or even longer.</p><p id="p-0015" num="0014">Moreover, even when such conventionally required manual registration of the various machines or components is completed, it is not uncommon that entities, including the aforementioned very high-level personnel, have failed to properly assign the proper scopes and services to the various machines or components of the computing environment. Furthermore, in conventional computing systems, it not uncommon to find such improper assignment of scopes and services to the various machines or components of the computing environment, even after a conventional computing system has been operational for years since its initial deployment. As a result, such improper assignment of the scopes and services to the various machines or components of the computing environment may have significantly and deleteriously impacted the accessibility by applications and the overall performance of conventional computing systems even for a prolonged duration.</p><p id="p-0016" num="0015">Furthermore, as stated above, most computing environments, including machine learning environments are not static. That is, various machines or components are constantly being added to, or removed from, the computing environment. As such changes are made to the computing environment, it is necessary to review the changed computing environment and once again assign the proper scopes and services to the various machines or components of the newly changed computing environment. Hence, the aforementioned overhead associated with the assignment of scopes and services to the various machines or components of the computing environment will not only occur at the initial phase when deploying a conventional security system, but such aforementioned overhead may also occur each time the computing environment is expanded, updated, or otherwise altered. This includes instances in which the computing environment is altered, for example, by expanding, updating, or otherwise altering, for example, the roles of machine or components including, but not limited to, virtual machines of the computing environment.</p><p id="p-0017" num="0016">Thus, conventional approaches for providing application discovery in a distributed computing platform with a large number of disparate components and applications of a computing environment, including a machine learning environment, are highly dependent upon the skill and knowledge of a system administrator. Also, conventional approaches for providing learning to machines or components of a computing environment, are not acceptable in complex and frequently revised computing environments.</p><p id="p-0018" num="0017">Furthermore, in many automatic (sometimes referred to as &#x201c;unsupervised&#x201d;) discovery methods, the end result of the discovery method is merely a collection of groups of workloads as applications. In such discovery approaches, the underlying mechanism used to derive the report is often based on what is referred to as an &#x201c;Unsupervised Clustering&#x201d; approach. In some instances, the discovery process ultimately outputs a report of a collection of groups of workloads as applications (herein sometimes referred to as an &#x201c;application/component&#x201d; grouping). Typically, an Unsupervised Clustering-based automatic discovery method does not, and, in fact, cannot, generate an identifier for an unsupervised machine learning based application and the various diverse components operating with the unsupervised machine learning based application. The lack of an identifier becomes increasingly burdensome as multiple &#x201c;runs&#x201d; are made to discover (or rediscover) the &#x201c;application/component&#x201d; grouping. Further exacerbating the issue is the fact that many of the application/component groupings are dynamic and frequently altered over time.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0002" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0019" num="0018">The accompanying drawings, which are incorporated in and form a part of this specification, illustrate embodiments of the present technology and, together with the description, serve to explain the principles of the present technology.</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>1</b></figref> shows an example of a conventional data center application topology with common services;</p><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. <b>2</b></figref> shows an example computer system upon which embodiments of the present invention can be implemented, in accordance with an embodiment of the present invention</p><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a block diagram of an exemplary virtual computing network environment, in accordance with an embodiment of the present invention</p><p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. <b>4</b>A</figref> is a high-level block diagram showing an example of work-flow approach of one embodiment of the present invention.</p><p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. <b>4</b>B</figref> is a high-level block diagram of a software-defined network in accordance with one embodiment of the present invention.</p><p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a block diagram showing an example of different functions of the machine learning based application discovery method of one embodiment, in accordance with an embodiment of the present invention.</p><p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a flow diagram of one embodiment of the application discovery method, in accordance with an embodiment of the present invention.</p><p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a topology diagram of an example of an application cluster detected in applying the application discovery method, in accordance with an embodiment of the present invention.</p><p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a topology diagram of an exemplary multi-tiered application discovery for a virtual computing network environment, in accordance with an embodiment of the present invention.</p><p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a block diagram of an exemplary virtual computing network environment, in accordance with an embodiment of the present invention</p><p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a flow diagram of one embodiment of the present persistent unique identifier method, in accordance with an embodiment of the present invention.</p><p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. <b>11</b></figref> is a flow diagram of another embodiment of the present persistent unique identifier method, in accordance with an embodiment of the present invention.</p><p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. <b>12</b></figref> is a flow diagram of still another embodiment of the present persistent unique identifier method, in accordance with an embodiment of the present invention.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><p id="p-0033" num="0032">The drawings referred to in this description should not be understood as being drawn to scale except if specifically noted.</p><heading id="h-0003" level="1">DETAILED DESCRIPTION OF EMBODIMENTS</heading><p id="p-0034" num="0033">Reference will now be made in detail to various embodiments of the present technology, examples of which are illustrated in the accompanying drawings. While the present technology will be described in conjunction with these embodiments, it will be understood that they are not intended to limit the present technology to these embodiments. On the contrary, the present technology is intended to cover alternatives, modifications and equivalents, which may be included within the spirit and scope of the present technology as defined by the appended claims. Furthermore, in the following description of the present technology, numerous specific details are set forth in order to provide a thorough understanding of the present technology. In other instances, well-known methods, procedures, components, and circuits have not been described in detail as not to unnecessarily obscure aspects of the present technology.</p><heading id="h-0004" level="1">Notation and Nomenclature</heading><p id="p-0035" num="0034">Some portions of the detailed descriptions which follow are presented in terms of procedures, logic blocks, processing and other symbolic representations of operations on data bits within a computer memory. These descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. In the present application, a procedure, logic block, process, or the like, is conceived to be one or more self-consistent procedures or instructions leading to a desired result. The procedures are those requiring physical manipulations of physical quantities. Usually, although not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared, and otherwise manipulated in an electronic device.</p><p id="p-0036" num="0035">It should be borne in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussions, it is appreciated that throughout the description of embodiments, discussions utilizing terms such as &#x201c;displaying&#x201d;, &#x201c;identifying&#x201d;, &#x201c;generating&#x201d;, &#x201c;deriving&#x201d;, &#x201c;providing,&#x201d; &#x201c;utilizing&#x201d;, &#x201c;determining,&#x201d; or the like, refer to the actions and processes of an electronic computing device or system such as: a host processor, a processor, a memory, a virtual storage area network (VSAN), virtual local area networks (VLANS), a virtualization management server or a virtual machine (VM), among others, of a virtualization infrastructure or a computer system of a distributed computing system, or the like, or a combination thereof. The electronic device manipulates and transforms data, represented as physical (electronic and/or magnetic) quantities within the electronic device's registers and memories, into other data similarly represented as physical quantities within the electronic device's memories or registers or other such information storage, transmission, processing, or display components.</p><p id="p-0037" num="0036">Embodiments described herein may be discussed in the general context of processor-executable instructions residing on some form of non-transitory processor-readable medium, such as program modules, executed by one or more computers or other devices. Generally, program modules include routines, programs, objects, components, data structures, etc., that perform particular tasks or implement particular abstract data types. The functionality of the program modules may be combined or distributed as desired in various embodiments.</p><p id="p-0038" num="0037">In the Figures, a single block may be described as performing a function or functions; however, in actual practice, the function or functions performed by that block may be performed in a single component or across multiple components, and/or may be performed using hardware, using software, or using a combination of hardware and software. To clearly illustrate this interchangeability of hardware and software, various illustrative components, blocks, modules, circuits, and steps have been described generally in terms of their functionality. Whether such functionality is implemented as hardware or software depends upon the particular application and design constraints imposed on the overall system. Skilled artisans may implement the described functionality in varying ways for each particular application, but such implementation decisions should not be interpreted as causing a departure from the scope of the present disclosure. Also, the example mobile electronic device described herein may include components other than those shown, including well-known components.</p><p id="p-0039" num="0038">The techniques described herein may be implemented in hardware, software, firmware, or any combination thereof, unless specifically described as being implemented in a specific manner. Any features described as modules or components may also be implemented together in an integrated logic device or separately as discrete but interoperable logic devices. If implemented in software, the techniques may be realized at least in part by a non-transitory processor-readable storage medium comprising instructions that, when executed, perform one or more of the methods described herein. The non-transitory processor-readable data storage medium may form part of a computer program product, which may include packaging materials.</p><p id="p-0040" num="0039">The non-transitory processor-readable storage medium may comprise random access memory (RAM) such as synchronous dynamic random access memory (SDRAM), read only memory (ROM), non-volatile random access memory (NVRAM), electrically erasable programmable read-only memory (EEPROM), FLASH memory, other known storage media, and the like. The techniques additionally, or alternatively, may be realized at least in part by a processor-readable communication medium that carries or communicates code in the form of instructions or data structures and that can be accessed, read, and/or executed by a computer or other processor.</p><p id="p-0041" num="0040">The various illustrative logical blocks, modules, circuits and instructions described in connection with the embodiments disclosed herein may be executed by one or more processors, such as one or more motion processing units (MPUs), sensor processing units (SPUs), host processor(s) or core(s) thereof, digital signal processors (DSPs), general purpose microprocessors, application specific integrated circuits (ASICs), application specific instruction set processors (ASIPs), field programmable gate arrays (FPGAs), or other equivalent integrated or discrete logic circuitry. The term &#x201c;processor,&#x201d; as used herein may refer to any of the foregoing structures or any other structure suitable for implementation of the techniques described herein. In addition, in some embodiments, the functionality described herein may be provided within dedicated software modules or hardware modules configured as described herein. Also, the techniques could be fully implemented in one or more circuits or logic elements. A general-purpose processor may be a microprocessor, but in the alternative, the processor may be any conventional processor, controller, microcontroller, or state machine. A processor may also be implemented as a combination of computing devices, e.g., a combination of an SPU/MPU and a microprocessor, a plurality of microprocessors, one or more microprocessors in conjunction with an SPU core, MPU core, or any other such configuration.</p><p id="p-0042" num="0041">The following terms will be frequently used throughout the application<ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0042">(a) Tier: A tier is a collection of endpoints based on a certain role (e.g., a tier comprising of database endpoints.</li>        <li id="ul0002-0002" num="0043">(b) Application: An application is a collection of tiers, e.g., a simple application comprising web, app and database tiers;</li>        <li id="ul0002-0003" num="0044">(c) Hosted Port: It is a port exposed by an endpoint by the virtue of hosting a service, e.g., port 443 exposed by endpoints of web tier;</li>        <li id="ul0002-0004" num="0045">(d) Accessed Port: It is the port accessed by an endpoint consuming a service hosted on a server in the datacenter. e.g., port 389 accessed by endpoints consuming LDAP services;</li>        <li id="ul0002-0005" num="0046">(e) Communication Profile: Communication profile of an endpoint is the snapshot of incoming and outgoing connections (including endpoints at other ends) with respect to the endpoint; and</li>        <li id="ul0002-0006" num="0047">(f) Communication Density: For a group of endpoints, the communication density is directly proportional to the degree of connectivity among the nodes of the group.</li>    </ul>    </li></ul></p><heading id="h-0005" level="1">Example Computer System Environment</heading><p id="p-0043" num="0048">With reference now to <figref idref="DRAWINGS">FIG. <b>2</b></figref>, all or portions of some embodiments described herein are composed of computer-readable and computer-executable instructions that reside, for example, in computer-usable/computer-readable storage media of a computer system. That is, <figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates one example of a type of computer (computer system <b>200</b>) that can be used in accordance with or to implement various embodiments which are discussed herein. It is appreciated that computer system <b>200</b> of <figref idref="DRAWINGS">FIG. <b>2</b></figref> is only an example and that embodiments as described herein can operate on or within a number of different computer systems including, but not limited to, general purpose networked computer systems, embedded computer systems, routers, switches, server devices, client devices, various intermediate devices/nodes, standalone computer systems, media centers, handheld computer systems, multi-media devices, virtual machines, virtualization management servers, and the like. Computer system <b>200</b> of <figref idref="DRAWINGS">FIG. <b>3</b></figref> is well adapted to having peripheral tangible computer-readable storage media <b>202</b> such as, for example, an electronic flash memory data storage device, a floppy disc, a compact disc, digital versatile disc, other disc based storage, universal serial bus &#x201c;thumb&#x201d; drive, removable memory card, and the like coupled thereto. The tangible computer-readable storage media is non-transitory in nature.</p><p id="p-0044" num="0049">System <b>200</b> of <figref idref="DRAWINGS">FIG. <b>2</b></figref> includes an address/data bus <b>204</b> for communicating information, and a plurality of processor <b>206</b> coupled with bus <b>204</b> for processing information and instructions. As depicted in <figref idref="DRAWINGS">FIG. <b>2</b></figref>, system <b>200</b> is also well suited to a multi-processor environment in which a plurality of processors <b>206</b> are present. Conversely, system <b>200</b> is also well suited to having a single processor such as, for example, processor <b>206</b>. Processor <b>206</b> may be any of various types of microprocessors. System <b>200</b> also includes data storage features such as a computer usable volatile memory <b>208</b>, e.g., random access memory (RAM), coupled with bus <b>204</b> for storing information and instructions for processor <b>206</b>.</p><p id="p-0045" num="0050">System <b>200</b> also includes computer usable non-volatile memory <b>210</b>, e.g., read only memory (ROM), coupled with bus <b>204</b> for storing static information and instructions for processor <b>206</b>. Also present in system <b>100</b> is a data storage unit <b>212</b> (e.g., a magnetic or optical disc and disc drive) coupled with bus <b>204</b> for storing information and instructions. System <b>200</b> also includes an alphanumeric input device <b>214</b> including alphanumeric and function keys coupled with bus <b>204</b> for communicating information and command selections to one or more of processor <b>206</b>. System <b>200</b> also includes a cursor control device <b>216</b> coupled with bus <b>204</b> for communicating user input information and command selections to one or more of processor <b>206</b>. In one embodiment, system <b>200</b> also includes a display device <b>218</b> coupled with bus <b>204</b> for displaying information.</p><p id="p-0046" num="0051">Referring still to <figref idref="DRAWINGS">FIG. <b>2</b></figref>, display device <b>218</b> of <figref idref="DRAWINGS">FIG. <b>2</b></figref> may be a liquid crystal device (LCD), light emitting diode display (LED) device, cathode ray tube (CRT), plasma display device, a touch screen device, or other display device suitable for creating graphic images and alphanumeric characters recognizable to a user. Cursor control device <b>216</b> allows the computer user to dynamically signal the movement of a visible symbol (cursor) on a display screen of display device <b>218</b> and indicate user selections of selectable items displayed on display device <b>218</b>.</p><p id="p-0047" num="0052">Many implementations of cursor control device <b>216</b> are known in the art including a trackball, mouse, touch pad, touch screen, joystick or special keys on alphanumeric input device <b>214</b> capable of signaling movement of a given direction or manner of displacement. Alternatively, it will be appreciated that a cursor can be directed and/or activated via input from alphanumeric input device <b>214</b> using special keys and key sequence commands. System <b>200</b> is also well suited to having a cursor directed by other means such as, for example, voice commands. In various embodiments, alpha-numeric input device <b>214</b>, cursor control device <b>216</b>, and display device <b>218</b>, or any combination thereof (e.g., user interface selection devices), may collectively operate to provide a graphical user interface (GUI) <b>230</b> under the direction of a processor (e.g., processor <b>206</b>). GUI <b>230</b> allows user to interact with system <b>200</b> through graphical representations presented on display device <b>218</b> by interacting with alpha-numeric input device <b>214</b> and/or cursor control device <b>216</b>.</p><p id="p-0048" num="0053">System <b>200</b> also includes an I/O device <b>220</b> for coupling system <b>200</b> with external entities. For example, in one embodiment, I/O device <b>220</b> is a modem for enabling wired or wireless communications between system <b>200</b> and an external network such as, but not limited to, the Internet.</p><p id="p-0049" num="0054">Referring still to <figref idref="DRAWINGS">FIG. <b>2</b></figref>, various other components are depicted for system <b>200</b>. Specifically, when present, an operating system <b>222</b>, applications <b>224</b>, modules <b>226</b>, and data <b>228</b> are shown as typically residing in one or some combination of computer usable volatile memory <b>208</b> (e.g., RAM), computer usable non-volatile memory <b>210</b> (e.g., ROM), and data storage unit <b>212</b>. In some embodiments, all or portions of various embodiments described herein are stored, for example, as an application <b>224</b> and/or module <b>226</b> in memory locations within RAM <b>208</b>, computer-readable storage media within data storage unit <b>212</b>, peripheral computer-readable storage media <b>202</b>, and/or other tangible computer-readable storage media.</p><heading id="h-0006" level="1">Brief Overview</heading><p id="p-0050" num="0055">First, a brief overview of an embodiment of the present machine learning based application discovery using netflow information invention, is provided below. Various embodiments of the present invention provide a method and system for automated feature selection within a machine learning environment operating with a virtual machine computing network environment.</p><p id="p-0051" num="0056">More specifically, the various embodiments of the present invention provide a novel approach for automatically providing identifying communication patterns between virtual machines (VMs) of different instantiations in a virtual computing network environment to discover applications and tiers of the applications across various components in order to improve access and optimize network traffic by clustering application with a common host in the computing environment. In one embodiment, an IT administrator (or other entity such as, but not limited to, a user/company/organization etc.) registers multiple number of machines or components, such as, for example, virtual machines onto a network system platform, such as, for example, virtual networking products from VMware, Inc. of Palo Alto.</p><p id="p-0052" num="0057">In the present embodiment, the IT administrator is not required to generate agent-based application discovery through any extraneous operating system intrusions of the virtual machines with the corresponding service type or indicate the importance of the particular machine or component. Further, the IT administrator is not required to manually list only those machines or components which the IT administrator feels warrant protection from excessive network traffic utilization. Instead, and as will be described below in detail, in various embodiments, the present invention, will automatically determine which applications and tiers with the associated machines or components are to be monitored by machine learning.</p><p id="p-0053" num="0058">As will also be described below, in various embodiments, the present invention is a computing module which integrated within an application discovery monitoring and optimization system. In various embodiments, the present application discovery and optimization invention, will itself identify application span across multiple diverse virtual machines and determines the associations of these application and clusters the application so that that the application being hosted by a common host are grouped together for easy access and identification after observing the activity by each of the machines or components for a period of time in the computing environment thereby enabling the machines to automatically learn where and how to access these applications and the iterations thereof.</p><p id="p-0054" num="0059">Additionally, for purposes of brevity and clarity, the present application will refer to &#x201c;machines or components&#x201d; of a computing environment. It should be noted that for purposes of the present application, the terms &#x201c;machines or components&#x201d; is intended to encompass physical (e.g., hardware and software based) computing machines, physical components (such as, for example, physical modules or portions of physical computing machines) which comprise such physical computing machines, aggregations or combination of various physical computing machines, aggregations or combinations or various physical components and the like. Further, it should be noted that for purposes of the present application, the terms &#x201c;machines or components&#x201d; is also intended to encompass virtualized (e.g., virtual and software based) computing machines, virtual components (such as, for example, virtual modules or portions of virtual computing machines) which comprise such virtual computing machines, aggregations or combination of various virtual computing machines, aggregations or combinations or various virtual components and the like.</p><p id="p-0055" num="0060">Additionally, for purposes of brevity and clarity, the present application will refer to machines or components of a computing environment. It should be noted that for purposes of the present application, the term &#x201c;computing environment&#x201d; is intended to encompass any computing environment (e.g., a plurality of coupled computing machines or components including, but not limited to, a networked plurality of computing devices, a neural network, a machine learning environment, and the like). Further, in the present application, the computing environment may be comprised of only physical computing machines, only virtualized computing machines, or, more likely, some combination of physical and virtualized computing machines.</p><p id="p-0056" num="0061">Furthermore, again for purposes and brevity and clarity, the following description of the various embodiments of the present invention, will be described as integrated within a machine learning based applications discovery system. Importantly, although the description and examples herein refer to embodiments of the present invention integrated within a machine learning based applications discovery system with, for example, its corresponding set of functions, it should be understood that the embodiments of the present invention are well suited to not being integrated into a machine learning based applications discovery system and operating separately from a machine learning based applications discovery system. Specifically, embodiments of the present invention can be integrated into a system other than a machine learning based applications discovery system.</p><p id="p-0057" num="0062">Embodiments of the present invention can operate as a stand-alone module without requiring integration into another system. In such an embodiment, results from the present invention regarding feature selection and/or the importance of various machines or components of a computing environment can then be provided as desired to a separate system or to an end user such as, for example, an IT administrator.</p><p id="p-0058" num="0063">Importantly, the embodiments of the present machine learning based application discovery invention significantly extend what was previously possible with respect to providing applications monitoring tools for machines or components of a computing environment. Various embodiments of the present machine learning based application discovery invention enable the improved capabilities while reducing reliance upon, for example, an IT administrator, to manually monitor and register various machines or components of a computing environment for applications monitoring and tracking. This contrasts with conventional approaches for providing applications discovery tools to various machines or components of a computing environment which highly dependent upon the skill and knowledge of a system administrator. Thus, embodiments of present network topology optimization invention provide a methodology which extends well beyond what was previously known.</p><p id="p-0059" num="0064">Also, although certain components are depicted in, for example, embodiments of the machine learning based applications discovery invention, it should be understood that, for purposes of clarity and brevity, each of the components may themselves be comprised of numerous modules or macros which are not shown.</p><p id="p-0060" num="0065">Procedures of the present machine learning based automated application discovery invention are performed in conjunction with various computer software and/or hardware components. It is appreciated that in some embodiments, the procedures may be performed in a different order than described above, and that some of the described procedures may not be performed, and/or that one or more additional procedures to those described may be performed. Further some procedures, in various embodiments, are carried out by one or more processors under the control of computer-readable and computer-executable instructions that are stored on non-transitory computer-readable storage media. It is further appreciated that one or more procedures of the present may be implemented in hardware, or a combination of hardware with firmware and/or software.</p><p id="p-0061" num="0066">Hence, the embodiments of the present machine learning based applications discovery invention greatly extend beyond conventional methods for providing application discovery in machines or components of a computing environment. Moreover, embodiments of the present invention amount to significantly more than merely using a computer to provide conventional applications monitoring measures to machines or components of a computing environment. Instead, embodiments of the present invention specifically recite a novel process, necessarily rooted in computer technology, for improving network communication within a virtual computing environment.</p><p id="p-0062" num="0067">Additionally, as will be described in detail below, embodiments of the present invention provide a machine learning based application discovery system including a novel search feature for machines or components (including, but not limited to, virtual machines) of the computing environment. The novel search feature of the present network optimization system enables ends users to readily assign the proper and scopes and services the machines or components of the computing environment, Moreover, the novel search feature of the present applications discovery system enables end users to identify various machines or components (including, but not limited to, virtual machines) similar to given and/or previously identified machines or components (including, but not limited to, virtual machines) when such machines or component satisfy a particular given criteria and are moved within the computing environment. Hence, as will be described in detail below, in embodiments of the present invention,</p><heading id="h-0007" level="1">Continued Detailed Description of Embodiments</heading><p id="p-0063" num="0068">As stated above, feature selection which is also known as &#x201c;variable selection&#x201d;, &#x201c;attribute selection&#x201d; and the like, is an import process of machine learning. The process of feature selection helps to determine which features are most relevant or important to use to create a machine learning model (predictive model).</p><p id="p-0064" num="0069">In embodiments of the present invention, a network topology optimization system such as, for example, provided in virtual machines from VMware, Inc. of Palo Alto, Calif. will utilize a network flow identification method to automatically identify application span across computing components and take remediation steps to improve discovery and access in the computing environment. That is, as will be described in detail below, in embodiments of the present network topology optimization invention, a computing module, such as, for example, the application discovery module <b>299</b> of <figref idref="DRAWINGS">FIG. <b>2</b></figref>, is coupled with a computing environment.</p><p id="p-0065" num="0070">Additionally, it should be understood that in embodiments of the present machine learning based applications discovery module <b>299</b> of <figref idref="DRAWINGS">FIG. <b>2</b></figref> may be integrated with one or more of the various components of <figref idref="DRAWINGS">FIG. <b>2</b></figref>. Application discovery module <b>299</b> then automatically evaluates the various machines or components of the computing environment to determine the importance of various features within the computing environment.</p><p id="p-0066" num="0071">Additionally, in one embodiment, the network optimizer of the present invention, micro-segments the network domain to enhance network traffic</p><p id="p-0067" num="0072">Several selection methodologies are currently utilized in the art of feature selection. The common selection algorithms include three classes: Filter Methods, Wrapper Methods and Embedded Methods. In Filter Methods, scores are assigned to each feature based on a statistical measurement. The features are then ranked by their scores and are either selected to be kept as relevant features or they are deemed to not be relevant features and are removed from or not included in dataset of those features defined as relevant features. One of the most popular algorithms of the Filter Methods classification is the Chi Squared Test. Algorithms in the Wrapper Methods classification consider the selection of a set of features as a search result from the best combinations. One such example from the Wrapper Methods classification is called the &#x201c;recursive feature elimination&#x201d; algorithm. Finally, algorithms in the Embedded Methods classification learn features while the machine learning model is being created, instead of prior to the building of the model. Examples of Embedded Method algorithms include the &#x201c;LASSO&#x201d; algorithm and the &#x201c;Elastic Net&#x201d; algorithm.</p><p id="p-0068" num="0073">Embodiments of the present application discovery invention utilize a statistic model to determine the importance of a particular feature within, for example, a machine learning environment.</p><p id="p-0069" num="0074">With reference now to <figref idref="DRAWINGS">FIG. <b>3</b></figref>, a block diagram of an exemplary virtual network system <b>300</b>, in accordance with one embodiment of the present invention.</p><p id="p-0070" num="0075">Cluster <b>310</b> utilizes a host group <b>310</b> with a first host <b>314</b>A, a second host <b>314</b>B and a third host <b>314</b>C. Each host <b>314</b>A-<b>314</b>C executes one or more VM nodes <b>312</b>A-<b>312</b>F of a distributed computing environment. For example, in the embodiment in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, first host <b>314</b>A executes a first hypervisor <b>311</b>A, a first VM node <b>312</b>A and a second VM node <b>312</b>B, Second host <b>314</b>B executes a second hypervisor <b>311</b>B and VM nodes <b>312</b>C-<b>312</b>D and third host <b>314</b>C executes hypervisor <b>311</b>C and VM nodes <b>312</b>E-<b>312</b>F. Although <figref idref="DRAWINGS">FIG. <b>3</b></figref> depicts only three hosts in host group, it should be recognized that a host group in alternative embodiments may include any quantity of hosts executing any number of VM nodes and hypervisors. As previously discussed in the context of <figref idref="DRAWINGS">FIG. <b>3</b></figref>, VM nodes running in host may execute one or more distributed software components of the distributed computing environment.</p><p id="p-0071" num="0076">VM nodes in hosts <b>310</b> communicate with each other via a network <b>330</b>. For example, the NameNode the functionality of a master VM node may communicate with the Data Node functionality via network <b>330</b> to store, delete, and/or copy a data file using a server filesystem. As depicted in the embodiment in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, cluster <b>300</b> also includes a management device <b>320</b> that is also networked with hosts <b>310</b> via network <b>330</b>. Management device <b>320</b> executes a virtualization management application (e.g., VMware vCenter Server, etc.) and a cluster management application. Virtualization management application monitors and controls hypervisors executed by host <b>310</b>, to instruct such hypervisors to initiate and/or to terminate execution of VMs such as VM nodes. In one embodiment, cluster management application communicates with virtualization management application in order to configure and manage VM nodes in hosts <b>310</b> for use by the distributed computing environment. It should be recognized that in alternative embodiments, virtualization management application and cluster management application may be implemented as one or more VMs running in a host in the IaaS or data center environment or may be a separate computing device.</p><p id="p-0072" num="0077">As further depicted in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, user of the distributed computing environment service may utilize a user interface on a remote client device to communicate with cluster management application in management device. For example, client device may communicate with management device using a wide area network (WAN), the internet, and/or any other network. In one embodiment, the user interface is a web page of a web application component of cluster management application that is rendered in a web browser running on a user's laptop. The user interface may enable a user to provide a cluster size data sets, data processing code and other preferences and configuration information to cluster management in order to launch cluster to perform a data processing job on the provided data sets. It should be recognized, in alternative embodiments, cluster management application may further provide an application programming interface (&#x201c;API&#x201d;) in addition supporting the user interface to enable users to programmatically launch or otherwise access clusters to process data sets. It should further be recognized that cluster management application may provide an interface for an administrator. For example, in one embodiment, an administrator may communicate with cluster management application through a client-side application, in order to configure and manage VM nodes in hosts <b>310</b> for example.</p><p id="p-0073" num="0078">With reference now to <figref idref="DRAWINGS">FIG. <b>4</b>A</figref>, a block diagram of an exemplary work-flow approach <b>400</b> of one embodiment of the machine learning based application discovery invention is shown. The present invention provides an agent-less, vendor agnostic and secure way to discover applications and tiers thereof in a computing environment automatically.</p><p id="p-0074" num="0079">The approach <b>400</b> depicted in <figref idref="DRAWINGS">FIG. <b>4</b></figref> only requires datacenter network flow information and their endpoints (i.e., VMs) in order to affect the machine learning principles of the invention.</p><p id="p-0075" num="0080">Still referring to <figref idref="DRAWINGS">FIG. <b>4</b>A</figref>, the netflow information is provided <b>410</b> to the application discovery engine <b>420</b> for processing. In one embodiment, the flow information is sourced from, for example, NetFlow, vDS IPFix and AWS flow logs. The application discovery engine <b>420</b> processes the input information to generate communication graphs of the various endpoints (C1 . . . Cn) <b>430</b>. The communication graphs are then presented to the tier detection component <b>440</b> where the endpoint communication graph corresponding to a single application are segregated into multiple tiers based on the similarities in the pattern of the hosting and accessed points of the endpoints.</p><p id="p-0076" num="0081">In one embodiment, the machine learning approach is based on the principles that the overlap in terms of communication profile for a pair of endpoints from the same application is greater than that for a pair of endpoints from different application. Also, the communication graph, the degree of connectivity within an application is significantly greater than the degrees of connectivity between two distinct applications. The similarity of the communication profile and degree of connectivity of endpoints can be exploited to perform the effective clustering of endpoints. Based on these principles the discovery engine <b>420</b> utilizes a vector encoding of an endpoint based on the communication patterns with the other endpoints. All endpoints are treated as individual dimensions. The component of the vector in the individual dimension is based on the communication pattern with the corresponding endpoint. In one embodiment, the endpoint could also be treated as a point in the multi-dimensional Euclidean space and coordinates of the point is derived from its vector encoding.</p><p id="p-0077" num="0082">In one embodiment, a set of endpoints which belong to the same application would have the same coordinates values in most of the dimensions whereas the same would not be true for two endpoints of different application. This may be represented by the formula</p><p id="p-0078" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>&#x221a;(<i>x</i><sub>1</sub><i>&#x2212;y</i><sub>1</sub>)<sup>2</sup>+(<i>x</i><sub>2</sub><i>&#x2212;y</i><sub>2</sub>)<sup>2</sup>+. . . +(<i>x</i><sub>n</sub><i>&#x2212;y</i><sub>n</sub>)<sup>2 </sup><?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0079" num="0083">Based on the Euclidean distance metric, the endpoints corresponding to the same application would relatively be in close proximity to each other compared to endpoints of different applications implemented by the present invention. In one embodiment, the identified application endpoints can be coupled to an application by utilizing micro-segmentation rules to exclude other endpoints from the application.</p><p id="p-0080" num="0084">In one embodiment of the invention, the application boundary endpoints locations (but not necessarily requiring knowledge of the corresponding application's location) are used to define a software defined network to enhance, for example, the security of the application or the computing network environment. As shown in <figref idref="DRAWINGS">FIG. <b>4</b>B</figref>, the software-defined network comprises an applications layer <b>470</b>, a control layer <b>480</b> and an infrastructure layer <b>490</b>. The SDN <b>460</b> enables dynamic, programmatic efficient network configuration and management in order to improve network performance and monitoring making it more like a cloud computing than a traditional network management, SDN <b>460</b> is meant to address the fact that the static architecture of traditional networks is decentralized and complex while current networks require more flexibility and easy troubleshooting. SDN <b>460</b> attempts to centralize network intelligence in one network component by disassociating the forwarding process of network packets (data plane) from the routing process (control layer). The control layer consists of one or more controllers which are considered as the brain of SDN <b>460</b> network where the whole intelligence is incorporated.</p><p id="p-0081" num="0085">In SDN <b>460</b>, the network administrator can shape traffic from a centralized control console without having to touch individual switches in the network. The centralized SDN <b>460</b> controllers directs the switches to deliver network services wherever they are needed regardless of the specific connections between a server and devices. The SDN <b>460</b> architecture decouples the network control and forwarding functions enabling the network control to become directly programmable and the underlying infrastructure to be abstracted for applications and network services.</p><p id="p-0082" num="0086">With reference now to <figref idref="DRAWINGS">FIG. <b>5</b></figref>, a block diagram of an exemplary components of one embodiment of the machine learning automated applications discovery <b>299</b> in accordance to an embodiment of the present invention is illustrated. As shown in <figref idref="DRAWINGS">FIG. <b>5</b></figref>, the computing environment <b>500</b> comprises a plurality of private cloud applications source <b>510</b>, public cloud <b>520</b>, flow collection component <b>535</b>, inventory collection component <b>530</b>, 4 Tuple flow information component <b>540</b> and machine learning based applications discovery component <b>550</b>. As shown in <figref idref="DRAWINGS">FIG. <b>5</b></figref>, an embodiment of the present invention goes through multiple processing layers. Each layer has a critical functionality which can be independently implemented and optimized. As shown in <figref idref="DRAWINGS">FIG. <b>5</b></figref>, in one embodiment network flow data is generated from private cloud component <b>510</b> and together with public cloud flow data from public cloud component <b>520</b> and provided to flow collection layer. In one embodiment, the flow collection component <b>535</b> resides in the virtual realize network insight component (vRNI) in a host machine.</p><p id="p-0083" num="0087">The flow layer <b>535</b> collects flows from the private cloud <b>510</b> and public cloud <b>520</b> using, for example, NetFlow and Flow Watcher logs respectively. The flow collection component <b>535</b> also collects VM inventory snapshots. With the help of inventory details, flow tuple information provided by 4 Tuple flow information component <b>540</b> is enriched with workload information. In one embodiment, the vRNI also enriches flows with traffic type information (e.g., for example East-West and North-South based on RFC 1918 Address Allocation for Private Internets).</p><p id="p-0084" num="0088">Still referring to <figref idref="DRAWINGS">FIG. <b>5</b></figref>, machine learner <b>550</b> provides an automated machine learning based application discovery of applications and their related tiers across multiple and, sometimes, diverse computing components. In one embodiment, the machine learner <b>550</b> implements data normalization <b>551</b>, generate disconnected component <b>552</b>, outlier detection of components <b>553</b>, generate clusters <b>554</b> and tier detection <b>555</b>.</p><p id="p-0085" num="0089">The data normalization layer <b>551</b> filters out the flow information provided by flow collection <b>535</b>. In one embodiment, the filtering of the flow data is based on the exclusion of flow data corresponding to Internet traffic and the exclusion of flow data based on user feedback in terms of subnets and port ranges. The data normalizer <b>551</b> optimizes the accuracy and time-complexity of the overall discovery process. Data normalization is important as flow data corresponding to dynamic server port or SSH traffic are not important communications from the perspective of identifying application and tier boundaries. For the user-case of application discovery these communications can be seen as noise data as these don't reveal any useful information about the application topology in the datacenter.</p><p id="p-0086" num="0090">Disconnected component layer <b>552</b> takes normalized flow data as input. A communication graph is built based on the input flow data. In this graph, nodes correspond to endpoints and the directed edges between nodes represent communication between endpoints. Each of the edges in the communication graph can output is annotated with port information as metadata. Construction of the communication graph can output one or more weakly connected components. Each Weakly connected component is considered separately because in general, it would be the case that an application spans across multiple weakly connected components</p><p id="p-0087" num="0091">Still referring to <figref idref="DRAWINGS">FIG. <b>5</b></figref>, outlier detection layer <b>523</b> detects outlier in the input graph. The outlier detection layer <b>553</b> helps determine whether the input communication graph requires further refinement based on the presence of common services. Node representing common services would generally have high in-degree or out-degree in the endpoint communication graph. In one embodiment to detect outlier nodes, a table is created that contains in-degree and out-degree of each node and perform a univariate analysis on in-degree and out-degree of nodes to find outliers using, for example, the MAD algorithm.</p><p id="p-0088" num="0092">The clustering layer <b>554</b> takes endpoint communication graph as input and generates clusters of endpoints. An output cluster would contain the endpoints of similar communication patterns. In one embedment, the cluster layer <b>554</b> includes a connection matrix generation component, a dimension reduction component and a clustering component. The clustering layer <b>554</b> comprise the step of vectorization of endpoints, dimensionality reduction and clusters. In vectoring the endpoints, the adjacency matrix of the endpoint communication graph is created. For N endpoints a N*N adjacency matrix is created. Each row of the matrix corresponding to an endpoint can be seen as the vector representation of that endpoint in N dimension.</p><p id="p-0089" num="0093">In reducing the dimensionality of the endpoints, for large number of endpoints (e.g., N endpoints) a clustering algorithm cannot be performed directly on the N-dimensional representation of endpoints obtained from the vectorization process. So, a PCA based on singular value decomposition to reduce the number of dimensions is used. To choose the optimal number of dimensions the cumulative explained variance ratio is used as a function of the number of dimensions, the optimal number of dimensions should retain 90% of the variance. Using PCA a representation of endpoints in lower dimensional space such that the variance in the reduced dimensional space is maximized.</p><p id="p-0090" num="0094">After the dimensionality reduction, clustering of the datapoints is performed. In one embodiment, two different clustering algorithms may be used. In a first instance, k-means++ algorithm is used to run cluster with random values of initial cluster centers. A Sum of square distances analysis is used to optimize the final set of clusters and the number of iterations to get the final cluster. Even though the running time of k-means++ is better than other clustering algorithms but is does not show good results with noisy data or outliers.</p><p id="p-0091" num="0095">Still with reference to <figref idref="DRAWINGS">FIG. <b>5</b></figref>, the tier detection layer <b>555</b> takes the endpoints communication graph corresponding to a single application as input and then segregates the endpoints within the application into multiple tiers. In this case, the grouping criterion based on similarities in the pattern of hosted and accessed ports, are considered to be part of the same tier, i.e., vectorization of endpoints works a bit differently.</p><p id="p-0092" num="0096">In one embodiment, all parts of an application are retrieved and two tags for each port is created (e.g., for port 442 two tags are created&#x2014;Hosted 443, Accessed: 443). A matrix with the tags created are matrixed as columns. Each row of the matrix would correspond to an endpoint. If an endpoint is hosting port <b>443</b> then the corresponding cell (Hosted: 443) in the matrix is marked as 1 (otherwise 0), similarly, if an endpoint is accessing port 443 then the corresponding cell (Accessed: 443) is marked as 1 (otherwise 0). The columns of the above connection matrix represent the multiple dimensions of the endpoint vector. After that, the dimension reduction algorithm and clustering algorithms are applied to group endpoints within an application across multiple tiers.</p><p id="p-0093" num="0097">Referring now to <figref idref="DRAWINGS">FIG. <b>6</b></figref>, a flow chart of an applications detection workflow process in accordance to one embodiment of the present invention is depicted. As shown at Step <b>610</b> the automated application discovery process starts with the collection of enriched flow data from vRNI and forwards the data to data cleansing step <b>610</b>. At Step <b>610</b>, the flow data is filtered and then passed on to the disconnected component generation step <b>615</b>.</p><p id="p-0094" num="0098">At the disconnected component generation step <b>615</b>, a network communication graph is created based on the input flow data and then produces multiple weakly connected components as output. In one embodiment, for each weakly connected component, an outlier detection is invoked. At outlier detection step <b>620</b>, a check of the existence is made at Step <b>625</b>. If any outliers are detected, processing continues at step <b>630</b> where the data flow presented to the outlier is forwarded to clustering layer and processing continues at step <b>630</b>. If on the other hand, no outliers are detected, processing continues at step <b>640</b> where the data flow presented to the outlier at step <b>630</b> is classified as an application.</p><p id="p-0095" num="0099">At Step <b>630</b>, if the cluster layer finds more than one cluster in the input connected component a determination is made at step <b>635</b> if more than one cluster component is present. If more than one cluster component is present, the information is forwarded to the disconnected component generation at step <b>615</b> for processing. If on the other hand, a single cluster component is detected at step <b>635</b>, the information is forwarded to step <b>640</b> where the connected component information is categorized as an application.</p><p id="p-0096" num="0100">At Step <b>645</b> the application component from step <b>640</b> is processed to be associated with its corresponding tiers.</p><p id="p-0097" num="0101"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is an exemplary topology diagram showing an exemplary communication pattern of a selected set of applications in an exemplary IT computing environment. The computer environment topology depicted in <figref idref="DRAWINGS">FIG. <b>7</b></figref> is based on an exemplary environment in the VMware Software Defined Data Center (SDDC) computing environment. As shown in <figref idref="DRAWINGS">FIG. <b>7</b></figref>, the auto-discovery invention <b>299</b> identifies 5 separate clusters&#x2014;Cluster 1-Cluster 5. Cluster 1 corresponds to Ocpm Staging, Cluster 2 corresponds to Oepm Prod, Cluster 3 correspond to BI Tab, Cluster 4 corresponds to CP Prod and Cluster 5 corresponds to Active Directory application groups. Only one VM of Active Directory (Cluster 5) is shown to keep the virtualization simple.</p><p id="p-0098" num="0102">Based on the application defined by the applications administrator in the computing environment (e.g., VMware's SDDC computing platform), Oepm Staging and Oepm Prod groups should have been part of the same application. However, based on the observed communication patterns, we can see that there are too many communication links within each of these groups but hardly see any communication going across these groups. Hence the present auto-detect component detects Oepm Staging and Oepm Prod groups as two separate applications based on the communication patterns.</p><p id="p-0099" num="0103">Referring now to <figref idref="DRAWINGS">FIG. <b>8</b></figref>, an exemplary applications topology of the application of one embodiment of the auto-detect method in accordance to one embodiment of the present invention is shown. The environment <b>800</b> shown in <figref idref="DRAWINGS">FIG. <b>8</b></figref> depicts the detection and segregation of endpoints in a computing environment. As shown although the endpoints span across multiple tiers for an identified application (e.g., ChangePoint) in the SDDC environment, the endpoints of each tier have the same hosted ports or accessed ports, for example, SQL-1 and SQL-2 are part of the same tier as they are hosting TCP connection on port 1433. Hence the endpoints are segregated and clustered for automatic discovery.</p><p id="p-0100" num="0104">Once again, although various embodiments of the present application discovery invention described herein refer to embodiments of the present invention integrated within a virtual computing system with, for example, its corresponding set of functions, it should be understood that the embodiments of the present invention are well suited to not being integrated into an application discovery system and operating separately from an applications discovery system. Specifically, embodiments of the present invention can be integrated into a system other than a security system. Embodiments of the present invention can operate as a stand-alone module without requiring integration into another system. In such an embodiment, results from the present invention regarding feature selection and/or the importance of various machines or components of a computing environment can then be provided as desired to a separate system or to an end user such as, for example, an IT administrator.</p><p id="p-0101" num="0105">Additionally, embodiments of the present invention provide a machine learning based application discovery system including a novel search feature for machines or components (including, but not limited to, virtual machines) of the computing environment. The novel search feature of the present machine learning based applications discovery system enables ends users to readily assign the proper and scopes and services the machines or components of the computing environment, Moreover, the novel search feature of the present machine learning based application discovery system enables end users to identify various machines or components (including, but not limited to, virtual machines) similar to given and/or previously identified machines or components (including, but not limited to, virtual machines) when such machines or component satisfy a particular given criteria. Hence, in embodiments of the present security system, the novel search feature functions by finding or identifying the &#x201c;siblings&#x201d; of various other machines or components (including, but not limited to, virtual machines) within the computing environment.</p><p id="p-0102" num="0106">In another embodiment of the present invention, a persistent unique identifier is generated for an unsupervised machine learning based application and the diverse components associated with the unsupervised machine learning based application. It should be understood that in many automatic (sometimes referred to as &#x201c;unsupervised&#x201d;) discovery methods, the end result of the discovery method is merely a collection of groups of workloads as applications. In such discovery approaches, the underlying mechanism used to derive the report is often based on what is referred to as an &#x201c;Unsupervised Clustering&#x201d; approach. As mentioned above, in one embodiment, the above-described Flow Based Application Discovery method, while performing a novel, valuable and complex task, will ultimately output a report of a collection of groups of workloads as applications (herein sometimes referred to as an &#x201c;application/component&#x201d; grouping). Typically, an Unsupervised Clustering-based automatic discovery method does not, and, in fact, cannot, generate an identifier for an unsupervised machine learning based application and the various diverse components operating with the unsupervised machine learning based application. The lack of an identifier becomes increasingly burdensome as multiple &#x201c;runs&#x201d; are made to discover (or rediscover) the &#x201c;application/component&#x201d; grouping. Further exacerbating the issue is the fact that many of the application/component groupings are dynamic and frequently altered over time. As will be described in detail below, embodiments of the present invention are able to obtain the previously unreachable goal of receiving only application/component grouping information (from, for example, an Unsupervised Clustering-based automatic discovery method) and yet the present embodiment provides a persistent unique identifier to each of the plurality of unsupervised machine learning based applications (and associated components) to ultimately generate uniquely identified unsupervised machine learning based applications.</p><p id="p-0103" num="0107">For purposes of brevity and clarity, the following discussion will occasionally refer to receiving &#x201c;a machine learning based discovery of a plurality of unsupervised machine learning based applications&#x201d; from the above-described Flow Based Application Discovery method. It should be noted, denote that embodiments of the present invention can operate in conjunction with the above-described any of numerous other discovery methods.</p><p id="p-0104" num="0108">Furthermore, in the same manner as was described above for the Flow Based Discovery method, the present persistent unique identifier invention is a computing module which integrated within an application discovery monitoring and optimization system. In various embodiments, the present persistent unique identifier invention, will span across multiple diverse virtual machines and provide the persistent unique identifier in an environment which is hosted by a common host are grouped together for easy access and identification after observing the activity by each of the machines or components for a period of time in the computing environment thereby enabling the machines to automatically learn where and how to access these applications and the iterations thereof.</p><p id="p-0105" num="0109">Additionally, for purposes of brevity and clarity, the present persistent unique identifier application will refer to &#x201c;machines or components&#x201d; of a computing environment. It should be noted that for purposes of the present application, the terms &#x201c;machines or components&#x201d; is intended to encompass physical (e.g., hardware and software based) computing machines, physical components (such as, for example, physical modules or portions of physical computing machines) which comprise such physical computing machines, aggregations or combination of various physical computing machines, aggregations or combinations or various physical components and the like.</p><p id="p-0106" num="0110">Further, it should be noted that for purposes of the present persistent unique identifier application, the terms &#x201c;machines or components&#x201d; is also intended to encompass virtualized (e.g., virtual and software based) computing machines, virtual components (such as, for example, virtual modules or portions of virtual computing machines) which comprise such virtual computing machines, aggregations or combination of various virtual computing machines, aggregations or combinations or various virtual components and the like.</p><p id="p-0107" num="0111">Additionally, for purposes of brevity and clarity, the present application will refer to machines or components of a computing environment. It should be noted that for purposes of the present application, the term &#x201c;computing environment&#x201d; is intended to encompass any computing environment (e.g., a plurality of coupled computing machines or components including, but not limited to, a networked plurality of computing devices, a neural network, a machine learning environment, and the like). Further, in the present application, the computing environment may be comprised of only physical computing machines, only virtualized computing machines, or, more likely, some combination of physical and virtualized computing machines.</p><p id="p-0108" num="0112">Furthermore, again for purposes and brevity and clarity, the following description of the various embodiments of the present persistent unique identifier invention, will be described as integrated within a machine learning based applications discovery system. Importantly, although the description and examples herein refer to embodiments of the present invention integrated within a machine learning based applications discovery system with, for example, its corresponding set of functions, it should be understood that the embodiments of the present invention are well suited to not being integrated into a machine learning based persistent unique identifier system and operating separately from a machine learning based persistent unique identifier system. Specifically, embodiments of the present invention can be integrated into a system other than a machine learning based persistent unique identifier system.</p><p id="p-0109" num="0113">Embodiments of the present invention can operate as a stand-alone module without requiring integration into another system. In such an embodiment, results from the present persistent unique identifier invention and/or the importance of various machines or components of a computing environment can then be provided as desired to a separate system or to an end user such as, for example, an IT administrator.</p><p id="p-0110" num="0114">Importantly, the embodiments of the present persistent unique identifier invention significantly extend what was previously possible with respect to providing applications monitoring tools for machines or components of a computing environment. Various embodiments of the present persistent unique identifier invention enable the improved capabilities while reducing reliance upon, for example, an IT administrator, to manually monitor and register various machines or components of a computing environment for applications monitoring and tracking. This contrasts with conventional approaches. Thus, embodiments of present persistent unique identifier invention provide a methodology which extends well beyond what was previously known.</p><p id="p-0111" num="0115">Also, although certain components are depicted in, for example, embodiments of the persistent unique identifier invention, it should be understood that, for purposes of clarity and brevity, each of the components may themselves be comprised of numerous modules or macros which are not shown.</p><p id="p-0112" num="0116">Procedures of the present persistent unique identifier invention are performed in conjunction with various computer software and/or hardware components. It is appreciated that in some embodiments, the procedures may be performed in a different order than described above, and that some of the described procedures may not be performed, and/or that one or more additional procedures to those described may be performed. Further some procedures, in various embodiments, are carried out by one or more processors under the control of computer-readable and computer-executable instructions that are stored on non-transitory computer-readable storage media. It is further appreciated that one or more procedures of the present may be implemented in hardware, or a combination of hardware with firmware and/or software.</p><p id="p-0113" num="0117">Hence, the embodiments of the present persistent unique identifier invention greatly extend beyond conventional methods for providing application discovery in machines or components of a computing environment. Moreover, embodiments of the present invention amount to significantly more than merely using a computer to provide conventional applications monitoring measures to machines or components of a computing environment. Instead, embodiments of the present invention specifically recite a novel process, necessarily rooted in computer technology, for improving network communication within a virtual computing environment.</p><p id="p-0114" num="0118">Additionally, as will be described in detail below, embodiments of the present persistent unique identifier invention provide a persistent unique identifier system including novel features (e.g., UUID Determinor and Assignor <b>902</b> of <figref idref="DRAWINGS">FIG. <b>9</b></figref>, and for machines or components (including, but not limited to, virtual machines) of the computing environment. The novel feature of the present persistent unique identifier system enables ends users to readily assign the proper and scopes and services the machines or components of the computing environment, Moreover, the novel search feature of the persistent unique identifier system enables end users to identify various machines or components (including, but not limited to, virtual machines) similar to given and/or previously identified machines or components (including, but not limited to, virtual machines) when such machines or component satisfy a particular given criteria and are moved within the computing environment.</p><heading id="h-0008" level="1">Continued Detailed Description of the present persistent unique identifier Embodiments</heading><p id="p-0115" num="0119">In embodiments of the present invention, a network topology optimization system such as, for example, provided in virtual machines from VMware, Inc. of Palo Alto, Calif. will utilize a persistent unique identifier method to automatically assign such persistent unique identifiers across computing components and thereby improve the computing environment. That is, as will be described in detail below, in embodiments of the present persistent unique identifier invention, a computing module, such as, for example, the UUID Determinor and Assigner <b>902</b> of <figref idref="DRAWINGS">FIG. <b>3</b></figref>, is coupled with a computing environment.</p><p id="p-0116" num="0120">Additionally, it should be understood that in embodiments of the present UUID Determinor and Assigner <b>902</b> of <figref idref="DRAWINGS">FIG. <b>3</b></figref> may be integrated with one or more of the various components of <figref idref="DRAWINGS">FIG. <b>2</b></figref>, <figref idref="DRAWINGS">FIG. <b>3</b></figref> or other Figures.</p><p id="p-0117" num="0121">Embodiments of the present UUID Determinor and Assigner <b>902</b> of <figref idref="DRAWINGS">FIG. <b>3</b></figref> invention utilize a statistic model to determine the importance of a particular feature within, for example, a machine learning environment.</p><p id="p-0118" num="0122">With reference now to <figref idref="DRAWINGS">FIG. <b>3</b></figref>, a block diagram of an exemplary virtual network system <b>300</b>, in accordance with one embodiment of the present invention.</p><p id="p-0119" num="0123">Cluster <b>310</b> utilizes a host group <b>310</b> with a first host <b>314</b>A, a second host <b>314</b>B and a third host <b>314</b>C. Each host <b>314</b>A-<b>314</b>C executes one or more VM nodes <b>312</b>A-<b>312</b>F of a distributed computing environment. For example, in the embodiment in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, first host <b>314</b>A executes a first hypervisor <b>311</b>A, a first VM node <b>312</b>A and a second VM node <b>312</b>B, Second host <b>314</b>B executes a second hypervisor <b>311</b>B and VM nodes <b>312</b>C-<b>312</b>D and third host <b>314</b>C executes hypervisor <b>311</b>C and VM nodes <b>312</b>E-<b>312</b>F. Although <figref idref="DRAWINGS">FIG. <b>3</b></figref> depicts only three hosts in host group, it should be recognized that a host group in alternative embodiments may include any quantity of hosts executing any number of VM nodes and hypervisors. As previously discussed in the context of <figref idref="DRAWINGS">FIG. <b>3</b></figref>, VM nodes running in host may execute one or more distributed software components of the distributed computing environment.</p><p id="p-0120" num="0124">VM nodes in hosts <b>310</b> communicate with each other via a network <b>330</b>. For example, the NameNode the functionality of a master VM node may communicate with the Data Node functionality via network <b>330</b> to store, delete, and/or copy a data file using a server filesystem. As depicted in the embodiment in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, cluster <b>300</b> also includes a management device <b>320</b> that is also networked with hosts <b>310</b> via network <b>330</b>. Management device <b>320</b> executes a virtualization management application (e.g., VMware vCenter Server, etc.) and a cluster management application. Virtualization management application monitors and controls hypervisors executed by host <b>310</b>, to instruct such hypervisors to initiate and/or to terminate execution of VMs such as VM nodes. In one embodiment, cluster management application communicates with virtualization management application in order to configure and manage VM nodes in hosts <b>310</b> for use by the distributed computing environment. It should be recognized that in alternative embodiments, virtualization management application and cluster management application may be implemented as one or more VMs running in a host in the laaS or data center environment or may be a separate computing device.</p><p id="p-0121" num="0125">As further depicted in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, user of the distributed computing environment service may utilize a user interface on a remote client device to communicate with cluster management application in management device. For example, client device may communicate with management device using a wide area network (WAN), the internet, and/or any other network. In one embodiment, the user interface is a web page of a web application component of cluster management application that is rendered in a web browser running on a user's laptop. The user interface may enable a user to provide a cluster size data sets, data processing code and other preferences and configuration information to cluster management in order to launch cluster to perform a data processing job on the provided data sets. It should be recognized, in alternative embodiments, cluster management application may further provide an application programming interface (&#x201c;API&#x201d;) in addition supporting the user interface to enable users to programmatically launch or otherwise access clusters to process data sets. It should further be recognized that cluster management application may provide an interface for an administrator. For example, in one embodiment, an administrator may communicate with cluster management application through a client-side application, in order to configure and manage VM nodes in hosts <b>310</b> for example.</p><p id="p-0122" num="0126">Referring now to <figref idref="DRAWINGS">FIG. <b>9</b></figref>, in some embodiments of the present invention, operations of the present persistent unique identifier embodiment are operating with each of the uniquely identified unsupervised machine learning based applications. As stated above, there remains a problem with correlating a group of VMs across multiple runs. It is important to have a notion of identity for an application as there are many important use-cases that depend on it. Some of the example of such use-cases are: 1) Change Notification:&#x2014;Identify and report what new members have been added to an application or what members have been removed from an application. This can help an application owner to visualize how the membership of applications has changed over time. 2) Analytics:&#x2014;A system like vRNI provides the capability to configure thresholds and receive alerts based on aberration in the behavior of entities like Application, Tier, Security Group, etc.</p><p id="p-0123" num="0127">For the above scenario and analysis to work, it is required that identity and changes in applications are maintained across multiple runs. One cannot afford to delete existing applications every time and create new set of applications, as the system would not be able to preserve the analysis done at the level of Application/Tier.</p><p id="p-0124" num="0128">Referring now to <figref idref="DRAWINGS">FIG. <b>10</b></figref>, in one approach, as depicted by flow chart <b>1000</b>, at <b>1002</b>, an embodiment of the present computer-implemented method for assigning an identity to a plurality of unsupervised machine learning based applications operating in a computing environment begins by receiving a machine learning based discovery of a plurality of unsupervised machine learning based applications spanning across a plurality of diverse components in a computing environment.</p><p id="p-0125" num="0129">At <b>1004</b>, an embodiment of the present computer-implemented method for assigning an identity to a plurality of unsupervised machine learning based applications operating in a computing environment assigns a persistent unique identifier to each of the plurality of unsupervised machine learning based applications.</p><p id="p-0126" num="0130">At <b>1006</b>, the embodiment of <figref idref="DRAWINGS">FIG. <b>10</b></figref> an embodiment of the present computer-implemented method for assigning an identity to a plurality of unsupervised machine learning based applications operating in a computing environment determines which of the plurality of diverse components in the computing environment is operating with each of the plurality of unsupervised machine learning based applications. Details of the embodiment of <figref idref="DRAWINGS">FIG. <b>10</b></figref> are provided below.</p><p id="p-0127" num="0131">Similarly, referring now to <figref idref="DRAWINGS">FIG. <b>11</b></figref>, in one approach, as depicted by flow chart <b>1100</b>, at <b>1102</b>, an embodiment of the present computer-implemented method for assigning an identity to a plurality of unsupervised machine learning based applications operating in a computing environment begins by receiving a machine learning based discovery of a plurality of unsupervised machine learning based applications spanning across a plurality of diverse components in a computing environment.</p><p id="p-0128" num="0132">At <b>1104</b>, at a first time, an embodiment of the present computer-implemented method for assigning an identity to a plurality of unsupervised machine learning based applications operating in a computing environment assigns a persistent unique identifier to each of the plurality of unsupervised machine learning based applications to generate a first plurality of uniquely identified unsupervised machine learning based applications.</p><p id="p-0129" num="0133">At <b>1106</b>, the present embodiment then determines which of the first plurality of diverse components in the computing environment is operating with each of the uniquely identified unsupervised machine learning based applications, at the first time, to obtain a first application/component grouping for each of said first plurality of uniquely identified unsupervised machine learning based applications, and such that each of the first application/component grouping is associated with a respective persistent unique identifier.</p><p id="p-0130" num="0134">Next, at <b>1108</b>, at a second time subsequent to the first time, an embodiment of the present computer-implemented method for assigning an identity to a plurality of unsupervised machine learning based applications operating in a computing environment determines which of a second plurality of diverse components in the computing environment is operating with each of the first uniquely identified unsupervised machine learning based applications at the second time to obtain a second application/component grouping for each of the first plurality of uniquely identified unsupervised machine learning based applications.</p><p id="p-0131" num="0135">At <b>1110</b>, an embodiment of the present computer-implemented method for assigning an identity to a plurality of unsupervised machine learning based applications operating in a computing environment compares the first application/component grouping with the second application/component grouping (see below discussion).</p><p id="p-0132" num="0136">At <b>1112</b>, in an embodiment of the present computer-implemented method for assigning an identity to a plurality of unsupervised machine learning based applications operating in a computing environment, provided a sufficient similarity exists between the first application/component grouping and the second application/component grouping, the present computer-implemented method for assigning an identity to a plurality of unsupervised machine learning based applications assigns the persistent unique identifier associated with the first application/component grouping to the second application/component grouping.</p><p id="p-0133" num="0137">With reference now to <figref idref="DRAWINGS">FIG. <b>12</b></figref>, in one approach, as depicted by flow chart <b>1200</b>, operations <b>1202</b>, <b>1204</b> and <b>1206</b> recite processes of the above-described Flow Based Discovery method which, in the embodiment of <figref idref="DRAWINGS">FIG. <b>12</b></figref>, is used in conjunction with the present computer-implemented method for assigning an identity to a plurality of unsupervised machine learning based applications operating in a computing environment.</p><p id="p-0134" num="0138">At <b>1208</b>, an embodiment of the present computer-implemented method for assigning an identity to a plurality of unsupervised machine learning based applications operating in a computing environment receives a machine learning based discovery of a plurality of unsupervised machine learning based applications spanning across a plurality of diverse components in a computing environment.</p><p id="p-0135" num="0139">At <b>1210</b>, at a first time, an embodiment of the present computer-implemented method for assigning an identity to a plurality of unsupervised machine learning based applications operating in a computing environment assigns a persistent unique identifier to each of the plurality of unsupervised machine learning based applications to generate a first plurality of uniquely identified unsupervised machine learning based applications.</p><p id="p-0136" num="0140">At <b>1212</b>, the present embodiment then determines which of the first plurality of diverse components in the computing environment is operating with each of the uniquely identified unsupervised machine learning based applications, at the first time, to obtain a first application/component grouping for each of the first plurality of uniquely identified unsupervised machine learning based applications, and such that each of the first application/component grouping is associated with a respective persistent unique identifier.</p><p id="p-0137" num="0141">Next, at <b>1214</b>, at a second time subsequent to the first time, an embodiment of the present computer-implemented method for assigning an identity to a plurality of unsupervised machine learning based applications operating in a computing environment determines which of a second plurality of diverse components in the computing environment is operating with each of the first uniquely identified unsupervised machine learning based applications at the second time to obtain a second application/component grouping for each of the first plurality of uniquely identified unsupervised machine learning based applications.</p><p id="p-0138" num="0142">At <b>1216</b>, an embodiment of the present computer-implemented method for assigning an identity to a plurality of unsupervised machine learning based applications operating in a computing environment compares the first application/component grouping with the second application/component grouping (see below discussion).</p><p id="p-0139" num="0143">At <b>1218</b>, in an embodiment of the present computer-implemented method for assigning an identity to a plurality of unsupervised machine learning based applications operating in a computing environment, provided a sufficient similarity exists between the first application/component grouping and the second application/component grouping, the present computer-implemented method for assigning an identity to a plurality of unsupervised machine learning based applications assigns the persistent unique identifier associated with the first application/component grouping to the second application/component grouping.</p><p id="p-0140" num="0144">The following discussion provides various details pertaining to the steps described above in conjunction with <figref idref="DRAWINGS">FIGS. <b>10</b>-<b>12</b></figref> for the present embodiments to assign a unique identifier to Application Groups (also referred to herein as &#x201c;application/component groupings&#x201d; which is persistent across time.</p><p id="p-0141" num="0145">At time t=T (0), when the very first set of Application Groups are reported (i.e. received by the present persistent unique identifier invention) (e.g., a new identifier is generated (using uuid.uuid1( )._str_( )(in Python)) and assigned to each of the plurality of unsupervised machine learning based applications (Application Group).</p><p id="p-0142" num="0146">At time t=T(n), the following scenario occurs. There are some existing sets (pluralities) of unsupervised machine learning based applications which now have a persistent unique identifier assigned to them. In one embodiment of the present persistent unique identifier invention, the existing set of unsupervised machine learning based applications and the corresponding diverse components associated with any particular unsupervised machine learning based application is recorded and additionally indicates which of the diverse components is associated with the now &#x201c;uniquely identified unsupervised machine learning based application&#x201d;. An example of the codification of such an embodiment is provided below.</p><p id="p-0143" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>a) EXISTING_APP1 - {</entry></row><row><entry>&#x201c;members&#x201d;: [&#x2033;vm1&#x2033;, &#x2033;vm2&#x2033;, &#x2033;vm3&#x2033;, &#x2033;vm4&#x2033;],</entry></row><row><entry>&#x201c;uid&#x201d;: &#x2033;uid1&#x2033;</entry></row><row><entry>}</entry></row><row><entry>b) EXISTING_APP2 - {</entry></row><row><entry>&#x201c;members&#x201d;: [&#x2033;vm11&#x2033;, &#x2033;vm12&#x2033;, &#x2033;vm13&#x2033;, &#x2033;vm14&#x2033;]</entry></row><row><entry>&#x201c;uid&#x201d;: &#x2033;uid2&#x2033;</entry></row><row><entry>}</entry></row><row><entry>c) EXISTING_APP3 - {</entry></row><row><entry>&#x201c;members&#x201d;: [&#x2033;vm21&#x2033;, &#x2033;vm22&#x2033;, &#x2033;vm23&#x2033;]</entry></row><row><entry>&#x201c;uid&#x201d;: &#x2033;uid3&#x2033;</entry></row><row><entry>d) EXISTING_APP4 - {</entry></row><row><entry>&#x201c;members&#x201d;: [&#x2033;vm31&#x2033;, &#x2033;vm32&#x2033;, &#x2033;vm33&#x2033;, &#x2033;vm34&#x2033;, &#x2033;vm35&#x2033;] &#x201c;uid&#x201d;: &#x2033;uid4&#x2033;</entry></row><row><entry>}</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0144" num="0000"><tables id="TABLE-US-00002" num="00002"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="21pt" align="left"/><colspec colname="1" colwidth="196pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>a) NEW_APP1 - {</entry></row><row><entry/><entry>&#x2002;&#x201c;members&#x201d;: [&#x2033;vm11&#x2033;, &#x2033;vm12&#x2033;, &#x2033;vm13&#x2033;]</entry></row><row><entry/><entry>&#x2002;&#x201c;uid&#x201d;: None</entry></row><row><entry/><entry>}</entry></row><row><entry/><entry>b) NEW_APP2 - {</entry></row><row><entry/><entry>&#x2002;&#x201c;members&#x201d;: [&#x2033;vm21&#x2033;, &#x2033;vm22&#x2033;, &#x2033;vm23&#x2033;]</entry></row><row><entry/><entry>&#x2002;&#x201c;uid&#x201d;: None</entry></row><row><entry/><entry>}</entry></row><row><entry/><entry>c) NEW_APP3 - {</entry></row><row><entry/><entry>&#x2002;&#x201c;members&#x201d;: [&#x2033;vm1&#x2033;, &#x2033;vm2&#x2033;, &#x2033;vm3&#x2033;, &#x2033;vm4&#x2033;, &#x2033;vm5&#x2033;]</entry></row><row><entry/><entry>&#x2002;&#x201c;uid&#x201d;: None</entry></row><row><entry/><entry>}</entry></row><row><entry/><entry>d) NEW_APP4 - {</entry></row><row><entry/><entry>&#x2002;&#x201c;members&#x201d;: [&#x2033;vm31&#x2033;, &#x2033;vm32&#x2033;, &#x2033;vm33&#x2033;, &#x2033;vm34&#x2033;, &#x2033;vm35&#x2033;]</entry></row><row><entry/><entry>&#x2002;&#x201c;uid&#x201d;: None</entry></row><row><entry/><entry>}</entry></row><row><entry/><entry>e) NEW_APP5 - {</entry></row><row><entry/><entry>&#x2002;&#x201c;members&#x201d;: [&#x2033;vm51&#x2033;, &#x2033;vm52&#x2033;, &#x2033;vm53&#x2033;, &#x2033;vm54&#x2033;, &#x2033;vm55&#x2033;]</entry></row><row><entry/><entry>&#x2002;&#x201c;uid&#x201d;: None</entry></row><row><entry/><entry>}</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0145" num="0147">Next, at a second time subsequent to the first time, the present persistent unique identifier invention determining which of a second plurality of diverse components in the computing environment is operating with each of the first uniquely identified unsupervised machine learning based applications to obtain a second application/component grouping for each of the first plurality of uniquely identified unsupervised machine learning based applications.</p><p id="p-0146" num="0148">It will be understood that any of a myriad of changes may have occurred with respect to the diverse components. As just a few examples, the present persistent unique identifier invention may discover that the existing uniquely identified applications discovered from the previous run have only minor updates or no updates with respect to the diverse components associated therewith. The present persistent unique identifier invention may discover that the various diverse components have now been split into smaller groups. The present persistent unique identifier invention may discover that two or more application/component groupings have been merged into a larger group. The present persistent unique identifier invention may discover new application/component groupings. Additionally, the present persistent unique identifier invention may actually discover that some of the application/component groupings have been deleted.</p><p id="p-0147" num="0149">Thus, the present persistent unique identifier invention will then compare the findings from the second run with the findings obtained during the first run. Provided a sufficient similarity exists between the first application/component grouping and the second application/component grouping, the present persistent unique identifier invention will assign the persistent unique identifier associated with the first application/component grouping to the second application/component grouping. Thus, the second application/component grouping &#x201c;inherits&#x201d; the persistent unique identifier associated with the first application/component grouping.</p><p id="p-0148" num="0150">In various embodiments of the present persistent unique identifier invention a stable marriage algorithm (see, e.g., https://en.wikipedia.org/wiki/Stable_marriage_problem):</p><p id="p-0149" num="0151">In some embodiments, the present persistent unique identifier invention, for each new application/component grouping, will iterate over all the existing application/components groupings and create a preference list of existing application/component groupings based on how well the new application/component grouping matches to the existing application/component grouping.</p><p id="p-0150" num="0152">Embodiments of the present persistent unique identifier invention identifies which of the existing application/component groupings best matches with the new application/component grouping. In one embodiment of the present persistent unique identifier invention for two application/component groupings, an F-1 score is calculated to represent the degree of matching.<ul id="ul0003" list-style="none">    <li id="ul0003-0001" num="0000">    <ul id="ul0004" list-style="none">        <li id="ul0004-0001" num="0153">F-1 score=2*precision*recall/(precision+recall).</li>        <li id="ul0004-0002" num="0154">Precision=True Positive/(True Positive+False Positive).</li>        <li id="ul0004-0003" num="0155">Recall=True Positive/(True Positive+False Negative).</li>    </ul>    </li></ul></p><p id="p-0151" num="0156">In the above example, the present persistent unique identifier invention, takes True Positive value as the size of intersection between the members of the new application/component grouping and the existing application/component grouping.</p><p id="p-0152" num="0157">Further, in the above example, the present persistent unique identifier invention defines False Positive value as the number of members in the new application/component grouping which are not part of the given existing application/component grouping, so this is the size of Set difference of old application/component grouping and new application/component grouping.</p><p id="p-0153" num="0158">The False Negative value is the number of members in the existing application/component grouping which are not part of the new application/component grouping, so this is the size of Set difference of the existing application/component grouping and new application/component grouping.</p><p id="p-0154" num="0159">Further, in embodiments of the present persistent unique identifier invention, using the above defined values for True Positive, False Positive and False Negative, the present invention computes Precision, Recall and F-1 score value.</p><p id="p-0155" num="0160">In the various embodiments, once the F-1 score is computed for all of the pairs of new and existing application/component groupings, then for each of the new application/component groupings, the preference list is computed by sorting the existing application/component groupings in decreasing order of F-1 score.</p><p id="p-0156" num="0161">In various embodiments of the present persistent unique identifier invention, such operations can be repeated from the perspective of existing application/component groupings to create the preference list from the perspective of existing application/component groupings.</p><p id="p-0157" num="0162">In various embodiments of the present persistent unique identifier invention, the preference list for the existing Application/component groupings and the new Application/component groupings is maintained in the following two maps: existingAppPreferenceMap&#x2014;This map has each of the existing application/component groupings as key and a list of new application/component groupings sorted in decreasing order of F-1 score as value; and newAppPreferenceMap&#x2014;This map has each of the new application/component groupings as key and a list of existing application/component groupings sorted in decreasing order of F-1 score as value.</p><p id="p-0158" num="0163">Once the preference list is ready, various embodiments of the present persistent unique identifier invention execute the following algorithm to get the mapping of new application/component groupings to existing application/component groupings and use this mapping to assign the identity to the new application/component grouping:<ul id="ul0005" list-style="none">    <li id="ul0005-0001" num="0000">    <ul id="ul0006" list-style="none">        <li id="ul0006-0001" num="0164">a) Initialize a Map newAppMatching with New Application Groups as keys and None as value.</li>        <li id="ul0006-0002" num="0165">b) Initialize a Map existingAppMatching with Existing Application/component groupings as keys and None as value.</li>        <li id="ul0006-0003" num="0166">c) Algorithm to generate Application matching:</li>    </ul>    </li></ul></p><p id="p-0159" num="0000"><tables id="TABLE-US-00003" num="00003"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;&#x2003;&#x2003;/** Flag to track convergence of the algorithm, and how long to</entry></row><row><entry>continue, it is set to true if in one run of the loop a new matching is identified (by</entry></row><row><entry>matching an Unmatched Application/component grouping/ Breaking existing</entry></row><row><entry>matching and creating new matching) */</entry></row><row><entry>&#x2003;&#x2003;&#x2003;Boolean continueProcessing = True</entry></row><row><entry>&#x2003;&#x2003;&#x2003;while (continueProcessing is True) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;// set as false so in case no new matching is created then there is no</entry></row><row><entry>need to loop any longer as stable matching has been achieved</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;continueProcessing = False</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2002;for existingApp in existingAppMatching:</entry></row><row><entry>&#x2003;if existingAppMatching [existingApp] is None:</entry></row><row><entry>&#x2003;&#x2003;existingAppPreferenceList = existingAppPreferenceMap[existingApp]</entry></row><row><entry>&#x2003;&#x2003;for preferredApp in existingAppPreferenceList:</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if (newAppMatching [preferredApp] is None):</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2002;newAppMatching [preferredApp] = existingApp</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2002;existingAppMatching [existingApp] = preferredApp</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2002;continueProcessing = True // set as true as new matching has</entry></row><row><entry>&#x2003;&#x2003;&#x2003;been created</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2002;break</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;else:</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2002;currentMatch = newAppMatching[preferredApp]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if preferredApp prefers existingApp over currentMatch:</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2002;newAppMatching [preferredApp] = existingApp</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;existingAppMatching [currentMatch] = null</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;existingAppMatching [existingApp]= preferredApp</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;process = True // set as true new matching has been created</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;break</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;&#x2003;return newAppMatching</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0160" num="0167">In various embodiments of the present persistent unique identifier invention, in newAppMatching if there are application/component groupings with no matches, they are treated as new application/component groupings and these application/component groupings are created in the system with new persistent unique identifiers assigned to them. Otherwise, embodiments of the present persistent unique identifier invention analyze the reported matching and if the F-1 score for the reported matching is beyond a threshold value (0.5) then the new application/component grouping is identified as the corresponding existing application/component grouping and consequently inherits the identity of the existing application/component grouping, and the membership of the existing application/component grouping is modified as per the corresponding new component members.</p><p id="p-0161" num="0168">Furthermore, In various embodiments of the present persistent unique identifier invention, where there is some difference between the new application/component grouping and the existing application/component grouping, such differences, in one embodiment, are then reported for analytic purposes. Hence, embodiments of the present persistent unique identifier invention enable troubleshooting, analytics, and time series data evaluations.</p><p id="p-0162" num="0169">The examples set forth herein were presented in order to best explain, to describe particular applications, and to thereby enable those skilled in the art to make and use embodiments of the described examples. However, those skilled in the art will recognize that the foregoing description and examples have been presented for the purposes of illustration and example only. The description as set forth is not intended to be exhaustive or to limit the embodiments to the precise form disclosed. Rather, the specific features and acts described above are disclosed as example forms of implementing the Claims.</p><p id="p-0163" num="0170">Reference throughout this document to &#x201c;one embodiment,&#x201d; &#x201c;certain embodiments,&#x201d; &#x201c;an embodiment,&#x201d; &#x201c;various embodiments,&#x201d; &#x201c;some embodiments,&#x201d; &#x201c;various embodiments&#x201d;, or similar term, means that a particular feature, structure, or characteristic described in connection with that embodiment is included in at least one embodiment. Thus, the appearances of such phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore, the particular features, structures, or characteristics of any embodiment may be combined in any suitable manner with one or more other features, structures, or characteristics of one or more other embodiments without limitation.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A computer-implemented method for assigning an identity to a plurality of unsupervised machine learning based applications operating in a computing environment, said method comprising:<claim-text>receiving a machine learning based discovery of said plurality of unsupervised machine learning based applications spanning across a plurality of diverse components in said computing environment;</claim-text><claim-text>assigning a persistent unique identifier to each of said plurality of unsupervised machine learning based applications; and</claim-text><claim-text>determining which of said plurality of diverse components in said computing environment is operating with each of said plurality of unsupervised machine learning based applications.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The computer-implemented method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said computing environment is a virtualized computing environment.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The computer-implemented method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said plurality of diverse components comprising said computing environment are comprised of virtualized components and physical components.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. A computer-implemented method for assigning an identity to a plurality of unsupervised machine learning based applications operating in a computing environment, said method comprising:<claim-text>receiving a machine learning based discovery of said plurality of unsupervised machine learning based applications spanning across a first plurality of diverse components in said computing environment;</claim-text><claim-text>at a first time, assigning a persistent unique identifier to each of said plurality of unsupervised machine learning based applications to generate a first plurality of uniquely identified unsupervised machine learning based applications;</claim-text><claim-text>determining which of said first plurality of diverse components in said computing environment is operating with each of said uniquely identified unsupervised machine learning based applications, at said first time, to obtain a first application/component grouping for each of said first plurality of uniquely identified unsupervised machine learning based applications, and such that each of said first application/component grouping is associated with a respective said persistent unique identifier;</claim-text><claim-text>at a second time subsequent to said first time, determining which of a second plurality of diverse components in said computing environment is operating with each of said first uniquely identified unsupervised machine learning based applications at said second time to obtain a second application/component grouping for each of said first plurality of uniquely identified unsupervised machine learning based applications;</claim-text><claim-text>comparing said first application/component grouping with said second application/component grouping; and</claim-text><claim-text>provided a sufficient similarity exists between said first application/component grouping and said second application/component grouping, assigning said persistent unique identifier associated with said first application/component grouping to said second application/component grouping.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The computer-implemented method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein, provided a sufficient similarity does not exist between said first application/component grouping and said second application/component grouping, assigning a new persistent unique identifier to said second application/component grouping.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The computer-implemented method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein, said comparing said first application/component grouping with said second application/component grouping is performed using a stable marriage method.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The computer-implemented method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, further comprising:<claim-text>provided a difference exists between said first application/component grouping and said second application/component grouping, recording said difference for analytic purposes.</claim-text></claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The computer-implemented method of <claim-ref idref="CLM-00007">claim 7</claim-ref>, further comprising:<claim-text>reporting said difference to a management device for performing said analytic purposes.</claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The computer-implemented method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein said computing environment is a virtualized computing environment.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The computer-implemented method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein said plurality of diverse components comprising said computing environment are comprised of virtualized components and physical components.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. A computer-implemented method for automated application discovery and for assigning an identity to a plurality of unsupervised machine learning based applications operating in a computing environment, said method comprising:<claim-text>automatically monitoring communications between a plurality of diverse components in said computing environment;</claim-text><claim-text>generating network flow information in relation to said plurality of diverse components in said computing environment;</claim-text><claim-text>performing a machine learning based discovery of said plurality of unsupervised machine learning based applications spanning across said plurality of diverse components in said computing environment;</claim-text><claim-text>receiving said machine learning based discovery of said plurality of unsupervised machine learning based applications spanning across said first plurality of diverse components in said computing environment;</claim-text><claim-text>at a first time, assigning a persistent unique identifier to each of said plurality of unsupervised machine learning based applications to generate a first plurality of uniquely identified unsupervised machine learning based applications;</claim-text><claim-text>determining which of said first plurality of diverse components in said computing environment is operating with each of said uniquely identified unsupervised machine learning based applications, at said first time, to obtain a first application/component grouping for each of said first plurality of uniquely identified unsupervised machine learning based applications, and such that each of said first application/component grouping is associated with a respective said persistent unique identifier;</claim-text><claim-text>at a second time subsequent to said first time, determining which of a second plurality of diverse components in said computing environment is operating with each of said first uniquely identified unsupervised machine learning based applications at said second time to obtain a second application/component grouping for each of said first plurality of uniquely identified unsupervised machine learning based applications;</claim-text><claim-text>comparing said first application/component grouping with said second application/component grouping; and</claim-text><claim-text>provided a sufficient similarity exists between said first application/component grouping and said second application/component grouping, assigning said persistent unique identifier associated with said first application/component grouping to said second application/component grouping.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The computer-implemented method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein, provided a sufficient similarity does not exist between said first application/component grouping and said second application/component grouping, assigning a new persistent unique identifier to said second application/component grouping.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The computer-implemented method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein, said comparing said first application/component grouping with said second application/component grouping is performed using a stable marriage method.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The computer-implemented method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, further comprising:<claim-text>provided a difference exists between said first application/component grouping and said second application/component grouping, recording said difference for analytic purposes.</claim-text></claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The computer-implemented method of <claim-ref idref="CLM-00014">claim 14</claim-ref>, further comprising:<claim-text>reporting said difference to a management device for performing said analytic purposes.</claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The computer-implemented method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein said computing environment is a virtualized computing environment.</claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The computer-implemented method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein said plurality of diverse components comprising said computing environment are comprised of virtualized components and physical components.</claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The computer-implemented method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein said machine learning based discovery of a plurality of applications further comprises:<claim-text>clustering said plurality of unsupervised machine learning based applications accessing common components of said computing network environment.</claim-text></claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The computer-implemented method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein said machine learning based discovery of said plurality of unsupervised machine learning based applications further comprises:<claim-text>determining boundaries of each of said plurality of unsupervised machine learning based applications in said computing environment.</claim-text></claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The computer-implemented method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein said machine learning based discovery of said plurality of unsupervised machine learning based applications further comprises:<claim-text>providing a change notification identifying and reporting differences between said first application/component grouping and said second application/component grouping, said change notification indicating which diverse components have been added to or removed from said second application/component grouping.</claim-text></claim-text></claim></claims></us-patent-application>