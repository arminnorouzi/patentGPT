<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230005208A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230005208</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17903949</doc-number><date>20220906</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><priority-claims><priority-claim sequence="01" kind="national"><country>GB</country><doc-number>1800794.8</doc-number><date>20180118</date></priority-claim></priority-claims><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20110101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>T</subclass><main-group>15</main-group><subgroup>00</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>T</subclass><main-group>1</main-group><subgroup>20</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>54</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>T</subclass><main-group>17</main-group><subgroup>20</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>T</subclass><main-group>1</main-group><subgroup>60</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>T</subclass><main-group>15</main-group><subgroup>005</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>T</subclass><main-group>1</main-group><subgroup>20</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>54</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>T</subclass><main-group>17</main-group><subgroup>20</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>T</subclass><main-group>1</main-group><subgroup>60</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e61">Topology Preservation in a Graphics Pipeline by Analyzing a Geometry Shader</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>16250706</doc-number><date>20190117</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11468620</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17903949</doc-number></document-id></child-doc></relation></continuation></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Imagination Technologies Limited</orgname><address><city>Kings Langley</city><country>GB</country></address></addressbook><residence><country>GB</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Howson</last-name><first-name>John W.</first-name><address><city>St. Albans</city><country>GB</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A graphics processing engine has a geometry shading stage having two modes of operation. In the first mode of operation, each primitive output by the geometry shading stage is independent, whereas in the second mode of operation, connectivity between input primitives is maintained by the geometry shading stage. The mode of operation of the geometry shading stage can be determined based on the value of control state data which may be generated at compile-time for a geometry shader based on analysis of that geometry shader.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="92.63mm" wi="113.71mm" file="US20230005208A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="230.04mm" wi="144.70mm" orientation="landscape" file="US20230005208A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="224.87mm" wi="120.90mm" file="US20230005208A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="228.60mm" wi="139.53mm" file="US20230005208A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="232.16mm" wi="150.11mm" orientation="landscape" file="US20230005208A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="179.75mm" wi="105.66mm" file="US20230005208A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="212.60mm" wi="153.25mm" file="US20230005208A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="222.67mm" wi="138.18mm" file="US20230005208A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="138.94mm" wi="104.39mm" orientation="landscape" file="US20230005208A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS AND CLAIM OF PRIORITY</heading><p id="p-0002" num="0001">This application is a continuation under 35 U.S.C. 120 of copending application Ser. No. 16/250,706 filed Jan. 17, 2019, which claims foreign priority under 35 U.S.C. 119 from United Kingdom Application No. 1800794.8 filed Jan. 18, 2018.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">BACKGROUND</heading><p id="p-0003" num="0002">Graphics processing systems are used to process graphics data. For example, an application running on a computing system may need to render an image of a three dimensional (3D) scene for display to a user. The application can send graphics data to a graphics processing system to be rendered, wherein the graphics data describes primitives to be rendered. As is known in the art, primitives are usually convex polygons, such as triangles or convex quadrilaterals, wherein a primitive typically has its position in the rendering space of the graphics processing system defined by the position of its vertices, and may have its appearance defined by other attributes such as colour or texture attributes. An object in a scene may be represented by one or more primitives. As graphics processing systems progress, their capability to render complex images improves, and as such applications make use of this and provide more complex images for graphics processing systems to render. This means that the number of primitives in images tends to increase, so the ability of a graphics processing system to process the primitives efficiently becomes more important.</p><p id="p-0004" num="0003">One known way of improving the efficiency of a graphics processing system is to render an image in a tile-based manner. In this way, the rendering space into which primitives are to be rendered is divided into a plurality of tiles, which can then be rendered independently from each other. In order to render primitives, a rendering unit uses memory to store intermediate results (e.g. depth values and primitive identifiers, etc.) for different sample positions. If the rendering unit operates on a tile at a time then most (or all) of this memory can be situated &#x201c;on-chip&#x201d;, i.e. on the Graphics Processing Unit (GPU), which might not be possible if the whole rendering space is rendered at once. Therefore, in a tile-based graphics system, the number of read and write operations between the GPU and an off-chip memory (i.e. which may be referred to as &#x201c;system memory&#x201d;) is typically reduced compared to a non-tile-based graphics system. Since read and write operations between the GPU and the system memory are typically very slow and use lots of power (compared to operations performed within the GPU), tile-based graphics systems are often more efficient (in terms of power and speed) than non-tile-based graphics systems.</p><p id="p-0005" num="0004">The embodiments described below are provided by way of example only and are not limiting of implementations which solve any or all of the disadvantages of known graphics processing systems.</p><heading id="h-0003" level="1">SUMMARY</heading><p id="p-0006" num="0005">This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.</p><p id="p-0007" num="0006">A graphics processing engine that comprises a geometry shading stage having two modes of operation is described. In the first mode of operation, each primitive output by the geometry shading stage is independent, whereas in the second mode of operation, connectivity between input primitives is maintained by the geometry shading stage. The mode of operation of the geometry shading stage can be determined based on the value of control state data which may be generated at compile-time for a geometry shader based on analysis of that geometry shader.</p><p id="p-0008" num="0007">A first aspect provides a method of controlling operation of a geometry shading stage in a graphics processing system, the method comprising: receiving a geometry shader for execution by the geometry shading stage; analyzing the geometry shader to determine whether it preserves connectivity; in response to determining that the geometry shader does not preserve connectivity of primitives, generating control state data having a first value; in response to determining that the geometry shader does preserve connectivity of primitives, generating control state data having a second value; and outputting the control state data.</p><p id="p-0009" num="0008">A second aspect provides a processor configured to control operation of a geometry shading stage in a graphics processing system, the processor being configured to: receive a geometry shader for execution by the geometry shading stage; analyze the geometry shader to determine whether it preserves connectivity; in response to determining that the geometry shader does not preserve connectivity of primitives, generate control state data having a first value; in response to determining that the geometry shader does preserve connectivity of primitives, generate control state data having a second value; and output the control state data.</p><p id="p-0010" num="0009">A third aspect provides a method of controlling operation of a geometry shading stage in a graphics processing system, the method comprising: receiving, in a compiler, a geometry shader for execution by the geometry shading stage; analyzing the geometry shader to determine whether it preserves connectivity; in response to determining that the geometry shader does not preserve connectivity of primitives, outputting geometry shader code; in response to determining that the geometry shader does preserve connectivity of primitives, including geometry shader code in a prior stage of a graphics pipeline implemented within the graphics processing system.</p><p id="p-0011" num="0010">A fourth aspect provides a computing device arranged to control operation of a geometry shading stage in a graphics processing system, the computing device comprising: a processor; and memory storing computer executable instructions that when executed cause the computing device to: receive a geometry shader for execution by the geometry shading stage; analyze the geometry shader to determine whether it preserves connectivity; in response to determining that the geometry shader does not preserve connectivity of primitives, output geometry shader code; in response to determining that the geometry shader does preserve connectivity of primitives, include geometry shader code in a prior stage of a graphics pipeline implemented within the graphics processing system.</p><p id="p-0012" num="0011">A fifth aspect provides a processor in a graphics processing system comprising: a geometry shading stage having a first and a second mode of operation, wherein in the first mode of operation each output primitive is independent and in the second mode of operation connectivity of primitives is maintained.</p><p id="p-0013" num="0012">A sixth aspect provides a method of operation of a geometry shading stage in a graphics processing system, the method comprising: receiving control state data; and switching between a first mode of operation and a second mode of operation dependent upon a value of the received control state data, wherein in the first mode of operation each output primitive is independent and in the second mode of operation connectivity of primitives is maintained.</p><p id="p-0014" num="0013">A seventh aspect provides an integrated circuit manufacturing system comprising: a non-transitory computer readable storage medium having stored thereon a computer readable description of an integrated circuit that describes a graphics processing system; a layout processing system configured to process the integrated circuit description so as to generate a circuit layout description of an integrated circuit embodying the graphics processing system; and an integrated circuit generation system configured to manufacture the graphics processing system according to the circuit layout description, wherein the processor comprises: a geometry shading stage having a first and a second mode of operation, wherein in the first mode of operation each output primitive is independent and in the second mode of operation connectivity of primitives is maintained.</p><p id="p-0015" num="0014">The graphics processing system described herein may be embodied in hardware on an integrated circuit. There may be provided a method of manufacturing, at an integrated circuit manufacturing system, a graphics processing system. There may be provided an integrated circuit definition dataset that, when processed in an integrated circuit manufacturing system, configures the system to manufacture a graphics processing system. There may be provided a non-transitory computer readable storage medium having stored thereon a computer readable description of an integrated circuit that, when processed, causes a layout processing system to generate a circuit layout description used in an integrated circuit manufacturing system to manufacture a graphics processing system.</p><p id="p-0016" num="0015">There may be provided an integrated circuit manufacturing system comprising: a non-transitory computer readable storage medium having stored thereon a computer readable integrated circuit description that describes the graphics processing system graphics processing system; a layout processing system configured to process the integrated circuit description so as to generate a circuit layout description of an integrated circuit embodying the graphics processing system; and an integrated circuit generation system configured to manufacture the graphics processing system according to the circuit layout description.</p><p id="p-0017" num="0016">There may be provided computer program code for performing any of the methods described herein. There may be provided non-transitory computer readable storage medium having stored thereon computer readable instructions that, when executed at a computer system, cause the computer system to perform any of the methods described herein.</p><p id="p-0018" num="0017">The above features may be combined as appropriate, as would be apparent to a skilled person, and may be combined with any of the aspects of the examples described herein.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0019" num="0018">Examples will now be described in detail with reference to the accompanying drawings in which:</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>1</b></figref> shows some elements of a tile-based graphics processing system;</p><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. <b>2</b>A</figref> is a flow diagram of a first mode of operation of a geometry shading stage;</p><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. <b>2</b>B</figref> is a flow diagram of a second mode of operation of a geometry shading stage;</p><p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. <b>3</b></figref> shows a graphical representation of the two modes of operation shown in <figref idref="DRAWINGS">FIGS. <b>2</b>A and <b>2</b>B</figref>;</p><p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. <b>4</b></figref> shows another graphical representation of the two modes of operation shown in <figref idref="DRAWINGS">FIGS. <b>2</b>A and <b>2</b>B</figref>;</p><p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is another flow diagram showing an example of the operation of a geometry shading stage;</p><p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. <b>6</b>A</figref> is a flow diagram of a first example method of operation of a compiler;</p><p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. <b>6</b>B</figref> is a flow diagram of a second example method of operation of a compiler;</p><p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. <b>7</b>A</figref> shows a computer system in which a graphics processing system is implemented;</p><p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. <b>7</b>B</figref> shows a computer system configured to implement the methods of <figref idref="DRAWINGS">FIGS. <b>6</b>A and/or <b>6</b>B</figref>; and</p><p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. <b>8</b></figref> shows an integrated circuit manufacturing system for generating an integrated circuit embodying a graphics processing system.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><p id="p-0031" num="0030">The accompanying drawings illustrate various examples. The skilled person will appreciate that the illustrated element boundaries (e.g., boxes, groups of boxes, or other shapes) in the drawings represent one example of the boundaries. It may be that in some examples, one element may be designed as multiple elements or that multiple elements may be designed as one element. Common reference numerals are used throughout the figures, where appropriate, to indicate similar features.</p><heading id="h-0005" level="1">DETAILED DESCRIPTION</heading><p id="p-0032" num="0031">The following description is presented by way of example to enable a person skilled in the art to make and use the invention. The present invention is not limited to the embodiments described herein and various modifications to the disclosed embodiments will be apparent to those skilled in the art.</p><p id="p-0033" num="0032">Embodiments will now be described by way of example only.</p><p id="p-0034" num="0033">In many examples and as a consequence of how the geometry shading API is defined, the geometry shading stage within a graphics processing system removes connectivity information associated with the incoming geometry data, i.e. whilst the incoming stream of primitives includes connectivity data (e.g. because adjoining primitives will reference two common vertices), the resulting primitive streams emitted by the geometry shading stage are all independent (e.g. because vertices defined in the incoming data are duplicated where required such that there are separate sets of vertices for each of the primitives in the output primitive stream). There are many situations, however, where the geometry shader preserves the topology (e.g. for multi-view rendering, such as stereoscopic rendering or rendering cube maps, where a cube map is a scene that has been rendered in six views, where each view would typically be composed of the visible scene geometry as viewed from the centre of a cube looking outwards towards each face of the cube, or for information gathering operations which analyse vertex data as it passes through) and so the duplication of vertex data in the geometry shading stage unnecessarily increases the amount of vertex data which is written to and subsequently read from memory in a tile-based rendering system, or passed between pipeline stages in an Immediate Mode Rendering (IMR) architecture. In some examples the duplication of vertex data can result in a six-fold increase in the number of vertices written to and read from memory (for tile-based rendering) or passed between pipeline stages (for IMR).</p><p id="p-0035" num="0034">Described herein is a more efficient graphics processing system (or pipeline) in which the geometry shading stage has two different modes of operation. As an example, the selection of a mode of operation from the two modes is made based on control state data that is generated by a compiler when compiling a geometry shader (which is a program that processes primitives) and which is associated with the data (e.g. primitive data) that is processed by the geometry shader. In other words, the control state data travels through the system with the data that is processed by the geometry shader. The control state data may for example be passed as a parallel pipeline state/signal or state that is pipelined with the primitive data. The first mode of operation is used when the compiler detects that the output of the geometry shading stage will modify the connectivity of the output geometry relative to the input geometry. In this mode the geometry shading stage (which is the hardware that executes the geometry shader) processes each primitive from the incoming primitive stream as independent primitives with no connectivity to adjacent primitives and the output primitives are all independent of each other (i.e. each vertex in each primitive is identified uniquely and vertex data is output for each vertex in each primitive). The second mode of operation is used when the compiler detects that the output of the geometry shading stage will not modify the connectivity of the output geometry relative to the input (i.e. connectivity is preserved). In this mode the geometry shading stage takes account of the connectivity between incoming primitives and only processes new vertices for each primitive (i.e. only those vertices which have not been previously processed) and hence the output primitives are not all independent of each other, because adjoining output primitives will refer to common vertices. In this second mode of operation, vertex data for a minimum number of vertices (e.g. there is no duplication of vertices) are written to memory (for tile-based rendering) or passed to the subsequent pipeline stage (for IMR).</p><p id="p-0036" num="0035">Whilst the methods and graphics processing system are described in one example below in terms of stereoscopic rendering which comprises two views&#x2014;a left view and a right view&#x2014;the methods can be used wherever a graphics shader preserves topology (vertices themselves may be modified in a consistent manner and the connectivity of the output geometry streams remains the same as the input geometry stream). As well as for multi-view rendering (which may render two or more views of the same instance of the scene, e.g. from different viewpoints), topology may also be preserved in other situations, such as graphics shaders which perform information gathering operations (e.g. which analyse vertex data as it passes through).</p><p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. <b>1</b></figref> shows some elements of a tile-based graphics processing system <b>100</b>. The graphics processing system <b>100</b> comprises a graphics processing unit (GPU) <b>102</b> and two portions of memory <b>104</b>A and <b>104</b>B. It is noted that the two portions of memory <b>104</b>A and <b>104</b>B may, or may not, be parts of the same physical memory, and both memories <b>104</b>A and <b>104</b>B may be situated &#x201c;off-chip&#x201d;, i.e. not on the same chip as the GPU <b>102</b>. Communication between the memories (<b>104</b>A and <b>104</b>B) and the GPU <b>102</b> may take place over a communications bus in the system <b>100</b>.</p><p id="p-0038" num="0037">The GPU <b>102</b> comprises a pre-processing module <b>106</b>, a tiling unit <b>108</b> and a rendering unit <b>110</b>. The tiling unit <b>108</b> comprises processing logic <b>112</b> and a data store <b>114</b>, and the rendering unit <b>110</b> comprises a hidden surface removal (HSR) module <b>116</b> and a texturing/shading module <b>118</b>. The graphics processing system <b>100</b> is arranged such that graphics data describing a sequence of primitives provided by an application is received at the pre-processing module <b>106</b>. The pre-processing module <b>106</b> performs functions such as geometry processing including clipping and culling to remove primitives which do not fall into a visible view. The pre-processing module <b>106</b> may also project the primitives into screen-space. The pre-processing module <b>106</b> outputs primitives to the tiling unit <b>108</b>.</p><p id="p-0039" num="0038">The tiling unit <b>108</b> receives the primitives from the pre-processing module <b>106</b> and determines which of the primitives are present within each of the tiles of the rendering space of the graphics processing system <b>100</b>. A primitive may be in one or more of the tiles of the rendering space. The tiling unit <b>108</b> assigns primitives to tiles of the rendering space by creating display lists for the tiles, wherein the display list for a tile includes indications of primitives (i.e. primitive IDs) which are present in the tile. In addition to generating display lists, the tiling unit <b>108</b> also generates data blocks, referred to as primitive blocks, which contain primitive data. The primitive data in a primitive block comprises data for a plurality of vertices and data for a plurality of primitives. As described above, a primitive is defined by the position of its vertices and hence the data for a primitive (in a primitive block) references the vertex data for a plurality of vertices within the same primitive block. The processing logic <b>112</b> of the tiling unit <b>108</b> performs the operations of the tiling unit <b>108</b> and the data store <b>114</b> stores data of intermediate results of the tiling process, such as results of tiling calculations and partially filled display lists. The processing logic <b>112</b> may be implemented in dedicated hardware designed specifically for performing the operations of the tiling unit <b>108</b>. Alternatively, at least some of the functionality of the processing logic <b>112</b> may be implemented by executing software on a processor wherein the software is written such that when it is executed it causes the processor to perform the operations of the tiling unit <b>108</b>.</p><p id="p-0040" num="0039">In various examples, once all of the primitives for a render have been tiled then the display lists are complete and they and the primitive blocks are passed to the off-chip memory <b>104</b>A for storage therein. In other examples, the tiling unit <b>108</b> might not use an internal store (such as store <b>114</b>) to store display lists, and instead primitive identifiers may be written directly to display lists in memory <b>104</b>A as tiling is performed. Furthermore, in some further examples, the internal store <b>114</b> may be implemented in the tiling unit <b>108</b>, but the internal store <b>114</b> might not be big enough to store all of the display lists for all of the tiles at once. Therefore, the internal store <b>114</b> may be used to gather tiling results that can then be written out to memory <b>104</b>A in chunks (or &#x201c;batches&#x201d;) as the tiling is performed. This can avoid inefficient memory access patterns when primitives are written to different control streams in memory <b>104</b>A.</p><p id="p-0041" num="0040">The rendering unit <b>110</b> fetches the display list for a tile and the primitives relevant to that tile from the memory <b>104</b>A (i.e. by reading data from a primitive block) and the HSR module <b>116</b> performs hidden surface removal to thereby remove fragments of primitives which are hidden in the scene. The remaining fragments are passed to the texturing/shading module <b>118</b> which performs texturing and/or shading on the fragments to determine pixel colour values of a rendered image which can be passed to the memory <b>104</b>B for storage in a frame buffer. The rendering unit <b>110</b> processes primitives in each of the tiles and when the whole image has been rendered and stored in the memory <b>104</b>B, the image can be outputted from the graphics processing system <b>100</b> and, for example, displayed on a display.</p><p id="p-0042" num="0041"><figref idref="DRAWINGS">FIG. <b>1</b></figref> also shows an example structure of the pre-processing module <b>106</b> in more detail. As shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the pre-processing module <b>106</b> may comprise a data fetch module <b>122</b> which fetches vertex data, a vertex processing module <b>124</b>, geometry shading stage <b>126</b> and a viewport transform module <b>128</b> which, in conjunction with a perspective divide, transforms the vertices into screen space coordinates. Although not shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the pre-processing module <b>106</b> (or more generally the GPU <b>102</b>) may additionally comprise internal storage (e.g. between the geometry shading stage <b>126</b> output and subsequent stages) for buffering vertex data associated with primitives during any processing that occurs after the geometry shading stage <b>126</b> (e.g. viewport and perspective transforms, clipping, culling and primitive block assembly).</p><p id="p-0043" num="0042">The geometry shading stage <b>126</b> in the pre-processing module <b>106</b> operates on a single input primitive (e.g. a point, a line, a triangle, a quad, etc.) at a time. For each input primitive the geometry shading stage <b>126</b> can see all the vertex data associated with the primitive. Vertices are identified by index values (or indices). For example, three index values may be used to identify the three vertices of a triangle input primitive. Index values allow the efficient representation of topologies in which vertices are shared. For example, where two triangular primitives share a common vertex, that vertex will be represented by a common index value. From the data relating to an input primitive (e.g. all the vertex data associated with the primitive), the geometry shading stage <b>126</b> can generate one or more output primitives of a type that may be different to the input primitive type. For example the geometry shader may be fed with point primitives (i.e. a single vertex), which it might then translates into strips of two triangles to form a quad onto which a point sprite can be mapped.</p><p id="p-0044" num="0043">The geometry shading stage <b>126</b> described herein has two modes of operation: the first mode of operation does not preserve topology information and the second mode of operation does preserve topology information. The geometry shading stage <b>126</b> switches between the first and second modes of operation based on control state data which is generated at compile time and which travels through the graphics processing system <b>100</b> with the graphics data. As described above, the control state data may for example be passed as a parallel pipeline state/signal or state that is pipelined with the primitive data.</p><p id="p-0045" num="0044">The first mode of operation is shown graphically in <figref idref="DRAWINGS">FIG. <b>2</b>A</figref> and the second mode of operation is shown graphically in <figref idref="DRAWINGS">FIG. <b>2</b>B</figref> and the difference in operation of the two modes can be described with reference to the arrangement <b>300</b> of adjoining primitives shown in <figref idref="DRAWINGS">FIGS. <b>3</b> and <b>4</b></figref>.</p><p id="p-0046" num="0045">In the first mode of operation as shown in <figref idref="DRAWINGS">FIG. <b>2</b>A</figref>, data is received for an input primitive (block <b>202</b>) e.g. vertex data for three vertices for a triangle input primitive. As described above, the geometry shader generates one or more output primitives from an input primitive and as shown in <figref idref="DRAWINGS">FIG. <b>2</b>A</figref>, all the vertices in an output primitive (e.g. vertex data for three vertices for a triangle output primitive) are processed (block <b>204</b>). If there are multiple processes, the processing operation (in block <b>204</b>) is repeated for each process before the output primitive is emitted (block <b>206</b>), e.g. vertex data for all the vertices in the output primitive is emitted. If the input primitive generates multiple output primitives (&#x2018;Yes&#x2019; in block <b>207</b>) the processing operation (in block <b>204</b>) is then repeated for each further output primitive until all the output primitives which correspond to the input primitive have been emitted (in block <b>206</b>). When a primitive is emitted, the data that is emitted is vertex data describing the vertices of the primitive, wherein the emitted data also indicates (e.g. via references or via its format) that the emitted primitive is formed from the appropriate vertices. The method is then repeated for the next input primitive (as indicated by the arrow from &#x2018;No&#x2019; in block <b>207</b> to block <b>202</b>). This first mode of operation may be represented in pseudocode as:</p><p id="p-0047" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="42pt" align="left"/><colspec colname="1" colwidth="175pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>FOR (Input Primitives)</entry></row><row><entry/><entry>&#x2003;FOR (Output Primitives)</entry></row><row><entry/><entry>&#x2003;Process all vertices for output primitive</entry></row><row><entry/><entry>&#x2003;Emit (Output Primitive)</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0048" num="0046">In the first mode of operation the output primitives generated by the geometry shader (and emitted in block <b>206</b>) are treated as being unconnected to the input geometry stream as such they do not carry any of the connectivity that the input stream may have possessed. For example, if an incoming strip of triangles, where each triangle shares two vertices with the previous triangle, is processed through the geometry shading stage and each triangle emitted without changes, the resulting geometry stream would lose its connectivity i.e. each triangle would now be composed of 3 unique vertices instead of sharing vertices with prior triangles. If index values are used to identify the vertices of the output primitives then new index values must be generated such that the index values do not indicate the sharing of vertices between primitives.</p><p id="p-0049" num="0047">In the second mode of operation as shown in <figref idref="DRAWINGS">FIG. <b>2</b>B</figref>, data is received for an input primitive (block <b>202</b>) e.g. vertex data for three vertices for a triangle input primitive, and any new vertices in the input primitive are identified (block <b>208</b>), where a new vertex is one that has not been previously processed by the geometry shading stage <b>126</b> (e.g. in a previous iteration of the method for another input primitive in the primitive stream). Then only those identified new vertices (from block <b>208</b>) are processed for an output primitive (block <b>210</b>). If there are multiple processes, the processing operation (in block <b>210</b>) is repeated for each process (again only processing the new vertices) before the output primitive is emitted (block <b>206</b>), e.g. vertex data for all the vertices in the output primitive. If the input primitive generates multiple output primitives (&#x2018;Yes&#x2019; in block <b>207</b>) the processing operation (in block <b>210</b>) is then repeated for each further output primitive until all the output primitives which correspond to the input primitive have been emitted (in block <b>206</b>). In the second mode, when a primitive is emitted, the data that is emitted is vertex data describing the one or more new vertices of the primitive. The connectivity for the emitted vertices is taken from the original input primitives. That is, the index values used to identify vertex data at the input to the geometry shading stage may also be used to identify the vertices of the output primitives at the output of the geometry shading stage. This is possible because the second mode is used when the shader is known not to modify the topology of the input data. Connectivity, represented by the sharing of vertex data through common index values, is preserved. The method is then repeated for the next input primitive. This mode of operation may be represented in pseudocode as:</p><p id="p-0050" num="0000"><tables id="TABLE-US-00002" num="00002"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="63pt" align="left"/><colspec colname="1" colwidth="154pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>FOR (Primitive)</entry></row><row><entry/><entry>&#x2003;Find new vertices</entry></row><row><entry/><entry>&#x2003;FOR (Process)</entry></row><row><entry/><entry>&#x2003;Process all new vertices</entry></row><row><entry/><entry>Emit (Primitive)</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0051" num="0048">Once the new vertices have been processed (in block <b>210</b>), the vertex data is stored in a buffer (e.g. in the internal storage described above) for subsequent use in the graphics processing system <b>100</b> (e.g. for inclusion in a primitive block by the tiling unit <b>108</b>) in a similar manner to the first mode of operation; however, in the second mode of operation the buffer will only contain the new vertices for each triangle, whereas in the first mode of operation, the buffer will contain three vertices per triangle. In the second mode of operation the vertex data that is stored in the buffer is accessed using the vertex indices and may be referred to as modified vertex data because, although the original vertex indices are used, the geometry shader may modify the vertex data. When operating in the second mode of operation, the vertex data in the buffer may be read more than once by stages of the graphics processing system <b>100</b> which follow the geometry shading stage <b>126</b> (e.g. because the same vertex index may be used by several primitives, unlike in the first mode of operation where each vertex index is used by only one primitive). In the second mode of operation the index values at the output of the geometry shader are the same as the index values at the input of the geometry shader. The index values may be passed through the geometry shader unmodified, or may be written directly to the buffer, in which case the indices are said to have bypassed the geometry shader.</p><p id="p-0052" num="0049">The difference between the first and second modes of operation can be demonstrated with reference to the arrangement <b>300</b> of adjoining primitives A, B, C shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref>. In this example, the geometry shader passes through (or bypasses) the topology without changing it. If the first mode of operation is used to process the three adjoining primitives A, B, C shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, three primitives are output: primitive A comprising vertices A0, A1, A2, primitive B comprising vertices B0, B1, B2 and primitive C comprising vertices C0, C1, C2. Whilst the incoming three primitives referenced only 5 vertices (vertices 0-4), the output primitives, which are all defined independently of each other, reference 9 vertices (vertices A0, A1, A2, B0, B1, B2, C0, C1, C2). In contrast, if the second mode of operation is used to process the same three adjoining primitives A, B, C shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, three primitives are still output, however, the vertices retain their original indices (although the vertices themselves may have been modified by the geometry shader) and hence the topology information is maintained. The output primitives are primitive A comprising vertices 0, 1, 2, primitive B comprising vertices 1, 2, 3 and primitive C comprising vertices 2, 3, 4. In this mode of operation the incoming three primitives and the output primitives reference the same number of vertices (5 vertices in the example shown). Consequently the amount of vertex data which is stored in memory is significantly less in the second mode of operation than the first mode of operation. Additionally, only 5 vertices are processed in the geometry shader in the second mode of operation, compared to 9 in the first mode of operation.</p><p id="p-0053" num="0050">The difference between the first and second modes of operation can also be demonstrated with reference to the same arrangement <b>300</b> of adjoining primitives A, B, C shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref>. In this example, the geometry shader duplicates the topology into two parallel streams of primitives, which in this example are labelled L and R. If the first mode of operation is used to process the three adjoining primitives A, B, C shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref>, six primitives are output: primitive A(L) comprising vertices A0(L), A1(L), A2(L), primitive A(R) comprising vertices A0(R), A1(R), A2(R), primitive B(L) comprising vertices B0(L), B1(L), B2(L), primitive B(R) comprising vertices B0(R), B1(R), B2(R), primitive C(L) comprising vertices C0(L), C1(L), C2(L) and primitive C(R) comprising vertices C0(R), C1(R), C2(R). Whilst the incoming three primitives referenced only 5 vertices (vertices 0-4), the output primitives, which are all defined independently of each other, reference 18 vertices. In contrast, if the second mode of operation is used to process the same three adjoining primitives A, B, C shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref>, six primitives are still output, however, the vertices retain their original indices and hence the topology information is maintained. The output primitives are primitives A(L) and A(R) each comprising vertices 0, 1, 2, primitives B(L) and B(R) each comprising vertices 1, 2, 3, and primitives C(L) and C(R) each comprising vertices 2, 3, 4. However, as the two streams of primitives (labelled L and R streams in this example) reference different vertex sets the output vertices are labelled with (L) or (R) in <figref idref="DRAWINGS">FIG. <b>4</b></figref>. It will also be appreciated that whilst the vertices retain their original indices, the vertices themselves may be modified by the geometry shader. In this second mode of operation the incoming three primitives and the output primitives for each stream reference the same number of vertices (5 vertices per stream in the example shown). Consequently the amount of vertex data which is stored in memory is significantly less in the second mode of operation than the first mode of operation (e.g. by using the second mode of operation the bandwidth associated with moving vertex data around a system is reduced to approximately one third of the bandwidth that would be required when using the first mode of operation). Additionally, in the example shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref>, only 10 vertices (5 vertices for each stream) are processed in the geometry shader in the second mode of operation, compared to 18 in the first mode of operation.</p><p id="p-0054" num="0051">The second mode of operation can only be used where the geometry shader maintains the primitive connectivity, either because it passes through the topology unchanged (as in the example in <figref idref="DRAWINGS">FIG. <b>3</b></figref>) or because it duplicates the topology into two or more parallel primitive streams (as in the example in <figref idref="DRAWINGS">FIG. <b>4</b></figref>), although vertices may themselves be modified in a consistent manner. This is determined at compile time (i.e. in a compiler when compiling the geometry shader) and control state data is generated at compile time which sets the mode of operation of the geometry shading stage <b>126</b>. The geometry shading stage <b>126</b> receives the control state data (block <b>502</b>) and switches between the first and second modes of operation based on the control state data (blocks <b>504</b>-<b>508</b>) as shown in <figref idref="DRAWINGS">FIG. <b>5</b></figref>. If the control state data is not equal to the second value (&#x2018;No&#x2019; in block <b>504</b>), the geometry shading stage <b>126</b> is set to the first mode of operation (block <b>506</b>). If the control state data is equal to the second value (&#x2018;Yes&#x2019; in block <b>504</b>), the geometry shading stage <b>126</b> is set to the second mode of operation (block <b>508</b>).</p><p id="p-0055" num="0052">The operation of the compiler is shown in <figref idref="DRAWINGS">FIG. <b>6</b>A</figref>. In block <b>602</b>, the compiler (which may comprise device executable instructions and which may be stored in memory and executed by a processor) receives the geometry shader (i.e. the program code for the geometry shader) and analyses the geometry shader code (block <b>604</b>) to determine whether the geometry shader maintains the primitive connectivity of streams of input primitives, e.g. by passing the topology through (as in the example shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref>) or by duplicating the topology into parallel streams (as in the example shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref>). In response to determining that the geometry shader does not maintain the connectivity of streams of input primitives (&#x2018;No&#x2019; in block <b>606</b>), the control state data is set to a first value (block <b>608</b>) which causes the geometry shading stage <b>126</b> to operate in the first mode of operation (as shown in <figref idref="DRAWINGS">FIG. <b>5</b></figref>). In response to determining that the geometry shader does maintain the connectivity of streams of input primitives (&#x2018;Yes&#x2019; in block <b>606</b>), the control state data is set to a second value (block <b>610</b>) which causes the geometry shading stage <b>126</b> to operate in the second mode of operation (as shown in <figref idref="DRAWINGS">FIG. <b>5</b></figref>).</p><p id="p-0056" num="0053">In various examples the control state data may be provided as a flag or an extension to the incoming stream of graphics data (e.g. a stereoscopic extension). In other examples the control state data (which may also be referred to as a control flag) may be passed directly to the API hardware Driver by the application by way of a modification or extension to the standard API's (e.g. OpenGL, OpenGL ES, Direct X, Vulcan etc.).</p><p id="p-0057" num="0054">Examples of geometry shaders which preserve topology and hence where the control state data may be set to the second value by the compiler include, but are not limited to:<ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0055">Stereoscopic rendering,</li>        <li id="ul0002-0002" num="0056">Rendering to an array of surfaces where each surface has a different transform associated with it (e.g. cube maps), and</li>        <li id="ul0002-0003" num="0057">Information gathering (i.e. where the geometry shader analyses data as it passes through e.g. to calculate an average density of vertices).</li>    </ul>    </li></ul></p><p id="p-0058" num="0058">In an alternative implementation, the compiler may operate as shown in <figref idref="DRAWINGS">FIG. <b>6</b>B</figref>. The alternative approach works by spotting geometry shader cases where the input connectivity data can be carried forward to the geometry shader output streams (&#x2018;Yes&#x2019; in block <b>606</b>). In these cases the geometry shader code is collapsed into the prior stage of the geometry pipeline (block <b>612</b>), for example the vertex shader (as executed in the vertex processing stage <b>124</b> which may alternatively be referred to as the vertex shading stage), such that the prior stage (which already takes into account connectivity) directly emits the vertices for each output stream. If, however, the compiler analyses the geometry shader code (in block <b>604</b>) and determines that the geometry shader does not maintain the connectivity of streams of input primitives (&#x2018;No&#x2019; in block <b>606</b>), then the compiler outputs geometry shader code in the standard way (block <b>614</b>).</p><p id="p-0059" num="0059">In the example shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the tile-based graphics processing system <b>100</b> is a deferred rendering system, meaning that the rendering unit <b>110</b> performs hidden surface removal on a primitive fragment prior to performing texturing and/or shading on the primitive fragment in order to render the scene. However, in other examples, graphics processing systems might not be deferred rendering systems, such that rendering units may perform texturing and/or shading on a primitive fragment before hidden surface removal is performed on the primitive fragment.</p><p id="p-0060" num="0060">It will be appreciated that some elements of the graphics processing system <b>100</b> are not shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>. For example, the graphics processing system <b>100</b> may comprise additional shading stages, e.g. a hull shading stage and/or a domain shading stage. In various examples the graphics processing system <b>100</b> may additionally comprise a tessellation unit (e.g. which may be located between the vertex processing module <b>124</b> and the geometry shading stage <b>126</b>). In such examples, the indices that are bypassed in the second mode of operation (i.e. when connectivity is preserved) are those indices that are generated as part of the tessellation process and not the original input indices that reference the patch data (and not the tessellated vertex data).</p><p id="p-0061" num="0061">Using the methods described above, the original indices for the vertices are used all the way through the pre-processing block <b>106</b> and into the tiling unit <b>108</b> (e.g. instead of being replaced by new indices in the geometry shading stage <b>126</b>). Whilst the original vertex indices are used, the vertex data to which it refers may be modified and hence the original indices may be used to access modified vertex data. In the tiling unit <b>108</b> (e.g. in the processing block <b>112</b>), the original indices are used to access the modified vertex data which is then formed into the primitive blocks output by the tiling unit <b>108</b> and stored in memory <b>104</b>A.</p><p id="p-0062" num="0062">By using the methods described above, memory bandwidth is reduced for any geometry shader that is topology and connectivity preserving.</p><p id="p-0063" num="0063">Whilst the methods are mainly described above with reference to tile-based rendering, the methods may also be used in graphics processing systems which use IMR. In immediate mode renderers, work that is sent to the GPU is drawn immediately and there is little connection to anything that has been drawn previously or will be drawn in the future. Triangles are sent to the graphics processing system and are shaded, the triangles are then rasterized into pixels and shaded before the rendered pixels are sent to the screen. In examples where the methods described herein are used in IMR-based rendering devices (e.g. in a graphics processing system which uses IMR), the methods lead to a reduction of internal bandwidth for passing vertex data for triangles to the rasterization pipeline.</p><p id="p-0064" num="0064"><figref idref="DRAWINGS">FIG. <b>7</b>A</figref> shows a computer system in which the graphics processing systems described herein may be implemented. The computer system comprises a GPU <b>102</b> (e.g. as shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref> and described above), a CPU <b>702</b>, a memory <b>706</b> and other devices <b>714</b>, such as a display <b>716</b>, speakers <b>718</b> and a camera <b>719</b>. The components of the computer system can communicate with each other via a communications bus <b>720</b>. The memories <b>104</b>A and <b>104</b>B shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref> may be implemented as part of memory <b>706</b>.</p><p id="p-0065" num="0065"><figref idref="DRAWINGS">FIG. <b>7</b>B</figref> shows a computer system in which the methods shown in <figref idref="DRAWINGS">FIGS. <b>6</b>A and <b>6</b>B</figref> and described above may be implemented. The computer system as similar to that shown in <figref idref="DRAWINGS">FIG. <b>7</b>A</figref> and described above; however the memory <b>706</b>&#x2032; is arranged to stored compiler software <b>722</b>. The compiler software <b>722</b> comprises device executable instructions that, when executed by the CPU <b>702</b>, cause the computer system to implement the method of <figref idref="DRAWINGS">FIG. <b>6</b>A or <b>6</b>B</figref>.</p><p id="p-0066" num="0066">The GPU <b>102</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, and in particular the pre-processing block <b>106</b>, is shown as comprising a number of functional blocks. This is schematic only and is not intended to define a strict division between different logic elements of such entities. Each functional block may be provided in any suitable manner. It is to be understood that intermediate values described herein as being formed by a GPU need not be physically generated by the GPU at any point and may merely represent logical values which conveniently describe the processing performed by the GPU between its input and output.</p><p id="p-0067" num="0067">The graphics processing system described herein may be embodied in hardware on an integrated circuit. The graphics processing system described herein may be configured to perform any of the methods described herein. Generally, any of the functions, methods, techniques or components described above can be implemented in software, firmware, hardware (e.g., fixed logic circuitry), or any combination thereof. The terms &#x201c;module,&#x201d; &#x201c;functionality,&#x201d; &#x201c;component&#x201d;, &#x201c;element&#x201d;, &#x201c;unit&#x201d;, &#x201c;block&#x201d; and &#x201c;logic&#x201d; may be used herein to generally represent software, firmware, hardware, or any combination thereof. In the case of a software implementation, the module, functionality, component, element, unit, block or logic represents program code that performs the specified tasks when executed on a processor. The algorithms and methods described herein could be performed by one or more processors executing code that causes the processor(s) to perform the algorithms/methods. Examples of a computer-readable storage medium include a random-access memory (RAM), read-only memory (ROM), an optical disc, flash memory, hard disk memory, and other memory devices that may use magnetic, optical, and other techniques to store instructions or other data and that can be accessed by a machine.</p><p id="p-0068" num="0068">The terms computer program code and computer readable instructions as used herein refer to any kind of executable code for processors, including code expressed in a machine language, an interpreted language or a scripting language. Executable code includes binary code, machine code, bytecode, code defining an integrated circuit (such as a hardware description language or netlist), and code expressed in a programming language code such as C, Java or OpenCL. Executable code may be, for example, any kind of software, firmware, script, module or library which, when suitably executed, processed, interpreted, compiled, executed at a virtual machine or other software environment, cause a processor of the computer system at which the executable code is supported to perform the tasks specified by the code.</p><p id="p-0069" num="0069">A processor, computer, or computer system may be any kind of device, machine or dedicated circuit, or collection or portion thereof, with processing capability such that it can execute instructions. A processor may be any kind of general purpose or dedicated processor, such as a CPU, GPU, System-on-chip, state machine, media processor, an application-specific integrated circuit (ASIC), a programmable logic array, a field-programmable gate array (FPGA), physics processing units (PPUs), radio processing units (RPUs), digital signal processors (DSPs), general purpose processors (e.g. a general purpose GPU), microprocessors, any processing unit which is designed to accelerate tasks outside of a CPU, etc. A computer or computer system may comprise one or more processors. Those skilled in the art will realize that such processing capabilities are incorporated into many different devices and therefore the term &#x2018;computer&#x2019; includes set top boxes, media players, digital radios, PCs, servers, mobile telephones, personal digital assistants and many other devices.</p><p id="p-0070" num="0070">It is also intended to encompass software which defines a configuration of hardware as described herein, such as HDL (hardware description language) software, as is used for designing integrated circuits, or for configuring programmable chips, to carry out desired functions. That is, there may be provided a computer readable storage medium having encoded thereon computer readable program code in the form of an integrated circuit definition dataset that when processed (i.e. run) in an integrated circuit manufacturing system configures the system to manufacture a graphics processing system configured to perform any of the methods described herein, or to manufacture a graphics processing system comprising any apparatus described herein. An integrated circuit definition dataset may be, for example, an integrated circuit description.</p><p id="p-0071" num="0071">Therefore, there may be provided a method of manufacturing, at an integrated circuit manufacturing system, a graphics processing system as described herein. Furthermore, there may be provided an integrated circuit definition dataset that, when processed in an integrated circuit manufacturing system, causes the method of manufacturing a graphics processing system to be performed.</p><p id="p-0072" num="0072">An integrated circuit definition dataset may be in the form of computer code, for example as a netlist, code for configuring a programmable chip, as a hardware description language defining an integrated circuit at any level, including as register transfer level (RTL) code, as high-level circuit representations such as Verilog or VHDL, and as low-level circuit representations such as OASIS&#xae; and GDSII. Higher level representations which logically define an integrated circuit (such as RTL) may be processed at a computer system configured for generating a manufacturing definition of an integrated circuit in the context of a software environment comprising definitions of circuit elements and rules for combining those elements in order to generate the manufacturing definition of an integrated circuit so defined by the representation. As is typically the case with software executing at a computer system so as to define a machine, one or more intermediate user steps (e.g. providing commands, variables etc.) may be required in order for a computer system configured for generating a manufacturing definition of an integrated circuit to execute code defining an integrated circuit so as to generate the manufacturing definition of that integrated circuit.</p><p id="p-0073" num="0073">An example of processing an integrated circuit definition dataset at an integrated circuit manufacturing system so as to configure the system to manufacture a graphics processing system will now be described with respect to <figref idref="DRAWINGS">FIG. <b>8</b></figref>.</p><p id="p-0074" num="0074"><figref idref="DRAWINGS">FIG. <b>8</b></figref> shows an example of an integrated circuit (IC) manufacturing system <b>802</b> which is configured to manufacture a graphics processing system as described in any of the examples herein. In particular, the IC manufacturing system <b>802</b> comprises a layout processing system <b>804</b> and an integrated circuit generation system <b>806</b>. The IC manufacturing system <b>802</b> is configured to receive an IC definition dataset (e.g. defining a graphics processing system as described in any of the examples herein), process the IC definition dataset, and generate an IC according to the IC definition dataset (e.g. which embodies a graphics processing system as described in any of the examples herein). The processing of the IC definition dataset configures the IC manufacturing system <b>802</b> to manufacture an integrated circuit embodying a graphics processing system as described in any of the examples herein.</p><p id="p-0075" num="0075">The layout processing system <b>804</b> is configured to receive and process the IC definition dataset to determine a circuit layout. Methods of determining a circuit layout from an IC definition dataset are known in the art, and for example may involve synthesising RTL code to determine a gate level representation of a circuit to be generated, e.g. in terms of logical components (e.g. NAND, NOR, AND, OR, MUX and FLIP-FLOP components). A circuit layout can be determined from the gate level representation of the circuit by determining positional information for the logical components. This may be done automatically or with user involvement in order to optimise the circuit layout. When the layout processing system <b>804</b> has determined the circuit layout it may output a circuit layout definition to the IC generation system <b>806</b>. A circuit layout definition may be, for example, a circuit layout description.</p><p id="p-0076" num="0076">The IC generation system <b>806</b> generates an IC according to the circuit layout definition, as is known in the art. For example, the IC generation system <b>806</b> may implement a semiconductor device fabrication process to generate the IC, which may involve a multiple-step sequence of photo lithographic and chemical processing steps during which electronic circuits are gradually created on a wafer made of semiconducting material. The circuit layout definition may be in the form of a mask which can be used in a lithographic process for generating an IC according to the circuit definition. Alternatively, the circuit layout definition provided to the IC generation system <b>806</b> may be in the form of computer-readable code which the IC generation system <b>806</b> can use to form a suitable mask for use in generating an IC.</p><p id="p-0077" num="0077">The different processes performed by the IC manufacturing system <b>802</b> may be implemented all in one location, e.g. by one party. Alternatively, the IC manufacturing system <b>802</b> may be a distributed system such that some of the processes may be performed at different locations, and may be performed by different parties. For example, some of the stages of: (i) synthesising RTL code representing the IC definition dataset to form a gate level representation of a circuit to be generated, (ii) generating a circuit layout based on the gate level representation, (iii) forming a mask in accordance with the circuit layout, and (iv) fabricating an integrated circuit using the mask, may be performed in different locations and/or by different parties.</p><p id="p-0078" num="0078">In other examples, processing of the integrated circuit definition dataset at an integrated circuit manufacturing system may configure the system to manufacture a graphics processing system without the IC definition dataset being processed so as to determine a circuit layout. For instance, an integrated circuit definition dataset may define the configuration of a reconfigurable processor, such as an FPGA, and the processing of that dataset may configure an IC manufacturing system to generate a reconfigurable processor having that defined configuration (e.g. by loading configuration data to the FPGA).</p><p id="p-0079" num="0079">In some embodiments, an integrated circuit manufacturing definition dataset, when processed in an integrated circuit manufacturing system, may cause an integrated circuit manufacturing system to generate a device as described herein. For example, the configuration of an integrated circuit manufacturing system in the manner described above with respect to <figref idref="DRAWINGS">FIG. <b>8</b></figref> by an integrated circuit manufacturing definition dataset may cause a device as described herein to be manufactured.</p><p id="p-0080" num="0080">In some examples, an integrated circuit definition dataset could include software which runs on hardware defined at the dataset or in combination with hardware defined at the dataset. In the example shown in <figref idref="DRAWINGS">FIG. <b>8</b></figref>, the IC generation system may further be configured by an integrated circuit definition dataset to, on manufacturing an integrated circuit, load firmware onto that integrated circuit in accordance with program code defined at the integrated circuit definition dataset or otherwise provide program code with the integrated circuit for use with the integrated circuit.</p><p id="p-0081" num="0081">Those skilled in the art will realize that storage devices utilized to store program instructions can be distributed across a network. For example, a remote computer may store an example of the process described as software. A local or terminal computer may access the remote computer and download a part or all of the software to run the program. Alternatively, the local computer may download pieces of the software as needed, or execute some software instructions at the local terminal and some at the remote computer (or computer network). Those skilled in the art will also realize that by utilizing conventional techniques known to those skilled in the art that all, or a portion of the software instructions may be carried out by a dedicated circuit, such as a DSP, programmable logic array, or the like.</p><p id="p-0082" num="0082">The methods described herein may be performed by a computer configured with software in machine readable form stored on a tangible storage medium e.g. in the form of a computer program comprising computer readable program code for configuring a computer to perform the constituent portions of described methods or in the form of a computer program comprising computer program code means adapted to perform all the steps of any of the methods described herein when the program is run on a computer and where the computer program may be embodied on a computer readable storage medium. Examples of tangible (or non-transitory) storage media include disks, thumb drives, memory cards etc. and do not include propagated signals. The software can be suitable for execution on a parallel processor or a serial processor such that the method steps may be carried out in any suitable order, or simultaneously.</p><p id="p-0083" num="0083">The hardware components described herein may be generated by a non-transitory computer readable storage medium having encoded thereon computer readable program code.</p><p id="p-0084" num="0084">Memories storing machine executable data for use in implementing disclosed aspects can be non-transitory media. Non-transitory media can be volatile or non-volatile. Examples of volatile non-transitory media include semiconductor-based memory, such as SRAM or DRAM. Examples of technologies that can be used to implement non-volatile memory include optical and magnetic memory technologies, flash memory, phase change memory, resistive RAM.</p><p id="p-0085" num="0085">A particular reference to &#x201c;logic&#x201d; refers to structure that performs a function or functions. An example of logic includes circuitry that is arranged to perform those function(s). For example, such circuitry may include transistors and/or other hardware elements available in a manufacturing process. Such transistors and/or other elements may be used to form circuitry or structures that implement and/or contain memory, such as registers, flip flops, or latches, logical operators, such as Boolean operations, mathematical operators, such as adders, multipliers, or shifters, and interconnect, by way of example. Such elements may be provided as custom circuits or standard cell libraries, macros, or at other levels of abstraction. Such elements may be interconnected in a specific arrangement. Logic may include circuitry that is fixed function and circuitry can be programmed to perform a function or functions; such programming may be provided from a firmware or software update or control mechanism. Logic identified to perform one function may also include logic that implements a constituent function or sub-process. In an example, hardware logic has circuitry that implements a fixed function operation, or operations, state machine or process.</p><p id="p-0086" num="0086">Any range or device value given herein may be extended or altered without losing the effect sought, as will be apparent to the skilled person.</p><p id="p-0087" num="0087">It will be understood that the benefits and advantages described above may relate to one embodiment or may relate to several embodiments. The embodiments are not limited to those that solve any or all of the stated problems or those that have any or all of the stated benefits and advantages.</p><p id="p-0088" num="0088">Any reference to &#x2018;an&#x2019; item refers to one or more of those items. The term &#x2018;comprising&#x2019; is used herein to mean including the method blocks or elements identified, but that such blocks or elements do not comprise an exclusive list and an apparatus may contain additional blocks or elements and a method may contain additional operations or elements. Furthermore, the blocks, elements and operations are themselves not impliedly closed.</p><p id="p-0089" num="0089">The steps of the methods described herein may be carried out in any suitable order, or simultaneously where appropriate. The arrows between boxes in the figures show one example sequence of method steps but are not intended to exclude other sequences or the performance of multiple steps in parallel. Additionally, individual blocks may be deleted from any of the methods without departing from the spirit and scope of the subject matter described herein. Aspects of any of the examples described above may be combined with aspects of any of the other examples described to form further examples without losing the effect sought. Where elements of the figures are shown connected by arrows, it will be appreciated that these arrows show just one example flow of communications (including data and control messages) between elements. The flow between elements may be in either direction or in both directions.</p><p id="p-0090" num="0090">The applicant hereby discloses in isolation each individual feature described herein and any combination of two or more such features, to the extent that such features or combinations are capable of being carried out based on the present specification as a whole in the light of the common general knowledge of a person skilled in the art, irrespective of whether such features or combinations of features solve any problems disclosed herein. In view of the foregoing description it will be evident to a person skilled in the art that various modifications may be made within the scope of the invention.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A method of controlling operation of a geometry shading stage in a graphics processing system, the method comprising:<claim-text>analyzing a geometry shader to determine whether it preserves connectivity of a topology of primitives input to the geometry shader;</claim-text><claim-text>in response to determining that the geometry shader modifies the topology of primitives input to the geometry shader, generating control state data having a first value;</claim-text><claim-text>in response to determining that the geometry shader does preserve connectivity of the topology of primitives, generating control state data having a second value; and</claim-text><claim-text>wherein the first value of control state data is configured to set the geometry shading stage into a first mode of operation and the second value of control state data is configured to set the geometry shading stage into a second mode of operation.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein in the first mode of operation each primitive output by the geometry shading stage is independent and in the second mode of operation connectivity of primitives output by the geometry shading stage is maintained.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the analysis is implemented in a compiler.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising outputting the control state data, wherein the outputting comprises:<claim-text>providing the control state data as an extension to a stream of graphics data input to the geometry shading stage; and</claim-text><claim-text>passing the control state data to the geometry shading stage in an API.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the method further comprises:<claim-text>receiving the control state data; and</claim-text><claim-text>switching the geometry shading stage between the first mode of operation and the second mode of operation dependent upon a value of the received control state data;</claim-text><claim-text>wherein in the first mode of operation each output primitive is independent and in the second mode of operation connectivity of primitives is maintained.</claim-text></claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The method according to <claim-ref idref="CLM-00005">claim 5</claim-ref>, further comprising, in the second mode of operation:<claim-text>receiving primitive data for a primitive, the primitive data referencing a plurality of vertices;</claim-text><claim-text>identifying those vertices referenced in the primitive data that have not been previously processed by the geometry shading stage;</claim-text><claim-text>processing only the identified vertices; and</claim-text><claim-text>emitting data for the primitive.</claim-text></claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The method according to <claim-ref idref="CLM-00006">claim 6</claim-ref>, further comprising, in the second mode of operation:<claim-text>storing an output from the processing of the identified vertices in a buffer, wherein the output comprises modified vertex data.</claim-text></claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The method according to <claim-ref idref="CLM-00005">claim 5</claim-ref>, further comprising, in the first mode of operation:<claim-text>receiving primitive data for a primitive, the primitive data referencing a plurality of vertices;</claim-text><claim-text>processing each of the plurality of vertices; and</claim-text><claim-text>emitting data for the primitive.</claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The method according to <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the control state data relates to a particular geometry shader and is generated when the geometry shader is compiled.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The method according to <claim-ref idref="CLM-00005">claim 5</claim-ref>, further comprising:<claim-text>receiving primitive data as a stream of graphics data;</claim-text><claim-text>wherein the control state data is received as an extension to the stream of graphics data.</claim-text></claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The method according to <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the control state data is received from an application via an API.</claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the geometry shading stage is operated in the second mode of operation for stereoscopic rendering.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. A processor configured to perform the method as set forth in <claim-ref idref="CLM-00001">claim 1</claim-ref>.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The processor of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the processor is embodied in hardware on an integrated circuit.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. A method of manufacturing a processor as set forth in <claim-ref idref="CLM-00014">claim 14</claim-ref>, comprising inputting into an integrated circuit manufacturing system a computer readable dataset description of a processor as set forth in <claim-ref idref="CLM-00014">claim 14</claim-ref>, which causes the integrated circuit manufacturing system to manufacture said processor.</claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. A non-transitory computer readable storage medium having stored thereon computer readable code configured to cause the method of <claim-ref idref="CLM-00001">claim 1</claim-ref> to be performed when the code is run.</claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. A non-transitory computer readable storage medium having stored thereon a computer readable dataset description of an integrated circuit that, when processed in an integrated circuit manufacturing system, causes the integrated circuit manufacturing system to manufacture a processor configured to perform the method as set forth in <claim-ref idref="CLM-00001">claim 1</claim-ref>.</claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. An integrated circuit manufacturing system configured to manufacture a processor configured to perform the method as set forth in <claim-ref idref="CLM-00001">claim 1</claim-ref>.</claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. An integrated circuit manufacturing system comprising:<claim-text>a computer readable storage medium having stored thereon a computer readable dataset description of an integrated circuit that describes a processor configured to perform the method as set forth in <claim-ref idref="CLM-00001">claim 1</claim-ref>;</claim-text><claim-text>a layout processing system configured to process the integrated circuit description so as to generate a circuit layout description of an integrated circuit embodying the processor; and</claim-text><claim-text>an integrated circuit generation system configured to manufacture the processor according to the circuit layout description.</claim-text></claim-text></claim></claims></us-patent-application>