<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230007270A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230007270</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17896012</doc-number><date>20220825</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><priority-claims><priority-claim sequence="01" kind="regional"><country>EP</country><doc-number>PCT/EP2020/055220</doc-number><date>20200228</date></priority-claim></priority-claims><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>14</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>423</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>174</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>14</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>423</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>174</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e61">DECODER AND CORRESPONDING METHODS TO SIGNAL PICTURE PARTITIONING INFORMATION FOR SLICES</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>PCT/CN2021/077000</doc-number><date>20210220</date></document-id><parent-status>PENDING</parent-status></parent-doc><child-doc><document-id><country>US</country><doc-number>17896012</doc-number></document-id></child-doc></relation></continuation></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Huawei Technologies Co., Ltd.</orgname><address><city>Shenzhen</city><country>CN</country></address></addressbook><residence><country>CN</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>ESENLIK</last-name><first-name>Semih</first-name><address><city>Munich</city><country>DE</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>WANG</last-name><first-name>Biao</first-name><address><city>Munich</city><country>DE</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>KOTRA</last-name><first-name>Anand Meher</first-name><address><city>Munich</city><country>DE</country></address></addressbook></inventor><inventor sequence="03" designation="us-only"><addressbook><last-name>ALSHINA</last-name><first-name>Elena Alexandrovna</first-name><address><city>Munich</city><country>DE</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A method of coding implemented by a decoding device and a decoder are disclosed, the method comprising: obtaining a bitstream for a current picture; obtaining a quantity of tiles in a tile row of the current picture; obtaining a value of an address of a current slice, the current slice is comprised in the current picture; obtaining a value of tileX according to the value of the address of the current slice; parsing an indication value for a slice width from the bitstream for the current picture, when a difference value between the quantity of tiles in the tile row of the current picture and the value of tileX is not equal to a first threshold.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="109.90mm" wi="158.75mm" file="US20230007270A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="220.30mm" wi="165.69mm" orientation="landscape" file="US20230007270A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="136.91mm" wi="130.64mm" orientation="landscape" file="US20230007270A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="246.13mm" wi="160.70mm" orientation="landscape" file="US20230007270A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="252.14mm" wi="175.01mm" orientation="landscape" file="US20230007270A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="207.77mm" wi="157.31mm" orientation="landscape" file="US20230007270A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="209.63mm" wi="137.75mm" orientation="landscape" file="US20230007270A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="144.02mm" wi="124.71mm" orientation="landscape" file="US20230007270A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="134.79mm" wi="128.27mm" orientation="landscape" file="US20230007270A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="236.47mm" wi="129.96mm" orientation="landscape" file="US20230007270A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="191.43mm" wi="73.66mm" orientation="landscape" file="US20230007270A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="148.00mm" wi="107.44mm" orientation="landscape" file="US20230007270A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="150.71mm" wi="132.93mm" orientation="landscape" file="US20230007270A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="187.79mm" wi="113.03mm" orientation="landscape" file="US20230007270A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00014" num="00014"><img id="EMI-D00014" he="92.54mm" wi="174.07mm" orientation="landscape" file="US20230007270A1-20230105-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00015" num="00015"><img id="EMI-D00015" he="167.47mm" wi="117.18mm" orientation="landscape" file="US20230007270A1-20230105-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading><p id="p-0002" num="0001">This application is a continuation of International Application No. PCT/CN2021/077000, filed on Feb. 20, 2021, which claims priority to International Application No. PCT/EP2020/055220, filed on Feb. 28, 2020. The disclosures of the aforementioned applications are hereby incorporated by reference in their entireties.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">TECHNICAL FIELD</heading><p id="p-0003" num="0002">Embodiments of the present application generally relate to the field of picture processing and more particularly to signal picture partitioning information for slices.</p><heading id="h-0003" level="1">BACKGROUND</heading><p id="p-0004" num="0003">Video coding (video encoding and decoding) is used in a wide range of digital video applications, for example broadcast digital TV, video transmission over internet and mobile networks, real-time conversational applications such as video chat, video conferencing, DVD and Blu-ray discs, video content acquisition and editing systems, and camcorders of security applications.</p><p id="p-0005" num="0004">The amount of video data needed to depict even a relatively short video can be substantial, which may result in difficulties when the data is to be streamed or otherwise communicated across a communications network with limited bandwidth capacity. Thus, video data is generally compressed before being communicated across modern day telecommunications networks. The size of a video could also be an issue when the video is stored on a storage device because memory resources may be limited. Video compression devices often use software and/or hardware at the source to code the video data prior to transmission or storage, thereby decreasing the quantity of data needed to represent digital video images. The compressed data is then received at the destination by a video decompression device that decodes the video data. With limited network resources and ever increasing demands of higher video quality, improved compression and decompression techniques that improve compression ratio with little to no sacrifice in picture quality are desirable.</p><heading id="h-0004" level="1">SUMMARY</heading><p id="p-0006" num="0005">Embodiments of the present application provide apparatuses and methods for encoding and decoding according to the independent claims.</p><p id="p-0007" num="0006">The foregoing and other objects are achieved by the subject matter of the independent claims. Further implementation forms are apparent from the dependent claims, the description and the figures.</p><p id="p-0008" num="0007">The first aspect of the present invention provides a method of coding implemented by a decoding device, the method comprising: obtaining a bitstream for a current picture; obtaining a quantity of tiles in a tile row of the current picture; obtaining a value of an address of a slice of the current picture; obtaining a value of tileX according to the value of the address of the slice; parsing an indication value for a slice width from the bitstream for the current picture, when a difference value between the quantity of tiles in the tile row of the current picture and the value of tileX is not equal to a first threshold.</p><p id="p-0009" num="0008">According to embodiments of the present invention, a signaling scheme is disclosed, only there are at least two tile columns, then syntax element for slice width is signaled. Hence, the bitstream utilization and decoding efficiency have been improved.</p><p id="p-0010" num="0009">The first threshold is an integer value, the first threshold may be 0, 1, 2 . . . .</p><p id="p-0011" num="0010">It could be understood that, the quantity of tiles in a tile row is same means as a number of tile columns.</p><p id="p-0012" num="0011">In one implementation, wherein the method further comprises: setting the indication value for the slice width to a default value, when a difference value between the quantity of tiles in the tile row of the current picture and the value of tileX is equal to the first threshold. The default value is an integer value, in an example, the default value may be 0, or 1.</p><p id="p-0013" num="0012">In one implementation, wherein the default value indicates that the width of the slice comprises 1 tile column.</p><p id="p-0014" num="0013">In one implementation, wherein the obtaining a value of tileX according to the value of the address of the slice comprises: obtaining the value of the tileX according to the value of the address of the slice and the quantity of tiles in the tile row of the current picture.</p><p id="p-0015" num="0014">In one implementation, wherein the address of the slice is an index of leftmost tile of the topmost tile row of the slice, wherein the tiles comprised in the current picture are indexed according to a raster scan order.</p><p id="p-0016" num="0015">In one implementation, wherein the value of tileX is obtained according to a modulus operation between the value of the address of the slice and the quantity of tiles in the tile row of the current picture. It could be understood that, in some examples, the condition &#x201c;when a difference value between the quantity of tiles in the tile row of the current picture and the value of tileX is not equal to a first threshold&#x201d; is equal to the condition &#x201c;when a difference value between the quantity of tiles in the tile row of the current picture and the value of modulus operation between the value of the address of the slice and the quantity of tiles in the tile row of the current picture is not equal to a first threshold&#x201d;. Hence, the value of tileX is not calculated at first but is represented according to the result of modulus operation between the value of the address of the slice and the quantity of tiles in the tile row of the current picture.</p><p id="p-0017" num="0016">In one implementation, wherein the value of the address of the slice specify an address of a top-left coordinate of the slice in tile index.</p><p id="p-0018" num="0017">In one implementation, wherein the value of tileX indicates a value of a horizontal coordinate. In an example, the value of tileX indicates a horizontal address in tile index.</p><p id="p-0019" num="0018">In one implementation, wherein the method further comprises: obtaining a quantity of tiles in a tile column of the current picture; obtaining a value of tileY according to the value of the address of the slice; parsing an indication value for a slice height from the bitstream for the current picture, when a difference value between the quantity of tiles in the tile column of the current picture and the value of the tileY is not equal to a second threshold. The second threshold is an integer value, the second threshold may be 0, 1, 2 . . . .</p><p id="p-0020" num="0019">It could be understood that, the quantity of tiles in a tile column is same means as a number of tile rows.</p><p id="p-0021" num="0020">In one implementation, wherein the method further comprises: setting the indication value for the slice height to a preset value, when a difference value between the quantity of tiles in the tile column of the current picture and the value of tileY is equal to the second threshold.</p><p id="p-0022" num="0021">In one implementation, wherein the obtaining a value of tileY according to the value of the address of the slice comprises: obtaining the value of tileY according to the value of the address of the slice and the quantity of tiles in the tile row of the current picture.</p><p id="p-0023" num="0022">In one implementation, wherein the value of tileY is obtained according to an integer division operation between the value of the address of the slice and the quantity of tiles in the tile row of the current picture. In one implementation, wherein the value of tileY indicates a value of a vertical coordinate. It could be understood that, in some examples, the condition &#x201c;when a difference value between the quantity of tiles in the tile column of the current picture and the value of tileY is not equal to a second threshold&#x201d; is equal to the condition &#x201c;when a difference value between the quantity of tiles in the tile column of the current picture and the value of the integer division operation between the value of the address of the slice and the quantity of tiles in the tile column of the current picture is not equal to a second threshold&#x201d;. Hence, the value of tileY is not calculated at first but is represented according to the result of the integer division operation between the value of the address of the slice and the quantity of tiles in the tile row of the current picture. In an example, the value of tileY indicates a vertical address in tile index.</p><p id="p-0024" num="0023">The second aspect of the present invention provides a method of coding implemented by a decoding device, the method comprising: obtaining a bitstream for a current picture; obtaining a quantity of tiles in a tile column of the current picture; obtaining a value of an address of a slice of the current picture; obtaining a value of tileY according to the value of the address of the slice; parsing an indication value for a slice height from the bitstream for the current picture, when a difference value between the quantity of tiles in the tile column of the current picture and the value of tileY is not equal to a second threshold.</p><p id="p-0025" num="0024">The second threshold is an integer value, the second threshold may be 0, 1, 2 . . . .</p><p id="p-0026" num="0025">It could be understood that, the quantity of tiles in a tile column is same means as a number of tile rows.</p><p id="p-0027" num="0026">In one implementation, wherein the method further comprises: setting the indication value for the slice height to a preset value, when a difference value between the quantity of tiles in the tile column of the current picture and the value of tileY is equal to the second threshold. The default value is an integer value, in an example, the default value may be 0, or 1.</p><p id="p-0028" num="0027">In one implementation, wherein the default value indicates that the height of the slice comprises 1 tile row.</p><p id="p-0029" num="0028">In one implementation, wherein the obtaining a value of tileY according to the value of the address of the slice comprises:</p><p id="p-0030" num="0029">obtaining a quantity of tiles in a tile row of the current picture;</p><p id="p-0031" num="0030">obtaining the value of tileY according to the value of the address of the slice and the quantity of tiles in the tile row of the current picture.</p><p id="p-0032" num="0031">In one implementation, wherein the value of tileY indicates a value of a vertical coordinate. In an example, the value of tileY indicates a vertical address in tile index.</p><p id="p-0033" num="0032">In one implementation, wherein the address of the slice is an index of leftmost tile of the topmost tile row of the slice, wherein the tiles comprised in the current picture are indexed according to a raster scan order.</p><p id="p-0034" num="0033">In one implementation, wherein the value of tileY is obtained according to an integer division operation between the value of the address of the slice and the quantity of tiles in the tile row of the current picture.</p><p id="p-0035" num="0034">In one implementation, wherein the value of the address of the slice specify an address of a top-left coordinate of the slice in tile index.</p><p id="p-0036" num="0035">In one implementation, wherein the method further comprises: obtaining a quantity of tiles in a tile row of the current picture; obtaining a value of tileX according to the value of the address of the slice; parsing an indication value for a slice width from the bitstream for the current picture, when a difference value between the quantity of tiles in the tile row of the current picture and the value of the tileX is not equal to a first threshold. The first threshold is an integer value, the first threshold may be 0, 1, 2 . . . .</p><p id="p-0037" num="0036">It could be understood that, the quantity of tiles in a tile row is same means as a number of tile columns.</p><p id="p-0038" num="0037">In one implementation, wherein the method further comprises: setting the indication value for the slice width to a default value, when a difference value between the quantity of tiles in the tile row of the current picture and the value of tileX is equal to the first threshold. The default value is an integer value, in an example, the default value may be 0, or 1.</p><p id="p-0039" num="0038">In one implementation, wherein the default value indicates that the width of the slice comprises 1 tile column.</p><p id="p-0040" num="0039">In one implementation, wherein the obtaining a value of tileX according to the value of the address of the slice comprises: obtaining the value of the tileX according to the value of the address of the slice and the quantity of tiles in the tile row of the current picture.</p><p id="p-0041" num="0040">In one implementation, wherein the address of the slice is an index of leftmost tile of the topmost tile row of the slice, wherein the tiles comprised in the current picture are indexed according to a raster scan order.</p><p id="p-0042" num="0041">In one implementation, wherein the value of tileX is obtained according to a modulus operation between the value of the address of the slice and the quantity of tiles in the tile row of the current picture. It could be understood that, in some examples, the condition &#x201c;when a difference value between the quantity of tiles in the tile row of the current picture and the value of tileX is not equal to a first threshold&#x201d; is equal to the condition &#x201c;when a difference value between the quantity of tiles in the tile row of the current picture and the value of modulus operation between the value of the address of the slice and the quantity of tiles in the tile row of the current picture is not equal to a first threshold&#x201d;. Hence, the value of tileX is not calculated at first but is represented according to the result of modulus operation between the value of the address of the slice and the quantity of tiles in the tile row of the current picture.</p><p id="p-0043" num="0042">In one implementation, wherein the value of the address of the slice specify an address of a top-left coordinate of the slice in tile index.</p><p id="p-0044" num="0043">In one implementation, wherein the value of tileX indicates a value of a horizontal coordinate.</p><p id="p-0045" num="0044">The third aspect of the present invention provides a method of coding implemented by an encoding device, the method comprising: obtaining a quantity of tiles in a tile row of a current picture; obtaining a value of an address of a slice of the current picture; obtaining a value of tileX according to the value of the address of the slice; coding an indication value for a slice width into a bitstream for the current picture, when a difference value between the quantity of tiles in the tile row of the current picture and the value of tileX is not equal to a first threshold.</p><p id="p-0046" num="0045">According to embodiments of the present invention, a signaling scheme is disclosed, only there are at least two tile columns, then syntax element for slice width is signaled. Hence, the bitstream utilization and decoding efficiency have been improved.</p><p id="p-0047" num="0046">The first threshold is an integer value, the first threshold may be 0, 1, 2 . . . .</p><p id="p-0048" num="0047">It could be understood that, the quantity of tiles in a tile row is same means as a number of tile columns.</p><p id="p-0049" num="0048">In one implementation, wherein the obtaining a value of tileX according to the value of the address of the slice comprises: obtaining the value of the tileX according to the value of the address of the slice and the quantity of tiles in the tile row of the current picture.</p><p id="p-0050" num="0049">In one implementation, wherein the address of the slice is an index of leftmost tile of the topmost tile row of the slice, wherein the tiles comprised in the current picture are indexed according to a raster scan order.</p><p id="p-0051" num="0050">In one implementation, wherein the value of tileX is obtained according to a modulus operation between the value of the address of the slice and the quantity of tiles in the tile row of the current picture. It could be understood that, in some examples, the condition &#x201c;when a difference value between the quantity of tiles in the tile row of the current picture and the value of tileX is not equal to a first threshold&#x201d; is equal to the condition &#x201c;when a difference value between the quantity of tiles in the tile row of the current picture and the value of modulus operation between the value of the address of the slice and the quantity of tiles in the tile row of the current picture is not equal to a first threshold&#x201d;. Hence, the value of tileX is not calculated at first but is represented according to the result of modulus operation between the value of the address of the slice and the quantity of tiles in the tile row of the current picture.</p><p id="p-0052" num="0051">In one implementation, wherein the value of the address of the slice specify an address of a top-left coordinate of the slice in tile index.</p><p id="p-0053" num="0052">In one implementation, wherein the value of tileX indicates a value of a horizontal coordinate.</p><p id="p-0054" num="0053">In one implementation, wherein the method further comprises: obtaining a quantity of tiles in a tile column of the current picture; obtaining a value of tileY according to the value of the address of the slice; coding an indication value for a slice height into the bitstream for the current picture, when a difference value between the quantity of tiles in the tile column of the current picture and the value of the tileY is not equal to a second threshold. The second threshold is an integer value, the second threshold may be 0, 1, 2 . . . .</p><p id="p-0055" num="0054">It could be understood that, the quantity of tiles in a tile column is same means as a number of tile rows.</p><p id="p-0056" num="0055">In one implementation, wherein the obtaining a value of tileY according to the value of the address of the slice comprises: obtaining the value of tileY according to the value of the address of the slice and the quantity of tiles in the tile row of the current picture.</p><p id="p-0057" num="0056">In one implementation, wherein the value of tileY is obtained according to an integer division operation between the value of the address of the slice and the quantity of tiles in the tile row of the current picture. In one implementation, wherein the value of tileY indicates a value of a vertical coordinate. It could be understood that, in some examples, the condition &#x201c;when a difference value between the quantity of tiles in the tile column of the current picture and the value of tileY is not equal to a second threshold&#x201d; is equal to the condition &#x201c;when a difference value between the quantity of tiles in the tile column of the current picture and the value of the integer division operation between the value of the address of the slice and the quantity of tiles in the tile row of the current picture is not equal to a second threshold&#x201d;. Hence, the value of tileY is not calculated at first but is represented according to the result of the integer division operation between the value of the address of the slice and the quantity of tiles in the tile column of the current picture.</p><p id="p-0058" num="0057">The fourth aspect of the present invention provides a method of coding implemented by an encoding device, the method comprising: obtaining a quantity of tiles in a tile column of the current picture; obtaining a value of an address of a slice of the current picture; obtaining a value of tileY according to the value of the address of the slice; coding an indication value for a slice height into a bitstream for the current picture, when a difference value between the quantity of tiles in the tile column of the current picture and the value of tileY is not equal to a second threshold.</p><p id="p-0059" num="0058">The second threshold is an integer value, the second threshold may be 0, 1, 2 . . . .</p><p id="p-0060" num="0059">It could be understood that, the quantity of tiles in a tile column is same means as a number of tile rows.</p><p id="p-0061" num="0060">In one implementation, wherein the obtaining a value of tileY according to the value of the address of the slice comprises:</p><p id="p-0062" num="0061">obtaining the value of tileY according to the value of the address of the slice and the quantity of tiles in the tile row of the current picture.</p><p id="p-0063" num="0062">In one implementation, wherein the value of tileY indicates a value of a vertical coordinate.</p><p id="p-0064" num="0063">In one implementation, wherein the address of the slice is an index of leftmost tile of the topmost tile row of the slice, wherein the tiles comprised in the current picture are indexed according to a raster scan order.</p><p id="p-0065" num="0064">In one implementation, wherein the value of tileY is obtained according to an integer division operation between the value of the address of the slice and the quantity of tiles in the tile row of the current picture.</p><p id="p-0066" num="0065">In one implementation, wherein the value of the address of the slice specify an address of a top-left coordinate of the slice in tile index.</p><p id="p-0067" num="0066">In one implementation, wherein the method further comprises: obtaining a quantity of tiles in a tile row of the current picture; obtaining a value of tileX according to the value of the address of the slice; coding an indication value for a slice width into the bitstream for the current picture, when a difference value between the quantity of tiles in the tile row of the current picture and the value of the tileX is not equal to a first threshold. The first threshold is an integer value, the first threshold may be 0, 1, 2 . . . .</p><p id="p-0068" num="0067">It could be understood that, the quantity of tiles in a tile row is same means as a number of tile columns.</p><p id="p-0069" num="0068">In one implementation, wherein the obtaining a value of tileX according to the value of the address of the slice comprises: obtaining the value of the tileX according to the value of the address of the slice and the quantity of tiles in the tile row of the current picture.</p><p id="p-0070" num="0069">In one implementation, wherein the address of the slice is an index of leftmost tile of the topmost tile row of the slice, wherein the tiles comprised in the current picture are indexed according to a raster scan order.</p><p id="p-0071" num="0070">In one implementation, wherein the value of tileX is obtained according to a modulus operation between the value of the address of the slice and the quantity of tiles in the tile row of the current picture. It could be understood that, in some examples, the condition &#x201c;when a difference value between the quantity of tiles in the tile row of the current picture and the value of tileX is not equal to a first threshold&#x201d; is equal to the condition &#x201c;when a difference value between the quantity of tiles in the tile row of the current picture and the value of modulus operation between the value of the address of the slice and the quantity of tiles in the tile row of the current picture is not equal to a first threshold&#x201d;. Hence, the value of tileX is not calculated at first but is represented according to the result of modulus operation between the value of the address of the slice and the quantity of tiles in the tile row of the current picture.</p><p id="p-0072" num="0071">In one implementation, wherein the value of the address of the slice specify an address of a top-left coordinate of the slice in tile index.</p><p id="p-0073" num="0072">In one implementation, wherein the value of tileX indicates a value of a horizontal coordinate.</p><p id="p-0074" num="0073">The fifth aspect of the preset invention provides a video decoding apparatus, the apparatus comprise:</p><p id="p-0075" num="0074">obtaining module, which is configured to obtain a bitstream for a current picture; and</p><p id="p-0076" num="0075">obtaining module is configured to obtain a quantity of tiles in a tile row of the current picture and obtain a value of an address of a slice of the current picture;</p><p id="p-0077" num="0076">calculating module, which is configured to obtain a value of tileX according to the value of the address of the slice;</p><p id="p-0078" num="0077">parsing module, which is configured to parse an indication value for a slice width from the bitstream for the current picture, when a difference value between the quantity of tiles in the tile row of the current picture and the value of tileX is not equal to a first threshold.</p><p id="p-0079" num="0078">The details for each module in the fifth aspect of the preset invention could refer to the embodiments and implementations in the above first aspect of the preset invention.</p><p id="p-0080" num="0079">The sixth aspect of the present invention provides a video decoding device, the decoding device comprise:</p><p id="p-0081" num="0080">obtaining module, which is configured to obtain a bitstream for a current picture; obtaining module is configured to obtain a quantity of tiles in a tile column of the current picture, and obtain a value of an address of a slice of the current picture;</p><p id="p-0082" num="0081">calculating module, which is configured to obtain a value of tileY according to the value of the address of the slice;</p><p id="p-0083" num="0082">parsing module, which is configured to parse an indication value for a slice height from the bitstream for the current picture, when a difference value between the quantity of tiles in the tile column of the current picture and the value of tileY is not equal to a second threshold.</p><p id="p-0084" num="0083">The details for each module in the sixth aspect of the preset invention could refer to the embodiments and implementations in the above second aspect of the preset invention.</p><p id="p-0085" num="0084">The seventh aspect of the present invention provides a video encoding device, the encoding device comprise:</p><p id="p-0086" num="0085">obtaining module, which is configured to obtain a quantity of tiles in a tile row of a current picture; obtaining module is configured to obtaining a value of an address of a slice of the current picture;</p><p id="p-0087" num="0086">calculating module, which is configured to obtain a value of tileX according to the value of the address of the slice;</p><p id="p-0088" num="0087">coding module, which is configured to code an indication value for a slice width into a bitstream for the current picture, when a difference value between the quantity of tiles in the tile row of the current picture and the value of tileX is not equal to a first threshold.</p><p id="p-0089" num="0088">The details for each module in the seventh aspect of the preset invention could refer to the embodiments and implementations in the above third aspect of the preset invention.</p><p id="p-0090" num="0089">The eighth aspect of the present invention provides a video encoding device, the video encoding device comprise: obtaining module, which is configured to obtain a quantity of tiles in a tile column of the current picture; obtaining module is configured to obtain a value of an address of a slice of the current picture;</p><p id="p-0091" num="0090">calculating module, which is configured to obtain a value of tileY according to the value of the address of the slice;</p><p id="p-0092" num="0091">coding module, which is configured to code an indication value for a slice height into a bitstream for the current picture, when a difference value between the quantity of tiles in the tile column of the current picture and the value of tileY is not equal to a second threshold.</p><p id="p-0093" num="0092">The details for each module in the eighth aspect of the preset invention could refer to the embodiments and implementations in the above fourth aspect of the preset invention.</p><p id="p-0094" num="0093">The ninth aspect of the present invention provides a decoder comprising processing circuitry for carrying out the method according to the first aspect, the second aspect and any one of implementation of the first aspect, the second aspect.</p><p id="p-0095" num="0094">The tenth aspect of the present invention provides a decoder comprising processing circuitry for carrying out the method according to the third aspect, the fourth aspect and any one of implementation of the third aspect, the fourth aspect.</p><p id="p-0096" num="0095">The tenth aspect of the present invention provides a computer program product comprising program code for performing the method of the first aspect, the second aspect, the third aspect, the fourth aspect and any one of implementation of the first aspect, the second aspect, the third aspect and the fourth aspect.</p><p id="p-0097" num="0096">The eleventh aspect of the present invention provides a non-transitory computer-readable medium carrying a program code which, when executed by a computer device, causes the computer device to perform the method of the first aspect, the second aspect, the third aspect, the fourth aspect and any one of implementation of the first aspect, the second aspect, the third aspect and the fourth aspect.</p><p id="p-0098" num="0097">The twelfth aspect of the present invention provides a decoder, comprising:</p><p id="p-0099" num="0098">one or more processors; and</p><p id="p-0100" num="0099">a non-transitory computer-readable storage medium coupled to the processors and storing programming for execution by the processors, wherein the programming, when executed by the processors, configures the decoder to carry out the method according to the first aspect, the second aspect and any one of implementation of the first aspect, the second aspect.</p><p id="p-0101" num="0100">The thirteenth aspect of the present invention provides an encoder, comprising:</p><p id="p-0102" num="0101">one or more processors; and</p><p id="p-0103" num="0102">a non-transitory computer-readable storage medium coupled to the processors and storing programming for execution by the processors, wherein the programming, when executed by the processors, configures the decoder to carry out the method according to the third aspect, the fourth aspect and any one of implementation of the third aspect, the fourth aspect.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0104" num="0103">In the following embodiments of the invention are described in more detail with reference to the attached figures and drawings, in which:</p><p id="p-0105" num="0104"><figref idref="DRAWINGS">FIG. <b>1</b>A</figref> is a block diagram showing an example of a video coding system configured to implement embodiments of the invention;</p><p id="p-0106" num="0105"><figref idref="DRAWINGS">FIG. <b>1</b>B</figref> is a block diagram showing another example of a video coding system configured to implement embodiments of the invention;</p><p id="p-0107" num="0106"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a block diagram showing an example of a video encoder configured to implement embodiments of the invention;</p><p id="p-0108" num="0107"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a block diagram showing an example structure of a video decoder configured to implement embodiments of the invention;</p><p id="p-0109" num="0108"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a block diagram illustrating an example of an encoding apparatus or a decoding apparatus;</p><p id="p-0110" num="0109"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a block diagram illustrating another example of an encoding apparatus or a decoding apparatus;</p><p id="p-0111" num="0110"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is an example of a picture divided into CTUs;</p><p id="p-0112" num="0111"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is an example of Tile-based raster scan order of CTUs;</p><p id="p-0113" num="0112"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is an example of picture partitioning;</p><p id="p-0114" num="0113"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is an example of CTU address information in a picture;</p><p id="p-0115" num="0114"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is another example of a picture partitioning;</p><p id="p-0116" num="0115"><figref idref="DRAWINGS">FIG. <b>11</b></figref> is a block diagram showing an example structure of a content supply system <b>3100</b> which realizes a content delivery service;</p><p id="p-0117" num="0116"><figref idref="DRAWINGS">FIG. <b>12</b></figref> is a block diagram showing a structure of an example of a terminal device.</p><p id="p-0118" num="0117"><figref idref="DRAWINGS">FIG. <b>13</b></figref> is a flowchart showing a method embodiment.</p><p id="p-0119" num="0118"><figref idref="DRAWINGS">FIG. <b>14</b></figref> is a block diagram showing an apparatus embodiment.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><p id="p-0120" num="0119">In the following identical reference signs refer to identical or at least functionally equivalent features if not explicitly specified otherwise.</p><heading id="h-0006" level="1">DETAILED DESCRIPTION OF THE EMBODIMENTS</heading><p id="p-0121" num="0120">In the following description, reference is made to the accompanying figures, which form part of the disclosure, and which show, by way of illustration, specific aspects of embodiments of the invention or specific aspects in which embodiments of the present invention may be used. It is understood that embodiments of the invention may be used in other aspects and comprise structural or logical changes not depicted in the figures. The following detailed description, therefore, is not to be taken in a limiting sense, and the scope of the present invention is defined by the appended claims.</p><p id="p-0122" num="0121">For instance, it is understood that a disclosure in connection with a described method may also hold true for a corresponding device or system configured to perform the method and vice versa. For example, if one or a plurality of specific method steps are described, a corresponding device may include one or a plurality of units, e.g. functional units, to perform the described one or plurality of method steps (e.g. one unit performing the one or plurality of steps, or a plurality of units each performing one or more of the plurality of steps), even if such one or more units are not explicitly described or illustrated in the figures. On the other hand, for example, if a specific apparatus is described based on one or a plurality of units, e.g. functional units, a corresponding method may include one step to perform the functionality of the one or plurality of units (e.g. one step performing the functionality of the one or plurality of units, or a plurality of steps each performing the functionality of one or more of the plurality of units), even if such one or plurality of steps are not explicitly described or illustrated in the figures. Further, it is understood that the features of the various exemplary embodiments and/or aspects described herein may be combined with each other, unless specifically noted otherwise.</p><p id="p-0123" num="0122">Video coding typically refers to the processing of a sequence of pictures, which form the video or video sequence. Instead of the term &#x201c;picture&#x201d; the term &#x201c;frame&#x201d; or &#x201c;image&#x201d; may be used as synonyms in the field of video coding. Video coding (or coding in general) comprises two parts video encoding and video decoding. Video encoding is performed at the source side, typically comprising processing (e.g. by compression) the original video pictures to reduce the amount of data required for representing the video pictures (for more efficient storage and/or transmission). Video decoding is performed at the destination side and typically comprises the inverse processing compared to the encoder to reconstruct the video pictures. Embodiments referring to &#x201c;coding&#x201d; of video pictures (or pictures in general) shall be understood to relate to &#x201c;encoding&#x201d; or &#x201c;decoding&#x201d; of video pictures or respective video sequences. The combination of the encoding part and the decoding part is also referred to as CODEC (Coding and Decoding).</p><p id="p-0124" num="0123">In case of lossless video coding, the original video pictures can be reconstructed, i.e. the reconstructed video pictures have the same quality as the original video pictures (assuming no transmission loss or other data loss during storage or transmission). In case of lossy video coding, further compression, e.g. by quantization, is performed, to reduce the amount of data representing the video pictures, which cannot be completely reconstructed at the decoder, i.e. the quality of the reconstructed video pictures is lower or worse compared to the quality of the original video pictures.</p><p id="p-0125" num="0124">Several video coding standards belong to the group of &#x201c;lossy hybrid video codecs&#x201d; (i.e. combine spatial and temporal prediction in the sample domain and 2D transform coding for applying quantization in the transform domain). Each picture of a video sequence is typically partitioned into a set of non-overlapping blocks and the coding is typically performed on a block level. In other words, at the encoder the video is typically processed, i.e. encoded, on a block (video block) level, e.g. by using spatial (intra picture) prediction and/or temporal (inter picture) prediction to generate a prediction block, subtracting the prediction block from the current block (block currently processed/to be processed) to obtain a residual block, transforming the residual block and quantizing the residual block in the transform domain to reduce the amount of data to be transmitted (compression), whereas at the decoder the inverse processing compared to the encoder is applied to the encoded or compressed block to reconstruct the current block for representation. Furthermore, the encoder duplicates the decoder processing loop such that both will generate identical predictions (e.g. intra- and inter predictions) and/or re-constructions for processing, i.e. coding, the subsequent blocks.</p><p id="p-0126" num="0125">In the following embodiments of a video coding system <b>10</b>, a video encoder <b>20</b> and a video decoder <b>30</b> are described based on <figref idref="DRAWINGS">FIGS. <b>1</b> to <b>3</b></figref>.</p><p id="p-0127" num="0126"><figref idref="DRAWINGS">FIG. <b>1</b>A</figref> is a schematic block diagram illustrating an example coding system <b>10</b>, e.g. a video coding system <b>10</b> (or short coding system <b>10</b>) that may utilize techniques of this present application. Video encoder <b>20</b> (or short encoder <b>20</b>) and video decoder <b>30</b> (or short decoder <b>30</b>) of video coding system <b>10</b> represent examples of devices that may be configured to perform techniques in accordance with various examples described in the present application.</p><p id="p-0128" num="0127">As shown in <figref idref="DRAWINGS">FIG. <b>1</b>A</figref>, the coding system <b>10</b> comprises a source device <b>12</b> configured to provide encoded picture data <b>21</b> e.g. to a destination device <b>14</b> for decoding the encoded picture data <b>13</b>.</p><p id="p-0129" num="0128">The source device <b>12</b> comprises an encoder <b>20</b>, and may additionally, i.e. optionally, comprise a picture source <b>16</b>, a pre-processor (or pre-processing unit) <b>18</b>, e.g. a picture pre-processor <b>18</b>, and a communication interface or communication unit <b>22</b>.</p><p id="p-0130" num="0129">The picture source <b>16</b> may comprise or be any kind of picture capturing device, for example a camera for capturing a real-world picture, and/or any kind of a picture generating device, for example a computer-graphics processor for generating a computer animated picture, or any kind of other device for obtaining and/or providing a real-world picture, a computer generated picture (e.g. a screen content, a virtual reality (VR) picture) and/or any combination thereof (e.g. an augmented reality (AR) picture). The picture source may be any kind of memory or storage storing any of the aforementioned pictures.</p><p id="p-0131" num="0130">In distinction to the pre-processor <b>18</b> and the processing performed by the pre-processing unit <b>18</b>, the picture or picture data <b>17</b> may also be referred to as raw picture or raw picture data <b>17</b>.</p><p id="p-0132" num="0131">Pre-processor <b>18</b> is configured to receive the (raw) picture data <b>17</b> and to perform pre-processing on the picture data <b>17</b> to obtain a pre-processed picture <b>19</b> or pre-processed picture data <b>19</b>. Pre-processing performed by the pre-processor <b>18</b> may, e.g., comprise trimming, color format conversion (e.g. from RGB to YCbCr), color correction, or de-noising. It can be understood that the pre-processing unit <b>18</b> may be optional component.</p><p id="p-0133" num="0132">The video encoder <b>20</b> is configured to receive the pre-processed picture data <b>19</b> and provide encoded picture data <b>21</b> (further details will be described below, e.g., based on <figref idref="DRAWINGS">FIG. <b>2</b></figref>).</p><p id="p-0134" num="0133">Communication interface <b>22</b> of the source device <b>12</b> may be configured to receive the encoded picture data <b>21</b> and to transmit the encoded picture data <b>21</b> (or any further processed version thereof) over communication channel <b>13</b> to another device, e.g. the destination device <b>14</b> or any other device, for storage or direct reconstruction.</p><p id="p-0135" num="0134">The destination device <b>14</b> comprises a decoder <b>30</b> (e.g. a video decoder <b>30</b>), and may additionally, i.e. optionally, comprise a communication interface or communication unit <b>28</b>, a post-processor <b>32</b> (or post-processing unit <b>32</b>) and a display device <b>34</b>.</p><p id="p-0136" num="0135">The communication interface <b>28</b> of the destination device <b>14</b> is configured receive the encoded picture data <b>21</b> (or any further processed version thereof), e.g. directly from the source device <b>12</b> or from any other source, e.g. a storage device, e.g. an encoded picture data storage device, and provide the encoded picture data <b>21</b> to the decoder <b>30</b>.</p><p id="p-0137" num="0136">The communication interface <b>22</b> and the communication interface <b>28</b> may be configured to transmit or receive the encoded picture data <b>21</b> or encoded data <b>13</b> via a direct communication link between the source device <b>12</b> and the destination device <b>14</b>, e.g. a direct wired or wireless connection, or via any kind of network, e.g. a wired or wireless network or any combination thereof, or any kind of private and public network, or any kind of combination thereof.</p><p id="p-0138" num="0137">The communication interface <b>22</b> may be, e.g., configured to package the encoded picture data <b>21</b> into an appropriate format, e.g. packets, and/or process the encoded picture data using any kind of transmission encoding or processing for transmission over a communication link or communication network.</p><p id="p-0139" num="0138">The communication interface <b>28</b>, forming the counterpart of the communication interface <b>22</b>, may be, e.g., configured to receive the transmitted data and process the transmission data using any kind of corresponding transmission decoding or processing and/or de-packaging to obtain the encoded picture data <b>21</b>.</p><p id="p-0140" num="0139">Both, communication interface <b>22</b> and communication interface <b>28</b> may be configured as unidirectional communication interfaces as indicated by the arrow for the communication channel <b>13</b> in <figref idref="DRAWINGS">FIG. <b>1</b>A</figref> pointing from the source device <b>12</b> to the destination device <b>14</b>, or bi-directional communication interfaces, and may be configured, e.g. to send and receive messages, e.g. to set up a connection, to acknowledge and exchange any other information related to the communication link and/or data transmission, e.g. encoded picture data transmission.</p><p id="p-0141" num="0140">The decoder <b>30</b> is configured to receive the encoded picture data <b>21</b> and provide decoded picture data <b>31</b> or a decoded picture <b>31</b> (further details will be described below, e.g., based on <figref idref="DRAWINGS">FIG. <b>3</b></figref> or <figref idref="DRAWINGS">FIG. <b>5</b></figref>).</p><p id="p-0142" num="0141">The post-processor <b>32</b> of destination device <b>14</b> is configured to post-process the decoded picture data <b>31</b> (also called reconstructed picture data), e.g. the decoded picture <b>31</b>, to obtain post-processed picture data <b>33</b>, e.g. a post-processed picture <b>33</b>. The post-processing performed by the post-processing unit <b>32</b> may comprise, e.g. color format conversion (e.g. from YCbCr to RGB), color correction, trimming, or re-sampling, or any other processing, e.g. for preparing the decoded picture data <b>31</b> for display, e.g. by display device <b>34</b>.</p><p id="p-0143" num="0142">The display device <b>34</b> of the destination device <b>14</b> is configured to receive the post-processed picture data <b>33</b> for displaying the picture, e.g. to a user or viewer. The display device <b>34</b> may be or comprise any kind of display for representing the reconstructed picture, e.g. an integrated or external display or monitor. The displays may, e.g. comprise liquid crystal displays (LCD), organic light emitting diodes (OLED) displays, plasma displays, projectors, micro LED displays, liquid crystal on silicon (LCoS), digital light processor (DLP) or any kind of other display.</p><p id="p-0144" num="0143">Although <figref idref="DRAWINGS">FIG. <b>1</b>A</figref> depicts the source device <b>12</b> and the destination device <b>14</b> as separate devices, embodiments of devices may also comprise both or both functionalities, the source device <b>12</b> or corresponding functionality and the destination device <b>14</b> or corresponding functionality. In such embodiments the source device <b>12</b> or corresponding functionality and the destination device <b>14</b> or corresponding functionality may be implemented using the same hardware and/or software or by separate hardware and/or software or any combination thereof.</p><p id="p-0145" num="0144">As will be apparent for the skilled person based on the description, the existence and (exact) split of functionalities of the different units or functionalities within the source device <b>12</b> and/or destination device <b>14</b> as shown in <figref idref="DRAWINGS">FIG. <b>1</b>A</figref> may vary depending on the actual device and application.</p><p id="p-0146" num="0145">The encoder <b>20</b> (e.g. a video encoder <b>20</b>) or the decoder <b>30</b> (e.g. a video decoder <b>30</b>) or both encoder <b>20</b> and decoder <b>30</b> may be implemented via processing circuitry as shown in <figref idref="DRAWINGS">FIG. <b>1</b>B</figref>, such as one or more microprocessors, digital signal processors (DSPs), application-specific integrated circuits (ASICs), field-programmable gate arrays (FPGAs), discrete logic, hardware, video coding dedicated or any combinations thereof. The encoder <b>20</b> may be implemented via processing circuitry <b>46</b> to embody the various modules as discussed with respect to encoder <b>20</b> of <figref idref="DRAWINGS">FIG. <b>2</b></figref> and/or any other encoder system or subsystem described herein. The decoder <b>30</b> may be implemented via processing circuitry <b>46</b> to embody the various modules as discussed with respect to decoder <b>30</b> of <figref idref="DRAWINGS">FIG. <b>3</b></figref> and/or any other decoder system or subsystem described herein. The processing circuitry may be configured to perform the various operations as discussed later. As shown in <figref idref="DRAWINGS">FIG. <b>5</b></figref>, if the techniques are implemented partially in software, a device may store instructions for the software in a suitable, non-transitory computer-readable storage medium and may execute the instructions in hardware using one or more processors to perform the techniques of this disclosure. Either of video encoder <b>20</b> and video decoder <b>30</b> may be integrated as part of a combined encoder/decoder (CODEC) in a single device, for example, as shown in <figref idref="DRAWINGS">FIG. <b>1</b>B</figref>.</p><p id="p-0147" num="0146">Source device <b>12</b> and destination device <b>14</b> may comprise any of a wide range of devices, including any kind of handheld or stationary devices, e.g. notebook or laptop computers, mobile phones, smart phones, tablets or tablet computers, cameras, desktop computers, set-top boxes, televisions, display devices, digital media players, video gaming consoles, video streaming devices (such as content services servers or content delivery servers), broadcast receiver device, broadcast transmitter device, or the like and may use no or any kind of operating system. In some cases, the source device <b>12</b> and the destination device <b>14</b> may be equipped for wireless communication. Thus, the source device <b>12</b> and the destination device <b>14</b> may be wireless communication devices.</p><p id="p-0148" num="0147">In some cases, video coding system <b>10</b> illustrated in <figref idref="DRAWINGS">FIG. <b>1</b>A</figref> is merely an example and the techniques of the present application may apply to video coding settings (e.g., video encoding or video decoding) that do not necessarily include any data communication between the encoding and decoding devices. In other examples, data is retrieved from a local memory, streamed over a network, or the like. A video encoding device may encode and store data to memory, and/or a video decoding device may retrieve and decode data from memory. In some examples, the encoding and decoding is performed by devices that do not communicate with one another, but simply encode data to memory and/or retrieve and decode data from memory.</p><p id="p-0149" num="0148">For convenience of description, embodiments of the invention are described herein, for example, by reference to High-Efficiency Video Coding (HEVC) or to the reference software of Versatile Video coding (VVC), the next generation video coding standard developed by the Joint Collaboration Team on Video Coding (JCT-VC) of ITU-T Video Coding Experts Group (VCEG) and ISO/IEC Motion Picture Experts Group (MPEG). One of ordinary skill in the art will understand that embodiments of the invention are not limited to HEVC or VVC.</p><p id="p-0150" num="0149">Encoder and Encoding Method</p><p id="p-0151" num="0150"><figref idref="DRAWINGS">FIG. <b>2</b></figref> shows a schematic block diagram of an example video encoder <b>20</b> that is configured to implement the techniques of the present application. In the example of <figref idref="DRAWINGS">FIG. <b>2</b></figref>, the video encoder <b>20</b> comprises an input <b>201</b> (or input interface <b>201</b>), a residual calculation unit <b>204</b>, a transform processing unit <b>206</b>, a quantization unit <b>208</b>, an inverse quantization unit <b>210</b>, and inverse transform processing unit <b>212</b>, a reconstruction unit <b>214</b>, a loop filter unit <b>220</b>, a decoded picture buffer (DPB) <b>230</b>, a mode selection unit <b>260</b>, an entropy encoding unit <b>270</b> and an output <b>272</b> (or output interface <b>272</b>). The mode selection unit <b>260</b> may include an inter prediction unit <b>244</b>, an intra prediction unit <b>254</b> and a partitioning unit <b>262</b>. Inter prediction unit <b>244</b> may include a motion estimation unit and a motion compensation unit (not shown). A video encoder <b>20</b> as shown in <figref idref="DRAWINGS">FIG. <b>2</b></figref> may also be referred to as hybrid video encoder or a video encoder according to a hybrid video codec.</p><p id="p-0152" num="0151">The residual calculation unit <b>204</b>, the transform processing unit <b>206</b>, the quantization unit <b>208</b>, the mode selection unit <b>260</b> may be referred to as forming a forward signal path of the encoder <b>20</b>, whereas the inverse quantization unit <b>210</b>, the inverse transform processing unit <b>212</b>, the reconstruction unit <b>214</b>, the buffer <b>216</b>, the loop filter <b>220</b>, the decoded picture buffer (DPB) <b>230</b>, the inter prediction unit <b>244</b> and the intra-prediction unit <b>254</b> may be referred to as forming a backward signal path of the video encoder <b>20</b>, wherein the backward signal path of the video encoder <b>20</b> corresponds to the signal path of the decoder (see video decoder <b>30</b> in <figref idref="DRAWINGS">FIG. <b>3</b></figref>). The inverse quantization unit <b>210</b>, the inverse transform processing unit <b>212</b>, the reconstruction unit <b>214</b>, the loop filter <b>220</b>, the decoded picture buffer (DPB) <b>230</b>, the inter prediction unit <b>244</b> and the intra-prediction unit <b>254</b> are also referred to forming the &#x201c;built-in decoder&#x201d; of video encoder <b>20</b>.</p><p id="p-0153" num="0152">Pictures &#x26; Picture Partitioning (Pictures &#x26; Blocks)</p><p id="p-0154" num="0153">The encoder <b>20</b> may be configured to receive, e.g. via input <b>201</b>, a picture <b>17</b> (or picture data <b>17</b>), e.g. picture of a sequence of pictures forming a video or video sequence. The received picture or picture data may also be a pre-processed picture <b>19</b> (or pre-processed picture data <b>19</b>). For sake of simplicity the following description refers to the picture <b>17</b>. The picture <b>17</b> may also be referred to as current picture or picture to be coded (in particular in video coding to distinguish the current picture from other pictures, e.g. previously encoded and/or decoded pictures of the same video sequence, i.e. the video sequence which also comprises the current picture).</p><p id="p-0155" num="0154">A (digital) picture is or can be regarded as a two-dimensional array or matrix of samples with intensity values. A sample in the array may also be referred to as pixel (short form of picture element) or a pel. The number of samples in horizontal and vertical direction (or axis) of the array or picture define the size and/or resolution of the picture. For representation of color, typically three color components are employed, i.e. the picture may be represented or include three sample arrays. In RBG format or color space a picture comprises a corresponding red, green and blue sample array. However, in video coding each pixel is typically represented in a luminance and chrominance format or color space, e.g. YCbCr, which comprises a luminance component indicated by Y (sometimes also L is used instead) and two chrominance components indicated by Cb and Cr. The luminance (or short luma) component Y represents the brightness or grey level intensity (e.g. like in a grey-scale picture), while the two chrominance (or short chroma) components Cb and Cr represent the chromaticity or color information components. Accordingly, a picture in YCbCr format comprises a luminance sample array of luminance sample values (Y), and two chrominance sample arrays of chrominance values (Cb and Cr). Pictures in RGB format may be converted or transformed into YCbCr format and vice versa, the process is also known as color transformation or conversion. If a picture is monochrome, the picture may comprise only a luminance sample array. Accordingly, a picture may be, for example, an array of luma samples in monochrome format or an array of luma samples and two corresponding arrays of chroma samples in 4:2:0, 4:2:2, and 4:4:4 colour format.</p><p id="p-0156" num="0155">Embodiments of the video encoder <b>20</b> may comprise a picture partitioning unit (not depicted in <figref idref="DRAWINGS">FIG. <b>2</b></figref>) configured to partition the picture <b>17</b> into a plurality of (typically non-overlapping) picture blocks <b>203</b>. These blocks may also be referred to as root blocks, macro blocks (H.264/AVC) or coding tree blocks (CTB) or coding tree units (CTU) (H.265/HEVC and VVC). The picture partitioning unit may be configured to use the same block size for all pictures of a video sequence and the corresponding grid defining the block size, or to change the block size between pictures or subsets or groups of pictures, and partition each picture into the corresponding blocks.</p><p id="p-0157" num="0156">In further embodiments, the video encoder may be configured to receive directly a block <b>203</b> of the picture <b>17</b>, e.g. one, several or all blocks forming the picture <b>17</b>. The picture block <b>203</b> may also be referred to as current picture block or picture block to be coded.</p><p id="p-0158" num="0157">Like the picture <b>17</b>, the picture block <b>203</b> again is or can be regarded as a two-dimensional array or matrix of samples with intensity values (sample values), although of smaller dimension than the picture <b>17</b>. In other words, the block <b>203</b> may comprise, e.g., one sample array (e.g. a luma array in case of a monochrome picture <b>17</b>, or a luma or chroma array in case of a color picture) or three sample arrays (e.g. a luma and two chroma arrays in case of a color picture <b>17</b>) or any other number and/or kind of arrays depending on the color format applied. The number of samples in horizontal and vertical direction (or axis) of the block <b>203</b> define the size of block <b>203</b>. Accordingly, a block may, for example, an M&#xd7;N (M-column by N-row) array of samples, or an M&#xd7;N array of transform coefficients.</p><p id="p-0159" num="0158">Embodiments of the video encoder <b>20</b> as shown in <figref idref="DRAWINGS">FIG. <b>2</b></figref> may be configured to encode the picture <b>17</b> block by block, e.g. the encoding and prediction is performed per block <b>203</b>.</p><p id="p-0160" num="0159">Embodiments of the video encoder <b>20</b> as shown in <figref idref="DRAWINGS">FIG. <b>2</b></figref> may be further configured to partition and/or encode the picture by using slices (also referred to as video slices), wherein a picture may be partitioned into or encoded using one or more slices (typically non-overlapping), and each slice may comprise one or more blocks (e.g. CTUs).</p><p id="p-0161" num="0160">Embodiments of the video encoder <b>20</b> as shown in <figref idref="DRAWINGS">FIG. <b>2</b></figref> may be further configured to partition and/or encode the picture by using tile groups (also referred to as video tile groups) and/or tiles (also referred to as video tiles), wherein a picture may be partitioned into or encoded using one or more tile groups (typically non-overlapping), and each tile group may comprise, e.g. one or more blocks (e.g. CTUs) or one or more tiles, wherein each tile, e.g. may be of rectangular shape and may comprise one or more blocks (e.g. CTUs), e.g. complete or fractional blocks.</p><p id="p-0162" num="0161">Residual Calculation</p><p id="p-0163" num="0162">The residual calculation unit <b>204</b> may be configured to calculate a residual block <b>205</b> (also referred to as residual <b>205</b>) based on the picture block <b>203</b> and a prediction block <b>265</b> (further details about the prediction block <b>265</b> are provided later), e.g. by subtracting sample values of the prediction block <b>265</b> from sample values of the picture block <b>203</b>, sample by sample (pixel by pixel) to obtain the residual block <b>205</b> in the sample domain.</p><p id="p-0164" num="0163">Transform</p><p id="p-0165" num="0164">The transform processing unit <b>206</b> may be configured to apply a transform, e.g. a discrete cosine transform (DCT) or discrete sine transform (DST), on the sample values of the residual block <b>205</b> to obtain transform coefficients <b>207</b> in a transform domain. The transform coefficients <b>207</b> may also be referred to as transform residual coefficients and represent the residual block <b>205</b> in the transform domain.</p><p id="p-0166" num="0165">The transform processing unit <b>206</b> may be configured to apply integer approximations of DCT/DST, such as the transforms specified for H.265/HEVC. Compared to an orthogonal DCT transform, such integer approximations are typically scaled by a certain factor. In order to preserve the norm of the residual block which is processed by forward and inverse transforms, additional scaling factors are applied as part of the transform process. The scaling factors are typically chosen based on certain constraints like scaling factors being a power of two for shift operations, bit depth of the transform coefficients, tradeoff between accuracy and implementation costs, etc. Specific scaling factors are, for example, specified for the inverse transform, e.g. by inverse transform processing unit <b>212</b> (and the corresponding inverse transform, e.g. by inverse transform processing unit <b>312</b> at video decoder <b>30</b>) and corresponding scaling factors for the forward transform, e.g. by transform processing unit <b>206</b>, at an encoder <b>20</b> may be specified accordingly.</p><p id="p-0167" num="0166">Embodiments of the video encoder <b>20</b> (respectively transform processing unit <b>206</b>) may be configured to output transform parameters, e.g. a type of transform or transforms, e.g. directly or encoded or compressed via the entropy encoding unit <b>270</b>, so that, e.g., the video decoder <b>30</b> may receive and use the transform parameters for decoding.</p><p id="p-0168" num="0167">Quantization</p><p id="p-0169" num="0168">The quantization unit <b>208</b> may be configured to quantize the transform coefficients <b>207</b> to obtain quantized coefficients <b>209</b>, e.g. by applying scalar quantization or vector quantization. The quantized coefficients <b>209</b> may also be referred to as quantized transform coefficients <b>209</b> or quantized residual coefficients <b>209</b>.</p><p id="p-0170" num="0169">The quantization process may reduce the bit depth associated with some or all of the transform coefficients <b>207</b>. For example, an n-bit transform coefficient may be rounded down to an m-bit Transform coefficient during quantization, where n is greater than m. The degree of quantization may be modified by adjusting a quantization parameter (QP). For example for scalar quantization, different scaling may be applied to achieve finer or coarser quantization. Smaller quantization step sizes correspond to finer quantization, whereas larger quantization step sizes correspond to coarser quantization. The applicable quantization step size may be indicated by a quantization parameter (QP). The quantization parameter may for example be an index to a predefined set of applicable quantization step sizes. For example, small quantization parameters may correspond to fine quantization (small quantization step sizes) and large quantization parameters may correspond to coarse quantization (large quantization step sizes) or vice versa. The quantization may include division by a quantization step size and a corresponding and/or the inverse dequantization, e.g. by inverse quantization unit <b>210</b>, may include multiplication by the quantization step size. Embodiments according to some standards, e.g. HEVC, may be configured to use a quantization parameter to determine the quantization step size. Generally, the quantization step size may be calculated based on a quantization parameter using a fixed point approximation of an equation including division. Additional scaling factors may be introduced for quantization and dequantization to restore the norm of the residual block, which might get modified because of the scaling used in the fixed point approximation of the equation for quantization step size and quantization parameter. In one example implementation, the scaling of the inverse transform and dequantization might be combined. Alternatively, customized quantization tables may be used and signaled from an encoder to a decoder, e.g. in a bitstream. The quantization is a lossy operation, wherein the loss increases with increasing quantization step sizes.</p><p id="p-0171" num="0170">Embodiments of the video encoder <b>20</b> (respectively quantization unit <b>208</b>) may be configured to output quantization parameters (QP), e.g. directly or encoded via the entropy encoding unit <b>270</b>, so that, e.g., the video decoder <b>30</b> may receive and apply the quantization parameters for decoding.</p><p id="p-0172" num="0171">Inverse Quantization</p><p id="p-0173" num="0172">The inverse quantization unit <b>210</b> is configured to apply the inverse quantization of the quantization unit <b>208</b> on the quantized coefficients to obtain dequantized coefficients <b>211</b>, e.g. by applying the inverse of the quantization scheme applied by the quantization unit <b>208</b> based on or using the same quantization step size as the quantization unit <b>208</b>. The dequantized coefficients <b>211</b> may also be referred to as dequantized residual coefficients <b>211</b> and correspond&#x2014;although typically not identical to the transform coefficients due to the loss by quantization&#x2014;to the transform coefficients <b>207</b>.</p><p id="p-0174" num="0173">Inverse Transform</p><p id="p-0175" num="0174">The inverse transform processing unit <b>212</b> is configured to apply the inverse transform of the transform applied by the transform processing unit <b>206</b>, e.g. an inverse discrete cosine transform (DCT) or inverse discrete sine transform (DST) or other inverse transforms, to obtain a reconstructed residual block <b>213</b> (or corresponding dequantized coefficients <b>213</b>) in the sample domain. The reconstructed residual block <b>213</b> may also be referred to as transform block <b>213</b>.</p><p id="p-0176" num="0175">Reconstruction</p><p id="p-0177" num="0176">The reconstruction unit <b>214</b> (e.g. adder or summer <b>214</b>) is configured to add the transform block <b>213</b> (i.e. reconstructed residual block <b>213</b>) to the prediction block <b>265</b> to obtain a reconstructed block <b>215</b> in the sample domain, e.g. by adding&#x2014;sample by sample&#x2014;the sample values of the reconstructed residual block <b>213</b> and the sample values of the prediction block <b>265</b>.</p><p id="p-0178" num="0177">Filtering</p><p id="p-0179" num="0178">The loop filter unit <b>220</b> (or short &#x201c;loop filter&#x201d; <b>220</b>), is configured to filter the reconstructed block <b>215</b> to obtain a filtered block <b>221</b>, or in general, to filter reconstructed samples to obtain filtered samples. The loop filter unit is, e.g., configured to smooth pixel transitions, or otherwise improve the video quality. The loop filter unit <b>220</b> may comprise one or more loop filters such as a de-blocking filter, a sample-adaptive offset (SAO) filter or one or more other filters, e.g. a bilateral filter, an adaptive loop filter (ALF), a sharpening, a smoothing filters or a collaborative filters, or any combination thereof. Although the loop filter unit <b>220</b> is shown in <figref idref="DRAWINGS">FIG. <b>2</b></figref> as being an in loop filter, in other configurations, the loop filter unit <b>220</b> may be implemented as a post loop filter. The filtered block <b>221</b> may also be referred to as filtered reconstructed block <b>221</b>.</p><p id="p-0180" num="0179">Embodiments of the video encoder <b>20</b> (respectively loop filter unit <b>220</b>) may be configured to output loop filter parameters (such as sample adaptive offset information), e.g. directly or encoded via the entropy encoding unit <b>270</b>, so that, e.g., a decoder <b>30</b> may receive and apply the same loop filter parameters or respective loop filters for decoding.</p><p id="p-0181" num="0180">Decoded Picture Buffer</p><p id="p-0182" num="0181">The decoded picture buffer (DPB) <b>230</b> may be a memory that stores reference pictures, or in general reference picture data, for encoding video data by video encoder <b>20</b>. The DPB <b>230</b> may be formed by any of a variety of memory devices, such as dynamic random access memory (DRAM), including synchronous DRAM (SDRAM), magnetoresistive RAM (MRAM), resistive RAM (RRAM), or other types of memory devices. The decoded picture buffer (DPB) <b>230</b> may be configured to store one or more filtered blocks <b>221</b>. The decoded picture buffer <b>230</b> may be further configured to store other previously filtered blocks, e.g. previously reconstructed and filtered blocks <b>221</b>, of the same current picture or of different pictures, e.g. previously reconstructed pictures, and may provide complete previously reconstructed, i.e. decoded, pictures (and corresponding reference blocks and samples) and/or a partially reconstructed current picture (and corresponding reference blocks and samples), for example for inter prediction. The decoded picture buffer (DPB) <b>230</b> may be also configured to store one or more unfiltered reconstructed blocks <b>215</b>, or in general unfiltered reconstructed samples, e.g. if the reconstructed block <b>215</b> is not filtered by loop filter unit <b>220</b>, or any other further processed version of the reconstructed blocks or samples.</p><p id="p-0183" num="0182">Mode Selection (Partitioning &#x26; Prediction)</p><p id="p-0184" num="0183">The mode selection unit <b>260</b> comprises partitioning unit <b>262</b>, inter-prediction unit <b>244</b> and intra-prediction unit <b>254</b>, and is configured to receive or obtain original picture data, e.g. an original block <b>203</b> (current block <b>203</b> of the current picture <b>17</b>), and reconstructed picture data, e.g. filtered and/or unfiltered reconstructed samples or blocks of the same (current) picture and/or from one or a plurality of previously decoded pictures, e.g. from decoded picture buffer <b>230</b> or other buffers (e.g. line buffer, not shown). The reconstructed picture data is used as reference picture data for prediction, e.g. inter-prediction or intra-prediction, to obtain a prediction block <b>265</b> or predictor <b>265</b>.</p><p id="p-0185" num="0184">Mode selection unit <b>260</b> may be configured to determine or select a partitioning for a current block prediction mode (including no partitioning) and a prediction mode (e.g. an intra or inter prediction mode) and generate a corresponding prediction block <b>265</b>, which is used for the calculation of the residual block <b>205</b> and for the reconstruction of the reconstructed block <b>215</b>.</p><p id="p-0186" num="0185">Embodiments of the mode selection unit <b>260</b> may be configured to select the partitioning and the prediction mode (e.g. from those supported by or available for mode selection unit <b>260</b>), which provide the best match or in other words the minimum residual (minimum residual means better compression for transmission or storage), or a minimum signaling overhead (minimum signaling overhead means better compression for transmission or storage), or which considers or balances both. The mode selection unit <b>260</b> may be configured to determine the partitioning and prediction mode based on rate distortion optimization (RDO), i.e. select the prediction mode which provides a minimum rate distortion. Terms like &#x201c;best&#x201d;, &#x201c;minimum&#x201d;, &#x201c;optimum&#x201d; etc. in this context do not necessarily refer to an overall &#x201c;best&#x201d;, &#x201c;minimum&#x201d;, &#x201c;optimum&#x201d;, etc. but may also refer to the fulfillment of a termination or selection criterion like a value exceeding or falling below a threshold or other constraints leading potentially to a &#x201c;sub-optimum selection&#x201d; but reducing complexity and processing time.</p><p id="p-0187" num="0186">In other words, the partitioning unit <b>262</b> may be configured to partition the block <b>203</b> into smaller block partitions or sub-blocks (which form again blocks), e.g. iteratively using quad-tree-partitioning (QT), binary partitioning (BT) or triple-tree-partitioning (TT) or any combination thereof, and to perform, e.g., the prediction for each of the block partitions or sub-blocks, wherein the mode selection comprises the selection of the tree-structure of the partitioned block <b>203</b> and the prediction modes are applied to each of the block partitions or sub-blocks.</p><p id="p-0188" num="0187">In the following the partitioning (e.g. by partitioning unit <b>260</b>) and prediction processing (by inter-prediction unit <b>244</b> and intra-prediction unit <b>254</b>) performed by an example video encoder <b>20</b> will be explained in more detail.</p><p id="p-0189" num="0188">Partitioning</p><p id="p-0190" num="0189">The partitioning unit <b>262</b> may partition (or split) a current block <b>203</b> into smaller partitions, e.g. smaller blocks of square or rectangular size. These smaller blocks (which may also be referred to as sub-blocks) may be further partitioned into even smaller partitions. This is also referred to tree-partitioning or hierarchical tree-partitioning, wherein a root block, e.g. at root tree-level 0 (hierarchy-level 0, depth 0), may be recursively partitioned, e.g. partitioned into two or more blocks of a next lower tree-level, e.g. nodes at tree-level 1 (hierarchy-level 1, depth 1), wherein these blocks may be again partitioned into two or more blocks of a next lower level, e.g. tree-level 2 (hierarchy-level 2, depth 2), etc. until the partitioning is terminated, e.g. because a termination criterion is fulfilled, e.g. a maximum tree depth or minimum block size is reached. Blocks which are not further partitioned are also referred to as leaf-blocks or leaf nodes of the tree. A tree using partitioning into two partitions is referred to as binary-tree (BT), a tree using partitioning into three partitions is referred to as ternary-tree (TT), and a tree using partitioning into four partitions is referred to as quad-tree (QT).</p><p id="p-0191" num="0190">As mentioned before, the term &#x201c;block&#x201d; as used herein may be a portion, in particular a square or rectangular portion, of a picture. With reference, for example, to HEVC and VVC, the block may be or correspond to a coding tree unit (CTU), a coding unit (CU), prediction unit (PU), and transform unit (TU) and/or to the corresponding blocks, e.g. a coding tree block (CTB), a coding block (CB), a transform block (TB) or prediction block (PB).</p><p id="p-0192" num="0191">For example, a coding tree unit (CTU) may be or comprise a CTB of luma samples, two corresponding CTBs of chroma samples of a picture that has three sample arrays, or a CTB of samples of a monochrome picture or a picture that is coded using three separate colour planes and syntax structures used to code the samples. Correspondingly, a coding tree block (CTB) may be an N&#xd7;N block of samples for some value of N such that the division of a component into CTBs is a partitioning. A coding unit (CU) may be or comprise a coding block of luma samples, two corresponding coding blocks of chroma samples of a picture that has three sample arrays, or a coding block of samples of a monochrome picture or a picture that is coded using three separate colour planes and syntax structures used to code the samples. Correspondingly a coding block (CB) may be an M&#xd7;N block of samples for some values of M and N such that the division of a CTB into coding blocks is a partitioning.</p><p id="p-0193" num="0192">In embodiments, e.g., according to HEVC, a coding tree unit (CTU) may be split into CUs by using a quad-tree structure denoted as coding tree. The decision whether to code a picture area using inter-picture (temporal) or intra-picture (spatial) prediction is made at the CU level. Each CU can be further split into one, two or four PUs according to the PU splitting type. Inside one PU, the same prediction process is applied and the relevant information is transmitted to the decoder on a PU basis. After obtaining the residual block by applying the prediction process based on the PU splitting type, a CU can be partitioned into transform units (TUs) according to another quadtree structure similar to the coding tree for the CU.</p><p id="p-0194" num="0193">In embodiments, e.g., according to the latest video coding standard currently in development, which is referred to as Versatile Video Coding (VVC), a combined Quad-tree and binary tree (QTBT) partitioning is for example used to partition a coding block. In the QTBT block structure, a CU can have either a square or rectangular shape. For example, a coding tree unit (CTU) is first partitioned by a quadtree structure. The quadtree leaf nodes are further partitioned by a binary tree or ternary (or triple) tree structure. The partitioning tree leaf nodes are called coding units (CUs), and that segmentation is used for prediction and transform processing without any further partitioning. This means that the CU, PU and TU have the same block size in the QTBT coding block structure. In parallel, multiple partition, for example, triple tree partition may be used together with the QTBT block structure.</p><p id="p-0195" num="0194">In one example, the mode selection unit <b>260</b> of video encoder <b>20</b> may be configured to perform any combination of the partitioning techniques described herein.</p><p id="p-0196" num="0195">As described above, the video encoder <b>20</b> is configured to determine or select the best or an optimum prediction mode from a set of (e.g. pre-determined) prediction modes. The set of prediction modes may comprise, e.g., intra-prediction modes and/or inter-prediction modes.</p><p id="p-0197" num="0196">Intra-Prediction</p><p id="p-0198" num="0197">The set of intra-prediction modes may comprise 35 different intra-prediction modes, e.g. non-directional modes like DC (or mean) mode and planar mode, or directional modes, e.g. as defined in HEVC, or may comprise 67 different intra-prediction modes, e.g. non-directional modes like DC (or mean) mode and planar mode, or directional modes, e.g. as defined for VVC.</p><p id="p-0199" num="0198">The intra-prediction unit <b>254</b> is configured to use reconstructed samples of neighboring blocks of the same current picture to generate an intra-prediction block <b>265</b> according to an intra-prediction mode of the set of intra-prediction modes.</p><p id="p-0200" num="0199">The intra prediction unit <b>254</b> (or in general the mode selection unit <b>260</b>) is further configured to output intra-prediction parameters (or in general information indicative of the selected intra prediction mode for the block) to the entropy encoding unit <b>270</b> in form of syntax elements <b>266</b> for inclusion into the encoded picture data <b>21</b>, so that, e.g., the video decoder <b>30</b> may receive and use the prediction parameters for decoding.</p><p id="p-0201" num="0200">Inter-Prediction</p><p id="p-0202" num="0201">The set of (or possible) inter-prediction modes depends on the available reference pictures (i.e. previous at least partially decoded pictures, e.g. stored in DBP <b>230</b>) and other inter-prediction parameters, e.g. whether the whole reference picture or only a part, e.g. a search window area around the area of the current block, of the reference picture is used for searching for a best matching reference block, and/or e.g. whether pixel interpolation is applied, e.g. half/semi-pel and/or quarter-pel interpolation, or not.</p><p id="p-0203" num="0202">Additional to the above prediction modes, skip mode and/or direct mode may be applied.</p><p id="p-0204" num="0203">The inter prediction unit <b>244</b> may include a motion estimation (ME) unit and a motion compensation (MC) unit (both not shown in <figref idref="DRAWINGS">FIG. <b>2</b></figref>). The motion estimation unit may be configured to receive or obtain the picture block <b>203</b> (current picture block <b>203</b> of the current picture <b>17</b>) and a decoded picture <b>231</b>, or at least one or a plurality of previously reconstructed blocks, e.g. reconstructed blocks of one or a plurality of other/different previously decoded pictures <b>231</b>, for motion estimation. E.g. a video sequence may comprise the current picture and the previously decoded pictures <b>231</b>, or in other words, the current picture and the previously decoded pictures <b>231</b> may be part of or form a sequence of pictures forming a video sequence.</p><p id="p-0205" num="0204">The encoder <b>20</b> may, e.g., be configured to select a reference block from a plurality of reference blocks of the same or different pictures of the plurality of other pictures and provide a reference picture (or reference picture index) and/or an offset (spatial offset) between the position (x, y coordinates) of the reference block and the position of the current block as inter prediction parameters to the motion estimation unit. This offset is also called motion vector (MV).</p><p id="p-0206" num="0205">The motion compensation unit is configured to obtain, e.g. receive, an inter prediction parameter and to perform inter prediction based on or using the inter prediction parameter to obtain an inter prediction block <b>265</b>. Motion compensation, performed by the motion compensation unit, may involve fetching or generating the prediction block based on the motion/block vector determined by motion estimation, possibly performing interpolations to sub-pixel precision. Interpolation filtering may generate additional pixel samples from known pixel samples, thus potentially increasing the number of candidate prediction blocks that may be used to code a picture block. Upon receiving the motion vector for the PU of the current picture block, the motion compensation unit may locate the prediction block to which the motion vector points in one of the reference picture lists.</p><p id="p-0207" num="0206">The motion compensation unit may also generate syntax elements associated with the blocks and video slices for use by video decoder <b>30</b> in decoding the picture blocks of the video slice. In addition or as an alternative to slices and respective syntax elements, tile groups and/or tiles and respective syntax elements may be generated or used.</p><p id="p-0208" num="0207">Entropy Coding</p><p id="p-0209" num="0208">The entropy encoding unit <b>270</b> is configured to apply, for example, an entropy encoding algorithm or scheme (e.g. a variable length coding (VLC) scheme, an context adaptive VLC scheme (CAVLC), an arithmetic coding scheme, a binarization, a context adaptive binary arithmetic coding (CABAC), syntax-based context-adaptive binary arithmetic coding (SBAC), probability interval partitioning entropy (PIPE) coding or another entropy encoding methodology or technique) or bypass (no compression) on the quantized coefficients <b>209</b>, inter prediction parameters, intra prediction parameters, loop filter parameters and/or other syntax elements to obtain encoded picture data <b>21</b> which can be output via the output <b>272</b>, e.g. in the form of an encoded bitstream <b>21</b>, so that, e.g., the video decoder <b>30</b> may receive and use the parameters for decoding. The encoded bitstream <b>21</b> may be transmitted to video decoder <b>30</b>, or stored in a memory for later transmission or retrieval by video decoder <b>30</b>.</p><p id="p-0210" num="0209">Other structural variations of the video encoder <b>20</b> can be used to encode the video stream. For example, a non-transform based encoder <b>20</b> can quantize the residual signal directly without the transform processing unit <b>206</b> for certain blocks or frames. In another implementation, an encoder <b>20</b> can have the quantization unit <b>208</b> and the inverse quantization unit <b>210</b> combined into a single unit.</p><p id="p-0211" num="0210">Decoder and Decoding Method</p><p id="p-0212" num="0211"><figref idref="DRAWINGS">FIG. <b>3</b></figref> shows an example of a video decoder <b>30</b> that is configured to implement the techniques of this present application. The video decoder <b>30</b> is configured to receive encoded picture data <b>21</b> (e.g. encoded bitstream <b>21</b>), e.g. encoded by encoder <b>20</b>, to obtain a decoded picture <b>331</b>. The encoded picture data or bitstream comprises information for decoding the encoded picture data, e.g. data that represents picture blocks of an encoded video slice (and/or tile groups or tiles) and associated syntax elements.</p><p id="p-0213" num="0212">In the example of <figref idref="DRAWINGS">FIG. <b>3</b></figref>, the decoder <b>30</b> comprises an entropy decoding unit <b>304</b>, an inverse quantization unit <b>310</b>, an inverse transform processing unit <b>312</b>, a reconstruction unit <b>314</b> (e.g. a summer <b>314</b>), a loop filter <b>320</b>, a decoded picture buffer (DBP) <b>330</b>, a mode application unit <b>360</b>, an inter prediction unit <b>344</b> and an intra prediction unit <b>354</b>. Inter prediction unit <b>344</b> may be or include a motion compensation unit. Video decoder <b>30</b> may, in some examples, perform a decoding pass generally reciprocal to the encoding pass described with respect to video encoder <b>100</b> from <figref idref="DRAWINGS">FIG. <b>2</b></figref>.</p><p id="p-0214" num="0213">As explained with regard to the encoder <b>20</b>, the inverse quantization unit <b>210</b>, the inverse transform processing unit <b>212</b>, the reconstruction unit <b>214</b> the loop filter <b>220</b>, the decoded picture buffer (DPB) <b>230</b>, the inter prediction unit <b>344</b> and the intra prediction unit <b>354</b> are also referred to as forming the &#x201c;built-in decoder&#x201d; of video encoder <b>20</b>. Accordingly, the inverse quantization unit <b>310</b> may be identical in function to the inverse quantization unit <b>110</b>, the inverse transform processing unit <b>312</b> may be identical in function to the inverse transform processing unit <b>212</b>, the reconstruction unit <b>314</b> may be identical in function to reconstruction unit <b>214</b>, the loop filter <b>320</b> may be identical in function to the loop filter <b>220</b>, and the decoded picture buffer <b>330</b> may be identical in function to the decoded picture buffer <b>230</b>. Therefore, the explanations provided for the respective units and functions of the video <b>20</b> encoder apply correspondingly to the respective units and functions of the video decoder <b>30</b>.</p><p id="p-0215" num="0214">Entropy Decoding</p><p id="p-0216" num="0215">The entropy decoding unit <b>304</b> is configured to parse the bitstream <b>21</b> (or in general encoded picture data <b>21</b>) and perform, for example, entropy decoding to the encoded picture data <b>21</b> to obtain, e.g., quantized coefficients <b>309</b> and/or decoded coding parameters (not shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref>), e.g. any or all of inter prediction parameters (e.g. reference picture index and motion vector), intra prediction parameter (e.g. intra prediction mode or index), transform parameters, quantization parameters, loop filter parameters, and/or other syntax elements. Entropy decoding unit <b>304</b> maybe configured to apply the decoding algorithms or schemes corresponding to the encoding schemes as described with regard to the entropy encoding unit <b>270</b> of the encoder <b>20</b>. Entropy decoding unit <b>304</b> may be further configured to provide inter prediction parameters, intra prediction parameter and/or other syntax elements to the mode application unit <b>360</b> and other parameters to other units of the decoder <b>30</b>. Video decoder <b>30</b> may receive the syntax elements at the video slice level and/or the video block level. In addition or as an alternative to slices and respective syntax elements, tile groups and/or tiles and respective syntax elements may be received and/or used.</p><p id="p-0217" num="0216">Inverse Quantization</p><p id="p-0218" num="0217">The inverse quantization unit <b>310</b> may be configured to receive quantization parameters (QP) (or in general information related to the inverse quantization) and quantized coefficients from the encoded picture data <b>21</b> (e.g. by parsing and/or decoding, e.g. by entropy decoding unit <b>304</b>) and to apply based on the quantization parameters an inverse quantization on the decoded quantized coefficients <b>309</b> to obtain dequantized coefficients <b>311</b>, which may also be referred to as transform coefficients <b>311</b>. The inverse quantization process may include use of a quantization parameter determined by video encoder <b>20</b> for each video block in the video slice (or tile or tile group) to determine a degree of quantization and, likewise, a degree of inverse quantization that should be applied.</p><p id="p-0219" num="0218">Inverse Transform</p><p id="p-0220" num="0219">Inverse transform processing unit <b>312</b> may be configured to receive dequantized coefficients <b>311</b>, also referred to as transform coefficients <b>311</b>, and to apply a transform to the dequantized coefficients <b>311</b> in order to obtain reconstructed residual blocks <b>213</b> in the sample domain. The reconstructed residual blocks <b>213</b> may also be referred to as transform blocks <b>313</b>. The transform may be an inverse transform, e.g., an inverse DCT, an inverse DST, an inverse integer transform, or a conceptually similar inverse transform process. The inverse transform processing unit <b>312</b> may be further configured to receive transform parameters or corresponding information from the encoded picture data <b>21</b> (e.g. by parsing and/or decoding, e.g. by entropy decoding unit <b>304</b>) to determine the transform to be applied to the dequantized coefficients <b>311</b>.</p><p id="p-0221" num="0220">Reconstruction</p><p id="p-0222" num="0221">The reconstruction unit <b>314</b> (e.g. adder or summer <b>314</b>) may be configured to add the reconstructed residual block <b>313</b>, to the prediction block <b>365</b> to obtain a reconstructed block <b>315</b> in the sample domain, e.g. by adding the sample values of the reconstructed residual block <b>313</b> and the sample values of the prediction block <b>365</b>.</p><p id="p-0223" num="0222">Filtering</p><p id="p-0224" num="0223">The loop filter unit <b>320</b> (either in the coding loop or after the coding loop) is configured to filter the reconstructed block <b>315</b> to obtain a filtered block <b>321</b>, e.g. to smooth pixel transitions, or otherwise improve the video quality. The loop filter unit <b>320</b> may comprise one or more loop filters such as a de-blocking filter, a sample-adaptive offset (SAO) filter or one or more other filters, e.g. a bilateral filter, an adaptive loop filter (ALF), a sharpening, a smoothing filters or a collaborative filters, or any combination thereof. Although the loop filter unit <b>320</b> is shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref> as being an in loop filter, in other configurations, the loop filter unit <b>320</b> may be implemented as a post loop filter.</p><p id="p-0225" num="0224">Decoded Picture Buffer</p><p id="p-0226" num="0225">The decoded video blocks <b>321</b> of a picture are then stored in decoded picture buffer <b>330</b>, which stores the decoded pictures <b>331</b> as reference pictures for subsequent motion compensation for other pictures and/or for output respectively display.</p><p id="p-0227" num="0226">The decoder <b>30</b> is configured to output the decoded picture <b>311</b>, e.g. via output <b>312</b>, for presentation or viewing to a user.</p><p id="p-0228" num="0227">Prediction</p><p id="p-0229" num="0228">The inter prediction unit <b>344</b> may be identical to the inter prediction unit <b>244</b> (in particular to the motion compensation unit) and the intra prediction unit <b>354</b> may be identical to the inter prediction unit <b>254</b> in function, and performs split or partitioning decisions and prediction based on the partitioning and/or prediction parameters or respective information received from the encoded picture data <b>21</b> (e.g. by parsing and/or decoding, e.g. by entropy decoding unit <b>304</b>). Mode application unit <b>360</b> may be configured to perform the prediction (intra or inter prediction) per block based on reconstructed pictures, blocks or respective samples (filtered or unfiltered) to obtain the prediction block <b>365</b>.</p><p id="p-0230" num="0229">When the video slice is coded as an intra coded (I) slice, intra prediction unit <b>354</b> of mode application unit <b>360</b> is configured to generate prediction block <b>365</b> for a picture block of the current video slice based on a signaled intra prediction mode and data from previously decoded blocks of the current picture. When the video picture is coded as an inter coded (i.e., B, or P) slice, inter prediction unit <b>344</b> (e.g. motion compensation unit) of mode application unit <b>360</b> is configured to produce prediction blocks <b>365</b> for a video block of the current video slice based on the motion vectors and other syntax elements received from entropy decoding unit <b>304</b>. For inter prediction, the prediction blocks may be produced from one of the reference pictures within one of the reference picture lists. Video decoder <b>30</b> may construct the reference frame lists, List <b>0</b> and List <b>1</b>, using default construction techniques based on reference pictures stored in DPB <b>330</b>. The same or similar may be applied for or by embodiments using tile groups (e.g. video tile groups) and/or tiles (e.g. video tiles) in addition or alternatively to slices (e.g. video slices), e.g. a video may be coded using I, P or B tile groups and/or tiles.</p><p id="p-0231" num="0230">Mode application unit <b>360</b> is configured to determine the prediction information for a video block of the current video slice by parsing the motion vectors or related information and other syntax elements, and uses the prediction information to produce the prediction blocks for the current video block being decoded. For example, the mode application unit <b>360</b> uses some of the received syntax elements to determine a prediction mode (e.g., intra or inter prediction) used to code the video blocks of the video slice, an inter prediction slice type (e.g., B slice, P slice, or GPB slice), construction information for one or more of the reference picture lists for the slice, motion vectors for each inter encoded video block of the slice, inter prediction status for each inter coded video block of the slice, and other information to decode the video blocks in the current video slice. The same or similar may be applied for or by embodiments using tile groups (e.g. video tile groups) and/or tiles (e.g. video tiles) in addition or alternatively to slices (e.g. video slices), e.g. a video may be coded using I, P or B tile groups and/or tiles.</p><p id="p-0232" num="0231">Embodiments of the video decoder <b>30</b> as shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref> may be configured to partition and/or decode the picture by using slices (also referred to as video slices), wherein a picture may be partitioned into or decoded using one or more slices (typically non-overlapping), and each slice may comprise one or more blocks (e.g. CTUs).</p><p id="p-0233" num="0232">Embodiments of the video decoder <b>30</b> as shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref> may be configured to partition and/or decode the picture by using tile groups (also referred to as video tile groups) and/or tiles (also referred to as video tiles), wherein a picture may be partitioned into or decoded using one or more tile groups (typically non-overlapping), and each tile group may comprise, e.g. one or more blocks (e.g. CTUs) or one or more tiles, wherein each tile, e.g. may be of rectangular shape and may comprise one or more blocks (e.g. CTUs), e.g. complete or fractional blocks.</p><p id="p-0234" num="0233">Other variations of the video decoder <b>30</b> can be used to decode the encoded picture data <b>21</b>. For example, the decoder <b>30</b> can produce the output video stream without the loop filtering unit <b>320</b>. For example, a non-transform based decoder <b>30</b> can inverse-quantize the residual signal directly without the inverse-transform processing unit <b>312</b> for certain blocks or frames. In another implementation, the video decoder <b>30</b> can have the inverse-quantization unit <b>310</b> and the inverse-transform processing unit <b>312</b> combined into a single unit.</p><p id="p-0235" num="0234">It should be understood that, in the encoder <b>20</b> and the decoder <b>30</b>, a processing result of a current step may be further processed and then output to the next step. For example, after interpolation filtering, motion vector derivation or loop filtering, a further operation, such as Clip or shift, may be performed on the processing result of the interpolation filtering, motion vector derivation or loop filtering.</p><p id="p-0236" num="0235">It should be noted that further operations may be applied to the derived motion vectors of current block (including but not limit to control point motion vectors of affine mode, sub-block motion vectors in affine, planar, ATMVP modes, temporal motion vectors, and so on). For example, the value of motion vector is constrained to a predefined range according to its representing bit. If the representing bit of motion vector is bitDepth, then the range is &#x2212;2{circumflex over (&#x2003;)}(bitDepth-1)&#x2dc;2{circumflex over (&#x2003;)}(bitDepth-1)&#x2212;1, where &#x201c;{circumflex over (&#x2003;)}&#x201d; means exponentiation. For example, if bitDepth is set equal to 16, the range is &#x2212;32768&#x2dc;32767; if bitDepth is set equal to 18, the range is &#x2212;131072&#x2dc;131071. For example, the value of the derived motion vector (e.g. the MVs of four 4&#xd7;4 sub-blocks within one 8&#xd7;8 block) is constrained such that the max difference between integer parts of the four 4&#xd7;4 sub-block MVs is no more than N pixels, such as no more than 1 pixel. Here provides two methods for constraining the motion vector according to the bitDepth.</p><p id="p-0237" num="0236">Method 1: remove the overflow MSB (most significant bit) by flowing operations</p><p id="p-0238" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>ux</i>=(<i>mvx+</i>2<sup>bitDepth</sup>)%2<sup>bitDepth</sup>&#x2003;&#x2003;(1)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0239" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>mvx</i>=(<i>UX&#x3e;=</i>2<sup>bitDepth-1</sup>)?(<i>ux&#x2212;</i>2<sup>bitDepth</sup>):<i>ux</i>&#x2003;&#x2003;(2)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0240" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>uy</i>=(<i>mvy+</i>2<sup>bitDepth</sup>)%2<sup>bitDepth</sup>&#x2003;&#x2003;(3)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0241" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>mvy</i>(<i>uy&#x3e;=</i>2<sup>bitDepth-1</sup>)?(<i>uy&#x2212;</i>2<sup>bitDepth</sup>):<i>uy</i>&#x2003;&#x2003;(4)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0242" num="0000">where mvx is a horizontal component of a motion vector of an image block or a sub-block, mvy is a vertical component of a motion vector of an image block or a sub-block, and ux and uy indicates an intermediate value;<br/>For example, if the value of mvx is &#x2212;32769, after applying formula (1) and (2), the resulting value is 32767. In computer system, decimal numbers are stored as two's complement. The two's complement of &#x2212;32769 is 1,0111,1111,1111,1111 (17 bits), then the MSB is discarded, so the resulting two's complement is 0111,1111,1111,1111 (decimal number is 32767), which is same as the output by applying formula (1) and (2).</p><p id="p-0243" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>ux</i>=(<i>mvpx+mvdx+</i>2<sup>bitDepth</sup>)%2<sup>bitDepth</sup>&#x2003;&#x2003;(5)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0244" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>mvx</i>=(<i>ux&#x3e;=</i>2<sup>bitDepth-1</sup>)?(<i>ux&#x2212;</i>2<sup>bitDepth</sup>):<i>ux</i>&#x2003;&#x2003;(6)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0245" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>uy</i>=(<i>mvpy+mvdy+</i>2<sup>bitDepth</sup>)%2<sup>bitDepth</sup>&#x2003;&#x2003;(7)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0246" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>mvy</i>=(<i>uy&#x3e;=</i>2<sup>bitDepth-1</sup>)?(<i>uy&#x2212;</i>2<sup>bitDepth</sup>):<i>uy</i>&#x2003;&#x2003;(8)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0247" num="0000">The operations may be applied during the sum of mvp and mvd, as shown in formula (5) to (8).<br/>Method 2: remove the overflow MSB by clipping the value</p><p id="p-0248" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>vx</i>=Clip3(&#x2212;2<sup>bitDepth-1</sup>,2<sup>bitDepth-1</sup>&#x2212;1<i>,vx</i>)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0249" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>vy</i>=Clip3(&#x2212;2<sup>bitDepth-1</sup>,2<sup>bitDepth-1</sup>&#x2212;1<i>,vy</i>)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0250" num="0237">where vx is a horizontal component of a motion vector of an image block or a sub-block, vy is a vertical component of a motion vector of an image block or a sub-block; x, y and z respectively correspond to three input value of the MV clipping process, and the definition of function Clip3 is as follow:</p><p id="p-0251" num="0000"><maths id="MATH-US-00001" num="00001"><math overflow="scroll"> <mrow>  <mrow>   <mi>Clip</mi>   <mo>&#x2062;</mo>   <mn>3</mn>   <mo>&#x2062;</mo>   <mrow>    <mo>(</mo>    <mrow>     <mi>x</mi>     <mo>,</mo>     <mi>y</mi>     <mo>,</mo>     <mi>z</mi>    </mrow>    <mo>)</mo>   </mrow>  </mrow>  <mo>=</mo>  <mrow>   <mo>{</mo>   <mtable>    <mtr>     <mtd>      <mrow>       <mi>x</mi>       <mo>;</mo>      </mrow>     </mtd>     <mtd>      <mrow>       <mi>z</mi>       <mo>&#x3c;</mo>       <mi>x</mi>      </mrow>     </mtd>    </mtr>    <mtr>     <mtd>      <mrow>       <mi>y</mi>       <mo>;</mo>      </mrow>     </mtd>     <mtd>      <mrow>       <mi>z</mi>       <mo>&#x3e;</mo>       <mi>y</mi>      </mrow>     </mtd>    </mtr>    <mtr>     <mtd>      <mrow>       <mi>z</mi>       <mo>;</mo>      </mrow>     </mtd>     <mtd>      <mi>otherwise</mi>     </mtd>    </mtr>   </mtable>  </mrow> </mrow></math></maths></p><p id="p-0252" num="0238"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a schematic diagram of a video coding device <b>400</b> according to an embodiment of the disclosure. The video coding device <b>400</b> is suitable for implementing the disclosed embodiments as described herein. In an embodiment, the video coding device <b>400</b> may be a decoder such as video decoder <b>30</b> of <figref idref="DRAWINGS">FIG. <b>1</b>A</figref> or an encoder such as video encoder <b>20</b> of <figref idref="DRAWINGS">FIG. <b>1</b>A</figref>.</p><p id="p-0253" num="0239">The video coding device <b>400</b> comprises ingress ports <b>410</b> (or input ports <b>410</b>) and receiver units (Rx) <b>420</b> for receiving data; a processor, logic unit, or central processing unit (CPU) <b>430</b> to process the data; transmitter units (Tx) <b>440</b> and egress ports <b>450</b> (or output ports <b>450</b>) for transmitting the data; and a memory <b>460</b> for storing the data. The video coding device <b>400</b> may also comprise optical-to-electrical (OE) components and electrical-to-optical (EO) components coupled to the ingress ports <b>410</b>, the receiver units <b>420</b>, the transmitter units <b>440</b>, and the egress ports <b>450</b> for egress or ingress of optical or electrical signals.</p><p id="p-0254" num="0240">The processor <b>430</b> is implemented by hardware and software. The processor <b>430</b> may be implemented as one or more CPU chips, cores (e.g., as a multi-core processor), FPGAs, ASICs, and DSPs. The processor <b>430</b> is in communication with the ingress ports <b>410</b>, receiver units <b>420</b>, transmitter units <b>440</b>, egress ports <b>450</b>, and memory <b>460</b>. The processor <b>430</b> comprises a coding module <b>470</b>. The coding module <b>470</b> implements the disclosed embodiments described above. For instance, the coding module <b>470</b> implements, processes, prepares, or provides the various coding operations. The inclusion of the coding module <b>470</b> therefore provides a substantial improvement to the functionality of the video coding device <b>400</b> and effects a transformation of the video coding device <b>400</b> to a different state. Alternatively, the coding module <b>470</b> is implemented as instructions stored in the memory <b>460</b> and executed by the processor <b>430</b>.</p><p id="p-0255" num="0241">The memory <b>460</b> may comprise one or more disks, tape drives, and solid-state drives and may be used as an over-flow data storage device, to store programs when such programs are selected for execution, and to store instructions and data that are read during program execution. The memory <b>460</b> may be, for example, volatile and/or non-volatile and may be a read-only memory (ROM), random access memory (RAM), ternary content-addressable memory (TCAM), and/or static random-access memory (SRAM).</p><p id="p-0256" num="0242"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a simplified block diagram of an apparatus <b>500</b> that may be used as either or both of the source device <b>12</b> and the destination device <b>14</b> from <figref idref="DRAWINGS">FIG. <b>1</b></figref> according to an exemplary embodiment.</p><p id="p-0257" num="0243">A processor <b>502</b> in the apparatus <b>500</b> can be a central processing unit. Alternatively, the processor <b>502</b> can be any other type of device, or multiple devices, capable of manipulating or processing information now-existing or hereafter developed. Although the disclosed implementations can be practiced with a single processor as shown, e.g., the processor <b>502</b>, advantages in speed and efficiency can be achieved using more than one processor.</p><p id="p-0258" num="0244">A memory <b>504</b> in the apparatus <b>500</b> can be a read only memory (ROM) device or a random access memory (RAM) device in an implementation. Any other suitable type of storage device can be used as the memory <b>504</b>. The memory <b>504</b> can include code and data <b>506</b> that is accessed by the processor <b>502</b> using a bus <b>512</b>. The memory <b>504</b> can further include an operating system <b>508</b> and application programs <b>510</b>, the application programs <b>510</b> including at least one program that permits the processor <b>502</b> to perform the methods described here. For example, the application programs <b>510</b> can include applications <b>1</b> through N, which further include a video coding application that performs the methods described here.</p><p id="p-0259" num="0245">The apparatus <b>500</b> can also include one or more output devices, such as a display <b>518</b>. The display <b>518</b> may be, in one example, a touch sensitive display that combines a display with a touch sensitive element that is operable to sense touch inputs. The display <b>518</b> can be coupled to the processor <b>502</b> via the bus <b>512</b>.</p><p id="p-0260" num="0246">Although depicted here as a single bus, the bus <b>512</b> of the apparatus <b>500</b> can be composed of multiple buses. Further, the secondary storage <b>514</b> can be directly coupled to the other components of the apparatus <b>500</b> or can be accessed via a network and can comprise a single integrated unit such as a memory card or multiple units such as multiple memory cards. The apparatus <b>500</b> can thus be implemented in a wide variety of configurations.</p><p id="p-0261" num="0247">Parameter Sets</p><p id="p-0262" num="0248">Parameter sets are fundamentally similar and share the same basic design goals&#x2014;namely bit rate efficiency, error resiliency, and providing systems layer interfaces. There is a hierarchy of parameter sets in HEVC (ITU-T H.265), including the Video Parameter Set (VPS), Sequence Parameter Set (SPS) and Picture Parameter Set (PPS) which are similar to their counterparts in AVC and VVC. Each slice references a single active PPS, SPS and VPS to access information used for decoding the slice. The PPS contains information which applies to all slices in a picture, and hence all slices in a picture must refer to the same PPS. The slices in different pictures are also allowed to refer to the same PPS. Similarly, the SPS contains information which applies to all pictures in the same coded video sequence.</p><p id="p-0263" num="0249">While the PPS may differ for separate pictures, it is common for many or all pictures in a coded video sequence to refer to the same PPS. Reusing parameter sets is bit rate efficient because it avoids the necessity to send shared information multiple times. It is also loss robust because it allows parameter set content to be carried by some more reliable external communication link or to be repeated frequently within the bitstream to ensure that it will not get lost.</p><p id="p-0264" num="0250">Sequence Parameter Set (SPS)</p><p id="p-0265" num="0251">The SPS contains parameters that apply to one or more layers of a coded video sequence and do not change from picture to picture within a coded video sequence. In particular, the SPS including information that signaling of subpicture.</p><p id="p-0266" num="0252">Some parts of the following table shows a snapshot of part of the subpicture signaling in SPS in ITU JVET-Q2001-v11, with the download link as follows:</p><p id="p-0267" num="0253">http://phenix.it-sudparis.eu/jvet/doc_end_user/documents/17_Brussels/wg11/JVET-Q2001-v11.zip. In the remaining part of the application this document will be named VVC draft 8 for simplicity.</p><p id="p-0268" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="224pt" align="left"/><colspec colname="1" colwidth="35pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="224pt" align="left"/><colspec colname="2" colwidth="35pt" align="left"/><tbody valign="top"><row><entry>seq_parameter_set_rbsp( ) {</entry><entry/></row><row><entry>&#x2003;sps_seq_parameter_set_id</entry><entry>u(4)</entry></row><row><entry>&#x2003;sps_video_parameter_set_id</entry><entry>u(4)</entry></row><row><entry>&#x2003;sps_max_sublayers_minus1</entry><entry>u(3)</entry></row><row><entry>&#x2003;sps_reserved_zero_4bits</entry><entry>u(4)</entry></row><row><entry>&#x2003;sps_ptl_dpb_hrd_params_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_ptl_dpb_hrd_params_present_flag )</entry></row><row><entry>&#x2003;&#x2003;profile_tier_level( 1, sps_max_sublayers_minus1 )</entry></row><row><entry>&#x2003;gdr_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;chroma_format_idc</entry><entry>u(2)</entry></row><row><entry>&#x2003;if( chroma_format_idc = = 3 )</entry></row><row><entry>&#x2003;&#x2003;separate_colour_plane_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;res_change_in_clvs_allowed_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;pic_width_max_in_luma_samples</entry><entry>ue(v)</entry></row><row><entry>&#x2003;pic_height_max_in_luma_samples</entry><entry>ue(v)</entry></row><row><entry>&#x2003;sps_conformance_window_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( sps_conformance_window_flag ) {</entry></row><row><entry>&#x2003;&#x2003;sps_conf_win_left_offset</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;sps_conf_win_right_offset</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;sps_conf_win_top_offset</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;sps_conf_win_bottom_offset</entry><entry>ue(v)</entry></row><row><entry>&#x2003;}</entry></row><row><entry>&#x2003;sps_log2_ctu_size_minus5</entry><entry>u(2)</entry></row><row><entry>&#x2003;subpic_info_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( subpic_info_present_flag ) {</entry></row><row><entry>&#x2003;&#x2003;sps_num_subpics_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;sps_independent_subpics_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; sps_num_subpics_minus1 &#x3e; 0 &#x26;&#x26; i &#x3c;=</entry></row><row><entry>sps_num_subpics_minus1; i++ ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( i &#x3e; 0 &#x26;&#x26; pic_width_max_in_luma_samples &#x3e; CtbSizeY )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;subpic_ctu_top_left_x[ i ]</entry><entry>u(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( i &#x3e; 0 &#x26;&#x26; pic_height_max_in_luma_samples &#x3e; CtbSizeY ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;subpic_ctu_top_left_y[ i ]</entry><entry>u(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( i &#x3c; sps_num_subpics_minus1 &#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;pic_width_max_in_luma_samples &#x3e; CtbSizeY )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;subpic_width_minus1[ i ]</entry><entry>u(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( i &#x3c; sps_num_subpics_minus1 &#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;pic_height_max_in_luma_samples &#x3e; CtbSizeY )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;subpic_height_minus1[ i ]</entry><entry>u(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( !sps_independent_subpics_flag) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;subpic_treated_as_pic_flag[ i ]</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;loop_filter_across_subpic_enabled_flag[ i ]</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;}</entry></row><row><entry>...</entry></row><row><entry>...</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0269" num="0254">Some syntax elements in SPS signal position information and control flags of each subpicture. The position information for the i-th subpicture includes:<ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0255">subpic_ctu_top_left_x[i], indicating the horizontal component of the top-left coordinate of the subpicture i in the picture; or</li>        <li id="ul0002-0002" num="0256">subpic_ctu_top_left_y[i] indicating the vertical component of the top-left coordinate of the subpicture i in the picture; or</li>        <li id="ul0002-0003" num="0257">subpic_width_minus1[i] indicating width of the subpicture i in the picture; or</li>        <li id="ul0002-0004" num="0258">subpic_height_minus1[i] indicating height of the subpicture i in the picture.</li>    </ul>    </li></ul></p><p id="p-0270" num="0259">Some syntax elements indicate the number of subpictures in the picture, e.g. sps_num_subpics_minus1.</p><p id="p-0271" num="0260">Partitioning of a picture into CTUs, slices, tiles and subpictures</p><p id="p-0272" num="0261">Partitioning of the picture into CTUs</p><p id="p-0273" num="0262">Picture is divided into a sequence of coding tree units (CTUs). The term CTU is sometimes used interchangeably as CTB (coding tree block). In an example, the term CTU is same as the CTU definition in the ITU-T H.265. For a picture that has three sample arrays, a CTU comprises an N&#xd7;N block of luma samples, and two corresponding blocks of chroma samples. <figref idref="DRAWINGS">FIG. <b>6</b></figref> shows an example of a picture divided into CTUs. The size of CTUs may be same except for the CTUs located at the picture boundaries (where incomplete CTUs can be present).</p><p id="p-0274" num="0263">Partitioning of the Picture into Tiles</p><p id="p-0275" num="0264">In some examples, when tiles are enabled, picture is divided into rectangular-shaped groups of CTUs separated by vertical and/or horizontal boundaries. The vertical and horizontal tile boundaries intersect the picture from top to bottom and from left picture boundary to right picture boundary respectively. Indication information related to the position of the horizontal tile boundaries and vertical tile boundaries are coded in bitstream.</p><p id="p-0276" num="0265"><figref idref="DRAWINGS">FIG. <b>7</b></figref> exemplifies partitioning of a picture into 9 tiles. In this example, the tile boundaries are marked with bold dashed lines. Tile-based raster scan order of CTUs with nine tiles of different sizes in the picture.</p><p id="p-0277" num="0266">When there are more than 1 tile dividing a picture vertically, the scan order of the CTUs is changed with respect to the raster scan order of CTUs in the picture. The CTUs are scanned according to the following rule:</p><p id="p-0278" num="0000">1. Tiles are scanned from left to right and from top to bottom in raster scan order, which is called the tile scan order. This means that starting from the top-left tile, all tiles in the same tile row are scanned from left to right. Then starting with the first tile in the second tile row (the tile row that is one below), all tiles in the second tile row are scanned from left to right. The process is repeated till all tiles are scanned.<br/>2. For a tile, CTUs in this tile are scanned in raster scan order. For each CTU row, CTUs are scanned from left to right and CTU rows are scanned from top to bottom. <figref idref="DRAWINGS">FIG. <b>7</b></figref> exemplifies the scanning order of CTUs in the tiles, the numbers correspond to the CTUs indicate the scanning order.</p><p id="p-0279" num="0267">The tile provides a partitioning of a picture in such a way that each tile is independently decodable from other tiles of the same picture, wherein decoding refers to entropy, residual, and predictive decoding. Moreover with tiles, it is possible to partition the picture into similar sized regions. Therefore it is possible to process the tiles of a picture in parallel to each other, which is preferable for multi-core processing environments where each processing core is identical to each other.</p><p id="p-0280" num="0268">The terms processing order and scanning order are used as follows in the application:</p><p id="p-0281" num="0000">Processing refers to encoding or decoding of CTUs in the encoder or decoder. Scanning order relates to the indexing of the particular partition in a picture. The CTUs are indexed in increasing order in a picture according to a specified scan order. CTU scan order in tile means how the CTUs inside a tile is indexed, which might not be the same order in which they are processed (i.e. processing order).</p><p id="p-0282" num="0269">Partitioning of the Picture into Slices</p><p id="p-0283" num="0270">The slice concept provides a partitioning of a picture in such a way that each slice is independently decodable from other slices of the same picture, wherein decoding refers to entropy, residual, and predictive decoding. The difference to tiles is that slices may have arbitrary shapes that are not necessarily rectangular (more flexible in partitioning possibilities), and the purpose of slice partitioning is not for parallel processing but is for packet size matching in transmission environments and error resilience.</p><p id="p-0284" num="0271">A slice may comprises a complete picture or comprises a part of a picture. In ITU-T H.265, a slice comprises consecutive CTUs of a picture in processing order. A slice is identified according to a starting CTU address, the starting CTU address is signalled in a slice header or in a picture parameter set or in other unit. In an example, the slice might be identified according to a starting tile address when the slices are required to comprise integer number of tiles.</p><p id="p-0285" num="0272">In the draft 8 of VVC, a slice comprises an integer number of tiles or an integer number of consecutive CTU rows within a tile of a picture. Consequently, a vertical slice boundary is also a vertical tile boundary. It is possible that a horizontal boundary of a slice is not a tile boundary, horizontal CTU boundaries may be comprised within a tile. In an example, when a tile is split into multiple rectangular slices, each slice comprises an integer number of consecutive complete CTU rows within the tile.</p><p id="p-0286" num="0273">In some examples, there are two slice modes, the raster-scan slice mode and the rectangular slice mode. In the raster-scan slice mode, a slice comprises a sequence of tiles in a tile raster scan of a picture. In the rectangular slice mode, a slice comprises a number of tiles that collectively form a rectangular region of the picture, or a slice comprises a number of consecutive CTU rows of one tile that collectively form a rectangular region of the picture. Tiles within a rectangular slice are scanned in tile raster scan order within the rectangular region corresponding to that slice.</p><p id="p-0287" num="0274">All slices of a picture collectively form the entire picture, all CTUs of a picture are comprised in one of the slices of a picture. Similar rules apply for tiles and subpictures.</p><p id="p-0288" num="0275">Partitioning of the Picture into Subpictures</p><p id="p-0289" num="0276">A subpicture may be a rectangular partition of a picture. A subpicture may be the whole picture or a part of the picture. A subpicture is partitioning of a picture in such a way that each subpicture is independently decodable from other subpictures of the entire video sequence. In VVC draft 8, when subpic_treated_as_pic_flag[i] indication is true (e.g. a value of subpic_treated_aspic_flag[i] is 1) for subpicture i, the subpicture i is independently decodable from other subpictures of the entire video sequence.</p><p id="p-0290" num="0277">The difference between the subpicture and tiles or slices is that, subpictures refer to an independently decodable video sequence. For tiles and slices, independent decoding is performed in a single picture of a video sequence.</p><p id="p-0291" num="0278">In VVC draft 8, a subpicture comprises one or more slices that collectively cover a rectangular region of a picture. Consequently, each subpicture boundary is always a slice boundary, and each vertical subpicture boundary is always a vertical tile boundary.</p><p id="p-0292" num="0279"><figref idref="DRAWINGS">FIG. <b>8</b></figref> provides an example of tiles, slices and subpictures. In <figref idref="DRAWINGS">FIG. <b>8</b></figref>, an example of picture containing 4 tiles (2 tile column and 2 tile rows), 4 rectangular slices, and 3 subpictures. The subpicture 2 contains two slices, subpicture 1 and 3 contain 1 slice each. Subpicture 1 contains 2 tiles, subpicture 2 and 3 contain 1 tile each. Subpicture, slice and tile boundaries all coincide with CTU boundaries. In the boundaries are shown with small offset to each other in order to make them distinguishable.</p><p id="p-0293" num="0280">In one example as shown in <figref idref="DRAWINGS">FIG. <b>8</b></figref>, a picture is partitioned into 216 CTUs, 4 tiles, 4 slices and 3 subpictures. A value of sps_num_subpics_minus1 is 2, and the position-related syntax elements have the following values:</p><p id="p-0294" num="0000">For subpicture 1<ul id="ul0003" list-style="none">    <li id="ul0003-0001" num="0000">    <ul id="ul0004" list-style="none">        <li id="ul0004-0001" num="0281">subpic_ctu_top_left_x[0], is not signaled but inferred as 0;</li>        <li id="ul0004-0002" num="0282">subpic_ctu_top_lefty[0], is not signaled but inferred as 0;</li>        <li id="ul0004-0003" num="0283">subpic_width_minus1[0], value is 8;</li>        <li id="ul0004-0004" num="0284">subpic_height_minus1[0], value is 11.<br/>For subpicture 2</li>        <li id="ul0004-0005" num="0285">subpic_ctu_top_left_x[1], value is 9;</li>        <li id="ul0004-0006" num="0286">subpic_ctu_top_left_y[1], value is 0;</li>        <li id="ul0004-0007" num="0287">subpic_width_minus1[1], value is 8;</li>        <li id="ul0004-0008" num="0288">subpic_height_minus1[1], value is 5.<br/>For subpicture 3</li>        <li id="ul0004-0009" num="0289">subpic_ctu_top_left_x[2], value is 9;</li>        <li id="ul0004-0010" num="0290">subpic_ctu_top_left_y[2], value is 6;</li>        <li id="ul0004-0011" num="0291">subpic_width_minus1[2], is not signaled but inferred as 8;</li>        <li id="ul0004-0012" num="0292">subpic_height_minus1[2], is not signaled but inferred as 5.</li>    </ul>    </li></ul></p><p id="p-0295" num="0293">Signalling of Tiles</p><p id="p-0296" num="0294">The following table exemplifies the signalling of tile sizes and coordinates of tiles in a picture, which is disclosed in the Picture Parameter Set RBSP syntax table of VVC draft 8.</p><p id="p-0297" num="0000"><tables id="TABLE-US-00002" num="00002"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="189pt" align="left"/><colspec colname="2" colwidth="28pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>no_pic_partition_flag</entry><entry>u(1)</entry></row><row><entry>if( !no_pic_partition_flag ) {</entry></row><row><entry>&#x2003;pps_log2_ctu_size_minus5</entry><entry>u(2)</entry></row><row><entry>&#x2003;num_exp_tile_columns_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;num_exp_tile_rows_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c;= num_exp_tile_columns_minus1; i++ )</entry></row><row><entry>&#x2003;&#x2003;tile_column_width_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c;= num_exp_tile_rows_minus1; i++ )</entry></row><row><entry>&#x2003;&#x2003;tile_row_height_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;if( NumTilesInPic &#x3e; 1 )</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0298" num="0295">The partitioning information (e.g. tile address and tile dimensions) of tile is usually coded in a parameter set. In the above example, a value of an indication no_pic_partition_flag is coded in the bitstream, the value of no_pic_partition_flag is used to indicate whether a picture is partitioned into slices and tiles or not. If no_pic_partition_flag is true (meaning the picture is not partitioned into slices or tiles), it is inferred that the picture is partitioned into only one slice and only one tile, whose boundaries are aligned with picture boundaries. Otherwise (no_pic_partition_flag is false), tile partitioning information is coded in the bitstream.</p><p id="p-0299" num="0296">A value of a syntax element tile_column_width_minus1[i] indicates the width of an i th tile columns. A value of a syntax element tile_row_height_minus1[i] indicates the height of the ith tile row.</p><p id="p-0300" num="0297">The tile row height and tile column widths can be either explicitly signalled in the bitstream or can be inferred according to the bitstream. Syntax elements num_exp_tile_columns_minus1 and num_exp_tile_rows_minus1 indicate the number of tile columns and tile rows respectively, widths and heights of these tiles are explicitly signaled in bitstream. The widths and heights of other tile columns and rows are inferred according to a function.</p><p id="p-0301" num="0298">The indexing of tiles are represent the &#x201c;tile scan order in the picture&#x201d;. The tiles in a picture are ordered (scanned) according to raster scan order, the first tile which is at the top-left corner of the picture is the 0th tile, and the index increases from left to right in each tile row and after the last tile in a tile row is scanned, one continues with the leftmost tile of the next tile row (one below current tile row).</p><p id="p-0302" num="0299">The CTUs in a tile (CTU scan order in a tile) are scanned in raster scan order.</p><p id="p-0303" num="0300">Tile-based scan order of CTUs in a picture indicates that the tile scan order in a picture and CTU scan order in each tile are followed simultaneously. In other words,<ul id="ul0005" list-style="none">    <li id="ul0005-0001" num="0000">    <ul id="ul0006" list-style="none">        <li id="ul0006-0001" num="0301">tiles of a picture are scanned according to tile scan order in picture;</li>        <li id="ul0006-0002" num="0302">the CTUs of one tile are scanned completely before any of the CTUs in a different tile;</li>        <li id="ul0006-0003" num="0303">in each tile, CTUs are scanned in raster scan order (CTU scan order in tile).</li>    </ul>    </li></ul></p><p id="p-0304" num="0304">Signaling of Slices</p><p id="p-0305" num="0305">The following table exemplifies signalling of sizes and coordinates of rectangular shaped slices in a picture, which is disclosed in the Picture Parameter Set RBSP syntax table of VVC draft 8.</p><p id="p-0306" num="0000"><tables id="TABLE-US-00003" num="00003"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="238pt" align="left"/><colspec colname="2" colwidth="21pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;if( NumTilesInPic &#x3e; 1 )</entry><entry/></row><row><entry>&#x2003;&#x2003;rect_slice_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( rect_slice_flag )</entry></row><row><entry>&#x2003;&#x2003;single_slice_per_subpic_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( rect_slice_flag &#x26;&#x26; !single_slice_per_subpic_flag ) {</entry></row><row><entry>&#x2003;&#x2003;num_slices_in_pic_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;if( num_slices_in_pic_minus1 &#x3e; 0 )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;tile_idx_delta_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c; num_slices_in_pic_minus1; i++ ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( NumTileColumns &#x3e; 1 )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_width_in_tiles_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( NumTileRows &#x3e; 1 &#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;( tile_idx_delta_present_flag | | tileIdx % NumTileColumns</entry></row><row><entry>= = 0 ) )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( slice_width_in_tiles_minus1[ i ] = = 0 &#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ] = = 0 &#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;RowHeight[ SliceTopLeftTileIdx[ i ] / NumTileRows] &#x3e; 1 ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;num_exp_slices_in_tile[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;numExpSlicesInTile = num_exp_slices_in_tile[ i ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c; numExpSlicesInTile; j++ )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;exp_slice_height_in_ctus_minus1[ j ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;i += NumSlicesInTile[ i ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( tile_idx_delta_present_flag &#x26;&#x26; i &#x3c; num_slices_in_pic_minus1</entry></row><row><entry>)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;tile_idx_delta[ i ]</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0307" num="0306">In VVC draft 8, a slice contains one or more complete tiles, or a tile contains one or more complete slices. Therefore the slice coordinates and sizes are indicated with respect to tile partitioning. In VVC draft 8, the tile partitioning is signalled in the picture parameter set. The slice partitioning information is signalled using the tile mapping information.</p><p id="p-0308" num="0307">In the above table, a value of the syntax element num_slices_in_pic_minus1 indicates a number of slices in a picture. A value of syntax element Tile_idx_delta[i] indicates a difference between the tile indexes of first tile of the (i+1) th slice and i th slice. For example, a tile index of the first tile of the first slice in a picture is 0. If the tile index of the first tile of the second slice is 5, a value of Tile_idx_delta[0] is equal to 5. In this context, the tile index may be used as an address of the slice, e.g. an index of the first tile of a slice is the starting address of the slice.</p><p id="p-0309" num="0308">A value of syntax element slice_width_in_tiles_minus1[i] indicates the width the i th slice in the picture in number of tiles, and a value of syntax element slice_height_in_tiles_minus1[i] indicates the height of the i<sup>th </sup>slice in the picture, in number of tiles (in an example, as disclosed in VVC draft 8, slice_width_in_tiles_minus1[i] plus 1 specifies the width of the i<sup>th </sup>rectangular slice in units of tile columns. slice_height_in_tiles_minus1[i] plus 1 specifies the height of the i<sup>th </sup>rectangular slice in units of tile rows).</p><p id="p-0310" num="0309">In the above table, if a value of slice_width_in_tiles_minus1[i] and a value of slice_height_in_tiles_minus1[i] are both equal to 0 (indicating that i th slice has a dimension of at most one tile in height and one tile in width), a value of syntax element num_exp_slices_in_tile[i] is coded in the bitstream. The value the syntax element num_exp_slices_in_tile[i] indicates a number of slices in a tile.</p><p id="p-0311" num="0310">According to VVC draft 8, a slice may contain multiple complete tiles or a tile may contain multiple complete slices. As shown in the above syntax table, a number of tiles in a slice is indicated by slice_width_in_tiles_minus1[i] and slice_height_in_tiles_minus1[i]. And if the number of tiles in a slice is equal to 1, a number of slices in the tile is indicated by num_exp_slices_in_tile[i]. So if the value of slice_width_in_tiles_minus1[i] and the value of slice_height_in_tiles_minus1[i] are both equal to 1, the size of the slice might be equal to or smaller than a size of a tile.</p><p id="p-0312" num="0311">The syntax element single_slice_per_subpic_flag is true (e.g. a value of single_slice_per_subpic_flag is equal to 1) indicates that there is one and only one slice per subpicture for all subpictures of a picture (in this case, a subpicture cannot be divided into more than one slice).</p><p id="p-0313" num="0312">According to one alternative signaling method, the slice starting addresses and slice sizes are indicated in VVC draft 8 is according to following steps:<ul id="ul0007" list-style="none">    <li id="ul0007-0001" num="0000">    <ul id="ul0008" list-style="none">        <li id="ul0008-0001" num="0313">1. First the tile partitioning information is indicated in the bitstream, where an index (tileIdx) is used to index tiles in a picture (According to the tile scan order in picture). After this step, values of the indices, coordinates and sizes of each tile are obtained.</li>        <li id="ul0008-0002" num="0314">2. A number of slices in the picture is signalled. In one example, the number of slices can be indicated by a value of syntax element num_slices_in_pic_minus1.</li>        <li id="ul0008-0003" num="0315">3. For the first slice in the picture, width and height of the slice in number of tiles are indicated. The starting address of the first slice is not explicitly signalled, and is inferred to be tileIdx 0, first tile in the picture is the first tile in the first slice of the picture.</li>        <li id="ul0008-0004" num="0316">4. If the size of the first slice is equal to one tile in width and one tile in height, and if there are more than one CTU rows in the tile, a value of syntax element num_exp_slices_in_tile[0] is signalled, the value of syntax element num_exp_slices_in_tile[0] indicates a quantity of slices that are comprised in the said tile. The value of num_exp_slices_in_tile[0] might indicate a number of slices in a tile whose sizes are explicitly indicated in the bitstream, whereas there might be slices in the said tile whose quantity and sizes are inferred based on the size of the tile, and sizes of the slices whose sizes are explicitly signalled. The total number of slices in a tile might therefore be determined according to num_exp_slices_in_tile[0] and the size of the tile. In one example, the number of slices in a tile can be represented by the parameter numSlicesInTile[0].</li>        <li id="ul0008-0005" num="0317">5. For each of the second slice till the last slice (including second slice but excluding the last slice) in the picture, width and height of the slice in number of tiles is explicitly indicated. The starting address of the slice might be explicitly indicated by a value of syntax element tile_idx_delta[i], where i is the index of the slice. If the starting address is not explicitly signalled (e.g. if slices are signalled in an order that makes it possible to infer the starting position of a next slice, by using the starting position and width and height of the current slice), then the starting address of the slice is inferred via a function. As an example, if slices are signalled in the bitstream in left to right order in a picture, if the horizontal coordinate of the starting address of a slice and the width of the slice are known, the horizontal coordinate of the starting coordinate of the next slice is inferred as sum of width of the slices plus starting address of the slice.</li>        <li id="ul0008-0006" num="0318">6. If a size of the n<sup>th </sup>slice (n is between 2 and value of slices in picture minus 1, both inclusive) is equal to 1 tile in width and 1 tile in height, and if there is more than 1 CTU rows in the tile that is comprised within the n<sup>th </sup>slice, a value of syntax element num_exp_slices_in_tile[n] is signalled, the value of syntax element num_exp_slices_in_tile[n] indicates a quantity of slices that are comprised in the said tile.</li>        <li id="ul0008-0007" num="0319">7. For the last slice in the picture, the width and height of the slice is not explicitly signalled, but inferred according to the number of tiles in picture width, number of tiles in picture height and the starting address of the last slice. The starting address of the last slice can be explicitly indicated or inferred. The inference of the width and height of the last slice in picture can be performed according to following two equations, which are from the section 6.5.1 of VVC Draft 8.        <ul id="ul0009" list-style="none">            <li id="ul0009-0001" num="0320">slice_width_in_tiles_minus1[i]=NumTileColumns&#x2212;1&#x2212;tileX</li>            <li id="ul0009-0002" num="0321">slice_height_in_tiles_minus1[i]=NumTileRows&#x2212;1&#x2212;tileY<br/>slice_width_in_tiles_minus1[i] plus 1 specifies the width of the i<sup>th </sup>rectangular slice in units of tile columns.<br/>slice_height_in_tiles_minus1[i] plus 1 specifies the height of the i<sup>th </sup>rectangular slice in units of tile rows.</li>        </ul>        </li>    </ul>    </li></ul></p><p id="p-0314" num="0322">In the above steps, the width and height of the last slice is not signaled, as it can be inferred if the starting address of the slice is known.</p><p id="p-0315" num="0323">The variables tileX, tileY, NumTileColumns, NumTileRows in the above equation are explained later.</p><p id="p-0316" num="0324">Section 6.5.1 of VVC draft 8</p><p id="p-0317" num="0325">6.5.1 CTB raster scanning, tile scanning, and subpicture scanning processes</p><p id="p-0318" num="0326">For rectangular slices, the list NumCtusInSlice[i] for i ranging from 0 to num_slices_in_pic_minus1, inclusive, specifying the number of CTU in the i-th slice, the list SliceTopLeftTileldx[i] for i ranging from 0 to num_slices_in_pic_minus1, inclusive, specifying the index of the top-left tile of the slice, and the matrix CtbAddrinSlice[i][j] for i ranging from 0 to num_slices_in_pic_minus1, inclusive, and j ranging from 0 to NumCtusInSlice[i]&#x2212;1, inclusive, specifying the picture raster scan address of the j-th CTB within the i-th slice, are derived as follows:</p><p id="p-0319" num="0000"><tables id="TABLE-US-00004" num="00004"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>if( single_slice_per_subpic_flag ) {</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c;= sps_num_subpics_minus1; i++ )</entry></row><row><entry>&#x2003;&#x2003;NumCtusInSlice[ i ] = 0</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c; PicSizeInCtbsY; i ++ ) {</entry></row><row><entry>&#x2003;&#x2003;sliceIdx = subpic_info_present_flag ? CtbToSubpicIdx[ i ] : 0</entry></row><row><entry>&#x2003;&#x2003;CtbAddrInSlice[ sliceIdx ][ NumCtusInSlice[ sliceIdx ] ] = i</entry></row><row><entry>&#x2003;&#x2003;&#x2003;NumCtusInSlice[ sliceIdx ]++</entry></row><row><entry>&#x2003;}</entry></row><row><entry>} else {</entry></row><row><entry>&#x2003;tileIdx = 0</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c;= num_slices_in_pic_minus1; i++ )</entry></row><row><entry>&#x2003;&#x2003;NumCtusInSlice[ i ] = 0</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c;= num_slices_in_pic_minus1; i++ ) {</entry></row><row><entry>&#x2003;&#x2003;SliceTopLeftTileIdx[ i ] = tileIdx</entry></row><row><entry>&#x2003;&#x2003;tileX = tileIdx % NumTileColumns</entry></row><row><entry>&#x2003;&#x2003;tileY = tileIdx / NumTileColumns</entry></row><row><entry>&#x2003;&#x2003;if( i = = num_slices_in_pic_minus1 ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;slice_width_in_tiles_minus1[ i ] = NumTileColumns &#x2212; 1 &#x2212; tileX</entry></row><row><entry>&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ] = NumTileRows &#x2212; 1 &#x2212; tileY</entry></row><row><entry>&#x2003;&#x2003;&#x2003;NumSlicesInTile[ i ] = 1</entry></row><row><entry>&#x2003;&#x2003;}</entry></row><row><entry>if( slice_width_in_tiles_minus1[ i ] = = 0 &#x26;&#x26;</entry></row><row><entry>slice_height_in_tiles_minus1[ i ] = = 0 ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;ctbY = tileRowBd[ tileY ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c; NumSlicesInTile[ i ] &#x2212; 1; j++ ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;AddCtbsToSlice( i, tileColBd[ tileX ], tileColBd[ tileX + 1 ],</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;ctbY, ctbY + SliceHeightInCtusMinus1[ i ] + 1 )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ctbY += SliceHeightInCtusMinus1[ i ] + 1</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;i++</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;&#x2003;AddCtbsToSlice( i, tileColBd[ tileX ], tileColBd[ tileX + 1 ], ctbY,</entry></row><row><entry>tileRowBd[ tileY + 1 ] )</entry></row><row><entry>&#x2003;&#x2003;} else</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c;= slice_height_in_tiles_minus1[ i ]; j++ )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;for( k = 0; k &#x3c;= slice_width_in_tiles_minus1[ i ]; k++ )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;AddCtbsToSlice( i, tileColBd[ tileX + k ], tileColBd[ tileX + k + 1 ],</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;tileRowBd[ tileY + j ], tileRowBd[ tileY + j + 1 ] )</entry></row><row><entry>&#x2003;&#x2003;if( tile_idx_delta_present_flag )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;tileIdx += tile_idx_delta[ i ]</entry></row><row><entry>&#x2003;&#x2003;else {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;tileIdx += slice_width_in_tiles_minus1[ i ] + 1</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( tileIdx % NumTileColumns = = 0 )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;tileIdx += slice_height_in_tiles_minus1[ i ] * NumTileColumns</entry></row><row><entry>&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;}</entry></row><row><entry>}</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0320" num="0327">Where the function AddCtbsToSlice(sliceIdx, startX, stopX, startY, stopY) is specified as follows:</p><p id="p-0321" num="0000"><tables id="TABLE-US-00005" num="00005"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="203pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>for( ctbY = startY; ctbY &#x3c; stopY; ctbY++ )</entry></row><row><entry/><entry>&#x2003;for( ctbX = startX; ctbX &#x3c; stopX; ctbX++ ) {</entry></row><row><entry/><entry>&#x2003;CtbAddrInSlice[ sliceIdx ][ NumCtusInSlice[ sliceIdx ] ] =</entry></row><row><entry/><entry>ctbY * PicWidthInCtbsY + ctbX (30)</entry></row><row><entry/><entry>&#x2003;&#x2003;NumCtusInSlice[ sliceIdx ]++</entry></row><row><entry/><entry>&#x2003;}</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0322" num="0328">The above description of the signalling of slice starting addresses and slice sizes in a picture is one example disclosed in VVC draft8. Specifically, the description describes the case where rectangular shaped slices are used, a number of slices in each subpicture is not indicated to be equal to 1 (a value of single_slice_per_subpic_flag syntax element is not equal to 1; when a value of single_slice_per_subpic_flag syntax element is equal to 1, each subpicture of a picture is composed of one and only one slice), more than 1 tile is present in the picture, and number of CTU rows in a tile is greater than 1. If some of the said parameters are changed, other modes of signalling of slice starting addresses and slice sizes can be used. For example, if there is only 1 slice in each subpicture, width and heights of the slices are not explicitly signalled in the bitstream, but inferred to be equal to corresponding subpicture width and height, respectively.</p><p id="p-0323" num="0329">The subclause 6.5.1 of VVC draft 8 also discloses a scan order of CTUs in a slice i, where i is the slice index. The matrix CtbAddrinSlice[i][n], which is the output of this subclause, specifies the CTU scan order in slice i, where n is the CTU index that is from 0 to number of CTUs of slice i. The value of CtbAddrinSlice[i][n] specifies the address of the n th CTU in slice i.</p><p id="p-0324" num="0330">Normally, the CTU scan order in a slice specifies an order in which the CTUs of a slice are scanned. The steps above of Section 6.5.1 of VVC draft 8 exemplifies an example about how the CTU scan order in slice is determined, e.g. how the matrix CtbAddrInSlice[i][n] is constructed.</p><p id="p-0325" num="0331">As disclosed in VVC Draft 8, CtbAddrInSlice[i][n] (which specifies CTU scan order in slice i) also specifies a processing order of CTUs in a slice. Specifically, the CTUs of a picture are processed in the following order:</p><p id="p-0326" num="0332">Slices are indexed by i and processed in increasing i, starting from i which is equal 0 till i which is equal to the number of slices in picture minus 1. Each CTU n in a slice i is processed in increasing order, starting from n which is equal 0 till n which is equal to the number of CTUs in slice i minus 1. The value of CtbAddrInSlice[i][n] specifies the address of the n<sup>th </sup>CTU in slice i.</p><p id="p-0327" num="0333">As disclosed in VVC Draft 8, a signalling method is used to indicate a number of slices in each subpicture of a picture. A value of single_slice_per_subpic_flag is used to indicate whether all subpictures of a picture comprises one and only one slice or not. If a value of single_sliceper_subpic_flag equal to 1, all subpictures of a picture comprises one and only one slice. Otherwise (a value of single_sliceper_subpic_flag is not equal to 1), a subpicture of a picture might comprises more than 1 slice.</p><p id="p-0328" num="0334"><figref idref="DRAWINGS">FIG. <b>9</b></figref> shows CTU addresses in a picture and one slice (slice 5, the 5<sup>th </sup>slice in the picture) in the picture as example. According to this example, values of the CtbAddrinSlice is as follows:</p><heading id="h-0007" level="2">CtbAddrInSlice[4][0]=<b>27</b></heading><heading id="h-0008" level="2">CtbAddrInSlice[4][1]=<b>28</b></heading><heading id="h-0009" level="2">CtbAddrInSlice[4][2]=<b>29</b></heading><heading id="h-0010" level="2">CtbAddrInSlice[4][3]=<b>30</b></heading><heading id="h-0011" level="2">CtbAddrInSlice[4][4]=<b>37</b></heading><heading id="h-0012" level="2">CtbAddrInSlice[4][5]=<b>38</b></heading><heading id="h-0013" level="2">CtbAddrInSlice[4][6]=<b>39</b></heading><heading id="h-0014" level="2">CtbAddrInSlice[4][7]=<b>40</b>.</heading><p id="p-0329" num="0335">Scanning order refers to the indexing, according to the order in which the index is incremented, of X in Y, such as CTU scanning order in tile, where X is CTU and Y is tile.</p><p id="p-0330" num="0336">Processing means decoding or encoding in the encoder or decoder. Therefore the processing order means the order in which X (e.g. a CTU) is processed in in the encoder or decoder.</p><p id="p-0331" num="0337">In the VVC draft 8, when there are more than one tile comprised in a picture, a slice in the picture is signaled as follows:<ul id="ul0010" list-style="none">    <li id="ul0010-0001" num="0000">    <ul id="ul0011" list-style="none">        <li id="ul0011-0001" num="0338">1. Value of syntax element (explicit indication in a bitstream or inference from a bitstream) is used to determine the starting tile address of a slice, in number of tiles.</li>        <li id="ul0011-0002" num="0339">2. For each slice except for the last slice, a quantity of tiles comprised in the slice is signaled.        <ul id="ul0012" list-style="none">            <li id="ul0012-0001" num="0340">a. If the slice only comprise 1 tile, a quantity of slices comprised in the tile is indicated.</li>        </ul>        </li>        <li id="ul0011-0003" num="0341">3. For the last slice in the picture, a quantity of tiles comprised in the slice is inferred if the slice comprises at least 1 complete tile.</li>    </ul>    </li></ul></p><p id="p-0332" num="0342">In VVC Draft 8, if a size of the last slice in a picture is greater than or equal to 1 tile (in width and height), then a value of the size of the last slice is inferred from a bitstream and not directly coded in the bitstream.</p><p id="p-0333" num="0343">As showed in the above, a value of the slice_width_in_tiles_minus1[i] and a value of slice_height_in_tiles_minus1[i] (which indicate the width and height of the i-th slice in number of tiles, respectively) are coded in a bitstream if i is smaller than num_slices_in_pic_minus1 (due to the for-loop &#x201c;for (i=0; i&#x3c;num_slices_in_pic_minus1; i++)&#x201d;). A value of the width and a value of height of the slice are not signalled when i is equal to num_slices_in_pic_minus1, e.g. for the last slice.</p><heading id="h-0015" level="1">Embodiment 1</heading><p id="p-0334" num="0000"><ul id="ul0013" list-style="none">    <li id="ul0013-0001" num="0000">    <ul id="ul0014" list-style="none">        <li id="ul0014-0001" num="0344">Determine whether a picture is partitioned into more than one tile.</li>        <li id="ul0014-0002" num="0345">When it is determined that the picture is partitioned into more than one tile (e.g. when the NumTilesInPic&#x3e;1 condition is true), obtain a quantity of tiles in a picture width (e.g. the number of tiles in a tile row of a picture), NumTileColumns.</li>        <li id="ul0014-0003" num="0346">Obtain a quantity of tile rows in the picture height (e.g. the number of tiles in a tile column of a picture), NumTileRows.</li>        <li id="ul0014-0004" num="0347">Obtain the top-left coordinate of a slice in tile index (SliceTopLeftTileldx[i]). A value of tile index specifies an index value of a tile in the picture, where tiles are ordered (indexed) in raster scan order in a picture.</li>        <li id="ul0014-0005" num="0348">Obtain the horizontal coordinate of the tile according to the value of the tile index, indicated by parameter tileX.</li>        <li id="ul0014-0006" num="0349">Obtain the vertical coordinate of the tile according to the value of the tile index, indicated by parameter tileY.</li>        <li id="ul0014-0007" num="0350">For each slice in the picture, a value of an indication for the width of the slice is coded in the bitstream, if a difference value between NumTileColumns and tileX is greater than a first threshold.</li>        <li id="ul0014-0008" num="0351">For each slice in the picture, a value of an indication for the height of the slice is coded in the bitstream, if a difference value between NumTileRows and tileY is greater than a second threshold.</li>    </ul>    </li></ul></p><p id="p-0335" num="0352">The first and second thresholds might be integer numbers that are greater than 0. In one example both threshold values might be equal to 1. The thresholds indicate a size threshold in number of tiles along horizontal (first threshold) and vertical (second threshold) directions. When the first threshold indicates that the size threshold is equal to 1 tile, the indication for slice width is included in the bitstream if the difference between tileX and number of tiles in picture width is greater than 1 tile. It is noted that depending on the starting value convention of tileX (the value of tileX for the first tile in the picture), the threshold might be different. For example if the starting value of tileX is 0, then first threshold might be 1. If the starting value of tileX is 1, then first threshold might be 0.</p><p id="p-0336" num="0353">In an embodiment, a value of the width of the last slice and a value of the height of the last slice are also not coded in the bitstream, if the last slice comprises at least 1 complete tile.</p><p id="p-0337" num="0354">In an embodiment, a value of tileX is obtained according to modulo operation and according to a value of NumTileColumns. For example, tileX=tileIdx % NumTileColumns.</p><p id="p-0338" num="0355">In an embodiment, a value of tileY is obtained according to division operation and according to a value of NumTileRows. For example, tileY=tileIdx/NumTileRows.</p><p id="p-0339" num="0356">In an embodiment, the condition &#x201c;greater than threshold a&#x201d; may be implemented as &#x201c;not equal to a threshold b&#x201d;. It is also possible to implement the condition as &#x201c;greater than or equal to a threshold c&#x201d;. Normally, the threshold a is equal to the threshold b, and the third threshold c is equal to threshold a+1.</p><p id="p-0340" num="0357">One possible implementation of the invention is depicted in table 3. The table 1, which was part of VVC draft 8 is modified.</p><p id="p-0341" num="0358">In table 3, row number 10 and 11 describe how to obatin the tileX and tileY. A value of SliceTopLeftTileldx[i] specifies a value of the index (tile index) of the top-left tile in the i-th slice. A value of the tile index is the index of a tile in a picture, where tiles are ordered in the picture in raster scan order. For example showed in <figref idref="DRAWINGS">FIG. <b>7</b></figref>, the tile comprises CTU 0 has the tile index 0. The tile comprises CTU 16 has tile index 1, the tile comprises CTU 24 has tile index 2, the tile comprises CTU 44 has tile index 3, the tile comprises CTU 52 has tile index 4, the tile comprises CTU 56 has tile index 5, and so on.</p><p id="p-0342" num="0359">A value of tileX (horizontal coordinate of tile in the picture) and a value of tileY (vertical coordinate of tile in the picture) are obtained using the equations:</p><p id="p-0343" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>tileX=SliceTopLeftTileldx[i]% NumTileColumns;<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0344" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>tileY=SliceTopLeftTileldx[i]/NumTileColumns.<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0345" num="0360">In an embodiment, in line 12, the following condition &#x201c;NumTileColumns&#x2212;tileX&#x3e;1&#x201d; is added to other conditions. If the condition is not satisfied (NumTileColumns&#x2212;tileX is not greater than 1), a value of syntax element slice_width_in_tiles_minus1[i] is not directly coded in a bitstream. Therefore bitrate saving and hence compression efficiency can be achieved.</p><p id="p-0346" num="0361">Similarly, in line 14, the following condition &#x201c;NumTileRows&#x2014; tileY&#x3e;1&#x201d; is added to other conditions. If the condition is not satisfied (NumTileRows&#x2014; tileY is not greater than 1), a value of syntax element slice_height_in_tiles_minus1[i] is not directly coded in the bitstream. Therefore bitrate saving and hence compression efficiency can be achieved. In an example, the threshold value is 1, which can be different in different implementations.</p><p id="p-0347" num="0000"><tables id="TABLE-US-00006" num="00006"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="231pt" align="left"/><colspec colname="2" colwidth="21pt" align="left"/><colspec colname="3" colwidth="14pt" align="char"/><thead><row><entry namest="1" nameend="3" rowsep="1">TABLE 3</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;if( NumTilesInPic &#x3e; 1 )</entry><entry/><entry>1</entry></row><row><entry>&#x2003;&#x2003;rect_slice_flag</entry><entry>u(1)</entry><entry>2</entry></row><row><entry>&#x2003;if( rect_slice_flag )</entry><entry/><entry>3</entry></row><row><entry>&#x2003;&#x2003;single_slice_per_subpic_flag</entry><entry>u(1)</entry><entry>4</entry></row><row><entry>&#x2003;if( rect_slice_flag &#x26;&#x26; !single_slice_per_subpic_flag ) {</entry><entry/><entry>5</entry></row><row><entry>&#x2003;&#x2003;num_slices_in_pic_minus1</entry><entry>ue(v)</entry><entry>6</entry></row><row><entry>&#x2003;&#x2003;if( num_slices_in_pic_minus1 &#x3e; 0 )</entry><entry/><entry>7</entry></row><row><entry>&#x2003;&#x2003;&#x2003;tile_idx_delta_present_flag</entry><entry>u(l)</entry><entry>8</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c; num_slices_in_pic_minus1; i++ ) {</entry><entry/><entry>9</entry></row><row><entry>&#x2003;&#x2003;&#x2003;tileX = SliceTopLeftTileIdx[ i ] % NumTileColumns</entry><entry/><entry>10</entry></row><row><entry>&#x2003;&#x2003;&#x2003;tileY = SliceTopLeftTileIdx[ i ] / NumTileRows</entry><entry/><entry>11</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( NumTileColumns &#x3e; 1 &#x26;&#x26; NumTileColumns &#x2212; tileX &#x3e; 1 )</entry><entry/><entry>12</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_width_in_tiles_minus1[ i ]</entry><entry>ue(v)</entry><entry>13</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( NumTileRows &#x3e; 1 &#x26;&#x26; NumTileRows &#x2212; tileY &#x3e; 1 &#x26;&#x26;</entry><entry/><entry>14</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;( tile_idx_delta_present_flag | | tileX = = 0 ) )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ]</entry><entry>ue(v)</entry><entry>15</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( slice_width_in_tiles_minus1[ i ] = = 0 &#x26;&#x26;</entry><entry/><entry>16</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ] = = 0 &#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;RowHeight[ SliceTopLeftTileIdx[ i ] / NumTileColumns ] &#x3e; 1 ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;num_exp_slices_in_tile[ i ]</entry><entry>ue(v)</entry><entry>17</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;numExpSlicesInTile = num_exp_slices_in_tile[ i ]</entry><entry/><entry>18</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c; numExpSlicesInTile; j++ )</entry><entry/><entry>19</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;exp_slice_height_in_ctus_minus1[ j ]</entry><entry>ue(v)</entry><entry>20</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;i += NumSlicesInTile[ i ]</entry><entry/><entry>21</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/><entry>22</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( tile_idx_delta_present_flag &#x26;&#x26; i &#x3c; num_slices_in_pic_minus1</entry><entry/><entry>23</entry></row><row><entry>)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;tile_idx_delta[ i ]</entry><entry>se(v)</entry><entry>24</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/><entry>25</entry></row><row><entry>&#x2003;}</entry><entry/><entry>26</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0348" num="0362">In one embodiment, the values of slice_width_in_tiles_minus1[i] and slice_height_in_tiles_minus1[i] are inferred when they are not present in the bitstream.</p><p id="p-0349" num="0363">Below, an implementation of the invention in Section 6.5.1 of VVC draft 8 is presented as example.</p><p id="p-0350" num="0364">According to one example, the values are inferred to be equal to zero. This can for instance be implemented in the Section 6.5.1 of VVC draft 8 as follows:</p><p id="p-0351" num="0000"><tables id="TABLE-US-00007" num="00007"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="42pt" align="left"/><colspec colname="1" colwidth="175pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>if(NumTileColumns &#x2212; tileX =&#x3c; 1) {</entry></row><row><entry/><entry>&#x2003;slice_width_in_tiles_minus1[ i ] = 0</entry></row><row><entry/><entry>}</entry></row><row><entry/><entry>if(NumTileRows &#x2212; tileY =&#x3c; 1) {</entry></row><row><entry/><entry>&#x2003;slice_height_in_tiles_minus1[ i ] = 0</entry></row><row><entry/><entry>}</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0352" num="0365">In the above assignments, the values of slice_width_in_tiles_minus1[i] is set equal to 0 when the difference between NumTileColumns and tileX is greater than 1, which is the same threshold that determines the presence of slice_width_in_tiles_minus1[i] in the bitstream. In other words, the condition &#x201c;NumTileColumns&#x2212;tileX&#x3c;=thr&#x201d; determines whether or not slice_width_in_tiles_minus1[i] is present in the bitstream, and when slice_width_in_tiles_minus1[i] is not present in the bitstream, the value of slice_width_in_tiles_minus1[i] is inferred (set equal to 0). Similar assignment is done for slice_height_in_tiles_minus1[i] when slice_height_in_tiles_minus1[i] is not present in the bitstream.</p><p id="p-0353" num="0366">The conditions &#x201c;NumTileRows&#x2212;tileY=&#x3c;1&#x201d; and &#x201c;NumTileColumns&#x2212;tileX=&#x3c;1&#x201d; in Section 6.5.1 of VVC draft 8 below are for checking the presence of slice_width_in_tiles_minus1[i] and slice_height_in_tiles_minus1[i] in the bitstream. They might be represented in other ways as well, the key point is when slice_width_in_tiles_minus1 and slice_height_in_tiles_minus1 are not present in rows 13 and 15 of table 3 (the condition for determining presence in the bitstream evaluates to false), then the values of slice_width_in_tiles_minus1 and slice_height_in_tiles_minus1 should be inferred as 0.</p><p id="p-0354" num="0367">The value of slice_height_in_tiles_minus1[i] is inferred to be zero indicates the height of the slice i is equal to 1 tile.</p><p id="p-0355" num="0368">When the value of slice_width_in_tiles_minus1[i] is inferred to be zero, it indicates the width of the slice i is equal to 1 tile.</p><p id="p-0356" num="0369">slice_height_in_tiles_minus1 and slice_width_in_tiles_minus1 are syntax elements that indicate the size of the slice in each direction. According to embodiments of the invention, if the syntax element related to the width or height of the slice in number of tiles is not present in the bitstream, the width or height of the slice is inferred to be 1 tile. Implementation of the invention in Section 6.5.1 of VVC draft 8</p><p id="p-0357" num="0370">6.5.1 CTB Raster Scanning, Tile Scanning, and Subpicture Scanning Processes</p><p id="p-0358" num="0371">For rectangular slices, the list NumCtusInSlice[i] for i ranging from 0 to num_slices_inpic_minus1, inclusive, specifying the number of CTU in the i-th slice, the list SliceTopLeftTileldx[i] for i ranging from 0 to num_slices_inpic_minus1, inclusive, specifying the index of the top-left tile of the slice, and the matrix CtbAddrinSlice[i][j] for i ranging from 0 to num_slices_inpic_minus1, inclusive, and j ranging from 0 to NumCtusInSlice[i]&#x2212;1, inclusive, specifying the picture raster scan address of the j-th CTB within the i-th slice, are derived as follows:</p><p id="p-0359" num="0000"><tables id="TABLE-US-00008" num="00008"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>if( single_slice_per_subpic_flag ) {</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c;= sps_num_subpics_minus1; i++ )</entry></row><row><entry>&#x2003;&#x2003;NumCtusInSlice[ i ] = 0</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c; PicSizeInCtbsY; i ++ ) {</entry></row><row><entry>&#x2003;&#x2003;sliceIdx = subpic_info_present_flag ? CtbToSubpicIdx[ i ] : 0</entry></row><row><entry>&#x2003;&#x2003;CtbAddrInSlice[ sliceIdx ][ NumCtusInSlice[ sliceIdx ] ] = i</entry></row><row><entry>&#x2003;&#x2003;NumCtusInSlice[ sliceIdx ]++</entry></row><row><entry>&#x2003;}</entry></row><row><entry>} else {</entry></row><row><entry>&#x2003;tileIdx = 0</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c;= num_slices_in_pic_minus1; i++ )</entry></row><row><entry>&#x2003;&#x2003;NumCtusInSlice[ i ] = 0</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c;= num_slices_in_pic_minus1; i++ ) {</entry></row><row><entry>&#x2003;&#x2003;SliceTopLeftTileIdx[ i ] = tileIdx</entry></row><row><entry>&#x2003;&#x2003;tileX = tileIdx % NumTileColumns</entry></row><row><entry>&#x2003;&#x2003;tileY = tileIdx / NumTileColumns</entry></row><row><entry>&#x2003;&#x2003;if( i = = num_slices_in_pic_minus1 ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;slice_width_in_tiles_minus1[ i ] = NumTileColumns &#x2212; 1 &#x2212; tileX</entry></row><row><entry>&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ] = NumTileRows &#x2212; 1 &#x2212; tileY</entry></row><row><entry>&#x2003;&#x2003;&#x2003;NumSlicesInTile[ i ] = 1</entry></row><row><entry>&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;if( NumTileColumns &#x2212; tileX &#x3c;= 1) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;slice_width_in_tiles_minus1[ i ] = 0</entry></row><row><entry>}</entry></row><row><entry>&#x2003;&#x2003;if( NumTileRows &#x2212; tileY &#x3c;= 1 ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ] = 0</entry></row><row><entry>&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;if( slice_width_in_tiles_minus1[ i ] = = 0 &#x26;&#x26;</entry></row><row><entry>slice_height_in_tiles_minus1[ i ] = = 0 ){</entry></row><row><entry>&#x2003;&#x2003;&#x2003;ctbY = tileRowBd[ tileY ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c; NumSlicesInTile[ i ] &#x2212; 1; j++ ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;AddCtbsToSlice( i, tileColBd[ tileX ], tileColBd[ tileX + 1 ],</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;ctbY, ctbY + SliceHeightInCtusMinus1[ i ] + 1 )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ctbY += SliceHeightInCtusMinus1[ i ] + 1</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;i++</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;&#x2003;AddCtbsToSlice( i, tileColBd[ tileX ], tileColBd[ tileX + 1 ], ctbY,</entry></row><row><entry>tileRowBd[ tileY + 1 ] )</entry></row><row><entry>&#x2003;&#x2003;} else</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c;= slice_height_in_tiles_minus1[ i ]; j++ )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;for( k = 0; k &#x3c;= slice_width_in_tiles_minus1[ i ]; k++ )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;AddCtbsToSlice( i, tileColBd[ tileX + k ], tileColBd[ tileX + k + 1 ],</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;tileRowBd[ tileY + j ], tileRowBd[ tileY + j + 1 ] )</entry></row><row><entry>&#x2003;&#x2003;if( tile_idx_delta_present_flag )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;tileIdx += tile_idx_delta[ i ]</entry></row><row><entry>&#x2003;&#x2003;else {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;tileIdx += slice_width_in_tiles_minus1[ i ] + 1</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( tileIdx % NumTileColumns = = 0 )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;tileIdx += slice_height_in_tiles_minus1[i] * NumTileColumns</entry></row><row><entry>&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;}</entry></row><row><entry>}</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>Where the function AddCtbsToSlice(sliceIdx, startX, stopX, startY, stopY) is specified as follows:</p><p id="p-0360" num="0000"><tables id="TABLE-US-00009" num="00009"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="203pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>for( ctbY = startY; ctbY &#x3c; stopY; ctbY++ )</entry></row><row><entry/><entry>&#x2003;for( ctbX = startX; ctbX &#x3c; stopX; ctbX++ ) {</entry></row><row><entry/><entry>&#x2003;&#x2003;CtbAddrInSlice[ sliceIdx ][ NumCtusInSlice[ sliceIdx ] ] =</entry></row><row><entry/><entry>ctbY * PicWidthInCtbsY + ctbX (30)</entry></row><row><entry/><entry>&#x2003;&#x2003;NumCtusInSlice[ sliceIdx ]++</entry></row><row><entry/><entry>&#x2003;}</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0361" num="0372">As shown in <figref idref="DRAWINGS">FIG. <b>13</b></figref>, a method of coding implemented by a decoding device is disclosed, the method comprising:</p><p id="p-0362" num="0373">S<b>1301</b>: obtaining a bitstream for a current picture.</p><p id="p-0363" num="0374">The bitstream may be obtained according to wireless network or wired network. The bitstream may be transmitted from a website, server, or other remote source using a coaxial cable, fiber optic cable, twisted pair, digital subscriber line (DSL), or wireless technologies such as infrared, radio, microwave, WIFI, Bluetooth, LTE or 5G.</p><p id="p-0364" num="0375">In an embodiment, a bitstream are a sequence of bits, in the form of a network abstraction layer (NAL) unit stream or a byte stream, that forms the representation of a sequence of access units (AUs) forming one or more coded video sequences (CVSs).</p><p id="p-0365" num="0376">In some embodiments, for a decoding process, decoder side reads a bitstream and derives decoded pictures from the bitstream; for an encoding process, encoder side produces a bitstream.</p><p id="p-0366" num="0377">Normally, a bitstream will comprise syntax elements that are formed by a syntax structure. syntax element: An element of data represented in the bitstream.</p><p id="p-0367" num="0378">syntax structure: Zero or more syntax elements present together in the bitstream in a specified order.</p><p id="p-0368" num="0379">In a specific example, bitstream formats specifies the relationship between the network abstraction layer (NAL) unit stream and byte stream, either of which are referred to as the bitstream.</p><p id="p-0369" num="0380">The bitstream can be in one of two formats: the NAL unit stream format or the byte stream format. The NAL unit stream format is conceptually the more &#x201c;basic&#x201d; type. The NAL unit stream format comprises a sequence of syntax structures called NAL units. This sequence is ordered in decoding order. There are constraints imposed on the decoding order (and contents) of the NAL units in the NAL unit stream.</p><p id="p-0370" num="0381">The byte stream format can be constructed from the NAL unit stream format by ordering the NAL units in decoding order and prefixing each NAL unit with a start code prefix and zero or more zero-valued bytes to form a stream of bytes. The NAL unit stream format can be extracted from the byte stream format by searching for the location of the unique start code prefix pattern within this stream of bytes.</p><p id="p-0371" num="0382">This clause specifies the relationship between source and decoded pictures that is given via the bitstream.</p><p id="p-0372" num="0383">The video source that is represented by the bitstream is a sequence of pictures in decoding order.</p><p id="p-0373" num="0384">The source and decoded pictures are each comprised of one or more sample arrays:<ul id="ul0015" list-style="none">    <li id="ul0015-0001" num="0000">    <ul id="ul0016" list-style="none">        <li id="ul0016-0001" num="0385">Luma (Y) only (monochrome).</li>        <li id="ul0016-0002" num="0386">Luma and two chroma (YCbCr or YCgCo).</li>        <li id="ul0016-0003" num="0387">Green, blue, and red (GBR, also known as RGB).</li>        <li id="ul0016-0004" num="0388">Arrays representing other unspecified monochrome or tri-stimulus colour samplings (for example, YZX, also known as XYZ).</li>    </ul>    </li></ul></p><p id="p-0374" num="0389">The variables and terms associated with these arrays are referred to as luma (or L or Y) and chroma, where the two chroma arrays are referred to as Cb and Cr; regardless of the actual colour representation method in use. The actual colour representation method in use can be indicated in syntax that is specified in VUI parameters as specified in ITU-T H. SEI|ISO/IEC 23002-7.</p><p id="p-0375" num="0390">S<b>1302</b>: obtaining a quantity of tiles in a tile row of the current picture.</p><p id="p-0376" num="0391">It could be understood that, the quantity of tiles in a tile row is same means as a number of tile columns.</p><p id="p-0377" num="0392">In an example, a quantity of tiles in a tile row of the current picture is represented according to a variable NumTileColumns, specifying the number of tile columns.</p><p id="p-0378" num="0393">In an example, a quantity of tiles in a tile row of the current picture is obtained according to parameters coded in the picture parameter set of the bitstream. The quantity of tiles in a tile row of the current picture may be obtained according to directly parse parameter in the bitstream or obtained according to derive a value from parameter.</p><p id="p-0379" num="0394">S<b>1303</b>: obtaining a value of an address of a slice of the current picture.</p><p id="p-0380" num="0395">In an example, the value of the address of the slice specify an address of a top-left coordinate of the slice in tile index.</p><p id="p-0381" num="0396">In an example, the address of the slice is an index of leftmost tile of the topmost tile row of the slice, wherein the tiles comprised in the current picture are indexed according to a raster scan order.</p><p id="p-0382" num="0397">In an example, a value of an address of a slice is represented according to a variable SliceTopLeftTileldx[i], &#x201c;i&#x201d; is a slice index.</p><p id="p-0383" num="0398">SliceTopLeftTileldx[i] for i ranging from 0 to pps_num_slices_inpic_minus1, inclusive, specifying the tile index of the tile containing the first CTU in the slice. pps_num_slices_inpic_minus1 plus 1 specifies the number of rectangular slices in each picture referring to the picture parameter set, PPS.</p><p id="p-0384" num="0399">In an example, a value of an address of a slice is obtained according to parameter coded in the picture parameter set of the bitstream. The quantity of tiles in a tile row of the current picture may be obtained according to directly parse parameter in the bitstream or obtained according to derive a value from parameter.</p><p id="p-0385" num="0400">S<b>1304</b>: obtaining a value of tileX according to the value of the address of the slice.</p><p id="p-0386" num="0401">In an example, the obtaining a value of tileX according to the value of the address of the slice comprises: obtaining the value of the tileX according to the value of the address of the slice and the quantity of tiles in the tile row of the current picture.</p><p id="p-0387" num="0402">In an example, the value of tileX is obtained according to a modulus operation between the value of the address of the slice and the quantity of tiles in the tile row of the current picture.</p><p id="p-0388" num="0403">In an example, tileX=SliceTopLeftTileldx[i]% NumTileColumns.</p><p id="p-0389" num="0404">In an example, the value of tileX indicates a value of a horizontal coordinate.</p><p id="p-0390" num="0405">S<b>1305</b>: parsing an indication value for a slice width from the bitstream for the current picture, when a difference value between the quantity of tiles in the tile row of the current picture and the value of tileX is not equal to a first threshold.</p><p id="p-0391" num="0406">The first threshold is an integer value, the first threshold may be 0, 1, 2 . . . .</p><p id="p-0392" num="0407">In an example, the indication value for a slice width is represented as pps_slice_width_in_tiles_minus1[i]. pps_slice_width_in_tiles_minus1[i] plus 1 specifies the width of the i-th rectangular slice in units of tile columns. The value of pps_slice_width_in_tiles_minus1[i] may be in the range of 0 to NumTileColumns&#x2212;1, inclusive. When not present, the value of pps_slice_width_in_tiles_minus1[i] is inferred to be equal to 0.</p><p id="p-0393" num="0408">It could be understood that, in some examples, the condition &#x201c;when a difference value between the quantity of tiles in the tile row of the current picture and the value of tileX is not equal to a first threshold&#x201d; is equal to the condition &#x201c;when a difference value between the quantity of tiles in the tile row of the current picture and the value of modulus operation between the value of the address of the slice and the quantity of tiles in the tile row of the current picture is not equal to a first threshold&#x201d;. Hence, the value of tileX is not calculated at first but is represented according to the result of modulus operation between the value of the address of the slice and the quantity of tiles in the tile row of the current picture.</p><p id="p-0394" num="0409">According to embodiments of the present invention, a signaling scheme is disclosed, only there are at least two tile columns, then syntax element for slice width is signaled. Hence, the bitstream utilization and decoding efficiency have been improved.</p><p id="p-0395" num="0410">In an example, wherein the method further comprises: setting the indication value for the slice width to a default value, when a difference value between the quantity of tiles in the tile row of the current picture and the value of tileX is equal to the first threshold. The default value is an integer value, in an example, the default value may be 0, or 1.</p><p id="p-0396" num="0411">In an example, wherein the default value indicates that the width of the slice comprises 1 tile column.</p><p id="p-0397" num="0412">In an example, the method further comprises: obtaining a quantity of tiles in a tile column of the current picture; obtaining a value of tileY according to the value of the address of the slice; parsing an indication value for a slice height from the bitstream for the current picture, when a difference value between the quantity of tiles in the tile column of the current picture and the value of the tileY is not equal to a second threshold. The second threshold is an integer value, the second threshold may be 0, 1, 2 . . . .</p><p id="p-0398" num="0413">It could be understood that, the quantity of tiles in a tile column is same means as a number of tile rows.</p><p id="p-0399" num="0414">In an example, the quantity of tiles in a tile column of the current picture is represented according to a variable NumTileRows. The variable NumTileRows, specifying the number of tile row.</p><p id="p-0400" num="0415">In an example, an indication value for a slice height is represented according to pps_slice_height_in_tiles_minus1[i]. pps_slice_height_in_tiles_minus1[i] plus 1 specifies the height of the i-th rectangular slice in units of tile rows when pps_num_exp_slices_in_tile[i] is equal to 0. The value of pps_slice_height_in_tiles_minus1[i] shall be in the range of 0 to NumTileRows&#x2212;1, inclusive.</p><p id="p-0401" num="0416">In an example, the method further comprises: setting the indication value for the slice height to a preset value, when a difference value between the quantity of tiles in the tile column of the current picture and the value of tileY is equal to the second threshold.</p><p id="p-0402" num="0417">In an example, wherein the obtaining a value of tileY according to the value of the address of the slice comprises: obtaining the value of tileY according to the value of the address of the slice and the quantity of tiles in the tile row of the current picture.</p><p id="p-0403" num="0418">In one implementation, wherein the value of tileY is obtained according to an integer division operation between the value of the address of the slice and the quantity of tiles in the tile column of the current picture. E.g. tileY=SliceTopLeftTileIdx[i]/NumTileColumns.</p><p id="p-0404" num="0419">In an example, wherein the value of tileY indicates a value of a vertical coordinate. It could be understood that, in some examples, the condition &#x201c;when a difference value between the quantity of tiles in the tile column of the current picture and the value of tileY is not equal to a second threshold&#x201d; is equal to the condition &#x201c;when a difference value between the quantity of tiles in the tile column of the current picture and the value of the integer division operation between the value of the address of the slice and the quantity of tiles in the tile column of the current picture is not equal to a second threshold&#x201d;. Hence, the value of tileY is not calculated at first but is represented according to the result of the integer division operation between the value of the address of the slice and the quantity of tiles in the tile column of the current picture.</p><p id="p-0405" num="0420">In an example, a syntax table for the above embodiments is</p><p id="p-0406" num="0000"><tables id="TABLE-US-00010" num="00010"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="196pt" align="left"/><colspec colname="2" colwidth="21pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;for( i = 0; i &#x3c; pps_num_slices_in_pic_minus1; i++ ) {</entry><entry/></row><row><entry>&#x2003;&#x2003;if( SliceTopLeftTileIdx[ i ] % NumTileColumns !=</entry></row><row><entry>NumTileColumns &#x2212; 1 )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;pps_slice_width_in_tiles_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( SliceTopLeftTileIdx[ i ] / NumTileColumns !=</entry></row><row><entry>NumTileRows &#x2212; 1 &#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;( pps_tile_idx_delta_present_flag | |</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;SliceTopLeftTileIdx[ i ] % NumTileColumns = = 0 ) )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;pps_slice_height_in_tiles_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0407" num="0421">As shown in <figref idref="DRAWINGS">FIG. <b>14</b></figref>, a video decoding apparatus <b>1400</b> is disclosed, the apparatus <b>1400</b> comprise:</p><p id="p-0408" num="0000">obtaining module <b>1401</b>, which is configured to obtain a bitstream for a current picture; and obtaining module <b>1401</b> is configured to obtain a quantity of tiles in a tile row of the current picture and obtain a value of an address of a slice of the current picture;<br/>calculating module <b>1402</b>, which is configured to obtain a value of tileX according to the value of the address of the slice;<br/>parsing module <b>1403</b>, which is configured to parse an indication value for a slice width from the bitstream for the current picture, when a difference value between the quantity of tiles in the tile row of the current picture and the value of tileX is not equal to a first threshold.</p><p id="p-0409" num="0422">The details for each module could refer to the embodiments and implementations in the above method embodiments.</p><heading id="h-0016" level="1">Benefits of the Invention</heading><p id="p-0410" num="0423"><figref idref="DRAWINGS">FIG. <b>10</b></figref> exemplifies a partitioning of a picture into 96 CTUs, 4 tiles and 8 slices.</p><p id="p-0411" num="0424">According to the solution disclosed in VVC draft 8 document, the following syntax elements need to be coded in the bitstream according to table 1.<ul id="ul0017" list-style="none">    <li id="ul0017-0001" num="0000">    <ul id="ul0018" list-style="none">        <li id="ul0018-0001" num="0425">num_slices_inpic_minus1, whose value is 0.</li>        <li id="ul0018-0002" num="0426">tile_idx_delta_present flag, whose value is equal to 1</li>        <li id="ul0018-0003" num="0427">for the first slice (meaning that i index is equal to 0)        <ul id="ul0019" list-style="none">            <li id="ul0019-0001" num="0428">slice_width_in_tiles_minus1[0], whose value is equal to 0</li>            <li id="ul0019-0002" num="0429">slice_height_in_tiles_minus1[0], whose value is equal to 0</li>            <li id="ul0019-0003" num="0430">num_exp_slices_in_tile[0], whose value is equal to 2</li>            <li id="ul0019-0004" num="0431">exp_slice_height_in_ctus_minus1[0] whose value is equal to 0, which indicates the height of the first slice in number of CTU rows.</li>        </ul>        </li>        <li id="ul0018-0004" num="0432">for the second slice (i=1)        <ul id="ul0020" list-style="none">            <li id="ul0020-0001" num="0433">exp_slice_height_in_ctus_minus1[1] whose value is equal to 1,</li>            <li id="ul0020-0002" num="0434">tile_idx_delta[1], whose value is equal to 1.</li>        </ul>        </li>        <li id="ul0018-0005" num="0435">for the third slice (i=2)        <ul id="ul0021" list-style="none">            <li id="ul0021-0001" num="0436">slice_width_in_tiles_minus1[2], whose value is equal to 0</li>            <li id="ul0021-0002" num="0437">slice_height_in_tiles_minus1[2], whose value is equal to 0</li>            <li id="ul0021-0003" num="0438">num_exp_slices_in_tile[2], whose value is equal to 2</li>            <li id="ul0021-0004" num="0439">exp_slice_height_in_ctus_minus1[2] whose value is equal to 0</li>        </ul>        </li>        <li id="ul0018-0006" num="0440">for the forth slice (i=3)        <ul id="ul0022" list-style="none">            <li id="ul0022-0001" num="0441">exp_slice_height_in_ctus_minus1[3] whose value is equal to 1,</li>            <li id="ul0022-0002" num="0442">tile_idx_delta[3], whose value is equal to 1.</li>        </ul>        </li>        <li id="ul0018-0007" num="0443">for the fifth slice (i=4)        <ul id="ul0023" list-style="none">            <li id="ul0023-0001" num="0444">slice_width_in_tiles_minus1[4], whose value is equal to 0</li>            <li id="ul0023-0002" num="0445">slice_height_in_tiles_minus1[4], whose value is equal to 0</li>            <li id="ul0023-0003" num="0446">num_exp_slices_in_tile[4], whose value is equal to 0</li>            <li id="ul0023-0004" num="0447">tile_idx_delta[4], whose value is equal to 1.</li>        </ul>        </li>        <li id="ul0018-0008" num="0448">for the sixth slice (i=5)        <ul id="ul0024" list-style="none">            <li id="ul0024-0001" num="0449">slice_width_in_tiles_minus1[5], whose value is equal to 0</li>            <li id="ul0024-0002" num="0450">slice_height_in_tiles_minus1[5], whose value is equal to 0</li>            <li id="ul0024-0003" num="0451">num_exp_slices_in_tile[5], whose value is equal to 3</li>            <li id="ul0024-0004" num="0452">exp_slice_height_in_ctus_minus1[5] whose value is equal to 1</li>        </ul>        </li>        <li id="ul0018-0009" num="0453">for the seventh slice (i=6)        <ul id="ul0025" list-style="none">            <li id="ul0025-0001" num="0454">exp_slice_height_in_ctus_minus1[6] whose value is equal to 0,</li>        </ul>        </li>        <li id="ul0018-0010" num="0455">for the eighth slice (i=7)        <ul id="ul0026" list-style="none">            <li id="ul0026-0001" num="0456">exp_slice_height_in_ctus_minus1[7] whose value is equal to 2,</li>        </ul>        </li>    </ul>    </li></ul></p><p id="p-0412" num="0457">According an embodiment of the invention, as showed in Table 3, the following syntax elements need to be coded in the bitstream, in order to describe the same picture partitioning in <figref idref="DRAWINGS">FIG. <b>10</b></figref>.<ul id="ul0027" list-style="none">    <li id="ul0027-0001" num="0000">    <ul id="ul0028" list-style="none">        <li id="ul0028-0001" num="0458">num_slices_in_pic_minus1, whose value is 0.</li>        <li id="ul0028-0002" num="0459">tile_idx_delta_present_flag, whose value is equal to 1</li>        <li id="ul0028-0003" num="0460">for the first slice (meaning that i index is equal to 0)        <ul id="ul0029" list-style="none">            <li id="ul0029-0001" num="0461">slice_width_in_tiles_minus1[0], whose value is equal to 0</li>            <li id="ul0029-0002" num="0462">slice_height_in_tiles_minus1[0], whose value is equal to 0</li>            <li id="ul0029-0003" num="0463">num_exp_slices_in_tile[0], whose value is equal to 2</li>            <li id="ul0029-0004" num="0464">exp_slice_height_in_ctus_minus1[0] whose value is equal to 0, which indicates the height of the first slice in number of CTU rows.</li>        </ul>        </li>        <li id="ul0028-0004" num="0465">for the second slice (i=1)        <ul id="ul0030" list-style="none">            <li id="ul0030-0001" num="0466">exp_slice_height_in_ctus_minus1[1] whose value is equal to 1,</li>            <li id="ul0030-0002" num="0467">tile_idx_delta[1], whose value is equal to 1.</li>        </ul>        </li>        <li id="ul0028-0005" num="0468">for the third slice (i=2)        <ul id="ul0031" list-style="none">            <li id="ul0031-0001" num="0469">slice_height_in_tiles_minus1[2], whose value is equal to 0</li>            <li id="ul0031-0002" num="0470">num_exp_slices_in_tile[2], whose value is equal to 2</li>            <li id="ul0031-0003" num="0471">exp_slice_height_in_ctus_minus1[2] whose value is equal to 0</li>        </ul>        </li>        <li id="ul0028-0006" num="0472">for the forth slice (i=3)        <ul id="ul0032" list-style="none">            <li id="ul0032-0001" num="0473">exp_slice_height_in_ctus_minus1[3] whose value is equal to 1,</li>            <li id="ul0032-0002" num="0474">tile_idx_delta[3], whose value is equal to 1.</li>        </ul>        </li>        <li id="ul0028-0007" num="0475">for the fifth slice (i=4)        <ul id="ul0033" list-style="none">            <li id="ul0033-0001" num="0476">slice_width_in_tiles_minus1[4], whose value is equal to 0</li>            <li id="ul0033-0002" num="0477">num_exp_slices_in_tile[4], whose value is equal to 0</li>            <li id="ul0033-0003" num="0478">tile_idx_delta[4], whose value is equal to 1.</li>        </ul>        </li>        <li id="ul0028-0008" num="0479">for the sixth slice (i=5)        <ul id="ul0034" list-style="none">            <li id="ul0034-0001" num="0480">num_exp_slices_in_tile[5], whose value is equal to 3</li>            <li id="ul0034-0002" num="0481">exp_slice_height_in_ctus_minus1[5] whose value is equal to 1</li>        </ul>        </li>        <li id="ul0028-0009" num="0482">for the seventh slice (i=6)        <ul id="ul0035" list-style="none">            <li id="ul0035-0001" num="0483">exp_slice_height_in_ctus_minus1[6] whose value is equal to 0,</li>        </ul>        </li>        <li id="ul0028-0010" num="0484">for the eighth slice (i=7)        <ul id="ul0036" list-style="none">            <li id="ul0036-0001" num="0485">exp_slice_height_in_ctus_minus1[7] whose value is equal to 2,</li>        </ul>        </li>    </ul>    </li></ul></p><p id="p-0413" num="0486">In summary the following syntax elements do not need to be coded in the bitstream:<ul id="ul0037" list-style="none">    <li id="ul0037-0001" num="0000">    <ul id="ul0038" list-style="none">        <li id="ul0038-0001" num="0487">slice_width_in_tiles_minus1[2], whose value is equal to 0</li>        <li id="ul0038-0002" num="0488">slice_height_in_tiles_minus1[4], whose value is equal to 0</li>        <li id="ul0038-0003" num="0489">slice_width_in_tiles_minus1[5], whose value is equal to 0</li>        <li id="ul0038-0004" num="0490">slice_height_in_tiles_minus1[5], whose value is equal to 0</li>    </ul>    </li></ul></p><p id="p-0414" num="0491">The values of those syntax elements are inferred to be equal to zero according to the following conditions that are added to the Section 6.5.1 of VVC draft 8.</p><p id="p-0415" num="0000"><tables id="TABLE-US-00011" num="00011"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="42pt" align="left"/><colspec colname="1" colwidth="175pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>if( NumTileColumns &#x2212; 1 &#x2212; tileX &#x3c;= 1) {</entry></row><row><entry/><entry>&#x2003;slice_width_in_tiles_minus1[ i ] = 0</entry></row><row><entry/><entry>}</entry></row><row><entry/><entry>if( NumTileRows &#x2212; 1 &#x2212; tileY &#x3c;= 1 ) {</entry></row><row><entry/><entry>&#x2003;slice_height_in_tiles_minus1[ i ] = 0</entry></row><row><entry/><entry>}</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0416" num="0000"><tables id="TABLE-US-00012" num="00012"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="231pt" align="left"/><colspec colname="2" colwidth="21pt" align="left"/><colspec colname="3" colwidth="14pt" align="char"/><thead><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x2003;if( NumTilesInPic &#x3e; 1 )</entry><entry/><entry>1</entry></row><row><entry>&#x2003;&#x2003;rect_slice_flag</entry><entry>u(1)</entry><entry>2</entry></row><row><entry>&#x2003;if( rect_slice_flag )</entry><entry/><entry>3</entry></row><row><entry>&#x2003;&#x2003;single_slice_per_subpic_flag</entry><entry>u(1)</entry><entry>4</entry></row><row><entry>&#x2003;if( rect_slice_flag &#x26;&#x26; !single_slice_per_subpic_flag ) {</entry><entry/><entry>5</entry></row><row><entry>&#x2003;&#x2003;num_slices_in_pic_minus1</entry><entry>ue(v)</entry><entry>6</entry></row><row><entry>&#x2003;&#x2003;if( num_slices_in_pic_minus1 &#x3e; 0 )</entry><entry/><entry>7</entry></row><row><entry>&#x2003;&#x2003;&#x2003;tile_idx_delta_present_flag</entry><entry>u(1)</entry><entry>8</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c; num_slices_in_pic_minus1; i++ ) {</entry><entry/><entry>9</entry></row><row><entry>&#x2003;&#x2003;&#x2003;tileX = SliceTopLeftTileIdx[ i ] % NumTileColumns</entry><entry/><entry>10</entry></row><row><entry>&#x2003;&#x2003;&#x2003;tileY = SliceTopLeftTileIdx[ i ] / NumTileColumns</entry><entry/><entry>11</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( NumTileColumns &#x3e; 1 &#x26;&#x26; NumTileColumns &#x2212; tileX &#x3e; 1)</entry><entry/><entry>12</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_width_in_tiles_minus1[ i ]</entry><entry>ue(v)</entry><entry>13</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( NumTileRows &#x3e; 1 &#x26;&#x26; NumTileRows &#x2212; tileY &#x3e; 1 &#x26;&#x26;</entry><entry/><entry>14</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;( tile_idx_delta_present_flag | | tileX = = 0 ) )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ]</entry><entry>ue(v)</entry><entry>15</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( slice_width_in_tiles_minus1[ i ] = = 0 &#x26;&#x26;</entry><entry/><entry>16</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ] = = 0 &#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;RowHeight[ SliceTopLeftTileIdx[ i ] / NumTileColumns ] &#x3e; 1 ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;num_exp_slices_in_tile[ i ]</entry><entry>ue(v)</entry><entry>17</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;numExpSlicesInTile = num_exp_slices_in_tile[ i ]</entry><entry/><entry>18</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c; numExpSlicesInTile; j++ )</entry><entry/><entry>19</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;exp_slice_height_in_ctus_minus1[ j ]</entry><entry>ue(v)</entry><entry>20</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;i += NumSlicesInTile[ i ]</entry><entry/><entry>21</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/><entry>22</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( tile_idx_delta_present_flag &#x26;&#x26; i &#x3c; num_slices_in_pic_minus1</entry><entry/><entry>23</entry></row><row><entry>)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;tile_idx_delta[ i ]</entry><entry>se(v)</entry><entry>24</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/><entry>25</entry></row><row><entry>&#x2003;}</entry><entry/><entry>26</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0417" num="0492">Following is an explanation of the applications of the encoding method as well as the decoding method as shown in the above-mentioned embodiments, and a system using them.</p><p id="p-0418" num="0000">1. A method of coding implemented by a decoding device, the method comprising: obtaining a bitstream for a current picture (or frame);<br/>obtaining a quantity of tiles in a tile row of the current picture (e.g. a value of NumTileColumns);<br/>obtaining a value of an address of a current slice (e.g. SliceTopLeftTileldx[i]), the current slice is comprised in the current picture;<br/>obtaining a value of a horizontal coordinate (in an example, a horizontal coordinate means a coordinate located in a horizontal coordinate axis) (e.g. tileX) according to the value of the address of the current slice (e.g. SliceTopLeftTileldx[i]);<br/>parsing an indication value for a slice width (i.e. width of a slice) from the bitstream for the current picture (i.e. the indication value for the slice width is coded in the bitstream), when a difference value between the quantity of tiles in the tile row of the current picture (e.g. a value of NumTileColumns) and the value of the horizontal coordinate (e.g. tileX) is greater than a first threshold (e.g. the first threshold is an integer number, may be 0, 1, 2 . . . and so on).</p><p id="p-0419" num="0493">Example 2. The method of example 1, wherein the method further comprises:</p><p id="p-0420" num="0000">setting the indication value for the slice width to a default value (e.g. the default value may be equal to 0), when a difference value between the quantity of tiles in the tile row of the current picture (e.g. a value of NumTileColumns) and the value of the horizontal coordinate (e.g. tileX) is smaller than or equal to the first threshold.</p><p id="p-0421" num="0494">Example 3. The method of example 2, wherein the default value indicates that the width of the current slice comprises 1 tile columns.</p><p id="p-0422" num="0495">Example 4. The method of any one of examples 1 to 3, wherein the obtaining a value of a horizontal coordinate according to the value of the address of the current slice comprises: obtaining the value of the horizontal coordinate according to the value of the address of the current slice and the quantity of tiles in the tile row of the current picture.</p><p id="p-0423" num="0496">Example 5. The method of any one of examples 1 to 4, wherein the address of the current slice is an index of leftmost tile of the topmost tile row of the current slice, wherein the tiles comprised in the current picture are indexed according to a raster scan order.</p><p id="p-0424" num="0497">Example 6. The method of example 4 or 5, wherein the value of the horizontal coordinate is obtained according to a modulus operation between the value of the address of the current slice and the quantity of tiles in the tile row of the current picture (e.g. SliceTopLeftTileldx[i])% NumTileColumns).</p><p id="p-0425" num="0498">Example 7. The method of any one of examples 1 to 6, wherein the value of the address of the current slice (e.g. SliceTopLeftTileldx[i]) specify an address of a top-left coordinate of the current slice in tile index.</p><p id="p-0426" num="0499">Example 8. The method of any one of examples 1 to 7, wherein the method further comprises:</p><p id="p-0427" num="0000">obtaining a quantity of tiles in a tile column of the current picture (e.g. a value of NumTileRows);<br/>obtaining a value of a vertical coordinate (in an example, an vertical coordinate means a coordinate located in an vertical coordinate axis) (e.g. tileY) according to the value of the address of the current slice (e.g. SliceTopLeftTileldx[i]);<br/>parsing an indication value for a slice height (i.e. height of a slice) from the bitstream for the current picture (i.e. the indication value for the slice height is coded in the bitstream), when a difference value between the quantity of tiles in the tile column of the current picture (e.g. a value of NumTileRows) and the value of the vertical coordinate (e.g. tileY) is greater than a second threshold (e.g. the second threshold is an integer number, may be 0, 1,2 . . . and so on).</p><p id="p-0428" num="0500">Example 9. The method of example 8, wherein the method further comprises:</p><p id="p-0429" num="0000">setting the indication value for the slice height to a preset value (e.g. the preset value may be equal to 0), when a difference value between the quantity of tiles in the tile column of the current picture (e.g. a value of NumTileRows) and the value of the vertical coordinate (e.g. tileY) is smaller than or equal to the second threshold.</p><p id="p-0430" num="0501">Example 10. The method of example 8 or 9, wherein the obtaining a value of a vertical coordinate according to the value of the address of the current slice comprises: obtaining the value of the vertical coordinate according to the value of the address of the current slice and the quantity of tiles in the tile column of the current picture.</p><p id="p-0431" num="0502">Example 11. The method of example 10, wherein the value of the vertical coordinate is obtained according to an integer division operation between the value of the address of the current slice and the quantity of tiles in the tile column of the current picture (e.g. SliceTopLeftTileldx[i])/NumTileRows).</p><p id="p-0432" num="0503">Example 12. A method of coding implemented by a decoding device, the method comprising:</p><p id="p-0433" num="0000">obtaining a bitstream for a current picture (or frame);<br/>obtaining a quantity of tiles in a tile column of the current picture (e.g. a value of NumTileRows);<br/>obtaining a value of an address of a current slice (e.g. SliceTopLeftTileldx[i]), the current slice is comprised in the current picture;<br/>obtaining a value of a vertical coordinate (in an example, an vertical coordinate means a coordinate located in an vertical coordinate axis) (e.g. tileY) according to the value of the address of the current slice (e.g. SliceTopLeftTileldx[i]);<br/>parsing an indication value for a slice height (i.e. height of a slice) from the bitstream for the current picture (i.e. the indication value for the slice height is coded in the bitstream), when a difference value between the quantity of tiles in the tile column of the current picture (e.g. a value of NumTileRows) and the value of the vertical coordinate (e.g. tileY) is greater than a second threshold (e.g. the second threshold is an integer number, may be 0, 1,2 . . . and so on).</p><p id="p-0434" num="0504">Example 13. The method of example 12, wherein the method further comprises:</p><p id="p-0435" num="0000">setting the indication value for the slice height to a preset value (e.g. the preset value may be equal to 0), when a difference value between the quantity of tiles in the tile column of the current picture (e.g. a value of NumTileRows) and the value of the vertical coordinate (e.g. tileY) is smaller than or equal to the second threshold.</p><p id="p-0436" num="0505">Example 14. The method of example 13, wherein</p><p id="p-0437" num="0000">the default value indicates that the height of the current slice comprises 1 tile rows.</p><p id="p-0438" num="0506">Example 15. The method of any one of examples 12 to 14, wherein the obtaining a value of a vertical coordinate according to the value of the address of the current slice comprises:</p><p id="p-0439" num="0000">obtaining the value of the vertical coordinate according to the value of the address of the current slice and the quantity of tiles in the tile column of the current picture.</p><p id="p-0440" num="0507">Example 16. The method of any one of examples 12 to 15, wherein the address of the current slice is an index of leftmost tile of the topmost tile row of the current slice, wherein the tiles comprised in the current picture are indexed according to a raster scan order.</p><p id="p-0441" num="0508">Example 17. The method of example 15 or 16, wherein the value of the vertical coordinate is obtained according to an integer division operation between the value of the address of the current slice and the quantity of tiles in the tile column of the current picture (e.g. SliceTopLeftTileldx[i])/NumTileRows).</p><p id="p-0442" num="0509">Example 18. The method of any one of examples 12 to 17, wherein the value of the address of the current slice (e.g. SliceTopLeftTileldx[i]) specify an address of a top-left coordinate of the current slice in tile index.</p><p id="p-0443" num="0510">Example 19. The method of any one of examples 12 to 18, wherein the method further comprises:</p><p id="p-0444" num="0000">obtaining a quantity of tiles in a tile row of the current picture (e.g. a value of NumTileColumns);<br/>obtaining a value of a horizontal coordinate (in an example, a horizontal coordinate means a coordinate located in a horizontal coordinate axis) (e.g. tileX) according to the value of the address of the current slice (e.g. SliceTopLeftTileldx[i]);<br/>parsing an indication value for a slice width (i.e. width of a slice) from the bitstream for the current picture (i.e. the indication value for the slice width is coded in the bitstream), when a difference value between the quantity of tiles in the tile row of the current picture (e.g. a value of NumTileColumns) and the value of the horizontal coordinate (e.g. tileX) is greater than a first threshold (e.g. the first threshold is an integer number, may be 0, 1,2 . . . and so on).</p><p id="p-0445" num="0511">Example 20. The method of example 19, wherein the method further comprises:</p><p id="p-0446" num="0000">setting the indication value for the slice width to a default value (e.g. the default value may be equal to 0), when a difference value between the quantity of tiles in the tile row of the current picture (e.g. a value of NumTileColumns) and the value of the horizontal coordinate (e.g. tileX) is smaller than or equal to the first threshold.</p><p id="p-0447" num="0512">Example 21. The method of example 19 or 20, wherein the obtaining a value of a horizontal coordinate according to the value of the address of the current slice comprises:</p><p id="p-0448" num="0000">obtaining the value of the horizontal coordinate according to the value of the address of the current slice and the quantity of tiles in the tile row of the current picture.</p><p id="p-0449" num="0513">Example 22. The method of example 21, wherein the value of the horizontal coordinate is obtained according to a modulus operation between the value of the address of the current slice and the quantity of tiles in the tile row of the current picture (e.g. SliceTopLeftTileldx[i])% NumTileColumns).</p><p id="p-0450" num="0514">Example 23. A method of coding implemented by an encoding device, the method comprising:</p><p id="p-0451" num="0000">obtaining a quantity of tiles in a tile row of the current picture (e.g. a value of NumTileColumns);<br/>obtaining a value of an address of a current slice (e.g. SliceTopLeftTileldx[i]), the current slice is comprised in the current picture;<br/>obtaining a value of a horizontal coordinate (in an example, a horizontal coordinate means a coordinate located in a horizontal coordinate axis) (e.g. tileX) according to the value of the address of the current slice (e.g. SliceTopLeftTileldx[i]);<br/>coding an indication value for a slice width (i.e. width of a slice) for the current picture (i.e. the indication value for the slice width is coded in the bitstream) to obtain a bitstream, when a difference value between the quantity of tiles in the tile row of the current picture (e.g. a value of NumTileColumns) and the value of the horizontal coordinate (e.g. tileX) is greater than a first threshold (e.g. the first threshold is an integer number, may be 0, 1,2 . . . and so on).</p><p id="p-0452" num="0515">Example 24. The method of example 23, wherein the method further comprises:</p><p id="p-0453" num="0000">obtaining a quantity of tiles in a tile column of the current picture (e.g. a value of NumTileRows);<br/>obtaining a value of a vertical coordinate (in an example, an vertical coordinate means a coordinate located in an vertical coordinate axis) (e.g. tileY) according to the value of the address of the current slice (e.g. SliceTopLeftTileldx[i]);<br/>coding an indication value for a slice height (i.e. height of a slice) for the current picture (i.e. the indication value for the slice height is coded in the bitstream) to obtain a bitstream, when a difference value between the quantity of tiles in the tile column of the current picture (e.g. a value of NumTileRows) and the value of the vertical coordinate (e.g. tileY) is greater than a second threshold (e.g. the second threshold is an integer number, may be 0, 1,2 . . . and so on).</p><p id="p-0454" num="0516">Example 25. A method of coding implemented by an encoding device, the method comprising:</p><p id="p-0455" num="0000">obtaining a quantity of tiles in a tile column of the current picture (e.g. a value of NumTileRows);<br/>obtaining a value of an address of a current slice (e.g. SliceTopLeftTileldx[i]), the current slice is comprised in the current picture;<br/>obtaining a value of a vertical coordinate (in an example, an vertical coordinate means a coordinate located in an vertical coordinate axis) (e.g. tileY) according to the value of the address of the current slice (e.g. SliceTopLeftTileldx[i]);<ul id="ul0039" list-style="none">    <li id="ul0039-0001" num="0000">    <ul id="ul0040" list-style="none">        <li id="ul0040-0001" num="0517">coding an indication value for a slice height (i.e. height of a slice) for the current picture (i.e. the indication value for the slice height is coded in the bitstream) to obtain a bitstream, when a difference value between the quantity of tiles in the tile column of the current picture (e.g. a value of NumTileRows) and the value of the vertical coordinate (e.g. tileY) is greater than a second threshold (e.g. the second threshold is an integer number, may be 0, 1,2 . . . and so on).</li>    </ul>    </li></ul></p><p id="p-0456" num="0518">Example 26. The method of example 25, wherein the method further comprises:</p><p id="p-0457" num="0000">obtaining a quantity of tiles in a tile row of the current picture (e.g. a value of NumTileColumns);<br/>obtaining a value of a horizontal coordinate (in an example, a horizontal coordinate means a coordinate located in a horizontal coordinate axis) (e.g. tileX) according to the value of the address of the current slice (e.g. SliceTopLeftTileldx[i]);<br/>coding an indication value for a slice width (i.e. width of a slice) for the current picture (i.e. the indication value for the slice width is coded in the bitstream) to obtain a bitstream, when a difference value between the quantity of tiles in the tile row of the current picture (e.g. a value of NumTileColumns) and the value of the horizontal coordinate (e.g. tileX) is greater than a first threshold (e.g. the first threshold is an integer number, may be 0, 1,2 . . . and so on).</p><p id="p-0458" num="0519">Example 27. A decoder (<b>30</b>) comprising processing circuitry for carrying out the method according to any one of examples 1 to 22.</p><p id="p-0459" num="0520">Example 28. An encoder comprising processing circuitry for carrying out the method according to any one of examples 23 to 26.</p><p id="p-0460" num="0521">Example 29. A computer program product comprising program code for performing the method according to any one of the preceding examples when executed on a computer or a processor.</p><p id="p-0461" num="0522">Example 30. A decoder, comprising:</p><p id="p-0462" num="0000">one or more processors; and<br/>a non-transitory computer-readable storage medium coupled to the processors and storing programming for execution by the processors, wherein the programming, when executed by the processors, configures the decoder to carry out the method according to any one of the preceding examples.</p><p id="p-0463" num="0523">Example 31. An encoder, comprising:</p><p id="p-0464" num="0000">one or more processors; and<br/>a non-transitory computer-readable storage medium coupled to the processors and storing programming for execution by the processors, wherein the programming, when executed by the processors, configures the decoder to carry out the method according to any one of the preceding examples.</p><p id="p-0465" num="0524">Example 32. A non-transitory computer-readable medium carrying a program code which, when executed by a computer device, causes the computer device to perform the method of any one of the preceding examples.</p><p id="p-0466" num="0525"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a block diagram showing a content supply system <b>3100</b> for realizing content distribution service. This content supply system <b>3100</b> includes capture device <b>3102</b>, terminal device <b>3106</b>, and optionally includes display <b>3126</b>. The capture device <b>3102</b> communicates with the terminal device <b>3106</b> over communication link <b>3104</b>. The communication link may include the communication channel <b>13</b> described above. The communication link <b>3104</b> includes but not limited to WIFI, Ethernet, Cable, wireless (3G/4G/5G), USB, or any kind of combination thereof, or the like.</p><p id="p-0467" num="0526">The capture device <b>3102</b> generates data, and may encode the data by the encoding method as shown in the above embodiments. Alternatively, the capture device <b>3102</b> may distribute the data to a streaming server (not shown in the Figures), and the server encodes the data and transmits the encoded data to the terminal device <b>3106</b>. The capture device <b>3102</b> includes but not limited to camera, smart phone or Pad, computer or laptop, video conference system, PDA, vehicle mounted device, or a combination of any of them, or the like. For example, the capture device <b>3102</b> may include the source device <b>12</b> as described above. When the data includes video, the video encoder <b>20</b> included in the capture device <b>3102</b> may actually perform video encoding processing. When the data includes audio (i.e., voice), an audio encoder included in the capture device <b>3102</b> may actually perform audio encoding processing. For some practical scenarios, the capture device <b>3102</b> distributes the encoded video and audio data by multiplexing them together. For other practical scenarios, for example in the video conference system, the encoded audio data and the encoded video data are not multiplexed. Capture device <b>3102</b> distributes the encoded audio data and the encoded video data to the terminal device <b>3106</b> separately.</p><p id="p-0468" num="0527">In the content supply system <b>3100</b>, the terminal device <b>310</b> receives and reproduces the encoded data. The terminal device <b>3106</b> could be a device with data receiving and recovering capability, such as smart phone or Pad <b>3108</b>, computer or laptop <b>3110</b>, network video recorder (NVR)/digital video recorder (DVR) <b>3112</b>, TV <b>3114</b>, set top box (STB) <b>3116</b>, video conference system <b>3118</b>, video surveillance system <b>3120</b>, personal digital assistant (PDA) <b>3122</b>, vehicle mounted device <b>3124</b>, or a combination of any of them, or the like capable of decoding the above-mentioned encoded data. For example, the terminal device <b>3106</b> may include the destination device <b>14</b> as described above. When the encoded data includes video, the video decoder <b>30</b> included in the terminal device is prioritized to perform video decoding. When the encoded data includes audio, an audio decoder included in the terminal device is prioritized to perform audio decoding processing.</p><p id="p-0469" num="0528">For a terminal device with its display, for example, smart phone or Pad <b>3108</b>, computer or laptop <b>3110</b>, network video recorder (NVR)/digital video recorder (DVR) <b>3112</b>, TV <b>3114</b>, personal digital assistant (PDA) <b>3122</b>, or vehicle mounted device <b>3124</b>, the terminal device can feed the decoded data to its display. For a terminal device equipped with no display, for example, STB <b>3116</b>, video conference system <b>3118</b>, or video surveillance system <b>3120</b>, an external display <b>3126</b> is contacted therein to receive and show the decoded data.</p><p id="p-0470" num="0529">When each device in this system performs encoding or decoding, the picture encoding device or the picture decoding device, as shown in the above-mentioned embodiments, can be used.</p><p id="p-0471" num="0530"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a diagram showing a structure of an example of the terminal device <b>3106</b>. After the terminal device <b>3106</b> receives stream from the capture device <b>3102</b>, the protocol proceeding unit <b>3202</b> analyzes the transmission protocol of the stream. The protocol includes but not limited to Real Time Streaming Protocol (RTSP), Hyper Text Transfer Protocol (HTTP), HTTP Live streaming protocol (HLS), MPEG-DASH, Real-time Transport protocol (RTP), Real Time Messaging Protocol (RTMP), or any kind of combination thereof, or the like.</p><p id="p-0472" num="0531">After the protocol proceeding unit <b>3202</b> processes the stream, stream file is generated. The file is outputted to a demultiplexing unit <b>3204</b>. The demultiplexing unit <b>3204</b> can separate the multiplexed data into the encoded audio data and the encoded video data. As described above, for some practical scenarios, for example in the video conference system, the encoded audio data and the encoded video data are not multiplexed. In this situation, the encoded data is transmitted to video decoder <b>3206</b> and audio decoder <b>3208</b> without through the demultiplexing unit <b>3204</b>.</p><p id="p-0473" num="0532">Via the demultiplexing processing, video elementary stream (ES), audio ES, and optionally subtitle are generated. The video decoder <b>3206</b>, which includes the video decoder <b>30</b> as explained in the above mentioned embodiments, decodes the video ES by the decoding method as shown in the above-mentioned embodiments to generate video frame, and feeds this data to the synchronous unit <b>3212</b>. The audio decoder <b>3208</b>, decodes the audio ES to generate audio frame, and feeds this data to the synchronous unit <b>3212</b>. Alternatively, the video frame may store in a buffer (not shown in <figref idref="DRAWINGS">FIG. <b>9</b></figref>) before feeding it to the synchronous unit <b>3212</b>. Similarly, the audio frame may store in a buffer (not shown in <figref idref="DRAWINGS">FIG. <b>9</b></figref>) before feeding it to the synchronous unit <b>3212</b>.</p><p id="p-0474" num="0533">The synchronous unit <b>3212</b> synchronizes the video frame and the audio frame, and supplies the video/audio to a video/audio display <b>3214</b>. For example, the synchronous unit <b>3212</b> synchronizes the presentation of the video and audio information. Information may code in the syntax using time stamps concerning the presentation of coded audio and visual data and time stamps concerning the delivery of the data stream itself</p><p id="p-0475" num="0534">If subtitle is included in the stream, the subtitle decoder <b>3210</b> decodes the subtitle, and synchronizes it with the video frame and the audio frame, and supplies the video/audio/subtitle to a video/audio/subtitle display <b>3216</b>.</p><p id="p-0476" num="0535">The present invention is not limited to the above-mentioned system, and either the picture encoding device or the picture decoding device in the above-mentioned embodiments can be incorporated into other system, for example, a car system.</p><p id="p-0477" num="0536">Mathematical Operators</p><p id="p-0478" num="0537">The mathematical operators used in this application are similar to those used in the C programming language. However, the results of integer division and arithmetic shift operations are defined more precisely, and additional operations are defined, such as exponentiation and real-valued division. Numbering and counting conventions generally begin from 0, e.g., &#x201c;the first&#x201d; is equivalent to the 0-th, &#x201c;the second&#x201d; is equivalent to the 1-th, etc.</p><p id="p-0479" num="0538">Arithmetic Operators</p><p id="p-0480" num="0539">The following arithmetic operators are defined as follows:<ul id="ul0041" list-style="none">    <li id="ul0041-0001" num="0000">    <ul id="ul0042" list-style="none">        <li id="ul0042-0001" num="0540">+ Addition</li>        <li id="ul0042-0002" num="0541">&#x2212; Subtraction (as a two-argument operator) or negation (as a unary prefix operator)</li>        <li id="ul0042-0003" num="0542">* Multiplication, including matrix multiplication</li>        <li id="ul0042-0004" num="0543">x<sup>y </sup>Exponentiation. Specifies x to the power of y. In other contexts, such notation is used for superscripting not intended for interpretation as exponentiation.</li>        <li id="ul0042-0005" num="0544">/ Integer division with truncation of the result toward zero. For example, 7/4 and &#x2212;7/&#x2212;4 are truncated to 1 and &#x2212;7/4 and 7/&#x2212;4 are truncated to &#x2212;1.</li>        <li id="ul0042-0006" num="0545">&#xf7; Used to denote division in mathematical equations where no truncation or rounding is intended.</li>    </ul>    </li></ul></p><p id="p-0481" num="0000"><maths id="MATH-US-00002" num="00002"><math overflow="scroll"> <mfrac>  <mi>x</mi>  <mi>y</mi> </mfrac></math></maths><ul id="ul0043" list-style="none">    <li id="ul0043-0001" num="0000">    <ul id="ul0044" list-style="none">        <li id="ul0044-0001" num="0546">Used to denote division in mathematical equations where no truncation or rounding is intended.</li>    </ul>    </li></ul></p><p id="p-0482" num="0000"><maths id="MATH-US-00003" num="00003"><math overflow="scroll"> <mrow>  <munderover>   <mo>&#x2211;</mo>   <mrow>    <mi>i</mi>    <mo>=</mo>    <mi>x</mi>   </mrow>   <mi>y</mi>  </munderover>  <mrow>   <mi>f</mi>   <mo>&#x2061;</mo>   <mo>(</mo>   <mi>i</mi>   <mo>)</mo>  </mrow> </mrow></math></maths><ul id="ul0045" list-style="none">    <li id="ul0045-0001" num="0000">    <ul id="ul0046" list-style="none">        <li id="ul0046-0001" num="0547">The summation of f(i) with i taking all integer values from x up to and including y.</li>        <li id="ul0046-0002" num="0548">x % y Modulus. Remainder of x divided by y, defined only for integers x and y with x&#x3e;=0 and y&#x3e;0.</li>    </ul>    </li></ul></p><p id="p-0483" num="0549">Logical Operators</p><p id="p-0484" num="0550">The following logical operators are defined as follows:<ul id="ul0047" list-style="none">    <li id="ul0047-0001" num="0000">    <ul id="ul0048" list-style="none">        <li id="ul0048-0001" num="0551">x &#x26;&#x26; y Boolean logical &#x201c;and&#x201d; of x and y</li>        <li id="ul0048-0002" num="0552">x&#x2225;y Boolean logical &#x201c;or&#x201d; of x and y</li>        <li id="ul0048-0003" num="0553">! Boolean logical &#x201c;not&#x201d;</li>        <li id="ul0048-0004" num="0554">x?y: z If x is TRUE or not equal to 0, evaluates to the value of y; otherwise, evaluates to the value of z.</li>    </ul>    </li></ul></p><p id="p-0485" num="0555">Relational Operators</p><p id="p-0486" num="0556">The following relational operators are defined as follows:<ul id="ul0049" list-style="none">    <li id="ul0049-0001" num="0000">    <ul id="ul0050" list-style="none">        <li id="ul0050-0001" num="0557">&#x3e; Greater than</li>        <li id="ul0050-0002" num="0558">&#x3e;= Greater than or equal to</li>        <li id="ul0050-0003" num="0559">&#x3c; Less than</li>        <li id="ul0050-0004" num="0560">&#x3c;= Less than or equal to</li>        <li id="ul0050-0005" num="0561">== Equal to</li>        <li id="ul0050-0006" num="0562">!= Not equal to</li>    </ul>    </li></ul></p><p id="p-0487" num="0563">When a relational operator is applied to a syntax element or variable that has been assigned the value &#x201c;na&#x201d; (not applicable), the value &#x201c;na&#x201d; is treated as a distinct value for the syntax element or variable. The value &#x201c;na&#x201d; is considered not to be equal to any other value.</p><p id="p-0488" num="0564">Bit-Wise Operators</p><p id="p-0489" num="0565">The following bit-wise operators are defined as follows:<ul id="ul0051" list-style="none">    <li id="ul0051-0001" num="0000">    <ul id="ul0052" list-style="none">        <li id="ul0052-0001" num="0566">&#x26; Bit-wise &#x201c;and&#x201d;. When operating on integer arguments, operates on a two's complement representation of the integer value. When operating on a binary argument that contains fewer bits than another argument, the shorter argument is extended by adding more significant bits equal to 0.</li>        <li id="ul0052-0002" num="0567">| Bit-wise &#x201c;or&#x201d;. When operating on integer arguments, operates on a two's complement representation of the integer value. When operating on a binary argument that contains fewer bits than another argument, the shorter argument is extended by adding more significant bits equal to 0.</li>        <li id="ul0052-0003" num="0568">{circumflex over (&#x2003;)} Bit-wise &#x201c;exclusive or&#x201d;. When operating on integer arguments, operates on a two's complement representation of the integer value. When operating on a binary argument that contains fewer bits than another argument, the shorter argument is extended by adding more significant bits equal to 0.</li>        <li id="ul0052-0004" num="0569">x&#x3e;&#x3e;y Arithmetic right shift of a two's complement integer representation of x by y binary digits. This function is defined only for non-negative integer values of y. Bits shifted into the most significant bits (MSBs) as a result of the right shift have a value equal to the MSB of x prior to the shift operation.</li>        <li id="ul0052-0005" num="0570">x&#x3c;&#x3c;y Arithmetic left shift of a two's complement integer representation of x by y binary digits. This function is defined only for non-negative integer values of y. Bits shifted into the least significant bits (LSBs) as a result of the left shift have a value equal to 0.</li>    </ul>    </li></ul></p><p id="p-0490" num="0571">Assignment Operators</p><p id="p-0491" num="0572">The following arithmetic operators are defined as follows:<ul id="ul0053" list-style="none">    <li id="ul0053-0001" num="0000">    <ul id="ul0054" list-style="none">        <li id="ul0054-0001" num="0573">= Assignment operator</li>        <li id="ul0054-0002" num="0574">++ Increment, i.e., x++ is equivalent to x=x+1; when used in an array index, evaluates to the value of the variable prior to the increment operation.</li>        <li id="ul0054-0003" num="0575">&#x2212;&#x2212; Decrement, i.e., x&#x2212;&#x2212; is equivalent to x=x&#x2212;1; when used in an array index, evaluates to the value of the variable prior to the decrement operation.</li>        <li id="ul0054-0004" num="0576">+= Increment by amount specified, i.e., x+=3 is equivalent to x=x+3, and x+=(&#x2212;3) is equivalent to x=x+(&#x2212;3).</li>        <li id="ul0054-0005" num="0577">&#x2212;= Decrement by amount specified, i.e., x&#x2212;=3 is equivalent to x=x&#x2212;3, and x&#x2212;=(&#x2212;3) is equivalent to x=&#x2212;(&#x2212;3).</li>    </ul>    </li></ul></p><p id="p-0492" num="0578">Range Notation</p><p id="p-0493" num="0579">The following notation is used to specify a range of values:<ul id="ul0055" list-style="none">    <li id="ul0055-0001" num="0000">    <ul id="ul0056" list-style="none">        <li id="ul0056-0001" num="0580">x=y..z x takes on integer values starting from y to z, inclusive, with x, y, and z being integer numbers and z being greater than y.</li>    </ul>    </li></ul></p><p id="p-0494" num="0581">Mathematical Functions</p><p id="p-0495" num="0582">The following mathematical functions are defined:</p><p id="p-0496" num="0000"><maths id="MATH-US-00004" num="00004"><math overflow="scroll"> <mrow>  <mrow>   <mi>Abs</mi>   <mo>&#x2061;</mo>   <mo>(</mo>   <mi>x</mi>   <mo>)</mo>  </mrow>  <mo>=</mo>  <mrow>   <mo>{</mo>   <mtable>    <mtr>     <mtd>      <mrow>       <mi>x</mi>       <mo>;</mo>       <mrow>        <mi>x</mi>        <mo>&#x3e;=</mo>        <mn>0</mn>       </mrow>      </mrow>     </mtd>    </mtr>    <mtr>     <mtd>      <mrow>       <mrow>        <mo>-</mo>        <mi>x</mi>       </mrow>       <mo>;</mo>       <mrow>        <mi>x</mi>        <mo>&#x3c;</mo>        <mn>0</mn>       </mrow>      </mrow>     </mtd>    </mtr>   </mtable>  </mrow> </mrow></math></maths><ul id="ul0057" list-style="none">    <li id="ul0057-0001" num="0000">    <ul id="ul0058" list-style="none">        <li id="ul0058-0001" num="0583">Asin(x) the trigonometric inverse sine function, operating on an argument x that is in the range of &#x2212;1.0 to 1.0, inclusive, with an output value in the range of &#x2212;&#x3c0;&#xf7;2 to &#x3c0;&#xf7;2, inclusive, in units of radians</li>        <li id="ul0058-0002" num="0584">Atan(x) the trigonometric inverse tangent function, operating on an argument x, with an output value in the range of &#x2212;&#x3c0;&#xf7;2 to &#x3c0;&#xf7;2, inclusive, in units of radians</li>    </ul>    </li></ul></p><p id="p-0497" num="0000"><maths id="MATH-US-00005" num="00005"><math overflow="scroll"> <mrow>  <mrow>   <mi>A</mi>   <mo>&#x2062;</mo>   <mi>tan</mi>   <mo>&#x2062;</mo>   <mn>2</mn>   <mo>&#x2062;</mo>   <mrow>    <mo>(</mo>    <mrow>     <mi>x</mi>     <mo>,</mo>     <mi>y</mi>    </mrow>    <mo>)</mo>   </mrow>  </mrow>  <mo>=</mo>  <mrow>   <mo>{</mo>   <mtable>    <mtr>     <mtd>      <mrow>       <mrow>        <mi>A</mi>        <mo>&#x2062;</mo>        <mrow>         <mi>tan</mi>         <mo>&#x2061;</mo>         <mo>(</mo>         <mfrac>          <mi>y</mi>          <mi>x</mi>         </mfrac>         <mo>)</mo>        </mrow>       </mrow>       <mo>;</mo>      </mrow>     </mtd>     <mtd>      <mrow>       <mi>x</mi>       <mo>&#x3e;</mo>       <mn>0</mn>      </mrow>     </mtd>    </mtr>    <mtr>     <mtd>      <mrow>       <mrow>        <mrow>         <mi>A</mi>         <mo>&#x2062;</mo>         <mrow>          <mi>tan</mi>          <mo>&#x2061;</mo>          <mo>(</mo>          <mfrac>           <mi>y</mi>           <mi>x</mi>          </mfrac>          <mo>)</mo>         </mrow>        </mrow>        <mo>+</mo>        <mi>&#x3c0;</mi>       </mrow>       <mo>;</mo>      </mrow>     </mtd>     <mtd>      <mrow>       <mrow>        <mi>x</mi>        <mo>&#x3c;</mo>        <mn>0</mn>       </mrow>       <mtext> </mtext>       <mo>&#x26;&#x26;</mo>       <mtext> </mtext>       <mrow>        <mi>y</mi>        <mo>&#x3e;=</mo>        <mn>0</mn>       </mrow>      </mrow>     </mtd>    </mtr>    <mtr>     <mtd>      <mrow>       <mrow>        <mrow>         <mi>A</mi>         <mo>&#x2062;</mo>         <mi>tan</mi>         <mo>&#x2062;</mo>         <mrow>          <mo>(</mo>          <mfrac>           <mi>y</mi>           <mi>x</mi>          </mfrac>          <mo>)</mo>         </mrow>        </mrow>        <mo>-</mo>        <mi>&#x3c0;</mi>       </mrow>       <mo>;</mo>      </mrow>     </mtd>     <mtd>      <mrow>       <mrow>        <mi>x</mi>        <mo>&#x3c;</mo>        <mn>0</mn>       </mrow>       <mtext> </mtext>       <mo>&#x26;&#x26;</mo>       <mtext> </mtext>       <mrow>        <mi>y</mi>        <mo>&#x3c;</mo>        <mn>0</mn>       </mrow>      </mrow>     </mtd>    </mtr>    <mtr>     <mtd>      <mrow>       <mrow>        <mo>+</mo>        <mfrac>         <mi>&#x3c0;</mi>         <mn>2</mn>        </mfrac>       </mrow>       <mo>;</mo>      </mrow>     </mtd>     <mtd>      <mrow>       <mrow>        <mi>x</mi>        <mo>==</mo>        <mn>0</mn>       </mrow>       <mtext>  </mtext>       <mo>&#x26;&#x26;</mo>       <mtext>  </mtext>       <mrow>        <mi>y</mi>        <mo>&#x3e;=</mo>        <mn>0</mn>       </mrow>      </mrow>     </mtd>    </mtr>    <mtr>     <mtd>      <mrow>       <mrow>        <mo>-</mo>        <mfrac>         <mi>&#x3c0;</mi>         <mn>2</mn>        </mfrac>       </mrow>       <mo>;</mo>      </mrow>     </mtd>     <mtd>      <mi>otherwise</mi>     </mtd>    </mtr>   </mtable>  </mrow> </mrow></math></maths><ul id="ul0059" list-style="none">    <li id="ul0059-0001" num="0000">    <ul id="ul0060" list-style="none">        <li id="ul0060-0001" num="0585">Ceil(x) the smallest integer greater than or equal to x.</li>    </ul>    </li></ul></p><p id="p-0498" num="0000"><maths id="MATH-US-00006" num="00006"><math overflow="scroll"> <mrow>  <mrow>   <mi>Clip</mi>   <mo>&#x2062;</mo>   <msub>    <mn>1</mn>    <mi>Y</mi>   </msub>   <mo>&#x2062;</mo>   <mrow>    <mo>(</mo>    <mi>x</mi>    <mo>)</mo>   </mrow>  </mrow>  <mo>=</mo>  <mrow>   <mi>Clip</mi>   <mo>&#x2062;</mo>   <mn>3</mn>   <mo>&#x2062;</mo>   <mrow>    <mo>(</mo>    <mrow>     <mn>0</mn>     <mo>,</mo>     <mrow>      <mo>(</mo>      <mrow>       <mn>1</mn>       <mo>&#x2062;</mo>       <mrow>        <mo>(</mo>        <mrow>         <mrow>          <mrow>           <mo>(</mo>           <mrow>            <mo>&#x3c;&#x3c;</mo>            <mtext> </mtext>            <msub>             <mi>BitDepth</mi>             <mi>Y</mi>            </msub>           </mrow>           <mo>)</mo>          </mrow>          <mo>-</mo>          <mn>1</mn>         </mrow>         <mo>,</mo>         <mi>x</mi>        </mrow>        <mo>)</mo>       </mrow>      </mrow>     </mrow>    </mrow>   </mrow>  </mrow> </mrow></math></maths><maths id="MATH-US-00006-2" num="00006.2"><math overflow="scroll"> <mrow>  <mrow>   <mi>Clip</mi>   <mo>&#x2062;</mo>   <msub>    <mn>1</mn>    <mi>C</mi>   </msub>   <mo>&#x2062;</mo>   <mrow>    <mo>(</mo>    <mi>x</mi>    <mo>)</mo>   </mrow>  </mrow>  <mo>=</mo>  <mrow>   <mi>Clip</mi>   <mo>&#x2062;</mo>   <mn>3</mn>   <mo>&#x2062;</mo>   <mrow>    <mo>(</mo>    <mrow>     <mn>0</mn>     <mo>,</mo>     <mrow>      <mo>(</mo>      <mrow>       <mn>1</mn>       <mo>&#x2062;</mo>       <mrow>        <mo>(</mo>        <mrow>         <mrow>          <mrow>           <mo>(</mo>           <mrow>            <mo>&#x3c;&#x3c;</mo>            <mtext> </mtext>            <msub>             <mi>BitDepth</mi>             <mi>C</mi>            </msub>           </mrow>           <mo>)</mo>          </mrow>          <mo>-</mo>          <mn>1</mn>         </mrow>         <mo>,</mo>         <mi>x</mi>        </mrow>        <mo>)</mo>       </mrow>      </mrow>     </mrow>    </mrow>   </mrow>  </mrow> </mrow></math></maths><maths id="MATH-US-00006-3" num="00006.3"><math overflow="scroll"> <mrow>  <mrow>   <mi>Clip</mi>   <mo>&#x2062;</mo>   <mn>3</mn>   <mo>&#x2062;</mo>   <mrow>    <mo>(</mo>    <mrow>     <mi>x</mi>     <mo>,</mo>     <mi>y</mi>     <mo>,</mo>     <mi>z</mi>    </mrow>    <mo>)</mo>   </mrow>  </mrow>  <mo>=</mo>  <mrow>   <mo>{</mo>   <mtable>    <mtr>     <mtd>      <mrow>       <mi>x</mi>       <mo>;</mo>      </mrow>     </mtd>     <mtd>      <mrow>       <mi>z</mi>       <mo>&#x3c;</mo>       <mi>x</mi>      </mrow>     </mtd>    </mtr>    <mtr>     <mtd>      <mrow>       <mi>y</mi>       <mo>;</mo>      </mrow>     </mtd>     <mtd>      <mrow>       <mi>z</mi>       <mo>&#x3e;</mo>       <mi>y</mi>      </mrow>     </mtd>    </mtr>    <mtr>     <mtd>      <mrow>       <mi>z</mi>       <mo>;</mo>      </mrow>     </mtd>     <mtd>      <mi>otherwise</mi>     </mtd>    </mtr>   </mtable>  </mrow> </mrow></math></maths><ul id="ul0061" list-style="none">    <li id="ul0061-0001" num="0000">    <ul id="ul0062" list-style="none">        <li id="ul0062-0001" num="0586">Cos(x) the trigonometric cosine function operating on an argument x in units of radians.</li>        <li id="ul0062-0002" num="0587">Floor(x) the largest integer less than or equal to x.</li>    </ul>    </li></ul></p><p id="p-0499" num="0000"><maths id="MATH-US-00007" num="00007"><math overflow="scroll"> <mrow>  <mrow>   <mi>GetCurrMsb</mi>   <mo>&#x2061;</mo>   <mo>(</mo>   <mrow>    <mi>a</mi>    <mo>,</mo>    <mi>b</mi>    <mo>,</mo>    <mi>c</mi>    <mo>,</mo>    <mi>d</mi>   </mrow>   <mo>)</mo>  </mrow>  <mo>=</mo>  <mrow>   <mo>{</mo>   <mtable>    <mtr>     <mtd>      <mrow>       <mrow>        <mi>c</mi>        <mo>+</mo>        <mi>d</mi>       </mrow>       <mo>;</mo>      </mrow>     </mtd>     <mtd>      <mrow>       <mrow>        <mi>b</mi>        <mo>-</mo>        <mi>a</mi>       </mrow>       <mo>&#x3e;=</mo>       <mrow>        <mi>d</mi>        <mo>/</mo>        <mn>2</mn>       </mrow>      </mrow>     </mtd>    </mtr>    <mtr>     <mtd>      <mrow>       <mrow>        <mi>c</mi>        <mo>-</mo>        <mi>d</mi>       </mrow>       <mo>;</mo>      </mrow>     </mtd>     <mtd>      <mrow>       <mrow>        <mi>a</mi>        <mo>-</mo>        <mi>b</mi>       </mrow>       <mo>&#x3e;</mo>       <mrow>        <mi>d</mi>        <mo>/</mo>        <mn>2</mn>       </mrow>      </mrow>     </mtd>    </mtr>    <mtr>     <mtd>      <mrow>       <mi>c</mi>       <mo>;</mo>      </mrow>     </mtd>     <mtd>      <mi>otherwise</mi>     </mtd>    </mtr>   </mtable>  </mrow> </mrow></math></maths><ul id="ul0063" list-style="none">    <li id="ul0063-0001" num="0000">    <ul id="ul0064" list-style="none">        <li id="ul0064-0001" num="0588">Ln(x) the natural logarithm of x (the base-e logarithm, where e is the natural logarithm base constant 2.718 281 828 . . . ).</li>        <li id="ul0064-0002" num="0589">Log2(x) the base-2 logarithm of x.</li>        <li id="ul0064-0003" num="0590">Log10(x) the base-10 logarithm of x.</li>    </ul>    </li></ul></p><p id="p-0500" num="0000"><maths id="MATH-US-00008" num="00008"><math overflow="scroll"> <mrow>  <mrow>   <mi>Min</mi>   <mo>&#x2061;</mo>   <mo>(</mo>   <mrow>    <mi>x</mi>    <mo>,</mo>    <mi>y</mi>   </mrow>   <mo>)</mo>  </mrow>  <mo>=</mo>  <mrow>   <mo>{</mo>   <mtable>    <mtr>     <mtd>      <mrow>       <mi>x</mi>       <mo>;</mo>       <mrow>        <mi>x</mi>        <mo>&#x3c;=</mo>        <mi>y</mi>       </mrow>      </mrow>     </mtd>    </mtr>    <mtr>     <mtd>      <mrow>       <mi>y</mi>       <mo>;</mo>       <mrow>        <mi>x</mi>        <mo>&#x3e;</mo>        <mi>y</mi>       </mrow>      </mrow>     </mtd>    </mtr>   </mtable>  </mrow> </mrow></math></maths><maths id="MATH-US-00008-2" num="00008.2"><math overflow="scroll"> <mrow>  <mrow>   <mi>Max</mi>   <mo>&#x2061;</mo>   <mo>(</mo>   <mrow>    <mi>x</mi>    <mo>,</mo>    <mi>y</mi>   </mrow>   <mo>)</mo>  </mrow>  <mo>=</mo>  <mrow>   <mo>{</mo>   <mtable>    <mtr>     <mtd>      <mrow>       <mi>x</mi>       <mo>;</mo>       <mrow>        <mi>x</mi>        <mo>&#x3e;=</mo>        <mi>y</mi>       </mrow>      </mrow>     </mtd>    </mtr>    <mtr>     <mtd>      <mrow>       <mi>y</mi>       <mo>;</mo>       <mrow>        <mi>x</mi>        <mo>&#x3c;</mo>        <mi>y</mi>       </mrow>      </mrow>     </mtd>    </mtr>   </mtable>  </mrow> </mrow></math></maths><maths id="MATH-US-00008-3" num="00008.3"><math overflow="scroll"> <mrow>  <mrow>   <mi>Round</mi>   <mo>(</mo>   <mi>x</mi>   <mo>)</mo>  </mrow>  <mo>=</mo>  <mrow>   <mrow>    <mi>Sign</mi>    <mo>(</mo>    <mi>x</mi>    <mo>)</mo>   </mrow>   <mo>*</mo>   <mrow>    <mi>Floor</mi>    <mo>(</mo>    <mrow>     <mrow>      <mi>Abs</mi>      <mo>&#x2061;</mo>      <mo>(</mo>      <mi>x</mi>      <mo>)</mo>     </mrow>     <mo>+</mo>     <mn>0.5</mn>    </mrow>    <mo>)</mo>   </mrow>  </mrow> </mrow></math></maths><maths id="MATH-US-00008-4" num="00008.4"><math overflow="scroll"> <mrow>  <mrow>   <mi>Sign</mi>   <mo>(</mo>   <mi>x</mi>   <mo>)</mo>  </mrow>  <mo>=</mo>  <mrow>   <mo>{</mo>   <mtable>    <mtr>     <mtd>      <mrow>       <mn>1</mn>       <mo>;</mo>       <mrow>        <mi>x</mi>        <mo>&#x3e;</mo>        <mn>0</mn>       </mrow>      </mrow>     </mtd>    </mtr>    <mtr>     <mtd>      <mrow>       <mn>0</mn>       <mo>;</mo>       <mrow>        <mi>x</mi>        <mo>==</mo>        <mn>0</mn>       </mrow>      </mrow>     </mtd>    </mtr>    <mtr>     <mtd>      <mrow>       <mrow>        <mo>-</mo>        <mn>1</mn>       </mrow>       <mo>;</mo>       <mrow>        <mi>x</mi>        <mo>&#x3c;</mo>        <mn>0</mn>       </mrow>      </mrow>     </mtd>    </mtr>   </mtable>  </mrow> </mrow></math></maths><ul id="ul0065" list-style="none">    <li id="ul0065-0001" num="0000">    <ul id="ul0066" list-style="none">        <li id="ul0066-0001" num="0591">Sin(x) the trigonometric sine function operating on an argument x in units of radians</li>        <li id="ul0066-0002" num="0592">Sqrt(x)=&#x221a;{square root over (x)}</li>        <li id="ul0066-0003" num="0593">Swap(x, y)=(y, x)</li>        <li id="ul0066-0004" num="0594">Tan(x) the trigonometric tangent function operating on an argument x in units of radians</li>    </ul>    </li></ul></p><p id="p-0501" num="0595">Order of Operation Precedence</p><p id="p-0502" num="0596">When an order of precedence in an expression is not indicated explicitly by use of parentheses, the following rules apply:<ul id="ul0067" list-style="none">    <li id="ul0067-0001" num="0000">    <ul id="ul0068" list-style="none">        <li id="ul0068-0001" num="0597">Operations of a higher precedence are evaluated before any operation of a lower precedence.</li>        <li id="ul0068-0002" num="0598">Operations of the same precedence are evaluated sequentially from left to right.</li>    </ul>    </li></ul></p><p id="p-0503" num="0599">The table below specifies the precedence of operations from highest to lowest; a higher position in the table indicates a higher precedence.</p><p id="p-0504" num="0600">For those operators that are also used in the C programming language, the order of precedence used in this Specification is the same as used in the C programming language.</p><p id="p-0505" num="0000"><tables id="TABLE-US-00013" num="00013"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Operation precedence from </entry></row><row><entry>highest (at top of table) to lowest (at bottom of table)</entry></row><row><entry>operations (with operands x, y, and z)</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>&#x201c;x++&#x201d;, &#x201c;x&#x2212; &#x2212;&#x201d;</entry></row><row><entry>&#x201c;!x&#x201d;, &#x201c;&#x2212;x&#x201d; (as a unary prefix operator)</entry></row><row><entry>x<sup>y</sup></entry></row><row><entry> </entry></row><row><entry><maths id="MATH-US-00009" num="00009"><math overflow="scroll"> <mrow>  <mrow>   <mo>&#x201c;</mo>   <mrow>    <mi>x</mi>    <mtext>  </mtext>    <mo>*</mo>    <mtext>  </mtext>    <mi>y</mi>   </mrow>   <mo>&#x201d;</mo>  </mrow>  <mo>,</mo>  <mrow>   <mo>&#x201c;</mo>   <mrow>    <mi>x</mi>    <mtext>  </mtext>    <mo>/</mo>    <mtext>  </mtext>    <mi>y</mi>   </mrow>   <mo>&#x201d;</mo>  </mrow>  <mo>,</mo>  <mrow>   <mo>&#x201c;</mo>   <mrow>    <mi>x</mi>    <mtext>  </mtext>    <mo>&#xf7;</mo>    <mtext>  </mtext>    <mi>y</mi>   </mrow>   <mo>&#x201d;</mo>  </mrow>  <mo>,</mo>  <mrow>   <mo>&#x201c;</mo>   <mfrac>    <mi>x</mi>    <mi>y</mi>   </mfrac>   <mo>&#x201d;</mo>  </mrow>  <mo>,</mo>  <mrow>   <mo>&#x201c;</mo>   <mrow>    <mi>x</mi>    <mo>&#x2062;</mo>    <mtext>   </mtext>    <mi>%</mi>    <mo>&#x2062;</mo>    <mtext>   </mtext>    <mi>y</mi>   </mrow>   <mo>&#x201d;</mo>  </mrow> </mrow></math></maths></entry></row><row><entry> </entry></row><row><entry><maths id="MATH-US-00010" num="00010"><math overflow="scroll"> <mrow>  <mrow>   <mo>&#x201c;</mo>   <mrow>    <mi>x</mi>    <mo>+</mo>    <mi>y</mi>   </mrow>   <mo>&#x201d;</mo>  </mrow>  <mo>,</mo>  <mrow>   <mrow>    <mo>&#x201c;</mo>    <mrow>     <mi>x</mi>     <mo>-</mo>     <mi>y</mi>    </mrow>    <mo>&#x201d;</mo>   </mrow>   <mo>&#x2062;</mo>   <mtext>   </mtext>   <mrow>    <mo>(</mo>    <mrow>     <mrow>      <mi>as</mi>      <mo>&#x2062;</mo>      <mtext>   </mtext>      <mi>a</mi>      <mo>&#x2062;</mo>      <mtext>   </mtext>      <mi>two</mi>     </mrow>     <mo>&#x2062;</mo>     <mi>&#x2010;</mi>     <mo>&#x2062;</mo>     <mrow>      <mi>argument</mi>      <mo>&#x2062;</mo>      <mtext>   </mtext>      <mi>operator</mi>     </mrow>    </mrow>    <mo>)</mo>   </mrow>  </mrow>  <mo>,</mo>  <mrow>   <mo>&#x201c;</mo>   <mrow>    <munderover>     <mo>&#x2211;</mo>     <mrow>      <mi>i</mi>      <mo>=</mo>      <mi>x</mi>     </mrow>     <mi>y</mi>    </munderover>    <mrow>     <mi>f</mi>     <mo>&#x2061;</mo>     <mo>(</mo>     <mi>i</mi>     <mo>)</mo>    </mrow>   </mrow>   <mo>&#x201d;</mo>  </mrow> </mrow></math></maths></entry></row><row><entry> </entry></row><row><entry>&#x201c;x &#x3c;&#x3c; y&#x201d;, &#x201c;x &#x3e;&#x3e; y&#x201d;</entry></row><row><entry>&#x201c;x &#x3c; y&#x201d;, &#x201c;x &#x3c;= y&#x201d;, &#x201c;x &#x3e; y&#x201d;, &#x201c;x &#x3e;= y&#x201d;</entry></row><row><entry>&#x201c;x = = y&#x201d;, &#x201c;x != y&#x201d;</entry></row><row><entry>&#x201c;x &#x26; y&#x201d;</entry></row><row><entry>&#x201c;x | y&#x201d;</entry></row><row><entry>&#x201c;x &#x26;&#x26; y&#x201d;</entry></row><row><entry>&#x201c;x | | y&#x201d;</entry></row><row><entry>&#x201c;x ? y : z&#x201d;</entry></row><row><entry>&#x201c;x . . . y&#x201d;</entry></row><row><entry>&#x201c;x = y&#x201d;, &#x201c;x += y&#x201d;, &#x201c;x &#x2212;= y&#x201d;</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0506" num="0601">Text Description of Logical Operations</p><p id="p-0507" num="0602">In the text, a statement of logical operations as would be described mathematically in the following form:</p><p id="p-0508" num="0000"><tables id="TABLE-US-00014" num="00014"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="28pt" align="left"/><colspec colname="1" colwidth="189pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>if( condition 0 )</entry></row><row><entry/><entry>&#x2003;statement 0</entry></row><row><entry/><entry>else if( condition 1 )</entry></row><row><entry/><entry>&#x2003;statement 1</entry></row><row><entry/><entry>...</entry></row><row><entry/><entry>else /* informative remark on remaining condition */</entry></row><row><entry/><entry>&#x2003;statement n</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>may be described in the following manner:<ul id="ul0069" list-style="none">    <li id="ul0069-0001" num="0000">    <ul id="ul0070" list-style="none">        <li id="ul0070-0001" num="0603">. . . as follows / . . . the following applies:</li>        <li id="ul0070-0002" num="0604">If condition 0, statement 0</li>        <li id="ul0070-0003" num="0605">Otherwise, if condition 1, statement 1</li>        <li id="ul0070-0004" num="0606">. . .</li>        <li id="ul0070-0005" num="0607">Otherwise (informative remark on remaining condition), statement n<br/>Each &#x201c;If . . . Otherwise, if . . . Otherwise, . . . &#x201d; statement in the text is introduced with &#x201c; . . . as follows&#x201d; or &#x201c; . . . the following applies&#x201d; immediately followed by &#x201c;If . . . &#x201d;. The last condition of the &#x201c;If . . . Otherwise, if . . . Otherwise, . . . &#x201d; is always an &#x201c;Otherwise, . . . &#x201d;. Interleaved &#x201c;If . . . Otherwise, if . . . Otherwise, . . . &#x201d; statements can be identified by matching &#x201c; . . . as follows&#x201d; or &#x201c; . . . the following applies&#x201d; with the ending &#x201c;Otherwise, . . . &#x201d;.</li>    </ul>    </li></ul></p><p id="p-0509" num="0608">In the text, a statement of logical operations as would be described mathematically in the following form:</p><p id="p-0510" num="0000"><tables id="TABLE-US-00015" num="00015"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="49pt" align="left"/><colspec colname="1" colwidth="168pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>if( condition 0a &#x26;&#x26; condition 0b )</entry></row><row><entry/><entry>&#x2003;statement 0</entry></row><row><entry/><entry>else if( condition 1a | | condition 1b )</entry></row><row><entry/><entry>&#x2003;statement 1</entry></row><row><entry/><entry>...</entry></row><row><entry/><entry>else</entry></row><row><entry/><entry>&#x2003;statement n</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>may be described in the following manner:<ul id="ul0071" list-style="none">    <li id="ul0071-0001" num="0000">    <ul id="ul0072" list-style="none">        <li id="ul0072-0001" num="0609">. . . as follows / . . . the following applies:        <ul id="ul0073" list-style="none">            <li id="ul0073-0001" num="0610">If all of the following conditions are true, statement 0:            <ul id="ul0074" list-style="none">                <li id="ul0074-0001" num="0611">condition 0a</li>                <li id="ul0074-0002" num="0612">condition 0b</li>            </ul>            </li>            <li id="ul0073-0002" num="0613">Otherwise, if one or more of the following conditions are true, statement 1:            <ul id="ul0075" list-style="none">                <li id="ul0075-0001" num="0614">condition 1a</li>                <li id="ul0075-0002" num="0615">condition 1b</li>            </ul>            </li>            <li id="ul0073-0003" num="0616">. . .</li>            <li id="ul0073-0004" num="0617">Otherwise, statement n</li>        </ul>        </li>    </ul>    </li></ul></p><p id="p-0511" num="0618">In the text, a statement of logical operations as would be described mathematically in the following form:<ul id="ul0076" list-style="none">    <li id="ul0076-0001" num="0000">    <ul id="ul0077" list-style="none">        <li id="ul0077-0001" num="0619">if(condition 0)        <ul id="ul0078" list-style="none">            <li id="ul0078-0001" num="0620">statement 0</li>        </ul>        </li>        <li id="ul0077-0002" num="0621">if(condition 1)        <ul id="ul0079" list-style="none">            <li id="ul0079-0001" num="0622">statement 1<br/>may be described in the following manner:</li>        </ul>        </li>        <li id="ul0077-0003" num="0623">When condition 0, statement 0</li>        <li id="ul0077-0004" num="0624">When condition 1, statement 1.</li>    </ul>    </li></ul></p><p id="p-0512" num="0625">Although embodiments of the invention have been primarily described based on video coding, it should be noted that embodiments of the coding system <b>10</b>, encoder <b>20</b> and decoder <b>30</b> (and correspondingly the system <b>10</b>) and the other embodiments described herein may also be configured for still picture processing or coding, i.e. the processing or coding of an individual picture independent of any preceding or consecutive picture as in video coding. In general only inter-prediction units <b>244</b> (encoder) and <b>344</b> (decoder) may not be available in case the picture processing coding is limited to a single picture <b>17</b>. All other functionalities (also referred to as tools or technologies) of the video encoder <b>20</b> and video decoder <b>30</b> may equally be used for still picture processing, e.g. residual calculation <b>204</b>/<b>304</b>, transform <b>206</b>, quantization <b>208</b>, inverse quantization <b>210</b>/<b>310</b>, (inverse) transform <b>212</b>/<b>312</b>, partitioning <b>262</b>/<b>362</b>, intra-prediction <b>254</b>/<b>354</b>, and/or loop filtering <b>220</b>, <b>320</b>, and entropy coding <b>270</b> and entropy decoding <b>304</b>.</p><p id="p-0513" num="0626">Embodiments, e.g. of the encoder <b>20</b> and the decoder <b>30</b>, and functions described herein, e.g. with reference to the encoder <b>20</b> and the decoder <b>30</b>, may be implemented in hardware, software, firmware, or any combination thereof. If implemented in software, the functions may be stored on a computer-readable medium or transmitted over communication media as one or more instructions or code and executed by a hardware-based processing unit. Computer-readable media may include computer-readable storage media, which corresponds to a tangible medium such as data storage media, or communication media including any medium that facilitates transfer of a computer program from one place to another, e.g., according to a communication protocol. In this manner, computer-readable media generally may correspond to (1) tangible computer-readable storage media which is non-transitory or (2) a communication medium such as a signal or carrier wave. Data storage media may be any available media that can be accessed by one or more computers or one or more processors to retrieve instructions, code and/or data structures for implementation of the techniques described in this disclosure. A computer program product may include a computer-readable medium.</p><p id="p-0514" num="0627">By way of example, and not limiting, such computer-readable storage media can comprise RAM, ROM, EEPROM, CD-ROM or other optical disk storage, magnetic disk storage, or other magnetic storage devices, flash memory, or any other medium that can be used to store desired program code in the form of instructions or data structures and that can be accessed by a computer. Also, any connection is properly termed a computer-readable medium. For example, if instructions are transmitted from a website, server, or other remote source using a coaxial cable, fiber optic cable, twisted pair, digital subscriber line (DSL), or wireless technologies such as infrared, radio, and microwave, then the coaxial cable, fiber optic cable, twisted pair, DSL, or wireless technologies such as infrared, radio, and microwave are included in the definition of medium. It should be understood, however, that computer-readable storage media and data storage media do not include connections, carrier waves, signals, or other transitory media, but are instead directed to non-transitory, tangible storage media. Disk and disc, as used herein, includes compact disc (CD), laser disc, optical disc, digital versatile disc (DVD), floppy disk and Blu-ray disc, where disks usually reproduce data magnetically, while discs reproduce data optically with lasers. Combinations of the above should also be included within the scope of computer-readable media.</p><p id="p-0515" num="0628">Instructions may be executed by one or more processors, such as one or more digital signal processors (DSPs), general purpose microprocessors, application specific integrated circuits (ASICs), field programmable logic arrays (FPGAs), or other equivalent integrated or discrete logic circuitry. Accordingly, the term &#x201c;processor,&#x201d; as used herein may refer to any of the foregoing structure or any other structure suitable for implementation of the techniques described herein. In addition, in some aspects, the functionality described herein may be provided within dedicated hardware and/or software modules configured for encoding and decoding, or incorporated in a combined codec. Also, the techniques could be fully implemented in one or more circuits or logic elements.</p><p id="p-0516" num="0629">The techniques of this disclosure may be implemented in a wide variety of devices or apparatuses, including a wireless handset, an integrated circuit (IC) or a set of ICs (e.g., a chip set). Various components, modules, or units are described in this disclosure to emphasize functional aspects of devices configured to perform the disclosed techniques, but do not necessarily require realization by different hardware units. Rather, as described above, various units may be combined in a codec hardware unit or provided by a collection of interoperative hardware units, including one or more processors as described above, in conjunction with suitable software and/or firmware.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-math idrefs="MATH-US-00001" nb-file="US20230007270A1-20230105-M00001.NB"><img id="EMI-M00001" he="8.81mm" wi="76.20mm" file="US20230007270A1-20230105-M00001.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00002" nb-file="US20230007270A1-20230105-M00002.NB"><img id="EMI-M00002" he="5.25mm" wi="76.20mm" file="US20230007270A1-20230105-M00002.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00003" nb-file="US20230007270A1-20230105-M00003.NB"><img id="EMI-M00003" he="7.79mm" wi="76.20mm" file="US20230007270A1-20230105-M00003.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00004" nb-file="US20230007270A1-20230105-M00004.NB"><img id="EMI-M00004" he="5.67mm" wi="76.20mm" file="US20230007270A1-20230105-M00004.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00005" nb-file="US20230007270A1-20230105-M00005.NB"><img id="EMI-M00005" he="27.52mm" wi="76.20mm" file="US20230007270A1-20230105-M00005.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00006 MATH-US-00006-2 MATH-US-00006-3" nb-file="US20230007270A1-20230105-M00006.NB"><img id="EMI-M00006" he="17.61mm" wi="76.20mm" file="US20230007270A1-20230105-M00006.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00007" nb-file="US20230007270A1-20230105-M00007.NB"><img id="EMI-M00007" he="8.81mm" wi="76.20mm" file="US20230007270A1-20230105-M00007.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00008 MATH-US-00008-2 MATH-US-00008-3 MATH-US-00008-4" nb-file="US20230007270A1-20230105-M00008.NB"><img id="EMI-M00008" he="27.18mm" wi="76.20mm" file="US20230007270A1-20230105-M00008.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-math idrefs="MATH-US-00009" nb-file="US20230007270A1-20230105-M00009.NB"><img id="EMI-M00009" he="5.25mm" wi="41.23mm" file="US20230007270A1-20230105-M00009.TIF" alt="embedded image " img-content="table" img-format="tif"/></us-math><us-math idrefs="MATH-US-00010" nb-file="US20230007270A1-20230105-M00010.NB"><img id="EMI-M00010" he="7.79mm" wi="57.49mm" file="US20230007270A1-20230105-M00010.TIF" alt="embedded image " img-content="table" img-format="tif"/></us-math><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A decoder, comprising:<claim-text>one or more processors; and</claim-text><claim-text>a non-transitory computer-readable storage medium coupled to the processors and storing programming for execution by the processors, wherein the programming, when executed by the processors, causes the decoder to perform operations, the operations comprising:</claim-text><claim-text>obtaining a bitstream for a current picture;</claim-text><claim-text>obtaining a quantity of tiles in a tile row of the current picture;</claim-text><claim-text>obtaining a value of an address of a slice of the current picture;</claim-text><claim-text>obtaining a value of tileX according to the value of the address of the slice, wherein the value of tileX indicates a horizontal address in tile index;</claim-text><claim-text>parsing an indication value for a slice width from the bitstream for the current picture, when a difference value between the quantity of tiles in the tile row of the current picture and the value of tileX is not equal to a first threshold.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The decoder of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the operations further comprise:<claim-text>setting the indication value for the slice width to a default value, when a difference value between the quantity of tiles in the tile row of the current picture and the value of tileX is equal to the first threshold.</claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The decoder of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the default value indicates that the width of the slice comprises 1 tile column.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The decoder of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the obtaining a value of tileX according to the value of the address of the slice comprises:<claim-text>obtaining the value of the tileX according to the value of the address of the slice and the quantity of tiles in the tile row of the current picture.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The decoder of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the value of tileX is obtained according to a modulus operation between the value of the address of the slice and the quantity of tiles in the tile row of the current picture.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The decoder of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the address of the slice is an index of leftmost tile of the topmost tile row of the slice, wherein the tiles comprised in the current picture are indexed according to a raster scan order.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The decoder <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the value of the address of the slice specify an address of a top-left coordinate of the slice in tile index.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The decoder of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the operations further comprise:<claim-text>obtaining a quantity of tiles in a tile column of the current picture;</claim-text><claim-text>obtaining a value of tileY according to the value of the address of the slice, wherein the value of tileY indicates a vertical address in tile index;</claim-text><claim-text>parsing an indication value for a slice height from the bitstream for the current picture, when a difference value between the quantity of tiles in the tile column of the current picture and the value of the tileY is not equal to a second threshold.</claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The decoder of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the operations further comprise:<claim-text>setting the indication value for the slice height to a preset value, when a difference value between the quantity of tiles in the tile column of the current picture and the value of tileY is equal to the second threshold.</claim-text></claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The decoder of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the obtaining a value of tileY according to the value of the address of the slice comprises:<claim-text>obtaining the value of tileY according to the value of the address of the slice and the quantity of tiles in the tile row of the current picture.</claim-text></claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The decoder of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the value of tileY is obtained according to an integer division operation between the value of the address of the slice and the quantity of tiles in the tile row of the current picture.</claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. An encoder, comprising:<claim-text>one or more processors; and</claim-text><claim-text>a non-transitory computer-readable storage medium coupled to the processors and storing programming for execution by the processors, wherein the programming, when executed by the processors, causes the decoder to perform operations, the operations comprising:</claim-text><claim-text>obtaining a quantity of tiles in a tile row of a current picture;</claim-text><claim-text>obtaining a value of an address of a slice of the current picture;</claim-text><claim-text>obtaining a value of tileX according to the value of the address of the slice, wherein the value of tileX indicates a horizontal address in tile index;</claim-text><claim-text>coding an indication value for a slice width for the current picture to obtain a bitstream, when a difference value between the quantity of tiles in the tile row of the current picture and the value of tileX is not equal to a first threshold.</claim-text></claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The encoder of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the operations further comprise:<claim-text>obtaining a quantity of tiles in a tile column of the current picture;</claim-text><claim-text>obtaining a value of tileY according to the value of the address of the slice, wherein the value of tileY indicates a vertical address in tile index; coding an indication value for a slice height for the current picture into the bitstream, when a difference value between the quantity of tiles in the tile column of the current picture and the value of the tileY is not equal to a second threshold.</claim-text></claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The encoder of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the obtaining a value of tileX according to the value of the address of the slice comprises:<claim-text>obtaining the value of the tileX according to the value of the address of the slice and the quantity of tiles in the tile row of the current picture.</claim-text></claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The encoder of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the value of tileX is obtained according to a modulus operation between the value of the address of the slice and the quantity of tiles in the tile row of the current picture.</claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The encoder of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the obtaining a value of tileY according to the value of the address of the slice comprises:<claim-text>obtaining the value of tileY according to the value of the address of the slice and the quantity of tiles in the tile row of the current picture.</claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The encoder of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the value of tileY is obtained according to an integer division operation between the value of the address of the slice and the quantity of tiles in the tile row of the current picture.</claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. A non-transitory computer-readable medium for storing bit string of a video, compring: a bit string stored in the non-transitory computer-readable medium, the bit string comprising an encoded sequence of frames of a video, wherein the sequence of frames is encoded into the bit string based on a plurality of operations comprising:<claim-text>obtaining a quantity of tiles in a tile row of a current picture;</claim-text><claim-text>obtaining a value of an address of a slice of the current picture;</claim-text><claim-text>obtaining a value of tileX according to the value of the address of the slice, wherein the value of tileX indicates a horizontal address in tile index;</claim-text><claim-text>coding an indication value for a slice width for the current picture to obtain the bit string, when a difference value between the quantity of tiles in the tile row of the current picture and the value of tileX is not equal to a first threshold.</claim-text></claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The medium of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein the obtaining a value of tileX according to the value of the address of the slice comprises:<claim-text>obtaining the value of the tileX according to the value of the address of the slice and the quantity of tiles in the tile row of the current picture.</claim-text></claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The medium of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein the bit string further comprises the indication value for a slice width for the current picture.</claim-text></claim></claims></us-patent-application>