<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004437A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004437</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17678523</doc-number><date>20220223</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><priority-claims><priority-claim sequence="01" kind="regional"><country>EP</country><doc-number>21386016.6</doc-number><date>20210225</date></priority-claim></priority-claims><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>50</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>48</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>T</subclass><main-group>1</main-group><subgroup>20</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>5038</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>485</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>4881</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>T</subclass><main-group>1</main-group><subgroup>20</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e61">Allocation of Resources to Tasks</invention-title><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="obligated-assignee"><addressbook><orgname>Imagination Technologies Limited</orgname><address><city>Kings Langley</city><country>GB</country></address></addressbook><residence><country>GB</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Velentzas</last-name><first-name>Panagiotis</first-name><address><city>Hertfordshire</city><country>GB</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Howson</last-name><first-name>John W.</first-name><address><city>Hertfordshire</city><country>GB</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>Broadhurst</last-name><first-name>Richard</first-name><address><city>Hertfordshire</city><country>GB</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A method of managing resources in a graphics processing pipeline includes conditionally suspending a task when the task reaches a phase boundary during execution of a program within a texture/shading unit. Suspending the task comprises freeing resources allocated to the task and resources are subsequently re-allocated to the task, such that the task is ready to continue execution, only after determining that the conditions associated with un-suspending the task are satisfied.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="225.72mm" wi="150.54mm" file="US20230004437A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="228.52mm" wi="152.57mm" file="US20230004437A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="189.40mm" wi="126.32mm" file="US20230004437A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="232.66mm" wi="155.02mm" file="US20230004437A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="168.83mm" wi="122.00mm" orientation="landscape" file="US20230004437A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="236.81mm" wi="154.77mm" file="US20230004437A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="186.86mm" wi="125.05mm" orientation="landscape" file="US20230004437A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="184.91mm" wi="156.63mm" file="US20230004437A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="226.65mm" wi="162.56mm" file="US20230004437A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="209.63mm" wi="155.53mm" file="US20230004437A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="191.69mm" wi="147.49mm" file="US20230004437A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="202.61mm" wi="150.62mm" file="US20230004437A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">BACKGROUND</heading><p id="p-0002" num="0001">There are a number of different ways of rendering 3D scenes, including tile-based rendering and immediate-mode rendering. In a graphics processing system that uses tile-based rendering, the rendering space is divided into one or more tiles (e.g. rectangular areas) and the rendering is then performed tile-by-tile. This typically increases the rendering speed as well as reducing the framebuffer memory bandwidth required, the amount of on-chip storage required for hidden surface removal (HSR) and the power consumed.</p><p id="p-0003" num="0002">Irrespective of whether tile-based or immediate-mode rendering is used, the rendering process involves the execution of many tasks in parallel. Execution of a task may involve operations, such as texture fetches, which are typically followed by long delays (e.g. due to the time taken to access memory) and this can reduce the efficiency and throughput of the graphics processing pipeline unless mitigating steps are taken.</p><p id="p-0004" num="0003">The embodiments described below are provided by way of example only and are not limiting of implementations which solve any or all of the disadvantages of known graphics processing systems.</p><heading id="h-0002" level="1">SUMMARY</heading><p id="p-0005" num="0004">This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.</p><p id="p-0006" num="0005">A method of managing resources in a graphics processing pipeline is described. The method comprises conditionally suspending a task when the task reaches a phase boundary during execution of a program within a texture/shading unit. Suspending the task comprises freeing resources allocated to the task and resources are subsequently re-allocated to the task, such that the task is ready to continue execution, only after determining that the conditions associated with un-suspending the task are satisfied.</p><p id="p-0007" num="0006">A first aspect provides a method of managing resources in a graphics processing pipeline, the method comprising: in response to a task reaching a phase boundary during execution of a program within a texture/shading unit, determining whether one or more pre-defined conditions are satisfied; in response to determining that de-scheduling conditions are satisfied, suspending the task, wherein suspending the task comprises freeing resources allocated to the task; determining whether conditions associated with un-suspending the task are satisfied; and after determining that the conditions associated with un-suspending the task are satisfied, allocating resources to the task such that the task is ready to continue execution of the program.</p><p id="p-0008" num="0007">A second aspect provides a method of sub-dividing a program into a plurality of phases, the method comprising: analysing instructions in the program to identify one or more instructions that, when executed, can introduce large latencies; and for an identified instruction, inserting a phase instruction into the program prior to or after the identified instruction.</p><p id="p-0009" num="0008">A third aspect provides a texture/shading unit for use in a graphics processing pipeline, the texture/shading unit comprising hardware logic arranged: in response to a task reaching a phase boundary during execution of a program, to determine whether one or more pre-defined conditions are satisfied; in response to determining that de-scheduling conditions are satisfied, to suspend the task, wherein suspending the task comprises freeing resources allocated to the task; to subsequently determine whether conditions associated with un-suspending the task are satisfied; and after determining that the conditions associated with un-suspending the task are satisfied, to allocate resources to the task such that the task is ready to continue execution of the program.</p><p id="p-0010" num="0009">A further aspect provides a graphics processing system configured to perform a method as described herein. The graphics processing system may be embodied in hardware on an integrated circuit.</p><p id="p-0011" num="0010">The texture/shading unit or graphics processing system comprising the texture/shading unit may be embodied in hardware on an integrated circuit. There may be provided a method of manufacturing, at an integrated circuit manufacturing system, a texture/shading unit or graphics processing system comprising the texture/shading unit. There may be provided an integrated circuit definition dataset that, when processed in an integrated circuit manufacturing system, configures the system to manufacture a texture/shading unit or graphics processing system comprising the texture/shading unit. There may be provided a non-transitory computer readable storage medium having stored thereon a computer readable description of an integrated circuit that, when processed, causes a layout processing system to generate a circuit layout description used in an integrated circuit manufacturing system to manufacture a texture/shading unit or graphics processing system comprising the texture/shading unit.</p><p id="p-0012" num="0011">There may be provided an integrated circuit manufacturing system comprising: a non-transitory computer readable storage medium having stored thereon a computer readable integrated circuit description that describes the texture/shading unit or graphics processing system comprising the texture/shading unit; a layout processing system configured to process the integrated circuit description so as to generate a circuit layout description of an integrated circuit embodying the texture/shading unit or graphics processing system comprising the texture/shading unit; and an integrated circuit generation system configured to manufacture the texture/shading unit or graphics processing system comprising the texture/shading unit according to the circuit layout description.</p><p id="p-0013" num="0012">There may be provided computer program code for performing any of the methods described herein. There may be provided non-transitory computer readable storage medium having stored thereon computer readable instructions that, when executed at a computer system, cause the computer system to perform any of the methods described herein.</p><p id="p-0014" num="0013">The above features may be combined as appropriate, as would be apparent to a skilled person, and may be combined with any of the aspects of the examples described herein.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0015" num="0014">Examples will now be described in detail with reference to the accompanying drawings in which:</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. <b>1</b></figref> shows a schematic diagram of an example graphics pipeline;</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>2</b></figref> shows an example program that has been divided into four phases through the identification of three phase boundaries;</p><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>3</b></figref> shows a first example method of managing resources within a GPU pipeline;</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>4</b></figref> shows a representation of the execution cycle of a task;</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>5</b></figref> shows another example method of managing resources within a GPU pipeline which is a variation of the method of <figref idref="DRAWINGS">FIG. <b>3</b></figref>;</p><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. <b>6</b></figref> shows a further example program that has been divided into four phases through the identification of three phase boundaries;</p><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. <b>7</b></figref> shows a second example method of managing resources within a GPU pipeline;</p><p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. <b>8</b></figref> shows a third example method of managing resources within a GPU pipeline;</p><p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a schematic diagram showing an example deadlock situation;</p><p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a flow diagram of an example method of dividing a program into a plurality of phases;</p><p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. <b>11</b></figref> shows a computer system in which the graphics pipeline of <figref idref="DRAWINGS">FIG. <b>1</b></figref> may be implemented; and</p><p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. <b>12</b></figref> shows an integrated circuit manufacturing system for generating an integrated circuit embodying a graphics pipeline as described herein.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><p id="p-0028" num="0027">The accompanying drawings illustrate various examples. The skilled person will appreciate that the illustrated element boundaries (e.g., boxes, groups of boxes, or other shapes) in the drawings represent one example of the boundaries. It may be that in some examples, one element may be designed as multiple elements or that multiple elements may be designed as one element. Common reference numerals are used throughout the figures, where appropriate, to indicate similar features.</p><heading id="h-0004" level="1">DETAILED DESCRIPTION</heading><p id="p-0029" num="0028">The following description is presented by way of example to enable a person skilled in the art to make and use the invention. The present invention is not limited to the embodiments described herein and various modifications to the disclosed embodiments will be apparent to those skilled in the art.</p><p id="p-0030" num="0029">Embodiments will now be described by way of example only.</p><p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. <b>1</b></figref> shows a schematic diagram of an example graphics processing unit (GPU) pipeline <b>100</b> which may be implemented in hardware within a GPU and which uses a tile-based rendering approach. As shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the pipeline <b>100</b> comprises a geometry processing unit <b>102</b>, a tiling unit <b>104</b>, a depth testing unit <b>106</b> (which may also be referred to as a hidden surface removal unit) and a texturing/shading unit (TSU) <b>108</b>. The pipeline <b>100</b> also comprises one or more memories and buffers, such as a first memory <b>110</b>, a second memory <b>112</b> (which may be referred to as parameter memory), a depth buffer <b>113</b> and one or more tag buffers <b>114</b>. Some of these memories and buffers may be implemented on-chip (e.g. on the same piece of silicon as some or all of the GPU <b>102</b>, tiling unit <b>104</b>, depth testing unit <b>106</b> and TSU <b>108</b>) and others may be implemented separately. It will be appreciated that the pipeline <b>100</b> may comprise other elements not shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0032" num="0031">The geometry processing unit <b>102</b> receives image geometrical data for an application and transforms it into domain space (e.g. UV coordinates) as well as performs tessellation, where required. The operations performed by the graphics processing unit <b>102</b>, aside from tessellation, comprise per-vertex transformations on vertex attributes (where position is just one of these attributes) performed by a vertex shader and these operations may also be referred to as &#x2018;transform and lighting&#x2019; (or &#x2018;transform and shading&#x2019;). The geometry processing unit <b>102</b> may, for example, comprise a tessellation unit and a vertex shader, and outputs data which is stored in memory <b>110</b>. This data that is output may comprise primitive data, where the primitive data may comprise a plurality of vertex indices (e.g. three vertex indices) for each primitive and a buffer of vertex data (e.g. for each vertex, a UV coordinate and in various examples, other vertex attributes). Where indexing is not used, the primitive data may comprise a plurality of domain vertices (e.g. three domain vertices) for each primitive, where a domain vertex may comprise only a UV coordinate or may comprise a UV coordinate plus other parameters (e.g. a displacement factor and optionally, parent UV coordinates).</p><p id="p-0033" num="0032">The tiling unit <b>104</b> reads the data generated by the geometry processing unit <b>102</b> (e.g. by a tessellation unit within the geometry processing unit <b>102</b>) from memory <b>110</b>, generates per-tile display lists and outputs these to the parameter memory <b>112</b>. Each per-tile display list identifies, for a particular tile, those primitives which are at least partially located within, or overlap with, that tile. These display lists may be generated by the tiling unit <b>104</b> using a tiling algorithm. Subsequent elements within the GPU pipeline, such as the depth testing unit <b>106</b>, can then read the data from parameter memory <b>112</b>. The back end of the tiling unit <b>104</b> may also group primitives into primitive blocks.</p><p id="p-0034" num="0033">The depth testing unit <b>106</b> accesses the per-tile display lists from the parameter memory <b>112</b> and performs depth tests on fragments of the primitives in the tile (where the term &#x2018;fragment&#x2019; is used herein to refer to an element of a primitive at a sample position). Current depth values (which may be referred to as &#x2018;depth state&#x2019;) may be stored in and accessed from the depth buffer <b>113</b>. If the depth test unit <b>106</b> determines that a fragment contributes to the image data, then one or more identifiers associated with the fragment, each referred to as a tag, are written to the tag buffer <b>114</b>. The one or more identifiers may comprise a tag that identifies the primitive and a tag that identifies the primitive block that the primitive is part of. If, however, the fragment is found not to contribute to the image data (e.g. because its depth indicates that the fragment is further away than, or is occluded by, an opaque fragment, which may be referred to as an occluder, that is already stored in the tag buffer), then the tag associated with the fragment is not written to the tag buffer <b>114</b>.</p><p id="p-0035" num="0034">The tag buffer <b>114</b> holds tags for the fragments from the front-most primitives (i.e. those closest to the viewpoint, which may also be referred to as &#x2018;near-most&#x2019;) for each sample position in a tile. To store a tag for a fragment in the tag buffer <b>114</b>, an identifier for the primitive of which the fragment is part is stored in a location that corresponds to the fragment and there is a 1:1 association between fragments and positions in the tag buffer. A fragment is therefore defined by the combination of the primitive identifier (or tag) and the position at which that identifier is stored in the tag buffer. The action of storing a fragment in the tag buffer therefore refers to the storing of the identifier for the primitive of which the fragment is part in a location in the tag buffer that corresponds to the sample position of the fragment.</p><p id="p-0036" num="0035">The texturing/shading unit (TSU) <b>108</b> performs texturing and/or shading tasks. The term &#x2018;task&#x2019; is used herein to refer to a group of one or more data-items (e.g. pixels or samples) and the work that is to be performed upon those data-items (where this &#x2018;work&#x2019; may be a program that is executed). For example, a task may comprise or be associated with a program or reference to a program (e.g. a shader) in addition to a set of data that is to be processed according to the program, where this set of data may comprise one or more data-items. The term &#x2018;instance&#x2019; (or &#x2018;program instance&#x2019;) is used herein to refer to individual instances that take a path through the code. An instance therefore refers to a single data-item (e.g. a single fragment or pixel, where in the context of the methods described herein, a fragment becomes a pixel when it has updated the output buffer, which may alternatively be known as the on-chip frame buffer or partition store) and a reference (e.g. pointer) to a program (e.g. a shader) which will be executed on the data-item. A task therefore comprises one or more instances and typically comprises a plurality of instances. In the context of the methods described herein, nearly all instances (e.g. except for the end of tile instance) correspond to a fragment.</p><p id="p-0037" num="0036">Tasks are generated when the tag buffer <b>114</b> is flushed through to the TSU <b>108</b>. There are a number of situations which trigger the flushing of the tag buffer <b>114</b>. When the tag buffer <b>114</b> is flushed, tasks are formed by scanning out (or gathering) data relating to fragments from the tag buffer <b>114</b> and placing them into tasks (with each fragment corresponding to a separate instance, as described above). The maximum number of instances (and hence fragments) within a task is limited by the width of SIMD structure in the graphics architecture. The efficiency of the TSU <b>108</b> (and hence the graphics pipeline <b>100</b>) is increased by filling tasks as full as possible; however, there are also a number of constraints that control how fragments are packed into tasks. In current systems, the group of tasks that are generated by a single tag buffer flush operation are collectively referred to as a pass and the TSU <b>108</b> implements mechanisms that ensure that all tasks from a pass finish updating the depth buffer (e.g. do a late depth-test or feedback to the depth test after alpha testing) before any of the tasks from the next pass. This ensures that pixels are processed in the correct order and avoids hazards, such as reads or writes being performed out of order. However, the efficiency of the pipeline is reduced where tasks in the pass are not fully occupied (i.e. they contain fewer than the maximum number of instances) and the impact of this increases as the width of the SIMD structure increases (e.g. there is a bigger impact for a 128-wide SIMD structure than a 32-wide SIMD structure). Typically, at least the last task in a pass will not be fully occupied (e.g. in a pipeline with a SIMD width of 128, the last task will typically contain less than 128 instances).</p><p id="p-0038" num="0037">As shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, there may be more than one tag buffer <b>114</b>. This enables two operations to be implemented in parallel: (i) scanning out data from a first tag buffer that has been flushed to form tasks and (ii) storing (or accumulating) tags into a second tag buffer. This parallel operation, which may be referred to as &#x2018;double-buffering&#x2019;, improves the efficiency of operation of the pipeline <b>100</b> as it is not necessary to wait for the flushing (i.e. operation (i)) to be complete before writing more tags into a tag buffer (i.e. operation (ii)).</p><p id="p-0039" num="0038">As also shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the TSU <b>108</b> may comprise a scheduler <b>116</b>, an instruction controller <b>118</b> and one or more execution pipelines <b>120</b>. It will be appreciated that the GPU pipeline <b>100</b> may comprise elements in addition to those shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref> and the TSU <b>108</b> may comprise elements in addition to (or instead of any of) the scheduler <b>116</b>, the instruction controller <b>118</b> and the execution pipelines <b>120</b>.</p><p id="p-0040" num="0039">As described above, execution of a task within the TSU <b>108</b> may involve operations, such as texture fetches or external memory fetches, which are typically followed by long delays (e.g. due to the memory latency which is not predictable and to the other operations involved in texture fetches, such as filtering/interpolation) and this can reduce the efficiency and throughput of the graphics processing pipeline <b>100</b> unless mitigating steps are taken. Techniques that may be used to hide the delay include de-scheduling the task to enable execution of other tasks (e.g. tasks from other threads), e.g. using a de-scheduling fence. A de-scheduled task still has resources allocated to it which enables it to be resumed quickly when the data returns. Whilst de-scheduling a task may enable another task to be executed (i.e. because another task can be in an ACTIVE state and there is a limit on the total number of tasks that can be in the ACTIVE state), a situation may be reached where there are no further tasks that are available to be selected for execution (e.g. there may be no tasks that are in a READY state). This is because prior to starting execution of a task, the resources required for execution of the task need to be allocated to that task. These resources may comprise some of all of: temporary registers, storage for task state, such as a task ID, predicates, the program counter (PC), reference counters, fence counters, SD masks/counters, etc. If a lot of resources are already allocated to both executing tasks and de-scheduled tasks, there may be insufficient available (i.e. unallocated) resources to allocate to another task.</p><p id="p-0041" num="0040">For the purposes of the following description, tasks which have been scheduled for execution within the TSU may be in one of a number of different states. A task in a READY state has the necessary resources allocated to it and sequential dependencies met and is able to be selected for execution. When a task in the READY state is selected for execution within the TSU it moves from the READY state to the ACTIVE state. If a task that is executing (and hence in the ACTIVE state) is subsequently de-scheduled (e.g. because it reaches an instruction that is followed by a long delay, such as a texture fetch), then it is no longer in the ACTIVE state but it cannot be placed into the READY state until the reason for the de-scheduling has been removed, e.g. if a task is de-scheduled following a texture fetch, it cannot become READY until the data returns in response to the texture fetch. As described above, a de-scheduled task still has the resources allocated to it, so that once the data returns, the task can be immediately placed back into the READY state without delay.</p><p id="p-0042" num="0041">Described herein are various methods of managing resources (within the GPU pipeline <b>100</b>) that are allocated to tasks and the methods may be implemented within the TSU <b>108</b> and/or by control hardware that is located outside the TSU <b>108</b> but affects the operation of the TSU <b>108</b>. For example, the methods described herein may be implemented by the scheduler <b>116</b> and instruction controller <b>118</b> within the TSU <b>108</b>. As described above, these resources may comprise some or all of: temporary registers, storage for predicates and the program counter (PC), etc. Each of the methods described herein may be used independently or in combination with one or more of the other methods described herein. By using one or more of the methods described herein, the amount of resource that is allocated to tasks that cannot currently be executed is reduced and hence the overall maximum number of tasks that are either available for selection for execution (i.e. are in the READY state) or being executed (i.e. are in the ACTIVE state) is increased (e.g. compared to known systems). This improves the efficiency of the TSU <b>108</b> (and hence of the GPU pipeline <b>100</b>) as it reduces the likelihood that resource limitations will cause a situation where the execution pipelines within the TSU <b>108</b> are under-utilised because there are too few tasks being available for execution or being executed. Put in another way, the use of the methods described herein reduce the likelihood that resource constraints will mean there are no tasks in the READY state when a TSU is being under-utilised.</p><p id="p-0043" num="0042">The methods of managing resources described herein involve the division of a program that is executed within the TSU <b>108</b> into a plurality of phases and this may be implemented by the addition of one or more special instructions (referred to herein as PHASE instructions). These special instructions, which define phase boundaries and hence segment the program into phases, may be added as part of static analysis of the program code, for example, when the program is compiled by a compiler. In addition, one or more of the phase boundaries may be skipped as the program is executed (thereby merging adjacent phases), based on analysis performed by the hardware (e.g. within the TSU <b>108</b>) as the program is executed. In other examples, the phase boundaries may be defined in any other way.</p><p id="p-0044" num="0043">Also described herein are methods of compiling programs executed within the TSU <b>108</b> to more efficiently manage resources within the GPU pipeline <b>100</b>. A compiler may implement one or more of these methods.</p><p id="p-0045" num="0044">Phase boundaries within a program (e.g. within a shader program) may be defined at points in the code that are followed by delays which are long or potentially long (e.g. longer than average actual or potential delays). These points may, for example, be after high-latency instructions (e.g. texel fetch operations) and/or where the program waits for sequential dependencies (SDs) to clear, e.g. before output buffer writes (OBW) and DISCARD instructions (which define fragments that are not drawn). DISCARD instructions may result in a long delay because before a DISCARD is executed, the sequential dependencies are checked to make sure that a previous pass (i.e. all tasks in the previous pass) has concluded writing to the depth buffer and this may be implemented using a mutex on the depth buffer. Similarly, before an instruction which writes to an output buffer (OBW), the sequential dependencies are checked to make sure that a previous pass (i.e. all tasks in the previous pass) has concluded writing to the output buffer.</p><p id="p-0046" num="0045"><figref idref="DRAWINGS">FIG. <b>2</b></figref> shows an example program <b>204</b> that has been divided into four phases through the identification of three phase boundaries. In the example program <b>204</b>, phase boundaries are positioned after a de-scheduling (DS) fence <b>216</b> (which follows a texture fetch instruction <b>215</b>), before a DISCARD instruction <b>218</b> and before a write to an output buffer (OBW) <b>224</b>.</p><p id="p-0047" num="0046">Whilst in the example of <figref idref="DRAWINGS">FIG. <b>2</b></figref>, the programs is divided into four phases, in other examples programs may be divided into more than four phases or fewer than four phases (e.g. where only a subset of the instructions shown in <figref idref="DRAWINGS">FIG. <b>2</b></figref> are present in the program code). In various examples, every pixel shader may be divided into at least two phases as a pixel shader will always comprise an instruction that writes to an output buffer (OBW), and in some examples the program will be divided into exactly two phases.</p><p id="p-0048" num="0047">Positions of phase boundaries within a program (e.g. within a shader program) may in addition, or instead, be defined based on other criteria, such as the number of live temporary registers (where a temporary register is considered to be live if data has been written to it but has not yet been read for the last time) and further examples are described below with reference to <figref idref="DRAWINGS">FIG. <b>6</b></figref>.</p><p id="p-0049" num="0048">As described above, the position of a phase boundary within a program may be identified by the addition of a special instruction, referred to herein as a PHASE instruction. In addition, or instead, the position of a phase boundary may be identified by adding a field in an existing instruction.</p><p id="p-0050" num="0049">A first example method of managing resources within a GPU pipeline can be described with reference to <figref idref="DRAWINGS">FIG. <b>3</b></figref>. As described above, execution of a task comprises executing a program (e.g. a shader) for a set of data items (e.g. pixels or samples) and when the task is being executed, it is referred to as being in an ACTIVE state. As shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, when the execution of a task reaches a phase boundary, it is determined whether de-scheduling conditions apply (block <b>301</b>) and if so, the task is suspended (block <b>302</b>). If, however, the de-scheduling conditions do not apply (No&#x2032; in block <b>301</b>), then the phase boundary is ignored and execution of the task continues. These de-scheduling conditions may be related to the reason for the placement of the particular phase boundary. As described above, a phase boundary may be placed at a point in the code where there is potential for a long delay. Consequently, if at the point the task reaches the phase boundary, the cause of the potential long delay does not exist (e.g. required data has already been returned), then the de-scheduling conditions do not apply and execution of the task can continue uninterrupted.</p><p id="p-0051" num="0050">When a task is in a suspended state, it not in the same state as a de-scheduled task because a de-scheduled task retains all the resources that were allocated to the task prior to its execution (and to enable its execution), whereas resources allocated to a task are freed (i.e. de-allocated) when the task is suspended (block <b>322</b>).</p><p id="p-0052" num="0051">The task remains in the suspended state until pre-defined conditions are satisfied (Yes' in block <b>304</b>). The particular conditions that need to be satisfied for a task will depend on the nature of the phase boundary, i.e. they will depend upon the instruction that resulted in the phase boundary. For example, where the phase boundary is placed following an instruction to fetch data (e.g. a texture fetch), then the conditions (in block <b>304</b>) will be satisfied when the data returns. Alternatively, where the phase boundary is placed where sequential dependencies or fences need to clear (e.g. before a DISCARD or OBW instruction), then the conditions (in block <b>304</b>) will be satisfied when the sequential dependencies or fence are cleared.</p><p id="p-0053" num="0052">As described above, as resources are freed when a task is suspended, there are more available (i.e. unallocated) resources for allocation to other tasks which are otherwise ready to be executed (e.g. all their sequential dependencies have been met) and this means that the freed resources can be used to place another task into the READY state. Once a task is in the READY state, it can be selected for execution (and hence enter the ACTIVE state).</p><p id="p-0054" num="0053">When a task is suspended, as well as freeing the allocated resources (block <b>322</b>), execution state for the task is stored (block <b>324</b>). This execution state comprises the state required to restart the task from the point after the phase boundary and this may include all the values that were stored in temporary registers that were live at the phase boundary or, in some implementations, all the values that were stored in any temporary registers allocated to the task if any of the allocated temporary registers are live at the phase boundary. A temporary register is considered to be live if data has been written to it but has not yet been read for the last time. The execution state that is stored (in block <b>324</b>) also comprises data that records the progress of the task prior to suspension (e.g. the task state, which may comprise the task ID, program counter, predicates, reference counters, fence counters, SD masks/counters, etc.).</p><p id="p-0055" num="0054">When the conditions are satisfied to restore a suspended task (Yes' in block <b>304</b>), the task cannot immediately commence execution, or be placed into the READY state, because (unlike a de-allocated task) it does not have any resources allocated to it. The task may be placed into a high-priority queue (block <b>306</b>) such that resources are allocated to the task in preference to another task that has not yet started execution. When the task is selected from the high-priority queue (Yes' in block <b>308</b>), resources are allocated to the task and the task state is restored (block <b>310</b>) using the information that was previously stored (in block <b>324</b>). The restoration of task state therefore comprises writing the stored values of temporary registers to newly allocated temporary registers. At this point the task is placed into the READY state and can be selected for execution when there is capacity within the execution pipelines (e.g. when the number of tasks in the ACTIVE state falls below a pre-defined limit).</p><p id="p-0056" num="0055">Where a task is suspended (in block <b>302</b>) as a consequence of a phase boundary that is immediately before a DISCARD or write to output buffer (OBW), once the task resumes execution, the DISCARD/OBW instruction can be executed immediately because the sequential dependency will have been met (as this has been checked before the task exited the suspended state, in block <b>304</b>).</p><p id="p-0057" num="0056">As described above, the methods described herein may be implemented by the scheduler <b>116</b> and instruction controller <b>118</b> within the TSU <b>108</b>. For example, in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, the instruction controller <b>118</b> may determine whether de-scheduling conditions apply (block <b>301</b>) and then suspend the task if required (blocks <b>302</b>, <b>322</b>, <b>324</b>) and the scheduler <b>116</b> may determine whether to un-suspend a task (block <b>304</b>) and the subsequent operations (blocks <b>306</b>, <b>308</b>, <b>310</b>).</p><p id="p-0058" num="0057">The method of <figref idref="DRAWINGS">FIG. <b>3</b></figref> can be described in the broader context of a task's execution with reference to the example execution cycle shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref>. New tasks that have been scheduled for execution, but have not yet been executed, are initially placed in a task queue <b>401</b>. When a task is selected from the task queue <b>401</b>, resources are allocated to the task (block <b>402</b>) and assuming that all dependencies are met, the task is then placed into the READY state. A task that is in the READY state is available for selection for execution and so, having been placed into the READY state, a task will subsequently be selected for execution (block <b>404</b>). At this point, the task is in the ACTIVE state and the instructions in the task are decoded and executed (block <b>406</b>).</p><p id="p-0059" num="0058">If a phase boundary is reached, the task is suspended (block <b>408</b>) until the data that has been requested prior to the phase boundary is returned or the sequential dependency that is outstanding at the phase boundary is met. At this point, the task is added to a high-priority queue <b>411</b> (block <b>410</b>) and is available for selection for allocation of resources once again (in block <b>402</b>). Unlike a new task, when resources are allocated to a task selected from the high-priority queue <b>411</b> (in block <b>402</b>), the task state is also restored based on stored task execution state, and then the cycle continues as described above until the task completes. As described above, tasks are preferentially selected from the high priority queue <b>411</b> for resource allocation (in block <b>402</b>), rather than selecting tasks from the input task queue <b>401</b>.</p><p id="p-0060" num="0059"><figref idref="DRAWINGS">FIG. <b>4</b></figref> also shows how the suspending of a task differs from the de-scheduling of a task and in various example implementations, there may be both suspended tasks and de-scheduled tasks (as described below). As shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref>, if a task is de-scheduled (block <b>412</b>), it does not need to return to the allocation stage (of block <b>402</b>) once the reason for the de-scheduling has been resolved, but instead a de-scheduled task can return immediately to the READY state as its resources remain allocated to it (as indicated by the dotted arrow that leaves block <b>412</b>).</p><p id="p-0061" num="0060">As shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref>, a de-scheduled task can return to the READY state, and hence continue execution, more quickly than a suspended task; however, a de-scheduled task uses resources (which may be scarce) even whilst de-scheduled which may prevent other tasks (e.g. other tasks from the task queue <b>401</b>) being allocated resources and hence prevent them from becoming READY and then ACTIVE. One or more techniques may be used, however, to reduce the time taken for a suspended task to return to the READY state once the reason for the suspension has been resolved. For example, by placing a task that has emerged from being suspended into a high-priority queue <b>411</b> (in block <b>410</b>), the time taken to restart execution of the task may be reduced (compared to not providing any priority to the allocation of resources in block <b>402</b>) and the time taken can be further reduced by prioritising the selection of a previously suspended task for execution over a new task (in block <b>404</b>). This prioritisation may, for example, be implemented by adding the previously suspended task to the front of a queue of READY tasks (which gives the task the highest possible priority) or by adding the previously suspended task into the queue of READY tasks according to the age of the task (where the age corresponds to the time since the task was first made READY). The task at the front of the queue of READY tasks may be the first to be selected for execution (in block <b>404</b>) and therefore the degree of prioritisation can be adjusted by use of different rules to determine the position at which the previously suspended task is added to the queue of READY tasks. In other examples, there may be two queues of READY tasks&#x2014;one for new tasks that have not previously executed and the other for tasks that were previously suspended (in a similar manner to the two task queues <b>401</b>, <b>411</b>) and tasks may be preferentially selected for execution from the queue of READY tasks that were previously suspended.</p><p id="p-0062" num="0061">In some implementations, tasks may only be suspended and no tasks are de-scheduled; however, in other implementations, some tasks may be de-scheduled (e.g. on reaching a de-scheduling fence) and others may be suspended (e.g. on reaching a phase boundary). The suspension or de-scheduling of a task may be pre-defined based on static analysis of the code at compile time. In addition, a GPU pipeline may also switch dynamically between a mode where tasks are only de-scheduled (e.g. where execution resources are limited but storage resources are not) and a mode where tasks are only suspended (e.g. where storage resources are limited but execution resources are not or where the texel fetch pipeline is overwhelmed which will increase the time taken for texel data to return). In some implementations, limits may be set such that there is a maximum number of tasks that can be de-scheduled (e.g. when they reach a de-scheduling fence) and once that limit has been reached, subsequent tasks that reach a phase boundary are instead suspended. In such an implementation, the maximum number of tasks that can be de-scheduled at any time may be pre-defined (and fixed) or may be set dynamically (e.g. at run time).</p><p id="p-0063" num="0062">In <figref idref="DRAWINGS">FIG. <b>4</b></figref>, for example, the instruction controller <b>118</b> (within the TSU <b>108</b>) may perform the decoding of tasks (in block <b>406</b>) and the de-scheduling and suspending of tasks (in blocks <b>408</b> and <b>412</b>). The two queues <b>401</b>, <b>411</b> may be located within the scheduler <b>116</b> which may add tasks to the high priority queue <b>411</b> (in block <b>410</b>), allocate resources to tasks (in block <b>402</b>) and select tasks for execution (in block <b>404</b>).</p><p id="p-0064" num="0063"><figref idref="DRAWINGS">FIG. <b>5</b></figref> shows a variation on the flow diagram of <figref idref="DRAWINGS">FIG. <b>3</b></figref> in which the suspending of tasks is conditional. As shown in <figref idref="DRAWINGS">FIG. <b>5</b></figref>, when a task reaches a phase boundary it is determined whether conditions are met to suspend, rather than de-schedule, the task (block <b>502</b>). These conditions may, for example, be based on the current status of the execution pipelines in the TSU <b>108</b> (e.g. the current utilisation of the execution pipelines). If the conditions are satisfied (Yes' in block <b>502</b>), then the task is suspended (block <b>302</b>) and the method continues as described above with reference to <figref idref="DRAWINGS">FIG. <b>3</b></figref>. If, however, the conditions are not satisfied (No&#x2032; in block <b>502</b>), then the task is de-scheduled (block <b>504</b>). This means that as soon as conditions are satisfied to re-schedule the task (Yes' in block <b>506</b>), e.g. data returns or a sequential dependency is met, the task is immediately ready to be selected for execution. The conditions for re-scheduling a task (as assessed in block <b>506</b>) may be the same as the conditions for removing a task from the suspended state (as assessed in block <b>304</b>).</p><p id="p-0065" num="0064">In <figref idref="DRAWINGS">FIG. <b>5</b></figref>, for example, the instruction controller <b>118</b> (in the TSU <b>108</b>) may determine whether de-scheduling conditions apply (in block <b>301</b>), whether suspension conditions are met (in block <b>502</b>) and then suspend or de-schedule the task if required (in blocks <b>302</b>, <b>504</b>). The scheduler <b>116</b> may determine whether to un-suspend a task (block <b>304</b>) and the subsequent operations (blocks <b>306</b>, <b>308</b>, <b>310</b>) and also whether conditions are satisfied to re-schedule a task (in block <b>506</b>).</p><p id="p-0066" num="0065">Whilst the above description refers to the suspending of tasks, the tasks may alternatively be described as hibernated or phased out.</p><p id="p-0067" num="0066">By using the methods of <figref idref="DRAWINGS">FIGS. <b>3</b>-<b>5</b></figref>, the execution of a task can be stopped and then restarted without holding onto the resources allocated to the task in the intervening period. This enables an increase in the utilisation of the execution pipelines within the TSU <b>108</b> without requiring significant additional infrastructure (e.g. additional storage, additional scheduling resource, etc.) and hence without introducing a substantial silicon area overhead. Alternatively, these methods may be used to provide the same level of performance but in a smaller area of silicon (e.g. as a consequence of providing less storage, less scheduling resource, etc.).</p><p id="p-0068" num="0067">As described above (with reference to <figref idref="DRAWINGS">FIG. <b>2</b></figref>), phase boundaries within a program (e.g. within a shader program) may be defined at points in the code that are followed by delays which are long or potentially long (e.g. longer than average actual or potential delays). In addition, or instead, phase boundaries may be positioned based on other criteria, such as the use of registers within the code. For example, the positions of phase boundaries may be based on the number of live temporary registers, where a temporary register is considered to be live if data has been written to it but has not yet been read for the last time. In various examples, phase boundaries may be defined at points in the code to reduce (or minimise) a number of temporary registers that are live at any phase boundary.</p><p id="p-0069" num="0068"><figref idref="DRAWINGS">FIG. <b>6</b></figref> shows an example program <b>602</b> that has been divided into four phases through the identification of three phase boundaries <b>604</b>-<b>608</b>. <figref idref="DRAWINGS">FIG. <b>6</b></figref> also shows which registers are live at each point in the code and after the execution of the read/write (column <b>610</b>) and arrows <b>612</b> show the scope of each register (i.e. the periods when it is live). Consequently if you suspend the program after instruction/row X, then the temporary registers that need to be stored are those in the register liveness column <b>610</b> from the row below (i.e. row X+1). In the example shown in <figref idref="DRAWINGS">FIG. <b>6</b></figref>, there are 6 temporary registers that are live at the first phase boundary <b>604</b> (r0, r2, r4, r5, r6, r7), 4 temporary registers that are live at the second phase boundary <b>606</b> (r0, r2, r6, r8) and 2 temporary registers that are live at the third phase boundary <b>608</b> (r6, r12) and there are a total of 8 temporary registers that are live at any of the phase boundaries in the program (r0, r2, r4, r5, r6, r7, r8, r12). These phase boundaries <b>604</b>, <b>606</b>, <b>608</b> may, for example, be placed based on the position of instructions with a potential to be followed by a long delay, e.g. DISCARD, OBW and DS fences (where these instructions are not shown in <figref idref="DRAWINGS">FIG. <b>6</b></figref>).</p><p id="p-0070" num="0069">In various examples, the position of phase boundaries in a task may be moved in order to reduce the number of temporary registers that are live at any phase boundary. In an example of this, the example described above with reference to <figref idref="DRAWINGS">FIG. <b>6</b></figref> can be modified. If the first phase boundary <b>604</b> is moved three positions (e.g. three instructions) earlier in the code (to the position marked with the dotted arrow <b>604</b>&#x2032;), then the number of temporary registers that are live at that phase boundary is reduced to 3 (r0, r2, r4), if the second phase boundary <b>606</b> is moved two positions earlier in the code (to the position marked with the dotted arrow <b>606</b>&#x2032;), then the number of temporary registers that are live at that phase boundary is reduced to 2 (r2, r6) and if the third phase boundary <b>608</b> is moved two positions later in the code (to the position marked with the dotted arrow <b>608</b>&#x2032;), then the number of temporary registers that are live at that phase boundary is reduced to zero, bringing the overall total number of temporary registers that are live at any of the phase boundaries in the program down to four (r0, r2, r4, r6).</p><p id="p-0071" num="0070">As described above, the position of a phase boundary within a program may be identified by the addition of a special instruction, referred to herein as a PHASE instruction, and this may be added by a compiler when the program is compiled.</p><p id="p-0072" num="0071">A second example method of managing resources within a GPU pipeline can be described with reference to <figref idref="DRAWINGS">FIG. <b>7</b></figref>, where in this example the resources are temporary registers. In this method, the temporary registers allocated to a task at any point in time (during the execution of the task) are dependent upon the position of any phase boundaries in the task and the number of temporary registers allocated to a task at any point in time is lower than if this method is not used. In particular, the temporary registers allocated to a task are divided into two parts: a static allocation which relates to the entire task and a dynamic allocation which relates to the particular phase of the task that is being executed. The static allocation comprises those temporary registers which are live at any phase boundary in the program and the dynamic allocation for a phase comprises those temporary registers which are live within the particular phase being executed (but are not live at the phase boundary). Each of the temporary registers used by a task are therefore categorised as being static or dynamic and where they are dynamic they fall within the dynamic allocation and where they are static they fall within the static allocation.</p><p id="p-0073" num="0072">As shown in <figref idref="DRAWINGS">FIG. <b>7</b></figref>, when a task is selected from the task queue and resources are allocated to the task (so that it can become READY), the task is allocated its static allocation of temporary registers and the dynamic allocation of temporary registers for the first phase (phase 1) only (block <b>702</b>). When the task subsequently reaches the first phase boundary, the dynamic allocation for the first phase is freed (i.e. de-allocated) and the dynamic allocation for the next phase (phase 2) is subsequently allocated (block <b>704</b>). This may involve moving the task back to the task queue (block <b>744</b>) between the de-allocation (block <b>742</b>) and new allocation (block <b>746</b>), e.g. if the allocation of temporary registers can only occur for tasks selected from a task queue. The task queue that the task is added to, following the de-allocation of the temporary registers from the first phase, may be the standard task queue (e.g. task queue <b>401</b> in <figref idref="DRAWINGS">FIG. <b>4</b></figref>) or may be a high priority task queue (e.g. to minimise the delay between the de-allocation of temporary registers from one phase and the allocation of temporary registers for the next phase). If there is more than one phase boundary in the task, when the task reaches the next phase boundary, the method repeats, with the dynamic allocation for the phase that has just ended being freed (i.e. de-allocated) and the dynamic allocation for the next phase being subsequently allocated (block <b>704</b>). Once the task reaches the end of the program, all of the allocated temporary registers (i.e. both the static and dynamic allocations) are freed (block <b>706</b>).</p><p id="p-0074" num="0073">As described above, the method of <figref idref="DRAWINGS">FIG. <b>7</b></figref> may be implemented within the TSU <b>108</b>. For example, the scheduler <b>116</b> (in the TSU <b>108</b>) may allocate resources (in blocks <b>702</b>, <b>704</b>, <b>746</b>) as well as adding tasks to the task queue (in block <b>744</b>). The freeing of allocations (in blocks <b>704</b>, <b>706</b>, <b>742</b>) may be performed by the scheduler <b>116</b> and/or by other hardware within the TSU <b>108</b>. For example, allocations may be freed by various hardware elements working together, e.g. the scheduler <b>116</b> along with additional hardware logic within the TSU <b>108</b> (e.g. a conditional execution unit pipeline) and hardware logic external to the TSU but within the GPU pipeline <b>100</b> (e.g. a hardware logic unit which is located between the tag buffer <b>114</b> and the TSU <b>108</b>).</p><p id="p-0075" num="0074">A contiguous block of temporary registers is allocated for the static allocation and a second contiguous block of temporary registers is allocated for the dynamic allocation for the first phase (in block <b>702</b>). Similarly, a contiguous block of temporary registers is subsequently allocated for the dynamic allocation for the next phase (in block <b>704</b>).</p><p id="p-0076" num="0075">The allocation of the static and dynamic allocations to a task initially (in block <b>702</b>) to allow the task to enter the READY state (and hence be able to be selected for execution) is atomic, i.e. the task is either allocated both the static allocation and dynamic allocation for the first phase or is not allocated any temporary registers (and hence does not enter the READY state). The allocation is atomic so that resources are used efficiently, e.g. such that a task that cannot be executed because its dynamic allocation cannot be allocated does not prevent another task (which can execute) as a consequence of allocation of its static allocation. Consequently, the allocation (in block <b>702</b>) can only occur when there are sufficient free resources to allocate both the static allocation for the task and the dynamic allocation for the first phase. The total number of temporary registers that are allocated to the task at the start of the method (in block <b>702</b>) is no greater than the total number of temporary registers required for execution of the entire task and in most cases will be smaller than this total number (e.g. because not all temporary registers will be live in the first phase).</p><p id="p-0077" num="0076">Referring back to the example of <figref idref="DRAWINGS">FIG. <b>6</b></figref> with the phase boundaries at positions <b>604</b>, <b>606</b> and <b>608</b> shown by the solid arrows, if all the temporary registers are allocated at the start (as in known systems) then the task is allocated 14 temporary registers (r0-r13); however, if the method of <figref idref="DRAWINGS">FIG. <b>7</b></figref> is used, the maximum number of temporary registers allocated to the task at any time is 11 as shown below:</p><p id="p-0078" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="21pt" align="center"/><colspec colname="2" colwidth="84pt" align="center"/><colspec colname="3" colwidth="35pt" align="center"/><colspec colname="4" colwidth="63pt" align="center"/><thead><row><entry/><entry namest="offset" nameend="4" align="center" rowsep="1"/></row><row><entry/><entry/><entry>Static</entry><entry>Dynamic</entry><entry>Total</entry></row><row><entry/><entry>Phase</entry><entry>allocation</entry><entry>allocation</entry><entry>allocation</entry></row><row><entry/><entry namest="offset" nameend="4" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="21pt" align="center"/><colspec colname="2" colwidth="84pt" align="center"/><colspec colname="3" colwidth="35pt" align="center"/><colspec colname="4" colwidth="63pt" align="char" char="."/><tbody valign="top"><row><entry/><entry>1</entry><entry>8 (r0, r2, r4,</entry><entry>2 (r1, r3)</entry><entry>10</entry></row><row><entry/><entry>2</entry><entry>r5, r6, r7, r8, r12)</entry><entry>0</entry><entry>8</entry></row><row><entry/><entry>3</entry><entry/><entry>3 (r9, r10,</entry><entry>11</entry></row><row><entry/><entry/><entry/><entry>r11)</entry></row><row><entry/><entry>4</entry><entry/><entry>1 (r13)</entry><entry>9</entry></row><row><entry/><entry namest="offset" nameend="4" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0079" num="0077">Referring back to the example of <figref idref="DRAWINGS">FIG. <b>6</b></figref> with the phase boundaries at positions <b>604</b>&#x2032;, <b>606</b>&#x2032; and <b>608</b>&#x2032; shown by the dotted arrows, if all the temporary registers are allocated at the start (as in known systems) then the task is allocated 14 temporary registers (r0-r13); however, if the method of <figref idref="DRAWINGS">FIG. <b>7</b></figref> is used, the maximum number of temporary registers allocated to the task at any time is 10 as shown below:</p><p id="p-0080" num="0000"><tables id="TABLE-US-00002" num="00002"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="21pt" align="center"/><colspec colname="2" colwidth="77pt" align="center"/><colspec colname="3" colwidth="56pt" align="center"/><colspec colname="4" colwidth="49pt" align="center"/><thead><row><entry/><entry namest="offset" nameend="4" align="center" rowsep="1"/></row><row><entry/><entry/><entry>Static</entry><entry>Dynamic</entry><entry>Total</entry></row><row><entry/><entry>Phase</entry><entry>allocation</entry><entry>allocation</entry><entry>allocation</entry></row><row><entry/><entry namest="offset" nameend="4" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>1</entry><entry>4 (r0, r2, r4, r6)</entry><entry>2 (r1, r3)</entry><entry>6</entry></row><row><entry/><entry>2</entry><entry/><entry>2 (r5, r7)</entry><entry>6</entry></row><row><entry/><entry>3</entry><entry/><entry>5 (r8, r9, r10,</entry><entry>9</entry></row><row><entry/><entry/><entry/><entry>r11, r12)</entry></row><row><entry/><entry>4</entry><entry/><entry>1 (r13)</entry><entry>5</entry></row><row><entry/><entry namest="offset" nameend="4" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0081" num="0078">As a consequence of the reduced allocation at the outset (in block <b>702</b>), tasks are able to start execution earlier (or at least enter a READY state earlier and be available for selection for execution earlier). This is because fewer temporary registers need to be available for allocation to the task.</p><p id="p-0082" num="0079">The method of <figref idref="DRAWINGS">FIG. <b>7</b></figref> improves the utilisation of the TSU <b>108</b> particularly where the tasks being executed make heavy use of the temporary registers (i.e. the tasks use the temporary registers a lot) and hence they are in short supply.</p><p id="p-0083" num="0080">The static allocation of temporary registers and the dynamic allocations of temporary registers may be allocated from a common pool of registers or from two different pools (or collections) of registers, e.g. from pools of registers in different physical storages (e.g. different RAMs). By allocating the static allocation and the dynamic allocations from different pools of registers, it prevents deadlock from occurring where a task from one pass (pass B) has a sequential dependency on a task from the previous pass (pass A). This is because the static allocations, which are held for the entirety of the task, cannot interfere with the dynamic allocations, which are only held for the relevant phase of the task.</p><p id="p-0084" num="0081">An alternative solution to the deadlock, where the static allocation and the dynamic allocations are allocated from the same pool of registers, is to provide one or more rules that define when the method of <figref idref="DRAWINGS">FIG. <b>7</b></figref> may be used and when it should be disabled (i.e. such that tasks are not split into phases and there is only one allocation for all registers for the entirety of the task). This analysis may be performed offline (e.g. by parsing the shader to determine allocations) and the rules may, for example, be defined based on the number of registers in the calculated static allocation, R<sub>static</sub>, the total number of temporary registers that are available in the system, R<sub>total</sub>, and the maximum number of tasks that can be mapped, T<sub>max </sub>(which is a hardware limit). A rule may be defined so as to ensure that following any allocation there are always enough unallocated temporary registers for at least one maximum-sized dynamic allocation, R<sub>dynamic_max </sub>and this results in the rule that the method of <figref idref="DRAWINGS">FIG. <b>7</b></figref> is enabled where R<sub>static</sub>&#x2264;(R<sub>total</sub>&#x2212;R<sub>dynamic_max</sub>)/T<sub>max </sub>In some examples, R<sub>dynamic_max</sub>=256. However, deadlock may still occur where such rules are used because fragmentation may prevent allocation of a large enough block of contiguous temporary registers.</p><p id="p-0085" num="0082">In a variation of the method shown in <figref idref="DRAWINGS">FIG. <b>7</b></figref> and described above, the method may initially allocate the static requirement and the dynamic requirements for all the phases of the task. Then, when a task reaches a phase boundary, the dynamic allocation for the completed phase is freed, but no further allocation is required. This avoids the need for the task to return to the task queue at each phase boundary and reduces the amount of allocated resources (compared to known allocation techniques) as the task progresses, but the initial allocation is not reduced.</p><p id="p-0086" num="0083">By adjusting the position of the phase boundaries, the granularity with which temporary registers are allocated may be adjusted. If temporary registers are allocated in smaller groups, then it takes less time to perform the allocation, and the delay prior to allocation is likely to be smaller; however allocation is performed more often than for larger groups of temporary registers.</p><p id="p-0087" num="0084">The method described above with reference to <figref idref="DRAWINGS">FIG. <b>7</b></figref> may be used independently or in combination with any of the other methods described herein (e.g. any of the methods described above with reference to <figref idref="DRAWINGS">FIGS. <b>3</b>-<b>5</b></figref>). Where the two methods are used in combination with each other, i.e. where tasks are suspended at phase boundaries (or conditionally suspended at phase boundaries) and de-allocation and allocation of the dynamic allocation of temporary registers also occurs at phase boundaries, the criteria used to place phase boundaries may be the same or different to those used where either the methods of <figref idref="DRAWINGS">FIGS. <b>3</b>-<b>5</b></figref> and the method of <figref idref="DRAWINGS">FIG. <b>7</b></figref> are used independently.</p><p id="p-0088" num="0085">Where the methods described herein are used together, phase boundaries within a program (e.g. within a shader program) may be defined initially at points in the code that are followed by delays which are long or potentially long (e.g. longer than average actual or potential delays). As described above, these initial points may, for example, be after high-latency instructions (e.g. texel fetch operations and instructions with a de-scheduling fence, where these are used) and/or where the program waits for sequential dependencies (SDs) and fences to clear, e.g. before output buffer writes (OBW) and DISCARD instructions. Following this initial definition, the position of one or more of the phase boundaries may, if certain criteria are met, be modified to a position earlier in the code if this reduces the number of live registers at the phase boundary or if it reduces the number of static registers overall (i.e. the number of registers that are live at any phase boundary in the program). Dependent upon the reason for the placement of a phase boundary, it may not be possible to move some phase boundaries. In various examples, only a subset of phase boundaries may be considered for adjustment, following their initial definition and this may be dependent upon the reason for the initial placement. For example, where a phase boundary is initially placed before a DS fence, the code may then be scanned upwards to identify the last texture sampling (SMP) operation in a texture sampling island (where this island comprises block of instructions between the instruction that set the fence and the instruction that waits on the fence, where the instructions in the block do not consume the data that is being fenced) and the phase boundary may be moved to following this last texture sampling instruction if this reduces the number of live registers at the phase boundary or if it reduces the number of static registers overall (i.e. the number of registers that are live at any phase boundary in the program).</p><p id="p-0089" num="0086">A third example method of managing resources within a GPU pipeline, which is a combination of the methods of <figref idref="DRAWINGS">FIGS. <b>3</b> and <b>7</b></figref>, can be described with reference to <figref idref="DRAWINGS">FIG. <b>8</b></figref>. When a task reaches a phase boundary, the dynamic allocation of temporary registers (for the phase that has just finished) is freed (block <b>801</b>, cf. block <b>702</b>) and the task is suspended (block <b>802</b>, cf. block <b>302</b>). As described above, when a task is in a suspended state, it not in the same state as a de-scheduled task because a de-scheduled task retains all the resources that were allocated to the task prior to its execution, whereas many of the resources allocated to a task are freed (i.e. de-allocated) when the task is suspended (block <b>822</b>, cf. block <b>322</b>). The resources that are freed (in block <b>822</b>) do not include the static allocation of temporary registers but do include any other resources allocated to the task such as storage for the task state (e.g. PC, task ID, counters and predicates etc. as described above).</p><p id="p-0090" num="0087">When a task is suspended (in block <b>802</b>), prior to freeing the allocated resources (in block <b>822</b>), the execution state for the task is stored (block <b>824</b>, cf. block <b>324</b>). Storing the execution state (in block <b>824</b>) comprises storing any state required to restart the task from the point after the phase boundary, such as data that records the progress of the task prior to suspension.</p><p id="p-0091" num="0088">In <figref idref="DRAWINGS">FIG. <b>8</b></figref>, for example, the instruction controller <b>118</b> (in the TSU <b>108</b>) may determine whether suspension conditions are met (in block <b>502</b>) and then suspend or de-schedule the task if required (in blocks <b>504</b>, <b>802</b>) including storing execution state where appropriate (in block <b>824</b>). The scheduler <b>116</b> may determine whether to un-suspend a task (block <b>304</b>) and the subsequent operations (blocks <b>306</b>, <b>308</b>, <b>810</b>, <b>814</b>, <b>816</b>) and also whether conditions are satisfied to re-schedule a task (in block <b>506</b>) and the subsequent operation (block <b>812</b>). As described above, the freeing of resources (in blocks <b>801</b>, <b>822</b>) may be performed by the scheduler <b>116</b> and/or by other hardware within the TSU <b>108</b>. For example, allocations may be freed by various hardware elements working together, e.g. the scheduler <b>116</b> along with additional hardware logic within the TSU <b>108</b> (e.g. a conditional execution unit pipeline) and hardware logic external to the TSU but within the GPU pipeline <b>100</b> (e.g. a hardware logic unit which is located between the tag buffer <b>114</b> and the TSU <b>108</b>).</p><p id="p-0092" num="0089">By using the combination of methods of <figref idref="DRAWINGS">FIGS. <b>3</b> and <b>7</b></figref>, there is less execution state to store (in block <b>824</b>), compared to the use of the method of <figref idref="DRAWINGS">FIG. <b>3</b></figref> without the method of <figref idref="DRAWINGS">FIG. <b>7</b></figref>, because the temporary registers that remain allocated to the task (i.e. the static allocation) are not freed. As a consequence of this, for a fixed amount of storage space for storing execution state (in block <b>824</b>), a larger number of tasks can be placed into a suspended state where the method of <figref idref="DRAWINGS">FIG. <b>8</b></figref> is used compared to where the method of <figref idref="DRAWINGS">FIG. <b>3</b></figref> is used without the method of <figref idref="DRAWINGS">FIG. <b>7</b></figref>.</p><p id="p-0093" num="0090">As described above with reference to <figref idref="DRAWINGS">FIG. <b>3</b></figref>, the task remains in the suspended state until pre-defined conditions are satisfied (Yes' in block <b>304</b>). The particular conditions that need to be satisfied for a task will depend on the nature of the phase boundary, e.g. they will depend upon the instruction that resulted in the phase boundary. For example, where the phase boundary is placed following an instruction to fetch data (e.g. a texture fetch), then the conditions (in block <b>304</b>) will be satisfied when the data returns. Alternatively, where the phase boundary is placed where sequential dependencies need to clear (e.g. before a DISCARD or OBW instruction), then the conditions (in block <b>304</b>) will be satisfied when the sequential dependencies is cleared.</p><p id="p-0094" num="0091">As described above, as resources (aside from the static allocation of temporary registers) are freed when a task is suspended, there are more available resources for allocation to other tasks which are otherwise ready to be executed (e.g. all their sequential dependencies have been met) and this means that the freed resources can be used to place another task into the READY state and once a task is in the READY state, it can be selected for execution (and hence enter the ACTIVE state).</p><p id="p-0095" num="0092">When the conditions are satisfied to restore a suspended task (Yes' in block <b>304</b>), the task cannot immediately commence execution, or be placed into the READY state, because it does not have all the required resources allocated to it. The task may be placed into a high-priority queue (block <b>306</b>) such that resources are allocated to the task in preference to another task that has not yet started execution. When the task is selected from the high-priority queue (Yes' in block <b>308</b>), resources are allocated to the task and the task state is restored (block <b>810</b>, cf. block <b>310</b>) using the information that was previously stored (in block <b>824</b>).</p><p id="p-0096" num="0093">The resources that are allocated to the task (in block <b>810</b>) include resources that store the task state (block <b>814</b>) and the dynamic allocation of temporary registers for the next phase (block <b>816</b>). At this point the task is placed into the READY state and can be selected for execution when there is capacity within the execution pipelines (e.g. when the number of tasks in the ACTIVE state falls below a pre-defined limit).</p><p id="p-0097" num="0094">As described above, where a task is suspended (in block <b>302</b>) as a consequence of a phase boundary that is immediately before a DISCARD or write to output buffer (OBW), once the task resumes execution, the DISCARD/OBW instruction can be executed immediately because the sequential dependency will have been met (as this has been checked before the task exited the suspended state, in block <b>304</b>).</p><p id="p-0098" num="0095"><figref idref="DRAWINGS">FIG. <b>8</b></figref> also shows a fourth example method of managing resources within a GPU pipeline, which is a combination of the methods of <figref idref="DRAWINGS">FIGS. <b>5</b> and <b>7</b></figref>. As shown in <figref idref="DRAWINGS">FIG. <b>8</b></figref>, when a task reaches a phase boundary there may be an additional check (compared to the third example method, described above) to determine whether conditions are met to suspend, rather than de-schedule, the task (block <b>502</b>). These conditions may, for example, be based on the current status of the execution pipelines in the TSU <b>108</b> (e.g. the current utilisation of the execution pipelines) and further examples are described above. If the conditions are satisfied (Yes' in block <b>502</b>), then the task is suspended (block <b>802</b>) and the method continues as described above with reference to <figref idref="DRAWINGS">FIG. <b>8</b></figref>. If, however, the conditions are not satisfied (No&#x2032; in block <b>502</b>), then the task is de-scheduled (block <b>504</b>). This means that as soon as conditions are satisfied to re-schedule the task (Yes' in block <b>506</b>), e.g. data returns or a sequential dependency is met, the dynamic allocation of temporary registers for the next phase of the task is allocated (block <b>812</b>) and then the task is immediately ready to be selected for execution. Unlike for a suspended task, where a task is de-scheduled, it retains the allocation of resources used to store the task state and so these do not need to be reallocated to the task before it can enter the READY state.</p><p id="p-0099" num="0096">By using conditional suspension of tasks (block <b>502</b>, as in <figref idref="DRAWINGS">FIGS. <b>5</b> and <b>8</b></figref>), this provides additional flexibility to improve the efficiency of operation of the TSU <b>108</b> dependent upon prevailing conditions within the GPU pipeline <b>100</b>. As noted above, a de-scheduled task can return to execution more quickly than a suspended task and so if there are plenty of available resources (i.e. the system is not currently resource-constrained), tasks may be de-scheduled rather than suspended; however, if the resources become constrained and/or the utilisation of the execution pipelines falls (e.g. because of a lack of tasks in the READY state), then tasks may be suspended rather than de-scheduled.</p><p id="p-0100" num="0097">As described above, one type of deadlock may be prevented by allocating the static allocation of temporary registers from a different pool of registers than the dynamic allocations of temporary registers. As shown in <figref idref="DRAWINGS">FIG. <b>9</b></figref>, if the registers are allocated from the same pool of resources and the static allocation of registers to the task <b>902</b> from the later pass (pass B) does not leave sufficient free registers to enable allocation of dynamic registers for a next phase (2<sup>nd </sup>phase) of the task <b>904</b> from the earlier pass (pass A), then that earlier task cannot progress (i.e. cannot execute the phase that requires the dynamic allocation of registers and hence is stuck at the point indicated by arrow <b>906</b> in <figref idref="DRAWINGS">FIG. <b>9</b></figref>) and the later task (from pass B) reaches a point (indicated by arrow <b>908</b> in <figref idref="DRAWINGS">FIG. <b>9</b></figref>) where it cannot progress because the sequential dependency has not been met. As shown in <figref idref="DRAWINGS">FIG. <b>9</b></figref>, in this example, the instruction <b>910</b> in the pass A task <b>904</b> that clears the sequential dependency condition is located after the request for the dynamic allocation which is blocked due to insufficient resource. In contrast, if the static allocation of temporary registers comes from a different pool of registers than the dynamic allocations, then the static allocation of registers to the task <b>902</b> from the later pass (pass B) cannot impact whether there are sufficient free registers to enable allocation of dynamic registers for the next phase (2<sup>nd </sup>phase) of the task <b>904</b> from the earlier pass (pass A). When the task <b>902</b> from the later pass reaches the point where it cannot progress (as indicated by arrow <b>908</b>), its dynamic allocation is released, thereby enabling the task <b>904</b> from the earlier pass to progress.</p><p id="p-0101" num="0098">The methods described above rely upon the presence of phase boundaries within a program. These phase boundaries, which may be identified by the position of a special instruction (e.g. a PHASE instruction) within the code, may be determined based on static analysis (e.g. offline analysis) of the code (e.g. by a compiler at compile-time) or may be determined dynamically (e.g. by the GPU pipeline <b>100</b> at run-time).</p><p id="p-0102" num="0099"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a flow diagram of an example method of dividing a program (e.g. a shader) into a plurality of phases. This method may, for example, be performed at compile-time by a compiler. As shown in <figref idref="DRAWINGS">FIG. <b>10</b></figref>, the method comprises receiving program code (e.g. shader code) and performing static analysis on the code using one or more pre-defined criteria (block <b>1002</b>). These criteria may be based on instruction types or instruction characteristics, as described above with reference to the example in <figref idref="DRAWINGS">FIG. <b>2</b></figref>, or based on resource-usage of the program, such as the number of live registers at any point in the code, as described above with reference to the example in <figref idref="DRAWINGS">FIG. <b>6</b></figref>, or based on a combination of the two. Other criteria may be used in addition to, or instead of, either of these.</p><p id="p-0103" num="0100">Based on the analysis, the position of one or more phase boundaries within the code are identified (block <b>1004</b>) and these may be identified by the addition of a special instruction (block <b>1006</b>) or in any other way such that it can be determined, at run-time when a task (which involves the execution of the program on one or more data-items) reaches a phase boundary.</p><p id="p-0104" num="0101">In some examples, the method may further comprise assessing the initial placement of the phase boundaries using one or more metrics (block <b>1008</b>), where these metrics may be associated with the criteria used to place the phase boundaries (in block <b>1002</b>). For example, if the phase boundaries are placed to reduce the number of temporary registers that are live at a phase boundary (in block <b>1002</b>), the associated metric that is used to assess the placement (in block <b>1008</b>) may be the total number of registers that are live at any phase boundary. Alternatively, different criteria may be used to initially place the phase boundaries (in block <b>1004</b>) and to assess the phase boundary placement (in block <b>1008</b>). In an example, which combines both the instruction type criteria (of <figref idref="DRAWINGS">FIG. <b>2</b></figref>) and the resource-usage (or more particularly register-usage) criteria (of <figref idref="DRAWINGS">FIG. <b>6</b></figref>), the static analysis may be based on instruction type/characteristics (in block <b>1002</b>) to initially place one or more phase boundaries (in block <b>1004</b>) and then the number of live registers at each phase boundary may be used as the metric to subsequently assess the placement (in block <b>1008</b>) and adjust the placement (in block <b>1010</b>).</p><p id="p-0105" num="0102">In such an example, a phase boundary position may initially be identified prior to DS fence; however, usually there is a block of instructions between the setting of a fence (which may be implemented by a field attached to an instruction, rather than a dedicated instruction) and the instruction that waits on it. Consequently, the position of the phase boundary may be moved upwards within the code (i.e. earlier in the code) from before the DS fence to somewhere after the instruction that sets the data fence, e.g. to a position where there are fewer live registers. This does not affect the operation of the code because the instructions in between (e.g. the instructions in the SMP island) are not dependent on the data that is fenced. In this way, the method serves reduce the size of the static allocation of registers (by reducing the number of registers that are live at the phase boundary).</p><p id="p-0106" num="0103">Following the assessment (in block <b>1010</b>), one or more phase boundary positions may be adjusted (block <b>1010</b>). The process may involve feedback (as shown by the arrow from block <b>1010</b> back to block <b>1008</b>) such that after the adjustment, the effect of the change is assessed (in block <b>1008</b>) and the change can be maintained or reversed as a result. Furthermore, the method may iterate (i.e. the loop may be traversed more than once) to optimise placement of the phase boundaries.</p><p id="p-0107" num="0104">In addition to, or instead of, adjusting the position of the phase boundaries (in block <b>1010</b>), the method may comprise rearranging instructions within the code so that instructions before a phase boundary are instead placed after a phase boundary (or vice versa) as long as no dependencies are broken (block <b>1012</b>). This rearrangement may be done, for example, to reduce the number of temporary registers that are live at the phase boundary or may be based on any other criteria. In addition, or instead, instructions that write to temporary registers may be duplicated, so that they occur both before and after a phase boundary, to reduce the number of temporary registers that are live at a phase boundary (and hence form part of the static allocation in the method of <figref idref="DRAWINGS">FIG. <b>7</b> or <b>8</b></figref>).</p><p id="p-0108" num="0105">A first further example provides a method of managing resources in a graphics processing pipeline, the method comprising: in response to a task reaching a phase boundary during execution of a program within a texture/shading unit, determining whether one or more pre-defined conditions are satisfied; in response to determining that de-scheduling conditions are satisfied, suspending the task, wherein suspending the task comprises freeing resources allocated to the task; determining whether conditions associated with un-suspending the task are satisfied; and after determining that the conditions associated with un-suspending the task are satisfied, allocating resources to the task such that the task is ready to continue execution of the program.</p><p id="p-0109" num="0106">Suspending the task may further comprise storing execution state associated with the task (<b>324</b>) and the method further comprises, after determining that the conditions associated with suspending the task are satisfied, allocating resources to the task and re-instating the stored execution state.</p><p id="p-0110" num="0107">The method may further comprise, after determining that the conditions associated with un-suspending the task are satisfied and before allocating resources to the task, placing the task in a high priority queue and wherein the resources are allocated in response to the task being selected from the high priority queue.</p><p id="p-0111" num="0108">The method may further comprise, after allocating resources to the task, placing the task in a queue of tasks that are ready to continue execution. Placing the task in a queue of tasks that are ready to continue execution may comprise placing the task at a front of the queue of tasks that are ready to continue execution. Placing the task in a queue of tasks that are ready to continue execution may comprise placing the task at a position in the queue of tasks that are ready to continue execution based on an age of the task relative to other tasks in the queue.</p><p id="p-0112" num="0109">The one or more pre-defined conditions may further comprise suspension conditions and wherein the task is suspended in response to determining that both the de-scheduling conditions and the suspension conditions are satisfied.</p><p id="p-0113" num="0110">The method may further comprise: in response to determining that the suspension conditions are not met, de-scheduling the task, wherein de-scheduling the task does not comprise freeing any of the resources allocated to the task; determining whether conditions associated with de-scheduling the task are satisfied; and in response to determining that the conditions associated with de-scheduling the task are satisfied, returning the task to a state that is ready to continue execution of the program.</p><p id="p-0114" num="0111">The program may comprise one or more phase instructions, each phase instruction marking a phase boundary, and the task reaches a phase boundary during execution of a program when the execution reaches a phase instruction.</p><p id="p-0115" num="0112">The resources allocated to a task may comprise a plurality of temporary registers.</p><p id="p-0116" num="0113">Suspending the task may comprise freeing any resources allocated to the task.</p><p id="p-0117" num="0114">The method may further comprise: in response to the task reaching a phase boundary, and prior to assessing the pre-defined conditions, freeing a dynamic allocation of temporary registers allocated to the task for an immediately previous phase of the task; and wherein suspending the task comprises: storing execution state for the task; and freeing resources allocated to the task for storage of the execution state, and wherein allocating resources to the task such that the task is ready to continue execution of the program comprises: allocating resources to the task for storage of the execution state and reinstating the execution state from the stored execution state; and allocating a dynamic allocation of temporary registers to the task for a next phase of the task.</p><p id="p-0118" num="0115">Suspending the task may not comprise freeing a static allocation of temporary registers to the task, wherein the static allocation of temporary registers comprises any temporary registers that are live at a boundary between two phases. The static allocation of temporary registers may be allocated from a first group of temporary registers and each dynamic allocation of temporary registers may be allocated from a second group of temporary registers, wherein the first and second groups of temporary registers do not overlap.</p><p id="p-0119" num="0116">The method may further comprise, on completion of execution of the task, freeing the static allocation and the dynamic allocation of temporary registers.</p><p id="p-0120" num="0117">A second further example provides a method of sub-dividing a program into a plurality of phases, the method comprising: analysing instructions in the program to identify one or more instructions that, when executed, can introduce large latencies; and for an identified instruction, inserting a phase instruction into the program prior to or after the identified instruction.</p><p id="p-0121" num="0118">The one or more instructions that, when executed, can introduce large latencies may comprise one or more of: a texture fetch instruction; and an instruction that triggers checking of sequential dependencies.</p><p id="p-0122" num="0119">A third further example provides a texture/shading unit for use in a graphics processing pipeline, the texture/shading unit comprising hardware logic arranged: in response to a task reaching a phase boundary during execution of a program, to determine whether one or more pre-defined conditions are satisfied; in response to determining that de-scheduling conditions are satisfied, to suspend the task, wherein suspending the task comprises freeing resources allocated to the task; to subsequently determine whether conditions associated with un-suspending the task are satisfied; and after determining that the conditions associated with un-suspending the task are satisfied, to allocate resources to the task such that the task is ready to continue execution of the program.</p><p id="p-0123" num="0120">The hardware logic may comprise a scheduler and an instruction controller and wherein the instruction controller is arranged: in response to a task reaching a phase boundary during execution of a program, to determine whether one or more pre-defined conditions are satisfied; and in response to determining that de-scheduling conditions are satisfied, to suspend the task, wherein suspending the task comprises freeing resources allocated to the task; and wherein the scheduler is arranged: to subsequently determine whether conditions associated with un-suspending the task are satisfied; and after determining that the conditions associated with un-suspending the task are satisfied, to allocate resources to the task such that the task is ready to continue execution of the program.</p><p id="p-0124" num="0121"><figref idref="DRAWINGS">FIG. <b>11</b></figref> shows a computer system in which the methods described herein may be implemented. The computer system comprises a CPU <b>1102</b>, a GPU <b>1104</b>, a memory <b>1106</b> and other devices <b>1114</b>, such as a display <b>1116</b>, speakers <b>1118</b> and a camera <b>1120</b>. The GPU <b>1104</b> may comprise a pipeline (e.g. as shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>) that implements a method as described herein. The components of the computer system can communicate with each other via a communications bus <b>1122</b>.</p><p id="p-0125" num="0122">The system of <figref idref="DRAWINGS">FIG. <b>11</b></figref> and the pipeline <b>100</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref> are shown as comprising a number of functional blocks. This is schematic only and is not intended to define a strict division between different logic elements of such entities. Each functional block may be provided in any suitable manner. It is to be understood that intermediate values described herein as being formed by a functional block need not be physically generated by the particular functional block at any point and may merely represent logical values which conveniently describe the processing performed by the system or pipeline between its input and output.</p><p id="p-0126" num="0123">The graphics pipeline described herein may be embodied in hardware on an integrated circuit. The graphics pipeline described herein may be configured to perform any of the methods described herein. Generally, any of the functions, methods, techniques or components described above can be implemented in software, firmware, hardware (e.g., fixed logic circuitry), or any combination thereof. The terms &#x201c;module,&#x201d; &#x201c;functionality,&#x201d; &#x201c;component&#x201d;, &#x201c;element&#x201d;, &#x201c;unit&#x201d;, &#x201c;block&#x201d; and &#x201c;logic&#x201d; may be used herein to generally represent software, firmware, hardware, or any combination thereof. In the case of a software implementation, the module, functionality, component, element, unit, block or logic represents program code that performs the specified tasks when executed on a processor. The algorithms and methods described herein could be performed by one or more processors executing code that causes the processor(s) to perform the algorithms/methods. Examples of a computer-readable storage medium include a random-access memory (RAM), read-only memory (ROM), an optical disc, flash memory, hard disk memory, and other memory devices that may use magnetic, optical, and other techniques to store instructions or other data and that can be accessed by a machine.</p><p id="p-0127" num="0124">The terms computer program code and computer readable instructions as used herein refer to any kind of executable code for processors, including code expressed in a machine language, an interpreted language or a scripting language. Executable code includes binary code, machine code, bytecode, code defining an integrated circuit (such as a hardware description language or netlist), and code expressed in a programming language code such as C, Java or OpenCL. Executable code may be, for example, any kind of software, firmware, script, module or library which, when suitably executed, processed, interpreted, compiled, executed at a virtual machine or other software environment, cause a processor of the computer system at which the executable code is supported to perform the tasks specified by the code.</p><p id="p-0128" num="0125">A processor, computer, or computer system may be any kind of device, machine or dedicated circuit, or collection or portion thereof, with processing capability such that it can execute instructions. A processor may be any kind of general purpose or dedicated processor, such as a CPU, GPU, System-on-chip, state machine, media processor, an application-specific integrated circuit (ASIC), a programmable logic array, a field-programmable gate array (FPGA), physics processing units (PPUs), radio processing units (RPUs), digital signal processors (DSPs), general purpose processors (e.g. a general purpose GPU), microprocessors, any processing unit which is designed to accelerate tasks outside of a CPU, etc. A computer or computer system may comprise one or more processors. Those skilled in the art will realize that such processing capabilities are incorporated into many different devices and therefore the term &#x2018;computer&#x2019; includes set top boxes, media players, digital radios, PCs, servers, mobile telephones, personal digital assistants and many other devices.</p><p id="p-0129" num="0126">It is also intended to encompass software which defines a configuration of hardware as described herein, such as HDL (hardware description language) software, as is used for designing integrated circuits, or for configuring programmable chips, to carry out desired functions. That is, there may be provided a computer readable storage medium having encoded thereon computer readable program code in the form of an integrated circuit definition dataset that when processed (i.e. run) in an integrated circuit manufacturing system configures the system to manufacture a graphics pipeline configured to perform any of the methods described herein, or to manufacture a graphics pipeline comprising any apparatus described herein. An integrated circuit definition dataset may be, for example, an integrated circuit description.</p><p id="p-0130" num="0127">Therefore, there may be provided a method of manufacturing, at an integrated circuit manufacturing system, a graphics pipeline as described herein. Furthermore, there may be provided an integrated circuit definition dataset that, when processed in an integrated circuit manufacturing system, causes the method of manufacturing a graphics pipeline to be performed.</p><p id="p-0131" num="0128">An integrated circuit definition dataset may be in the form of computer code, for example as a netlist, code for configuring a programmable chip, as a hardware description language defining an integrated circuit at any level, including as register transfer level (RTL) code, as high-level circuit representations such as Verilog or VHDL, and as low-level circuit representations such as OASIS (RTM) and GDSII. Higher level representations which logically define an integrated circuit (such as RTL) may be processed at a computer system configured for generating a manufacturing definition of an integrated circuit in the context of a software environment comprising definitions of circuit elements and rules for combining those elements in order to generate the manufacturing definition of an integrated circuit so defined by the representation. As is typically the case with software executing at a computer system so as to define a machine, one or more intermediate user steps (e.g. providing commands, variables etc.) may be required in order for a computer system configured for generating a manufacturing definition of an integrated circuit to execute code defining an integrated circuit so as to generate the manufacturing definition of that integrated circuit.</p><p id="p-0132" num="0129">An example of processing an integrated circuit definition dataset at an integrated circuit manufacturing system so as to configure the system to manufacture a graphics pipeline will now be described with respect to <figref idref="DRAWINGS">FIG. <b>12</b></figref>.</p><p id="p-0133" num="0130"><figref idref="DRAWINGS">FIG. <b>12</b></figref> shows an example of an integrated circuit (IC) manufacturing system <b>1202</b> which is configured to manufacture a graphics pipeline as described in any of the examples herein. In particular, the IC manufacturing system <b>1202</b> comprises a layout processing system <b>1204</b> and an integrated circuit generation system <b>1206</b>. The IC manufacturing system <b>1202</b> is configured to receive an IC definition dataset (e.g. defining a graphics pipeline as described in any of the examples herein), process the IC definition dataset, and generate an IC according to the IC definition dataset (e.g. which embodies a graphics pipeline as described in any of the examples herein). The processing of the IC definition dataset configures the IC manufacturing system <b>1202</b> to manufacture an integrated circuit embodying a graphics pipeline as described in any of the examples herein.</p><p id="p-0134" num="0131">The layout processing system <b>1204</b> is configured to receive and process the IC definition dataset to determine a circuit layout. Methods of determining a circuit layout from an IC definition dataset are known in the art, and for example may involve synthesising RTL code to determine a gate level representation of a circuit to be generated, e.g. in terms of logical components (e.g. NAND, NOR, AND, OR, MUX and FLIP-FLOP components). A circuit layout can be determined from the gate level representation of the circuit by determining positional information for the logical components. This may be done automatically or with user involvement in order to optimise the circuit layout. When the layout processing system <b>1204</b> has determined the circuit layout it may output a circuit layout definition to the IC generation system <b>1206</b>. A circuit layout definition may be, for example, a circuit layout description.</p><p id="p-0135" num="0132">The IC generation system <b>1206</b> generates an IC according to the circuit layout definition, as is known in the art. For example, the IC generation system <b>1206</b> may implement a semiconductor device fabrication process to generate the IC, which may involve a multiple-step sequence of photo lithographic and chemical processing steps during which electronic circuits are gradually created on a wafer made of semiconducting material. The circuit layout definition may be in the form of a mask which can be used in a lithographic process for generating an IC according to the circuit definition. Alternatively, the circuit layout definition provided to the IC generation system <b>1206</b> may be in the form of computer-readable code which the IC generation system <b>1206</b> can use to form a suitable mask for use in generating an IC.</p><p id="p-0136" num="0133">The different processes performed by the IC manufacturing system <b>1202</b> may be implemented all in one location, e.g. by one party. Alternatively, the IC manufacturing system <b>1202</b> may be a distributed system such that some of the processes may be performed at different locations and may be performed by different parties. For example, some of the stages of: (i) synthesising RTL code representing the IC definition dataset to form a gate level representation of a circuit to be generated, (ii) generating a circuit layout based on the gate level representation, (iii) forming a mask in accordance with the circuit layout, and (iv) fabricating an integrated circuit using the mask, may be performed in different locations and/or by different parties.</p><p id="p-0137" num="0134">In other examples, processing of the integrated circuit definition dataset at an integrated circuit manufacturing system may configure the system to manufacture a graphics pipeline without the IC definition dataset being processed so as to determine a circuit layout. For instance, an integrated circuit definition dataset may define the configuration of a reconfigurable processor, such as an FPGA, and the processing of that dataset may configure an IC manufacturing system to generate a reconfigurable processor having that defined configuration (e.g. by loading configuration data to the FPGA).</p><p id="p-0138" num="0135">In some embodiments, an integrated circuit manufacturing definition dataset, when processed in an integrated circuit manufacturing system, may cause an integrated circuit manufacturing system to generate a device as described herein. For example, the configuration of an integrated circuit manufacturing system in the manner described above with respect to <figref idref="DRAWINGS">FIG. <b>12</b></figref> by an integrated circuit manufacturing definition dataset may cause a device as described herein to be manufactured.</p><p id="p-0139" num="0136">In some examples, an integrated circuit definition dataset could include software which runs on hardware defined at the dataset or in combination with hardware defined at the dataset. In the example shown in <figref idref="DRAWINGS">FIG. <b>12</b></figref>, the IC generation system may further be configured by an integrated circuit definition dataset to, on manufacturing an integrated circuit, load firmware onto that integrated circuit in accordance with program code defined at the integrated circuit definition dataset or otherwise provide program code with the integrated circuit for use with the integrated circuit.</p><p id="p-0140" num="0137">Those skilled in the art will realize that storage devices utilized to store program instructions can be distributed across a network. For example, a remote computer may store an example of the process described as software. A local or terminal computer may access the remote computer and download a part or all of the software to run the program. Alternatively, the local computer may download pieces of the software as needed or execute some software instructions at the local terminal and some at the remote computer (or computer network). Those skilled in the art will also realize that by utilizing conventional techniques known to those skilled in the art that all, or a portion of the software instructions may be carried out by a dedicated circuit, such as a DSP, programmable logic array, or the like.</p><p id="p-0141" num="0138">The methods described herein may be performed by a computer configured with software in machine readable form stored on a tangible storage medium e.g. in the form of a computer program comprising computer readable program code for configuring a computer to perform the constituent portions of described methods or in the form of a computer program comprising computer program code means adapted to perform all the steps of any of the methods described herein when the program is run on a computer and where the computer program may be embodied on a computer readable storage medium. Examples of tangible (or non-transitory) storage media include disks, thumb drives, memory cards etc. and do not include propagated signals. The software can be suitable for execution on a parallel processor or a serial processor such that the method steps may be carried out in any suitable order, or simultaneously.</p><p id="p-0142" num="0139">The hardware components described herein may be generated by a non-transitory computer readable storage medium having encoded thereon computer readable program code.</p><p id="p-0143" num="0140">Memories storing machine executable data for use in implementing disclosed aspects can be non-transitory media. Non-transitory media can be volatile or non-volatile. Examples of volatile non-transitory media include semiconductor-based memory, such as SRAM or DRAM. Examples of technologies that can be used to implement non-volatile memory include optical and magnetic memory technologies, flash memory, phase change memory, resistive RAM.</p><p id="p-0144" num="0141">A particular reference to &#x201c;logic&#x201d; refers to structure that performs a function or functions. An example of logic includes circuitry that is arranged to perform those function(s). For example, such circuitry may include transistors and/or other hardware elements available in a manufacturing process. Such transistors and/or other elements may be used to form circuitry or structures that implement and/or contain memory, such as registers, flip flops, or latches, logical operators, such as Boolean operations, mathematical operators, such as adders, multipliers, or shifters, and interconnect, by way of example. Such elements may be provided as custom circuits or standard cell libraries, macros, or at other levels of abstraction. Such elements may be interconnected in a specific arrangement. Logic may include circuitry that is fixed function and circuitry can be programmed to perform a function or functions; such programming may be provided from a firmware or software update or control mechanism. Logic identified to perform one function may also include logic that implements a constituent function or sub-process. In an example, hardware logic has circuitry that implements a fixed function operation, or operations, state machine or process.</p><p id="p-0145" num="0142">The implementation of concepts set forth in this application in devices, apparatus, modules, and/or systems (as well as in methods implemented herein) may give rise to performance improvements when compared with known implementations. The performance improvements may include one or more of increased computational performance, reduced latency, increased throughput, and/or reduced power consumption. During manufacture of such devices, apparatus, modules, and systems (e.g. in integrated circuits) performance improvements can be traded-off against the physical implementation, thereby improving the method of manufacture. For example, a performance improvement may be traded against layout area, thereby matching the performance of a known implementation but using less silicon. This may be done, for example, by reusing functional blocks in a serialised fashion or sharing functional blocks between elements of the devices, apparatus, modules and/or systems. Conversely, concepts set forth in this application that give rise to improvements in the physical implementation of the devices, apparatus, modules, and systems (such as reduced silicon area) may be traded for improved performance. This may be done, for example, by manufacturing multiple instances of a module within a predefined area budget.&#x201d;</p><p id="p-0146" num="0143">Any range or device value given herein may be extended or altered without losing the effect sought, as will be apparent to the skilled person.</p><p id="p-0147" num="0144">It will be understood that the benefits and advantages described above may relate to one embodiment or may relate to several embodiments. The embodiments are not limited to those that solve any or all of the stated problems or those that have any or all of the stated benefits and advantages.</p><p id="p-0148" num="0145">Any reference to &#x2018;an&#x2019; item refers to one or more of those items. The term &#x2018;comprising&#x2019; is used herein to mean including the method blocks or elements identified, but that such blocks or elements do not comprise an exclusive list and an apparatus may contain additional blocks or elements and a method may contain additional operations or elements. Furthermore, the blocks, elements and operations are themselves not impliedly closed.</p><p id="p-0149" num="0146">The steps of the methods described herein may be carried out in any suitable order, or simultaneously where appropriate. The arrows between boxes in the figures show one example sequence of method steps but are not intended to exclude other sequences or the performance of multiple steps in parallel. Additionally, individual blocks may be deleted from any of the methods without departing from the spirit and scope of the subject matter described herein. Aspects of any of the examples described above may be combined with aspects of any of the other examples described to form further examples without losing the effect sought. Where elements of the figures are shown connected by arrows, it will be appreciated that these arrows show just one example flow of communications (including data and control messages) between elements. The flow between elements may be in either direction or in both directions.</p><p id="p-0150" num="0147">The applicant hereby discloses in isolation each individual feature described herein and any combination of two or more such features, to the extent that such features or combinations are capable of being carried out based on the present specification as a whole in the light of the common general knowledge of a person skilled in the art, irrespective of whether such features or combinations of features solve any problems disclosed herein. In view of the foregoing description it will be evident to a person skilled in the art that various modifications may be made within the scope of the invention.</p><?detailed-description description="Detailed Description" end="tail"?></description><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A method of managing resources in a graphics processing pipeline, the method comprising:<claim-text>in response to a task reaching a phase boundary during execution of a program within a texture/shading unit, determining whether one or more pre-defined conditions are satisfied;</claim-text><claim-text>in response to determining that de-scheduling conditions are satisfied, suspending the task, wherein suspending the task comprises freeing resources allocated to the task;</claim-text><claim-text>determining whether conditions associated with un-suspending the task are satisfied; and</claim-text><claim-text>after determining that the conditions associated with un-suspending the task are satisfied, allocating resources to the task such that the task is ready to continue execution of the program.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the de-scheduling conditions are related to the position of the phase boundary within the program and conditions associated with un-suspending the task depend on a nature of the phase boundary.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein suspending the task further comprises storing execution state associated with the task and the method further comprises, after determining that the conditions associated with suspending the task are satisfied, allocating resources to the task and re-instating the stored execution state.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising, after determining that the conditions associated with un-suspending the task are satisfied and before allocating resources to the task, placing the task in a high priority queue and wherein the resources are allocated in response to the task being selected from the high priority queue.</claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising, after allocating resources to the task, placing the task in a queue of tasks that are ready to continue execution.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The method according to <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein placing the task in a queue of tasks that are ready to continue execution comprises:<claim-text>placing the task at a front of the queue of tasks that are ready to continue execution; or</claim-text><claim-text>placing the task at a position in the queue of tasks that are ready to continue execution based on an age of the task relative to other tasks in the queue.</claim-text></claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the one or more pre-defined conditions further comprise suspension conditions and wherein the task is suspended in response to determining that both the de-scheduling conditions and the suspension conditions are satisfied.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The method according to <claim-ref idref="CLM-00007">claim 7</claim-ref>, further comprising:<claim-text>in response to determining that the suspension conditions are not met, de-scheduling the task, wherein de-scheduling the task does not comprise freeing any of the resources allocated to the task;</claim-text><claim-text>determining whether conditions associated with de-scheduling the task are satisfied; and</claim-text><claim-text>in response to determining that the conditions associated with de-scheduling the task are satisfied, returning the task to a state that is ready to continue execution of the program.</claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the program comprises one or more phase instructions, each phase instruction marking a phase boundary, and the task reaches a phase boundary during execution of a program when the execution reaches a phase instruction.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the resources allocated to a task comprise a plurality of temporary registers.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. (canceled)</claim-text></claim><claim id="CLM-00011-1" num="00011-1"><claim-text><b>11</b>. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>in response to the task reaching a phase boundary, and prior to assessing the pre-defined conditions, freeing a dynamic allocation of temporary registers allocated to the task for an immediately previous phase of the task;</claim-text></claim-text><claim-text>and wherein suspending the task comprises:<claim-text>storing execution state for the task, and</claim-text><claim-text>freeing resources allocated to the task for storage of the execution state;</claim-text></claim-text><claim-text>and wherein allocating resources to the task such that the task is ready to continue execution of the program comprises:<claim-text>allocating resources to the task for storage of the execution state and reinstating the execution state from the stored execution state, and</claim-text><claim-text>allocating a dynamic allocation of temporary registers to the task for a next phase of the task.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the resources allocated to a task comprise a plurality of temporary registers and suspending the task does not comprise freeing a static allocation of temporary registers to the task, wherein the static allocation of temporary registers comprises any temporary registers that are live at a boundary between two phases.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The method according to <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the static allocation of temporary registers is allocated from a first group of temporary registers and each dynamic allocation of temporary registers is allocated from a second group of temporary registers, wherein the first and second groups of temporary registers do not overlap.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The method according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising, on completion of execution of the task, freeing the static allocation and the dynamic allocation of temporary registers.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. A method of sub-dividing a program into a plurality of phases, the method comprising:<claim-text>analysing instructions in the program to identify one or more instructions that, when executed, can introduce large latencies; and</claim-text><claim-text>for an identified instruction, inserting a phase instruction into the program prior to or after the identified instruction.</claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The method according to <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the one or more instructions that, when executed, can introduce large latencies comprise one or more of:<claim-text>a texture fetch instruction; and</claim-text><claim-text>an instruction that triggers checking of sequential dependencies.</claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. A texture/shading unit for use in a graphics processing pipeline, the texture/shading unit comprising hardware logic arranged to:<claim-text>in response to a task reaching a phase boundary during execution of a program, determine whether one or more pre-defined conditions are satisfied;</claim-text><claim-text>in response to determining that de-scheduling conditions are satisfied, suspend the task, wherein suspending the task comprises freeing resources allocated to the task;</claim-text><claim-text>subsequently determine whether conditions associated with un-suspending the task are satisfied; and</claim-text><claim-text>after determining that the conditions associated with un-suspending the task are satisfied, allocate resources to the task such that the task is ready to continue execution of the program.</claim-text></claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The texture/shading unit according to <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the hardware logic comprises a scheduler and an instruction controller and wherein the instruction controller is arranged to:<claim-text>in response to a task reaching a phase boundary during execution of a program, determine whether one or more pre-defined conditions are satisfied, and</claim-text><claim-text>in response to determining that de-scheduling conditions are satisfied, suspend the task, wherein suspending the task comprises freeing resources allocated to the task; and</claim-text><claim-text>wherein the scheduler is arranged to:</claim-text><claim-text>subsequently determine whether conditions associated with un-suspending the task are satisfied, and</claim-text><claim-text>after determining that the conditions associated with un-suspending the task are satisfied, to allocate resources to the task such that the task is ready to continue execution of the program.</claim-text></claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. A method of manufacturing, at an integrated circuit manufacturing system, a texture/shading unit as set forth in <claim-ref idref="CLM-00017">claim 17</claim-ref> by inputting into said integrated circuit manufacturing system an integrated circuit definition dataset describing said texture/shading unit, to cause said integrated circuit manufacturing system to manufacture said texture/shading unit.</claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. A non-transitory computer readable storage medium having stored thereon an integrated circuit definition dataset that, when processed in an integrated circuit manufacturing system, configures the system to manufacture a texture/shading unit as set forth in <claim-ref idref="CLM-00017">claim 17</claim-ref>.</claim-text></claim></claims></us-patent-application>