<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004348A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004348</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17940394</doc-number><date>20220908</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>7</main-group><subgroup>483</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>7</main-group><subgroup>483</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc></classifications-cpc><invention-title id="d2e43">Methods and Apparatus for Efficient Denormal Handling In Floating-Point Units</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>PCT/US2020/053055</doc-number><date>20200928</date></document-id><parent-status>PENDING</parent-status></parent-doc><child-doc><document-id><country>US</country><doc-number>17940394</doc-number></document-id></child-doc></relation></continuation><us-provisional-application><document-id><country>US</country><doc-number>63032602</doc-number><date>20200530</date></document-id></us-provisional-application></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Huawei Technologies Co., Ltd.</orgname><address><city>Shenzhen</city><country>CN</country></address></addressbook><residence><country>CN</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Dibrino</last-name><first-name>Michael Thomas</first-name><address><city>Austin</city><state>TX</state><country>US</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A floating-point (FP) arithmetic unit includes a first FP execution pipeline operatively coupled to a register file, the first FP execution pipeline configured to perform a first FP operation on a first FP operand provided by the register file, the first FP execution pipeline comprising a plurality of execution units; and a first normalization unit operatively coupled to the register file, and the first FP execution pipeline, the first normalization unit configured to normalize the first FP operand, wherein the first normalization unit is configured to operate in parallel with the first FP execution pipeline, and is further configured to, in response to detecting that the first FP operand is a denormal, assert a first FP execution pipeline busy flag to stall the instruction dispatch of a first subsequent FP operation, the first FP operation and the first subsequent FP operation being of one FP operation type.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="39.45mm" wi="94.23mm" file="US20230004348A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="226.99mm" wi="148.84mm" file="US20230004348A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="216.92mm" wi="150.79mm" file="US20230004348A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="233.00mm" wi="148.84mm" file="US20230004348A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="222.93mm" wi="152.40mm" orientation="landscape" file="US20230004348A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="222.93mm" wi="152.40mm" orientation="landscape" file="US20230004348A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="222.67mm" wi="152.40mm" orientation="landscape" file="US20230004348A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="222.93mm" wi="152.40mm" orientation="landscape" file="US20230004348A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="222.93mm" wi="152.40mm" orientation="landscape" file="US20230004348A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="222.93mm" wi="152.40mm" orientation="landscape" file="US20230004348A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="223.10mm" wi="152.40mm" orientation="landscape" file="US20230004348A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="152.40mm" wi="105.07mm" file="US20230004348A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="209.13mm" wi="99.48mm" file="US20230004348A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="146.39mm" wi="126.32mm" file="US20230004348A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading><p id="p-0002" num="0001">This application is a continuation of International Application PCT/US2020/053055, filed Sep. 28, 2020, entitled &#x201c;Methods and Apparatus for Efficient Denormal Handling in Floating-Point Units,&#x201d; which claims the benefit of U.S. Provisional Application No. 63/032,602, filed on May 30, 2020, entitled &#x201c;Efficient Denormal Handling in Superscalar Floating-Point Units,&#x201d; which applications of which are incorporated herein by reference in their entireties.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">TECHNICAL FIELD</heading><p id="p-0003" num="0002">The present disclosure relates generally to methods and apparatus for digital computing, and, in particular embodiments, to methods and apparatus for efficient denormal handling in floating-point units.</p><heading id="h-0003" level="1">BACKGROUND</heading><p id="p-0004" num="0003">Denormals are floating-point values in the IEEE-754 floating-point standard in which the leading bit ahead of the fraction is assumed to be &#x2018;0&#x2019; instead of a &#x2018;1&#x2019;. They are indicated by an exponent field of zero and a fraction field of non-zero. A true zero is indicated by an exponent field of zero and a fraction field also of zero.</p><p id="p-0005" num="0004">There are two cases involving denormals which must be handled by floating-point execution units: input denormals and output denormals. Input denormals are denormals which appear at the input of the execution units and must be processed by the execution units. Output denormals are denormals which are produced by the execution units as a result of an arithmetic computation and may be written into the register files, stored into memory, or forwarded back to the inputs of the execution units.</p><heading id="h-0004" level="1">SUMMARY</heading><p id="p-0006" num="0005">According to a first aspect, a floating-point (FP) arithmetic unit is provided. The FP arithmetic unit includes: a first FP execution pipeline operatively coupled to a register file and an instruction dispatch, the first FP execution pipeline configured to perform a first FP operation on a first FP operand provided by the register file, the first FP execution pipeline comprising a plurality of execution units; and a first normalization unit operatively coupled to the register file, the first FP execution pipeline, and the instruction dispatch, the first normalization unit configured to normalize the first FP operand provided by the register file, wherein the first normalization unit is configured to operate in parallel with the first FP execution pipeline, and is further configured to, in response to detecting that the first FP operand is a denormal, assert a first FP execution pipeline busy flag to stall the instruction dispatch of a first subsequent FP operation and to provide the normalized first FP operand to the first FP execution pipeline, the first FP operation and the first subsequent FP operation being of one FP operation type.</p><p id="p-0007" num="0006">In a first implementation form of the FP arithmetic unit according to the first aspect, wherein the first FP execution pipeline is further configured to perform a second FP operation on a second FP operand provided by the register file; wherein the first normalization unit is further configured to normalize the second FP operand provided by the register file; and wherein in response to detecting that the second FP operand is normal, the first normalization unit is configured to discard the normalized second FP operand.</p><p id="p-0008" num="0007">In a second implementation form of the FP arithmetic unit according to the first aspect or any preceding implementation form of the first aspect, wherein the FP execution pipeline comprises one of a FP addition execution pipeline, a FP multiplication pipeline, an FP division pipeline, an FP square-root or generalized root pipeline, an FP exponential pipeline, an FP power pipeline, or an FP logarithm pipeline, or any other operation or instruction on a floating-point operand.</p><p id="p-0009" num="0008">In a third implementation form of the FP arithmetic unit according to the first aspect or any preceding implementation form of the first aspect, further comprising: a second FP execution pipeline operatively coupled to the register file and the instruction dispatch, the second FP execution pipeline configured to perform a third FP operation on a third FP operand provided by the register file, the second FP execution pipeline comprising a plurality of execution units; and a second normalization unit operatively coupled to the register file, the second FP execution pipeline, and the instruction dispatch, the second normalization unit configured to normalize the third FP operand provided by the register file, wherein the second normalization unit is configured to operate in parallel with the second FP execution pipeline, and is configured to, in response to detecting that the third FP operand is a denormal, assert a second FP execution pipeline busy flag to stall the instruction dispatch of a second subsequent FP operation and to provide the normalized third FP operand to the second FP execution pipeline, the third FP operation and the second subsequent FP operation being of one FP operation type.</p><p id="p-0010" num="0009">In a fourth implementation form of the FP arithmetic unit according to the first aspect or any preceding implementation form of the first aspect, wherein the second FP execution pipeline is further configured to perform a fourth FP operation on a fourth FP operand provided by the register file; wherein the second normalization unit is further configured to normalize the fourth FP operand provided by the register file; and wherein in response to detecting that the fourth FP operand is a normal, the second normalization unit is configured to discard the normalized fourth FP operand.</p><p id="p-0011" num="0010">In a fifth implementation form of the FP arithmetic unit according to the first aspect or any preceding implementation form of the first aspect, wherein the first normalization unit is further configured to cause the second normalization unit to assert the second FP execution pipeline busy flag and to provide the normalized third FP operand to the second FP execution pipeline when asserting the first FP execution pipeline busy flag, and wherein the second normalization unit is further configured to cause the first normalization unit to assert the first FP execution pipeline busy flag and to provide the normalized first FP operand to the first FP execution pipeline when asserting the second FP execution pipeline busy flag.</p><p id="p-0012" num="0011">In a sixth implementation form of the FP arithmetic unit according to the first aspect or any preceding implementation form of the first aspect, further comprising a denormal unit operatively coupled to the first FP execution pipeline, the denormal unit configured to convert a fifth FP operand outputted by the first FP execution pipeline into a denormal.</p><p id="p-0013" num="0012">According to a second aspect, a system is provided. The system comprising: a non-transitory memory storage comprising instructions and data; one or more processors in communication with the memory storage, wherein the one or more processors execute the instructions; and a FP arithmetic unit in communication with the one or more processors and the memory storage, the FP arithmetic unit comprising: a first FP execution pipeline operatively coupled to a register file and an instruction dispatch, the first FP execution pipeline configured to perform a first FP operation on a first FP operand provided by the register file, the first FP execution pipeline comprising a plurality of execution units; and a first normalization unit operatively coupled to the register file, the first FP execution pipeline, and the instruction dispatch, the first normalization unit configured to normalize the first FP operand provided by the register file, wherein the first normalization unit is configured to operate in parallel with the first FP execution pipeline, and is configured to, in response to detecting that the first FP operand is a denormal, assert a first FP execution pipeline busy flag to stall the instruction dispatch of a first subsequent FP operation and to provide the normalized first FP operand to the first FP execution pipeline, the first FP operation and the first subsequent FP operation being of one FP operation type.</p><p id="p-0014" num="0013">In a first implementation form of the system according to the second aspect, wherein the first FP execution pipeline is further configured to perform a second FP operation on a second FP operand provided by the register file; wherein the first normalization unit is further configured to normalize the second FP operand provided by the register file; and wherein in response to detecting that the second FP operand is a normal, the first normalization unit is configured to discard the normalized second FP operand.</p><p id="p-0015" num="0014">In a second implementation form of the system according to the second aspect or any preceding implementation form of the second aspect, wherein the FP execution pipeline comprises one of a FP addition execution pipeline, a FP multiplication pipeline, an FP division pipeline, an FP square-root or generalized root pipeline, an FP exponential pipeline, an FP power pipeline, or an FP logarithm pipeline, or any other operation or instruction on a floating-point operand.</p><p id="p-0016" num="0015">In a third implementation form of the system according to the second aspect or any preceding implementation form of the second aspect, further comprising: a second FP execution pipeline operatively coupled to the register file and the instruction dispatch, the second FP execution pipeline configured to perform a third FP operation on a third FP operand provided by the register file, the second FP execution pipeline comprising a plurality of execution units; and a second normalization unit operatively coupled to the register file, the second FP execution pipeline, and the instruction dispatch, the second normalization unit configured to normalize the third FP operand provided by the register file, wherein the second normalization unit is configured to operate in parallel with the second FP execution pipeline, and is further configured to, in response to detecting that the third FP operand is a denormal, assert a second FP execution pipeline busy flag to stall the instruction dispatch of a second subsequent FP operation and to provide the normalized third FP operand to the second FP execution pipeline, the third FP operation and the second subsequent FP operation being of one FP operation type.</p><p id="p-0017" num="0016">In a fourth implementation form of the system according to the second aspect or any preceding implementation form of the second aspect, wherein the second FP execution pipeline is further configured to perform a fourth FP operation on a fourth FP operand provided by the register file; wherein the second normalization unit is further configured to normalize the fourth FP operand provided by the register file; and wherein in response to detecting that the fourth FP operand is a normal, the second normalization unit is configured to discard the normalized fourth FP operand.</p><p id="p-0018" num="0017">In a fifth implementation form of the system according to the second aspect or any preceding implementation form of the second aspect, wherein the first normalization unit is further configured to cause the second normalization unit to assert the second FP execution pipeline busy flag and to provide the normalized third FP operand to the second FP execution pipeline when asserting the first FP execution pipeline busy flag, and wherein the second normalization unit is further configured to cause the first normalization unit to assert the first FP execution pipeline busy flag and to provide the normalized first FP operand to the first FP execution pipeline when asserting the second FP execution pipeline busy flag.</p><p id="p-0019" num="0018">In a sixth implementation form of the system according to the second aspect or any preceding implementation form of the second aspect, further comprising a denormal unit operatively coupled to the first FP execution pipeline, the denormal unit configured to convert a fifth FP operand outputted by the first FP execution pipeline into a denormal.</p><p id="p-0020" num="0019">According to a third aspect, a method implemented by a FP arithmetic unit is provided. The method comprising: receiving, by the FP arithmetic unit, from an instruction dispatch, a first FP operation and a first FP operand; executing, by a first FP execution pipeline of the FP arithmetic unit, the first FP operation with the first FP operand; normalizing, by a first normalization unit of the FP arithmetic unit, the first FP operand in parallel with the executing of the first FP operation; and detecting, by the first normalization unit of the FP arithmetic unit, that the first FP operand is a denormal, and based thereon, asserting, by the first normalization unit of the FP arithmetic unit, a first FP execution pipeline busy flag to stall the instruction dispatch of a first subsequent FP operation, the first FP operation and the first subsequent FP operation being of one FP operation type; and providing, by the first normalization unit of the FP arithmetic unit, the normalized first FP operand to the first FP execution pipeline.</p><p id="p-0021" num="0020">In a first implementation form of the method according to the third aspect, further comprising: receiving, by the FP arithmetic unit, from the instruction dispatch, a second FP operation and a second FP operand; executing, by the first FP execution pipeline of the FP arithmetic unit, the second FP operation with the second FP operand; normalizing, by the first normalization unit of the FP arithmetic unit, the second FP operand in parallel with the executing of the second FP operation; and detecting, by the first normalization unit of the FP arithmetic unit, that the first FP operand is a normal, and based thereon, discarding the normalized second FP operand.</p><p id="p-0022" num="0021">In a second implementation form of the method according to the third aspect or any preceding implementation form of the third aspect, further comprising: receiving, by the FP arithmetic unit, from the instruction dispatch, a third FP operation and a third FP operand; executing, by a second FP execution pipeline of the FP arithmetic unit, the third FP operation with the third FP operand; normalizing, by a second normalization unit of the FP arithmetic unit, the third FP operand in parallel with the executing of the third FP operation; and detecting, by the second normalization unit of the FP arithmetic unit, that the third FP operand is a denormal, and based thereon, asserting, by the second normalization unit of the FP arithmetic unit, a second FP execution pipeline busy flag to stall the instruction dispatch of a second subsequent FP operation, the third FP operation and the second subsequent FP operation being of one FP operation type; and providing, by the second normalization unit of the FP arithmetic unit, the normalized second FP operand to the second FP execution pipeline.</p><p id="p-0023" num="0022">In a third implementation form of the method according to the third aspect or any preceding implementation form of the third aspect, further comprising: receiving, by the FP arithmetic unit, from the instruction dispatch, a fourth FP operation and a fourth FP operand; executing, by the second FP execution pipeline of the FP arithmetic unit, the fourth FP operation with the fourth FP operand; normalizing, by the second normalization unit of the FP arithmetic unit, the fourth FP operand in parallel with the executing of the fourth FP operation; and detecting, by the second normalization unit of the FP arithmetic unit, that the fourth FP operand is a normal, and based thereon, discarding the normalized fourth FP operand.</p><p id="p-0024" num="0023">In a fourth implementation form of the method according to the third aspect or any preceding implementation form of the third aspect, further comprising, when detecting that the first FP operand is a denormal: asserting, by the second normalization unit of the FP arithmetic unit, the second FP execution pipeline busy flag to stall the instruction dispatch of a subsequent FP operating having the same FP operation type as the third FP operation; and providing, by the second normalization unit of the FP arithmetic unit, the normalized second FP operand to the second FP execution pipeline.</p><p id="p-0025" num="0024">In a fifth implementation form of the method according to the third aspect or any preceding implementation form of the third aspect, further comprising converting, by a denormal unit of the FP arithmetic unit, a sixth FP operand outputted by the first FP execution pipeline to the denormal FP number unit.</p><p id="p-0026" num="0025">In a sixth implementation form of the method according to the third aspect or any preceding implementation form of the third aspect, the first FP operation comprising one of a FP addition operation or a FP multiplication operation.</p><p id="p-0027" num="0026">In a seventh implementation form of the method according to the third aspect or any preceding implementation form of the third aspect, the first subsequent FP operation and the first FP operation are of the same operation type.</p><p id="p-0028" num="0027">An advantage of a preferred embodiment is that the processing of operands of a FP operation is performed in parallel. Therefore, additional processing associated with denormals is incurred only when at least one of the operands of the FP operation is a denormal. If none of the operands are denormals, then processing associated with denormal processing is not incurred.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0029" num="0028">For a more complete understanding of the present disclosure, and the advantages thereof, reference is now made to the following descriptions taken in conjunction with the accompanying drawings, in which:</p><p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. <b>1</b>A</figref> illustrates a single precision floating-point number in the IEEE 754 format;</p><p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. <b>1</b>B</figref> illustrates a double precision floating-point number in the IEEE 754 format;</p><p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates a number range of values representable by a single precision floating-point number in the IEEE 754 standard;</p><p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates a prior art floating-point arithmetic unit;</p><p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. <b>4</b></figref> illustrates an example floating-point arithmetic unit according to example embodiments presented herein;</p><p id="p-0035" num="0034"><figref idref="DRAWINGS">FIGS. <b>5</b>A-<b>5</b>F</figref> illustrate a sequence of floating-point arithmetic unit block diagrams highlighting the execution of a first example sequence of floating-point instructions with some denormal operands according to example embodiments presented herein;</p><p id="p-0036" num="0035"><figref idref="DRAWINGS">FIGS. <b>6</b>A-<b>6</b>I</figref> illustrate a sequence of floating-point arithmetic unit block diagrams highlighting the execution of a second example sequence of floating-point instructions with some denormal operands according to example embodiments presented herein;</p><p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. <b>7</b></figref> illustrates a flow diagram of example operations occurring in a floating-point arithmetic unit that is capable of processing denormal inputs without incurring additional latency associated with the processing of denormals according to example embodiments presented herein; and</p><p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. <b>8</b></figref> illustrates a block diagram of a computing system that may include the methods and apparatus disclosed herein.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0006" level="1">DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENTS</heading><p id="p-0039" num="0038">The structure and use of disclosed embodiments are discussed in detail below. It should be appreciated, however, that the present disclosure provides many applicable concepts that can be embodied in a wide variety of specific contexts. The specific embodiments discussed are merely illustrative of specific structure and use of embodiments, and do not limit the scope of the disclosure.</p><p id="p-0040" num="0039"><figref idref="DRAWINGS">FIG. <b>1</b>A</figref> illustrates a single precision floating-point number <b>100</b> in the IEEE 754 format. Single precision floating-point number <b>100</b> is 32 bits long with a 1-bit sign <b>105</b>, an 8-bit exponent <b>107</b>, and a 23-bit mantissa <b>109</b>. There is an implicit &#x2018;1&#x2019; as the leading bit of mantissa <b>109</b> when the floating-point number is normal. <figref idref="DRAWINGS">FIG. <b>1</b>B</figref> illustrates a double precision floating-point number <b>120</b> in the IEEE 754 format. Double precision floating point number <b>120</b> is 64 bits long with a 1-bit sign <b>125</b>, an 11-bit exponent <b>127</b>, and a 52-bit mantissa <b>129</b>, with an implicit &#x2018;1&#x2019; as the leading bit of mantissa <b>129</b> when the floating-point number is a normal. A smallest value representable with single precision floating-point number <b>100</b> is +/&#x2212;2<sup>&#x2212;126</sup>. For double precision floating-point number <b>150</b>, the smallest representable value is +/&#x2212;2<sup>&#x2212;1022</sup>.</p><p id="p-0041" num="0040">Denormals are floating-point values where the leading bit of the mantissa is assumed to be a &#x2018;0&#x2019; rather than a &#x2018;1&#x2019;. In the IEEE 754 standard, denormals are indicated by a zero in the exponent field and a non-zero mantissa field. The value of a denormal is expressible as:</p><p id="p-0042" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>(&#x2212;1)<sup>S</sup>(0&#xb7;M)2<sup>&#x2212;126</sup>(single precision)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0043" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>(&#x2212;1)<sup>S</sup>(0&#xb7;M)2<sup>&#x2212;1022</sup>(double precision)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0044" num="0000">where S is the value of the sign field, and M is the value of the mantissa field. The IEEE 754 standard uses denormals to fill in the gap between zero and the smallest normalized floating-point number. The denormals are also used to provide a gradual underflow to zero.</p><p id="p-0045" num="0041"><figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates a number range <b>200</b> of values representable by a single precision floating-point number in the IEEE 754 standard. As shown in <figref idref="DRAWINGS">FIG. <b>2</b></figref>, using normalized values, the range of positive values is from +2<sup>&#x2212;126 </sup>to +2<sup>127 </sup>(shown as range <b>205</b>) and the range of negative values is from &#x2212;2<sup>127 </sup>to &#x2212;2<sup>&#x2212;126 </sup>(shown as range <b>207</b>). A positive overflow situation occurs with any positive number greater than +2<sup>127</sup>. Similarly, any negative number lesser than &#x2212;2<sup>127 </sup>results in a negative overflow situation.</p><p id="p-0046" num="0042">Denormals represent some of the values that are more positive than zero but less than the smallest values representable by normalized floating-point values (shown as range <b>209</b> for positive values and range <b>211</b> for negative values). Underflow is said to occur when the exact result of an operation is nonzero, but with an absolute value that is smaller than the smallest normalized floating point number. Therefore, denormals represent values in positive underflow (a floating point number in range <b>209</b>) and negative underflow (a floating point number in range <b>211</b>) conditions.</p><p id="p-0047" num="0043">A superscalar processor leverages instruction level parallelism to allow more work to be performed at the same clock rate. A superscalar processor executes more than one instruction at the same time by having multiple floating-point execution units, with each floating-point execution unit potentially be pipelined. A pipelined floating-point execution unit includes multiple stages that each performs a fraction of the work of the floating-point execution unit in totality. As an example, in a pipelined floating-point execution unit with three stages, an instruction to be executed in the floating-point execution unit is broken into three tasks with each task being associated with one of the three stages. In order for the instruction to complete, all three stages of the pipeline have to complete. As one stage completes its task, and provides information the next stage in the pipeline. However, instead of becoming idle, the stage that just completed is provided with a new task from a new instruction and remains busy by executing the new task. Therefore, multiple instructions may be executed in a single clock cycle. Hence, computational performance is improved.</p><p id="p-0048" num="0044">The handling of denormals requires more processing than typical normal floating-point numbers. Typically, a denormal would be normalized, which involves detecting the leading zeros and removing the leading zeros, prior to undergoing the processing of the typical normal floating-point number. The normalization process usually requires a combination of leading zeros counting and left-shifting of the mantissa. Furthermore, the exponent must be adjusted by the leading zeros count, implying the inclusion of an adder in the exponent path.</p><p id="p-0049" num="0045">There are two conditions where a floating-point functional unit (a functional unit designed to operate on floating-point numbers) has to handle when it comes to denormals:<ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0046">Input denormals&#x2014;denormals that are at the input of the floating-point functional unit and must be processed by the stages in the floating-point functional unit.</li>        <li id="ul0002-0002" num="0047">Output denormals&#x2014;denormals that are produced by the stages as a result of an arithmetic computation (e.g., subtraction of two floating-point values that are almost equal to one another) and may be written to register files, stored in memory, or forward back to inputs of the stages.</li>    </ul>    </li></ul></p><p id="p-0050" num="0048">Prior art techniques exist for handling input denormals. They include:<ul id="ul0003" list-style="none">    <li id="ul0003-0001" num="0000">    <ul id="ul0004" list-style="none">        <li id="ul0004-0001" num="0049">Forcing all denormal inputs to software routines that will provide needed processing. This is referred to as traps. However, software routines are extremely slow compared to hardware solutions.</li>        <li id="ul0004-0002" num="0050">Stalling the dispatch of instructions with denormal input so that normalization can take place. A prenormalization stall may be introduced, which prevents the instruction dispatcher from dispatching instructions, resulting in a significant performance slowdown.</li>        <li id="ul0004-0003" num="0051">Providing support for gross underflow situations in hardware but force other underflow situations to software. However, software routines are extremely slow compared to hardware solutions. Also, hardware support for gross underflow situations may be complex, add latency, and be difficult to verify.</li>        <li id="ul0004-0004" num="0052">Always normalize all inputs in the execution pipeline. The performance of the float-point execution pipeline is penalized for all floating-point operations, even those without denormal inputs.</li>        <li id="ul0004-0005" num="0053">Modifying the arithmetic units of the floating-point execution pipelines to natively handle all denormals. Again, the delay associated with the floating-point execution pipelines is increased, leading to lower clock rates. Furthermore, the complexity of the floating-point execution pipelines is increased, leading to greater difficulty in functional verification.</li>    </ul>    </li></ul></p><p id="p-0051" num="0054">Prior art techniques also exist for handling output denormals. They include:<ul id="ul0005" list-style="none">    <li id="ul0005-0001" num="0000">    <ul id="ul0006" list-style="none">        <li id="ul0006-0001" num="0055">Stalling the floating-point execution pipelines (i.e., a back-end stall). Significant impact on latency is incurred.</li>        <li id="ul0006-0002" num="0056">Adding a right shift register at the end of the floating-point execution pipelines as an output denormalizer. Significant impact on latency is incurred.</li>        <li id="ul0006-0003" num="0057">Sending the result (of the floating-point operation) to another unit of the pipeline for denormalization or feedback to the same floating-point execution pipelines for denormalization. Significant impact on latency is incurred.</li>        <li id="ul0006-0004" num="0058">Preventing output denormals, e.g., with a leading zero anticipator (LZA) mask.<br/>Although this technique can handle output denormals with less latency than the previous prior-art approaches, if the output denormal is forwarded to another floating-point execution pipeline for immediate use, the output denormal (now an input denormal in another floating-point execution pipeline) will require input normalization.</li>    </ul>    </li></ul></p><p id="p-0052" num="0059"><figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates a prior art floating-point arithmetic unit <b>300</b>. Floating-point arithmetic unit <b>300</b> includes an instruction issue queue <b>305</b> that stores instructions for subsequent execution. Instruction issue queue <b>305</b> may enable out of order execution, where instructions may be executed in a different order from how they are stored in instruction issue queue <b>305</b>. The order of execution may be dependent upon data dependencies, for example. Operands of the instructions may be provided to a floating-point register file <b>309</b>, which stores the operands before or after execution. Depending on the instruction being executed, contents of registers of floating-point register file <b>309</b> are provided to a bypass network <b>313</b>, which allows the operands to be provided to a floating-point execution pipeline corresponding to the instruction being executed.</p><p id="p-0053" num="0060">As shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, floating-point arithmetic unit <b>300</b> includes two floating-point execution pipelines, a floating point addition pipeline <b>315</b> and a floating point multiply pipeline <b>321</b>. Other implementations of floating-point arithmetic unit <b>300</b> may have different numbers of floating-point execution pipelines.</p><p id="p-0054" num="0061">As shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, floating-point addition pipeline <b>315</b> includes two pipelined stages <b>317</b> and <b>319</b>, while floating-point multiply pipeline <b>321</b> includes three pipelined stages <b>323</b>, <b>325</b>, and <b>327</b>. Output of pipelines <b>315</b> and <b>321</b> are written back to floating-point register file <b>309</b>. Output of pipelines <b>315</b> and <b>321</b> may also be forwarded to bypass network <b>313</b> if the output is used immediately for other instructions. Furthermore, the outputs of pipeline <b>315</b> and <b>321</b> may be stored to memory through a floating-point store pipeline <b>329</b> if the output is not immediately used for other instructions.</p><p id="p-0055" num="0062">Registers (such as registers <b>307</b>, <b>311</b>, and <b>314</b>, as well as registers between stages of pipelines <b>315</b> and <b>321</b>) may be used to synchronize the operation of the various components of floating-point arithmetic unit <b>300</b> to a clock.</p><p id="p-0056" num="0063">As shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, if input denormals are provided to pipelines <b>315</b> or <b>321</b>, pipelines <b>315</b> or <b>321</b> may use any of the prior art techniques discussed above for handling the input denormals before pipelines <b>315</b> and <b>321</b> processes the floating-point input. Similarly, if output denormals are output by pipelines <b>315</b> or <b>321</b>, pipelines <b>315</b> or <b>321</b> may use any of the prior art techniques discussed above for handling the output denormals before outputting the output denormals to floating-point store pipeline <b>329</b>, floating-point register file <b>309</b>, or bypass network <b>313</b>.</p><p id="p-0057" num="0064">According to an example embodiment, methods and apparatus are provided that enable the computation of arithmetic operations with denormal inputs in a floating-point execution pipeline of a floating-point arithmetic unit without incurring additional pipeline latency associated with the processing of the denormals to the processing of normal floating-point operands. If denormal values are rarely encountered in well-written code, the floating-point execution pipelines should not be designed such that they incur additional latency due to denormal normalization. Doing so would penalize the most commonly occurring cases to handle a small number of rarely encountered cases. As an example, denormal normalization typically consumes &#x2153; to &#xbd; of a clock cycle for the leading zero detection and left-shift operations (for up to 53 bits in the double-precision floating-point format). Therefore, adding denormal normalization to floating-point execution pipelines may result in a one clock-cycle penalty (due to the addition of an additional pipeline stage dedicated to denormal normalization). In a two-stage floating-point execution pipeline, this will lead to a 50% penalty, while a three-stage floating-point execution pipeline incurs a 33% penalty.</p><p id="p-0058" num="0065">According to an example embodiment, the denormal normalization operation is performed in a pipeline dedicated to normalization of denormals that executes in parallel to the floating-point execution pipeline used for processing normal floating-point operands. The normalized denormals (normalized in the parallel pipeline) are then rescheduled and take place of the denormals in the normal floating-point execution pipeline (which have not yet been executed), completing the processing of the operands.</p><p id="p-0059" num="0066">In an embodiment, in a situation where a floating-point operation involves at least one denormal operand, the issuing of a subsequent floating-point operation of the same operation type (e.g., a floating-point add if the floating-point operation involving a denormal operand is a floating-point add, a floating-point multiply if the floating-point operation involving a denormal operand is a floating-point multiply, etc.) for the next clock cycle is blocked. Other types of floating-point operations may include floating-point divide, floating-point square-root or generalized root, floating-point exponential, floating-point power, floating-point logarithm, and so on. Although the discussion focusses on floating-point addition and floating-point multiplication operations, the example embodiments presented herein are operable with any floating-point operation type. Therefore, the focus on floating-point addition and multiplication should not be construed as being limiting to the scope of the example embodiments.</p><p id="p-0060" num="0067">However, if the floating-point arithmetic unit has multiple floating-point execution pipelines configured to process the same type of floating-point operation, then it may not be necessary to block the subsequent floating-point operation if there is one or more floating-point execution pipelines is not currently processing a floating-point operation involving a denormal operand. As an example, if the floating-point arithmetic unit includes two floating-point add pipelines, and a first of the floating-point add pipelines is processing a floating-point add with a denormal operand, it is not necessary to block a subsequent floating-point add in the next clock cycle as long a second of the floating-point add pipelines is not also processing a floating-point add.</p><p id="p-0061" num="0068">In an embodiment, first stage of each floating-point execution pipeline operates under an assumption that all of the input operands are normal floating-point values. This applies to floating-point execution pipelines that are serviced by an issue queue.</p><p id="p-0062" num="0069">In an embodiment, the denormal normalization operation is performed in parallel to a first stage of all floating-point execution pipelines in the floating-point arithmetic unit. The unit performing denormal normalization, referred to herein as a denormal normalization unit (DNU), is configured to normalize each source operand that is a denormal.</p><p id="p-0063" num="0070">In an embodiment, in a situation if all source operands of a floating-point operation are normal, the results of the DNU are ignored. Instead, the second stage of the floating-point execution pipeline (and subsequent stages if present) operates on the input operands as processed by the first stage of the floating-point execution pipeline. Therefore, no additional latency is incurred for normal operands.</p><p id="p-0064" num="0071">In an embodiment, in situations where at least one of the operands of the floating-point execution pipeline is a denormal, the DNU, dedicated to normalizing denormals, normalizes the denormal operand(s). While, occurring in parallel, the first stage of floating-point execution pipeline processes the operands as if the operands are in the normal floating-point format (although at least one of the operands is a denormal). Then, once the DNU completes the normalization processing, the normalized operand(s) are provided to the floating-point execution pipeline.</p><p id="p-0065" num="0072">In an embodiment, the output of the DNU is provided to the first stage of the floating-point execution pipeline, where the operands (now normalized) are processed as if the operands had never been denormals.</p><p id="p-0066" num="0073">In an embodiment, to prevent a floating-point operation of the same type from being issued and colliding with the processing of the normalized operands, a flag (or status bit) is asserted to a specified value to block the issue of a subsequent floating-point operation of the same floating-point operation type to the floating-point execution pipeline. The flag (or status bit) may be implemented using a single bit. As an example, the flag (or status bit) is set to a binary &#x2018;1&#x2019; to block the issue of the subsequent floating-point operation of the same type to the floating-point execution pipeline. The reverse value (i.e., a binary &#x2018;0&#x2019;) may alternatively be used to block the issue of the subsequent floating-point operation. A multi-bit flag or indicator may be used in place of the flag or status bit.</p><p id="p-0067" num="0074">In an embodiment, the flag (or status bit) is set to the specified value for only one clock cycle to block the issue of the subsequent floating-point operation of the same type to the floating-point execution pipeline for one clock cycle. After which time, the flag (or status bit) may be cleared.</p><p id="p-0068" num="0075">As discussed previously, in a situation where the floating-point arithmetic unit has multiple floating-point execution pipelines configured to process the same floating-point operation of a single type, only the flag (or status bit) associated with the floating-point execution pipeline that received the denormal operand is asserted. In other words, each floating-point execution pipeline has its own flag (or status bit) and they are independently controlled and set or reset as needed.</p><p id="p-0069" num="0076">In an embodiment, the processing of the denormal source operand(s) performed by the first stage of the floating-point execution pipeline that occurred in parallel to the processing performed by the DNU is discarded. Because the floating-point execution pipeline processed the operands as if they were in normal floating-point format (although at least one of the operands was a denormal), the results may be incorrect. Therefore, any results produced by the first stage of the floating-point execution pipeline are discarded.</p><p id="p-0070" num="0077">In an embodiment, as related to output denormals, output denormals are generated only when results are to be written back to the floating-point register file or the floating-point store. If the output of the floating-point execution pipeline is immediately used for another floating-point operation, the output is retained in an intermediate floating-point format to prevent the need to normalize denormals in a subsequent operation. Latency in a floating-point execution pipeline is saved by never generating output denormals (i.e., denormalizing floating-point values) prior to forwarding. Instead, output denormals are generated only during register writebacks or floating-point stores.</p><p id="p-0071" num="0078"><figref idref="DRAWINGS">FIG. <b>4</b></figref> illustrates an example floating-point arithmetic unit <b>400</b>. Floating-point arithmetic unit <b>400</b> includes an instruction issue queue <b>405</b> that stores instructions for subsequent execution. Instruction issue queue <b>405</b> may enable out of order execution, where instructions may be executed in a different order from how they are stored in instruction issue queue <b>405</b>. The order of execution may be dependent upon data dependencies, for example. Operands of the instructions may be provided to a floating-point register file <b>407</b>, which stores the operands before or after execution. Depending on the instruction being executed, contents of registers of floating-point register file <b>407</b> are provided to a bypass network <b>409</b>, which allows the operands to be provided to a floating-point execution pipeline corresponding to the instruction being executed.</p><p id="p-0072" num="0079">Floating-point arithmetic unit <b>400</b> includes two floating-point execution pipelines, a floating-point add pipeline <b>411</b> and a floating-point multiply pipeline <b>413</b>. Although floating-point arithmetic unit <b>400</b> is shown with two floating-point execution pipelines, other implementations of floating-point arithmetic unit <b>400</b> may have different numbers of floating-point execution pipelines. As an example, an alternate implementation of floating-point arithmetic unit <b>400</b> includes three floating-point execution units, each implementing a different floating-point operation. As another example, an alternate implementation of floating-point arithmetic unit <b>400</b> includes multiple copies of the same floating-point execution unit (as an example, two floating-point add units and two floating-point multiply units). Other combinations of floating-point units, floating-point operation types, and numbers of floating-point execution units are possible.</p><p id="p-0073" num="0080">As shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref>, floating-point add pipeline <b>411</b> includes two pipelined stages, while floating-point multiply pipeline <b>413</b> includes three pipelined stages. Other numbers of pipelined stages are possible.</p><p id="p-0074" num="0081">Floating-point arithmetic unit <b>400</b> also includes DNUs <b>415</b> and <b>417</b>, one DNU for each floating-point execution pipeline. DNU <b>415</b> is associated with floating-point add pipeline <b>411</b> and DNU <b>417</b> is associated with floating-point multiply pipeline <b>413</b>. As shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref>, a DNU and its associated floating-point execution pipeline are provided the same operands. As an example, floating-point add pipeline <b>411</b> and DNU <b>415</b> are provided the same operands, and floating-point multiply pipeline <b>413</b> and DNU <b>415</b> are provided the same operands.</p><p id="p-0075" num="0082">DNUs <b>415</b> and <b>417</b> each includes a single stage that performs denormal normalization of operands provided by bypass network. As discussed previously, the DNUs operate in parallel with their associated floating-point execution pipeline, and perform denormal normalization on the provided operands. The DNUs may perform denormal normalization on the provided operands irrespective of the operands being denormals or not. If none of the operands provided to a DNU are denormals, the results of the denormal normalization are discarded, and the floating-point execution pipeline associated with the DNU proceeds with its processing of the provided operands (which are the same as the operands provided to the DNU) as usual.</p><p id="p-0076" num="0083">If at least one of the operands provided to a DNU is a denormal, the normalized operands are provided to the first stage of the associated floating-point execution pipeline and the associated floating-point execution pipeline processes the normalized operands as if the operands were provided by bypass network <b>409</b>. An example operation of a DNU is as follows:<ul id="ul0007" list-style="none">    <li id="ul0007-0001" num="0000">    <ul id="ul0008" list-style="none">        <li id="ul0008-0001" num="0084">In parallel to the associated floating-point execution pipeline, the DNU checks each operand and normalizes each denormal operand.</li>        <li id="ul0008-0002" num="0085">If all operands are normal, then the results of the DNU are not used. Instead, the second stage (and any subsequent stage) processes the operands as provided by bypass network <b>409</b>.</li>        <li id="ul0008-0003" num="0086">If any operand is denormal,        <ul id="ul0009" list-style="none">            <li id="ul0009-0001" num="0087">A pipeline valid bit from the first stage of the associated floating-point execution pipeline and the second stage of the associated floating-point execution pipeline is set to indicate that the pipeline is not valid and halt propagation of the results of the first stage.</li>            <li id="ul0009-0002" num="0088">All denormal operands are normalized by the DNU and forwarded to the first stage of the associated floating-point execution pipeline.</li>            <li id="ul0009-0003" num="0089">A flag (or status bit) <b>419</b> or <b>421</b> associated with the DNU is set to indicate to issue queue <b>405</b> to stall the issue of a floating-point operation of the same operation type as the one associated with the DNU. As shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref>, floating-point add busy flag (FADD E1 BUSY FLAG) <b>419</b> is associated with DNU <b>415</b>, while floating-point multiply busy flag (FMUL E1 BUSY FLAG) <b>421</b> is associated with DNU <b>417</b>. Hence, if FADD E1 BUSY FLAG <b>419</b> is set to the specified value, issue queue <b>405</b> will stall floating-point add operations. Similarly, if FMUL E1 BUSY FLAG <b>421</b> is set to the specified value, issue queue <b>405</b> will stall floating-point multiply operations. As an example, the flag (or status bit) is set to stall the issue of a floating-point operation of the same operation type as the one associated with the DNU.</li>        </ul>        </li>    </ul>    </li></ul></p><p id="p-0077" num="0090">In an embodiment, floating-point arithmetic unit <b>400</b> also includes a denormalize unit <b>423</b>. Denormalize unit <b>423</b> is configured to convert a normalized floating-point value in an intermediate or extended exponent format into a denormal, provided that the normalized floating-point value is representable as a denormal and does not underflow to zero. Denormalize unit <b>423</b> receives as input, floating-point values from the floating-point execution pipelines and denormalizes any floating-point value meeting the underflow condition when the floating-point value is to be written back to floating-point register file <b>407</b> or floating-point store <b>425</b>.</p><p id="p-0078" num="0091">However, outputs of the floating-point execution pipelines, if immediately being used in a subsequent floating-point operations and not being written back to floating-point register file <b>409</b> or floating-point store <b>425</b>, are provided to bypass network <b>409</b> without being denormalized (even if they meet the underflow condition). Hence, latency associated with denormalizing floating-point values is saved.</p><p id="p-0079" num="0092">In an embodiment, floating-point exceptions, such as overflow, underflow, etc., are set as necessary during denormalization and writebacks to floating-point register file <b>407</b> or floating point store <b>425</b>.</p><p id="p-0080" num="0093">In an embodiment, in order to prevent having to normalize denormals or denormalize floating-point values that meet the underflow condition, an intermediate representation of floating-point values with greater precision is used in bypass network <b>409</b> and floating-point execution pipelines. As an example, the floating-point execution pipelines and bypass network <b>409</b> operate on normalized data with exponents in an extended exponent format. The extended exponent format is a format in which the exponent field is extended by at least one bit. As an example, the most significant bit (MSB) of the exponent is replaced by n bits: [E<sub>MSB</sub>, &#x2dc;E<sub>MSB</sub>, . . . , &#x2dc;E<sub>MSB</sub>].</p><p id="p-0081" num="0094">Floating-point arithmetic unit <b>400</b>, as shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref>, presents an example implementation of a floating-point arithmetic unit according to the example embodiments presented herein. Other configurations are possible. As an example, an alternative floating-point arithmetic unit may have a floating-point execution pipeline configured to perform rounding operations, division operations, square-root or generalized root operations, exponential operations, power operations, logarithm operations, etc. As another example, an alternative floating-point arithmetic unit may have more than one floating-point execution pipeline configured to perform the same operation, e.g., two floating-point add pipelines and one floating-point multiply pipeline. Other values and configurations are possible.</p><p id="p-0082" num="0095"><figref idref="DRAWINGS">FIGS. <b>5</b>A-<b>5</b>F</figref> illustrate a sequence of floating-point arithmetic unit block diagrams highlighting the execution of a first example sequence of floating-point instructions with some denormal operands.</p><p id="p-0083" num="0096"><figref idref="DRAWINGS">FIG. <b>5</b>A</figref> illustrates a first floating-point arithmetic unit block diagram <b>500</b>. First floating-point arithmetic unit block diagram <b>500</b> displays a floating-point arithmetic unit with an issue queue <b>505</b>, a floating-point register file <b>506</b>, a floating-point add pipeline <b>507</b>, a first DNU <b>508</b> that is associated with floating-point add pipeline <b>507</b>, a floating-point multiply pipeline <b>509</b>, a second DNU <b>510</b> that is associated with floating-point multiply pipeline <b>509</b>, a floating-point add busy flag <b>511</b>, a floating-point multiply busy flag <b>512</b>, and a pick <b>513</b> pointing to a next floating-point instruction to be dispatched. As shown in <figref idref="DRAWINGS">FIG. <b>5</b>A</figref>, no floating-point instructions have been dispatched. However, pick <b>513</b> is pointing at floating-point instruction &#x201c;FADD f1, f4, f5&#x201d; with both operands f4 and f5 being bolded and underlined to indicate that operands f4 and f5 being denormals.</p><p id="p-0084" num="0097"><figref idref="DRAWINGS">FIG. <b>5</b>B</figref> illustrates a second floating-point arithmetic unit block diagram <b>515</b>. Second floating-point arithmetic unit block diagram <b>515</b> displays the floating-point arithmetic unit one clock cycle after first floating-point arithmetic unit block diagram <b>500</b> shown in <figref idref="DRAWINGS">FIG. <b>5</b>A</figref>. After one clock cycle, floating-point instruction &#x201c;FADD f1, f4, f5&#x201d; has been issued and operands have been loaded into registers <b>516</b> and <b>517</b> for loading into the first stages of floating-point add pipeline <b>507</b> and first DNU <b>508</b>. Also, pick <b>513</b> has now moved to floating-point instruction &#x201c;FADD f2, f6, f7&#x201d; with both operands f6 and f7 being normal floating-point values.</p><p id="p-0085" num="0098"><figref idref="DRAWINGS">FIG. <b>5</b>C</figref> illustrates a third floating-point arithmetic unit block diagram <b>520</b>. Third floating-point arithmetic unit block diagram <b>520</b> displays the floating-point arithmetic unit one clock cycle after second floating-point arithmetic unit block diagram <b>515</b> shown in <figref idref="DRAWINGS">FIG. <b>5</b>B</figref>. After one clock cycle, the first stage of floating-point add pipeline <b>507</b> has processed operands f4 and f5 (although they were denormals). Also, first DNU <b>508</b> has normalized operands f4 and f5. Because operands f4 and f5 were denormals, floating-point add busy flag <b>511</b> was set to the specified value to stall issue queue <b>505</b> from issuing floating-point add operations. FADD E1 Busy flag <b>511</b> being set now blocks the transfer of floating-point operands f6 and f7 in register <b>516</b> into the first stages of floating-point pipeline <b>507</b>. Instead, outputs of first DNU <b>508</b> (the normalized operands f4 and f5) are provided to the first stage of floating-point add pipeline <b>507</b>. Pick <b>513</b> has now moved to floating-point instruction &#x201c;FMUL f3, f8, f9&#x201d; with both operands f8 and f9 being normal floating-point values.</p><p id="p-0086" num="0099"><figref idref="DRAWINGS">FIG. <b>5</b>D</figref> illustrates a fourth floating-point arithmetic unit block diagram <b>525</b>. Fourth floating-point arithmetic unit block diagram <b>525</b> displays the floating-point arithmetic unit one clock cycle after third floating-point arithmetic unit block diagram <b>520</b> shown in <figref idref="DRAWINGS">FIG. <b>5</b>C</figref>. After one clock cycle, the first stage of floating-point add pipeline <b>507</b> has processed normalized operands f4 and f5. Additionally, floating-point add busy flag <b>511</b> has been cleared and it therefore no longer inhibits operands f6 and f7 from being provided to the first stages of floating-point add pipeline <b>507</b> and first DNU <b>508</b> in the next clock cycle. Similarly, memories <b>526</b> and <b>527</b> hold operands f8 and f9 of floating-point instruction &#x201c;FMUL f3, f8, f9&#x201d;.</p><p id="p-0087" num="0100"><figref idref="DRAWINGS">FIG. <b>5</b>E</figref> illustrates a fifth floating-point arithmetic unit block diagram <b>530</b>. Fifth floating-point arithmetic unit block diagram <b>530</b> displays floating-point arithmetic unit one clock cycle after fourth floating-point arithmetic unit block diagram <b>525</b> shown in <figref idref="DRAWINGS">FIG. <b>5</b>D</figref>. After one clock cycle, the second stage of floating-point add pipeline <b>507</b> has processed the output of the first stage of floating-point add pipeline <b>507</b>. The first stage of floating-point add pipeline <b>507</b> has processed operands f6 and f7. Because operands f6 and f7 are normals, the processing of first DNU <b>508</b> are not utilized. Additionally, the first stage of floating-point multiply pipeline <b>509</b> has processed operands f8 and f9. Because operands f8 and f9 are normals, the processing of second DNU <b>510</b> are not utilized.</p><p id="p-0088" num="0101"><figref idref="DRAWINGS">FIG. <b>5</b>F</figref> illustrates a sixth floating-point arithmetic unit block diagram <b>535</b>. Sixth floating-point arithmetic unit block diagram <b>535</b> displays floating-point arithmetic unit one clock cycle after fifth floating-point arithmetic block diagram <b>530</b> shown in <figref idref="DRAWINGS">FIG. <b>5</b>E</figref>. After one clock cycle, the second stage of floating-point add pipeline <b>507</b> has processed the output of the first stage of floating-point add pipeline <b>507</b>. The second stage of the floating-point multiply pipeline <b>509</b> has processed the output of the first stage of the floating-point multiply pipeline <b>509</b>. Additional processing may occur in subsequent clock cycles, but are not shown herein.</p><p id="p-0089" num="0102"><figref idref="DRAWINGS">FIGS. <b>6</b>A-<b>6</b>I</figref> illustrate a sequence of floating-point arithmetic unit block diagrams highlighting the execution of a second example sequence of floating-point instructions with some denormal operands.</p><p id="p-0090" num="0103"><figref idref="DRAWINGS">FIG. <b>6</b>A</figref> illustrates a first floating-point arithmetic unit block diagram <b>600</b>. First floating-point arithmetic unit block diagram <b>600</b> displays a floating-point arithmetic unit were components that have similar numbers to the floating-point arithmetic unit shown in <figref idref="DRAWINGS">FIGS. <b>5</b>A-<b>5</b>F</figref> have similar functionality. As shown in <figref idref="DRAWINGS">FIG. <b>6</b>A</figref>, no floating-point instructions have been dispatched. However, pick <b>513</b> is pointing at floating-point instruction &#x201c;FADD f1, f4, f5&#x201d; with both operands f4 and f5 being bolded and underlined to indicate that operands f4 and f5 being denormals.</p><p id="p-0091" num="0104"><figref idref="DRAWINGS">FIG. <b>6</b>B</figref> illustrates a second floating-point arithmetic unit block diagram <b>615</b>. Second floating-point arithmetic unit block diagram <b>615</b> displays the floating-point arithmetic unit one clock cycle after first floating-point arithmetic unit block diagram <b>600</b> shown in <figref idref="DRAWINGS">FIG. <b>6</b>A</figref>. After one clock cycle, floating-point instruction &#x201c;FADD f1, f4, f5&#x201d; has been dispatched and operands have been loaded into registers <b>516</b> and <b>517</b> for loading into the first stages of floating-point add pipeline <b>507</b> and first DNU <b>508</b>. Also, pick <b>513</b> has now moved to floating-point instruction &#x201c;FADD f2, f6, f7&#x201d; with operand f6 being denormal and operand f7 being a normal floating-point value.</p><p id="p-0092" num="0105"><figref idref="DRAWINGS">FIG. <b>6</b>C</figref> illustrates a third floating-point arithmetic unit block diagram <b>620</b>. Third floating-point arithmetic unit block diagram <b>620</b> displays the floating-point arithmetic unit one clock cycle after second floating-point arithmetic unit block diagram <b>615</b> shown in <figref idref="DRAWINGS">FIG. <b>6</b>B</figref>. After one clock cycle, the first stage of floating-point add pipeline <b>507</b> has processed operands f4 and f5 (although they were denormals). Also, first DNU <b>508</b> has normalized operands f4 and f5. Because operands f4 and f5 were denormals, floating-point add busy flag <b>511</b> was set to the specified value to stall issue queue <b>505</b> from issuing floating-point add operations. Furthermore, FADD E1 Busy flag <b>511</b> is set to inhibit to prevent operands f6 and f7 (stored in memories <b>516</b> and <b>517</b>) from being provided to the first stages of floating-point add pipeline <b>507</b> and first DNU <b>508</b> in the next clock cycle. Instead, outputs of first DNU <b>508</b> (the normalized operands f4 and f5) are provided to the first stage of floating-point add pipeline <b>507</b>. Additionally, a pipeline invalid bit from the first stage of floating-point add pipeline <b>507</b> is set to the specified value to indicate that the output of the first stage of floating-point add pipeline <b>507</b> is not valid. Pick <b>513</b> has now changed to not point to the next floating-point instruction because the next floating-point instruction is a floating-point add instruction and floating-point add busy flag <b>511</b> indicates that the next floating-point add instruction should be stalled.</p><p id="p-0093" num="0106"><figref idref="DRAWINGS">FIG. <b>6</b>D</figref> illustrates a fourth floating-point arithmetic unit block diagram <b>625</b>. Fourth floating-point arithmetic unit block diagram <b>625</b> displays the floating-point arithmetic unit one clock cycle after third floating-point arithmetic unit block diagram <b>620</b> shown in <figref idref="DRAWINGS">FIG. <b>6</b>C</figref>. After one clock cycle, the first stage of floating-point add pipeline <b>507</b> has processed normalized operands f4 and f5. Additionally, floating-point add busy flag <b>511</b> has been cleared so it no longer inhibit operands f6 and f7 from being provided to the first stages of floating-point add pipeline <b>507</b> and first DNU <b>508</b> in the next clock cycle. Pick <b>513</b> now indicates that floating-point instruction &#x201c;FADD f3, f8, f9&#x201d; with operand f8 being a normal floating-point value and operand f9 being denormal.</p><p id="p-0094" num="0107"><figref idref="DRAWINGS">FIG. <b>6</b>E</figref> illustrates a fifth floating-point arithmetic unit block diagram <b>630</b>. Fifth floating-point arithmetic unit block diagram <b>630</b> displays floating-point arithmetic unit one clock cycle after fourth floating-point arithmetic unit block diagram <b>625</b> shown in <figref idref="DRAWINGS">FIG. <b>6</b>D</figref>. After one clock cycle, the second stage of floating-point add pipeline <b>507</b> has processed the output of the first stage of floating-point add pipeline <b>507</b>. The first stage of floating-point add pipeline <b>507</b> has processed operands f6 and f7 (although operand f6 is denormal). Because operand f6 is denormal, floating-point add busy flag <b>511</b> was set to the specified value to stall issue queue <b>505</b> from issuing floating-point add operations and inhibits operands f8 and f9 (stored in memories <b>516</b> and <b>517</b>) from being provided to the first stages of floating-point add pipeline <b>507</b> and first DNU <b>508</b> in the next clock cycle. Instead, outputs of first DNU <b>508</b> (the normalized operand f6 and unaltered operand f7) are provided to the first stage of floating-point add pipeline <b>507</b>. Additionally, a pipeline invalid bit from the first stage of floating-point add pipeline <b>507</b> is set to indicate that the output of the first stage of floating-point add pipeline <b>507</b> is not valid. Pick <b>513</b> has now changed to not point to the next floating-point instruction because the next floating-point instruction is a floating-point add instruction and floating-point add busy flag <b>511</b> indicates that the next floating-point add instruction should be stalled.</p><p id="p-0095" num="0108"><figref idref="DRAWINGS">FIG. <b>6</b>F</figref> illustrates a sixth floating-point arithmetic unit block diagram <b>635</b>. Sixth floating-point arithmetic unit block diagram <b>635</b> displays floating-point arithmetic unit one clock cycle after fifth floating-point arithmetic block diagram <b>630</b> shown in <figref idref="DRAWINGS">FIG. <b>6</b>E</figref>. After one clock cycle, the first stage of floating-point add pipeline <b>507</b> has processed the normalized operand f6 and the normal operand f7. Additionally, floating-point add busy flag <b>511</b> has been cleared and so it no longer inhibits operands f6 and f7 from being provided to the first stages of floating-point add pipeline <b>507</b> and first DNU <b>508</b> in the next clock cycle. Pick <b>513</b> has now moved to floating-point instruction &#x201c;FADD f10, f11, f12&#x201d; with both operands f11 and f12 being normal floating-point values.</p><p id="p-0096" num="0109"><figref idref="DRAWINGS">FIG. <b>6</b>G</figref> illustrates a seventh floating-point arithmetic unit block diagram <b>640</b>. Seventh floating-point arithmetic unit block diagram <b>640</b> displays floating-point arithmetic unit one clock cycle after sixth floating-point arithmetic block diagram <b>635</b> shown in <figref idref="DRAWINGS">FIG. <b>6</b>F</figref>. After one clock cycle, the first stage of floating-point add pipeline <b>507</b> has processed operands f8 and f9 (although operand f9 is denormal). Also, first DNU <b>508</b> has normalized operand f9 and left operand f8 unaltered. Because operand f9 was denormal, floating-point add busy flag <b>511</b> was set to stall issue queue <b>505</b> from issuing floating-point add operations and inhibits operands f11 and f12 (stored in memories <b>516</b> and <b>517</b>) from being provided to the first stages of floating-point add pipeline <b>507</b> and first DNU <b>508</b> in the next clock cycle. Instead, outputs of first DNU <b>508</b> (the normalized operands f9 and unaltered f8) are provided to the first stage of floating-point add pipeline <b>507</b>. Additionally, a pipeline invalid bit from the first stage of floating-point add pipeline <b>507</b> is set to indicate that the output of the first stage of floating-point add pipeline <b>507</b> is not valid. The second stage of floating-point add pipeline <b>507</b> processes the output of the first stage of floating-point add pipeline <b>507</b> from the previous clock cycle.</p><p id="p-0097" num="0110"><figref idref="DRAWINGS">FIG. <b>6</b>H</figref> illustrates an eighth floating-point arithmetic unit block diagram <b>645</b>. Eighth floating-point arithmetic unit block diagram <b>645</b> displays floating-point arithmetic unit one clock cycle after seventh floating-point arithmetic block diagram <b>640</b> shown in <figref idref="DRAWINGS">FIG. <b>6</b>G</figref>. After one clock cycle, the first stage of floating-point add pipeline <b>507</b> has processed normalized operand f9 and normal operand f8. Additionally, floating-point add busy flag <b>511</b> has been cleared and so it no longer inhibits operands f11 and f12 from being provided to the first stages of floating-point add pipeline <b>507</b> and first DNU <b>508</b> in the next clock cycle.</p><p id="p-0098" num="0111"><figref idref="DRAWINGS">FIG. <b>6</b>I</figref> illustrates a ninth floating-point arithmetic unit block diagram <b>650</b>. Ninth floating-point arithmetic unit block diagram <b>650</b> displays floating-point arithmetic unit one clock cycle after eighth floating-point arithmetic block diagram <b>645</b> shown in <figref idref="DRAWINGS">FIG. <b>6</b>G</figref>. After one clock cycle, the second stage of floating-point add pipeline <b>507</b> has processed the output of the first stage of floating-point add pipeline <b>507</b>. The first stage of the floating-point add pipeline <b>507</b> has processed normal operands f11 and f12. Additional processing may occur in subsequent clock cycles, but are not shown herein.</p><p id="p-0099" num="0112">According to an example embodiment, methods and apparatus are provided that enable the computation of arithmetic operations with denormal inputs in a floating-point execution pipeline of a vector floating-point arithmetic unit. A major difference between scalar floating-point arithmetic units (such as those discussed above) and vector floating-point arithmetic units is that control flow operates in lockstep fashion in the vector floating-point arithmetic units. In other words, the same processing must be provided for all of the operands of a vector.</p><p id="p-0100" num="0113">In an embodiment, if at least one operand of the vector is detected as a denormal, then all operands must be processed by DNUs. Even if every operand of the vector is normal except for one operand, all operands are processed by DNUs. If a normal operand is processed by a DNU, then it is passed through the DNU unchanged.</p><p id="p-0101" num="0114">In an embodiment, a vector status bit is used to block the issue for the particular instruction type in the issue queue when any operand of the vector is a denormal. When the vector status bit is set to a specified value (e.g., a binary &#x2018;1&#x2019;) then the issue queue is prevented from issuing that instruction type for all operands or elements of the vector. Alternatively, the specified value may be a binary &#x2018;0&#x2019; to prevent the issue queue from issuing that instruction type for all operands of the vector.</p><p id="p-0102" num="0115"><figref idref="DRAWINGS">FIG. <b>7</b></figref> illustrates a flow diagram of example operations <b>700</b> occurring in a floating-point arithmetic unit that is capable of processing denormal inputs without incurring additional latency associated with the processing of denormals. Operations <b>700</b> may be indicative of operations occurring in a floating-point arithmetic that is capable of processing denormal inputs without incurring additional latency associated with the processing of denormals in accordance with example embodiments presented herein.</p><p id="p-0103" num="0116">Operations <b>700</b> begin with the floating-point arithmetic unit receiving operands for a floating-point instruction (block <b>705</b>). As discussed previously, both a floating-point execution pipeline and an associated DNU receive the operands for the floating-point instruction. The floating-point arithmetic unit normalizes the denormal operands (block <b>707</b>) and executes the first stage of the floating-point execution pipeline (block <b>709</b>). As previously presented, the normalization of the denormal operands (block <b>707</b>) and the execution of the first stage of the floating-point execution pipeline (block <b>709</b>) occurs in parallel so that the latency associated with normalizing denormals is hidden. The normalization of the denormal operands occur in the DNU associated with the floating-point execution pipeline executing the floating-point instruction.</p><p id="p-0104" num="0117">Floating-point arithmetic unit performs a check to determine if any of the operands is denormal (block <b>711</b>). If at least one of the operands is denormal, floating-point arithmetic unit asserts a flag (or status bit) to indicate that the floating-point execution pipeline is busy (block <b>713</b>). The assertion of the flag (or status bit) stalls the dispatch of any subsequent floating-point instruction of the same type. Floating-point arithmetic unit provides the normalized operands (as well as the normal operands) to the first stage of the floating-point execution pipeline (block <b>715</b>). Floating-point arithmetic unit clears the flag (or status bit) (block <b>717</b>) and the operation of the floating-point execution pipeline continues (block <b>719</b>). As an example, if subsequent stages of the floating-point execution pipeline are ready to execute, they are allowed to complete.</p><p id="p-0105" num="0118">If none of the operands are denormal (block <b>711</b>), the floating-point arithmetic unit discards the normalized operands produced by the DNU.</p><p id="p-0106" num="0119"><figref idref="DRAWINGS">FIG. <b>8</b></figref> illustrates a block diagram of a computing system <b>800</b> that may include the methods and apparatus disclosed herein. For example, computing system <b>800</b> may include a floating-point arithmetic unit that is capable of processing denormal inputs without incurring additional latency associated with the processing of denormals. The floating-point arithmetic unit may be a scalar floating-point arithmetic unit or a vector floating-point arithmetic unit.</p><p id="p-0107" num="0120">Specific computing systems may utilize all of the components shown or only a subset of the components, and levels of integration may vary from device to device. Furthermore, a computing system may contain multiple instances of a component, such as multiple processing units, processors, memories, transmitters, receivers, etc. The computing system <b>800</b> includes a processing unit (CPU) <b>802</b>, a floating-point arithmetic unit (FPU) <b>804</b>, memory <b>806</b>, and may further include mass storage <b>808</b>, a display adapter <b>810</b>, a network interface <b>812</b>, human interface <b>814</b>. Mass storage <b>808</b>, display adapter <b>810</b>, network interface <b>812</b>, and human interface <b>814</b> may be connected to a bus <b>816</b> or through an I/O interface <b>818</b> connected to bus <b>816</b>.</p><p id="p-0108" num="0121">Mass storage <b>808</b> may comprise any type of non-transitory storage device configured to store data, programs, and other information and to make the data, programs, and other information accessible via bus <b>816</b>. Mass storage <b>808</b> may comprise, for example, one or more of a solid state drive, hard disk drive, a magnetic disk drive, or an optical disk drive.</p><p id="p-0109" num="0122">Display adapter <b>810</b> and I/O interface <b>818</b> provide interfaces to couple external input and output devices to the CPU <b>802</b>. As illustrated, examples of input and output devices include a display coupled the video adapter <b>810</b> and a mouse, keyboard, or printer coupled to human interface <b>814</b>. Other devices may be coupled to CPU <b>802</b>, and additional or fewer interface cards may be utilized. For example, a serial interface such as Universal Serial Bus (USB) (not shown) may be used to provide an interface for an external device.</p><p id="p-0110" num="0123">Computing system <b>800</b> also includes one or more network interfaces <b>812</b>, which may comprise wired links, such as an Ethernet cable, or wireless links to access nodes or different networks. Network interfaces <b>812</b> allow computing system <b>800</b> to communicate with remote units via the networks. For example, network interfaces <b>812</b> may provide wireless communication via one or more transmitters/transmit antennas and one or more receivers/receive antennas. In an embodiment, computing system <b>800</b> is coupled to a local-area network or a wide-area network for data processing and communications with remote devices, such as other processing units, the Internet, or remote storage facilities.</p><p id="p-0111" num="0124">FPU <b>804</b> includes one or more floating-point execution pipelines, and for each floating-point execution pipeline, there is an associated DNU configured to normalize denormals in parallel with the floating-point execution pipeline. FPU <b>804</b> also includes a denormalize unit coupled to the outputs of the floating-point execution pipelines. The denormalize unit denormalizes floating-point values as needed prior to the floating-point values being fedback to a floating-point register file or a floating-point store. An example FPU <b>804</b> is shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref>.</p><p id="p-0112" num="0125">It should be appreciated that one or more steps of the embodiment methods provided herein may be performed by corresponding units or modules. For example, a signal may be transmitted by a transmitting unit or a transmitting module. A signal may be received by a receiving unit or a receiving module. A signal may be processed by a processing unit or a processing module. Other steps may be performed by an executing unit or module, an executing unit or module, a detecting unit or module, an asserting unit or module, a providing unit or module, a converting unit or module, or a normalizing unit or module. The respective units or modules may be hardware, software, or a combination thereof. For instance, one or more of the units or modules may be an integrated circuit, such as field programmable gate arrays (FPGAs) or application-specific integrated circuits (ASICs).</p><p id="p-0113" num="0126">Although the present disclosure and its advantages have been described in detail, it should be understood that various changes, substitutions and alterations can be made herein without departing from the scope of the disclosure as defined by the appended claims.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A floating-point (FP) arithmetic unit comprising:<claim-text>a first FP execution pipeline operatively coupled to a register file and an instruction dispatch, the first FP execution pipeline configured to:<claim-text>perform a first FP operation on a first FP operand provided by the register file, the first FP execution pipeline comprising a first plurality of execution units; and</claim-text></claim-text><claim-text>a first normalization unit operatively coupled to the register file, the first FP execution pipeline, and the instruction dispatch, the first normalization unit configured to:<claim-text>normalize the first FP operand provided by the register file,</claim-text></claim-text><claim-text>wherein the first normalization unit is configured to:<claim-text>operate in parallel with the first FP execution pipeline,</claim-text><claim-text>in response to detecting that the first FP operand is a denormal:<claim-text>assert a first FP execution pipeline busy flag to stall the instruction dispatch of a first subsequent FP operation, and</claim-text><claim-text>provide the normalized first FP operand to the first FP execution pipeline, the first FP operation and the first subsequent FP operation being of a first FP operation type.</claim-text></claim-text></claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The FP arithmetic unit of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the first FP execution pipeline is further configured to:<claim-text>perform a second FP operation on a second FP operand provided by the register file, wherein the first normalization unit is further configured to:</claim-text><claim-text>normalize the second FP operand provided by the register file, and</claim-text><claim-text>in response to detecting that the second FP operand is normal, discard the normalized second FP operand.</claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The FP arithmetic unit of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the FP execution pipeline comprises one of a FP addition execution pipeline, a FP multiplication pipeline, an FP division pipeline, an FP square-root or generalized root pipeline, an FP exponential pipeline, an FP power pipeline, or an FP logarithm pipeline, or any other operation or instruction on a floating-point operand.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The FP arithmetic unit of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>a second FP execution pipeline operatively coupled to the register file and the instruction dispatch, the second FP execution pipeline configured to:<claim-text>perform a third FP operation on a third FP operand provided by the register file, the second FP execution pipeline comprising a second plurality of execution units; and</claim-text></claim-text><claim-text>a second normalization unit operatively coupled to the register file, the second FP execution pipeline, and the instruction dispatch, the second normalization unit configured to:<claim-text>normalize the third FP operand provided by the register file,</claim-text></claim-text><claim-text>wherein the second normalization unit is configured to:<claim-text>operate in parallel with the second FP execution pipeline,</claim-text><claim-text>in response to detecting that the third FP operand is a denormal:<claim-text>assert a second FP execution pipeline busy flag to stall the instruction dispatch of a second subsequent FP operation, and</claim-text><claim-text>provide the normalized third FP operand to the second FP execution pipeline, the third FP operation and the second subsequent FP operation being of a second FP operation type.</claim-text></claim-text></claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The FP arithmetic unit of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the second FP execution pipeline is further configured to perform a fourth FP operation on a fourth FP operand provided by the register file, wherein the second normalization unit is further configured to:<claim-text>normalize the fourth FP operand provided by the register file, and</claim-text><claim-text>in response to detecting that the fourth FP operand is a normal, discard the normalized fourth FP operand.</claim-text></claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The FP arithmetic unit of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the first normalization unit is further configured to:<claim-text>cause the second normalization unit to assert the second FP execution pipeline busy flag, and</claim-text><claim-text>provide the normalized third FP operand to the second FP execution pipeline when asserting the first FP execution pipeline busy flag, and wherein the second normalization unit is further configured to:</claim-text><claim-text>cause the first normalization unit to assert the first FP execution pipeline busy flag, and</claim-text><claim-text>provide the normalized first FP operand to the first FP execution pipeline when asserting the second FP execution pipeline busy flag.</claim-text></claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The FP arithmetic unit of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising a denormal unit operatively coupled to the first FP execution pipeline, the denormal unit configured to:<claim-text>convert a fifth FP operand outputted by the first FP execution pipeline into a denormal.</claim-text></claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. A system comprising:<claim-text>a non-transitory memory storage comprising instructions and data;</claim-text><claim-text>one or more processors in communication with the non-transitory memory storage, wherein the one or more processors execute the instructions; and</claim-text><claim-text>a floating-point (FP) arithmetic unit in communication with the one or more processors and the non-transitory memory storage, the FP arithmetic unit comprising:<claim-text>a first FP execution pipeline operatively coupled to a register file and an instruction dispatch, the first FP execution pipeline configured to:<claim-text>perform a first FP operation on a first FP operand provided by the register file, the first FP execution pipeline comprising a first plurality of execution units; and</claim-text></claim-text><claim-text>a first normalization unit operatively coupled to the register file, the first FP execution pipeline, and the instruction dispatch, the first normalization unit configured to:</claim-text><claim-text>normalize the first FP operand provided by the register file,</claim-text><claim-text>wherein the first normalization unit is configured to:</claim-text><claim-text>operate in parallel with the first FP execution pipeline, and</claim-text><claim-text>in response to detecting that the first FP operand is a denormal:<claim-text>assert a first FP execution pipeline busy flag to stall the instruction dispatch of a first subsequent FP operation, and</claim-text><claim-text>provide the normalized first FP operand to the first FP execution pipeline, the first FP operation and the first subsequent FP operation being of a first FP operation type.</claim-text></claim-text></claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The system of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the first FP execution pipeline is further configured to:<claim-text>perform a second FP operation on a second FP operand provided by the register file, wherein the first normalization unit is further configured to:</claim-text><claim-text>normalize the second FP operand provided by the register file, and</claim-text><claim-text>in response to detecting that the second FP operand is a normal, discard the normalized second FP operand.</claim-text></claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The system of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the FP execution pipeline comprises one of a FP addition execution pipeline, a FP multiplication pipeline, an FP division pipeline, an FP square-root or generalized root pipeline, an FP exponential pipeline, an FP power pipeline, or an FP logarithm pipeline, or any other operation or instruction on a floating-point operand.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The system of <claim-ref idref="CLM-00008">claim 8</claim-ref>, further comprising:<claim-text>a second FP execution pipeline operatively coupled to the register file and the instruction dispatch, the second FP execution pipeline configured to:<claim-text>perform a third FP operation on a third FP operand provided by the register file, the second FP execution pipeline comprising a second plurality of execution units; and</claim-text></claim-text><claim-text>a second normalization unit operatively coupled to the register file, the second FP execution pipeline, and the instruction dispatch, the second normalization unit configured to:<claim-text>normalize the third FP operand provided by the register file,</claim-text></claim-text><claim-text>wherein the second normalization unit is configured to:<claim-text>operate in parallel with the second FP execution pipeline, and</claim-text><claim-text>in response to detecting that the third FP operand is a denormal:<claim-text>assert a second FP execution pipeline busy flag to stall the instruction dispatch of a second subsequent FP operation, and</claim-text><claim-text>provide the normalized third FP operand to the second FP execution pipeline, the third FP operation and the second subsequent FP operation being of a second FP operation type.</claim-text></claim-text></claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The system of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the second FP execution pipeline is further configured to:<claim-text>perform a fourth FP operation on a fourth FP operand provided by the register file, wherein the second normalization unit is further configured to:</claim-text><claim-text>normalize the fourth FP operand provided by the register file, and</claim-text><claim-text>in response to detecting that the fourth FP operand is a normal, discard the normalized fourth FP operand.</claim-text></claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The system of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the first normalization unit is further configured to:<claim-text>cause the second normalization unit to assert the second FP execution pipeline busy flag, and</claim-text><claim-text>provide the normalized third FP operand to the second FP execution pipeline when asserting the first FP execution pipeline busy flag, and wherein the second normalization unit is further configured to:</claim-text><claim-text>cause the first normalization unit to assert the first FP execution pipeline busy flag. and</claim-text><claim-text>provide the normalized first FP operand to the first FP execution pipeline when asserting the second FP execution pipeline busy flag.</claim-text></claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The system of <claim-ref idref="CLM-00008">claim 8</claim-ref>, further comprising a denormal unit operatively coupled to the first FP execution pipeline, the denormal unit configured to:<claim-text>convert a fifth FP operand outputted by the first FP execution pipeline into a denormal.</claim-text></claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. A method implemented by a floating-point (FP) arithmetic unit comprising:<claim-text>receiving, by the FP arithmetic unit, from an instruction dispatch, a first FP operation and a first FP operand;</claim-text><claim-text>executing, by a first FP execution pipeline of the FP arithmetic unit, the first FP operation with the first FP operand;</claim-text><claim-text>normalizing, by a first normalization unit of the FP arithmetic unit, the first FP operand in parallel with the executing of the first FP operation; and</claim-text><claim-text>in response to detecting, by the first normalization unit of the FP arithmetic unit, that the first FP operand is a denormal:<claim-text>asserting, by the first normalization unit of the FP arithmetic unit, a first FP execution pipeline busy flag to stall the instruction dispatch of a first subsequent FP operation, the first FP operation and the first subsequent FP operation being of a first FP operation type; and</claim-text><claim-text>providing, by the first normalization unit of the FP arithmetic unit, the normalized first FP operand to the first FP execution pipeline.</claim-text></claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The method of <claim-ref idref="CLM-00015">claim 15</claim-ref>, further comprising:<claim-text>receiving, by the FP arithmetic unit, from the instruction dispatch, a second FP operation and a second FP operand;</claim-text><claim-text>executing, by the first FP execution pipeline of the FP arithmetic unit, the second FP operation with the second FP operand;</claim-text><claim-text>normalizing, by the first normalization unit of the FP arithmetic unit, the second FP operand in parallel with the executing of the second FP operation; and</claim-text><claim-text>in response to detecting, by the first normalization unit of the FP arithmetic unit, that the first FP operand is a normal, discarding the normalized second FP operand.</claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The method of <claim-ref idref="CLM-00016">claim 16</claim-ref>, further comprising:<claim-text>receiving, by the FP arithmetic unit, from the instruction dispatch, a third FP operation and a third FP operand;</claim-text><claim-text>executing, by a second FP execution pipeline of the FP arithmetic unit, the third FP operation with the third FP operand;</claim-text><claim-text>normalizing, by a second normalization unit of the FP arithmetic unit, the third FP operand in parallel with the executing of the third FP operation; and</claim-text><claim-text>in response to detecting, by the second normalization unit of the FP arithmetic unit, that the third FP operand is a denormal:<claim-text>asserting, by the second normalization unit of the FP arithmetic unit, a second FP execution pipeline busy flag to stall the instruction dispatch of a second subsequent FP operation, the third FP operation and the second subsequent FP operation being of a second FP operation type; and</claim-text><claim-text>providing, by the second normalization unit of the FP arithmetic unit, the normalized second FP operand to the second FP execution pipeline.</claim-text></claim-text></claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The method of <claim-ref idref="CLM-00017">claim 17</claim-ref>, further comprising:<claim-text>receiving, by the FP arithmetic unit, from the instruction dispatch, a fourth FP operation and a fourth FP operand;</claim-text><claim-text>executing, by the second FP execution pipeline of the FP arithmetic unit, the fourth FP operation with the fourth FP operand;</claim-text><claim-text>normalizing, by the second normalization unit of the FP arithmetic unit, the fourth FP operand in parallel with the executing of the fourth FP operation; and</claim-text><claim-text>in response to detecting, by the second normalization unit of the FP arithmetic unit, that the fourth FP operand is a normal, discarding the normalized fourth FP operand.</claim-text></claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The method of <claim-ref idref="CLM-00017">claim 17</claim-ref>, further comprising, when detecting that the first FP operand is a denormal:<claim-text>asserting, by the second normalization unit of the FP arithmetic unit, the second FP execution pipeline busy flag to stall the instruction dispatch of a subsequent FP operating having a same FP operation type as the third FP operation; and</claim-text><claim-text>providing, by the second normalization unit of the FP arithmetic unit, the normalized second FP operand to the second FP execution pipeline.</claim-text></claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The method of <claim-ref idref="CLM-00015">claim 15</claim-ref>, further comprising converting, by a denormal unit of the FP arithmetic unit, a sixth FP operand outputted by the first FP execution pipeline to a denormal FP number unit.</claim-text></claim><claim id="CLM-00021" num="00021"><claim-text><b>21</b>. The method of <claim-ref idref="CLM-00015">claim 15</claim-ref>, the first FP operation comprising one of a FP addition operation or a FP multiplication operation.</claim-text></claim><claim id="CLM-00022" num="00022"><claim-text><b>22</b>. The method of <claim-ref idref="CLM-00015">claim 15</claim-ref>, the first subsequent FP operation and the first FP operation are of a same FP operation type.</claim-text></claim></claims></us-patent-application>