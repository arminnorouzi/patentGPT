<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004967A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004967</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17763169</doc-number><date>20200917</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><priority-claims><priority-claim sequence="01" kind="national"><country>GB</country><doc-number>1913990.6</doc-number><date>20190927</date></priority-claim></priority-claims><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>Q</subclass><main-group>20</main-group><subgroup>40</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>L</subclass><main-group>9</main-group><subgroup>00</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>Q</subclass><main-group>20</main-group><subgroup>38</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>Q</subclass><main-group>20</main-group><subgroup>22</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>Q</subclass><main-group>20</main-group><subgroup>401</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20220501</date></cpc-version-indicator><section>H</section><class>04</class><subclass>L</subclass><main-group>9</main-group><subgroup>50</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>Q</subclass><main-group>20</main-group><subgroup>3825</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>Q</subclass><main-group>20</main-group><subgroup>389</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>Q</subclass><main-group>20</main-group><subgroup>223</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>Q</subclass><main-group>2220</main-group><subgroup>00</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e61">TIME-LOCKED BLOCKCHAIN TRANSACTIONS AND RELATED BLOCKCHAIN TECHNOLOGY</invention-title><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>nChain Holdings Limited</orgname><address><city>St. Johns</city><country>AG</country></address></addressbook><residence><country>AG</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>DAVIES</last-name><first-name>Jack Owen</first-name><address><city>London</city><country>GB</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>ZHANG</last-name><first-name>Wei</first-name><address><city>London</city><country>GB</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>WRIGHT</last-name><first-name>Craig Steven</first-name><address><city>London</city><country>GB</country></address></addressbook></inventor></inventors></us-parties><pct-or-regional-filing-data><document-id><country>WO</country><doc-number>PCT/IB2020/058674</doc-number><date>20200917</date></document-id><us-371c12-date><date>20220323</date></us-371c12-date></pct-or-regional-filing-data></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A blockchain payment channel is effected based on a series of spending transactions exchanged between parties, in which each transaction of the series of spending transactions has a future lock time, before which it cannot be committed to the blockchain, and comprises at least two spendable transaction outputs having respective digital asset values. At computer equipment of the party, a previous transaction of the series of spending transactions is received, and a function is applied to one or more function variables contained in the previous transaction to at least partially determine the current transaction. A portion of the current transaction is cryptographically signed, the signed portion comprising the at least two spendable transaction outputs, using a private key counterpart to the public key of the party, thereby computing a transaction signature for inclusion in the transaction input of the current transaction.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="221.06mm" wi="158.75mm" file="US20230004967A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="224.87mm" wi="162.05mm" file="US20230004967A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="220.30mm" wi="175.26mm" file="US20230004967A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="216.75mm" wi="152.32mm" file="US20230004967A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="161.63mm" wi="155.19mm" file="US20230004967A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="193.38mm" wi="155.53mm" file="US20230004967A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="193.29mm" wi="155.36mm" file="US20230004967A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="153.33mm" wi="81.45mm" file="US20230004967A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="104.65mm" wi="137.58mm" file="US20230004967A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="235.12mm" wi="144.10mm" orientation="landscape" file="US20230004967A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="227.92mm" wi="151.21mm" file="US20230004967A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="242.32mm" wi="153.84mm" file="US20230004967A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="240.54mm" wi="155.11mm" file="US20230004967A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="232.33mm" wi="111.25mm" orientation="landscape" file="US20230004967A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00014" num="00014"><img id="EMI-D00014" he="216.75mm" wi="116.16mm" orientation="landscape" file="US20230004967A1-20230105-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00015" num="00015"><img id="EMI-D00015" he="222.67mm" wi="152.57mm" file="US20230004967A1-20230105-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00016" num="00016"><img id="EMI-D00016" he="219.37mm" wi="107.27mm" orientation="landscape" file="US20230004967A1-20230105-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00017" num="00017"><img id="EMI-D00017" he="130.64mm" wi="137.33mm" file="US20230004967A1-20230105-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00018" num="00018"><img id="EMI-D00018" he="229.87mm" wi="116.25mm" orientation="landscape" file="US20230004967A1-20230105-D00018.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00019" num="00019"><img id="EMI-D00019" he="202.86mm" wi="150.54mm" file="US20230004967A1-20230105-D00019.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00020" num="00020"><img id="EMI-D00020" he="221.23mm" wi="122.68mm" orientation="landscape" file="US20230004967A1-20230105-D00020.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00021" num="00021"><img id="EMI-D00021" he="226.23mm" wi="151.38mm" orientation="landscape" file="US20230004967A1-20230105-D00021.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00022" num="00022"><img id="EMI-D00022" he="237.24mm" wi="141.22mm" orientation="landscape" file="US20230004967A1-20230105-D00022.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00023" num="00023"><img id="EMI-D00023" he="237.41mm" wi="158.75mm" orientation="landscape" file="US20230004967A1-20230105-D00023.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00024" num="00024"><img id="EMI-D00024" he="234.87mm" wi="141.73mm" orientation="landscape" file="US20230004967A1-20230105-D00024.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00025" num="00025"><img id="EMI-D00025" he="232.07mm" wi="134.03mm" orientation="landscape" file="US20230004967A1-20230105-D00025.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00026" num="00026"><img id="EMI-D00026" he="214.04mm" wi="166.03mm" orientation="landscape" file="US20230004967A1-20230105-D00026.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00027" num="00027"><img id="EMI-D00027" he="122.34mm" wi="136.91mm" file="US20230004967A1-20230105-D00027.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00028" num="00028"><img id="EMI-D00028" he="218.61mm" wi="146.30mm" file="US20230004967A1-20230105-D00028.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">CROSS REFERENCE TO RELATED APPLICATIONS</heading><p id="p-0002" num="0001">This application is the U.S. National Stage of International Application No. PCT/IB2020/058674 filed on Sep. 17, 2020, which claims the benefit of United Kingdom Patent Application No. 1913990.6, filed on Sep. 27, 2019, the contents of which are incorporated herein by reference in their entireties.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">TECHNICAL FIELD</heading><p id="p-0003" num="0002">The present disclosure pertains generally to a communication framework in which &#x201c;time-locked&#x201d; blockchain transactions (or component(s) thereof) are exchanged between entities but only a subset of those transactions (e.g. a single transaction) is generally expected to be committed to a blockchain once its lock time has expired. This disclosure further pertains to steps, systems, computer programs and/or transactions etc. for facilitating such an exchange or otherwise related thereto.</p><heading id="h-0003" level="1">BACKGROUND</heading><p id="p-0004" num="0003">A blockchain refers to a form of distributed data structure, wherein a duplicate copy of the blockchain is maintained at each of a plurality of nodes in a peer-to-peer (P2P) network. The blockchain comprises a chain of blocks of data, wherein each block comprises one or more transactions. Each transaction may point back to a preceding transaction in a sequence which may span one or more blocks. Transactions can be submitted to the network to be included in new blocks. New blocks are created by a process known as &#x201c;mining&#x201d;, which involves each of a plurality of mining nodes competing to perform &#x201c;proof-of-work&#x201d;, i.e. solving a cryptographic puzzle based on a pool of the pending transactions waiting to be included in blocks.</p><p id="p-0005" num="0004">Conventionally the transactions in the blockchain are used to convey a digital asset, i.e. data acting as a store of value. However, a blockchain can also be exploited in order to layer additional functionality on top of the blockchain. For instance, blockchain protocols may allow for storage of additional user data in an output of a transaction. Modern blockchains are increasing the maximum data capacity that can be stored within a single transaction, enabling more complex data to be incorporated. For instance this may be used to store an electronic document in the blockchain, or even audio or video data.</p><p id="p-0006" num="0005">Each node in the network can have any one, two or all of three roles: forwarding, mining and storage. Forwarding nodes propagate transactions throughout the nodes of the network. Mining nodes perform the mining of transactions into blocks. Storage nodes each store their own copy of the mined blocks of the blockchain. In order to have a transaction recorded in the blockchain, a party sends the transaction to one of the nodes of the network to be propagated. Mining nodes which receive the transaction may race to mine the transaction into a new block. Each node is configured to respect the same node protocol, which will include one or more conditions for a transaction to be valid. Invalid transactions will not be propagated nor mined into blocks. Assuming the transaction is validated and thereby accepted onto the blockchain, then the transaction (including any user data) will thus remain stored at each of the nodes in the P2P network as an immutable public record.</p><p id="p-0007" num="0006">The miner who successfully solved the proof-of-work puzzle to create the latest block is typically rewarded with a new transaction called a &#x201c;generation transaction&#x201d; which generates a new amount of the digital asset. The proof-of work incentivises miners not to cheat the system by including double-spending transactions in their blocks, since it requires a large amount of computational resource to mine a block, and a block that includes an attempt to double spend is likely not be accepted by other nodes.</p><p id="p-0008" num="0007">In an &#x201c;output-based&#x201d; model (sometimes referred to as a UTXO-based model), the data structure of a given transaction comprises one or more inputs (transaction inputs) and one or more outputs (transaction outputs). Any spendable output comprises an element specifying an amount of the digital asset, sometimes referred to as a UTXO (&#x201c;unspent transaction output&#x201d;). The output may further comprise a locking script specifying a condition for redeeming the output. Each input comprises a pointer to such an output in a preceding transaction, and may further comprise an unlocking script for unlocking the locking script of the pointed-to output. So consider a pair of transactions, call them a first and a second transaction (or &#x201c;target&#x201d; transaction). The first transaction comprises at least one output specifying an amount of the digital asset, and comprising a locking script defining one or more conditions of unlocking the output. The second, target transaction comprises at least one input, comprising a pointer to the output of the first transaction, and an unlocking script for unlocking the output of the first transaction.</p><p id="p-0009" num="0008">In such a model, when the second, target transaction is sent to the P2P network to be propagated and recorded in the blockchain, one of the criteria for validity applied at each node will be that the unlocking script meets all of the one or more conditions defined in the locking script of the first transaction. Another will be that the output of the first transaction has not already been redeemed by another, earlier valid transaction. Any node that finds the target transaction invalid according to any of these conditions will not propagate it nor include it for mining into a block to be recorded in the blockchain.</p><p id="p-0010" num="0009">An alternative type of transaction model is an account-based model. In this case each transaction does not define the amount to be transferred by referring back to the UTXO of a preceding transaction in a sequence of past transactions, but rather by reference to an absolute account balance. The current state of all accounts is stored by the miners separate to the blockchain and is updated constantly.</p><p id="p-0011" num="0010">At least one blockchain protocol in use today defines the related concepts of &#x201c;sequence numbers&#x201d; and &#x201c;lock times&#x201d;. In one particular UTXO-based model, the (or each) input of a transaction has a sequence number which can a take values between a maximum and a minimum sequence number (e.g. 0x00000000 to 0xFFFFFFFF in hexadecimal notation). A transaction can also have a defined lock time, and can only become valid after that lock time has expired (even if, before that point in time, it satisfied all of the other requirements of validity). Before that point in time, the transaction is said to be &#x201c;time locked&#x201d;. Sequence numbers together with lock times provide certainty in a situation in which multiple versions of the same transaction are created (or, more precisely, when multiple transactions which all satisfy the condition(s) for unlocking the same output(s) are created). Without a defined lock time, the creation of two such transactions would lead to &#x201c;double spending&#x201d; uncertainty: both transactions could be submitted to a blockchain network for validation, and it would not necessarily be possible to predict with any certainty which of these would end up getting mined into a valid block (at which point the other would become invalid).</p><p id="p-0012" num="0011">However, a transaction with a defined future lock time cannot become valid until that lock time expires. Moreover, if two otherwise-valid transactions are submitted to the blockchain network which unlock the same output(s) and which have expired lock times, only the transaction with the higher sequence number will be accepted as valid by miners&#x2014;the transaction number with the lower sequence number will be invalid, even though its lock time has expired, and even though it satisfies all of the other validity requirements.</p><heading id="h-0004" level="1">SUMMARY</heading><p id="p-0013" num="0012">Sequence numbers and lock times can be used to implement a particular form of blockchain payment channel. In a blockchain context, the term &#x201c;payment channel&#x201d; refers to a particular form of &#x201c;off-chain&#x201d; communication between two or more parties to the payment channel (participants). A payment channel can be used to exchange a series of spending transactions, for unlocking the same output(s), and having future lock times and incrementing sequence numbers. Each spending transaction may be valid but for the fact that its lock time has not yet expired, and subject to an equally valid spending transaction being created with a higher sequence number before that point in time. This provides a secure technical framework in which two or more parties can negotiate&#x2014;in the expectation that they will be able to reach a mutually agreed settlement transaction to terminate the negotiation, but with each party having the option of publishing the spending transaction with the highest sequence number, upon expiry of its lock time, in the event of the other party/parties terminating the negotiation prematurely or otherwise acting in bad faith.</p><p id="p-0014" num="0013">A similar outcome could be achieved by simply committing an agreed transaction to the blockchain at every step of the negotiation. However, that would require significantly more time and computational resources to process each transaction and wait for the necessary level of consensus to be reached&#x2014;typically the parties would have to wait not only for the transaction to be mined into a block, but also for several more blocks to be mined in order for the blockchain network to reach a consensus as to the block's validity, before proceeding to the next step of the negotiation. For a negotiation with a large number of steps, this would be extremely inefficient both in terms of the time delay and the computational resources needed to process so many transactions within the blockchain network.</p><p id="p-0015" num="0014">The present disclosure pertains generally to a novel framework for implementing blockchain &#x201c;payment channels&#x201d;. It is important to note that, notwithstanding the terminology, the present payment channels are not limited to negotiated payment&#x2014;in general, a payment channel of the present disclosure provides a computationally efficient way to conduct off-chain communication in a secure manner according to an agreed set of rules. A core issue addressed herein is that of balancing efficiency (both in terms of time and computational resources) and security in the context of a blockchain payment channel. Security in the present context means the extent to which the payment channel is robust to one party (or parties) violating the agreed rules of the payment channel.</p><p id="p-0016" num="0015">According to one aspect disclosed herein, there is provided a computer-implemented method of effecting a blockchain payment channel based on a series of spending transactions exchanged between parties, in which: each transaction of the series of spending transactions has a future lock time, before which it cannot be committed to the blockchain, and comprises: (i) at least one transaction input containing a pointer a common spendable transaction output, and (ii) at least two spendable transaction outputs having respective digital asset values, an initial transaction of the series of spending transactions has a lowest sequence number and each subsequent transaction of the series of spending transactions has a higher sequence number than the previous transaction and contains one or more function variables other than the respective digital asset values of its spendable transaction outputs; wherein the method comprises, by one of the parties: receiving, at computer equipment of the party, a previous transaction of the series of spending transactions; applying a function to the one or more function variables contained in the previous transaction to do at least one of: compute the digital asset values of the current transaction, create a new data field for the current transaction, which does not correspond to any existing data field contained in the previous transaction, the current transaction containing the new data field, and prevent an existing type of data field from being propagated from the previous transaction into the current transaction, such that the previous transaction contains a data field which does not correspond to any data field in the current transaction; and cryptographically signing a portion of the current transaction, the signed portion comprising the at least two spendable transaction outputs, using a private key counterpart to the public key of the party, thereby computing a transaction signature for inclusion in the transaction input of the current transaction.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0017" num="0016">To assist understanding of embodiments of the present disclosure and to show how such embodiments may be put into effect, reference is made, by way of example only, to the accompanying drawings in which:</p><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a schematic block diagram of a system for implementing a blockchain,</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>2</b></figref> schematically illustrates some examples of transactions which may be recorded in a blockchain,</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>2</b>A</figref> shows an example of a funding transaction and two cooperating &#x201c;loop&#x201d; transactions</p><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a schematic block diagram of another system for implementing a blockchain payment channel,</p><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. <b>3</b>A</figref> shows a second example of a system for implementing a blockchain payment channel,</p><p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. <b>3</b>B</figref> shows a third example of a system for implementing a blockchain payment channel,</p><p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. <b>4</b>A</figref> is a schematic block diagram of a client application,</p><p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. <b>4</b>B</figref> is a schematic block diagram of some node software for processing transactions,</p><p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. <b>4</b>C</figref> is a schematic mock-up of an example user interface that may be presented by the client application of <figref idref="DRAWINGS">FIG. <b>4</b>A</figref>,</p><p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. <b>5</b></figref> conceptually illustrates how spending relationships are established between blockchain transactions in a UTXO model,</p><p id="p-0028" num="0027"><figref idref="DRAWINGS">FIGS. <b>6</b>A, <b>6</b>A and <b>6</b>B</figref> show example process flows for implementing a &#x201c;payment channel loop&#x201d;,</p><p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. <b>7</b></figref> shows one example of a &#x201c;for&#x201d; payment channel loop,</p><p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. <b>8</b></figref> shows how loop transaction may be iteratively created, using a defined functional unit,</p><p id="p-0031" num="0030"><figref idref="DRAWINGS">FIGS. <b>9</b>A and <b>9</b>B</figref> show examples for different &#x201c;2-out-of-2&#x201d; funding transactions for establishing a secure payment channel,</p><p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. <b>10</b></figref> shows a relationship between a funding transaction and a loop transaction,</p><p id="p-0033" num="0032"><figref idref="DRAWINGS">FIGS. <b>11</b>A and <b>11</b>B</figref> show, respectively, an example of a settlement transaction, and its relationship to a funding transaction,</p><p id="p-0034" num="0033"><figref idref="DRAWINGS">FIGS. <b>12</b> to <b>16</b></figref> show various example process flows for different implementations of payment channel loops,</p><p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. <b>17</b></figref> shows a &#x201c;2-out-of-3&#x201d; funding transaction,</p><p id="p-0036" num="0035"><figref idref="DRAWINGS">FIGS. <b>18</b>A and <b>18</b>B</figref> shows, respectively, a settlement transaction evidencing a series of input values and/or parameters, and a data structure for evidencing the series of transactions.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0006" level="1">DETAILED DESCRIPTION OF EMBODIMENTS</heading><p id="p-0037" num="0036">A blockchain is maintained by a blockchain network (a peer-to-peer network of blockchain nodes, each of which performs one or more of a mining role, a forwarding role and a storage role). A &#x201c;committed&#x201d; transaction is a transaction which has been validated by a mining node of a blockchain network which maintains the blockchain, and mined by the mining node into a valid block of the blockchain (and thus immutably recorded in the blockchain; for the block to be valid, in practice this will mean that the validity for the transaction has been confirmed by a sufficient number of mining nodes in order to reach a consensus as to the validity of the block). By definition, a committed transaction must be valid with respect to a blockchain protocol of the blockchain network.</p><p id="p-0038" num="0037">By contrast, a &#x201c;published&#x201d; transaction is a transaction which has been submitted to a node the blockchain network for validation (by that node and/or other node(s) of the blockchain network), but has not yet mined into a block, and which may or may not be valid. A published transaction will not necessarily ever be mined (i.e. it may or may not be mined in due course, depending on the circumstances). For example, a published transaction may be held in a mining pool of transactions which are potential candidates for being mined (and may be visible to other users of the blockchain), but has not yet been immutably recorded in the blockchain, and may never be because it may or may not be valid.</p><p id="p-0039" num="0038">The phrase &#x201c;receiving, at computer equipment of the party, a previous transaction of the series of spending transaction&#x201d; encompasses not only receipt from a remote source, such as computer equipment of one of the other parties, but also local receiving, e.g. from local storage of the computer equipment of the same party. For example, the previous transaction may have been created (or at least finalized) by another of the parties, and received from that party, or it may have been created (or at least finalized) by the same party and stored locally to enable that same party to create (but not necessarily finalize) the current transaction, or at least compute its input value(s) and/or any other relevant component(s) such as its digital asset distribution.</p><p id="p-0040" num="0039">In the present context, a transaction is said to be &#x201c;completed&#x201d; at the point at which the input of that transaction satisfies the conditions for unlocking the output of the funding transaction&#x2014;note that a transaction of the series of spending transactions will not necessarily be valid at the point it is completed, even if the structure and contents of the transaction meets all of the validity requirements imposed by a blockchain protocol of the blockchain. This is because the transaction can only become valid after its lock time has been expired and, moreover, will only be valid (i.e. accepted as valid by a consensus of mining nodes) if no other completed spending transaction has been published with a higher sequence number and whose lock time has expired. That is to say, if multiple completed spending transactions are published after their respective lock times have expired, only one of those spending transactions will be accepted as valid by a consensus of mining nodes&#x2014;that one spending transaction being the one with the highest sequence number.</p><p id="p-0041" num="0040">Since the output of the funding transaction is locked to at least two public keys of the parties, as a minimum two transaction signatures&#x2014;each valid in respect of a different one of the public keys&#x2014;will be required to complete the transaction. For example, the point at which a transaction is completed may be the point at which a second of the parties signs the transaction, subsequent to an earlier point at which a first of the second parties signed the transaction.</p><p id="p-0042" num="0041">Note, the terminology &#x201c;at least one spendable output locked to at least two public keys&#x201d; does not necessarily imply that the only requirement for unlocking (spending) that output is the provision of two transaction signatures valid in respect of those keys respectively. That is to say, there may or may not be additional unlocking requirement(s) (such as the requirement to provide a solution to a specified hash puzzle etc.). For example, the full locking script could be something like:</p><p id="p-0043" num="0042">[Hash puzzle H(X)] [Multisig 2-of-2],</p><p id="p-0044" num="0043">which means the funds are not entirely (un)locked by the keys, and that there may be an additional minimum requirement to unlock funds, i.e. the provision of a preimage which hashes to H(X).</p><p id="p-0045" num="0044">The verb &#x201c;to chorographically sign&#x201d; in this specific context refers to the process of generating a transaction signature for inclusion in the input of the current transaction, by applying a signature generation function to at least the outputs of the spending transaction, using a private key counterpart to that party's public key. The party signing the transaction will not necessarily add the transaction signature to the input of the transaction&#x2014;for example, it could be sent to another of the parties (or indeed some other external entity) for adding to the input. The party signing a transaction does not necessarily need to be in possession of the whole transaction&#x2014;only the signed portion is required.</p><p id="p-0046" num="0045">A spending transaction can be created by one party (or indeed by an external entity who is not party to the payment channel) but completed by another party (optionally, with one or more additional parties adding to the transaction in the interim). Alternatively, in the present context, a spending transaction can be created and completed by the same party, but in that event at least one other party needs to provide a valid transaction signature, and will generally require at least the outputs of the transaction in order to do so. The party that applies the function to compute the input value(s) of the current transaction and the distribution of digital asset may or may not create the rest of transaction&#x2014;for the latter, it would, for example, be sufficient for the function-applying party to simply compute the input value(s), the digital asset distribution and that party's transaction signature, and send them to another entity (e.g. another of the parties) to create the rest of the transaction.</p><p id="p-0047" num="0046">The terms &#x2018;previous transaction&#x2019; and &#x2018;current transaction&#x2019; are relative terms and can thus refer to any two temporally adjacent transaction in the series (including the case where the previous transaction is the initial transaction, and the case where the current transaction is a final transaction in the series.</p><p id="p-0048" num="0047">The phrase &#x201c;output locked to at least two public keys of the parties&#x201d; covers not only the case where a signature is required for every single public key specified in the output, by also an output in which m public keys are specified but the output is locked to any n&#x3c;m of those public keys (i.e. any subset of n parties can sign the transaction to unlock the output of the funding transaction). In accordance with the terminology applied in the art, this may be referred to as an &#x201c;n-ofm check multi-sig&#x201d; (multi-signature) condition in the output of the funding transaction.</p><p id="p-0049" num="0048">This disclosure uses the terminology &#x201c;n-of-m check multisig&#x201d; and similar as a convenient shorthand for any locking script that requires transaction signatures for only a subset n of the specified m public keys. There are numerous ways this requirement can be coded in blockchain Script, and the terminology does not imply any particular Script-level implementation. For example, the following alternatives are encompassed by the terminology (among others, including more complex scripts):<ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0049">1. a &#x2018;bare multisig&#x2019;, which uses the opcode OP_CHECKMULTISGI(VERIFY),</li>        <li id="ul0002-0002" num="0050">2. a P2SH (pay to script hash) multisig, where a special script is written to implement this requirement.</li>    </ul>    </li></ul></p><p id="p-0050" num="0051">The at least two spendable outputs of each spending transaction will typically be constructed for distributing an amount of digital asset between at least two of the parties&#x2014;although the possibility of constructing spending transactions that distribute the amount of digital asset between other parties is not excluded (e.g. the parties to the payment channel could negotiate or otherwise agree a distribution of digital asset on behalf of some other blockchain parties). Each of those spendable outputs is locked to a public key of a different one of the parties amongst which the digital asset is to be distributed. Where those are the same parties who agree the distribution via the payment channel, that public key may or may not be the same public specified in the spendable output of the funding transaction.</p><p id="p-0051" num="0052">For each spending transaction the distribution of the amount of digital asset is defined by the respective digital asset values of the spending transaction outputs (as determined by the application of the function). Hence, the function together with the one or more input values of the previous transaction defines the distribution of the digital asset between the parties. Of course, that distribution will only be crystallised if and when the transaction is committed to the blockchain&#x2014;which, in turn, can only happen (a) after the lock time of the transaction has expired and (b) only if no other spending transaction with a higher sequence number is published.</p><p id="p-0052" num="0053">In some contexts, it may be preferable for the one or more function variables to be contained in an output(s) of the transaction, so that the function variable(s) are signed. For example, they may be contained in one or more of the spendable outputs or in one or more separate, unspendable outputs of the transaction.</p><heading id="h-0007" level="1">1. Example System Overview</heading><p id="p-0053" num="0054"><figref idref="DRAWINGS">FIG. <b>1</b></figref> shows an example system <b>100</b> for implementing a blockchain <b>150</b>. The system <b>100</b> comprises a packet-switched network <b>101</b>, typically a wide-area internetwork such as the Internet. The packet-switched network <b>101</b> comprises a plurality of nodes <b>104</b> arranged to form a peer-to-peer (P2P) overlay network <b>106</b> within the packet-switched network <b>101</b>. Each node <b>104</b> comprises computer equipment of a peers, with different ones of the nodes <b>104</b> belonging to different peers. Each node <b>104</b> comprises processing apparatus comprising one or more processors, e.g. one or more central processing units (CPUs), accelerator processors, application specific processors and/or field programmable gate arrays (FPGAs). Each node also comprises memory, i.e. computer-readable storage in the form of a non-transitory computer-readable medium or media. The memory may comprise one or more memory units employing one or more memory media, e.g. a magnetic medium such as a hard disk; an electronic medium such as a solid-state drive (SSD), flash memory or EEPROM; and/or an optical medium such as an optical disk drive.</p><p id="p-0054" num="0055">The blockchain <b>150</b> comprises a chain of blocks of data <b>151</b>, wherein a respective copy of the blockchain <b>150</b> is maintained at each of a plurality of nodes in the P2P network <b>160</b>. Each block <b>151</b> in the chain comprises one or more transactions <b>152</b>, wherein a transaction in this context refers to a kind of data structure. The nature of the data structure will depend on the type of transaction protocol used as part of a transaction model or scheme. A given blockchain will typically use one particular transaction protocol throughout. In one common type of transaction protocol, the data structure of each transaction <b>152</b> comprises at least one input and at least one output. Each output specifies an amount representing a quantity of a digital asset belonging to a user <b>103</b> to whom the output is cryptographically locked (requiring a signature of that user in order to be unlocked and thereby redeemed or spent). Each input points back to the output of a preceding transaction <b>152</b>, thereby linking the transactions.</p><p id="p-0055" num="0056">At least some of the nodes <b>104</b> take on the role of forwarding nodes <b>104</b>F which forward and thereby propagate transactions <b>152</b>. At least some of the nodes <b>104</b> take on the role of miners <b>104</b>M which mine blocks <b>151</b>. At least some of the nodes <b>104</b> take on the role of storage nodes <b>104</b>S (sometimes also called &#x201c;full-copy&#x201d; nodes), each of which stores a respective copy of the same blockchain <b>150</b> in their respective memory. Each miner node <b>104</b>M also maintains a pool <b>154</b> of transactions <b>152</b> waiting to be mined into blocks <b>151</b>. A given node <b>104</b> may be a forwarding node <b>104</b>, miner <b>104</b>M, storage node <b>104</b>S or any combination of two or all of these.</p><p id="p-0056" num="0057">In a given present transaction <b>152</b><i>j</i>, the (or each) input comprises a pointer referencing the output of a preceding transaction <b>152</b><i>i </i>in the sequence of transactions, specifying that this output is to be redeemed or &#x201c;spent&#x201d; in the present transaction <b>152</b><i>j</i>. In general, the preceding transaction could be any transaction in the pool <b>154</b> or any block <b>151</b>. The preceding transaction <b>152</b><i>i </i>need not necessarily exist at the time the present transaction <b>152</b><i>j </i>is created or even sent to the network <b>106</b>, though the preceding transaction <b>152</b><i>i </i>will need to exist and be validated in order for the present transaction to be valid. Hence &#x201c;preceding&#x201d; herein refers to a predecessor in a logical sequence linked by pointers, not necessarily the time of creation or sending in a temporal sequence, and hence it does not necessarily exclude that the transactions <b>152</b><i>i</i>, <b>152</b><i>j </i>be created or sent out-of-order (see discussion below on orphan transactions). The preceding transaction <b>152</b><i>i </i>could equally be called the antecedent or predecessor transaction.</p><p id="p-0057" num="0058">The input of the present transaction <b>152</b><i>j </i>also comprises the signature of the user <b>103</b><i>a </i>to whom the output of the preceding transaction <b>152</b><i>i </i>is locked. In turn, the output of the present transaction <b>152</b><i>j </i>can be cryptographically locked to a new user <b>103</b><i>b</i>. The present transaction <b>152</b><i>j </i>can thus transfer the amount defined in the input of the preceding transaction <b>152</b><i>i </i>to the new user <b>103</b><i>b </i>as defined in the output of the present transaction <b>152</b><i>j</i>. In some cases a transaction <b>152</b> may have multiple outputs to split the input amount between multiple users (one of whom could be the original user <b>103</b><i>a </i>in order to give change). In some cases a transaction can also have multiple inputs to gather together the amounts from multiple outputs of one or more preceding transactions, and redistribute to one or more outputs of the current transaction.</p><p id="p-0058" num="0059">The above may be referred to as an &#x201c;output-based&#x201d; transaction protocol, sometimes also referred to as an unspent transaction output (UTXO) type protocol (where the outputs are referred to as UTXOs). A user's total balance is not defined in any one number stored in the blockchain, and instead the user needs a special &#x201c;wallet&#x201d; application <b>105</b> to collate the values of all the UTXOs of that user which are scattered throughout many different transactions <b>152</b> in the blockchain <b>151</b>.</p><p id="p-0059" num="0060">An alternative type of transaction protocol may be referred to as an &#x201c;account-based&#x201d; protocol, as part of an account-based transaction model. In the account-based case, each transaction does not define the amount to be transferred by referring back to the UTXO of a preceding transaction in a sequence of past transactions, but rather by reference to an absolute account balance. The current state of all accounts is stored by the miners separate to the blockchain and is updated constantly. In such a system, transactions are ordered using a running transaction tally of the account (also called the &#x201c;position&#x201d;). This value is signed by the sender as part of their cryptographic signature and is hashed as part of the transaction reference calculation. In addition, an optional data field may also be signed the transaction. This data field may point back to a previous transaction, for example if the previous transaction ID is included in the data field.</p><p id="p-0060" num="0061">With either type of transaction protocol, when a user <b>103</b> wishes to enact a new transaction <b>152</b><i>j</i>, then he/she sends the new transaction from his/her computer terminal <b>102</b> to one of the nodes <b>104</b> of the P2P network <b>106</b> (which nowadays are typically servers or data centres, but could in principle be other user terminals). This node <b>104</b> checks whether the transaction is valid according to a node protocol which is applied at each of the nodes <b>104</b>. The details of the node protocol will correspond to the type of transaction protocol being used in the blockchain <b>150</b> in question, together forming the overall transaction model. The node protocol typically requires the node <b>104</b> to check that the cryptographic signature in the new transaction <b>152</b><i>j </i>matches the expected signature, which depends on the previous transaction <b>152</b><i>i </i>in an ordered sequence of transactions <b>152</b>. In an output-based case, this may comprise checking that the cryptographic signature of the user included in the input of the new transaction <b>152</b><i>j </i>matches a condition defined in the output of the preceding transaction <b>152</b><i>i </i>which the new transaction spends, wherein this condition typically comprises at least checking that the cryptographic signature in the input of the new transaction <b>152</b><i>j </i>unlocks the output of the previous transaction <b>152</b><i>i </i>to which the input of the new transaction points. In some transaction protocols the condition may be at least partially defined by a custom script included in the input and/or output. Alternatively it could simply be a fixed by the node protocol alone, or it could be due to a combination of these. Either way, if the new transaction <b>152</b><i>j </i>is valid, the current node forwards it to one or more others of the nodes <b>104</b> in the P2P network <b>106</b>. At least some of these nodes <b>104</b> also act as forwarding nodes <b>104</b>F, applying the same test according to the same node protocol, and so forward the new transaction <b>152</b><i>j </i>on to one or more further nodes <b>104</b>, and so forth. In this way the new transaction is propagated throughout the network of nodes <b>104</b>.</p><p id="p-0061" num="0062">In an output-based model, the definition of whether a given output (e.g. UTXO) is spent is whether it has yet been validly redeemed by the input of another, onward transaction <b>152</b><i>j </i>according to the node protocol. Another condition for a transaction to be valid is that the output of the preceding transaction <b>152</b><i>i </i>which it attempts to spend or redeem has not already been spent/redeemed by another valid transaction. Again if not valid, the transaction <b>152</b><i>j </i>will not be propagated or recorded in the blockchain. This guards against double-spending whereby the spender tries to spend the output of the same transaction more than once. An account-based model on the other hand guards against double-spending by maintaining an account balance. Because again there is a defined order of transactions, the account balance has a single defined state at any one time.</p><p id="p-0062" num="0063">In addition to validation, at least some of the nodes <b>104</b>M also race to be the first to create blocks of transactions in a process known as mining, which is underpinned by &#x201c;proof of work&#x201d;. At a mining node <b>104</b>M, new transactions are added to a pool of valid transactions that have not yet appeared in a block. The miners then race to assemble a new valid block <b>151</b> of transactions <b>152</b> from the pool of transactions <b>154</b> by attempting to solve a cryptographic puzzle. Typically this comprises searching for a &#x201c;nonce&#x201d; value such that when the nonce is concatenated with the pool of transactions <b>154</b> and hashed, then the output of the hash meets a predetermined condition. E.g. the predetermined condition may be that the output of the hash has a certain predefined number of leading zeros. A property of a hash function is that it has an unpredictable output with respect to its input. Therefore this search can only be performed by brute force, thus consuming a substantive amount of processing resource at each node <b>104</b>M that is trying to solve the puzzle.</p><p id="p-0063" num="0064">The first miner node <b>104</b>M to solve the puzzle announces this to the network <b>106</b>, providing the solution as proof which can then be easily checked by the other nodes <b>104</b> in the network (once given the solution to a hash it is straightforward to check that it causes the output of the hash to meet the condition). The pool of transactions <b>154</b> for which the winner solved the puzzle then becomes recorded as a new block <b>151</b> in the blockchain <b>150</b> by at least some of the nodes <b>104</b> acting as storage nodes <b>104</b>S, based on having checked the winner's announced solution at each such node. A block pointer <b>155</b> is also assigned to the new block <b>151</b><i>n </i>pointing back to the previously created block <b>151</b><i>n</i>-<b>1</b> in the chain. The proof-of-work helps reduce the risk of double spending since it takes a large amount of effort to create a new block <b>151</b>, and as any block containing a double spend is likely to be rejected by other nodes <b>104</b>, mining nodes <b>104</b>M are incentivised not to allow double spends to be included in their blocks. Once created, the block <b>151</b> cannot be modified since it is recognized and maintained at each of the storing nodes <b>104</b>S in the P2P network <b>106</b> according to the same protocol. The block pointer <b>155</b> also imposes a sequential order to the blocks <b>151</b>. Since the transactions <b>152</b> are recorded in the ordered blocks at each storage node <b>104</b>S in a P2P network <b>106</b>, this therefore provides an immutable public ledger of the transactions.</p><p id="p-0064" num="0065">Note that different miners <b>104</b>M racing to solve the puzzle at any given time may be doing so based on different snapshots of the unmined transaction pool <b>154</b> at any given time, depending on when they started searching for a solution. Whoever solves their respective puzzle first defines which transactions <b>152</b> are included in the next new block <b>151</b><i>n</i>, and the current pool <b>154</b> of unmined transactions is updated. The miners <b>104</b>M then continue to race to create a block from the newly defined outstanding pool <b>154</b>, and so forth. A protocol also exists for resolving any &#x201c;fork&#x201d; that may arise, which is where two miners <b>104</b>M solve their puzzle within a very short time of one another such that a conflicting view of the blockchain gets propagated. In short, whichever prong of the fork grows the longest becomes the definitive blockchain <b>150</b>.</p><p id="p-0065" num="0066">In most blockchains the winning miner <b>104</b>M is automatically rewarded with a special kind of new transaction which creates a new quantity of the digital asset out of nowhere (as opposed to normal transactions which transfer an amount of the digital asset from one user to another). Hence the winning node is said to have &#x201c;mined&#x201d; a quantity of the digital asset. This special type of transaction is sometime referred to as a &#x201c;generation&#x201d; transaction. It automatically forms part of the new block <b>151</b><i>n</i>. This reward gives an incentive for the miners <b>104</b>M to participate in the proof-of-work race. Often a regular (non-generation) transaction <b>152</b> will also specify an additional transaction fee in one of its outputs, to further reward the winning miner <b>104</b>M that created the block <b>151</b><i>n </i>in which that transaction was included.</p><p id="p-0066" num="0067">Due to the computational resource involved in mining, typically at least each of the miner nodes <b>104</b>M takes the form of a server comprising one or more physical server units, or even whole a data centre. Each forwarding node <b>104</b>M and/or storage node <b>104</b>S may also take the form of a server or data centre. However in principle any given node <b>104</b> could take the form of a user terminal or a group of user terminals networked together.</p><p id="p-0067" num="0068">The memory of each node <b>104</b> stores software configured to run on the processing apparatus of the node <b>104</b> in order to perform its respective role or roles and handle transactions <b>152</b> in accordance with the node protocol. It will be understood that any action attributed herein to a node <b>104</b> may be performed by the software run on the processing apparatus of the respective computer equipment. The node software may be implemented in one or more applications at the application layer, or a lower layer such as the operating system layer or a protocol layer, or any combination of these. Also, the term &#x201c;blockchain&#x201d; as used herein is a generic term that refers to the kind of technology in general, and does not limit to any particular proprietary blockchain, protocol or service.</p><p id="p-0068" num="0069">Also connected to the network <b>101</b> is the computer equipment <b>102</b> of each of a plurality of parties <b>103</b> in the role of consuming users. These act as payers and payees in transactions but do not necessarily participate in mining or propagating transactions on behalf of other parties. They do not necessarily run the mining protocol. Two parties <b>103</b> and their respective equipment <b>102</b> are shown for illustrative purposes: a first party <b>103</b><i>a </i>and his/her respective computer equipment <b>102</b><i>a</i>, and a second party <b>103</b><i>b </i>and his/her respective computer equipment <b>102</b><i>b</i>. It will be understood that many more such parties <b>103</b> and their respective computer equipment <b>102</b> may be present and participating in the system, but for convenience they are not illustrated. Each party <b>103</b> may be an individual or an organization. Purely by way of illustration the first party <b>103</b><i>a </i>is referred to herein as Alice and the second party <b>103</b><i>b </i>is referred to as Bob, but it will be appreciated that this is not limiting and any reference herein to Alice or Bob may be replaced with &#x201c;first party&#x201d; and &#x201c;second &#x201c;party&#x201d; respectively.</p><p id="p-0069" num="0070">The computer equipment <b>102</b> of each party <b>103</b> comprises respective processing apparatus comprising one or more processors, e.g. one or more CPUs, GPUs, other accelerator processors, application specific processors, and/or FPGAs. The computer equipment <b>102</b> of each party <b>103</b> further comprises memory, i.e. computer-readable storage in the form of a non-transitory computer-readable medium or media. This memory may comprise one or more memory units employing one or more memory media, e.g. a magnetic medium such as hard disk; an electronic medium such as an SSD, flash memory or EEPROM; and/or an optical medium such as an optical disc drive. The memory on the computer equipment <b>102</b> of each party <b>103</b> stores software comprising a respective instance of at least one client application <b>105</b> arranged to run on the processing apparatus. It will be understood that any action attributed herein to a given party <b>103</b> may be performed using the software run on the processing apparatus of the respective computer equipment <b>102</b>. The computer equipment <b>102</b> of each party <b>103</b> comprises at least one user terminal, e.g. a desktop or laptop computer, a tablet, a smartphone, or a wearable device such as a smartwatch. The computer equipment <b>102</b> of a given party <b>103</b> may also comprise one or more other networked resources, such as cloud computing resources accessed via the user terminal.</p><p id="p-0070" num="0071">The client application <b>105</b> may be initially provided to the computer equipment <b>102</b> of any given party <b>103</b> on suitable computer-readable storage medium or media, e.g. downloaded from a server, or provided on a removable storage device such as a removable SSD, flash memory key, removable EEPROM, removable magnetic disk drive, magnetic floppy disk or tape, optical disk such as a CD or DVD ROM, or a removable optical drive, etc.</p><p id="p-0071" num="0072">The client application <b>105</b> comprises at least a &#x201c;wallet&#x201d; function. This has two main functionalities. One of these is to enable the respective user party <b>103</b> to create, sign and send transactions <b>152</b> to be propagated throughout the network of nodes <b>104</b> and thereby included in the blockchain <b>150</b>. The other is to report back to the respective party the amount of the digital asset that he or she currently owns. In an output-based system, this second functionality comprises collating the amounts defined in the outputs of the various <b>152</b> transactions scattered throughout the blockchain <b>150</b> that belong to the party in question.</p><p id="p-0072" num="0073">Note: whilst the various client functionality may be described as being integrated into a given client application <b>105</b>, this is not necessarily limiting and instead any client functionality described herein may instead be implemented in a suite of two or more distinct applications, e.g. interfacing via an API, or one being a plug-in to the other. More generally the client functionality could be implemented at the application layer or a lower layer such as the operating system, or any combination of these. The following will be described in terms of a client application <b>105</b> but it will be appreciated that this is not limiting.</p><p id="p-0073" num="0074">The instance of the client application or software <b>105</b> on each computer equipment <b>102</b> is operatively coupled to at least one of the forwarding nodes <b>104</b>F of the P2P network <b>106</b>. This enables the wallet function of the client <b>105</b> to send transactions <b>152</b> to the network <b>106</b>. The client <b>105</b> is also able to contact one, some or all of the storage nodes <b>104</b> in order to query the blockchain <b>150</b> for any transactions of which the respective party <b>103</b> is the recipient (or indeed inspect other parties' transactions in the blockchain <b>150</b>, since in embodiments the blockchain <b>150</b> is a public facility which provides trust in transactions in part through its public visibility). The wallet function on each computer equipment <b>102</b> is configured to formulate and send transactions <b>152</b> according to a transaction protocol. Each node <b>104</b> runs software configured to validate transactions <b>152</b> according to a node protocol, and in the case of the forwarding nodes <b>104</b>F to forward transactions <b>152</b> in order to propagate them throughout the network <b>106</b>. The transaction protocol and node protocol correspond to one another, and a given transaction protocol goes with a given node protocol, together implementing a given transaction model. The same transaction protocol is used for all transactions <b>152</b> in the blockchain <b>150</b> (though the transaction protocol may allow different subtypes of transaction within it). The same node protocol is used by all the nodes <b>104</b> in the network <b>106</b> (though it many handle different subtypes of transaction differently in accordance with the rules defined for that subtype, and also different nodes may take on different roles and hence implement different corresponding aspects of the protocol).</p><p id="p-0074" num="0075">As mentioned, the blockchain <b>150</b> comprises a chain of blocks <b>151</b>, wherein each block <b>151</b> comprises a set of one or more transactions <b>152</b> that have been created by a proof-of-work process as discussed previously. Each block <b>151</b> also comprises a block pointer <b>155</b> pointing back to the previously created block <b>151</b> in the chain so as to define a sequential order to the blocks <b>151</b>. The blockchain <b>150</b> also comprises a pool of valid transactions <b>154</b> waiting to be included in a new block by the proof-of-work process. Each transaction <b>152</b> (other than a generation transaction) comprises a pointer back to a previous transaction so as to define an order to sequences of transactions (N.B. sequences of transactions <b>152</b> are allowed to branch). The chain of blocks <b>151</b> goes all the way back to a genesis block (Gb) <b>153</b> which was the first block in the chain. One or more original transactions <b>152</b> early on in the chain <b>150</b> pointed to the genesis block <b>153</b> rather than a preceding transaction.</p><p id="p-0075" num="0076">When a given party <b>103</b>, say Alice, wishes to send a new transaction <b>152</b><i>j </i>to be included in the blockchain <b>150</b>, then she formulates the new transaction in accordance with the relevant transaction protocol (using the wallet function in her client application <b>105</b>). She then sends the transaction <b>152</b> from the client application <b>105</b> to one of the one or more forwarding nodes <b>104</b>F to which she is connected. E.g. this could be the forwarding node <b>104</b>F that is nearest or best connected to Alice's computer <b>102</b>. When any given node <b>104</b> receives a new transaction <b>152</b><i>j</i>, it handles it in accordance with the node protocol and its respective role. This comprises first checking whether the newly received transaction <b>152</b><i>j </i>meets a certain condition for being &#x201c;valid&#x201d;, examples of which will be discussed in more detail shortly. In some transaction protocols, the condition for validation may be configurable on a per-transaction basis by scripts included in the transactions <b>152</b>. Alternatively the condition could simply be a built-in feature of the node protocol, or be defined by a combination of the script and the node protocol.</p><p id="p-0076" num="0077">On condition that the newly received transaction <b>152</b><i>j </i>passes the test for being deemed valid (i.e. on condition that it is &#x201c;validated&#x201d;), any storage node <b>104</b>S that receives the transaction <b>152</b><i>j </i>will add the new validated transaction <b>152</b> to the pool <b>154</b> in the copy of the blockchain <b>150</b> maintained at that node <b>104</b>S. Further, any forwarding node <b>104</b>F that receives the transaction <b>152</b><i>j </i>will propagate the validated transaction <b>152</b> onward to one or more other nodes <b>104</b> in the P2P network <b>106</b>. Since each forwarding node <b>104</b>F applies the same protocol, then assuming the transaction <b>152</b><i>j </i>is valid, this means it will soon be propagated throughout the whole P2P network <b>106</b>.</p><p id="p-0077" num="0078">Once admitted to the pool <b>154</b> in the copy of the blockchain <b>150</b> maintained at one or more storage nodes <b>104</b>, then miner nodes <b>104</b>M will start competing to solve the proof-of-work puzzle on the latest version of the pool <b>154</b> including the new transaction <b>152</b> (other miners <b>104</b>M may still be trying to solve the puzzle based on the old view of the pool <b>154</b>, but whoever gets there first will define where the next new block <b>151</b> ends and the new pool <b>154</b> starts, and eventually someone will solve the puzzle for a part of the pool <b>154</b> which includes Alice's transaction <b>152</b><i>j</i>). Once the proof-of-work has been done for the pool <b>154</b> including the new transaction <b>152</b><i>j</i>, it immutably becomes part of one of the blocks <b>151</b> in the blockchain <b>150</b>. Each transaction <b>152</b> comprises a pointer back to an earlier transaction, so the order of the transactions is also immutably recorded.</p><p id="p-0078" num="0079">Different nodes <b>104</b> may receive different instances of a given transaction first and therefore have conflicting views of which instance is &#x2018;valid&#x2019; before one instance is mined into a block <b>150</b>, at which point all nodes <b>104</b> agree that the mined instance is the only valid instance. If a node <b>104</b> accepts one instance as valid, and then discovers that a second instance has been recorded in the blockchain <b>150</b> then that node <b>104</b> must accept this and will discard (i.e. treat as invalid) the unmined instance which it had initially accepted.</p><p id="p-0079" num="0080">UTXO-Based Model</p><p id="p-0080" num="0081"><figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates an example transaction protocol. This is an example of an UTXO-based protocol. A transaction <b>152</b> (abbreviated &#x201c;Tx&#x201d;) is the fundamental data structure of the blockchain <b>150</b> (each block <b>151</b> comprising one or more transactions <b>152</b>). The following will be described by reference to an output-based or &#x201c;UTXO&#x201d; based protocol. However, this not limiting to all possible embodiments.</p><p id="p-0081" num="0082">In a UTXO-based model, each transaction (&#x201c;Tx&#x201d;) <b>152</b> comprises a data structure comprising one or more inputs <b>202</b>, and one or more outputs <b>203</b>. Each output <b>203</b> may comprise an unspent transaction output (UTXO), which can be used as the source for the input <b>202</b> of another new transaction (if the UTXO has not already been redeemed). The UTXO specifies an amount of a digital asset (a store of value). It may also contain the transaction ID of the transaction from which it came, amongst other information. The transaction data structure may also comprise a header <b>201</b>, which may comprise an indicator of the size of the input field(s) <b>202</b> and output field(s) <b>203</b>. The header <b>201</b> may also include an ID of the transaction. In embodiments the transaction ID is the hash of the transaction data (excluding the transaction ID itself) and stored in the header <b>201</b> of the raw transaction <b>152</b> submitted to the miners <b>104</b>M.</p><p id="p-0082" num="0083">Say Alice <b>103</b><i>a </i>wishes to create a transaction <b>152</b><i>j </i>transferring an amount of the digital asset in question to Bob <b>103</b><i>b</i>. In <figref idref="DRAWINGS">FIG. <b>2</b></figref> Alice's new transaction <b>152</b><i>j </i>is labelled &#x201c;Tx<sub>1</sub>&#x201d;. It takes an amount of the digital asset (digital asset value) that is locked to Alice in the output <b>203</b> of a preceding transaction <b>152</b><i>i </i>in the sequence, and transfers at least some of this to Bob. The preceding transaction <b>152</b><i>i </i>is labelled &#x201c;Tx<sub>0</sub>&#x201d; in <figref idref="DRAWINGS">FIG. <b>2</b></figref>. Tx<sub>0 </sub>and Tx<sub>1 </sub>are just an arbitrary labels. They do not necessarily mean that Tx<sub>0 </sub>is the first transaction in the blockchain <b>151</b>, nor that Tx<sub>1 </sub>is the immediate next transaction in the pool <b>154</b>. Tx<sub>1 </sub>could point back to any preceding (i.e. antecedent) transaction that still has an unspent output <b>203</b> locked to Alice.</p><p id="p-0083" num="0084">The preceding transaction Tx<sub>0 </sub>may already have been validated and included in the blockchain <b>150</b> at the time when Alice creates her new transaction Tx<sub>1</sub>, or at least by the time she sends it to the network <b>106</b>. It may already have been included in one of the blocks <b>151</b> at that time, or it may be still waiting in the pool <b>154</b> in which case it will soon be included in a new block <b>151</b>. Alternatively Tx<sub>0 </sub>and Tx<sub>1 </sub>could be created and sent to the network <b>102</b> together, or Tx<sub>0 </sub>could even be sent after Tx<sub>1 </sub>if the node protocol allows for buffering &#x201c;orphan&#x201d; transactions. The terms &#x201c;preceding&#x201d; and &#x201c;subsequent&#x201d; as used herein in the context of the sequence of transactions refer to the order of the transactions in the sequence as defined by the transaction pointers specified in the transactions (which transaction points back to which other transaction, and so forth). They could equally be replaced with &#x201c;predecessor&#x201d; and &#x201c;successor&#x201d;, or &#x201c;antecedent&#x201d; and &#x201c;descendant&#x201d;, &#x201c;parent&#x201d; and &#x201c;child&#x201d;, or such like. It does not necessarily imply an order in which they are created, sent to the network <b>106</b>, or arrive at any given node <b>104</b>. Nevertheless, a subsequent transaction (the descendent transaction or &#x201c;child&#x201d;) which points to a preceding transaction (the antecedent transaction or &#x201c;parent&#x201d;) will not be validated until and unless the parent transaction is validated. A child that arrives at a node <b>104</b> before its parent is considered an orphan. It may be discarded or buffered for a certain time to wait for the parent, depending on the node protocol and/or miner behaviour.</p><p id="p-0084" num="0085">One of the one or more outputs <b>203</b> of the preceding transaction Tx<sub>0 </sub>comprises a particular UTXO, labelled here UTXO<sub>0</sub>. Each UTXO comprises a value specifying an amount of the digital asset represented by the UTXO, and a locking script which defines a condition which must be met by an unlocking script in the input <b>202</b> of a subsequent transaction in order for the subsequent transaction to be validated, and therefore for the UTXO to be successfully redeemed. Typically the locking script locks the amount to a particular party (the beneficiary of the transaction in which it is included). I.e. the locking script defines an unlocking condition, typically comprising a condition that the unlocking script in the input of the subsequent transaction comprises the cryptographic signature of the party to whom the preceding transaction is locked.</p><p id="p-0085" num="0086">The locking script (aka scriptPubKey) is a piece of code written in the domain specific language recognized by the node protocol. A particular example of such a language is called &#x201c;Script&#x201d; (capital S). The locking script specifies what information is required to spend a transaction output <b>203</b>, for example the requirement of Alice's signature. Unlocking scripts appear in the outputs of transactions. The unlocking script (aka scriptSig) is a piece of code written the domain specific language that provides the information required to satisfy the locking script criteria. For example, it may contain Bob's signature. Unlocking scripts appear in the input <b>202</b> of transactions.</p><p id="p-0086" num="0087">So in the example illustrated, UTXO<sub>0 </sub>in the output <b>203</b> of Tx<sub>0 </sub>comprises a locking script [Checksig P<sub>A</sub>] which requires a signature Sig P<sub>A </sub>of Alice in order for UTXO<sub>0 </sub>to be redeemed (strictly, in order for a subsequent transaction attempting to redeem UTXO<sub>0 </sub>to be valid). [Checksig P<sub>A</sub>] contains the public key P<sub>A </sub>from a public-private key pair of Alice. The input <b>202</b> of Tx<sub>1 </sub>comprises a pointer pointing back to Tx<sub>1 </sub>(e.g. by means of its transaction ID, TxID<sub>0</sub>, which in embodiments is the hash of the whole transaction Tx<sub>0</sub>). The input <b>202</b> of Tx<sub>1 </sub>comprises an index identifying UTXO<sub>0 </sub>within Tx<sub>0</sub>, to identify it amongst any other possible outputs of Tx<sub>0</sub>. The input <b>202</b> of Tx<sub>1 </sub>further comprises an unlocking script &#x3c;Sig P<sub>A</sub>&#x3e; which comprises a cryptographic signature of Alice, created by Alice applying her private key from the key pair to a predefined portion of data (sometimes called the &#x201c;message&#x201d; in cryptography). What data (or &#x201c;message&#x201d;) needs to be signed by Alice to provide a valid signature may be defined by the locking script, or by the node protocol, or by a combination of these.</p><p id="p-0087" num="0088">When the new transaction Tx<sub>1 </sub>arrives at a node <b>104</b>, the node applies the node protocol. This comprises running the locking script and unlocking script together to check whether the unlocking script meets the condition defined in the locking script (where this condition may comprise one or more criteria). In embodiments this involves concatenating the two scripts:</p><p id="p-0088" num="0089">&#x3c;Sig P<sub>A</sub>&#x3e; &#x3c;P<sub>A</sub>&#x3e;&#x2225;[Checksig P<sub>A</sub>]</p><p id="p-0089" num="0090">where &#x201c;&#x2225;&#x201d; represents a concatenation and &#x201c;&#x3c; . . . &#x3e;&#x201d; means place the data on the stack, and &#x201c;[ . . . ]&#x201d; is a function comprised by the unlocking script (in this example a stack-based language). Equivalently the scripts may be run one after the other, with a common stack, rather than concatenating the scripts. Either way, when run together, the scripts use the public key P<sub>A </sub>of Alice, as included in the locking script in the output of Tx<sub>0</sub>, to authenticate that the locking script in the input of Tx<sub>1 </sub>contains the signature of Alice signing the expected portion of data. The expected portion of data itself (the &#x201c;message&#x201d;) also needs to be included in Tx<sub>0 </sub>order to perform this authentication. In embodiments the signed data comprises the whole of Tx<sub>0 </sub>(so a separate element does to need to be included specifying the signed portion of data in the clear, as it is already inherently present).</p><p id="p-0090" num="0091">The details of authentication by public-private cryptography will be familiar to a person skilled in the art. Basically, if Alice has signed a message by encrypting it with her private key, then given Alice's public key and the message in the clear (the unencrypted message), another entity such as a node <b>104</b> is able to authenticate that the encrypted version of the message must have been signed by Alice. Signing typically comprises hashing the message, signing the hash, and tagging this onto the clear version of the message as a signature, thus enabling any holder of the public key to authenticate the signature. Note therefore that any reference herein to signing a particular piece of data or part of a transaction, or such like, can in embodiments mean signing a hash of that piece of data or part of the transaction.</p><p id="p-0091" num="0092">If the unlocking script in Tx<sub>1 </sub>meets the one or more conditions specified in the locking script of Tx<sub>0 </sub>(so in the example shown, if Alice's signature is provided in Tx<sub>1 </sub>and authenticated), then the node <b>104</b> deems Tx<sub>1 </sub>valid. If it is a mining node <b>104</b>M, this means it will add it to the pool of transactions <b>154</b> awaiting proof-of-work. If it is a forwarding node <b>104</b>F, it will forward the transaction Tx<sub>1 </sub>to one or more other nodes <b>104</b> in the network <b>106</b>, so that it will be propagated throughout the network. Once Tx<sub>1 </sub>has been validated and included in the blockchain <b>150</b>, this defines UTXO<sub>0 </sub>from Tx<sub>0 </sub>as spent. Note that Tx<sub>1 </sub>can only be valid if it spends an unspent transaction output <b>203</b>. If it attempts to spend an output that has already been spent by another transaction <b>152</b>, then Tx<sub>1 </sub>will be invalid even if all the other conditions are met. Hence the node <b>104</b> also needs to check whether the referenced UTXO in the preceding transaction Tx<sub>0 </sub>is already spent (has already formed a valid input to another valid transaction). This is one reason why it is important for the blockchain <b>150</b> to impose a defined order on the transactions <b>152</b>. In practice a given node <b>104</b> may maintain a separate database marking which UTXOs <b>203</b> in which transactions <b>152</b> have been spent, but ultimately what defines whether a UTXO has been spent is whether it has already formed a valid input to another valid transaction in the blockchain <b>150</b>.</p><p id="p-0092" num="0093">If the total amount specified in all the outputs <b>203</b> of a given transaction <b>152</b> is greater than the total amount pointed to by all its inputs <b>202</b>, this is another basis for invalidity in most transaction models. Therefore such transactions will not be propagated nor mined into blocks <b>151</b>.</p><p id="p-0093" num="0094">Note that in UTXO-based transaction models, a given UTXO needs to be spent as a whole. It cannot &#x201c;leave behind&#x201d; a fraction of the amount defined in the UTXO as spent while another fraction is spent. However the amount from the UTXO can be split between multiple outputs of the next transaction. E.g. the amount defined in UTXO<sub>0 </sub>in Tx<sub>0 </sub>can be split between multiple UTXOs in Tx<sub>1</sub>. Hence if Alice does not want to give Bob all of the amount defined in UTXO<sub>0</sub>, she can use the remainder to give herself change in a second output of Tx<sub>1</sub>, or pay another party.</p><p id="p-0094" num="0095">In practice Alice will also usually need to include a fee for the winning miner, because nowadays the reward of the generation transaction alone is not typically sufficient to motivate mining. If Alice does not include a fee for the miner, Tx<sub>0 </sub>will likely be rejected by the miner nodes <b>104</b>M, and hence although technically valid, it will still not be propagated and included in the blockchain <b>150</b> (the miner protocol does not force miners <b>104</b>M to accept transactions <b>152</b> if they don't want). In some protocols, the mining fee does not require its own separate output <b>203</b> (i.e. does not need a separate UTXO). Instead any different between the total amount pointed to by the input(s) <b>202</b> and the total amount of specified in the output(s) <b>203</b> of a given transaction <b>152</b> is automatically given to the winning miner <b>104</b>. E.g. say a pointer to UTXO<sub>0 </sub>is the only input to Tx<sub>1</sub>, and Tx<sub>1 </sub>has only one output UTXO<sub>1</sub>. If the amount of the digital asset specified in UTXO<sub>0 </sub>is greater than the amount specified in UTXO<sub>1</sub>, then the difference automatically goes to the winning miner <b>104</b>M. Alternatively or additionally however, it is not necessarily excluded that a miner fee could be specified explicitly in its own one of the UTXOs <b>203</b> of the transaction <b>152</b>.</p><p id="p-0095" num="0096">Alice and Bob's digital assets consist of the unspent UTXOs locked to them in any transactions <b>152</b> anywhere in the blockchain <b>150</b>. Hence typically, the assets of a given party <b>103</b> are scattered throughout the UTXOs of various transactions <b>152</b> throughout the blockchain <b>150</b>. There is no one number stored anywhere in the blockchain <b>150</b> that defines the total balance of a given party <b>103</b>. It is the role of the wallet function in the client application <b>105</b> to collate together the values of all the various UTXOs which are locked to the respective party and have not yet been spent in another onward transaction. It can do this by querying the copy of the blockchain <b>150</b> as stored at any of the storage nodes <b>104</b>S, e.g. the storage node <b>104</b>S that is closest or best connected to the respective party's computer equipment <b>102</b>.</p><p id="p-0096" num="0097">Note that the script code is often represented schematically (i.e. not the exact language). For example, one may write [Checksig P<sub>A</sub>] to mean [Checksig P<sub>A</sub>]=OP_DUP OP_HASH160&#x3c;H(P<sub>A</sub>)&#x3e;OP_EQUALVERIFY OP_CHECKSIG. &#x201c;OP_. . . &#x201d; refers to a particular opcode of the Script language. OP_CHECKSIG (also called &#x201c;Checksig&#x201d;) is a Script opcode that takes two inputs (signature and public key) and verifies the signature's validity using the Elliptic Curve Digital Signature Algorithm (ECDSA). At runtime, any occurrences of signature (&#x2018;sig&#x2019;) are removed from the script but additional requirements, such as a hash puzzle, remain in the transaction verified by the &#x2018;sig&#x2019; input. As another example, OP_RETURN is an opcode of the Script language for creating an unspendable output of a transaction that can store metadata within the transaction, and thereby record the metadata immutably in the blockchain <b>150</b>. E.g. the metadata could comprise a document which it is desired to store in the blockchain.</p><p id="p-0097" num="0098">The signature P<sub>A </sub>is a digital signature. In embodiments this is based on the ECDSA using the elliptic curve secp256k1. A digital signature signs a particular piece of data. In embodiments, for a given transaction the signature will sign part of the transaction input, and all or part of the transaction output. The particular parts of the outputs it signs depends on the SIGHASH flag. The SIGHASH flag is a 4-byte code included at the end of a signature to select which outputs are signed (and thus fixed at the time of signing).</p><p id="p-0098" num="0099">The locking script is sometimes called &#x201c;scriptPubKey&#x201d; referring to the fact that it comprises the public key of the party to whom the respective transaction is locked. The unlocking script is sometimes called &#x201c;scriptSig&#x201d; referring to the fact that it supplies the corresponding signature. However, more generally it is not essential in all applications of a blockchain <b>150</b> that the condition for a UTXO to be redeemed comprises authenticating a signature. More generally the scripting language could be used to define any one or more conditions. Hence the more general terms &#x201c;locking script&#x201d; and &#x201c;unlocking script&#x201d; may be preferred.</p><p id="p-0099" num="0100">Sequence Numbers and Lock Times</p><p id="p-0100" num="0101"><figref idref="DRAWINGS">FIG. <b>2</b>A</figref> shows a schematic illustration of a second transaction <b>152</b>-<i>j</i>-<b>1</b> that has a specific use in the context of a particular form of payment channel.</p><p id="p-0101" num="0102">The second transaction <b>152</b>-<i>j</i>-<b>1</b> is shown to comprise at least one input <b>202</b>-<i>j</i>-<b>1</b>. The input <b>202</b>-<i>j</i>-<b>1</b>&#x2014;in addition to containing a pointer to an output <b>203</b>-<i>i </i>of a first transaction <b>151</b>-<i>i </i>and an unlocking script <b>502</b>-<i>j</i>-<b>1</b> for unlocking that output <b>203</b>-<i>i</i>, i.e. which meets (all of) the condition(s) specified in a locking script <b>503</b>-<i>i </i>of that output <b>203</b>-<i>i</i>&#x2014;has a sequence number nS. The output <b>203</b>-<i>i </i>of the first transaction <b>151</b>-<i>i </i>contains a value denoted as v (digital asset value), which defines an amount of digital asset conveyed by the output <b>203</b>-<i>i</i>. That same notation is used elsewhere in this description.</p><p id="p-0102" num="0103">The second transaction <b>152</b>-<i>j</i>-<b>1</b> also has a defined lock time T<sub>L </sub>and the second transaction <b>152</b>-<i>j</i>-<b>1</b> cannot be accepted as valid until its lock time T<sub>L </sub>has expired. Assuming it meets all other requirements for validity, once the lock time T<sub>L </sub>has expired, the second transaction <b>152</b>-<i>j</i>-<b>1</b> will only be accepted as valid if the blockchain network <b>101</b> has not received any other &#x201c;conflicting&#x201d; transaction which is valid and has a higher sequence number. Two transactions are said to &#x201c;conflict&#x201d; if they both have at least one input which spends the same output (more precisely, if they both have at least one input containing a pointer to the same output and a locking script which satisfies the one or more conditions defined in a locking script of that output, and both satisfy any other validity requirements&#x2014;i.e. but for the presence of the transaction having the higher sequence number, the transaction with the lower sequence number would be accepted as valid).</p><p id="p-0103" num="0104">By way of example, <figref idref="DRAWINGS">FIG. <b>2</b>A</figref> shows a third transaction <b>151</b><i>j</i>-<b>2</b> comprising at least one input <b>202</b>-<i>j</i>-<b>2</b> which contains a pointer to the same output <b>503</b>-<i>i </i>of the first transaction <b>151</b>-<i>i </i>and an unlocking script <b>502</b>-<i>j</i>-<b>2</b> which also satisfies all of the condition(s) specified in the locking script <b>503</b>-<i>i </i>of that output <b>203</b>-<i>i</i>. The third transaction <b>151</b>-<i>j</i>-<b>2</b> has a lock time T<sub>L</sub>&#x2032; (which may or may not be the same as the lock time T<sub>L </sub>of the second transaction <b>152</b>-<i>j</i>-<b>1</b>), and the input <b>202</b>-<i>j</i>-<b>2</b> of the third transaction <b>151</b>-<i>j</i>-<b>2</b> has a sequence number nS&#x2032;. If both the second and third transactions <b>151</b>-<i>j</i>-<b>1</b>, <b>151</b>-<i>j</i>-<b>2</b> are submitted to the blockchain network <b>101</b> after their respective lock times T<sub>L</sub>, T<sub>L</sub>&#x2032; have expired, only the one with the highest sequence number will be accepted as valid (unless, of course, another conflicting transaction with even higher sequence number has been submitted).</p><p id="p-0104" num="0105">In the present example, the second and third transactions <b>152</b>-<i>j</i>-<b>1</b>, <b>152</b>-<i>j</i>-<b>2</b> are shown to each have at least two outputs, which in turn have digital asset values v<sub>1 </sub>and v<sub>2 </sub>respectively in the case of the second transaction <b>152</b>-<i>j</i>-<b>1</b>, and digital asset values v<sub>1</sub>&#x2032; and v<sub>2</sub>&#x2032; respectively in the case of the third transaction <b>152</b>-<i>j</i>-<b>2</b>. Although not depicted in <figref idref="DRAWINGS">FIG. <b>2</b>A</figref>, each of those outputs will typically have its own unlocking script which must be satisfied in order to release the corresponding amount of digital asset. For example, the two outputs of each of the second and third transactions <b>151</b>-<i>j</i>-<b>1</b>, <b>151</b>-<i>j</i>-<b>2</b> may have the effect of distributing the amount of digital asset conveyed by the output <b>203</b>-<i>i </i>of the first transaction <b>152</b>-<i>i </i>(as defined by v) between two different parties, where:<ul id="ul0003" list-style="none">    <li id="ul0003-0001" num="0000">    <ul id="ul0004" list-style="none">        <li id="ul0004-0001" num="0106">if the second transaction <b>151</b>-<i>j</i>-<b>1</b> is valid, the first party receives the amount of digital asset defined by v<sub>1 </sub>and the second party receives the amount of digital asset defined by v<sub>2</sub>; whereas</li>        <li id="ul0004-0002" num="0107">if the third transaction <b>151</b>-<i>j</i>-<b>2</b> is valid, the first party receives the amount of digital asset defined by v<sub>1</sub>&#x2032; and the second party receives the amount of digital asset defined by v<sub>2</sub>&#x2032;.</li>    </ul>    </li></ul></p><p id="p-0105" num="0108">For example, the first transaction <b>151</b>-<i>i </i>may be a special &#x201c;funding transaction&#x201d; having certain properties that are described later with reference, in particular, to <figref idref="DRAWINGS">FIGS. <b>6</b>A and <b>6</b>B</figref>. A payment channel can then be used as a basis for negotiating a distribution of digital asset conveyed by the funding transaction between two or more parties, by creating successive spending transactions, with future lock times and incrementing sequence numbers, which distribute that amount in different way (as defined by the digital asset values of the outputs of the spending transactions).</p><p id="p-0106" num="0109">Side Channel</p><p id="p-0107" num="0110"><figref idref="DRAWINGS">FIG. <b>3</b></figref> shows a further system <b>100</b> for implementing a blockchain <b>150</b>. The system <b>100</b> is substantially the same as that described in relation to <figref idref="DRAWINGS">FIG. <b>1</b></figref> except that additional communication functionality is involved. The client application on each of Alice and Bob's computer equipment <b>102</b><i>a</i>, <b>120</b><i>b</i>, respectively, comprises additional communication functionality. That is, it enables Alice <b>103</b><i>a </i>to establish a separate side channel <b>301</b> with Bob <b>103</b><i>b </i>(at the instigation of either party or a third party). The side channel <b>301</b> enables exchange of data separately from the P2P network. Such communication is sometimes referred to as &#x201c;off-chain&#x201d;. For instance this may be used to exchange a transaction <b>152</b> between Alice and Bob without the transaction (yet) being published onto the network P2P <b>106</b> or making its way onto the chain <b>150</b>, until one of the parties chooses to broadcast it to the network <b>106</b>. Alternatively or additionally, the side channel <b>301</b> may be used to exchange any other transaction related data, such as keys, negotiated amounts or terms, data content, etc.</p><p id="p-0108" num="0111">The side channel <b>301</b> may be established via the same packet-switched network <b>101</b> as the P2P overlay network <b>106</b>. Alternatively or additionally, the side channel <b>301</b> may be established via a different network such as a mobile cellular network, or a local area network such as a local wireless network, or even a direct wired or wireless link between Alice and Bob's devices <b>102</b><i>a</i>, <b>102</b><i>b</i>. Generally, the side channel <b>301</b> as referred to anywhere herein may comprise any one or more links via one or more networking technologies or communication media for exchanging data &#x201c;off-chain&#x201d;, i.e. separately from the P2P overlay network <b>106</b>. Where more than one link is used, then the bundle or collection of off-chain links as a whole may be referred to as the side channel <b>301</b>. Note therefore that if it is said that Alice and Bob exchange certain pieces of information or data, or such like, over the side channel <b>301</b>, then this does not necessarily imply all these pieces of data have to be send over exactly the same link or even the same type of network.</p><p id="p-0109" num="0112"><figref idref="DRAWINGS">FIG. <b>3</b>A</figref> shows a variation of the system of <figref idref="DRAWINGS">FIG. <b>3</b></figref> with at least three parties, one of which/whom is a &#x201c;trusted oracle&#x201d; <b>102</b><i>o</i>. In this example, the trusted oracle takes the form of a set of oracle computer equipment <b>102</b><i>o </i>running client software <b>105</b><i>o</i>&#x2014; of the kind described above and in further detail below with reference to <figref idref="DRAWINGS">FIG. <b>4</b></figref>&#x2014;that operates autonomously to carry out the functions described below (without any substantive human oversight). Alternatively, the trusted oracle may be a human user operating similar computer equipment <b>102</b><i>o</i>, in which case those functions are carries out at the oracle computer equipment <b>102</b><i>o </i>with at least an element of human oversight and/or control. Respective side channels between each pair of parties are provided, denoted by reference numerals <b>301</b> (between Alice <b>103</b><i>a </i>and Bob <b>103</b><i>b</i>), <b>302</b> (between Alice <b>103</b><i>a </i>and the oracle <b>102</b><i>o</i>) and <b>303</b> (Between Bob <b>103</b><i>b </i>and the oracle <b>102</b><i>o</i>).</p><p id="p-0110" num="0113"><figref idref="DRAWINGS">FIG. <b>3</b>B</figref> shows a further variation, again with at least three parties, but in this case at least two of the parties are trusted oracles <b>102</b><i>o</i>-<b>1</b>, <b>102</b><i>o</i>-<b>2</b>. In this particular example, the second trusted oracle <b>102</b><i>o</i>-<b>2</b> essentially assumes Bob's role, and all of the above description pertaining to Bob <b>103</b><i>a </i>and his computer equipment <b>102</b><i>b </i>applies equally to the second oracle <b>102</b><i>o</i>-<b>1</b>.</p><p id="p-0111" num="0114">The role of a trusted oracle (or oracles) in the context of a blockchain payment channel is described in detail below with reference to particular examples.</p><p id="p-0112" num="0115">Client Software</p><p id="p-0113" num="0116"><figref idref="DRAWINGS">FIG. <b>4</b>A</figref> illustrates an example implementation of the client application <b>105</b> for implementing embodiments of the presently disclosed scheme. The client application <b>105</b> comprises a transaction engine <b>401</b> and a user interface (UI) layer <b>402</b>. The transaction engine <b>401</b> is configured to implement the underlying transaction-related functionality of the client <b>105</b>, such as to formulate transactions <b>152</b>, receive and/or send transactions and/or other data over the side channel <b>301</b>, and/or send transactions to be propagated through the P2P network <b>106</b>, in accordance with the schemes discussed above and as discussed in further detail shortly. In accordance with embodiments disclosed herein, the transaction engine <b>401</b> of the client <b>105</b> of at least one party to a payment channel (who/which may or may not be a trusted oracle) comprises payment channel logic <b>403</b> for generating and signing payment channel transactions which can be sent to another party or parties for completion as needed, or completed as needed by the same party using information received from another party or parties. This is described in detail later.</p><p id="p-0114" num="0117">The UI layer <b>402</b> is configured to render a user interface via a user input/output (I/O) means of the respective user's computer equipment <b>102</b>, including outputting information to the respective user <b>103</b> via a user output means of the equipment <b>102</b>, and receiving inputs back from the respective user <b>103</b> via a user input means of the equipment <b>102</b>. For example the user output means could comprise one or more display screens (touch or non-touch screen) for providing a visual output, one or more speakers for providing an audio output, and/or one or more haptic output devices for providing a tactile output, etc. The user input means could comprise for example the input array of one or more touch screens (the same or different as that/those used for the output means); one or more cursor-based devices such as mouse, trackpad or trackball; one or more microphones and speech or voice recognition algorithms for receiving a speech or vocal input; one or more gesture-based input devices for receiving the input in the form of manual or bodily gestures; or one or more mechanical buttons, switches or joysticks, etc.</p><p id="p-0115" num="0118">Note: whilst the various functionality herein may be described as being integrated into the same client application <b>105</b>, this is not necessarily limiting and instead they could be implemented in a suite of two or more distinct applications, e.g. one being a plug-in to the other or interfacing via an API (application programming interface). For instance, the functionality of the transaction engine <b>401</b> may be implemented in a separate application than the UI layer <b>402</b>, or the functionality of a given module such as the transaction engine <b>401</b> could be split between more than one application. Nor is it excluded that some or all of the described functionality could be implemented at, say, the operating system layer. Where reference is made anywhere herein to a single or given application <b>105</b>, or such like, it will be appreciated that this is just by way of example, and more generally the described functionality could be implemented in any form of software.</p><p id="p-0116" num="0119">The presence of the UI layer <b>402</b> assumes the computer equipment <b>102</b> is to be operated by a user. Certain parties to a payment channel may in fact be autonomous machine entities, i.e. computer equipment that operates to generate and sign transactions without any (or with minimal) human oversight. In particular, the payment channel logic <b>203</b> may operate with or without human oversight. This applies both to parties who/which are trusted oracles any and party to a payment channel who/which is a not a trusted oracle. With regards to the former, although in the above examples Alice <b>103</b><i>a </i>and Bob <b>103</b><i>b </i>are presented as human users by way of examples, one or both of their roles could be assumed by an autonomous machine(s) (which is to say that one or both of Alice's or Bob's computer equipment <b>105</b><i>a</i>, <b>105</b><i>b </i>could operate autonomously or substantially autonomously).</p><p id="p-0117" num="0120"><figref idref="DRAWINGS">FIG. <b>4</b>C</figref> gives a mock-up of an example of the user interface (UI) <b>470</b> which may be rendered by the UI layer <b>402</b> of the client application <b>105</b><i>a </i>on Alice's equipment <b>102</b><i>a</i>. It will be appreciated that a similar UI may be rendered by the client <b>105</b><i>b </i>on Bob's equipment <b>102</b><i>b</i>, or that of any other party.</p><p id="p-0118" num="0121">By way of illustration <figref idref="DRAWINGS">FIG. <b>4</b>C</figref> shows the UI <b>470</b> from Alice's perspective. The UI <b>470</b> may comprise one or more UI elements <b>471</b>, <b>472</b>, <b>472</b> rendered as distinct UI elements via the user output means.</p><p id="p-0119" num="0122">For example, the UI elements may comprise one or more user-selectable elements <b>471</b> which may be, such as different on-screen buttons, or different options in a menu, or such like. The user input means is arranged to enable the user <b>103</b> (in this case Alice <b>103</b><i>a</i>) to select or otherwise operate one of the options, such as by clicking or touching the UI element on-screen, or speaking a name of the desired option (N.B. the term &#x201c;manual&#x201d; as used herein is meant only to contrast against automatic, and does not necessarily limit to the use of the hand or hands). The options enable the user (Alice) to e.g. display and, where appropriate, sign existing (but perhaps incomplete) payment channel transaction, or in some cases create new payment channel transactions. Alternatively or additionally, the UI elements may comprise one or more data entry fields <b>472</b>, through which the user perform such operation. These data entry fields are rendered via the user output means, e.g. on-screen, and the data can be entered into the fields through the user input means, e.g. a keyboard or touchscreen. Alternatively the data could be received orally for example based on speech recognition.</p><p id="p-0120" num="0123">Alternatively or additionally, the UI elements may comprise one or more information elements <b>453</b> output to output information to the user. E.g. this/these could be rendered on screen or audibly.</p><p id="p-0121" num="0124">It will be appreciated that the particular means of rendering the various UI elements, selecting the options and entering data is not material. The functionality of these UI elements will be discussed in more detail shortly. It will also be appreciated that the UI <b>470</b> shown in <figref idref="DRAWINGS">FIG. <b>4</b>C</figref> is only a schematized mock-up and in practice it may comprise one or more further UI elements, which for conciseness are not illustrated.</p><p id="p-0122" num="0125">Node Software</p><p id="p-0123" num="0126"><figref idref="DRAWINGS">FIG. <b>4</b>B</figref> illustrates an example of the node software <b>450</b> that is run on each node <b>104</b> of the P2P network <b>106</b>, in the example of a UTXO- or output-based model. The node software <b>450</b> comprises a protocol engine <b>451</b>, a script engine <b>452</b>, a stack <b>453</b>, an application-level decision engine <b>454</b>, and a set of one or more blockchain-related functional modules <b>455</b>. At any given node <b>104</b>, these may include any one, two or all three of: a mining module <b>455</b>M, a forwarding module <b>455</b>F and a storing module <b>455</b>S (depending on the role or roles of the node). The protocol engine <b>401</b> is configured to recognize the different fields of a transaction <b>152</b> and process them in accordance with the node protocol. When a transaction <b>152</b><i>j </i>(Tx<sub>j</sub>) is received having an input pointing to an output (e.g. UTXO) of another, preceding transaction <b>152</b><i>i </i>(Tx<sub>m-1</sub>), then the protocol engine <b>451</b> identifies the unlocking script in Tx<sub>j </sub>and passes it to the script engine <b>452</b>. The protocol engine <b>451</b> also identifies and retrieves Tx<sub>i </sub>based on the pointer in the input of Tx<sub>j</sub>. It may retrieve Tx<sub>i </sub>from the respective node's own pool <b>154</b> of pending transactions if Tx<sub>i </sub>is not already on the blockchain <b>150</b>, or from a copy of a block <b>151</b> in the blockchain <b>150</b> stored at the respective node or another node <b>104</b> if Tx<sub>i </sub>is already on the blockchain <b>150</b>. Either way, the script engine <b>451</b> identifies the locking script in the pointed-to output of Tx<sub>i </sub>and passes this to the script engine <b>452</b>.</p><p id="p-0124" num="0127">The script engine <b>452</b> thus has the locking script of Tx<sub>i </sub>and the unlocking script from the corresponding input of Tx<sub>j</sub>. For example, transactions labelled Tx<sub>0 </sub>and Tx<sub>1 </sub>are illustrated in <figref idref="DRAWINGS">FIG. <b>2</b></figref>, but the same could apply for any pair of transactions. The script engine <b>452</b> runs the two scripts together as discussed previously, which will include placing data onto and retrieving data from the stack <b>453</b> in accordance with the stack-based scripting language being used (e.g. Script).</p><p id="p-0125" num="0128">By running the scripts together, the script engine <b>452</b> determines whether or not the unlocking script meets the one or more criteria defined in the locking script&#x2014;i.e. does it &#x201c;unlock&#x201d; the output in which the locking script is included? The script engine <b>452</b> returns a result of this determination to the protocol engine <b>451</b>. If the script engine <b>452</b> determines that the unlocking script does meet the one or more criteria specified in the corresponding locking script, then it returns the result &#x201c;true&#x201d;. Otherwise it returns the result &#x201c;false&#x201d;.</p><p id="p-0126" num="0129">In an output-based model, the result &#x201c;true&#x201d; from the script engine <b>452</b> is one of the conditions for validity of the transaction. Typically there are also one or more further, protocol-level conditions evaluated by the protocol engine <b>451</b> that must be met as well; such as that the total amount of digital asset specified in the output(s) of Tx<sub>j </sub>does not exceed the total amount pointed to by its inputs, and that the pointed-to output of Tx<sub>i </sub>has not already been spent by another valid transaction. The protocol engine <b>451</b> evaluates the result from the script engine <b>452</b> together with the one or more protocol-level conditions, and only if they are all true does it validate the transaction Tx<sub>j</sub>. The protocol engine <b>451</b> outputs an indication of whether the transaction is valid to the application-level decision engine <b>454</b>. Only on condition that Tx<sub>j </sub>is indeed validated, the decision engine <b>454</b> may select to control one or both of the mining module <b>455</b>M and the forwarding module <b>455</b>F to perform their respective blockchain-related function in respect of Tx<sub>j</sub>. This may comprise the mining module <b>455</b>M adding Tx<sub>j </sub>to the node's respective pool <b>154</b> for mining into a block <b>151</b>, and/or the forwarding module <b>455</b>F forwarding Tx<sub>j </sub>to another node <b>104</b> in the P2P network <b>106</b>. Note however that in embodiments, while the decision engine <b>454</b> will not select to forward or mine an invalid transaction, this does not necessarily mean that, conversely, it is obliged to trigger the mining or the forwarding of a valid transaction simply because it is valid. Optionally, in embodiments the application-level decision engine <b>454</b> may apply one or more additional conditions before triggering either or both of these functions. E.g. if the node is a mining node <b>104</b>M, the decision engine may only select to mine the transaction on condition that the transaction is both valid and leaves enough of a mining fee.</p><p id="p-0127" num="0130">Note also that the terms &#x201c;true&#x201d; and &#x201c;false&#x201d; herein do not necessarily limit to returning a result represented in the form of only a single binary digit (bit), though that is certainly one possible implementation. More generally, &#x201c;true&#x201d; can refer to any state indicative of a successful or affirmative outcome, and &#x201c;false&#x201d; can refer to any state indicative of an unsuccessful or non-affirmative outcome. For instance in an account-based model (not illustrated in <figref idref="DRAWINGS">FIG. <b>4</b></figref>), a result of &#x201c;true&#x201d; could be indicated by a combination of an implicit, protocol-level) validation of a signature by the node <b>104</b> and an additional affirmative output of a smart contract (the overall result being deemed to signal true if both individual outcomes are true).</p><heading id="h-0008" level="1">2. Blockchain Payment Channels</heading><p id="p-0128" num="0131">A payment channel allows users and/or autonomous entities (machines) to communicate peer to peer via transactions. It serves not only as a communication channel but may also serve as a negotiation and settlement process. When designing a payment channel, an important aspect is the balance between security and efficiency.</p><p id="p-0129" num="0132">A number of general payment channel designs are described below, in order to provide relevant context to the described embodiments of the present technology.</p><p id="p-0130" num="0133">In brief, the described embodiments utilize what is referred to herein as a &#x201c;funded Nakamoto payment channel&#x201d;, which provides the security that all participants can be assured of not being cheated by others.</p><p id="p-0131" num="0134">Additional &#x201c;application-layer&#x201d; rule(s) can be imposed on a payment channel (in addition to any &#x201c;native&#x201d; rules of the blockchain protocol that are used to determine transaction validity). Such application-layer rules can be enforced using one or more of the payment channel methodologies taught herein.</p><p id="p-0132" num="0135">2.1 Preliminaries</p><p id="p-0133" num="0136">2.1.1 Blockchain Script</p><p id="p-0134" num="0137">Briefly recapping the more detailed description above, a blockchain <b>150</b> comprises blocks <b>151</b> of transactions <b>152</b>, whereby each transaction <b>152</b> may encode a transfer of digital asset from one address to another using a stack-based scripting language known referred to herein generally as Script (capital S).</p><p id="p-0135" num="0138">Transactions contain scripts written in this language (Script-code), which can appear in one or both of their inputs <b>202</b> and outputs <b>203</b>. Output scripts typically have the function of locking an amount of digital asset by placing a spending condition(s) on it, while input scripts have the function of unlocking such an amount of digital asset by satisfying such spending conditions. Input and output scripts are thus referred to as unlocking scripts and locking scripts respectively herein.</p><p id="p-0136" num="0139">Note that the terms &#x2018;scriptSig&#x2019; and &#x2018;scriptPubKey&#x2019; may sometimes be used instead of the terms unlocking script and locking script respectively. Such terminology assumes that an amount of digital asset it locked to at least one public key, and thus requires at least one transaction signature to unlock. This is often true in practice, but it is not a requirement of output-based protocols&#x2014;any locking script can be defined, which may or may not require a valid transaction signature to unlock. It will therefore be appreciated that all description pertaining to &#x2018;scriptSig&#x2019; and &#x2018;scriptPubKey&#x2019; applies equally to any form of locking/unlocking script, unless context demands otherwise.</p><p id="p-0137" num="0140">Script Execution</p><p id="p-0138" num="0141">In order to validate transactions, script execution is performed by at least some nodes <b>104</b> of the blockchain network <b>101</b>. This ensures that the unlocking script, used by a transaction <b>152</b> input to spend an amount of digital asset, does indeed satisfy the spending condition(s) defined by the locking script of the previous (source) transaction conveying that amount of digital asset. This is illustrated in <figref idref="DRAWINGS">FIG. <b>2</b></figref> and described in detail above.</p><p id="p-0139" num="0142">The amount of digital asset conveyed by a transaction <b>152</b> with a single output <b>203</b> is defined by the digital asset value of the single output. The amount of digital asset conveyed by a transaction <b>152</b> with multiple outputs <b>203</b> is defined by the digital asset values of those multiple outputs.</p><p id="p-0140" num="0143">Note the term &#x2018;digital asset unit&#x2019; herein means an amount v of bitcoins, locked by a locking script in an output of a given transaction Tx with identifier TxID.</p><p id="p-0141" num="0144">The process of script execution is responsible for ensuring that an unlocking script satisfies a locking script in order to create a successful spending relationship such as the one shown in <figref idref="DRAWINGS">FIG. <b>2</b></figref>. This process can be summarised as follows:<ul id="ul0005" list-style="none">    <li id="ul0005-0001" num="0000">    <ul id="ul0006" list-style="none">        <li id="ul0006-0001" num="0145">1. Execute the unlocking script with a new stack <b>453</b>.</li>        <li id="ul0006-0002" num="0146">2. Keep the stack <b>453</b> as it is at the end of execution in (1).</li>        <li id="ul0006-0003" num="0147">3. Execute the locking script using the stack <b>453</b> from (2).</li>        <li id="ul0006-0004" num="0148">4. If the top stack item after (3) is non-zero and non-empty, the spending is valid.</li>    </ul>    </li></ul></p><p id="p-0142" num="0149">The process above describes exactly how script execution is actually implemented by a node <b>104</b> validating a transaction <b>152</b>. However, the process can be conceptually understood by interpreting script execution as:<ul id="ul0007" list-style="none">    <li id="ul0007-0001" num="0000">    <ul id="ul0008" list-style="none">        <li id="ul0008-0001" num="0150">1. Put the unlocking and locking scripts together as:</li>    </ul>    </li></ul></p><p id="p-0143" num="0151">[Unlocking script] OP_CODESEPARATOR [Locking script]<ul id="ul0009" list-style="none">    <li id="ul0009-0001" num="0000">    <ul id="ul0010" list-style="none">        <li id="ul0010-0001" num="0152">2. Executing the resulting scripts from (1), from left to right, using a common stack.</li>        <li id="ul0010-0002" num="0153">3. If the top stack item after (2) is non-zero and non-empty, the spending is valid.</li>    </ul>    </li></ul></p><p id="p-0144" num="0154"><figref idref="DRAWINGS">FIG. <b>5</b></figref> shows a high-level overview of this conceptual interpretation of the process of script execution, in which unlocking script in an output of a first transaction <b>152</b>-<i>i </i>and locking script in an input of a second transition <b>152</b>-<i>j </i>are denoted by reference numerals <b>503</b>-<i>i </i>and <b>502</b>-<i>j </i>respectively. Steps <b>1</b> to <b>3</b> immediately above are denoted by corresponding numbers in square brackets. As indicated, the input of the second transaction <b>152</b>-<i>j </i>has a pointer to the output of the first transaction <b>152</b>-<i>i </i>(in the form of a point to the second transaction <b>152</b>-<i>j </i>together with an index of the output of the first transaction <b>152</b>-<i>i</i>&#x2014;see <figref idref="DRAWINGS">FIG. <b>2</b></figref> above).</p><p id="p-0145" num="0155">2.2 Payment Channels</p><p id="p-0146" num="0156">The term payment channel is taken generally to mean a communication channel (side channel, such as one of the side channels <b>301</b>, <b>302</b> and <b>303</b> described above), established between multiple parties in a peer-to-peer fashion, whereby messages exchanged via the communications channel take the form of transactions <b>152</b>. In a payment channel, it may the case that not all of these transactions are committed to the blockchain <b>152</b>, and they may not even be published (in the above-defined sense). Indeed, in practice, it may be the case that only a small number of these transaction messages are actually published, in order to represent the settlement (and optionally the instigation) of such a channel (but not necessarily all of the intermediate negotiation steps that led to settlement).</p><p id="p-0147" num="0157">A number of scenarios, including peer-to-peer interactions such as micropayments, may involve a number of potentially high-frequency transactions that do not all need to be published.</p><p id="p-0148" num="0158">There are many variants of the general concept of payment channels. This description will focus only on two payment channel architectures in particular:</p><p id="p-0149" num="0159">Nakamoto payment channels&#x2014;based on nSequence and nLocktime.</p><p id="p-0150" num="0160">Funded Nakamoto (FN) payment channels&#x2014;a Nakamoto architecture with funding.</p><p id="p-0151" num="0161">Despite their differences, all of these payment channel architectures can be described as three phase processes, which underpin payment channels as a concept. These phases are:<ul id="ul0011" list-style="none">    <li id="ul0011-0001" num="0000">    <ul id="ul0012" list-style="none">        <li id="ul0012-0001" num="0162">1. Set-up phase&#x2014;the initialisation of a payment channel;</li>        <li id="ul0012-0002" num="0163">2. Negotiation phase&#x2014;creation of off-chain intermediate states; and</li>        <li id="ul0012-0003" num="0164">3. Settlement phase&#x2014;the closure of a payment channel.</li>    </ul>    </li></ul></p><p id="p-0152" num="0165">This description first considers the case of two parties (such as Alice and Bob) who wish to transact many times yet only publish the initial and/or final states of the interaction on-chain.</p><p id="p-0153" num="0166">Directionality</p><p id="p-0154" num="0167">Before detailing different example payment channel architectures, certain terms related to the directionality of payment channels are defined:</p><p id="p-0155" num="0168">Bidirectional&#x2014;a payment channel in which the initial state of funds includes contributions from both parties is said to be bidirectional. This means that, overall, the payment channel may induce a net payment to either party.</p><p id="p-0156" num="0169">Unidirectional&#x2014;a payment channel, conducted between exactly two parties, in which the initial state of funds includes contributions from only one party (a payer) is said to be unidirectional. This means that, overall, the payment channel may induce a net payment to the second party (payee) i.e. the party who does not contribute funds to the initial state of the channel.</p><p id="p-0157" num="0170">The distinction between a net payment and a state transition is noted. In both bidirectional and unidirectional payment channels, an intermediate state transition may reallocate funds toward either party (i.e. in either direction). However, the direction of any possible net change in a payment channel is defined by which parties contribute funds to the initial state.</p><p id="p-0158" num="0171">2.1.1 Nakamoto Payment Channels</p><p id="p-0159" num="0172">A Nakamoto payment channel architecture is set out in the following document, incorporated herein by reference in its entirety: S. Nakamoto and M. Hearn, [Bitcoin-development] Anti DoS for tx replacement, Lists.linuxfoundation.org, 2019.</p><p id="p-0160" num="0173">Such a payment channel utilized sequence numbers and lock times (see <figref idref="DRAWINGS">FIG. <b>2</b>A</figref>) in the following manner.</p><p id="p-0161" num="0174">The architecture is based on the fact that a transaction, having a &#x201c;non-final&#x201d; nSequence number(s) in its input(s), can be updated many times before it becomes valid at nLocktime.</p><p id="p-0162" num="0175">The following assumes, for simplicity, a payment channel between two parties for simplicity. However, payment channels with more than two participants are viable, and various examples of such payment channels are described later.</p><p id="p-0163" num="0176">The outline of a simple Nakamoto payment channel between two such parties can be viewed as a simple three-phase process as follows.<ul id="ul0013" list-style="none">    <li id="ul0013-0001" num="0000">    <ul id="ul0014" list-style="none">        <li id="ul0014-0001" num="0177">1. Set-Up Phase:</li>        <li id="ul0014-0002" num="0178">Alice and Bob each contribute and sign an input to create an initial version of a transaction between them. This initial version represents the initial state of the payment channel, and is kept off-chain. This transaction is time-locked, meaning it has a non-zero nLocktime value set to a suitable point T<sub>L </sub>in the future.</li>        <li id="ul0014-0003" num="0179">2. Update Phase:</li>        <li id="ul0014-0004" num="0180">Alice and Bob update the state of the payment channel by signing a new version of the initial transaction, with higher sequence numbers on both their inputs (transaction replacement), and having updated the transaction details to reflect the desired new state of payment.</li>        <li id="ul0014-0005" num="0181">This process is repeated, creating new intermediate states, as many times as required before nLocktime is reached. Each time a new version is signed with a higher sequence number, all versions with a lower sequence number are invalidated.</li>        <li id="ul0014-0006" num="0182">3. Settlement Phase:</li>        <li id="ul0014-0007" num="0183">Alice and Bob can settle the payment channel by either:        <ul id="ul0015" list-style="none">            <li id="ul0015-0001" num="0184">(i) publishing the version of the transaction with highest nSequence number once nLocktime T<sub>L </sub>has elapsed; or</li>            <li id="ul0015-0002" num="0185">(ii) finalising the transaction prior to nLocktime by mutually signing with the maximum value sequence number (nSequence=0xFFFFFFFF).</li>        </ul>        </li>    </ul>    </li></ul></p><p id="p-0164" num="0186">Note that there is no requirement for any initial transaction to be published, and only the very final state needs to be published and mined onto the blockchain. However, there exists a possible security vulnerability whereby either party's input could be &#x2018;double-spent&#x2019; at any time before settlement, because no transaction is published prior to the time of settlement.</p><p id="p-0165" num="0187">A Nakamoto payment channel can be implemented in either the bidirectional or unidirectional configurations, simply by changing who has contributed to the initial state.</p><p id="p-0166" num="0188"><figref idref="DRAWINGS">FIG. <b>6</b></figref> shows an example process diagram for a Nakamoto payment channel architecture.</p><p id="p-0167" num="0189">The process diagram illustrates a typical Nakamoto payment channel, in the bidirectional configuration, according to this description. The notation &#x2018;nS&#x2019; is used as shorthand for nSequence, &#x2018;M&#x2019; denotes the maximum e.g. 4-byte value (0xFFFFFFFF) a sequence number nS can take, &#x2018;I<sub>n</sub>&#x2019; denotes a state n (I<sub>0 </sub>being an initial state) and &#x2018;S&#x2019; denotes a settlement transaction. White circles represent incomplete transactions, whilst black circles represent complete transactions, and cross-hatched circles for transactions that have been successfully mined. In this context, the term &#x201c;state&#x201d; refers to a partial or completed spending transaction which has not necessarily been mined or published.</p><p id="p-0168" num="0190">The reference numeral <b>600</b> is used to denote a series of spending transaction created, over time, via a payment channel. The payment channel is implemented in a sequence of steps, with Sn denoting the step in which state I<sub>n </sub>is created (S0 being an initial step in which the initial state I<sub>0 </sub>is established). A final step SF creates the settlement transaction S, and this step SF may or may not occur, depending on whether all parties remain cooperative through the entire negotiation.</p><p id="p-0169" num="0191">2.2.2 Funded Nakamoto (FN) Payment Channels</p><p id="p-0170" num="0192">A &#x201c;funded&#x201d; payment channel refers to a situation in which a special funding transaction is committed to the blockchain <b>150</b> before the negotiation commences. One example of a funded payment channel is a Spilman payment channel, which does not make use of sequence numbers of lock times.</p><p id="p-0171" num="0193">Both Nakamoto channels and Spilman channels have different features and properties, as well as different security vulnerabilities dependent on the situational requirements of the channel. The security flaws in particular are summarised as:</p><p id="p-0172" num="0194">Nakamoto&#x2014;because there is no funding transaction, it is possible for either party to maliciously double-spend their money at any point prior to settlement.</p><p id="p-0173" num="0195">Funded (Spilman)&#x2014;because there is no use of nSequence and nLocktime in the update phase, it is possible for one party to maliciously broadcast an early state if implemented poorly.</p><p id="p-0174" num="0196">This section introduces the concept of a Funded Nakamoto (FN) payment channel to show how both of these security flaws can be mitigated.</p><p id="p-0175" num="0197">The term &#x2018;Funded Nakamoto payment channels&#x2019; is used to describe any payment channel that both:<ul id="ul0016" list-style="none">    <li id="ul0016-0001" num="0000">    <ul id="ul0017" list-style="none">        <li id="ul0017-0001" num="0198">Uses transaction replacement in the update phase, by employing nLocktime and incrementing nSequence, analogous to a Nakamoto payment channel (2.2.1); and</li>        <li id="ul0017-0002" num="0199">Uses a funding transaction to &#x201c;escrow&#x201d; the interacting parties' funds, and record the initial state of the payment channel on-chain.</li>    </ul>    </li></ul></p><p id="p-0176" num="0200">An example three-phase outline of an FN payment channel, in the bidirectional configuration, is provided as follows:<ul id="ul0018" list-style="none">    <li id="ul0018-0001" num="0000">    <ul id="ul0019" list-style="none">        <li id="ul0019-0001" num="0201">1. Set-up phase:</li>        <li id="ul0019-0002" num="0202">Alice and Bob collaborate to create a funding transaction, which escrows funds jointly to a 2-of-2 multisignature address. This defines the initial state of their funds and it must be published on-chain.</li>        <li id="ul0019-0003" num="0203">Alice and Bob collaborate to create a refund transaction, which returns the escrowed funds to the original owners according to the initial state. This transaction is time-locked, meaning it has a non-zero nLocktime value set to a suitable point T<sub>R </sub>in the future.</li>        <li id="ul0019-0004" num="0204">2. Update phase:</li>        <li id="ul0019-0005" num="0205">Alice and Bob collaborate, by providing their respective signatures, to create a transaction spending the output of the funding transaction. This is the first intermediate state of the payment channel, and reflects an initial payment direction. This intermediate state is time-locked to a suitable time T<sub>L </sub>in the future, such that T<sub>L</sub>&#x2264;T<sub>R</sub>.</li>        <li id="ul0019-0006" num="0206">Alice and Bob update the state of the payment channel by signing a new version of the initial state transaction, with a higher sequence number (transaction replacement), and having updated the transaction details to reflect the desired new state of payment. The nLocktime of each new state remains consistently at the value T<sub>L</sub>.</li>        <li id="ul0019-0007" num="0207">This process is repeated, creating new intermediate states, as many times as required before intermediate transaction nLocktime T<sub>L </sub>elapses.</li>        <li id="ul0019-0008" num="0208">3. Settlement phase:</li>        <li id="ul0019-0009" num="0209">Alice and Bob can settle the payment channel by either:        <ul id="ul0020" list-style="none">            <li id="ul0020-0001" num="0210">(i) publishing the version of the transaction with highest nSequence number once nLocktime T<sub>L </sub>has elapsed; or</li>            <li id="ul0020-0002" num="0211">(ii) finalising the transaction prior to nLocktime T<sub>L </sub>by mutually signing with the maximum value sequence number (nSequence=0xFFFFFFFF).</li>        </ul>        </li>        <li id="ul0019-0010" num="0212">In either case, the final state is published and mined into the blockchain <b>150</b>.</li>    </ul>    </li></ul></p><p id="p-0177" num="0213">The notation T<sub>R </sub>and T<sub>L </sub>is used to distinguish between the nLocktime limits placed on the refund transaction and the intermediate transaction version(s) respectively. These times may be different because the time T<sub>L </sub>at which negotiation of the intermediate states must cease may be different than the time T<sub>R </sub>at which the parties wish to be mutually refunded if the interaction or negotiation fails. The relationship between them should be T<sub>L</sub>&#x3c;T<sub>R </sub>to ensure that negotiation would cease before either party is able to be refunded. It would cause an issue if it were possible for a party to be refunded during the update phase.</p><p id="p-0178" num="0214"><figref idref="DRAWINGS">FIGS. <b>6</b>A and <b>6</b>B</figref> illustrate two examples of Funded Nakamoto payment channels, in the bidirectional and unidirectional configurations respectively.</p><p id="p-0179" num="0215">In both cases, it can be seen that a special funding transaction F is created and signed by the parties in the initial step S0, and committed to the blockchain <b>150</b> before proceeding (as denoted by the cross-hatched circled to the right-hand side of the figure in the section representing step S0).</p><p id="p-0180" num="0216">Typically, the finding transaction F will have an output that requires at least two valid transaction signatures, from different parties, to unlock (there may or may not be additional requirement(s)). In the simplest case, it simply requires signature from Alice and Bob, however extensions are described later which use more complex multi-signature locking conditions, such as an &#x201c;m-of-n multi-signature requirement&#x201d; (see below).</p><p id="p-0181" num="0217">The transaction which does eventually unlock the output of the funding transaction F will&#x2014;if all goes to plan&#x2014;be the settlement transaction S, as is depicted in all of <figref idref="DRAWINGS">FIGS. <b>6</b>, <b>6</b>A and <b>6</b>B</figref>. However, in the event that the negotiation terminates before any settlement transaction S is completed, any party can publish whichever completed transaction I<sub>n </sub>of the series of spending transactions <b>600</b> has the highest sequence number&#x2014;and that transaction will unlock the output of the funding transaction F. The transaction which unlocks the output of the funding transaction F has the effect of distributing the value v of the output of the funding transaction between the parties (or a subset of the parties).</p><p id="p-0182" num="0218">This description has already outlined above&#x2014;with reference to <figref idref="DRAWINGS">FIG. <b>2</b>A</figref>&#x2014;how a series of spending transactions can be created over time to negotiate a distribution of an amount of digital asset between two or more parties.</p><p id="p-0183" num="0219">In the example of <figref idref="DRAWINGS">FIG. <b>6</b>A</figref>, each party commits an amount of digital asset to the spending transaction&#x2014;&#xa3;11 and &#xa3;1 from Alice and Bob respectively (where &#x201c;&#xa3;&#x201d; denotes whatever unit issued to quantify digital asset according to the blockchain protocol in question; elsewhere the letters &#x201c;BSV&#x201d; may be used to denote units of digital asset). These amounts are committed by way of two signed inputs in the funding transaction F&#x2014; one which validly spends &#xa3;11 belonging to Alice (requiring a valid transaction signature from Alice), and the other of which validly spends &#xa3;1 belonging to Bob (requiring a valid transaction signature from Bob). The refund transaction R has two outputs, which restore the status quo&#x2014;i.e., were the refund transaction R to be mined, it would convey &#xa3;11 back to Alice and &#xa3;1 back to Bob (any mining fees are ignored for the sake of simplicity). The payment channel is then used to negotiate incremental increases in Bob's share, offset against corresponding decreases in Alice's.</p><p id="p-0184" num="0220">In <figref idref="DRAWINGS">FIG. <b>6</b>B</figref>, the principles are the same, but in this case only Alice commits any digital asset initially in the funding transaction F, and the refund transaction R would transfer all of this back to Alice. Successive spending transactions incrementally increase the amount to be paid to Bob, offset against any amount paid back to Alice.</p><heading id="h-0009" level="1">3. Payment Channel Loops</heading><p id="p-0185" num="0221">It is possible to use payment channels to implement loops, and that this can be achieved in a number of ways. This disclosure refers to loops implemented by use of a payment channel as Payment Channel Loops (PCLs).</p><p id="p-0186" num="0222">The execution of such looping functionality, when implemented using a payment channel, will generally require some form of off-chain processing. This refers to any type of processing which may involve one or many of:<ul id="ul0021" list-style="none">    <li id="ul0021-0001" num="0000">    <ul id="ul0022" list-style="none">        <li id="ul0022-0001" num="0223">(i) reading transactions;</li>        <li id="ul0022-0002" num="0224">(ii) writing transactions;</li>        <li id="ul0022-0003" num="0225">(iii) using an off-chain instance of the scripting engine <b>452</b> to pieces of Script; and</li>        <li id="ul0022-0004" num="0226">(iv) using an alternative engine to execute code of an alternative language (&#x201c;non-Script&#x201d; herein).</li>    </ul>    </li></ul></p><p id="p-0187" num="0227">The ultimate goal of implementing a PCL is to allow an iterative process to be performed off-chain, while ensuring that the funds associated with the channel are distributed between participants correctly. This means that the funds should be dependent on the outcome(s) of the process and in accordance with any rules of the channel. The final and/or initial state of the process may also be recorded on chain.</p><p id="p-0188" num="0228">The term &#x201c;off-chain&#x201d; refers to processing that is not performed as part of the transaction validation process, i.e. which is performed outside of the blockchain protocol. Typically, this would occur at an external system which is not part of the blockchain network <b>101</b>, but which may have access to the blockchain network <b>101</b> and thus have visibility of published transactions. This would include, for example, processing by Alice, Bob or any of the trusted oracles <b>150</b><i>o</i>, <b>150</b><i>o</i>-<b>1</b>, <b>150</b><i>o</i>-<b>2</b> mentioned above.</p><p id="p-0189" num="0229">In some respects, payment channel loops match, and in certain ways exceed the benefits associated with account-based blockchains. An account-based blockchain with a Turing-complete virtual machine can execute program loops &#x201c;on-chain&#x201d; as part of transaction validation. On the one hand this is beneficial, but on the other hand it is costly in terms of computational resources. A smart contract may be called multiple times by multiple later transactions, and each time it is called, all nodes in the network that validate transactions will execute the smart contract code to validate the later transaction.</p><p id="p-0190" num="0230">A limitation of certain script-based UTXO blockchains is the inability to execute loops on-chain. PLCs are a therefore highly effective mechanism for augmenting the native blockchain functionality of such blockchains, by providing a structured framework in which the execution of loops can be performed off-chain according to defined rules, with all parties being incentivized to behave in compliance with those rules, and with robust controls in the event any party fails to do so. A benefit of off-chain loop execution in this context is that it does not burden the entire network with needing to execute the loop, which means a significant saving in terms of computational resources.</p><p id="p-0191" num="0231">The following examples are covered in the following sections of the description:<ul id="ul0023" list-style="none">    <li id="ul0023-0001" num="0000">    <ul id="ul0024" list-style="none">        <li id="ul0024-0001" num="0232">Mapping loops to payment channel architectures generally;</li>        <li id="ul0024-0002" num="0233">Bidirectional PCLs; and</li>        <li id="ul0024-0003" num="0234">Unidirectional PCLs.</li>    </ul>    </li></ul></p><p id="p-0192" num="0235">The distinction is made between bidirectional and unidirectional PCLs because they may lend themselves to different use cases. For example, bidirectional PCLs may be used to implement the iteration of a process where a payment is to be rebalanced in either direction via state transitions, while unidirectional PCLs may be more suited to a &#x2018;paid computation&#x2019; scenario whereby Alice pays Bob incrementally (i.e. per operation) for his computational resources.</p><p id="p-0193" num="0236">3.1 Generic PCL Architecture</p><p id="p-0194" num="0237">This section describes how the primary features of loops can be mapped to the features of general payment channel architectures (see 2.2).</p><p id="p-0195" num="0238">3.1.1. Mapping Loops to Payment Channels</p><p id="p-0196" num="0239">The Loop</p><p id="p-0197" num="0240">In general, any type of loop may be implemented in a payment channel. This description focusses mainly on a &#x2018;for&#x2019; for demonstrative purposes.</p><p id="p-0198" num="0241">A schematic version of a generic &#x2018;for&#x2019; loop mapped to a payment channel is as follows:</p><p id="p-0199" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="63pt" align="left"/><colspec colname="1" colwidth="154pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>V = V<sub>initial</sub></entry></row><row><entry/><entry>for ( i = 0; i &#x2264; M; i++ ) {</entry></row><row><entry/><entry>&#x2003;V<sub>i </sub>= Function ( V )</entry></row><row><entry/><entry>&#x2003;V = V<sub>i</sub></entry></row><row><entry/><entry>&#x2003;}</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0200" num="0242">The loop has elements which include a loop counter i, a starting point (0) and upper limit (M) for the counter, an initial value(s) passed to the loop V<sub>i </sub>and a repeating unit of code Function( ) (or just F( ) as a shorthand) that is to be executed on each iteration of the loop. An aim is to map elements of the loop to a PLC.</p><p id="p-0201" num="0243"><figref idref="DRAWINGS">FIG. <b>7</b></figref> illustrates a possible mapping of the elements of the &#x2018;for&#x2019; loop to a payment channel. A description of this mapping follows.</p><p id="p-0202" num="0244">Incrementing nSequence</p><p id="p-0203" num="0245">The loop iteration counter i can, for example, be replaced in a PCL with the value of nSequence (or nS as shorthand) used in the input of transactions in the update phase. The range of possible values for nSequence is between 0 and M, where M is the maximum nSequence value, which is considered &#x2018;final&#x2019; by the blockchain protocol. In certain blockchain protocols, the largest 8-byte value, 0xFFFFFFFF, is taken to mean that a transaction is finalised, which means therefore that upper limit for the loop would be M=0xFFFFFFFF in that event. That is just under 4.3 billion when expressed as a decimal.</p><p id="p-0204" num="0246">Mapping the loop counter i to the sequence number nS allows for just under 4.3 billion iterations of the loop to update a transaction, meaning the statement(s) in the body can be executed at least 4.3 billion times before the transaction is finalised.</p><p id="p-0205" num="0247">Note the value of nS can be incremented in non-uniform steps of any size, despite the fact that the loop counter i increases uniformly in steps of one. This is because the only constraint on nS for the payment channel to function is that it increases in each step, which means a one-to-one map can be created between the values of i and the values of nS for any loop.</p><p id="p-0206" num="0248">It is noted, however, that this example ties the value of nSequence to the counter of a &#x2018;for&#x2019; loop purely for ease of demonstration. As indicated above, it is possible to map any form of loop to a set of transactions in a payment channel. This can be done by choosing any condition on which the loop repeats, such as &#x2018;while (it is raining in June)&#x2019; or &#x2018;for each (game won by Liverpool FC)&#x2019;, to be verified off-chain, and ensuring what the value nSequence increments while that condition is true.</p><p id="p-0207" num="0249">Methods for verifying such conditional statements for veracity can be implemented using oracle-based systems (see section 4).</p><p id="p-0208" num="0250">Inputs and Parameters</p><p id="p-0209" num="0251">The &#x2018;initial input&#x2019; passed to the loop has been referred to as V Initial, where the letter V is used to mean &#x2018;value&#x2019;. However, more generally it is possible that the loop will depend on a number of different inputs and parameters, defined as follows:<ul id="ul0025" list-style="none">    <li id="ul0025-0001" num="0000">    <ul id="ul0026" list-style="none">        <li id="ul0026-0001" num="0252">Inputs &#x3d5;<sub>i</sub>&#x2014; values passed to the loop that may be updated by the loop on each iteration. Note the input to a function F( ) is distinct from an input <b>203</b> of a transaction <b>152</b>; it will be clear in context which is meant. The term &#x201c;input value&#x201d; may be used to refer to the input as a function, and the term &#x201c;transaction input&#x201d; may be used to explicitly disguise between the two where helpful; and</li>        <li id="ul0026-0002" num="0253">Parameters &#x3c9;<sub>i</sub>&#x2014;values passed to the loop that may be updated externally to the loop on each iteration.</li>    </ul>    </li></ul></p><p id="p-0210" num="0254">Both input values and parameters are examples of &#x201c;function variables&#x201d; as the latter term is used herein. The terms &#x201c;function variable&#x201d; and &#x201c;argument&#x201d; may be used synonymously.</p><p id="p-0211" num="0255">A set of inputs and parameters taken by the i<sup>th </sup>iteration of the loop may be written as a tuple of arguments V<sub>i</sub>:=(&#x3d5;<sub>i</sub>,&#x3c9;<sub>i</sub>) where the i<sup>th </sup>sets of inputs and parameters are denoted as (p<sub>i </sub>and &#x3c9;<sub>i </sub>respectively.</p><p id="p-0212" num="0256">In most cases, it is expected that at least some of the elements in V<sub>i</sub>, taken by the i<sup>th </sup>transaction as arguments, will be encoded or represented in some way in the (i&#x2212;1)<sup>th </sup>transaction. In other words. It is expected that the i<sup>th </sup>transaction will depend on the (i&#x2212;1)<sup>th </sup>transaction, whereby the dependency is defined by the repeating function F( ) of the loop.</p><p id="p-0213" num="0257">Note that the input arguments (&#x3d5;<sub>i</sub>,&#x3c9;<sub>i</sub>) may reside in any field of a transaction. Given that the input scripts of a transaction are not signed, it may be desirable for the arguments (&#x3d5;<sub>i</sub>,&#x3c9;<sub>i</sub>) to reside in an output, which is signed, whether or not it is an unspendable (OP_RETURN) or spendable output (in a locking script).</p><p id="p-0214" num="0258">For certain blockchain protocols, the code OP_RETURN should be taken to mean the pair of opcodes OP_0 OP_RETURN. This has the effect of safely restoring the functionality of OP_RETURN for any such protocol where that is necessary. For further details, see S. Shadders, &#x201c;The return of OP_RETURN&#x2014; roadmap to Genesis part 4&#x2014;BitcoinSV&#x201d;, BitcoinSV, 2019.</p><p id="p-0215" num="0259">3.1.2 Repeating Functional Unit F( )</p><p id="p-0216" num="0260">The term repeating functional unit refers to the main body of the loop to be implemented via a PCL, which is the portion of code comprising executable statements. In the present example, this is a functional unit of code denoted by F( ) above.</p><p id="p-0217" num="0261">In terms of the architecture of a PCL, the repeating functional unit F( ) is the portion of code that will be executed off-chain in each iteration of the loop. The functional unit F( ) can be treated as a &#x201c;black box&#x201d;, which receives one or more arguments (input(s) and/or parameter(s)) and returns an output as the next input. Therefore, the input can be derived from the previous transaction, and the output can be used to form the next transaction.</p><p id="p-0218" num="0262">By way of example, <figref idref="DRAWINGS">FIG. <b>8</b></figref> shows the functional unit F( ) taking a second transaction <b>152</b>-<i>j</i>-<b>1</b> as an &#x2018;argument&#x2019; and yielding one or more components of a third transaction <b>152</b>-<i>j</i>-<b>2</b> as &#x2018;output(s)&#x2019;. Using the mathematical notation above, those transactions are denoted as I<sub>i&#x2212;1 </sub>and I<sub>i </sub>respectively.</p><p id="p-0219" num="0263">This could, for example, be the way in which the third transaction <b>152</b>-<i>j</i>-<b>2</b> of <figref idref="DRAWINGS">FIG. <b>2</b>A</figref> is created. Although not depicted in <figref idref="DRAWINGS">FIG. <b>8</b></figref>, each of the second and third transactions <b>152</b>-<i>j</i>-<b>1</b>, <b>152</b>-<i>j</i>-<b>2</b> would spend an output of the same first transaction <b>152</b>-<i>i </i>as depicted in <figref idref="DRAWINGS">FIG. <b>2</b>A</figref>.</p><p id="p-0220" num="0264"><figref idref="DRAWINGS">FIG. <b>8</b></figref> highlights certain the differences between the input transaction and the output transaction by: (i) incrementing the value of nSequence i&#x2212;1&#x2192;i; and (ii) updating the inputs and parameters (&#x3d5;<sub>i&#x2212;1</sub>,&#x3c9;<sub>i&#x2212;1</sub>)&#x2192;(&#x3d5;<sub>i</sub>,&#x3c9;<sub>i</sub>), where (&#x3d5;<sub>i&#x2212;1</sub>,&#x3c9;<sub>i&#x2212;1</sub>) represent the function variables in the second transaction <b>152</b>-<i>j</i>-<b>1</b> and (&#x3d5;<sub>i</sub>,&#x3c9;<sub>i</sub>) represent the function variables in the third transaction <b>152</b>-<i>j</i>-<b>2</b>.</p><p id="p-0221" num="0265">Sig P<sub>A </sub>and Sig P<sub>B </sub>denote valid transaction signatures provided by Alice and Bob respectively; the input value(s) &#x3d5;<sub>i </sub>are by definition computed by executing the function F( ), i.e. as (or as part of) F(&#x3d5;<sub>i</sub>,&#x3c9;<sub>i</sub>) (that is, the function F( ) applied to the function variables (&#x3d5;<sub>i</sub>,&#x3c9;<sub>i</sub>) of the second transaction <b>152</b>-<i>j</i>-<b>1</b>); the parameter(s) &#x3c9;<sub>i </sub>are by definition not computed in the execution of F( ) but rather are provided by one or more external sources <b>800</b> (i.e. external to the loop&#x2014;not necessarily external to the device/system/equipment at which F is applied; for example, the external source(s) could be Alice, Bob, an Oracle <b>102</b><i>o </i>(or one or both of the Oracles <b>102</b><i>o</i>-<b>1</b>, <b>102</b><i>o</i>-<b>2</b>), and/or any other external source(s)).</p><p id="p-0222" num="0266">In the present example, each transaction <b>152</b>-<i>j</i>-<b>1</b>, <b>152</b>-<i>j</i>-<b>2</b> has two transaction outputs as in <figref idref="DRAWINGS">FIG. <b>2</b>A</figref>&#x2014;having digital asset values v<sub>1</sub>, v<sub>2 </sub>and v<sub>1</sub>&#x2032;, v<sub>2</sub>&#x2032; respectively. The function F( ) may also determine the value(s) v<sub>1</sub>&#x2032;, v<sub>2</sub>&#x2032; of the output of the returned transaction <b>152</b>-<i>j</i>-<b>2</b>, and may use the digital asset values v<sub>1</sub>, v<sub>2 </sub>of the outputs of the input transaction <b>142</b>-<i>j</i>-<b>1</b> may in that case be used to determine in addition to (&#x3d5;<sub>i&#x2212;1</sub>,&#x3c9;<sub>i&#x2212;1</sub>). Although in this example, each transaction has two outputs, that is not required in general; each transaction can have any number of outputs including one, and may or may not have the same number of outputs as each other.</p><p id="p-0223" num="0267">The next section details how the functional unit F( ) can is executed repeatedly in a PCL, at least once per iteration of the loop. The reason for saying &#x2018;at least&#x2019; once is because of the possibility that one iteration of the loop requires some integer k&#x2265;1 application of the unit.</p><p id="p-0224" num="0268">There is choice between two options when expressing the function F( ) used in a PCL; it may be written in either Script (i.e. the scripting language of the blockchain <b>150</b>) or some alternative language (non-Script). The choice made here may affect how the PCL is implemented:<ul id="ul0027" list-style="none">    <li id="ul0027-0001" num="0000">    <ul id="ul0028" list-style="none">        <li id="ul0028-0001" num="0269">Script&#x2014;in this case the functional unit can exist as part of a spendable output script, which can be executed, using the Bitcoin script engine, off-chain by an interpreter alongside the arguments (&#x3d5;<sub>i&#x2212;1</sub>,&#x3c9;<sub>i&#x2212;1</sub>) to produce one or more components of the next transaction.</li>        <li id="ul0028-0002" num="0270">Alternative non-Script language&#x2014;in this case the functional unit may need to exist as part of an unspendable (e.g. OP_RETURN) output. The code unit F( ) can then be executed off-chain using some other engine, also using the arguments (&#x3d5;<sub>i&#x2212;1</sub>,&#x3c9;<sub>i&#x2212;1</sub>) to produce one or more components of the next transaction.</li>    </ul>    </li></ul></p><p id="p-0225" num="0271">Example PCL implementations are described in detail later, which demonstrate how both of these approaches may be useful in different circumstances.</p><p id="p-0226" num="0272">It is important to note that, even in the case that the functional unit F is embodied as Script in a transaction, in the described examples, the validity of the transaction can be such that it does not depend on the outcome of executing F( ) at a node <b>104</b>. That is, the validity of the transaction is not necessarily dependent on the function F( ). Rather the function F( ) defines a set of &#x201c;payment channel rules&#x201d; according to which a payment channel is implemented off-chain. The implementation of the payment channel will therefore be dependent on the execution of F off-chain (whether it is coded in Script or non-Script), but the validity of any published transaction will not necessarily depend on F (even when it is encoded in Script).</p><p id="p-0227" num="0273">Accommodating Zero-Functions</p><p id="p-0228" num="0274">One final consideration to be made is that, in some cases, F( ) is implemented in Script, and the execution of F( ) is part of the locking or unlocking script. It is possible that the output values &#x3d5;<sub>i </sub>of an iteration may take the value &#x2018;zero&#x2019;, which would invalidate the transaction. This might be desirable as it can be a signal for ending the loop. However, if this is not the case, then the zero value can be replaced with some placeholder such as a, for some non-zero value a, and by appending a conditional Bitcoin script statement to the functional unit:</p><p id="p-0229" num="0000"><tables id="TABLE-US-00002" num="00002"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="56pt" align="left"/><colspec colname="1" colwidth="161pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>[G( )] = [F( )]OP_DUP OP_IF</entry></row><row><entry/><entry>&#x2003;&#x2003;OP_NOP</entry></row><row><entry/><entry>&#x2003;OP_ELSE</entry></row><row><entry/><entry>&#x2003;&#x2003;OP_DROP&#x2009;<img id="CUSTOM-CHARACTER-00001" he="2.46mm" wi="1.10mm" file="US20230004967A1-20230105-P00001.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;&#x3b1;&#x2009;<img id="CUSTOM-CHARACTER-00002" he="2.46mm" wi="1.10mm" file="US20230004967A1-20230105-P00002.TIF" alt="custom-character" img-content="character" img-format="tif"/> </entry></row><row><entry/><entry>&#x2003;OP_ENDIF</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0230" num="0275">Where [F( )] represents the functional unit of code in Bitcoin script and [G ( )] now represents a version of that repeating unit that accommodates zero-valued outcomes. If a is chosen carefully, it can also serve as a flag for some special event, such as reaching the end of the loop.</p><p id="p-0231" num="0276">3.1.3 Transactions in PCLs</p><p id="p-0232" num="0277">In this section, a number of possible &#x201c;skeleton&#x201d; transaction structures are described that can be used to implement a general PCL. These transactions are classified according to the terminology established for payment channels in section (2.2): the funding, update-phase and settlement transactions respectively.</p><p id="p-0233" num="0278">The Funding Transaction</p><p id="p-0234" num="0279">In a PCL, a funding transaction F plays the dual roles of (i) escrowing the participants' funds to the payment channel and (ii) also establishing the functional unit F( ) to be used in the looping process.</p><p id="p-0235" num="0280">Role (ii) is a key feature of the described funding transaction F in a PLC&#x2014; the funding transaction F serves to immutably record the set of rules according to which the payment channel must be implemented&#x2014;those rules being embodied in the function F( ). These rules are agreed by the parties who sign the funding transaction F, and the funding transaction F serves as immutable proof of the agreed rules once committed to the blockchain <b>150</b>.</p><p id="p-0236" num="0281">The funding transaction F may contain the code embodying function F( ), or it may otherwise evidence that code. For example, the code may be contained in another transaction committed to the blockchain <b>150</b> and the function transaction F may evidence that code by way of a hash value or other unique identifier of that code contained in the funding transaction F.</p><p id="p-0237" num="0282">For the case of a bidirectional payment channel, and wherein the functional unit is written in Script, a funding transaction F can be constructed as depicted schematically in <figref idref="DRAWINGS">FIG. <b>9</b>A</figref>. Consistent with <figref idref="DRAWINGS">FIGS. <b>2</b>A and <b>8</b></figref>, the funding transaction F is denoted by reference sign <b>152</b>-<i>i</i>. The repeating unit is part of a spendable script in this example.</p><p id="p-0238" num="0283">In this case, there is only a single output, which includes two distinct portions of script. The first is a simple 2-of-2 multisignature script required to jointly escrow funds for a bidirectional payment channel. The second is the repeating functional unit F( ), written in Script in this example.</p><p id="p-0239" num="0284">Another motivation for including the function F( ) in the funding transaction F is that it only needs to be written and stored once, rather than creating multiple duplicate copies as would be the case if the functional unit F( ) were to reside in the update-phase transactions <b>600</b>. The funding transaction is set out in further detail below, as Transaction 1.</p><p id="p-0240" num="0000"><tables id="TABLE-US-00003" num="00003"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Transaction 1: A funding transaction (in detail) where</entry></row><row><entry>the repeating unit is part of a spendable script.</entry></row><row><entry>Funding Transaction, TxID<sub>F</sub></entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="98pt" align="center"/><colspec colname="2" colwidth="119pt" align="center"/><tbody valign="top"><row><entry>Inputs</entry><entry>Outputs</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="35pt" align="left"/><colspec colname="2" colwidth="63pt" align="left"/><colspec colname="3" colwidth="35pt" align="left"/><colspec colname="4" colwidth="84pt" align="left"/><tbody valign="top"><row><entry>Value</entry><entry>Script</entry><entry>Value</entry><entry>Script</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row><row><entry>11 BSV</entry><entry>nSequence:</entry><entry>12 BSV</entry><entry>OP_2 &#x3c;P<sub>A</sub>&#x3e; &#x3c;P<sub>B</sub>&#x3e; OP_2</entry></row><row><entry/><entry>0xFF...F</entry><entry/><entry>OP_CHECKMULTISIG</entry></row><row><entry/><entry>&#x3c; Sig(P<sub>A</sub>, Tx<sub>F</sub>)&#x3e;</entry><entry/><entry>[Function( )]</entry></row><row><entry/><entry>&#x3c;P<sub>A</sub>&#x3e;</entry></row><row><entry>1 BSV</entry><entry>nSequence:</entry></row><row><entry/><entry>0xFF...F</entry></row><row><entry/><entry>&#x3c; Sig(P<sub>B</sub>, Tx<sub>F</sub>)&#x3e;</entry></row><row><entry/><entry>&#x3c;P<sub>B</sub>&#x3e;</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><tbody valign="top"><row><entry>nLocktime: 0</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0241" num="0285">Alternatively, if the functional unit is written in a different programming language, a similar funding transaction can be constructed, shown in <figref idref="DRAWINGS">FIG. <b>9</b>B</figref>.</p><p id="p-0242" num="0286">In this case two outputs are provided that separate the multisignature script from the functional unit, which is now written in a non-Script language. To accommodate this, the unit of code is stored in an unspendable (e.g. OP_RETURN) output, meaning this part of the transaction will never be executed by miners during the transaction validation process.</p><p id="p-0243" num="0287">The funding transaction of <figref idref="DRAWINGS">FIG. <b>9</b>B</figref> is set out in further detail below, as Transaction 2.</p><p id="p-0244" num="0000"><tables id="TABLE-US-00004" num="00004"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Transaction 2: A funding transaction (in detail) where</entry></row><row><entry>the repeating unit is stored in an</entry></row><row><entry>OP_RETURN output.</entry></row><row><entry>Funding Transaction, TxID<sub>F</sub></entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="98pt" align="center"/><colspec colname="2" colwidth="119pt" align="center"/><tbody valign="top"><row><entry>Inputs</entry><entry>Outputs</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="35pt" align="left"/><colspec colname="2" colwidth="63pt" align="left"/><colspec colname="3" colwidth="35pt" align="left"/><colspec colname="4" colwidth="84pt" align="left"/><tbody valign="top"><row><entry>Value</entry><entry>Script</entry><entry>Value</entry><entry>Script</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row><row><entry>11 BSV</entry><entry>nSequence:</entry><entry>0 BSV</entry><entry>OP_0 OP_RETURN</entry></row><row><entry/><entry>0xFF...F</entry><entry/><entry>[Function( )]</entry></row><row><entry/><entry>&#x3c; Sig(P<sub>A</sub>, Tx<sub>F</sub>)&#x3e;</entry></row><row><entry/><entry>&#x3c;P<sub>A</sub>&#x3e;</entry></row><row><entry>1 BSV</entry><entry>nSequence:</entry><entry>12 BSV</entry><entry>OP_2 &#x3c;P<sub>A</sub>&#x3e; &#x3c;P<sub>B</sub>&#x3e; OP_2</entry></row><row><entry/><entry>0xFF...F</entry><entry/><entry>OP_CHECKMULTISIG</entry></row><row><entry/><entry>&#x3c; Sig(P<sub>B</sub>, Tx<sub>F</sub>)&#x3e;</entry></row><row><entry/><entry>&#x3c;P<sub>B</sub>&#x3e;</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><tbody valign="top"><row><entry>nLocktime: 0</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0245" num="0288">In the set-up phase of a PCL, a corresponding refund transaction R is created for the funding transaction F as part of the initial step S0. The refund transaction R has nSequence value of 0 (or anything less than the maximal value) and an nLocktime value set to T<sub>R </sub>in the future.</p><p id="p-0246" num="0289">An example of such a refund transaction is shown as Transaction 3 below.</p><p id="p-0247" num="0000"><tables id="TABLE-US-00005" num="00005"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Transaction 3: A refund transaction (in detail) spending</entry></row><row><entry>the output of the funding transaction.</entry></row><row><entry>Refund Transaction, TxID<sub>R</sub></entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="91pt" align="center"/><colspec colname="2" colwidth="126pt" align="center"/><tbody valign="top"><row><entry>Inputs</entry><entry>Outputs</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="35pt" align="left"/><colspec colname="2" colwidth="56pt" align="left"/><colspec colname="3" colwidth="28pt" align="left"/><colspec colname="4" colwidth="98pt" align="left"/><tbody valign="top"><row><entry>Value</entry><entry>Script</entry><entry>Value</entry><entry>Script</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row><row><entry>12 BSV</entry><entry>nSequence: 0</entry><entry>11 BSV</entry><entry>OP_DUP OP_HASH160 &#x3c;P<sub>A</sub>&#x3e;</entry></row><row><entry/><entry>&#x3c; Sig(P<sub>A</sub>, Tx<sub>R</sub>)&#x3e;</entry><entry/><entry>OP_EQUALVERIFY</entry></row><row><entry/><entry>&#x3c;P<sub>A</sub>&#x3e;</entry><entry/><entry>OP_CHECKSIG</entry></row><row><entry/><entry>&#x3c; Sig(P<sub>B</sub>, Tx<sub>R</sub>)&#x3e;</entry></row><row><entry/><entry>&#x3c;P<sub>B</sub>&#x3e;</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="91pt" align="left"/><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="98pt" align="left"/><tbody valign="top"><row><entry/><entry>1 BSV</entry><entry>OP_DUP OP_HASH160 &#x3c;P<sub>B</sub>&#x3e;</entry></row><row><entry/><entry/><entry>OP_EQUALVERIFY</entry></row><row><entry/><entry/><entry>OP_CHECKSIG</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><tbody valign="top"><row><entry>nLocktime: T<sub>R</sub></entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0248" num="0290">This refund transaction R simply spends the spendable outputs of the funding transaction F used to escrow funds to the channel. The purpose of the refund transaction R is simply to return the initial state of funds back to the participants in case no further states I<sub>n </sub>are mutually signed during the update phase of the PCL. Note that the refund transaction R can take exactly the same form, irrespective of whether the type of funding transaction F shown in <figref idref="DRAWINGS">FIG. <b>9</b>A</figref> or <figref idref="DRAWINGS">FIG. <b>9</b>B</figref> is used.</p><p id="p-0249" num="0291">The Loop Transaction</p><p id="p-0250" num="0292">The transactions corresponding to the update-phase of the payment channel are herein renamed loop transactions, because these will represent the inputs and outputs of each respective iteration of the loop. That is, each transaction of the series of spending transaction <b>600</b> shown in <figref idref="DRAWINGS">FIGS. <b>6</b>-<b>6</b>B</figref> is referred to as a loop transaction.</p><p id="p-0251" num="0293">Each loop transaction I<sub>i </sub>contains a set of values V<sub>i</sub>:=(&#x3d5;<sub>i</sub>,&#x3c9;<sub>i</sub>), representing the respective inputs and parameters to be consumed in the next iteration of the loop. Recall that in general it is plausible that the values (&#x3d5;<sub>i</sub>,&#x3c9;<sub>i</sub>) may reside anywhere inside a transaction. However, for simplicity they are shown here in the inputs. It may be advantageous however, to alternatively store these values in outputs (e.g. an OP_RETURN output) because these will become part of the signed message of a transaction, whereas input scripts are not themselves part of the signed message.</p><p id="p-0252" num="0294"><figref idref="DRAWINGS">FIG. <b>10</b></figref> shows specifically an initial loop transaction I<sub>0 </sub>shown spending the output of a funding transaction F. As shown in <figref idref="DRAWINGS">FIGS. <b>6</b>-<b>6</b>B</figref>, the initial loop transaction I<sub>0 </sub>is created in the first step of the payment channel negotiation S1 (immediately after the initial step S0 that establishes the funding and refund transactions F, R).</p><p id="p-0253" num="0295"><figref idref="DRAWINGS">FIG. <b>10</b></figref> shows a loop transaction, and depicts how its inputs sends the spendable output of the funding transaction. As expected for a Funded Nakamoto payment channel, the loop transaction has an nLocktime value set to some time T<sub>L </sub>in the future, and its nSequence value is non-maximal.</p><p id="p-0254" num="0296">The outputs of the loop transaction can take any form.</p><p id="p-0255" num="0297">Two examples of loop transactions are given below, as Transaction 4 and Transaction 5, both representing the i<sup>th </sup>iteration of the loop I<sub>i </sub>where i is an integer between 0 and the maximum value M. Recall that this transaction is necessarily locked until a time T<sub>L </sub>in the future, and the nSequence value increments until the maximum value M is reached or the time T<sub>L </sub>elapses. The first example shows a loop transaction whereby the inputs &#x3d5;<sub>i </sub>and the parameters &#x3c9;<sub>i </sub>for the i<sup>th </sup>iteration of the loop are stored in the inputs of the loop transaction.</p><p id="p-0256" num="0298">The second example shows a loop transaction where &#x3d5;<sub>i </sub>and &#x3c9;<sub>i </sub>are instead stored in an OP_RETURN output. This has the added benefit that the values and parameters may be part of the message signed by the signatures in the input of the transaction, which can be achieved with an appropriate choice of SIGHASH flags (e.g. SIGHASH ALL).</p><p id="p-0257" num="0299">Note that in both cases, for simplicity, the payment values in the outputs are shown to be monotonically increasing (1+i) or decreasing (11&#x2212;i), as in the case of unidirectional channel. However, this is not required in general&#x2014;the digital asset value(s) of the output(s) can change or stay the same depending on the outcome of the execution of the payment loop function F( ).</p><p id="p-0258" num="0000"><tables id="TABLE-US-00006" num="00006"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Transaction 4: A loop transaction I<sub>k </sub>(in detail) where</entry></row><row><entry>the inputs and parameters are stored in the input.</entry></row><row><entry>Loop transaction I<sub>i</sub>, TxID<sub>i</sub></entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="77pt" align="center"/><colspec colname="2" colwidth="140pt" align="center"/><tbody valign="top"><row><entry>Inputs</entry><entry>Outputs</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="28pt" align="left"/><colspec colname="2" colwidth="49pt" align="left"/><colspec colname="3" colwidth="42pt" align="left"/><colspec colname="4" colwidth="98pt" align="left"/><tbody valign="top"><row><entry>Value</entry><entry>Script</entry><entry>Value</entry><entry>Script</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row><row><entry>12 BSV</entry><entry>nSequence: i</entry><entry>11 &#x2212; i BSV</entry><entry>OP_DUP OP_HASH160 &#x3c;P<sub>A</sub>&#x3e;</entry></row><row><entry/><entry>&#x3c; Sig(P<sub>A</sub>, Tx<sub>i</sub>)&#x3e;</entry><entry/><entry>OP_EQUALVERIFY</entry></row><row><entry/><entry>&#x3c;P<sub>A</sub>&#x3e;</entry><entry/><entry>OP_CHECKSIG</entry></row><row><entry/><entry>&#x3c; Sig(P<sub>B</sub>, Tx<sub>i</sub>)&#x3e;</entry></row><row><entry/><entry>&#x3c;P<sub>B</sub>&#x3e;</entry></row><row><entry/><entry>&#x3c;&#x3d5;<sub>i</sub>&#x3e; &#x3c;&#x3c9;<sub>i</sub>&#x3e;</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="77pt" align="left"/><colspec colname="1" colwidth="42pt" align="left"/><colspec colname="2" colwidth="98pt" align="left"/><tbody valign="top"><row><entry/><entry>1 + i BSV</entry><entry>OP_DUP OP_HASH160 &#x3c;P<sub>B</sub>&#x3e;</entry></row><row><entry/><entry/><entry>OP_EQUALVERIFY</entry></row><row><entry/><entry/><entry>OP_CHECKSIG</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><tbody valign="top"><row><entry>nLocktime: T<sub>L</sub></entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0259" num="0000"><tables id="TABLE-US-00007" num="00007"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="center"/><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Transaction 5: A loop transaction I<sub>k </sub>(in detail) where</entry></row><row><entry>the inputs and parameters are stored in an output.</entry></row><row><entry>Loop transaction I<sub>i</sub>, TxID<sub>i</sub></entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="112pt" align="center"/><colspec colname="2" colwidth="147pt" align="center"/><tbody valign="top"><row><entry>Inputs</entry><entry>Outputs</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="35pt" align="left"/><colspec colname="2" colwidth="77pt" align="left"/><colspec colname="3" colwidth="49pt" align="left"/><colspec colname="4" colwidth="98pt" align="left"/><tbody valign="top"><row><entry>Value</entry><entry>Script</entry><entry>Value</entry><entry>Script</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row><row><entry>12 BSV</entry><entry>nSequence: i</entry><entry>0 BSV</entry><entry>OP_0 OP_RETURN &#x3c;&#x3d5;<sub>i</sub>&#x3e; &#x3c;&#x3c9;<sub>i</sub>&#x3e;</entry></row><row><entry/><entry>&#x3c; Sig(P<sub>A</sub>, Tx<sub>i</sub>)&#x3e; &#x3c;P<sub>A</sub>&#x3e;</entry></row><row><entry/><entry>&#x3c; Sig(P<sub>B</sub>, Tx<sub>i</sub>)&#x3e; &#x3c;P<sub>B</sub>&#x3e;</entry></row><row><entry/><entry/><entry>11 &#x2212; i BSV</entry><entry>OP_DUP OP_HASH160 &#x3c;P<sub>A</sub>&#x3e;</entry></row><row><entry/><entry/><entry/><entry>OP_EQUALVERIFY</entry></row><row><entry/><entry/><entry/><entry>OP_CHECKSIG</entry></row><row><entry/><entry/><entry>1 + i BSV</entry><entry>OP_DUP OP_HASH160 &#x3c;P<sub>B</sub>&#x3e;</entry></row><row><entry/><entry/><entry/><entry>OP_EQUALVERIFY</entry></row><row><entry/><entry/><entry/><entry>OP_CHECKSIG</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="center"/><tbody valign="top"><row><entry>nLocktime: T<sub>L</sub></entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0260" num="0300">The Settlement Transaction</p><p id="p-0261" num="0301">The settlement transaction S has exactly the same data as the most recent loop transaction, but it now has a maximal nSequence value. This disables the nLocktime value and causes the settlement transaction to be valid for mining onto the blockchain <b>150</b>.</p><p id="p-0262" num="0302"><figref idref="DRAWINGS">FIG. <b>11</b>A</figref> schematically depicts an example settlement transaction S.</p><p id="p-0263" num="0303"><figref idref="DRAWINGS">FIG. <b>11</b>B</figref> schematically depicts how the settlement transaction spends S the original funding transaction F.</p><p id="p-0264" num="0304">A detailed example of a settlement transaction S is shown below as Transaction 6. This assumes settlement after N iterations of the loop (hence &#x3d5;<sub>N</sub>,&#x3c9;<sub>N</sub>).</p><p id="p-0265" num="0000"><tables id="TABLE-US-00008" num="00008"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="center"/><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Transaction 6: An example settlement transaction S (in detail) where</entry></row><row><entry>the inputs and parameters are stored in an output.</entry></row><row><entry>Settlement transaction S, TxID<sub>S</sub></entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="112pt" align="center"/><colspec colname="2" colwidth="147pt" align="center"/><tbody valign="top"><row><entry>Inputs</entry><entry>Outputs</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="35pt" align="left"/><colspec colname="2" colwidth="77pt" align="left"/><colspec colname="3" colwidth="49pt" align="left"/><colspec colname="4" colwidth="98pt" align="left"/><tbody valign="top"><row><entry>Value</entry><entry>Script</entry><entry>Value</entry><entry>Script</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row><row><entry>12 BSV</entry><entry>nSequence:</entry><entry>0 BSV</entry><entry>OP_0 OP_RETURN &#x3c;&#x3d5;<sub>N</sub>&#x3e;</entry></row><row><entry/><entry>0xFF...F</entry><entry/><entry>&#x3c;&#x3c9;<sub>N</sub>&#x3e;</entry></row><row><entry/><entry>&#x3c; Sig(P<sub>A</sub>, Tx<sub>S</sub>)&#x3e; &#x3c;P<sub>A</sub>&#x3e;</entry></row><row><entry/><entry>&#x3c; Sig(P<sub>B</sub>, Tx<sub>S</sub>)&#x3e; &#x3c;P<sub>B</sub>&#x3e;</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="112pt" align="left"/><colspec colname="1" colwidth="49pt" align="left"/><colspec colname="2" colwidth="98pt" align="left"/><tbody valign="top"><row><entry/><entry>11 &#x2212; N BSV</entry><entry>OP_DUP OP_HASH160 &#x3c;P<sub>A</sub>&#x3e;</entry></row><row><entry/><entry/><entry>OP_EQUALVERIFY</entry></row><row><entry/><entry/><entry>OP_CHECKSIG</entry></row><row><entry/><entry>1 + N BSV</entry><entry>OP_DUP OP_HASH160 &#x3c;P<sub>B</sub>&#x3e;</entry></row><row><entry/><entry/><entry>OP_EQUALVERIFY</entry></row><row><entry/><entry/><entry>OP_CHECKSIG</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="center"/><tbody valign="top"><row><entry>nLocktime: T<sub>L</sub></entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0266" num="0305">3.1.4 Implementing the Loop</p><p id="p-0267" num="0306"><figref idref="DRAWINGS">FIG. <b>12</b></figref> shows a flow diagram to illustrate how the looping functionality of a PCL is implemented using a combination of the functional unit F <b>0</b>, as established in the funding transaction F, with the loop transactions I<sub>0</sub>, I<sub>1</sub>, I<sub>2</sub>, . . . created during the update-phase of the payment channel.</p><p id="p-0268" num="0307">The first loop transaction I<sub>0 </sub>includes the initial set of input and parameter values (&#x3d5;<sub>0</sub>,&#x3c9;<sub>0</sub>), which are not produced via execution of the functional unit. These values are the initial state from which the looping process will start.</p><p id="p-0269" num="0308">Each subsequent loop transaction I<sub>1</sub>, . . . , I<sub>N </sub>for N&#x2264;M is the result of the functional unit F( ) having been applied to the previous transaction as an operator. For example, I<sub>1</sub>=F(I<sub>0</sub>), I<sub>2</sub>=F(I<sub>1</sub>) and so on. This can also be understood as the functional unit being applied to the previous set of inputs and parameters: &#x3d5;<sub>i</sub>=F((&#x3d5;<sub>i&#x2212;1</sub>,&#x3c9;<sub>i&#x2212;1</sub>)).</p><p id="p-0270" num="0309">As indicated, the functional unit F( ) may also compute the digital asset value or values of the output or outputs of each loop transaction I<sub>i</sub>. Those digital asset value(s) are denoted v<sub>i</sub>, and the digital asset value(s) of the previous transaction I<sub>i </sub>may be used to do this. According to the above definition, the digital asset value(s) v are a form of input value &#x3d5;<sub>i</sub>. That it to say, the input value(s) &#x3d5;<sub>i </sub>may consist of or include the digital asset value(s) v of the loop transaction I<sub>i</sub>. At times, the present disclosure draws a distinction between digital asset value(s) v and input value(s) other than the digital asset value(s) v<sub>i</sub>, and for the latter, the notation &#x3d5;<sub>i</sub>&#x2032; may be used. Examples of input value(s) &#x3d5;<sub>i</sub>&#x2032; other than the digital asset value(s) v include. As a particular example, non-digital asset input value(s) of the previous transactions may be used to calculate the digital asset value(s) v of the current transaction I<sub>i</sub>:</p><p id="p-0271" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>v</i><sub>i</sub><i>=F</i>(&#x3d5;<sub>i&#x2212;1</sub>&#x2032;)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0272" num="0310">noting that F may take other arguments and/or return additional input value(s).</p><p id="p-0273" num="0311">In general, the functional unit F( ) can take only inputs &#x3d5;<sub>i</sub>, only parameters &#x3c9;<sub>i </sub>or both.</p><p id="p-0274" num="0312">By way of further example, the functional unit F( ) could have the effect of:</p><p id="p-0275" num="0313">2) Generating and inserting a new type of data field to I<sub>i </sub>(as opposed to changing an existing data field) which does not correspond to any existing data field in the previous transaction I<sub>i&#x2212;1 </sub>example would be adding an OP_RETURN output to the transaction I<sub>i</sub>.</p><p id="p-0276" num="0314">3) Removing an existing type of data field from I<sub>i&#x2212;1</sub>, i.e. such that the previous transaction contains a data field which does not correspond to any data field in the newly-created transaction I<sub>i</sub>.</p><p id="p-0277" num="0315">The functional unit F( ) is taken from the funding transaction F for each iteration of the loop, which can be stored in memory and non-duplicated.</p><p id="p-0278" num="0316">The execution of any one iteration of the loop is done off-chain, i.e. each step S1, S2, . . . , SN+1 is off-chain.</p><p id="p-0279" num="0317">Both parties sign on each new state I<sub>i </sub>(i.e. new loop transaction) to represent the progress of the computation of the loop. Once both parties have signed on one state, they can continue by executing the functional unit F( ) once again to produce the next state I<sub>i+1 </sub>to sign.</p><p id="p-0280" num="0318">3.2 Bidirectional PCLs</p><p id="p-0281" num="0319"><figref idref="DRAWINGS">FIG. <b>13</b></figref> shows an example process flow for implementing a bidirectional payment channel based on payment channel loops.</p><p id="p-0282" num="0320">The previous section establishes a generalised framework for implementing looping functionality inside a payment channel. This includes a set of transaction templates, and a looping mechanism that uses them, which allows the looping to be executed off-chain.</p><p id="p-0283" num="0321">The following example makes use of that framework to show how a bidirectional payment channel can be used to implement a simple loop of payments between two parties.</p><p id="p-0284" num="0322">Scenario</p><p id="p-0285" num="0323">Consider two pool players, Alice and Bob. They wish to play a one-on-one tournament comprising a large number N of games. Alice and Bob also wish to wager money on the outcome of the tournament, but are aware there is a risk that one player may refuse to continue playing and walk away from the table at any point.</p><p id="p-0286" num="0324">They therefore decide to use a bidirectional payment channel to ensure that the overall winnings are rebalanced in accordance with the proportion of games each player has one after each game. This way, each player can be cheated at most out of the winnings for one game.</p><p id="p-0287" num="0325">Their payment channel proceeds as follows:<ul id="ul0029" list-style="none">    <li id="ul0029-0001" num="0000">    <ul id="ul0030" list-style="none">        <li id="ul0030-0001" num="0326">1. Alice and Bob each agree to wager W/2, where W is the total possible prize pool for the tournament.</li>        <li id="ul0030-0002" num="0327">2. Alice and Bob cooperate to construct:        <ul id="ul0031" list-style="none">            <li id="ul0031-0001" num="0328">i. a funding transaction escrowing their total funds W; and</li>            <li id="ul0031-0002" num="0329">ii. a corresponding refund transaction, time-locked to T<sub>R </sub>in the future.</li>            <li id="ul0031-0003" num="0330">Note that the spendable output of the funding transaction includes a functional unit F( ), which will update the number time Alice has won and increment the total number of games by one each round. This is written in Bitcoin script as:</li>        </ul>        </li>    </ul>    </li></ul></p><p id="p-0288" num="0000"><tables id="TABLE-US-00009" num="00009"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="42pt" align="left"/><colspec colname="1" colwidth="175pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>[F ( )] = OP_IF</entry></row><row><entry/><entry>&#x2003;&#x2003;<img id="CUSTOM-CHARACTER-00003" he="2.46mm" wi="1.10mm" file="US20230004967A1-20230105-P00003.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;1&#x2009;<img id="CUSTOM-CHARACTER-00004" he="2.46mm" wi="1.10mm" file="US20230004967A1-20230105-P00004.TIF" alt="custom-character" img-content="character" img-format="tif"/> &#x2009;OP_ADD</entry></row><row><entry/><entry>&#x2003;OP_ENDIF</entry></row><row><entry/><entry>&#x2003;OP_SWAP &#x3c;1&#x3e; OP_ADD OP_SWAP</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><ul id="ul0032" list-style="none">    <li id="ul0032-0001" num="0000">    <ul id="ul0033" list-style="none">        <li id="ul0033-0001" num="0331">3. After each round of pool, Alice and Bob construct a loop transaction, with nLocktime set to a time T<sub>L </sub>in the future, and spending the funding transaction. This transaction has input containing:        <ul id="ul0034" list-style="none">            <li id="ul0034-0001" num="0332">i. &#x3d5;<sub>i</sub>={Total No. Games, No. Games won by Alice already}={K, k<sub>A</sub>}</li>            <li id="ul0034-0002" num="0333">ii. &#x3c9;<sub>i</sub>={Outcome of this round}=1 (Alice wins) or 0 (Alice loses) (note 0 and 1 can be any values that denote a win and a loss by Alice respectively)</li>        </ul>        </li>        <li id="ul0033-0002" num="0334">4. This process is repeated until either the total number of games N is reached, and Alice and Bob settle, or one party decides to stop playing and they settle prematurely.</li>    </ul>    </li></ul></p><p id="p-0289" num="0335">In this scenario, the repeating unit F( ) updates the number of games won by Alice and the total number of games played each round. This means the payment amounts can be rebalanced in proportion to games won by each player, k<sub>A</sub>/K:1&#x2212;k<sub>A</sub>/K, in each loop transaction.</p><p id="p-0290" num="0336">Observations about Bidirectional PCLs</p><p id="p-0291" num="0337">As it is a bidirectional channel, the final state may favour either party. It is expected that this party will check the final state of the transaction, and they are incentivised to publish that final state to be mined.</p><p id="p-0292" num="0338">The redistribution of funds between any two consecutive states of the channel may favour one party or the other. It is expected that at least one party, most likely the party favoured by each state transition, will check the most recent state (i.e. output of a state transition). When a party chooses to &#x2018;settle prematurely&#x2019;, they are merely broadcasting the most recent state once T<sub>L </sub>has elapsed, rather than continuing to increment nSequence further.</p><p id="p-0293" num="0339">Neither party is able to cheat the other by publishing an earlier transaction because of the effect nSequence and nLocktime values in the update-phase transactions. If one party does publish an earlier state, the other can simply publish a more recent state (with greater nSequence), which will override the earlier state from the perspective of miners.</p><p id="p-0294" num="0340">The act of creating and updating the transactions in the update phase may be performed by Alice, Bob or some off-chain oracle system (see section 4). The order in which each transaction is signed may also be dependent on the exact configuration of this process, as well as the situational requirements of the scenario in which the PCL is used.</p><p id="p-0295" num="0341">The case here assumes the functional unit is written in Script, and stored in a spendable output. However, as noted, this may be replaced with a functional unit F( ) written in any programming language and stored in an OP_RETURN output or other unspendable output since, the execution of the body of the loop statements is performed off-chain.</p><p id="p-0296" num="0342">3.2.1 Bidirectional PCLs</p><p id="p-0297" num="0343">Possible use cases for bidirectional PCLs include:<ul id="ul0035" list-style="none">    <li id="ul0035-0001" num="0000">    <ul id="ul0036" list-style="none">        <li id="ul0036-0001" num="0344">Micropayments for utilities used on repeated basis;</li>        <li id="ul0036-0002" num="0345">Payment for monitoring services;</li>        <li id="ul0036-0003" num="0346">Commerce involving in-flows and out-flow from multiple merchants; and</li>        <li id="ul0036-0004" num="0347">Gaming involving repeated actions (e.g. turn-based RPGs).</li>    </ul>    </li></ul></p><p id="p-0298" num="0348">3.3 Unidirectional PCLs</p><p id="p-0299" num="0349"><figref idref="DRAWINGS">FIG. <b>14</b></figref> shows a process flow for an example unidirectional PCL.</p><p id="p-0300" num="0350">This section describes examples of how unidirectional PCLs may be used, as a special case of PCLs in general, to implement certain tasks. In particular, tasks such as:<ul id="ul0037" list-style="none">    <li id="ul0037-0001" num="0000">    <ul id="ul0038" list-style="none">        <li id="ul0038-0001" num="0351">Paid computation; and</li>        <li id="ul0038-0002" num="0352">Repeated micropayments.</li>    </ul>    </li></ul></p><p id="p-0301" num="0353">The case of paid computation is considered for the following explanation.</p><p id="p-0302" num="0354">Scenario</p><p id="p-0303" num="0355">Consider two parties, Alice and Bob. Alice is a researcher working in remote location, with little access to computational resources, while Bob is a service provider, specialising in &#x2018;pay-per-computation&#x2019; services.</p><p id="p-0304" num="0356">Alice wishes to pay bob to compute the value of 2<sup>N</sup>, where N is a very large integer, such that Alice cannot efficiently compute the desired valuer herself. Bob offers to compute the value for Alice, in return for payment. However, he stipulates that he wishes to be paid incrementally, an amount k per computation, using micropayments.</p><p id="p-0305" num="0357">In order to achieve this, Alice and Bob agree to implement a unidirectional PCL between them. The PCL variant chosen is unidirectional because Alice (payer) is always paying Bob (payee) in each iteration of the loop. Their payment channel loop proceeds as follows:<ul id="ul0039" list-style="none">    <li id="ul0039-0001" num="0000">    <ul id="ul0040" list-style="none">        <li id="ul0040-0001" num="0358">1. Alice and Bob agree on a price k=&#xa3;1 per computation round. This is the amount that Alice will pay Bob for computing (&#x3d5;<sub>i</sub>,&#x3c9;<sub>i</sub>)=F((&#x3d5;<sub>i&#x2212;1</sub>,&#x3c9;<sub>i&#x2212;1</sub>)) in each iteration of the loop.</li>        <li id="ul0040-0002" num="0359">2. Alice and Bob cooperate to construct:        <ul id="ul0041" list-style="none">            <li id="ul0041-0001" num="0360">i. a funding transaction escrowing Alice's total funds k&#xd7;N; and</li>            <li id="ul0041-0002" num="0361">ii. a corresponding refund transaction, time-locked to T<sub>R </sub>in the future.</li>            <li id="ul0041-0003" num="0362">The spendable output of the funding transaction includes a functional unit F( ), which simply multiplies a single input argument V<sub>i</sub>=&#x3d5;<sub>i</sub>=(Argument) by 2, written in Bitcoin script as:</li>            <li id="ul0041-0004" num="0363">[F( )]=&#x3c;2&#x3e;OP_MUL</li>        </ul>        </li>        <li id="ul0040-0003" num="0364">3. Alice creates the initial loop transaction, which includes the initial input argument &#x3d5;<sub>0</sub>=(2), which establishes the value to be multiplied by 2 using the functional unit.</li>        <li id="ul0040-0004" num="0365">4. Bob (or an oracle operated by Bob) constructs each subsequent loop transaction, which spend the funding transaction from step <b>2</b> and have nLocktime set to T<sub>L </sub>in the future. The input of each loop transaction contains the newly calculated value &#x3d5;<sub>i</sub>=(2<sup>i</sup>), for i&#x3e;0.</li>        <li id="ul0040-0005" num="0366">5. This process is repeated until either the final value &#x3d5;<sub>N</sub>=(2<sup>N</sup>) is computed by Bob, or one party decides to terminate the interaction and settle prematurely.</li>    </ul>    </li></ul></p><p id="p-0306" num="0367">Observations about on Unidirectional PCLs</p><p id="p-0307" num="0368">As it is a unidirectional channel, the final state will always favour Bob (the receiving party). It is expected that this party will check the final state of the transaction, and they are incentivised to publish that final state to be mined. Note that, because it is unidirectional, Bob is always incentivised to publish the final (or otherwise most recent) transaction.</p><p id="p-0308" num="0369">The sending party (Alice) in a unidirectional channel is always incentivised to publish a non-final (or otherwise earlier) transaction. However, the mechanism of nSequence and nLocktime is used to prevent Alice from doing so. If Alice does publish an earlier state, then Bob can simply publish a more recent state (with greater nSequence), which will override the earlier state from the perspective of miners. When a party chooses to &#x2018;settle prematurely&#x2019;, they are merely broadcasting the most recent state once T<sub>L </sub>has elapsed, rather than continuing to increment nSequence further.</p><p id="p-0309" num="0370">The redistribution of funds between any two consecutive states of the channel may favour one party or the other. It is expected that at least one party, most likely the party favoured by each state transition, will check the most recent state (i.e. output of a state transition). However, in the case of paid computation, where all state transitions favour Bob (the receiver), it is expected that Bob will check new states of the payment channel funds.</p><p id="p-0310" num="0371">The act of creating and updating the transactions in the update phase may be performed by Alice, Bob or some off-chain oracle system (see section 4). The order in which each transaction is signed may also be dependent on the exact configuration of this process, as well as the situational requirements of the scenario in which the PCL is used.</p><p id="p-0311" num="0372">This assumes the functional unit F( ) is written in Script, and stored in a spendable output. However, as noted, this can be replaced with a functional unit F( ) written in any programming language and stored in an OP_RETURN output or other unspendable output since, the execution of the body of the loop statements is performed off-chain.</p><p id="p-0312" num="0373">In practice, Alice is unlikely to be in a position to verify every computation by Bob (because, if she were in that position, she might be unlikely to outsource the computation in the first place). However, Alice can &#x201c;sample&#x201d; a limited number of computational results provided by Bob (e.g. using random sampling) and verify the computations herself to check they match.</p><p id="p-0313" num="0374">Function Variables in Funding Transaction</p><p id="p-0314" num="0375">Note, in addition or an alternative to including the initial function variables (&#x3d5;<sub>0</sub>,&#x3c9;<sub>0</sub>) in the first loop transaction I<sub>0</sub>, it may also be desirable to include or otherwise evidence the initial conditions, expressed as (&#x3d5;<sub>0</sub>,&#x3c9;<sub>0</sub>), in the funding transaction F itself. This would allow the initial state to always be published on-chain. In this case, the initial state can be compared to the state that is later published on-chain to close the channel in the settlement phase. By comparing the initial state and the settled state, both of which now reside on-chain, it can be seen how much of the looped process was executed i.e. whether it reached the expected termination point or whether it was prematurely terminated. An example of a unidirectional PCL employing this principle is shown in <figref idref="DRAWINGS">FIG. <b>15</b></figref>. This shows the early steps of the process, and in contrast to <figref idref="DRAWINGS">FIG. <b>14</b></figref>, the initial values (&#x3d5;<sub>0</sub>,&#x3c9;<sub>0</sub>) are taken from the funding transaction F; thereafter the process continues as in <figref idref="DRAWINGS">FIG. <b>14</b></figref>. Note, although a unidirectional PCL is considered by way of example, this applies equally to a bidirectional PLC.</p><p id="p-0315" num="0376">Evidencing Input Values &#x3d5;<sub>i</sub>/Parameters &#x3c9;<sub>i </sub>in Settlement Transaction S</p><p id="p-0316" num="0377"><figref idref="DRAWINGS">FIG. <b>18</b>A</figref> shows a settlement transaction S, denoted by reference numeral <b>1800</b>, in which an additional piece of information <b>1802</b> is contained. The additional piece of information <b>1802</b> evidences the full sequence of inputs and/or parameters that resulted in the settlement transaction <b>1800</b>, i.e. (&#x3d5;<sub>0</sub>,&#x3c9;<sub>0</sub>), (&#x3d5;<sub>1</sub>,&#x3c9;<sub>1</sub>), . . . , (&#x3d5;<sub>M</sub>,&#x3c9;<sub>M</sub>). In the present example, that piece of information takes the form of a Merkle root hash <b>1802</b> of a Merkle tree <b>1801</b> shown in <figref idref="DRAWINGS">FIG. <b>18</b>B</figref>.</p><p id="p-0317" num="0378"><figref idref="DRAWINGS">FIG. <b>18</b>B</figref> shows the Merkle tree <b>1801</b> to comprise a plurality of leaf nodes <b>1804</b>, each of which represents one set of inputs/transactions (&#x3d5;<sub>i</sub>,&#x3c9;<sub>i</sub>). For example, each leaf node <b>1804</b> may be a hash of that set. The sets of inputs/parameters are ordered by root iteration. i.e. from 0 to M. The Merkle tree also comprises a hierarchy of intermediate nodes <b>1806</b>. A lowest level of intermediate node is created by hashing a pair of non-leaf nodes, and each intermediate node at any level above that is created by hashing a pair of non-leaf nodes one level below&#x2014;all the way up to the root hash <b>1802</b>. The verb &#x201c;to hash&#x201d; in this context means &#x201c;to generate by applying at least one cryptographic hash function&#x201d;, so includes double hashing etc. Merkle trees are known per se as a data structure for evidencing and efficiently verifying sequenced data elements. Therefore the structure of the Merkle tree <b>1802</b> is not described in further detail. Suffice it to say that the root hash <b>1802</b> concisely and robustly evidences the entire sequence of inputs/parameters.</p><p id="p-0318" num="0379">Once the settlement transaction S has been published, the functional unit F( ) in the funding transaction F (now spent by the committed settlement transaction S) can be used to verify the settlement transaction S, e.g. to verify the final distribution of digital asset defined by the value(s) v<sub>M </sub>of its output(s) (assuming the functional unit F( ) is used to compute those value(s) v<sub>i</sub>) given a verifiable sequence of input values/parameters. The given sequence of input value's/parameters can be verified by using that sequence to compute a reconstructed root hash for comparison with the root hash <b>1802</b> in the settlement transaction S.</p><p id="p-0319" num="0380">A Merkle root hash <b>1802</b> is just one example of a piece of data that can evidence the input value/parameter sequence. For example, a simple hash, double hash etc. of the sequence could be used instead, or indeed the sequence itself could simply be included in the settlement transaction S of that information is non-sensitive. A Merkle tree <b>1801</b> has the benefit that any single set of input values/parameters (&#x3d5;<sub>i</sub>,&#x3c9;<sub>i</sub>) can be verified as belonging to the Merkle tree <b>1802</b> using a Merkle proof, and the ability to do this may be beneficial in certain circumstances&#x2014;but not necessarily required. Merkle proofs are known per se and not described herein.</p><p id="p-0320" num="0381">3.3.1 Use Cases</p><p id="p-0321" num="0382">Possible use cases for bidirectional PCLs include:<ul id="ul0042" list-style="none">    <li id="ul0042-0001" num="0000">    <ul id="ul0043" list-style="none">        <li id="ul0043-0001" num="0383">Paid computation; or</li>        <li id="ul0043-0002" num="0384">Recursive merchant-customer interactions e.g. payment of micro-subscriptions.</li>    </ul>    </li></ul></p><p id="p-0322" num="0385">3.4 Further Considerations</p><p id="p-0323" num="0386">Incentive Models</p><p id="p-0324" num="0387">Payment channels rely at least to some extent on incentive models to ensure that no one participant in the channel may successfully cheat any other participant, such that the latter receives less than they otherwise would have. The broad incentive models for the payment channels described herein are as follows:<ul id="ul0044" list-style="none">    <li id="ul0044-0001" num="0000">    <ul id="ul0045" list-style="none">        <li id="ul0045-0001" num="0388">Nakamoto&#x2014;both parties are incentivised not to cheat primarily due to circumstance. If the participants have been updating the state of a transaction, it would be damaging to their relationship should one party choose to double-spend their input and invalidate the negotiation.</li>        <li id="ul0045-0002" num="0389">Funded Nakamoto&#x2014;at any point in time, either party may be incentivised to cheat depending on the state of the channel. However, the features (i) funding transaction in set-up; and (ii) nSequence and nLocktime, are used to mitigate the incentive to cheat by ensuring that neither party is able to successfully cheat the other by publishing an earlier version of a transaction.</li>    </ul>    </li></ul></p><p id="p-0325" num="0390">The Security and Efficiency Trade-Off</p><p id="p-0326" num="0391">When choosing a payment channel architecture for a particular use case, one will generally be met with a trade-off; specifically between security and efficiency. These terms are defined broadly as:<ul id="ul0046" list-style="none">    <li id="ul0046-0001" num="0000">    <ul id="ul0047" list-style="none">        <li id="ul0047-0001" num="0392">Security&#x2014;because payment channels generally involve the transfer of funds between multiple parties, care must be taken to ensure that neither party may practically cheat the other out of funds. The security of a channel is therefore an expression of the ability of a participating party to cheat.</li>        <li id="ul0047-0002" num="0393">Efficiency&#x2014;for payment channels, efficiency may refer collectively to the amount of data that must be exchanged, latency that must be incurred and financial cost that must be sacrificed in order to implement the channel to achieve a particular goal.</li>    </ul>    </li></ul></p><p id="p-0327" num="0394">In general, a choice needs to be made between using a Funded Nakamoto channel, which has high-security, and using a Nakamoto channel, which has high-efficiency.</p><p id="p-0328" num="0395">FN channels are described as &#x2018;high-security&#x2019;, as mentioned in section 2.2.2, for two reasons. The use of nSequence and nLocktime in conjunction mitigates the possibility that a state that is older than the final or current state is mined. In addition, the use of a funding transaction mitigates the possibility that either party can &#x2018;double-spend&#x2019; the funds contributed to the channel by committing them to mutual escrow in the set-up phase.</p><p id="p-0329" num="0396">Nakamoto channels are described as &#x2018;high-efficiency&#x2019; because they do not require a funding transaction (nor associated refund transaction). This means that not only is the set-up phase much more succinct and less data-intensive, but the channel only requires for one transaction to published and mined, which reduces the total value in &#x2018;transaction fees&#x2019; required to implement the channel.</p><p id="p-0330" num="0397">Consider, for example, the scenario where Alice and Bob are a customer and a highly-reputable merchant respectively. They mutually wish to use a payment channel to record a set of recurring purchases of an item without publishing a transaction for each individual purchase. A Nakamoto payment channel would lend itself well to this scenario because Alice and Bob have external, real-world reasons to trust the other party, which make efficiency the primary consideration.</p><p id="p-0331" num="0398">Conversely, if Alice and Bob are distant peers connected over the internet, wishing to exchange data via a payment channel, each party may be unable to validate trustworthiness of the other. In this case, security would be the primary concern, and thus an FN channel may be the better option.</p><p id="p-0332" num="0399">The key point is that different payment channels may be used to perform the same tasks, or different tasks, depending on the situation. When introducing the concept of Payment Channel Loops in section 4, this reasoning applies also. The fact that a particular loop is shown to implemented using one architecture does not necessarily preclude it from being implemented using another.</p><p id="p-0333" num="0400">Update-Phase Race Conditions</p><p id="p-0334" num="0401">In channels that involve nSequence and nLocktime&#x2014; Nakamoto and FN architectures&#x2014;it is possible that a race condition may occur if two conflicting states, with non-finalised nSequence value, are published near their common locktime T<sub>L</sub>.</p><p id="p-0335" num="0402">The issue lies in the fact that two such alternative versions, with different nSequence values but a common nLocktime value T<sub>L </sub>will both appear independently as valid once the locktime is reached. It is therefore possible that one version I<sub>1 </sub>(i.e. the earlier version, favouring Alice) could be published by Alice near T<sub>L </sub>and be mined very quickly.</p><p id="p-0336" num="0403">Although Bob can see when the earlier version is published, and respond by publishing the more recent version I<sub>2 </sub>(favouring Bob), there is still a non-zero probability that I<sub>1 </sub>may be mined before I<sub>2</sub>, which is tantamount to double-spend in the channel.</p><p id="p-0337" num="0404">The probability of such an event is highly unlikely, given that all mining nodes are likely to receive both transactions (if broadcast in quick succession) before a new block is found, and any honest miner would drop I<sub>1 </sub>and deem I<sub>2 </sub>the only valid version given its higher nSequence number. Nonetheless, there are many ways in the risk of such a scenario can be mitigated, two of which are:<ul id="ul0048" list-style="none">    <li id="ul0048-0001" num="0000">    <ul id="ul0049" list-style="none">        <li id="ul0049-0001" num="0405">Variable nLocktime&#x2014; decreasing the value of nLocktime in the update phase transaction each time the nSequence value is increased ensures that the most recent version of a transaction will always become valid to mine earlier than an older version.</li>        <li id="ul0049-0002" num="0406">Fee incrementation&#x2014;by increasing the total transaction fee for each new version of the update-phase transaction, miners can be incentivised to mine the most recent version simply on the basis of profitability.</li>    </ul>    </li></ul></p><p id="p-0338" num="0407">Receiver Checking</p><p id="p-0339" num="0408">With reference to sections 3.2 and 3.3 in particular, there is an onus on at least one of interacting parties (or an oracle; see section 4) to check the values of the funds distributed in the outputs of each update-phase transaction in a PCL.</p><p id="p-0340" num="0409">In general, this will likely be the responsibility of whichever party acts a &#x2018;receiver&#x2019;. As discussed in section 2 (&#x2018;directionality&#x2019;), either party may be a net beneficiary of a given state transition in both bidirectional and unidirectional PCLs. Therefore the onus may be on either party to check the allocation of funds, and indeed the integrity of the transaction itself, for any state transition. However, in unidirectional channels, the final state should always be checked by the overall receiving party.</p><p id="p-0341" num="0410">Verification of &#x3d5;<sub>i </sub>Values</p><p id="p-0342" num="0411">A key feature of the PCL architectures are that input/output values &#x3d5;<sub>i </sub>are updated in each iteration of the loop, according to the repeating unit, as: &#x3d5;<sub>i</sub>=F((&#x3d5;<sub>i&#x2212;1</sub>,&#x3c9;<sub>i&#x2212;1</sub>)).</p><p id="p-0343" num="0412">However, this is generally done by a &#x2018;computing party&#x2019; (e.g. Bob), so for the description has omitted any consideration of how the &#x2018;non-computing party&#x2019; (e.g. Alice) may verify the correctness of an output value &#x3d5;<sub>i </sub>for a given input value &#x3d5;<sub>i&#x2212;1</sub>. In general, there are at least three methods may be used to do this:<ul id="ul0050" list-style="none">    <li id="ul0050-0001" num="0000">    <ul id="ul0051" list-style="none">        <li id="ul0051-0001" num="0413">Trap-door functions&#x2014;if the repeating unit involves finding a solution to a computationally difficult trap-door problem, such as finding a hash digest under a target value by repeated hashing, then the final result will have a trap-door for fast verification. This means the non-computing party will be able to quickly verify that the final value &#x3d5;<sub>N </sub>given by the computing value is indeed correct and valid.</li>        <li id="ul0051-0002" num="0414">Random spot-checking&#x2014;because it is expected that the repeating unit will be reused for every iteration of the loop, it is possible for the &#x2018;non-computing party&#x2019; to take a single input &#x3d5;<sub>i&#x2212;1 </sub>and verify that it produces the correct candidate output &#x3d5;<sub>i </sub>as calculated by the &#x2018;computing party&#x2019;. The non-computing party may do this at any point in the loop, and at random intervals, which means that the behaviour of the computing party can be checked at any instance in time.</li>        <li id="ul0051-0003" num="0415">Use of oracle system&#x2014;the functional unit F( ) may be set up within some kind of oracle-based system, where the &#x2018;rules&#x2019; of how the oracle operates are well known and auditable ahead of time. See section 4 below.</li>    </ul>    </li></ul></p><p id="p-0344" num="0416">3.5 Chained PCLs</p><p id="p-0345" num="0417">There is a limit to the number of operations that can be implemented within a single PCL process. In Bitcoin, this is currently approximately 4.3 billion, or rather 2<sup>32</sup>&#x2212;1 operations. This is expected to be sufficient in most practical contexts.</p><p id="p-0346" num="0418">Nevertheless, it is possible to overcome this limit simply by chaining multiple PCLs together. In this way, the maximum number of operations can be extended to any arbitrarily large number, where each individual PCL process is used to cover up to approximately 4.3 billion operations.</p><p id="p-0347" num="0419">Method</p><p id="p-0348" num="0420">The method for implementing PCLs is simply to treat the settlement phase of one PCL as the set-up phase of the next PCL.</p><p id="p-0349" num="0421">This involves modifying the normal settlement phase of a PCL in the following way:<ul id="ul0052" list-style="none">    <li id="ul0052-0001" num="0000">    <ul id="ul0053" list-style="none">        <li id="ul0053-0001" num="0422">In a normal, singular PCL the settlement phase simply involves finalising the most recently signed update-phase transaction, by signing a transaction representing the same state but with an nLocktime value of 0. This allows the most recent state to be broadcast and published to the blockchain. This transaction submitted to the blockchain represents the final state of the channel, and has outputs to both parties that reflect this final state.</li>        <li id="ul0053-0002" num="0423">To implement a series of chained PCLs, the settlement of one PCL involves signing a final state that locks funds to a multi-signature output, rather than to multiple outputs to the multiple involved parties. By locking to a multisignature output, the settlement transaction becomes functionally equivalent to a funding transaction, which can be used to begin the next PCL.</li>        <li id="ul0053-0003" num="0424">A new refund transaction is signed, spending the output of the new funding transaction back to the participating parties according to the final state of the previous PCL. This ensures that the outcome of the previous PCL is preserved as the default refund outcome of the next PCL.</li>    </ul>    </li></ul></p><p id="p-0350" num="0425">This design for a series of chained PCLs is outlined in <figref idref="DRAWINGS">FIG. <b>16</b></figref>. A sector labelled <b>1300</b> highlights the crossover between the first and second PCLs (note, the settlement of the first PCL and the set-up of the second PCL are treated as a single phase).</p><p id="p-0351" num="0426">In this hybrid phase, the creation of the first settlement transaction (S1) is considered tantamount to the creation of the second funding transaction (F2). The second refund transaction (R2) is also shown, which spends the funds of F2 back to the participants in exactly the same way as in the final update-phase transaction (I<sub>N</sub>) of the first PCL.</p><heading id="h-0010" level="1">4. Payment Channel Oracles</heading><p id="p-0352" num="0427">Section 3 considered two participating parties Alice and Bob, acting in a peer-to-peer fashion. In each case, at least one of the two parties is relied upon to perform the off-chain execution of the repeating code unit F( ) of the loop.</p><p id="p-0353" num="0428">However, it is possible to generalise this off-chain process and delegate it to the role of an oracle (e.g. the oracle <b>102</b><i>o </i>in <figref idref="DRAWINGS">FIG. <b>3</b>A</figref>, or the oracles <b>102</b><i>o</i>-<b>1</b>, <b>102</b><i>o</i>-<b>2</b> in <figref idref="DRAWINGS">FIG. <b>3</b>B</figref>), which reads each successive loop transaction, in conjunction with the initial funding transaction, and executes the function to produce the next transaction.</p><p id="p-0354" num="0429">Trusted oracles per se are a known concept in blockchain technology. A typical role of a trusted oracle is to provide a trusted source of external data that may, for example, be time dependent. An example might, for example, be where a smart contract in an account-based model is executed in dependence on current weather conditions, or the outcome of a sporting event, where that information is provided by a mutually-agreed oracle.</p><p id="p-0355" num="0430">In the present context, the status of a trusted oracle is similar in that a particular trusted oracle is agreed by two parties, however the tole of the trusted oracle is to apply a predefined (and pre-agreed) set of rules for creating payment channel transactions&#x2014;namely, the rules encoded in the functional unit F( ).</p><p id="p-0356" num="0431">An execution oracle is permitted to construct transactions in the payment channel. Transactions may be parameterised as:<ul id="ul0054" list-style="none">    <li id="ul0054-0001" num="0000">    <ul id="ul0055" list-style="none">        <li id="ul0055-0001" num="0432">1. Locktime,</li>        <li id="ul0055-0002" num="0433">2. Sequence number,</li>        <li id="ul0055-0003" num="0434">3. Outputs        <ul id="ul0056" list-style="none">            <li id="ul0056-0001" num="0435">a. Index,</li>            <li id="ul0056-0002" num="0436">b. Value,</li>            <li id="ul0056-0003" num="0437">c. Locking script.</li>        </ul>        </li>    </ul>    </li></ul></p><p id="p-0357" num="0438">That is, the execution oracle can set the locktime, the sequence number, or the outputs of a transaction according to the computation results from an iteration. Note that, for simplicity, it is assumed the input of the transaction is the outpoint from the funding transaction, which cannot be changed by the oracle. Once the oracle creates a new version of the spending transaction, the relevant participants can sign the transaction.</p><p id="p-0358" num="0439">There are a certain rules that applies to any implementation of such oracle:<ul id="ul0057" list-style="none">    <li id="ul0057-0001" num="0000">    <ul id="ul0058" list-style="none">        <li id="ul0058-0001" num="0440">1. Locktime: T<sub>Li</sub>&#x2264;T<sub>L</sub><sub><sub2>i&#x2212;1</sub2></sub>&#x2264;T<sub>L</sub>.</li>        <li id="ul0058-0002" num="0441">2. Sequence number: max&#x3e;s<sub>i</sub>&#x3e;s<sub>i&#x2212;1</sub>&#x3e;0.</li>        <li id="ul0058-0003" num="0442">3. The total output value is equal to or less than the value of the funding transaction or the total value given by the inputs.</li>    </ul>    </li></ul></p><p id="p-0359" num="0443">This may be generalised by allowing any implementation of an oracle or many oracles in a payment channel. If all participants in the payment channel agree on a set of rules implemented as oracles, all transactions exchanged via the payment channel will have to follow the new rules in addition to being valid under the bitcoin protocol.</p><p id="p-0360" num="0444">That is, a payment channel offers an instance of a customised interaction channel with functionalities and utilities, of which the security and payments are backed up by the bitcoin protocol.</p><p id="p-0361" num="0445">4.1 Chess Payment Channel</p><p id="p-0362" num="0446">A first example is considered in which Alice and Bob can play chess against each other. The core idea here is to implement a trusted oracle that enforces the rules of chess&#x2014;encoded in the functional unit F( ). Note this example is used to introduce concepts that are generally applicable to any payment channel in which an oracle acts as an &#x201c;intermediary&#x201d; between two parties&#x2014;i.e. as broadly illustrated in <figref idref="DRAWINGS">FIG. <b>3</b>A</figref>. Although described in the context of the chess game example, the relevant description applies equally to any such scenario.</p><p id="p-0363" num="0447">The oracle is trusted is the limited sense of being trusted not to collude with either player.</p><p id="p-0364" num="0448">Setup</p><p id="p-0365" num="0449">Both Alice and Bob verify the source code that implements the chess oracle which can be provided by a third party. Alice, Bob, and the chess oracle create a 2-out-of-3 funding transaction F and the corresponding refund transaction R to open the chess payment channel. To make the game more exciting, both Alice and Bob are rewarded a small portion of the fund when they capture the other's piece.</p><p id="p-0366" num="0450">A 2-out-of-three funding transaction has a transaction output which contains three public keys&#x2014;of Alice, Bob and the oracle respectively&#x2014;as operands of a 2-of-3 check multi-signature operate. Hence any two of Alice, Bob and the Oracle can unlock the output, by providing transaction signatures valid with respect to their specified public keys.</p><p id="p-0367" num="0451"><figref idref="DRAWINGS">FIG. <b>17</b></figref> shows an example of a 2-out-of-3 funding transaction F, denoted by reference numeral <b>1700</b>. This particular funding transaction <b>1700</b> is the same as the &#x201c;2-out-of-2&#x201d; funding transaction <b>152</b>-<i>i </i>of <figref idref="DRAWINGS">FIG. <b>9</b>A</figref>, except for the fact that the spendable output of the funding transaction <b>1302</b> specifies three public keys&#x2014;of Bob, Alice and the Oracle <b>102</b><i>o</i>&#x2014; and requires only two valid transaction signatures to unlock, i.e. Alice+Bob can unlock, Alice+Oracle can unlock and Bob+Oracle can unlock.</p><p id="p-0368" num="0452">The public key of the Oracle <b>102</b><i>o </i>constitutes a public identity of the oracle <b>102</b><i>o</i>&#x2014; hence, by signing the funding transaction and committing it to the blockchain, Alice and Bob are, by choice, mutually authorized the Oracle <b>102</b><i>o </i>to act as an intermediary in the payment channel, and immutably recording that authorization in the blockchain <b>150</b>. In this manner, each of the parties agrees the identity of the oracle <b>102</b><i>o</i>, and that agreement is immutably recorded in the funding transaction F. If any party does not have sufficient trust in the particular oracle, he/she/it is free to refuse to sign the payment transaction.</p><p id="p-0369" num="0453">The role of the oracle <b>102</b><i>o </i>is to execute the functional unit F( ) specified in the funding transaction <b>1300</b> to create loop transactions (or at least component(s) thereof), and to provide one of the two required signatures for each loop transaction. It can be assumed that Alice and Bob will only sign the funding transaction <b>1300</b> if they each trust the oracle <b>102</b><i>o </i>to carry out that role as expected.</p><p id="p-0370" num="0454">Playing Chess</p><p id="p-0371" num="0455">A chess game implemented via a payment channel is described move by move. In each move, the oracle <b>102</b><i>o </i>will prepare a transaction template for the player (Alice or Bob who take it in turns to select game moves). The functional unit F( ) is applied to verify each game move and update a game state of the game if the move is valid. In the above parlance, each game move is a parameter(s) &#x3c9;<sub>i </sub>(determined external to the loop&#x2014;by the players and each game state is an input value(s) &#x3d5;<sub>i </sub>(determined from by applying F( ) to the previous game state and the most recent move &#x3c9;<sub>i&#x2212;1</sub>).</p><p id="p-0372" num="0456">The player will be able to read from the transaction<ul id="ul0059" list-style="none">    <li id="ul0059-0001" num="0000">    <ul id="ul0060" list-style="none">        <li id="ul0060-0001" num="0457">1. the current state of the chessboard, and</li>        <li id="ul0060-0002" num="0458">2. the distribution of the fund that reflects the current state of the chessboard.</li>    </ul>    </li></ul></p><p id="p-0373" num="0459">The player then fills in their move in the OP_RETURN payload and signs the transaction.</p><p id="p-0374" num="0460">When the oracle <b>102</b><i>o </i>receives the signed transaction, it checks the validity of the move and the signature. If both are valid, the oracle <b>102</b><i>o </i>signs the transaction to make up the 2-out-of-3 multiSig.</p><p id="p-0375" num="0461">The oracle <b>102</b><i>o </i>applies the move to the chessboard and computes the resulting state. According to the new state, the oracle <b>102</b><i>o </i>computes the corresponding distribution of the fund between the two players. The oracle <b>102</b><i>o </i>then creates a new transaction template with a lower locktime, a higher sequence number and three updated outputs, one of which is the OP_RETURN payload containing the new state and all historical moves.</p><p id="p-0376" num="0462">A list of transactions is provided below.</p><p id="p-0377" num="0463">Move 1:</p><p id="p-0378" num="0464">Suppose Alice makes her first move. She gets a transaction template from the chess oracle <b>102</b><i>o</i>-, competes her move and signs the transaction.</p><p id="p-0379" num="0000"><tables id="TABLE-US-00010" num="00010"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="273pt" align="center"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>TxID<sub>1</sub></entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="91pt" align="left"/><colspec colname="3" colwidth="35pt" align="left"/><colspec colname="4" colwidth="91pt" align="left"/><tbody valign="top"><row><entry>Version</entry><entry>1</entry><entry>Locktime</entry><entry>T<sub>L</sub><sub><sub2>1</sub2></sub></entry></row><row><entry>In-count</entry><entry>1</entry><entry>Out-count</entry><entry>3</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="147pt" align="center"/><colspec colname="2" colwidth="126pt" align="center"/><tbody valign="top"><row><entry>Input list</entry><entry>Output list</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="49pt" align="left"/><colspec colname="3" colwidth="42pt" align="left"/><colspec colname="4" colwidth="35pt" align="left"/><colspec colname="5" colwidth="91pt" align="left"/><tbody valign="top"><row><entry/><entry>Unlocking</entry><entry>Sequence</entry><entry/><entry>Locking</entry></row><row><entry>Outpoint</entry><entry>script</entry><entry>number</entry><entry>Value</entry><entry>script</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row><row><entry>Funding Outpoint</entry><entry>&#x3c; Sig<sub>A </sub>&#x3e;&#x3c; P<sub>A</sub></entry><entry>0x00000001</entry><entry>0</entry><entry>OP_FALSE OP_RETURN &#x3c;</entry></row><row><entry/><entry>&#x3e;</entry><entry/><entry/><entry>data<sub>1 </sub>&#x3e;</entry></row><row><entry/><entry/><entry/><entry>1 BSV</entry><entry>[P2PKH Alice]</entry></row><row><entry/><entry/><entry/><entry>1 BSV</entry><entry>[P2PKH Bob]</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0380" num="0465">where data<sub>1 </sub>consists of:</p><p id="p-0381" num="0000"><tables id="TABLE-US-00011" num="00011"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="49pt" align="left"/><colspec colname="2" colwidth="42pt" align="center"/><colspec colname="3" colwidth="49pt" align="left"/><colspec colname="4" colwidth="119pt" align="left"/><thead><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row><row><entry/><entry>Field</entry><entry/><entry/></row><row><entry>Field</entry><entry>Length</entry><entry>Value</entry><entry>Explanation</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="49pt" align="left"/><colspec colname="2" colwidth="14pt" align="right"/><colspec colname="3" colwidth="28pt" align="left"/><colspec colname="4" colwidth="49pt" align="left"/><colspec colname="5" colwidth="119pt" align="left"/><tbody valign="top"><row><entry>Current state</entry><entry>64</entry><entry>bytes</entry><entry>A list of triplets</entry><entry>A triplet is used to represent each</entry></row><row><entry>of the</entry><entry/><entry/><entry>(x, y, piece)</entry><entry>piece on the board. 1 byte for the</entry></row><row><entry>chessboard</entry><entry/><entry/><entry/><entry>location (x, y), and 1 byte for the</entry></row><row><entry/><entry/><entry/><entry/><entry>piece identifier. Maximum 32 pieces.</entry></row><row><entry/><entry/><entry/><entry/><entry>Hence maximum 64 bytes.</entry></row><row><entry>Next Move</entry><entry>2</entry><entry>bytes</entry><entry>(x<sub>1</sub>, y<sub>1</sub>)</entry><entry>Move white_pawn_4 from (4, 2) to</entry></row><row><entry/><entry/><entry/><entry>&#x2192; (x<sub>2</sub>, y<sub>2</sub>)</entry><entry>(4, 4).</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="49pt" align="left"/><colspec colname="2" colwidth="42pt" align="center"/><colspec colname="3" colwidth="49pt" align="left"/><colspec colname="4" colwidth="119pt" align="left"/><tbody valign="top"><row><entry>Events</entry><entry>N/A</entry><entry>Game starts</entry><entry>List of historical moves and events.</entry></row><row><entry/><entry/><entry/><entry>This field can be optional.</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0382" num="0466">Once the chess oracle <b>102</b><i>o </i>receives the transaction or simply her move and signature from Alice, it checks whether Alice's move is valid. If it is, the chess oracle <b>102</b><i>o </i>adds its signature to the input of the transaction and passes it on to Bob for record. The chess oracle <b>102</b><i>o </i>then computes the new state of the chessboard. This new state will be included in the next transaction template for Bob. Since no piece is captured and no winning conditions are met, the fund will be evenly distributed between the two players in the next transaction template as in this one.</p><p id="p-0383" num="0000"><tables id="TABLE-US-00012" num="00012"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="273pt" align="center"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>TxID&#x2032;<sub>1</sub></entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="91pt" align="left"/><colspec colname="3" colwidth="35pt" align="left"/><colspec colname="4" colwidth="91pt" align="left"/><tbody valign="top"><row><entry>Version</entry><entry>1</entry><entry>Locktime</entry><entry>T<sub>L</sub><sub><sub2>1</sub2></sub></entry></row><row><entry>In-count</entry><entry>1</entry><entry>Out-count</entry><entry>3</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="147pt" align="center"/><colspec colname="2" colwidth="126pt" align="center"/><tbody valign="top"><row><entry>Input list</entry><entry>Output list</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="49pt" align="left"/><colspec colname="3" colwidth="42pt" align="left"/><colspec colname="4" colwidth="35pt" align="left"/><colspec colname="5" colwidth="91pt" align="left"/><tbody valign="top"><row><entry/><entry>Unlocking</entry><entry>Sequence</entry><entry/><entry>Locking</entry></row><row><entry>Outpoint</entry><entry>script</entry><entry>number</entry><entry>Value</entry><entry>script</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row><row><entry>Funding Outpoint</entry><entry>&#x3c; Sig<sub>A </sub>&#x3e;&#x3c; P<sub>A</sub></entry><entry>0x00000001</entry><entry>0</entry><entry>OP_FALSE OP_RETURN &#x3c;</entry></row><row><entry/><entry>&#x3e;&#x3c; Sig<sub>O </sub>&#x3e;</entry><entry/><entry/><entry>data<sub>1 </sub>&#x3e;</entry></row><row><entry/><entry>&#x3c; P<sub>O </sub>&#x3e;</entry></row><row><entry/><entry/><entry/><entry>1 BSV</entry><entry>[P2PKH Alice]</entry></row><row><entry/><entry/><entry/><entry>1 BSV</entry><entry>[P2PKH Bob]</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0384" num="0467">This marks the end of Move 1.</p><p id="p-0385" num="0468">Move 2:</p><p id="p-0386" num="0469">Bob gets the second transaction template from the oracle <b>102</b><i>o </i>and fills in his move:</p><p id="p-0387" num="0000"><tables id="TABLE-US-00013" num="00013"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="center"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>TxID<sub>2</sub></entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="77pt" align="left"/><colspec colname="3" colwidth="35pt" align="left"/><colspec colname="4" colwidth="91pt" align="left"/><tbody valign="top"><row><entry>Version</entry><entry>1</entry><entry>Locktime</entry><entry>T<sub>L</sub><sub><sub2>2</sub2></sub></entry></row><row><entry>In-count</entry><entry>1</entry><entry>Out-count</entry><entry>3</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="133pt" align="center"/><colspec colname="2" colwidth="126pt" align="center"/><tbody valign="top"><row><entry>Input list</entry><entry>Output list</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="35pt" align="left"/><colspec colname="3" colwidth="42pt" align="left"/><colspec colname="4" colwidth="35pt" align="left"/><colspec colname="5" colwidth="91pt" align="left"/><tbody valign="top"><row><entry/><entry>Unlocking</entry><entry>Sequence</entry><entry/><entry>Locking</entry></row><row><entry>Outpoint</entry><entry>script</entry><entry>number</entry><entry>Value</entry><entry>script</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row><row><entry>Funding Outpoint</entry><entry>&#x3c; Sig<sub>B </sub>&#x3e;</entry><entry>0x00000002</entry><entry>0</entry><entry>OP_FALSE OP_RETURN &#x3c;</entry></row><row><entry/><entry>&#x3c; P<sub>B </sub>&#x3e;</entry><entry/><entry/><entry>data<sub>2 </sub>&#x3e;</entry></row><row><entry/><entry/><entry/><entry>1 BSV</entry><entry>[P2PKH Alice]</entry></row><row><entry/><entry/><entry/><entry>1 BSV</entry><entry>[P2PKH Bob]</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0388" num="0470">Note that the second transaction can be viewed as an updated version of the first transaction. The locktime T<sub>L</sub><sub><sub2>2 </sub2></sub>is closer to the current time frame than T<sub>L</sub><sub><sub2>1</sub2></sub>. The sequence number is incremented by 1 to 0x00000002. The OP_RETURN data payload has been updated to reflect the current state of the chess board and Bob's next move. The transaction is then sent to the oracle <b>102</b><i>o </i>to verify and sign before being sent to Alice as in Move 1.</p><p id="p-0389" num="0000"><tables id="TABLE-US-00014" num="00014"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="center"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>TxID&#x2032;<sub>2</sub></entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="77pt" align="left"/><colspec colname="3" colwidth="35pt" align="left"/><colspec colname="4" colwidth="91pt" align="left"/><tbody valign="top"><row><entry>Version</entry><entry>1</entry><entry>Locktime</entry><entry>T<sub>L</sub><sub><sub2>2</sub2></sub></entry></row><row><entry>In-count</entry><entry>1</entry><entry>Out-count</entry><entry>3</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="133pt" align="center"/><colspec colname="2" colwidth="126pt" align="center"/><tbody valign="top"><row><entry>Input list</entry><entry>Output list</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="35pt" align="left"/><colspec colname="3" colwidth="42pt" align="left"/><colspec colname="4" colwidth="35pt" align="left"/><colspec colname="5" colwidth="91pt" align="left"/><tbody valign="top"><row><entry/><entry>Unlocking</entry><entry>Sequence</entry><entry/><entry>Locking</entry></row><row><entry>Outpoint</entry><entry>script</entry><entry>number</entry><entry>Value</entry><entry>script</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row><row><entry>Funding Outpoint</entry><entry>&#x3c; Sig<sub>B </sub>&#x3e;</entry><entry>0x00000002</entry><entry>0</entry><entry>OP_FALSE OP_RETURN &#x3c;</entry></row><row><entry/><entry>&#x3c; P<sub>B </sub>&#x3e;</entry><entry/><entry/><entry>data<sub>2 </sub>&#x3e;</entry></row><row><entry/><entry>&#x3c; Sig<sub>O </sub>&#x3e;</entry></row><row><entry/><entry>&#x3c; P<sub>O </sub>&#x3e;</entry></row><row><entry/><entry/><entry/><entry>1 BSV</entry><entry>[P2PKH Alice]</entry></row><row><entry/><entry/><entry/><entry>1 BSV</entry><entry>[P2PKH Bob]</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0390" num="0471">Move 3:</p><p id="p-0391" num="0472">Similar to previous transactions, Alice fills in the third transaction with her move and sends to the oracle <b>102</b><i>o</i>-.</p><p id="p-0392" num="0000"><tables id="TABLE-US-00015" num="00015"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="273pt" align="center"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>TxID<sub>3</sub></entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="91pt" align="left"/><colspec colname="3" colwidth="35pt" align="left"/><colspec colname="4" colwidth="91pt" align="left"/><tbody valign="top"><row><entry>Version</entry><entry>1</entry><entry>Locktime</entry><entry>T<sub>L</sub><sub><sub2>3</sub2></sub></entry></row><row><entry>In-count</entry><entry>1</entry><entry>Out-count</entry><entry>3</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="147pt" align="center"/><colspec colname="2" colwidth="126pt" align="center"/><tbody valign="top"><row><entry>Input list</entry><entry>Output list</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="49pt" align="left"/><colspec colname="3" colwidth="42pt" align="left"/><colspec colname="4" colwidth="35pt" align="left"/><colspec colname="5" colwidth="91pt" align="left"/><tbody valign="top"><row><entry/><entry>Unlocking</entry><entry>Sequence</entry><entry/><entry>Locking</entry></row><row><entry>Outpoint</entry><entry>script</entry><entry>number</entry><entry>Value</entry><entry>script</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row><row><entry>Funding Outpoint</entry><entry>&#x3c; Sig<sub>A </sub>&#x3e;&#x3c; P<sub>A</sub></entry><entry>0x00000003</entry><entry>0</entry><entry>OP_FALSE OP_RETURN &#x3c;</entry></row><row><entry/><entry>&#x3e;</entry><entry/><entry/><entry>data<sub>3 </sub>&#x3e;</entry></row><row><entry/><entry/><entry/><entry>1 BSV</entry><entry>[P2PKH Alice]</entry></row><row><entry/><entry/><entry/><entry>1 BSV</entry><entry>[P2PKH Bob]</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0393" num="0473">In this move, suppose that Alice captures Bob's pawn. The oracle <b>102</b><i>o </i>does all the computation and works out the new state of the chessboard and the corresponding outputs. However, the oracle <b>102</b><i>o </i>only incorporates these changes in the transaction template for Bob's next move. It signs the third transaction and passes it on to Bob.</p><p id="p-0394" num="0000"><tables id="TABLE-US-00016" num="00016"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="273pt" align="center"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>TxID<sub>3</sub></entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="91pt" align="left"/><colspec colname="3" colwidth="35pt" align="left"/><colspec colname="4" colwidth="91pt" align="left"/><tbody valign="top"><row><entry>Version</entry><entry>1</entry><entry>Locktime</entry><entry>T<sub>L</sub><sub><sub2>3</sub2></sub></entry></row><row><entry>In-count</entry><entry>1</entry><entry>Out-count</entry><entry>3</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="147pt" align="center"/><colspec colname="2" colwidth="126pt" align="center"/><tbody valign="top"><row><entry>Input list</entry><entry>Output list</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="49pt" align="left"/><colspec colname="3" colwidth="42pt" align="left"/><colspec colname="4" colwidth="35pt" align="left"/><colspec colname="5" colwidth="91pt" align="left"/><tbody valign="top"><row><entry/><entry>Unlocking</entry><entry>Sequence</entry><entry/><entry>Locking</entry></row><row><entry>Outpoint</entry><entry>script</entry><entry>number</entry><entry>Value</entry><entry>script</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row><row><entry>Funding Outpoint</entry><entry>&#x3c; Sig<sub>A </sub>&#x3e;&#x3c; P<sub>A</sub></entry><entry>0x00000003</entry><entry>0</entry><entry>OP_FALSE OP_RETURN &#x3c;</entry></row><row><entry/><entry>&#x3e;</entry><entry/><entry/><entry>data<sub>3 </sub>&#x3e;</entry></row><row><entry/><entry>&#x2003;&#x3c; Sig<sub>O </sub>&#x3e;</entry></row><row><entry/><entry>&#x2003;&#x3c; P<sub>O </sub>&#x3e;</entry></row><row><entry/><entry/><entry/><entry>1 BSV</entry><entry>[P2PKH Alice]</entry></row><row><entry/><entry/><entry/><entry>1 BSV</entry><entry>[P2PKH Bob]</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0395" num="0474">When Bob receives Alice's move via the oracle <b>102</b><i>o</i>-, if he cheats and leaves the payment channel as he is losing, then either Alice or the oracle <b>102</b><i>o </i>can publish a transaction that reflects the outcome. Note that the funding transaction only requires two signatures to spend. Therefore, there is no incentive for Bob to leave the channel unilaterally.</p><p id="p-0396" num="0475">The template for Bob's next move will look like this:</p><p id="p-0397" num="0000"><tables id="TABLE-US-00017" num="00017"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="center"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>TxID<sub>4</sub></entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="77pt" align="left"/><colspec colname="3" colwidth="35pt" align="left"/><colspec colname="4" colwidth="91pt" align="left"/><tbody valign="top"><row><entry>Version</entry><entry>1</entry><entry>Locktime</entry><entry>T<sub>L</sub><sub><sub2>4</sub2></sub></entry></row><row><entry>In-count</entry><entry>1</entry><entry>Out-count</entry><entry>3</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="133pt" align="center"/><colspec colname="2" colwidth="126pt" align="center"/><tbody valign="top"><row><entry>Input list</entry><entry>Output list</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="35pt" align="left"/><colspec colname="3" colwidth="42pt" align="left"/><colspec colname="4" colwidth="35pt" align="left"/><colspec colname="5" colwidth="91pt" align="left"/><tbody valign="top"><row><entry/><entry>Unlocking</entry><entry>Sequence</entry><entry/><entry>Locking</entry></row><row><entry>Outpoint</entry><entry>script</entry><entry>number</entry><entry>Value</entry><entry>script</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row><row><entry>Funding Outpoint</entry><entry/><entry>0x00000004</entry><entry>0</entry><entry>OP_FALSE OP_RETURN &#x3c;</entry></row><row><entry/><entry/><entry/><entry/><entry>data<sub>4 </sub>&#x3e;</entry></row><row><entry/><entry/><entry/><entry>1.05 BSV</entry><entry>[P2PKH Alice]</entry></row><row><entry/><entry/><entry/><entry>0.95 BSV</entry><entry>[P2PKH Bob]</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0398" num="0476">Settlement</p><p id="p-0399" num="0477">Suppose Alice wins the game in Move 21. Alice submits the 21st transaction to the oracle <b>102</b><i>o</i>.</p><p id="p-0400" num="0000"><tables id="TABLE-US-00018" num="00018"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="273pt" align="center"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>TxID<sub>21</sub></entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="91pt" align="left"/><colspec colname="3" colwidth="35pt" align="left"/><colspec colname="4" colwidth="91pt" align="left"/><tbody valign="top"><row><entry>Version</entry><entry>1</entry><entry>Locktime</entry><entry>T<sub>L</sub><sub><sub2>21</sub2></sub></entry></row><row><entry>In-count</entry><entry>1</entry><entry>Out-count</entry><entry>3</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="147pt" align="center"/><colspec colname="2" colwidth="126pt" align="center"/><tbody valign="top"><row><entry>Input list</entry><entry>Output list</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="49pt" align="left"/><colspec colname="3" colwidth="42pt" align="left"/><colspec colname="4" colwidth="35pt" align="left"/><colspec colname="5" colwidth="91pt" align="left"/><tbody valign="top"><row><entry/><entry>Unlocking</entry><entry>Sequence</entry><entry/><entry>Locking</entry></row><row><entry>Outpoint</entry><entry>script</entry><entry>number</entry><entry>Value</entry><entry>script</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row><row><entry>Funding Outpoint</entry><entry>&#x3c; Sig<sub>A </sub>&#x3e;&#x3c; P<sub>A</sub></entry><entry>0x00000015</entry><entry>0</entry><entry>OP_FALSE OP_RETURN &#x3c;</entry></row><row><entry/><entry>&#x3e;</entry><entry/><entry/><entry>data<sub>21 </sub>&#x3e;</entry></row><row><entry/><entry/><entry/><entry>1.5 BSV</entry><entry>[P2PKH Alice]</entry></row><row><entry/><entry/><entry/><entry>0.5 BSV</entry><entry>[P2PKH Bob]</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0401" num="0478">The oracle <b>102</b><i>o </i>verifies that Bob's king will be captured after Alice's move. If it is true, it signs and passes on the transaction to Bob, together with a template for the final transaction. When Bob receives the template, he accepts the defeat and signs the final transaction to settle the payment channel. If Bob chooses the leave the payment channel unilaterally, then Alice and the oracle <b>102</b><i>o </i>can sign the final transaction to settle the payment channel.</p><p id="p-0402" num="0000"><tables id="TABLE-US-00019" num="00019"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="266pt" align="center"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>TxID<sub>final</sub></entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="84pt" align="left"/><colspec colname="3" colwidth="35pt" align="left"/><colspec colname="4" colwidth="91pt" align="left"/><tbody valign="top"><row><entry>Version</entry><entry>1</entry><entry>Locktime</entry><entry>0</entry></row><row><entry>In-count</entry><entry>1</entry><entry>Out-count</entry><entry>2</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="140pt" align="center"/><colspec colname="2" colwidth="126pt" align="center"/><tbody valign="top"><row><entry>Input list</entry><entry>Output list</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="35pt" align="left"/><colspec colname="3" colwidth="49pt" align="left"/><colspec colname="4" colwidth="35pt" align="left"/><colspec colname="5" colwidth="91pt" align="left"/><tbody valign="top"><row><entry/><entry>Unlocking</entry><entry>Sequence</entry><entry/><entry>Locking</entry></row><row><entry>Outpoint</entry><entry>script</entry><entry>number</entry><entry>Value</entry><entry>script</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row><row><entry>Funding Outpoint</entry><entry>&#x3c; Sig<sub>B </sub>&#x3e;</entry><entry>0xFFFFFFFF</entry><entry>0</entry><entry>OP_FALSE OP_RETURN &#x3c;</entry></row><row><entry/><entry>&#x3c; P<sub>B </sub>&#x3e;</entry><entry/><entry/><entry>data<sub>22 </sub>&#x3e;</entry></row><row><entry/><entry/><entry/><entry>2 BSV</entry><entry>[P2PKH Alice]</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0403" num="0479">4.2 Proof of Work Payment Channel</p><p id="p-0404" num="0480">In this scenario, Alice is a miner. She would like to delegate her mining computation to hash oracles. This corresponds to the scenario of <figref idref="DRAWINGS">FIG. <b>3</b>B</figref>, with the oracles <b>102</b><i>o</i>-<b>1</b>, <b>102</b><i>o</i>-<b>2</b> being hash oracles and (in this case) a single non-oracle participant (miner Alice).</p><p id="p-0405" num="0481">Without loss of generality, two hash oracles <b>102</b><i>o</i>-<b>1</b>, <b>102</b><i>o</i><b>2</b>&#x2014;Olivia and Oscar for short&#x2014;are assumed to be competing (there may be more than two competing oracles in practice).</p><p id="p-0406" num="0482">To implement a form of &#x201c;mining pool&#x201d;, Alice will reduce the network difficulty to a reasonable level for her payment channel. That is to say, if the network requires a block hash&#x2264;BH for a valid block, Alice can set a computationally easier task of finding a nonce that yields a block hash &#x3c;BH&#x2032; where BH&#x2032;&#x3e;BH.</p><p id="p-0407" num="0483">She will reward participants each time they find a nonce that meets the criteria. She will hope that during the life time of the payment channel, one of the answers would produce a hash value that is small enough to meet the network difficulty.</p><p id="p-0408" num="0484">The underlying idea is that each party seeks to solve a simpler problem than the block mining problem&#x2014;in the hope that, in seeking to solve the simpler problem, one of them will eventually happen to solve the block mining problem (with each mining oracle being rewarded for their efforts&#x2014;effectively pooling their efforts and receiving a share of the mining fee Alice hopes to eventually secure in return).</p><p id="p-0409" num="0485">To open a PoW payment channel, participants submits a funding transaction.</p><p id="p-0410" num="0000"><tables id="TABLE-US-00020" num="00020"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="center"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>TxID<sub>funding</sub></entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="98pt" align="left"/><colspec colname="3" colwidth="35pt" align="left"/><colspec colname="4" colwidth="70pt" align="left"/><tbody valign="top"><row><entry>Version</entry><entry>1</entry><entry>Locktime</entry><entry>0</entry></row><row><entry>In-count</entry><entry>1</entry><entry>Out-count</entry><entry>2</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="154pt" align="center"/><colspec colname="2" colwidth="105pt" align="center"/><tbody valign="top"><row><entry>Input list</entry><entry>Output list</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="49pt" align="left"/><colspec colname="3" colwidth="49pt" align="left"/><colspec colname="4" colwidth="35pt" align="left"/><colspec colname="5" colwidth="70pt" align="left"/><tbody valign="top"><row><entry/><entry>Unlocking</entry><entry>Sequence</entry><entry/><entry>Locking</entry></row><row><entry>Outpoint</entry><entry>script</entry><entry>number</entry><entry>Value</entry><entry>script</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row><row><entry>Alice Outpoint</entry><entry>&#x3c; Sig<sub>A </sub>&#x3e;&#x3c; P<sub>A</sub></entry><entry>0xFFFFFFFF</entry><entry>10 BSV</entry><entry>[P2PKH Alice]</entry></row><row><entry/><entry>&#x3e;</entry><entry/><entry/><entry>[1-2 multiSig Olivia,</entry></row><row><entry/><entry/><entry/><entry/><entry>Oscar]</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0411" num="0486">The goal of the payment channel is to achieve:</p><p id="p-0412" num="0000"><tables id="TABLE-US-00021" num="00021"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="42pt" align="left"/><colspec colname="1" colwidth="175pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>While (OP_HASH256(data) &#x3e;= difficulty) {</entry></row><row><entry/><entry>&#x2003;Do data = updated data</entry></row><row><entry/><entry>}</entry></row><row><entry/><entry>Return data</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0413" num="0487">Once the payment channel is opened, both oracles are given a block header with missing nonce. They iterate the nonce and try to find a nonce that produces a hash value that is less than the difficulty.</p><p id="p-0414" num="0488">Suppose Olivia finds one first. She submits a transaction to Alice:</p><p id="p-0415" num="0000"><tables id="TABLE-US-00022" num="00022"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="266pt" align="center"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>TxID<sub>1</sub></entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="84pt" align="left"/><colspec colname="3" colwidth="35pt" align="left"/><colspec colname="4" colwidth="91pt" align="left"/><tbody valign="top"><row><entry>Version</entry><entry>1</entry><entry>Locktime</entry><entry>T<sub>L</sub><sub><sub2>1</sub2></sub></entry></row><row><entry>In-count</entry><entry>1</entry><entry>Out-count</entry><entry>3</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="140pt" align="center"/><colspec colname="2" colwidth="126pt" align="center"/><tbody valign="top"><row><entry>Input list</entry><entry>Output list</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="42pt" align="left"/><colspec colname="3" colwidth="42pt" align="left"/><colspec colname="4" colwidth="35pt" align="left"/><colspec colname="5" colwidth="91pt" align="left"/><tbody valign="top"><row><entry/><entry>Unlocking</entry><entry>Sequence</entry><entry/><entry>Locking</entry></row><row><entry>Outpoint</entry><entry>script</entry><entry>number</entry><entry>Value</entry><entry>script</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row><row><entry>Funding Outpoint</entry><entry>&#x3c; Sig<sub>Olivia </sub>&#x3e;</entry><entry>0x00000001</entry><entry>0.1 BSV</entry><entry>[P2PKH Olivia]</entry></row><row><entry/><entry>&#x3c; P<sub>Olivia </sub>&#x3e;</entry></row><row><entry/><entry/><entry/><entry>9.9 BSV</entry><entry>[P2PKH Alice]</entry></row><row><entry/><entry/><entry/><entry>0</entry><entry>OP_FALSE OP_RETURN</entry></row><row><entry/><entry/><entry/><entry/><entry>&#x3c;nonce_Olivia&#x3e;</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0416" num="0489">Alice checks that the nonce produces a hash value that is less than the difficulty. If it is the case, she signs the transaction and passes on to both Olivia and Oscar. Note that Alice can also implement an oracle that does all the verifications.</p><p id="p-0417" num="0490">In this case, the functional unit F( ) is applied to determine the new distribution of digital asset between Alice and the mining oracles based on the determined nonce. The determined nonce is a parameter &#x3c9;<sub>i </sub>in the above terminology, determined externally from functional unit F( ).</p><p id="p-0418" num="0491">In one implementation, the only input values are the digital asset values v<sub>i</sub>, which are computed in dependence on the previous digital asset values v<sub>i&#x2212;1</sub>.</p><p id="p-0419" num="0492">In another implementation, Alice is responsible for setting the digital asset values correctly (which Oracle's can verify before signing). In that case, there are no inputs &#x3d5;<sub>i </sub>to the functional unit&#x2014;only parameters &#x3c9;<sub>i</sub>.</p><p id="p-0420" num="0493">Suppose Oscar finds the next one. He updates the transaction and submits it to Alice:</p><p id="p-0421" num="0000"><tables id="TABLE-US-00023" num="00023"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="266pt" align="center"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>TxID<sub>2</sub></entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="84pt" align="left"/><colspec colname="3" colwidth="35pt" align="left"/><colspec colname="4" colwidth="91pt" align="left"/><tbody valign="top"><row><entry>Version</entry><entry>1</entry><entry>Locktime</entry><entry>T<sub>L</sub><sub><sub2>2</sub2></sub></entry></row><row><entry>In-count</entry><entry>1</entry><entry>Out-count</entry><entry>4</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="140pt" align="center"/><colspec colname="2" colwidth="126pt" align="center"/><tbody valign="top"><row><entry>Input list</entry><entry>Output list</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="42pt" align="left"/><colspec colname="3" colwidth="42pt" align="left"/><colspec colname="4" colwidth="35pt" align="left"/><colspec colname="5" colwidth="91pt" align="left"/><tbody valign="top"><row><entry/><entry>Unlocking</entry><entry>Sequence</entry><entry/><entry>Locking</entry></row><row><entry>Outpoint</entry><entry>script</entry><entry>number</entry><entry>Value</entry><entry>script</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row><row><entry>Funding Outpoint</entry><entry>&#x3c; Sig<sub>Oscar </sub>&#x3e;</entry><entry>0x00000002</entry><entry>0.1 BSV</entry><entry>[P2PKH Olivia]</entry></row><row><entry/><entry>&#x3c; P<sub>Oscar </sub>&#x3e;</entry></row><row><entry/><entry/><entry/><entry>0.1 BSV</entry><entry>[P2PKH Oscar]</entry></row><row><entry/><entry/><entry/><entry>9.8 BSV</entry><entry>[P2PKH Alice]</entry></row><row><entry/><entry/><entry/><entry>0</entry><entry>OP_FALSE OP_RETURN</entry></row><row><entry/><entry/><entry/><entry/><entry>&#x3c;nonce_Olivia&#x3e;</entry></row><row><entry/><entry/><entry/><entry/><entry>&#x3c;nonce_Oscar&#x3e;</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0422" num="0494">Alice verifies the claim and signs the transaction if it is true.</p><p id="p-0423" num="0495">It is Alice's responsibility to make sure that the distribution of the fund is correct. If Alice leaves the payment channel unilaterally, both Olivia and Oscar will publish the latest transaction to claim their reward. If Oscar left the payment channel unilaterally, then it is possible for the rest of the participants to claim all Oscar's reward in an updated transaction.</p><p id="p-0424" num="0496">This design incentivises participants to stay in the payment channel as long as its life span. The payment channel can be closed when the funding is running out, or the initial lock time is about to expire, or a nonce that produces a small enough hash value is found.</p><p id="p-0425" num="0497">It will be appreciated that the above embodiments have been described by way of example only.</p><p id="p-0426" num="0498">More generally there may be provided a method, apparatus or program in accordance with any one or more of the following Statements.</p><p id="p-0427" num="0499">Statement 1. A first aspect of the present disclosure provides a computer-implemented method of effecting a blockchain payment channel based on a series of spending transactions exchanged between parties, in which: each transaction of the series of spending transactions has a future lock time, before which it cannot be committed to the blockchain, and comprises: (i) at least one transaction input containing a pointer to a common spendable transaction output, and (ii) at least two spendable transaction outputs having respective digital asset values, an initial transaction of the series of spending transactions has a lowest sequence number and each subsequent transaction of the series of spending transactions has a higher sequence number than the previous transaction and contains one or more function variables other than the respective digital asset values of its spendable transaction outputs; wherein the method comprises, by one of the parties: receiving, at computer equipment of the party, a previous transaction of the series of spending transactions; applying a function to the one or more function variables contained in the previous transaction to do at least one of: compute the digital asset values of the current transaction, create a new data field for the current transaction, which does not correspond to any existing data field contained in the previous transaction, the current transaction containing the new data field, and prevent an existing type of data field from being propagated from the previous transaction into the current transaction, such that the previous transaction contains a data field which does not correspond to any data field in the current transaction; and cryptographically signing a portion of the current transaction, the signed portion comprising the at least two spendable transaction outputs, using a private key counterpart to the public key of the party, thereby computing a transaction signature for inclusion in the transaction input of the current transaction.</p><p id="p-0428" num="0500">Example embodiments are set out below, as Statements 2 onwards.</p><p id="p-0429" num="0501">Statement 2. The method of Statement 1, wherein the common spendable transaction output specifies m public keys of the parties and is locked to any 2&#x2264;n&#x3c;m of the m public keys, the party applying the function being a trusted oracle, whereby any other n&#x2212;1 of the parties may sign a portion of the current transaction for unlocking the common spendable transaction output.</p><p id="p-0430" num="0502">Where n=2, &#x201c;n&#x2212;1 of the parties&#x201d; means a single other party. The other n&#x2212;1 party/parties may sign the portion of the current transaction before, after or simultaneously with the trusted oracle. The trusted oracle may be the only trusted oracle of the parties or two or more of the parties may be trusted oracles.</p><p id="p-0431" num="0503">Statement 3. The method of Statement 2, wherein the trusted oracle signs the current transaction after receiving, from another of the parties, at least a transaction signature for the current transaction which is valid in respect of the public of the other party.</p><p id="p-0432" num="0504">The trusted oracle may add the other party's transaction signature to the transaction input of the current transaction, along with the trusted oracle's signature, or the trusted oracle may send the signatures elsewhere to be added to the current transaction. Alternatively, the trusted oracle may send his/her/its transaction signature to another of the parties or to an external source for that other party/external source to add to the current transaction. The transaction signature may be received alone, or along with a full copy of the current transaction (for example), or more generally along with one or more components of the current transaction.</p><p id="p-0433" num="0505">Statement 4. The method of Statement 1 or 2, wherein said function is defined or otherwise evidenced in a funding transaction comprising the common spendable transaction output.</p><p id="p-0434" num="0506">The verb &#x201c;to evidence&#x201d; is used in a specific sense to mean that, given an actual piece of code or some other data evidenced in a transaction, it is possible to verify whether or not the actual data (e.g. code) matches the data (e.g. code) evidenced by the transaction. For example, the transaction may comprise a cryptograph hash of the data or some other unique identifier of the data. The term &#x201c;cryptographic hash&#x201d; is used in a broad sense to mean any hash value derived from a piece of data (e.g. a piece of code) via the application of one or more cryptographic hash functions (such as a single or double/multi hash of the piece of code, a root hash of a hash tree containing the piece of code etc.)</p><p id="p-0435" num="0507">Statement 5. The method of Statement 4 when dependent on Statement 2, wherein the trusted oracle uses the funding transaction to determine or verify the function to be applied.</p><p id="p-0436" num="0508">Statement 6. The method of Statement 4 or 5, wherein the funding transaction contains or evidences a piece of code executable embodying the function, the function being applied by executing the piece of code on one or more computer processors of the computer equipment in dependence on the one or more previous input values.</p><p id="p-0437" num="0509">Statement 7. The method of Statement 6, wherein the piece of code is contained in: the funding transaction, or another transaction recorded in the blockchain, and in that event the funding transaction contains an identifier of the piece of code.</p><p id="p-0438" num="0510">Statement 8. The method of Statement 7 when dependent on Statement 5, wherein the trusted oracle retrieves the piece of code from the blockchain for execution, and thereby determines the function to be applied.</p><p id="p-0439" num="0511">Statement 9. The method of Statement 6 or 7 when dependent on Statement 5, wherein the trusted oracle receives the piece of code from an off-chain source and uses the funding transaction to verify the received piece of code.</p><p id="p-0440" num="0512">Statement 10. The method of any preceding Statement, wherein the one or more function variables in each transaction comprise one or more input values; wherein the function is applied to at least the one or more input values of the previous transaction to additionally compute the one or more input values of the current transaction.</p><p id="p-0441" num="0513">Statement 11. The method of any preceding Statement, wherein the one or more function variables in each transaction comprise one or more external parameters which are not computed by applying the function; wherein the function is applied to at least the one or more external parameters contained in the previous transaction in order to compute the digital asset values of the current transaction.</p><p id="p-0442" num="0514">Statement 12. The method of Statements 10 and 11, wherein the variables in each transaction comprise the one or more function variables and the one or more external parameters; wherein the function is applied to the one or more input values and the one or more external parameters contained in the previous transaction in order to compute (a) and (b).</p><p id="p-0443" num="0515">Statement 13. The method of Statement 11 or 12, wherein the one or more external parameters of the current transaction are provided by another of the parties, other than the party applying the function.</p><p id="p-0444" num="0516">Statement 14. The method of Statement 13, wherein the one or more external parameters of the current transaction are contained in the signed portion of the current transaction, and the party signs the current transaction after the other party has provided the one or more external parameters.</p><p id="p-0445" num="0517">Statement 15. The method of Statement 10 or any Statement dependent thereon, wherein the party also applies the same function to at least the one or more input values of the current transaction, in order to compute: (a&#x2032;) one or more input values of the next transaction, the next transaction being the transaction after the current transaction in the series of spending transactions, and (b&#x2032;) the digital asset values of the next transaction.</p><p id="p-0446" num="0518">Statement 16. The method of Statement 11 or any Statement dependent thereon, wherein the party applies the same function to at least the one or more external parameters of the current transaction in order to compute the digital asset values of the next transaction.</p><p id="p-0447" num="0519">Statement 17. The method of Statement 15, wherein the party creates the next transaction containing at least the digital asset values of the next transaction, cryptographically signs a portion of the next transaction, and sends the next transaction and the transaction signature to another of the parties.</p><p id="p-0448" num="0520">For example, the party sending the external parameter(s) could be a first game player, and the party to which the next transaction is sent could be a second game player who is an opponent of the first game player.</p><p id="p-0449" num="0521">Statement 18. The method of Statement 12 or any Statement dependent thereon, wherein: the one or more input values in each transaction of the series of spending transactions represent a game state, and the one or more external parameters in the previous transaction define a game move, the one or more external parameters in the previous transaction having been determined by a second of the parties, wherein the function is applied to update the game state of the previous transaction to implement the game move of the previous transaction, the updated game state represented by the one or more input values of the current transaction, whereby the digital asset values of the current transaction are computed responsive to the game move.</p><p id="p-0450" num="0522">Statement 19. The method of Statement 18, wherein the current transaction is sent to a third of the parties for the third party to determine the one or more external parameters for the current transaction, representing the third party's game move responsive to the second party's game move.</p><p id="p-0451" num="0523">In some such embodiments, the party applying the function to update the game state is a structured oracle. The function captures a set of game rules for validating game moves and updating the game state responsive to valid game moves. Where the function is committed/evidenced in the blockchain, the rules of the game may be entirely defined by the blockchain (or at least unambiguously verifiable from the blockchain).</p><p id="p-0452" num="0524">Statement 20. The method of any preceding Statement, wherein the one or more input values of the current transaction are contained in the signed portion of the current transaction.</p><p id="p-0453" num="0525">Statement 21. The method of any preceding Statement, wherein the party applies the function after the previous transaction has been signed by at least two of the parties.</p><p id="p-0454" num="0526">Statement 22. The method of any preceding Statement, wherein the function is applied to the one or more function variables and to the digital asset values of the previous transaction, in order to determine the digital asset values of the current transaction.</p><p id="p-0455" num="0527">Statement 23. The method of any preceding Statement dependent thereon, wherein the one or more external parameters of the previous transaction comprise a nonce value, wherein the function is applied to: add the nonce value to a partial data set, thereby determining a complete data set including the nonce value, apply a hash function to the complete data set, thereby computing a hash value, determine if the hash value meets a defined requirement, and determine the digital asset values of the current transaction in dependence on whether the hash value meets the defined requirement.</p><p id="p-0456" num="0528">Statement 24. The method of any preceding Statement, wherein the final transaction in the series is used to compute a settlement transaction, by applying the same function to the one or more function variables of the final transaction to compute respective digital asset values of at least two spendable transaction outputs of the settlement transaction, wherein the settlement transaction comprises at least one transaction input containing a pointer to the spendable transaction output of the funding transaction, wherein the settlement transaction is committed to the blockchain.</p><p id="p-0457" num="0529">Statement 25. The method of Statement 24, wherein the settlement transaction has a maximum possible sequence number.</p><p id="p-0458" num="0530">In that case, it may be unnecessary for the settlement transaction to have a future lock time, i.e. it may be that no conditions are imposed on when the settlement transaction can be committed. The settlement transaction may also contain one or more function variables of the same kind, or it may not contain any such function variables (because it may be that no such function variable(s) are required because no further transaction is to be computed).</p><p id="p-0459" num="0531">Statement 26. The method of any preceding Statement, wherein the function is not applied to compute the digital asset values of the current transaction until the previous transaction has been finalized at least by the application of two or more required transaction signatures.</p><p id="p-0460" num="0532">Statement 27. The method of any preceding Statement, wherein the common spendable transaction output is part of a funding transaction, committed to a blockchain, and is locked to at least two public keys of the parties.</p><p id="p-0461" num="0533">Statement 28. Computer equipment comprising one or more computer processors, the one or more computer processors being configured to implement the method of any preceding Statements.</p><p id="p-0462" num="0534">Statement 29. Computer program instructions stored on a transitory or non-transitory computer-readable medium or media, the computer program instructions for programming computer equipment to carry out the steps of Statements 1 to 27.</p><p id="p-0463" num="0535">According to another aspect disclosed herein, there may be provided a method comprising the actions of the first party, second party, any third party that may be involved, and the network of nodes.</p><p id="p-0464" num="0536">According to another aspect disclosed herein, there may be provided a system comprising the computer equipment of the first party, the computer equipment of the second party, the computer equipment of any third party, and the network of nodes.</p><p id="p-0465" num="0537">Other variants or use cases of the disclosed techniques may become apparent to the person skilled in the art once given the disclosure herein. The scope of the disclosure is not limited by the described embodiments but only by the accompanying claims.</p><?detailed-description description="Detailed Description" end="tail"?></description><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A computer-implemented method of effecting a blockchain payment channel based on a series of spending transactions exchanged between parties, in which:<claim-text>each transaction of the series of spending transactions has a future lock time, before which it cannot be committed to the blockchain, and comprises: (i) at least one transaction input containing a pointer a common spendable transaction output, and (ii) at least two spendable transaction outputs having respective digital asset values,</claim-text><claim-text>an initial transaction of the series of spending transactions has a lowest sequence number and each subsequent transaction of the series of spending transactions has a higher sequence number than the previous transaction and contains one or more function variables other than the respective digital asset values of its spendable transaction outputs;</claim-text><claim-text>wherein the method comprises, by one of the parties:</claim-text><claim-text>receiving, at computer equipment of the party, a previous transaction of the series of spending transactions;</claim-text><claim-text>applying a function to the one or more function variables contained in the previous transaction to do at least one of:<claim-text>compute the digital asset values of a current transaction,</claim-text><claim-text>create a new data field for the current transaction, which does not correspond to any existing data field contained in the previous transaction, the current transaction containing the new data field, and</claim-text><claim-text>prevent an existing type of data field from being propagated from the previous transaction into the current transaction, such that the previous transaction contains a data field which does not correspond to any data field in the current transaction; and</claim-text></claim-text><claim-text>cryptographically signing a portion of the current transaction, the signed portion comprising the at least two spendable transaction outputs, using a private key counterpart to a public key of the party, thereby computing a transaction signature for inclusion in the transaction input of the current transaction.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the common spendable transaction output specifies m public keys of the parties and is locked to any 2&#x2264;n&#x3c;m of the m public keys, the party applying the function being a trusted oracle, whereby any other n&#x2212;1 of the parties may sign a portion of the current transaction for unlocking the common spendable transaction output.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the trusted oracle signs the current transaction after receiving, from another of the parties, at least a transaction signature for the current transaction which is valid in respect of the public key of the other party.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein said function is defined or otherwise evidenced in a funding transaction comprising the common spendable transaction output.</claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the common spendable transaction output specifies m public keys of the parties and is locked to any 2&#x2264;n&#x3c;m of the m public keys, the party applying the function being a trusted oracle, whereby any other n&#x2212;1 of the parties may sign a portion of the current transaction for unlocking the common spendable transaction output, wherein the trusted oracle uses the funding transaction to determine or verify the function to be applied.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the funding transaction contains or evidences a piece of code executable embodying the function, the function being applied by executing the piece of code on one or more computer processors of the computer equipment in dependence on the one or more previous input values.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the piece of code is contained in:<claim-text>the funding transaction, or</claim-text><claim-text>another transaction recorded in the blockchain, and in that event the funding transaction contains an identifier of the piece of code.</claim-text></claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the one or more function variables in each transaction comprise one or more input values;<claim-text>wherein the function is applied to at least the one or more input values of the previous transaction to additionally compute the one or more input values of the current transaction</claim-text></claim-text></claim><claim id="CLM-09-10" num="09-10"><claim-text><b>9</b>-<b>10</b>. (canceled)</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the one or more function variables in each transaction comprise one or more external parameters which are not computed by applying the function;<claim-text>wherein the function is applied to at least the one or more external parameters contained in the previous transaction in order to compute the digital asset values of the current transaction.</claim-text></claim-text></claim><claim id="CLM-12-14" num="12-14"><claim-text><b>12</b>-<b>14</b>. (canceled)</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the party also applies the same function to at least the one or more input values of the current transaction, in order to compute: (a&#x2032;) one or more input values of a next transaction, the next transaction being the transaction after the current transaction in the series of spending transactions, and (b&#x2032;) the digital asset values of the next transaction.</claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the party applies the same function to at least the one or more external parameters of the current transaction in order to compute the digital asset values of a next transaction.</claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The method of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the party creates the next transaction containing at least the digital asset values of the next transaction, cryptographically signs a portion of the next transaction, and sends the next transaction and the transaction signature to another of the parties.</claim-text></claim><claim id="CLM-18-19" num="18-19"><claim-text><b>18</b>-<b>19</b>. (canceled)</claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the one or more input values of the current transaction are contained in the signed portion of the current transaction.</claim-text></claim><claim id="CLM-00021" num="00021"><claim-text><b>21</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the party applies the function after the previous transaction has been signed by at least two of the parties.</claim-text></claim><claim id="CLM-00022" num="00022"><claim-text><b>22</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the function is applied to the one or more function variables and to the digital asset values of the previous transaction, in order to determine the digital asset values of the current transaction.</claim-text></claim><claim id="CLM-00023" num="00023"><claim-text><b>23</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein one or more external parameters of the previous transaction comprise a nonce value, wherein the function is applied to:<claim-text>add the nonce value to a partial data set, thereby determining a complete data set including the nonce value,</claim-text><claim-text>apply a hash function to the complete data set, thereby computing a hash value,</claim-text><claim-text>determine if the hash value meets a defined requirement, and</claim-text><claim-text>determine the digital asset values of the current transaction in dependence on whether the hash value meets the defined requirement.</claim-text></claim-text></claim><claim id="CLM-00024" num="00024"><claim-text><b>24</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein a final transaction in the series is used to compute a settlement transaction, by applying the same function to the one or more function variables of the final transaction to compute respective digital asset values of at least two spendable transaction outputs of the settlement transaction, wherein the settlement transaction comprises at least one transaction input containing a pointer to the common spendable transaction output, wherein the settlement transaction is committed to the blockchain.</claim-text></claim><claim id="CLM-00025" num="00025"><claim-text><b>25</b>. (canceled)</claim-text></claim><claim id="CLM-00026" num="00026"><claim-text><b>26</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the function is not applied to compute the digital asset values of the current transaction until the previous transaction has been finalized at least by the application of two or more required transaction signatures.</claim-text></claim><claim id="CLM-00027" num="00027"><claim-text><b>27</b>. (canceled)</claim-text></claim><claim id="CLM-00028" num="00028"><claim-text><b>28</b>. Computer equipment comprising one or more computer processors, the one or more computer processors being configured to affect a blockchain payment channel based on a series of spending transactions exchanged between parties, in which:<claim-text>each transaction of the series of spending transactions has a future lock time, before which it cannot be committed to the blockchain, and comprises: (i) at least one transaction input containing a pointer a common spendable transaction output, and (ii) at least two spendable transaction outputs having respective digital asset values,</claim-text><claim-text>an initial transaction of the series of spending transactions has a lowest sequence number and each subsequent transaction of the series of spending transactions has a higher sequence number than the previous transaction and contains one or more function variables other than the respective digital asset values of its spendable transaction outputs;</claim-text><claim-text>wherein the one or more computer processors of one of the parties is configured to:</claim-text><claim-text>receive, at computer equipment of the party, a previous transaction of the series of spending transactions;</claim-text><claim-text>apply a function to the one or more function variables contained in the previous transaction to do at least one of:<claim-text>compute the digital asset values of a current transaction,</claim-text><claim-text>create a new data field for the current transaction, which does not correspond to any existing data field contained in the previous transaction, the current transaction containing the new data field, and</claim-text><claim-text>prevent an existing type of data field from being propagated from the previous transaction into the current transaction, such that the previous transaction contains a data field which does not correspond to any data field in the current transaction; and</claim-text></claim-text><claim-text>cryptographically sign a portion of the current transaction, the signed portion comprising the at least two spendable transaction outputs, using a private key counterpart to a public key of the party, thereby computing a transaction signature for inclusion in the transaction input of the current transaction.</claim-text></claim-text></claim><claim id="CLM-00029" num="00029"><claim-text><b>29</b>. A non-transitory computer-readable medium or media storing computer program instructions, the computer program instructions for programming computer equipment to affect a blockchain payment channel based on a series of spending transactions exchanged between parties, in which:<claim-text>each transaction of the series of spending transactions has a future lock time, before which it cannot be committed to the blockchain, and comprises: (i) at least one transaction input containing a pointer a common spendable transaction output, and (ii) at least two spendable transaction outputs having respective digital asset values,</claim-text><claim-text>an initial transaction of the series of spending transactions has a lowest sequence number and each subsequent transaction of the series of spending transactions has a higher sequence number than the previous transaction and contains one or more function variables other than the respective digital asset values of its spendable transaction outputs;</claim-text><claim-text>wherein the computer program instructions program the computer equipment of one of the parties to:</claim-text><claim-text>receive, at computer equipment of the party, a previous transaction of the series of spending transactions;</claim-text><claim-text>apply a function to the one or more function variables contained in the previous transaction to do at least one of:<claim-text>compute the digital asset values of a current transaction,</claim-text><claim-text>create a new data field for the current transaction, which does not correspond to any existing data field contained in the previous transaction, the current transaction containing the new data field, and</claim-text><claim-text>prevent an existing type of data field from being propagated from the previous transaction into the current transaction, such that the previous transaction contains a data field which does not correspond to any data field in the current transaction; and</claim-text></claim-text><claim-text>cryptographically sign a portion of the current transaction, the signed portion comprising the at least two spendable transaction outputs, using a private key counterpart to a public key of the party, thereby computing a transaction signature for inclusion in the transaction input of the current transaction.</claim-text></claim-text></claim></claims></us-patent-application>