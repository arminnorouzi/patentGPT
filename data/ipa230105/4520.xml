<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004521A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004521</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17901720</doc-number><date>20220901</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>15</main-group><subgroup>167</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>L</subclass><main-group>69</main-group><subgroup>22</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>22</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>15</main-group><subgroup>167</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>L</subclass><main-group>69</main-group><subgroup>22</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>22</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">FLEXIBLE REMOTE DIRECT MEMORY ACCESS</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>17139621</doc-number><date>20201231</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11436183</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17901720</doc-number></document-id></child-doc></relation></continuation><continuation><relation><parent-doc><document-id><country>US</country><doc-number>16702187</doc-number><date>20191203</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>10884974</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17139621</doc-number></document-id></child-doc></relation></continuation><continuation><relation><parent-doc><document-id><country>US</country><doc-number>15164601</doc-number><date>20160525</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>10509764</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>16702187</doc-number></document-id></child-doc></relation></continuation><us-provisional-application><document-id><country>US</country><doc-number>62182259</doc-number><date>20150619</date></document-id></us-provisional-application></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Amazon Technologies, Inc.</orgname><address><city>Seattle</city><state>WA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Izenberg</last-name><first-name>Erez</first-name><address><city>Tel Aviv</city><country>IL</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Shalev</last-name><first-name>Leah</first-name><address><city>Zichron Yaakov</city><country>IL</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>Bshara</last-name><first-name>Nafea</first-name><address><city>San Jose</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="03" designation="us-only"><addressbook><last-name>Nakibly</last-name><first-name>Guy</first-name><address><city>Kedumim</city><country>IL</country></address></addressbook></inventor><inventor sequence="04" designation="us-only"><addressbook><last-name>Machulsky</last-name><first-name>Georgy</first-name><address><city>San Jose</city><state>CA</state><country>US</country></address></addressbook></inventor></inventors></us-parties><assignees><assignee><addressbook><orgname>Amazon Technologies, Inc.</orgname><role>02</role><address><city>Seattle</city><state>WA</state><country>US</country></address></addressbook></assignee></assignees></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">Apparatus and methods are disclosed herein for remote, direct memory access (RDMA) technology that enables direct memory access from one host computer memory to another host computer memory over a physical or virtual computer network according to a number of different RDMA protocols. In one example, a method includes receiving remote direct memory access (RDMA) packets via a network adapter, deriving a protocol index identifying an RDMA protocol used to encode data for an RDMA transaction associated with the RDMA packets, applying the protocol index to a generate RDMA commands from header information in at least one of the received RDMA packets, and performing an RDMA operation using the RDMA commands.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="210.74mm" wi="158.75mm" file="US20230004521A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="236.14mm" wi="177.97mm" file="US20230004521A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="235.63mm" wi="162.73mm" file="US20230004521A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="192.28mm" wi="176.95mm" file="US20230004521A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="144.36mm" wi="155.28mm" file="US20230004521A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="233.09mm" wi="179.24mm" file="US20230004521A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="229.28mm" wi="178.22mm" file="US20230004521A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="231.73mm" wi="167.81mm" file="US20230004521A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="214.63mm" wi="154.69mm" file="US20230004521A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="243.84mm" wi="170.26mm" file="US20230004521A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="192.62mm" wi="162.56mm" file="US20230004521A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="159.94mm" wi="162.56mm" file="US20230004521A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="159.94mm" wi="162.56mm" file="US20230004521A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="192.62mm" wi="162.56mm" file="US20230004521A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00014" num="00014"><img id="EMI-D00014" he="237.74mm" wi="175.60mm" orientation="landscape" file="US20230004521A1-20230105-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00015" num="00015"><img id="EMI-D00015" he="242.82mm" wi="171.79mm" orientation="landscape" file="US20230004521A1-20230105-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00016" num="00016"><img id="EMI-D00016" he="238.93mm" wi="169.25mm" orientation="landscape" file="US20230004521A1-20230105-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00017" num="00017"><img id="EMI-D00017" he="197.27mm" wi="121.75mm" orientation="landscape" file="US20230004521A1-20230105-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">CROSS REFERENCE TO RELATED APPLICATIONS</heading><p id="p-0002" num="0001">This application claims the benefit of U.S. Provisional Application No. 62/182,259, filed Jun. 19, 2015, which is incorporated herein by reference in its entirety.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">BACKGROUND</heading><p id="p-0003" num="0002">Remote Direct Memory Access (RDMA) allows for direct memory access from one host computer to another host computer. Examples of RDMA protocols include Infiniband, RDMA over converged Ethernet (RoCE), and iWARP. RDMA technology can be used to create large, massively parallel computing environments, and can be applied in a cloud computing environment. Cloud computing is the use of computing resources (hardware and software) which are available in a remote location and accessible over a network, such as the Internet. Users are able to buy these computing resources (including storage and computing power) as a utility on demand. Processor-based RDMA implementations use processor instructions stored in firmware to decode packets encoded in an RDMA protocol. Thus, there is ample room for improvement in the performance and configurability of RDMA hardware.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0004" num="0003"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is block diagram of a suitable system environment in which certain examples of the disclosed technology can be implemented.</p><p id="p-0005" num="0004"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a block diagram illustrating how tables can be used to extract data from RDMA packets, as can be performed in some examples of the disclosed technology.</p><p id="p-0006" num="0005"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a diagram depicting a number of fields included in an example data packet, as can be performed in some examples of the disclosed technology.</p><p id="p-0007" num="0006"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a diagram depicting an example of generic field extraction, as can be performed in some examples of the disclosed technology.</p><p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a diagram outlining an example of detecting and using transaction identifiers, as can be performed in certain examples of the disclosed technology.</p><p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a diagram outlining an example of performing RDMA field processing, as can be performed in certain examples of the disclosed technology.</p><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a diagram outlining an example of operations that can be performed using direct data placement (DDP) for address generation, as can be performed in certain examples of the disclosed technology.</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a diagram outlining an example circuit that can be used to perform generic RDMA operations, as can be used in certain examples of the disclosed technology.</p><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a diagram outlining an example of mapping fields from an RDMA packet to a generic RDMA commands and fields.</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a flowchart outlining an example method of performing RDMA operations for RDMA packets encoded in an arbitrary RDMA protocol, as can be performed in certain examples of the disclosed technology.</p><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. <b>11</b></figref> is a flowchart outlining an example method of performing accelerated RDMA operations for RDMA packets encoded in an arbitrary RDMA protocol, as can be performed in certain examples of the disclosed technology.</p><p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. <b>12</b></figref> is a flowchart outlining an example method of performing direct data placement operations for RDMA transactions encoded in an arbitrary RDMA protocol, as can be performed in certain examples of the disclosed technology.</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. <b>13</b></figref> is a flowchart outlining an example method of validating RDMA packets, as can be performed in certain examples of the disclosed technology.</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>14</b></figref> shows details of an example system including a plurality of management components associated with a control plane.</p><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>15</b></figref> shows details of management components that can be used in a multi-tenant environment.</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>16</b></figref> shows an example of a plurality of host computers, routers and switches, which are hardware assets used for running virtual machine instances.</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>17</b></figref> depicts a generalized example of a suitable computing environment in which the described innovations can be implemented.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0004" level="1">DETAILED DESCRIPTION</heading><heading id="h-0005" level="1">I. Introduction to the Disclosed Technology</heading><p id="p-0021" num="0020">Apparatus, methods, and computer-readable storage media are disclosed herein for remote, direct memory access (RDMA) technology that enables direct memory access from one host computer memory to another host computer memory over a physical or virtual computer network. Data packets for the RDMA operations can be encoded according to any one of a number of arbitrary RDMA protocols and translated to generic RDMA operations by a receiving RDMA controller. Thus, any existing protocol, or protocols developed after manufacture of the RDMA controller can be supported. This allows for increased flexibility and reduction in computing resources used, as one controller can support a number of different RDMA protocols.</p><p id="p-0022" num="0021">As used herein, the adjective &#x201c;generic&#x201d; indicates an aspect can be supported for two or more RDMA protocols, for example, for a single embodiment of an RDMA controller. For example, operations include write commands for each of two RDMA protocols can be supported with a single generic RDMA write command, and similarly, write commands for two RDMA protocols can be supported using a single generic RDMA read command. Similarly, a generic ALU can be configured to support a first RDMA protocol, and then used, or reconfigured and used, to support a second RDMA protocol.</p><p id="p-0023" num="0022">The disclosed direct memory access techniques allow for memory operations to be performed while bypassing at least certain aspects of an application and/or operating system hosted by a central process unit (CPU). In some examples of the disclosed technology, RDMA functionality is provided by combining a host executing instructions for RDMA software applications and a dedicated hardware accelerator, where the host has access to substantially all RDMA connection context (e.g., configuration, status, state machine, counters, etc.) and a hardware accelerator stores information for a reduced set of currently active transactions.</p><p id="p-0024" num="0023">In some examples of the disclosed technology, a connection database is provided that stores connection information for millions or billions of RDMA connections that can be serviced by an RDMA source or target system. A transaction database is provided that can store information for a smaller number of active transactions for a subset of the connections (e.g., information for hundreds or thousands of transactions). The disclosed technology can be scaled easily because the host has access to the system memory and can support many connections. The hardware accelerator can use a relatively limited size and relatively faster memory to save information for only currently active transactions. Each active RDMA transaction (e.g., RDMA read, RDMA write, etc.) can be identified using transaction ID. Certain example RDMA implementations are not protocol specific and can be implemented for standard and/or non-standard RDMA protocols.</p><p id="p-0025" num="0024">In some examples of the disclosed technology, methods are disclosed for implementing RDMA and Direct Data Placement (DDP) accelerators that can support an arbitrary number of RDMA protocols, including standard protocols and proprietary protocols. Such methods can also support future extensions and modifications to RDMA protocols and RDMA protocols developed after hardware implementing the disclosed methods has been implemented in the field. By providing a generic, programmable implementation, a protocol used to transmit RDMA packets can be detected and configurable implementation hardware can be adapted to parse packets in the detected protocol and perform operations to support processing of packets in the received protocol. It is common that such RDMA protocols use similar methods of operation and have similar parameters and variables, but encoded in different packet formats, and packet headers have different formats and fields.</p><p id="p-0026" num="0025">The disclosed technology includes methods for supporting RDMA protocols including performing at least the following RDMA operations: detection of protocol type (including when network tunneling or encapsulation is used), extraction and parsing of RDMA and DDP headers, extraction of relevant fields for packets received according to one of the supported protocols, mapping of protocoled fields to a common, generic representation, detection of RDMA/DDP commands, controlling an RDMA/DDP engine operation based on a combination of the detected RDMA protocol and RDMA command (e.g., using an RDMA control table as described further below), using an RDMA connection or transaction database to extract specific information from RDMA packets, performing RDMA operations and/or RDMA accelerations required for the reported protocol based on the detected protocol and encoded RDMA commands. Features of RDMA communication and operation that can be supported using the disclosed technology include: state machines, connection management, counter updates, field updates, DDP, header splitting, as well as generation of completion information in software hits to allow for software offloading of RDMA operations to dedicated hardware. Further, an RDMA controller implementing the disclosed technology can include the ability to update all relevant fields and databases in order to place the controller in a state to be ready for receiving a next packet of an RDMA transmission. In some examples, a single received RDMA command is converted to a single generic command plus one or more attributes detailing parameters for performing the generic command. In some examples, a single received RDMA command is converted to two or more generic commands and their respective attributes. For example, an RDMA read command for a large range of addresses could be converted to two generic commands, each implementing a read of two portions of the large range of addresses specified by the RFMA read command. In another example, a single received RDMA operations specifies both read and validation operations. This single received RDMA command can be converted to separate generic commands (and corresponding attributes) for performing the read and validation operations. Whether to convert a received RDMA command to multiple generic commands can be determined by the hardware implementing the underlying generic RDMA controller.</p><p id="p-0027" num="0026">In certain examples of the disclosed technology, a number of RDMA operations can be performed including zero copy or direct data placement protocol (DDP) operations that allow a hardware controller coupled to a network adapter to perform memory copies directly to and from application memory space, thereby reducing host CPU and memory load. In some examples, the use of virtual addresses for memory access and other memory operations is provided. In some examples, low latency memory operations over a computer network can be performed including: RDMA read, RDMA write, RDMA write with immediate value, atomic fetch and add, atomic compare and swap, and other suitable RDMA options over different forms of physical network connections. The physical media supported for performing RDMA operations includes wired connections (e.g., megabit or gigabit Ethernet, Infiniband, Fibre Channel over electrical or fiber optic connections) and wireless connections, including RF connections via Bluetooth, WiFi (IEEE 802.11a/b/n), WiMax, cellular, satellite, laser, infrared and other suitable communication connections for providing a network connection for the disclosed methods. Examples of suitable RDMA protocols that can be adapted for communication according to the disclosed technologies include, without limitation: Infiniband, RDMA over Converged Ethernet (RoCE), iWARP, and other suitable communication protocols including other open and proprietary communication protocols.</p><p id="p-0028" num="0027">In disclosed examples of RDMA communication, two or more RDMA-enabled systems include host hardware, including processors, memory, and network adapters that are configured to communicate with each other over a computer network that can include networking switches and routers. Application programs are hosted by operating systems that are executed using the processors. In some examples, a hypervisor supports operation of one or more operating systems and/or virtual machines on a host. RDMA commands issued using one or more appropriate protocols can specify addresses and spans of data for which to read and write between two or more hosts. In some examples of the disclosed technology, the disclosed RDMA techniques allow directly copying from application memory on a first host, to application memory on a second host, without copying data to system memory, or requiring execution of instructions by the host CPU.</p><heading id="h-0006" level="1">II. Example System Environment</heading><p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is block diagram <b>100</b> of a suitable system environment in which certain examples of the disclosed technology can be implemented. The system includes an RDMA source system <b>110</b> and an RDMA target system <b>150</b> that are configured to communicate with each other via a computer network <b>190</b>. For example, the RDMA source system <b>110</b> can send data for RDMA transactions via the computer network <b>190</b> to the RDMA target system <b>150</b>. The sent RDMA data includes fields that can be used by the RDMA target system <b>150</b> to identify the RDMA transaction. The RDMA target system <b>150</b>, in turn, receives the data for the first RDMA transaction and can identify the transaction based on the fields included with the RDMA data.</p><p id="p-0030" num="0029">The RDMA source system <b>110</b> includes a host <b>120</b>, which can include one or more processors such as CPUs, GPUs, microcontrollers, and/or programmable logic. The host is coupled to the computer network <b>190</b> by a network adapter <b>125</b> that is configured to send and receive communications to the computer network. Examples of suitable interfaces that can be used by the network adapter <b>125</b> include Ethernet, wireless, and cellular network connections. The host <b>120</b> has access to main memory <b>130</b>, which can include physical and virtual memory, including DRAM, SRAM, Flash, and/or mass storage devices.</p><p id="p-0031" num="0030">The main memory <b>130</b> and/or other storage can be used in conjunction with the host <b>120</b> to implement a transaction database and a connection database. The transaction database includes data relating to particular RDMA transactions being actively processed by the RDMA source system <b>110</b>. The connection database stores information regarding RDMA connections being processed by the RDMA source system <b>110</b>. In typical examples, the number of connections stored in the connection database can be much larger for the connection database vs. the transaction database&#x2014;on the order of millions or billions of RDMA connections in the connection database, vs. thousands of active transactions in the transaction database (in contemporary systems). In some examples, additional real or virtual processors are used to implement the databases. The RDMA source system <b>110</b> also includes an RDMA controller <b>140</b> that can be used to control aspects of RDMA operations performed at the RDMA source system <b>110</b>. The RDMA controller <b>140</b> includes field processing circuitry <b>145</b> that is used to translate data received according to a specific RDMA protocol to generic RDMA commands used to carry out the specified operations.</p><p id="p-0032" num="0031">The RDMA controller <b>140</b> further includes one or more translation tables <b>147</b> that store data used to perform the generic RDMA operations. For example, the tables <b>147</b> can store control and command information used to perform the disclosed RDMA operations that can be accessed by specifying a protocol index that indicates which RDMA protocol is being translated. While any suitable memory technology can be used to implement the translation tables <b>147</b>, it will be more typical that the tables will be implemented with memory technology having properties desirable in performing generic RDMA operations with the RDMA controller <b>140</b>. For example, in some applications, use of SRAM may be desirable to implement some or all of the tables <b>147</b>, while in other examples, flash memory may be more desirable, depending on the particular parameters of an instance of the RDMA source system <b>110</b> (e.g., how often parameters stored in the tables are re-programmed). In some examples, the tables <b>147</b> include local cache memory for a portion of the main memory <b>130</b>. Similarly, any suitable logic technology can be used to implement the field processing circuitry <b>145</b>, including fixed logic included in an ASIC or SoC, or reconfigurable logic included as part of a Field Programmable Gate Array (FPGA) chip or portion of an ASIC or SoC. In some examples, reconfigurable logic for an RDMA controller can be reconfigured on a per-transaction basis. In some examples, reconfigurable logic can be reconfigured for each clock cycle of performing an RDMA operations. For example, the reconfigurable logic is configured to perform operations for a first RDMA protocol in a first clock cycle, and is reconfigured to perform operations for a second, different RDMA protocol in a subsequent clock cycle.</p><p id="p-0033" num="0032">The RDMA controller <b>140</b> can be coupled to a transaction memory that can store data associated with currently-active RDMA transactions being processing by the RDMA controller <b>140</b>. In some examples, the transaction memory, RDMA controller <b>140</b>, and network adapter <b>125</b> are attached to a single network interface card that is coupled to a main board for the host <b>120</b> within the RDMA source system <b>110</b>. In some examples, some or all of the transaction database is stored in the transaction memory, and some or all of the connection database is stored in the main memory. In some examples, information stored in the connection database is partially stored in a bulk storage device (e.g., flash memory or a hard drive), in network-accessible storage, and/or in a distinct database server that is queried by the host. In some examples, the RDMA controller <b>140</b> is not connected to the main memory <b>130</b> directly, but accesses data in the connection database (e.g., to populate the transaction database for a new active transaction) via an I/O interface, bus, or other connection mechanism.</p><p id="p-0034" num="0033">The RDMA target system <b>150</b> includes similar components as the RDMA source system <b>110</b>, including a host <b>160</b>, which can include one or more processors and is coupled to the computer network <b>190</b> via a network adapter. The host also has access to main memory <b>170</b> that can be used to implement its connection and transaction databases, similar to those of the RDMA source system <b>110</b>. The RDMA controller <b>140</b> includes field processing circuitry <b>185</b> that is used to translate data received according to a specific RDMA protocol to generic RDMA commands used to carry out the specified operations. The RDMA controller <b>140</b> further includes one or more translation tables <b>187</b> that store data used to perform the generic RDMA operations.</p><p id="p-0035" num="0034">Each of the translation tables <b>147</b> and <b>187</b> can include at least one or more of the following: a protocol table, a command field translation table, a control table, a translation/connection table, search/match logic, or a transaction/connection ID database. In some examples, the tables (e.g., the protocol table <b>210</b>, the command field translation table <b>230</b>, and the control table <b>240</b>) perform lookups in addressable memory (e.g., with latches or flip-flops in a register file, an SRAM, or a DRAM) using an address based on a portion of their inputs. In some examples, additional logic is included with the tables (e.g., to modify input to an address for accessing a memory. In some examples one or more of the translation tables <b>147</b> and <b>187</b> are implemented with a content addressable memory (CAM) or ternary content addressable memory (TCAM).</p><p id="p-0036" num="0035">Further, the RDMA target system <b>150</b> also includes an RDMA controller <b>180</b> coupled to transaction memory. The RDMA controller <b>180</b> is configured to, responsive to receiving an RDMA initiation packet indicating initiation of an RDMA transaction, generate and store a first transaction identifier in the transaction memory. The RDMA controller <b>180</b> can generated the first transaction identifier based at least in part on information in an RDMA initiation packet. The RDMA controller <b>180</b> can store context data for performing the RDMA transaction in transaction memory. Further, the RDMA controller is configured to receive additional RDMA packets for the initiated RDMA transaction, generate a second transaction identifier based on RDMA header information in the packets, and with the second transaction identifier, retrieve at least a portion of the context data from the first memory. The second transaction identifier can be generated by extracting a designated field in the RDMA header. In some examples, the second transaction identifier is generated by combining information from other fields in the RDMA or other headers of an RDMA packet. Using the retrieved context data, the RDMA controller <b>180</b> can perform at least a portion of the RDMA transaction.</p><p id="p-0037" num="0036">In some examples, the RDMA controller <b>180</b> is further configured to, based on the context data stored in the first memory, determine a target location in the main memory, the determined target location being used for the performing at least a portion for the RDMA transaction. In some examples, the RDMA controller <b>180</b> is further configured to validate the RDMA transaction by comparing context data stored in the transaction memory to the data received with the additional RDMA packets.</p><p id="p-0038" num="0037">Implementations of the components within the RDMA target system <b>150</b> can use similar components as those described above regarding the RDMA source system <b>110</b>, although they do not necessarily need to be identical or similar in configuration and/or capacity.</p><p id="p-0039" num="0038">The computer network <b>190</b> can carry bidirectional data, including RDMA packets, between the RDMA source system <b>110</b> and the RDMA target system <b>150</b>. The computer network <b>190</b> can include public networks (e.g., the Internet), private networks (including virtual private networks), or a combination thereof. The network may include, but are not limited to personal area networks (PANs), local area networks (LANs), wide area networks (WANs), and so forth. The computer network <b>190</b> can communicate using Ethernet, Wi-Fi&#x2122;, Bluetooth&#xae;, ZigBee&#xae;, 3G, 4G, or other suitable technologies.</p><p id="p-0040" num="0039">Each of the hosts <b>120</b> and <b>160</b> depicted in the block diagram <b>100</b> can execute computer-readable instructions implementing RDMA software and can be configured to implement any RDMA standard. For example, RDMA software can implement at least a portion of the network transport layer and packet validation. The RDMA software can also perform protocol operation and management operations. In some examples, the software can implement connection validation and maintenance, while in other examples, some of the operations performed by the software can be performed by specially-configured hardware. Computer-readable instructions implementing the RDMA software can also be used to send signals to the RDMA controllers <b>140</b> and <b>180</b> with instructions on the manner in which to read and write information to their respective transaction memories. In some examples, the RDMA controllers act as accelerators and enable faster communication between the source system and the target system. However, in certain cases the RDMA controller <b>140</b> and/or RDMA controller <b>180</b> may not be configured to accelerate RDMA traffic in a particular scenario. In such cases, the respective hosts <b>120</b> or <b>160</b> can take over the transaction and operate without the assistance of the RDMA controllers. Further, it should be noted that, for ease of explanation, network traffic is generally described as being transmitted from the RDMA source system <b>110</b> to the RDMA target system <b>150</b>, but that bi-directional communication between the source system and the target system can occur simultaneously or alternatively.</p><p id="p-0041" num="0040">Each of the RDMA controllers <b>140</b> and <b>180</b> include hardware that can perform a number of different transactions for processing RDMA traffic. The RDMA controllers can be implemented using a digital signal processor, a microprocessor, an application-specific integrated circuit (ASIC), and soft processor (e.g., a microprocessor core implemented in a field-programmable gate array (FPGA) using reconfigurable logic), programmable logic, SoC, or other suitable logic circuitry.</p><p id="p-0042" num="0041">The RDMA controllers <b>140</b> and <b>180</b> identify packets related to RDMA operations and can perform one or more of the following operations. The controller can validate RDMA headers contained within packets of data. This validation can include validating fields of the RDMA header and validating error correction codes, such as cyclic redundancy check (CRC) codes or other header verification mechanisms. The controller can parse RDMA headers and extract fields used for processing and accelerating RDMA transactions. For example, the controller can identify an active transaction based on a transaction identifier derived from the RDMA header. The transaction identifier can be derived based on one or more specific transaction ID fields in the RDMA header, a combination of multiple fields of the RDMA header, or matching data of the header with a list of expected values (e.g., using a content-addressable memory (CAM) or a transaction table). The controller can further validate header fields including RDMA header fields against information previously stored for the current transaction. Further, the controller can implement RDMA acceleration techniques including one or more of: DDP enable, DDB address, header splitting, data trimming, DMA/queue selection, and/or target server/virtual machine acceleration. For example, RDMA hardware acceleration can result in writing received RDMA data directly to application memory space (e.g., directly to the main memory <b>170</b>) in a &#x201c;zero copy&#x201d; mode. In other words, the RDMA controller <b>180</b> can write RDMA data, and perform other RDMA options, thus bypassing the host <b>160</b>, and therefore reducing processor load and memory traffic between the host <b>160</b> and the main memory. Further, the controller <b>180</b> can notify software for the software executing on the host <b>160</b> and forward the RDMA information, thereby reducing the number of software operations used and further reducing latency.</p><p id="p-0043" num="0042">In some examples of the disclosed technology, RDMA implementations are connection-based implementations. In such examples, a database including connection data is maintained for each RDMA connection. The context information that can be stored in the database for each connection can include: connection information, connection state information, state machine information for the connection, counters, buffer scatter gather lists, and other suitable context data. In some examples, hardware support is provided to implement one or more databases storing context information on a per connection basis, as well state machine state on a per connection basis.</p><p id="p-0044" num="0043">In certain examples of the disclosed technology, hardware and methods are provided for implementing RDMA functionality by combining software and/or hardware accelerators. In some examples, the software implementation (e.g., computer-executable instructions that are executed on a host processor) maintains data for context state for one or more RDMA connections. The context state that can be maintained by the instructions can include configuration information, status information, state machine information, counters, network addresses, hardware identifiers, and other suitable data. In such examples, hardware is configured to store a subset of the context information that relates to current active RDMA transactions that are being processed by the respective host computer.</p><p id="p-0045" num="0044">In some examples, such RDMA configurations allow for improved scaling because connection context maintained by the host CPU, which has access to the system main memory and can support a large number of connections while the accelerator (e.g., an RDMA controller) can use a limited amount of faster memory to save a smaller portion of information regarding currently active transactions. Each of the currently active transactions can be identified using a transaction identifier (transaction ID), which can be generated using a number of different techniques, including combinations and subcombinations of transaction ID generating techniques disclosed herein.</p><p id="p-0046" num="0045">In certain examples, implementations of an RDMA controller are not limited to a single protocol, but the same hardware can be used to implement two or more standardized and/or non-standardized RDMA protocols. In some examples, RDMA controller hardware can initiate and perform direct data placement of RDMA data, thereby reducing load on other host processor resources, including CPUs and memory. Further, disclosed transaction based accelerations can be performed for RDMA read, RDMA write, and other suitable RDMA transactions.</p><p id="p-0047" num="0046">It should be noted that while the terms &#x201c;transaction&#x201d; and &#x201c;transaction ID&#x201d; are associated with particular RDMA operations such as RDMA reads and writes, the use of transactions is not limited to these operations, but can also be associated with other RDMA entities or variables. For example, a transaction ID can be associated with a portion of memory (e.g., a memory space, memory region, or memory window), in which case the disclosed RDMA acceleration techniques can associate RDMA packets, RDMA operations, and/or RDMA messages with a single transaction ID and use context information association with the transaction ID to perform DDP and other acceleration or protection operations. In such examples, a transaction database can be initialized during memory registration of the associated memory portion.</p><p id="p-0048" num="0047">For example, when a transaction ID is associated with a memory window, multiple RDMA write operations can be linked to the same transaction ID and thus, associated with the same memory window. Thus, the associated operations can be verified with any associated memory restrictions that apply to the region and can use the properties of the memory region that are registered in a transaction database.</p><p id="p-0049" num="0048">In some examples of the disclosed technology, scalability of the system can be improved by maintaining a large amount of RDMA connection information in a database maintained by a host in main memory, while maintaining active transaction information in a relatively smaller hardware database. In some examples, overall load on memory resources is reduced by performing zero copy operations using DDP. In some examples, processor load (e.g., CPU load) is reduced by an RDMA controller performing a large portion of RDMA operations, while forwarding hints and other information related to RDMA transaction to the host processor. In some examples, transaction latency is improved by the hardware performing much of the operations associated with certain RDMA transactions.</p><p id="p-0050" num="0049">In some examples, the disclosed technologies allow for the performance of RDMA transactions involving out-of-order data. Thus, data loss, data arriving at a target host in a different order than it was sent, and other issues associated with out-of-order data can be alleviated. For example, the use of transaction IDs transparent to the host allows the RDMA controller to re-order, request resending, and perform other operations that make an RDMA transaction carried out with out-of-order data appear to be in-order to the host. In some examples, an RDMA controller supports both out-of-order and in-order transactions using any suitable RDMA protocol. In some examples, use of certain examples of the disclosed RDMA controllers allow for implementation of out-of-order RDMA transactions using RDMA protocols that do not natively support such out-of-order transactions. In some examples, in-order transactions are supported with RDMA protocols that natively support only out-of-order transaction implementations.</p><heading id="h-0007" level="1">III. Example Use of Protocol Index to Generate Generic RDMA Commands</heading><p id="p-0051" num="0050"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a block diagram <b>200</b> illustrating data flow in an RDMA controller configured to use a number of tables can be used to extract data from received RDMA packets, including the use of a number of tables implemented using memory or registers and additional logic circuitry (e.g., fixed or reconfigurable logic circuits) in order to convert data specified in a particular, specific RDMA protocol to a generic RDMA command format. For example, the exemplary system environment of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, including the RDMA source system <b>110</b> and the RDMA target system <b>150</b> can be used to perform operations associated with the system of <figref idref="DRAWINGS">FIG. <b>2</b></figref>. For example, the system of <figref idref="DRAWINGS">FIG. <b>2</b></figref> can be implemented in each of the RDMA controllers <b>140</b> and <b>180</b> alone, or in conjunction with a portion of resources of their respective host systems. For ease of explanation, the example block diagram <b>200</b> represents components, including circuits and memories with square-cornered rectangles, while data that is passed to and from the components are represented with rounded rectangles.</p><p id="p-0052" num="0051">A protocol index <b>205</b> is extracted from an RDMA packet that indicates which of a plurality of RDMA protocols the associated RDMA packet is encoded. Any suitable RDMA protocol can be assigned to an associated index, including but not limited to proprietary and non-proprietary RDMA implementations including Virtual Interface Architecture, RDMA Over-Converged Ethernet (RoCE), Infiniband, and iWarp. The protocol index <b>205</b> is used to access a protocol table <b>210</b> that stores control information for performing field extraction that can vary based on the applied protocol index. For example, the protocol index <b>205</b> can be applied as an address to a memory unit that stores the protocol table <b>210</b>. The control information <b>215</b> is in turn applied to a field extraction circuit <b>220</b>, which includes logic for decoding an associated extracted RDMA header <b>225</b> and which generates input to a command field translation table <b>230</b>. In other examples, the system does not include a command field translation table. The control information <b>215</b> can include size and offset information used to select the appropriate data (e.g., a range of bits) in the extracted RDMA header of interest for generating command fields. This enables detection of fields and command from different locations in the RDMA header, according to the detected protocol index.</p><p id="p-0053" num="0052">The command field translation table <b>230</b> can be implemented using a memory or registers and generates further input that can be applied to a control table <b>240</b> in conjunction with the protocol index <b>205</b> in order to generate control information <b>245</b> for processing a selected generic RDMA command. Thus, read, write, move, copy, and other suitable RDMA commands expressed in a specific format in the RDMA packets can be translated to a generic control format, thereby allowing the same hardware to support two or more RDMA protocols. Data for the control information <b>245</b> is applied to a reconfigurable field extraction unit <b>250</b> which comprises a logic circuit that is used to extract additional control and data fields from the RDMA packet which are output as extracted fields <b>255</b>. In some examples, the circuit of <figref idref="DRAWINGS">FIG. <b>2</b></figref> can be implemented in an integrated circuit, such as an application-specific integrated circuit (ASIC), an SoC, or in reconfigurable logic such as an FPGA.</p><p id="p-0054" num="0053">As stated above, the example block diagram <b>200</b> includes circuits and memories represented with square-cornered rectangles, while data that is passed to and from the components are represented with rounded rectangles. The circuits and memories can be interconnected using any suitable interconnection technology, including electrical and optical multipoint and point-to-point busses. In some examples, the tables (e.g., the protocol table <b>210</b>, the command field translation table <b>230</b>, and the control table <b>240</b>) perform lookups in addressable memory (e.g., with latches or flip-flops in a register file, an SRAM, or a DRAM) using an address based on a portion of their inputs. In some examples, additional logic is included with the tables (e.g., to modify input to an address for accessing a memory. In some examples, the circuits (e.g., the field extraction circuit <b>220</b> and the reconfigurable field extraction unit) use combinational and/or sequential logic to perform their described functions. In some examples, the circuit can include addressable memory and/or reconfigurable logic.</p><heading id="h-0008" level="1">IV. Example Data Packet with RDMA Header and Payload</heading><p id="p-0055" num="0054"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a diagram <b>300</b> depicting a number of fields included in an example data packet <b>310</b>. It should be noted that the depicted fields can be fixed length or variable length, depending on the associated protocol. Further, the depiction of <figref idref="DRAWINGS">FIG. <b>3</b></figref> is a simplified example used to illustrate header processing, but is not limited to the examples shown.</p><p id="p-0056" num="0055">As shown, the data packet includes a packet header <b>320</b>, packet data <b>330</b>, and in some cases, a CRC <b>340</b> for the packet data. As shown at <figref idref="DRAWINGS">FIG. <b>3</b></figref>, the packet header <b>320</b> is further elaborated and can include a tunnel header <b>321</b> and an inner header <b>322</b>. For example, the tunnel header <b>321</b> can be associated with a security or other transport protocol while the inner header <b>322</b> includes data for the header itself. As shown, the optional tunnel header <b>321</b> includes data corresponding to different layers of a network protocol hierarchy (e.g., an L2 header, and L3 header, and an L4 header). The inner header includes an L2 header, an L3 header, and L4 header, as well as an RDMA header <b>325</b>. The L2, L3, and L4 headers correspond to different header levels in a network protocol stack (e.g., according to a TCP/IP protocol stack). The RDMA header <b>325</b> can be implemented in a number of different communication layers depending on the implemented RDMA protocol. In some examples, the RDMA header <b>325</b> includes header CRC data that can be used to validate the header information. The RDMA header <b>325</b> can be specified according to the RDMA protocol being used for the data packet.</p><p id="p-0057" num="0056">A number of different fields can be encoded in the RDMA header <b>325</b> and the particular names and functionalities for the fields can vary depending on the particular RDMA protocol employed. For example, the RDMA header <b>325</b> can include data regarding queue numbers, connection identifiers, transaction identifiers, packet sequence numbers, message sequence numbers, RDMA commands, RDMA op codes, keys, protection data, memory keys, memory addresses, message length and size data (e.g., describing the complete length of the associated RDMA operation, for example as a number of bytes or a number of packets), host number, host identifier, Internet Protocol (e.g. IPv4 or IPv6) addresses, and other suitable data.</p><p id="p-0058" num="0057">Any or all of the different header fields in the packet header <b>320</b> can be used to determine a protocol index <b>350</b>. In some examples, only data in the RDMA header <b>325</b> is used to determine the protocol index <b>350</b>. In some examples, data in the RDMA header <b>325</b> and one or more of the L2/L3/L4 headers is used. In some examples, only data in one of the L2/L3/L4 headers is used. In some examples, only the RDMA header <b>325</b> encoded in the data packet is used to generate the extracted RDMA header <b>360</b>. In other examples, data from other portions of the packet header <b>320</b> supplements, or replaces, the RDMA header <b>325</b> to generate the extracted RDMA header <b>360</b>. The extracted RDMA header <b>360</b> can also be used for additional aspects of RDMA operation control, as discussed further below.</p><p id="p-0059" num="0058">A generic RDMA parser can be used to detect all headers encapsulated in a RDMA packet including extraction of the L2/L3/L4 protocols (including standard and non-standard protocol detection as well as RDMA information encoded in the RDMA packet header). In cases where tunneling or other encapsulation methods are detected, inter headers of the packets can also be parsed and inter protocols detected. All of the information parsed from the packet can be used to detect the type of protocol employed. A list of all detected protocols is then matched with a predefined list of protocols. For example, a content addressable memory (CAM) can be used to detect the RDMA protocol encoding. Once the detected protocol has been matched to a predefined list, a selected protocol index is used to represent the detected packet type/structure of the RDMA packet. The detected protocol can also be used to extract the RDMA header from the network packet headers. This header can be used to facilitate more detailed RDMA processing. The following Table 1 lists a number of examples of RDMA fields that can be detected and implemented using a generic RDMA engine. As will be readily understood to one of ordinary skill in the relevant art, the names and functionality of these header fields can vary between different RDMA protocols/standards. Further, the disclosed methods are not limited to header fields in this Table, but can be extended to any suitable RDMA header field.</p><p id="p-0060" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="49pt" align="left"/><colspec colname="1" colwidth="168pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" rowsep="1">TABLE 1</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>Queue number/connection ID</entry></row><row><entry/><entry>Transaction ID</entry></row><row><entry/><entry>Sequence number (packet or message)</entry></row><row><entry/><entry>Command/Opcode</entry></row><row><entry/><entry>Key/protection/memory-key</entry></row><row><entry/><entry>Address</entry></row><row><entry/><entry>Message Length/size (e.g., the complete</entry></row><row><entry/><entry>length of the RDMA operation for</entry></row><row><entry/><entry>example where an operation has been</entry></row><row><entry/><entry>segmented into multiple packets)</entry></row><row><entry/><entry>Host number/ID</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0009" level="1">V. Example Generic RDMA Field Extraction</heading><p id="p-0061" num="0059"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a diagram <b>400</b> depicting an example of generic field extraction, as can be performed in certain examples of the disclosed technology. For example, the depicted generic field extraction can be performed using the field extraction circuit <b>220</b> discussed above regarding <figref idref="DRAWINGS">FIG. <b>2</b></figref>. As shown, an RDMA packet includes an input RDMA header <b>410</b> that includes data encoding specifics regarding an RDMA transaction to be performed in a specific RDMA format. Control information for processing the input RDMA header including, for example, an offset <b>420</b> and a size <b>425</b> of a field to be extracted can be applied in order to identify the required field <b>430</b>. In some examples, the data encoded for the required field <b>430</b> is simply copied to the generic extracted field <b>440</b>. In other examples, data in the required field <b>430</b> is modulated in some fashion, for example, by changing the number of bits to comply with the extracted field size by performing data cast operations, such as converting from a signed to an unsigned integer, or vice versa, or by changing data precision of a fixed point format number field. Other examples of operations can include shifting or rotating bits of the field <b>430</b> to be extracted or changing the endianness of data encoded in the required field to a different format used for the extracted generic field <b>440</b>. The generic field extraction logic circuit can be configured to support different parameters (e.g., offset and size), depending on the identified protocol index. This allows the RDMA controller to extract fields with different offsets and sizes based on the outputs of the protocol table and the control table. Thus, a field (with similar functionality in two different RDMA protocols) can be extracted from different locations in the headers for different RDMA protocols.</p><heading id="h-0010" level="1">VI. Example Technology for Using Transaction Identifier</heading><p id="p-0062" num="0060"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a block diagram <b>500</b> outlining data flow as can be used in certain exemplary apparatus and methods for detecting transaction identifiers and selecting from a list of active transactions, as can be performed in certain examples of the disclosed technology. As shown in <figref idref="DRAWINGS">FIG. <b>5</b></figref>, an extracted RDMA header <b>510</b> is applied an RDMA parsing engine <b>520</b> which generates control information <b>525</b> for a selected RDMA command. The RDMA parsing engine <b>520</b> also sends data to one or more circuits in order to generate a transaction identifier. For ease of explanation, the example block diagram <b>500</b> represents components, including circuits and memories with square-cornered rectangles, while data that is passed to and from the components are represented with rounded rectangles.</p><p id="p-0063" num="0061">In some examples, a transaction identifier is extracted directly from an RDMA header as shown at block <b>530</b>. In some examples, one or more fields are extracted from the RDMA header <b>510</b> and applied to a translation/connection table <b>540</b> as shown at block <b>545</b>. In some examples, extracted field data from the extracted RDMA header is applied to a search logic function, or using matching logic, or using a content addressable memory (CAM) <b>550</b> as shown at block <b>555</b>. Examples of fields that can be extracted (via any of blocks <b>530</b>, <b>545</b>, or <b>555</b>) include, but are not limited to: memory key, memory protection, queue number, and sequence number.</p><p id="p-0064" num="0062">One or more of the extracted transaction identifiers are then used to detect a transaction identifier and to select an appropriate active transaction based on the detected protocol using a transaction ID detection circuit <b>560</b>. The identified transaction identifier is used to access an active transaction list and/or a transaction/connection identifier database <b>570</b>, which stores information about active RDMA transactions, including destination and source addresses, sequence numbers of received RDMA packets, and other information that can be used to accelerate or facilitate performing an RDMA operation. Using information stored in the transaction list database <b>570</b>, one or more acceleration commands for a specific transaction <b>580</b> can be generated and used to perform an RDMA transaction.</p><p id="p-0065" num="0063">As stated above, the example block diagram <b>500</b> includes circuits and memories represented with square-cornered rectangles, while data that is passed to and from the components are represented with rounded rectangles. The circuits and memories can be interconnected using any suitable interconnection technology, including electrical and optical multipoint and point-to-point busses. In some examples, tables, databases, and search logic (e.g., the translation/connection table <b>540</b>, search/match logic/CAM <b>550</b>, and database <b>570</b>) perform lookups in addressable memory (e.g., including latches or flip-flops in an array, SRAM, and/or DRAM) using an address based on a portion of their inputs. In some examples, additional logic is included. In some examples, circuits (e.g., implementing the RDMA parsing engine <b>520</b> and transaction ID detection circuit <b>560</b>) use combinational and/or sequential logic to perform their described functions. In some examples, the circuit can include addressable memory and/or reconfigurable logic.</p><p id="p-0066" num="0064">In some examples an RDMA protocol uses connection identifications or transaction identification to detect specific RDMA operations. RDMA operations can also be segmented into multiple packets. These identification fields can be mapped to a generic context ID. The connection ID and/or transaction ID can be encoded in one of the header fields (with different names, offsets, and/or sizes) and can be extracted from the RDMA header based on the detected protocol number and the detected command. The extracted connection/transaction ID can be used to access a connection/transaction database, and the output of this database can include control and commands to be used for this specific connection or transaction.</p><p id="p-0067" num="0065">In some examples, a sequence number field can be extracted from the RDMA header. This sequence number can be the connection sequence number (used to detect link errors that can cause lost packets, mis-inserted packets, and/or out of order packets). This sequence number can also be used to detect multiple packets that are part of an RDMA command that was segmented to multiple packets.</p><p id="p-0068" num="0066">The sequence number can be saved in a connection/transaction ID table (or RDMA context table), and the saved value can be compared to the received field from the RDMA header to validate the packet. The sequence number can be incremented (e.g., using a reconfigurable ALU and stored in a table or database to be used in decoding the next received packet of this connection/transaction.</p><p id="p-0069" num="0067">It should be noted that the increment can be in steps of any value, depending on the protocol number and the RDMA command. For example, in some cases the increment will be &#x2018;1&#x2019; to detect consecutive packets, but the sequence number can also be incremented by any other suitable value. The sequence number can also be incremented by a value which depends on the packet payload size (for example, when the payload includes multiple blocks of data).</p><p id="p-0070" num="0068">A memory protection field can be extracted from the RDMA header. Examples of suitable memory protection fields include, but are not limited to: memory protection, memory key, protection domain, transaction protection, or network link protection.</p><p id="p-0071" num="0069">The protection field can be saved in the connection/transaction ID table, and the saved value can be compared to the received field from the RDMA header to validate the packet. In some examples the protection field can be modified (e.g., using a reconfigurable ALU and stored in the table to be used in the next received packet of the currently processed connection or transaction. The protection information can also be used to invalidate a selected memory region or to deregister a memory window or a protection domain.</p><p id="p-0072" num="0070">As stated above, the example block diagram <b>200</b> includes circuits and memories represented with square-cornered rectangles, while data that is passed to and from the components are represented with rounded rectangles. The circuits and memories can be interconnected using any suitable interconnection technology, including electrical and optical multipoint and point-to-point busses. In some examples, the tables (e.g., the protocol table <b>210</b>, the command field translation table <b>230</b>, and the control table <b>240</b>) perform lookups in addressable memory (e.g., with latches or flip-flops in a register file, an SRAM, or a DRAM) using an address based on a portion of their inputs. In some examples, additional logic is included with the tables (e.g., to modify input to an address for accessing a memory. In some examples, the circuits (e.g., the field extraction circuit <b>220</b> and the reconfigurable field extraction unit) use combinational and/or sequential logic to perform their described functions. In some examples, the circuit can include addressable memory and/or reconfigurable logic.</p><heading id="h-0011" level="1">VII. Example Technology for RDMA Field Processing</heading><p id="p-0073" num="0071"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a block diagram <b>600</b> outlining dataflow as can be used in certain exemplary methods of performing RDMA field processing according to the disclosed technology. For example, the example system described above regarding <figref idref="DRAWINGS">FIG. <b>1</b></figref> can be used to implement the field processing operations depicted in <figref idref="DRAWINGS">FIG. <b>6</b></figref>. An extracted RDMA header <b>610</b> contains a number of fields that can be used by an RDMA processing engine. These fields can be used for example, to detect and identify the connection/transaction, packet sequence, packet loss, memory protection, address and link control, and connection management. A number of different field processing components (e.g., field processing components <b>620</b> and <b>629</b>) can be used to each process fields according to a different protocol. For example, the first field processing component <b>620</b> receives decoded control information <b>630</b> and decoded field information <b>635</b> that can be extracted using similar technology to that described above regarding <figref idref="DRAWINGS">FIG. <b>2</b></figref>. The control information <b>630</b> is applied to a field extraction circuit <b>640</b> and optionally, a command field translation table <b>645</b>. The field extraction circuit <b>640</b> is used to detect and translate data encoded in a particular RDMA header field format to a generic RDMA field format. The command field translation table <b>645</b> can then translate RDMA commands detected from the RDMA header to generic RDMA commands based on the received control information <b>630</b> as well as information extracted from the RDMA fields. For example, information regarding the location and size of fields can be extracted from an RDMA header, along with information describing actual RDMA operations.</p><p id="p-0074" num="0072">These commands are then sent to the field compare circuit <b>650</b> and a configurable ALU circuit <b>655</b> for field modification. The field compare circuit <b>650</b> compares the field extracted from the RDMA packet to a configurable field from a control table or from a connection/transaction table associated with a currently detected transaction and compares the result of the comparison. Fields can be compared to a configurable field from the control table or from the connection/transaction table. Similar processing can be used to update RDMA context fields.</p><p id="p-0075" num="0073">The extracted fields and commands can also be sent to a reconfigurable ALU for field modification. The configurable ALU circuit <b>655</b> can generate new values to be used by the current packet or by next packets of an RDMA connection transaction. The field can be modified using the configurable ALU circuit <b>655</b> to generate new value to be used for this packet or the next consecutive packet of this connection/transaction. For example, the address of a next memory location to write data to when performing an RDMA write or location to copy data as part of an RDMA read can be calculated using the configurable ALU circuit <b>655</b>. The field operation results <b>670</b> can be sent to signal other portions of the RDMA controller and/or stored in one or more registers in order to be used in the processing of the current or subsequent RDMA packets.</p><p id="p-0076" num="0074">The result of the field compare circuit <b>650</b> and/or the modified results output by the configurable ALU <b>655</b> is sent to the field result generation circuit <b>660</b> for comparison. The field result generation circuit <b>660</b> outputs field operation results <b>670</b> to control how further RDMA processing will proceed based on the comparison. For example, if the field result generation circuit <b>660</b> indicates that the packet is validated, then RDMA operations by the RDMA controller are allowed to continue. If the packed is determined to be invalid in some way, then an exception or signal can be raised, and further RDMA operations can be passed to the host system for exception handling. Other operations can be supported using the disclosed validation comparison. For example, based on the validation, DDP transactions can be performed and validated or invalidated, a stop processing command can be sent to instruct the sending RDMA source system to stop sending data. In further examples, the completeness of the RDMA packets can be determined using the validated transaction ID, and RDMA packets can be retransmitted to another RDMA target system.</p><heading id="h-0012" level="1">VIII. Example of DDP Address Generation</heading><p id="p-0077" num="0075"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a block diagram <b>700</b> outlining example operations that can be performed for address generation for direct data placement (DDP), as can be used in some examples of the disclosed technology. RDMA controllers disclosed herein can be adapted to enable DDP operations, which are used to write received data (e.g., data received in an RDMA packet) directly to a memory location used by the receiving application with &#x201c;zero copy.&#x201d; Thus, the software and memory access overhead of copying data to a memory buffer or other location before transferring the data to the target destination can be avoided. The address for the DDP operation can be extracted from the RDMA packet itself, retrieved from a connection/transaction ID table, or read from a list (including, in some examples, a scatter/gather buffer list) that can be used for performing the DDP operation. In some examples, a combination of the above technologies is used to determine the target address. For example, the specified RDMA address can be translated from or to one or more of the following: a virtual address, an intermediate physical address, or a physical address. A virtual memory ID can also be used for address translation when the virtualized system is implemented.</p><p id="p-0078" num="0076">The generated DDP address can also be saved and used for the next received packet for this connection/transaction. For example, a generic ALU can be used to modify the address and store it in a register for use when the next packet is received. As shown in <figref idref="DRAWINGS">FIG. <b>7</b></figref>, an extracted RDMA header <b>710</b> is sent to a generic field extraction circuit <b>720</b>, which produces an extracted address <b>725</b> based on the RDMA header. The extracted address <b>725</b> is sent to an address generation circuit <b>730</b>, which can also receive address translation information <b>740</b> an address from a connection/transaction ID database <b>741</b>, and/or an address from a control table <b>742</b>. The address generation circuit <b>730</b> performs address selection and optional address translation and outputs a generated address <b>750</b> for DDP. The DDP address <b>750</b> is output for performing RDMA operations with the current packet <b>755</b>. The generated address <b>750</b> is also used to generate an address for next packets <b>760</b>. For example, the new address can equal the current address plus a defined Maximum Transfer Unit (MTU) parameter then the generated next address is stored <b>770</b> for next consecutive packet. In some examples, the MTU ranges from 256 bytes up to 64K or more bytes, depending on the particular RDMA protocol in which the packets were encoded.</p><heading id="h-0013" level="1">IX. Example Generic ALU for Field Processing</heading><p id="p-0079" num="0077"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a diagram <b>800</b> outlining an example circuit that can be used to perform generic RDMA operations such as RDMA field modification, address generation, data translation, and other suitable calculations for implementing disclosed RDMA operations. The illustrated circuit can be reconfigurable, for example the circuit can be reconfigured to implement a plurality of RDMA protocols prior to initiating a number of RDMA transactions, or the circuit can be reconfigured during processing of received RDMA packets.</p><p id="p-0080" num="0078">As shown in <figref idref="DRAWINGS">FIG. <b>8</b></figref>, a plurality of multiplexers <b>810</b> is arranged to receive data derived from RDMA packets, including, for example, header information extracted from RDMA fields, as well as data stored in the RDMA packet data payload. For example, a first multiplexer <b>811</b> can have an arbitrary number of data inputs, labeled 0-n. A first operation selection signal (labeled Op_sel_0) is used to select one of the data inputs, which is output from the first multiplexer as a signal <b>821</b>.</p><p id="p-0081" num="0079">Similarly, a second multiplexer <b>812</b> selects an output according to a second selection input (labeled Op_sel_1) to select another data input, which in turn outputs the selected input as an output signal <b>822</b>. The first output signal <b>821</b> and the second output signal <b>822</b> are input to a 2-input arithmetic and logic unit (ALU) <b>830</b>. The inputs A and B can be multiple bits wide. The ALU <b>830</b> performs an operation that is specified by its opcode input signal (labeled Op_code_0). Examples of operations that can be performed by ALUs according to certain examples of the disclosed technology, include: output the value on its first input A (e.g., the ALU input signal <b>821</b>), output the value on its second input B (e.g., the ALU input signal <b>822</b>), output the value of the logical inverse of A or B, add A plus B, subtract B from A, left shift or right shift of A or B, multiply A and B, logical operations on A and B, including AND, OR, XOR, XNOR, or any other suitable arithmetic or logical operations. The outputs of the first ALU <b>830</b> and the second ALU <b>831</b> can be output to a third ALU <b>840</b>. Each of the ALUs <b>830</b>, <b>831</b>, and <b>840</b> have an independent opcode input signal. Thus, the ALUs can be reconfigured to perform a selected operation for field extraction and translation, according to the current protocol index of the RDMA packet being processed. The result of the circuit can be output as a data output <b>850</b>. It should be readily understood to one of ordinary skill in the art that the number of ALUs can be increased or decreased. Further, in certain examples, other hardware implementing arithmetic and logic operations can be employed. For example, dedicated shifters, adders, or other logic circuits can be employed at one or all levels of the logic circuit, replacing the ALUs shown, depending on design selections made by a designer of the RDMA hardware.</p><heading id="h-0014" level="1">X. Example Mapping of Specific RDMA Fields to Generic RDMA Fields</heading><p id="p-0082" num="0080"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a diagram <b>900</b> that shows an example mapping between fields in an example, specific RDMA protocol (RDMA over Converged Ethernet, RoCE) to generic RDMA fields. Packets encoded in the illustrated RDMA protocol can include a base transport header <b>910</b> and an extended transport header <b>950</b>. As shown in <figref idref="DRAWINGS">FIG. <b>9</b></figref>, a number of fields in the RDMA packet headers <b>910</b> and <b>950</b> are mapped to a generic table <b>970</b> of generic commands and parameters. For example, RDMA commands such as read and write can be encoded in the 8-bit OpCode field of the base transport header <b>910</b>. The specific RDMA command is mapped to a generic RDMA command encoded as 32 bits of the generic table <b>970</b>, at bytes 12-15. Similarly, the Destination QP (queue pair) field is mapped to the generic parameter queue number field at bytes 0-3. Two words of virtual address in the extended transport header <b>950</b> are mapped to 8 bytes of address space for the generic command field. Because the generic commands and parameters are not transmitted over a network, it can be more efficient in some cases to assign these fields to word-size portions of a table, in lieu of constraining the generic commands and parameters to varying-size fields. The decoded generic commands and parameters can be stored in, for examples, the protocol table <b>210</b>, the command field translation table <b>230</b>, the control table <b>240</b>, and other suitable tables used to perform generic RDMA commands.</p><heading id="h-0015" level="1">XI. Example Method of Performing RDMA Operations Using a Protocol Index</heading><p id="p-0083" num="0081"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a flowchart <b>1000</b> outlining an example method of performing RDMA operations for RDMA packets received that are encoded in an arbitrary RDMA protocol. For example, the system described above in <figref idref="DRAWINGS">FIG. <b>1</b></figref> can be used to transmit, receive, and perform the disclosed RDMA operations.</p><p id="p-0084" num="0082">At process block <b>1010</b>, one or more RDMA packets are received via a network adapter (e.g., network adapter <b>165</b>). At process block <b>1020</b>, the packets can be controlled with the aid of an RDMA controller in order to derive a protocol index that identifies an RDMA protocol in which the RDMA packets were encoded. For example, fixed or reconfigurable circuits coupled to a memory implementing a protocol table as discussed further above regarding <figref idref="DRAWINGS">FIG. <b>2</b></figref> can be used to generate a protocol index and to generate corresponding control information for processing the RDMA packets according to the protocol index. The derived protocol index is used to indicate how to map fields in the received RDMA packets to a generic set of RDMA fields and generic RDMA commands.</p><p id="p-0085" num="0083">At process block <b>1030</b>, the protocol index derived at process block <b>1020</b> is applied to generate generic RDMA commands from header information in the received RDMA packets. For example, control information such as control information <b>215</b> generated from the protocol index <b>205</b> can be applied to a field extraction circuit to generate commands and command fields for processing of the RDMA packets. The generated command field and protocol index can be applied to a control table, which can be implemented as a memory in order to generate control information for processing the RDMA command specified in the RDMA packet. Control information can be stored in the memory and generated by applying the appropriate index values.</p><p id="p-0086" num="0084">At process block <b>1040</b>, the control information is generated for a reconfigurable field extraction unit. The reconfigurable field extraction unit can include a number of multiplexers and ALUs used to apply signals according to the generated control and command information in order to extract the appropriate data from the RDMA packet. These signals are sent to the appropriate processing units within the RDMA controller.</p><p id="p-0087" num="0085">At process block <b>1050</b>, an RDMA operation is performed using the generated generic RDMA commands and control information that was generated at process blocks <b>1030</b> and <b>1040</b>. Thus, RDMA packets encoded in a specific RDMA protocol including proprietary protocols can be translated into generic RDMA functions and their associated RDMA operations can be performed.</p><heading id="h-0016" level="1">XII. Example Method of Performing RDMA Operation Using a Transaction Identifier</heading><p id="p-0088" num="0086"><figref idref="DRAWINGS">FIG. <b>11</b></figref> is a flowchart <b>1100</b> outlining an example method of performing accelerated RDMA operations for RDMA packets encoded in an arbitrary RDMA protocol using a transaction identifier. For example, the system described above regarding <figref idref="DRAWINGS">FIG. <b>5</b></figref> can be used to perform the method of <figref idref="DRAWINGS">FIG. <b>11</b></figref>.</p><p id="p-0089" num="0087">At process block <b>1110</b>, a protocol index is derived for identifying the RDMA protocol encoded with the RDMA packets. For example, techniques discussed above regarding <figref idref="DRAWINGS">FIG. <b>2</b></figref> can be used to generate the protocol index, which identifies a specific RDMA protocol that was used to identify received RDMA packets.</p><p id="p-0090" num="0088">At process block <b>1120</b>, the specific RDMA information in the RDMA packet is extracted and converted to generic RDMA fields, commands, and/or control information used to process the RDMA protocol.</p><p id="p-0091" num="0089">At process block <b>1130</b>, the transaction identifier is generated based on the protocol index derived at process block <b>1110</b> and/or the generic fields, commands, and control information generated at process block <b>1120</b>. Thus, a transaction identifier encoded in any arbitrary RDMA packet format according to its corresponding RDMA protocol can be generated.</p><p id="p-0092" num="0090">At process block <b>1140</b>, an accelerated RDMA operation is performed based on data accessed using the transaction identifier generated at process block <b>1130</b>. For example, an RDMA controller can include a memory that stores values and parameters associated with a number of currently active transactions. Such information can include a current or next memory address with which to read or write memory for performing the RDMA operation. The memory can also store information that is used to validate the RDMA operation. Thus, by using the transaction identifier to look up data in a memory coupled to an RDMA controller, the host machine supporting the RDMA transaction, including its processor, can be bypassed. The RDMA controller can perform the specified RDMA operations by directly reading or writing to the memory, without use of the host or software such as the operating system executing on the host.</p><p id="p-0093" num="0091">In some examples, RDMA acceleration methods can also use header splits, in which case the payload of the packet is written to a buffer using DDP, and the header of the packet is written to a different buffer to be used by the RDMA controller and/or software for additional packet processing. Header splits can be enabled based on the detected protocol index and command.</p><p id="p-0094" num="0092">The size of the header can be calculated using the generic ALU and parsed RDMA information (e.g., L3/4 header offset, L3/4 header length, or, RDMA header length) and using fields from the protocol table, control table, or the connection/transaction table to determine different behavior per protocol/command/transaction.</p><p id="p-0095" num="0093">Another possible output of RDMA acceleration is information for data trimming. In some protocols the packet payload includes additional fields such as integrity check fields or protection fields (e.g., additional CRC information). In these cases, these fields can be verified by the acceleration engine and can also be trimmed, and not to be written with the data in the direct data placement operation. Trimming enable and trim length can be configured on a per-protocol and/or per-command using control tables.</p><p id="p-0096" num="0094">At the end of the RDMA packet processing the RDMA controller can enable a DMA engine to write the header and the data to the selected location.</p><p id="p-0097" num="0095">In some examples, RDMA parsing information and results generated by the RDMA controller can be forwarded to the host through completion information or a dedicated buffer. This information can be used to terminate RDMA transactions or commands and complete the RDMA operations. Additional information can be forwarded to the host to offload software operations (e.g., the selected connection/transaction identifier, sequence number state, etc.).</p><heading id="h-0017" level="1">XIII. Example Method of DDP Operations for RDMA Transactions</heading><p id="p-0098" num="0096"><figref idref="DRAWINGS">FIG. <b>12</b></figref> is a flowchart <b>1200</b> outlining an example method of performing direct data placement (DDP) operations for RDMA transactions, as can be performed in some examples of the disclosed technology. For example, the system outlined in <figref idref="DRAWINGS">FIG. <b>7</b></figref> can be used to perform the illustrated method.</p><p id="p-0099" num="0097">At process block <b>1210</b>, a protocol index is derived identifying RDMA protocol encoding a number of received RDMA packets. For example, the received packet is partially decoded in order to determine the protocol with which the packet was encoded.</p><p id="p-0100" num="0098">At process block <b>1220</b>, an address to be used for direct data placement is generated. For example, the address can be generated by extracting fields from an RDMA header, by using address translation information, by using and address from a transaction database accessed using a transaction identifier for the RDMA packet or an address stored in a control table. The generated address can be signaled to an address generation circuit for generating a DDP address.</p><p id="p-0101" num="0099">At process block <b>1230</b>, an address is generated for a DDP. For example, depending on whether the address is for a physical address, an indirect physical address, or a virtual memory address, the address can be generated. For example, the physical address associated with a virtual memory address specified in the RDMA packet can be generated for performing RDMA operations. The generated DDP address can be sent to a direct memory access (DMA) controller for performing the specified operations. For example, a number of bytes of data can be sent to a DMA controller for performing direct data placement to main memory of the system hosting the RDMA controller.</p><p id="p-0102" num="0100">At process block <b>1240</b>, an address for reading or writing next packets for the RDMA transaction can be created and stored for use with consecutive next packets of the RDMA transaction. For example, if the current packet reads or writes to a certain number of memory addresses, the next address can be generated as the following address to be written to in the memory block. In some examples, more complicated operations such as scatter/gather can be used to address non-consecutive memory locations. In other examples, the memory locations are consecutive and the next address is generated by adding or subtracting the size of the currently processed packet from the current address.</p><heading id="h-0018" level="1">XIV. Example Method of Validating RDMA Packets</heading><p id="p-0103" num="0101"><figref idref="DRAWINGS">FIG. <b>13</b></figref> is a flowchart <b>1300</b> outlining an example method of validating RDMA packets as can be performed in certain examples of the disclosed technology. For example, the system described above regarding <figref idref="DRAWINGS">FIG. <b>6</b></figref> can be used to perform some forms of validation according to the method of <figref idref="DRAWINGS">FIG. <b>13</b></figref>.</p><p id="p-0104" num="0102">At process block <b>1310</b>, a protocol index is derived for identifying an RDMA protocol in which received RDMA packets are encoded.</p><p id="p-0105" num="0103">At process block <b>1320</b>, fields are extracted from the RDMA header based on the protocol index. The protocol index, thus, can be used to identify the correct fields to be extracted for performing the validation.</p><p id="p-0106" num="0104">At process block <b>1330</b>, the extracted fields are compared to configurable fields stored in a control table or a connection table, or a transaction table for use in comparing. For example, the address, sequence number, stride length, data size, and/or other fields can be compared to data in the storage control table. If an unexpected value is found during the comparison, an exception can be raised. For example, if the packet sequence number does not match an expected value, then an exception is raised so that appropriate action (e.g., aborting the transaction or initiating error recovery) can be taken.</p><p id="p-0107" num="0105">At process block <b>1340</b>, the RDMA packet is validated based on the compare result from process block <b>1330</b>. In some examples, certain fields can be compared using a reconfigurable ALU to validate RDMA packets. In some examples, if the packet is validated as being correct, the RDMA controller hosting the RDMA transaction will continue to process RDMA packets. In some examples, if the RDMA packet is not validated, then the RDMA controller can raise an exception or otherwise notify the host system that the packet was not validated. Thus, the host can perform error recovery and processing in order to complete or otherwise respond to the requested RDMA operation. For example, the RDMA controller may only be configured to handle successful, validated RDMA packets, but lack error processing and other exceptional features that are supported by an operating system executing on the host.</p><p id="p-0108" num="0106">A process block <b>1350</b>, a field value generated from the field extraction unit is modified using a reconfigurable ALU to generate new values for validating the current or next packet of a transaction. Thus, complex validation operations can be performed while still allowing the flexibility that a reconfigurable circuit allows. In some examples, a packet size, memory address, or other information predicted for the next packet of the RDMA transaction can be stored and later verified when the packet is actually received. Other information such as check sums or hashes can be used to authenticate the validity of data received in the RDMA packet.</p><heading id="h-0019" level="1">XV. Example Compute Service Provider</heading><p id="p-0109" num="0107">Web services are commonly used in cloud computing. A web service is a software function provided at a network address over the web or the cloud. Clients initiate web service requests to servers and servers process the requests and return appropriate responses. The client web service requests are typically initiated using, for example, an API request. For purposes of simplicity, web service requests will be generally described below as API requests, but it is understood that other web service requests can be made. An API request is a programmatic interface to a defined request-response message system, typically expressed in JSON or XML, which is exposed via the web&#x2014;most commonly by means of an HTTP-based web server. Thus, in certain implementations, an API can be defined as a set of Hypertext Transfer Protocol (HTTP) request messages, along with a definition of the structure of response messages, which can be in an Extensible Markup Language (XML) or JavaScript Object Notation (JSON) format. The API can specify a set of functions or routines that perform an action, which includes accomplishing a specific task or allowing interaction with a software component. When a web service receives the API request from a client device, the web service can generate a response to the request and send the response to the endpoint identified in the request.</p><p id="p-0110" num="0108">Generally speaking, a &#x201c;plug-in&#x201d; includes, but is not limited to, a software component that plugs into a larger application to add functionality. When an application supports plug-ins, it can, for example, enable customization without recompilation. Additionally, in some instances, plug-ins can reduce the need for redeployment of the larger application, as functionality can be added through the plug-ins without modifying or redeploying the application itself. The common examples are the plug-ins used in web browsers to add new features such as search-engines, virus scanners, or the ability to utilize a new file type, such as a new video format.</p><p id="p-0111" num="0109">The network may include public networks, private networks, or a combination thereof. The network may include, but are not limited to personal area networks (PANs), local area networks (LANs), wide area networks (WANs), and so forth. The networks (e.g., network <b>190</b>) can communicate using Ethernet, Wi-Fi&#x2122;, Bluetooth&#xae;, ZigBee&#xae;, 3G, 4G, or other technologies.</p><p id="p-0112" num="0110"><figref idref="DRAWINGS">FIG. <b>14</b></figref> is a computing system diagram of a network-based compute service provider <b>1400</b> that illustrates one environment in which embodiments described herein can be used. For example, the network-based compute service provider <b>1400</b> can provide services based at least in part on using RDMA transactions to transfer data between two or more physical or virtual hosts. By way of background, the compute service provider <b>1400</b> (e.g., a cloud provider) is capable of delivery of computing and storage capacity as a service to a community of end recipients. In an example embodiment, the compute service provider can be established for an organization by or on behalf of the organization. That is, the compute service provider <b>1400</b> may offer a &#x201c;private cloud environment.&#x201d; In another embodiment, the compute service provider <b>1400</b> supports a multi-tenant environment, wherein a plurality of customers operate independently (e.g., a public cloud environment). Generally speaking, the compute service provider <b>1400</b> can provide the following models: Infrastructure as a Service (&#x201c;IaaS&#x201d;), Platform as a Service (&#x201c;PaaS&#x201d;), and/or Software as a Service (&#x201c;SaaS&#x201d;). Other models can be provided. For the IaaS model, the compute service provider <b>1400</b> can offer computers as physical or virtual machines and other resources. The virtual machines can be run as guests by a hypervisor, as described further below. The PaaS model delivers a computing platform that can include an operating system, programming language execution environment, database, and web server. Application developers can develop and run their software solutions on the compute service provider platform without the cost of buying and managing the underlying hardware and software. The SaaS model allows installation and operation of application software in the compute service provider. In some embodiments, end users access the compute service provider <b>1400</b> using networked client devices, such as desktop computers, laptops, tablets, smartphones, etc. running web browsers or other lightweight client applications. Those skilled in the art will recognize that the compute service provider <b>1400</b> can be described as a &#x201c;cloud&#x201d; environment.</p><p id="p-0113" num="0111">The particular illustrated compute service provider <b>1400</b> includes a plurality of server computers <b>1402</b>A-<b>1402</b>D. While only four server computers are shown, any number can be used, and large centers can include thousands of server computers. The server computers <b>1402</b>A-<b>1402</b>D can provide computing resources for executing software instances <b>1406</b>A-<b>1406</b>D. In one embodiment, the instances <b>1406</b>A-<b>1406</b>D are virtual machines. As known in the art, a virtual machine is an instance of a software implementation of a machine (e.g., a computer) that executes applications like a physical machine. In the example of virtual machine, each of the servers <b>1402</b>A-<b>1402</b>D can be configured to execute a hypervisor <b>1408</b> or another type of program configured to enable the execution of multiple instances <b>1406</b> on a single server. Additionally, each of the instances <b>1406</b> can be configured to execute one or more applications, including applications that perform RDMA transactions with the use of an RDMA controller <b>1409</b>.</p><p id="p-0114" num="0112">It should be appreciated that although the embodiments disclosed herein are described primarily in the context of virtual machines, other types of instances can be utilized with the concepts and technologies disclosed herein. For instance, the technologies disclosed herein can be utilized with storage resources, data communications resources, and with other types of computing resources. The embodiments disclosed herein might also execute all or a portion of an application directly on a computer system without utilizing virtual machine instances.</p><p id="p-0115" num="0113">One or more server computers <b>1404</b> can be reserved for executing software components for managing the operation of the server computers <b>1402</b> and the instances <b>1406</b>. For example, the server computer <b>1404</b> can execute a management component <b>1410</b>. A customer can access the management component <b>1410</b> to configure various aspects of the operation of the instances <b>1406</b> purchased by the customer. For example, the customer can purchase, rent or lease instances and make changes to the configuration of the instances. The customer can also specify settings regarding how the purchased instances are to be scaled in response to demand. The management component can further include a policy document to implement customer policies. An auto scaling component <b>1412</b> can scale the instances <b>1406</b> based upon rules defined by the customer. In one embodiment, the auto scaling component <b>1412</b> allows a customer to specify scale-up rules for use in determining when new instances should be instantiated and scale-down rules for use in determining when existing instances should be terminated. The auto scaling component <b>1412</b> can consist of a number of subcomponents executing on different server computers <b>1402</b> or other computing devices. The auto scaling component <b>1412</b> can monitor available computing resources over an internal management network and modify resources available based on need.</p><p id="p-0116" num="0114">A deployment component <b>1414</b> can be used to assist customers in the deployment of new instances <b>1406</b> of computing resources. The deployment component can have access to account information associated with the instances, such as who is the owner of the account, credit card information, country of the owner, etc. The deployment component <b>1414</b> can receive a configuration from a customer that includes data describing how new instances <b>1406</b> should be configured. For example, the configuration can specify one or more applications to be installed in new instances <b>1406</b>, provide scripts and/or other types of code to be executed for configuring new instances <b>1406</b>, provide cache logic specifying how an application cache should be prepared, and other types of information. The deployment component <b>1414</b> can utilize the customer-provided configuration and cache logic to configure, prime, and launch new instances <b>1406</b>. The configuration, cache logic, and other information may be specified by a customer using the management component <b>1410</b> or by providing this information directly to the deployment component <b>1414</b>. The instance manager can be considered part of the deployment component.</p><p id="p-0117" num="0115">Customer account information <b>1415</b> can include any desired information associated with a customer of the multi-tenant environment. For example, the customer account information can include a unique identifier for a customer, a customer address, billing information, licensing information, customization parameters for launching instances, scheduling information, auto-scaling parameters, previous IP addresses used to access the account, etc.</p><p id="p-0118" num="0116">A network <b>1430</b> can be utilized to interconnect the server computers <b>1402</b>A-<b>702</b>D and the server computer <b>1404</b>. The network <b>1430</b> can be a local area network (LAN) and can be connected to a Wide Area Network (WAN) <b>1440</b> so that end users can access the compute service provider <b>1400</b>. Data for initiating and performing RDMA transactions described herein can be transferred by the network between any of the server computers <b>1402</b>A-<b>1402</b>D, the server computer <b>1404</b>, and/or server computers accessed via the WAN <b>1440</b>. It should be appreciated that the network topology illustrated in <figref idref="DRAWINGS">FIG. <b>14</b></figref> has been simplified and that many more networks and networking devices can be utilized to interconnect the various computing systems disclosed herein.</p><heading id="h-0020" level="1">XVI. Example Compute Service Provider Management Components</heading><p id="p-0119" num="0117"><figref idref="DRAWINGS">FIG. <b>15</b></figref> illustrates in further detail management components <b>1506</b> that can be used in a multi-tenant environment <b>1500</b> of the compute service provider <b>1400</b>. In order to access and utilize instances (such as instances <b>1406</b> of <figref idref="DRAWINGS">FIG. <b>14</b></figref>), a client device can be used. The client device <b>1510</b> can be any of a variety of computing devices, mobile or otherwise including a cell phone, smartphone, handheld computer, Personal Digital Assistant (PDA), desktop computer, etc. The client device <b>1510</b> can communicate with the compute service provider <b>1300</b> through an end point <b>1512</b>, which can be a DNS address designed to receive and process API requests. In particular, the end point <b>1512</b> can be a web server configured to expose an API. Using the API requests, a client <b>1510</b> can make requests to implement any of the functionality described herein. Other services <b>1515</b>, which can be internal to the compute service provider <b>1300</b>, can likewise make API requests to the end point <b>1512</b>.</p><p id="p-0120" num="0118">Other general management services that may or may not be included in the compute service provider <b>1400</b> include an admission control <b>1514</b>, e.g., one or more computers operating together as an admission control web service. The admission control <b>1514</b> can authenticate, validate, and unpack the API requests for service or storage of data within the compute service provider <b>1400</b>. The capacity tracker <b>1516</b> is responsible for determining how the servers need to be configured in order to meet the need for the different instance types by managing and configuring physical inventory in terms of forecasting, provisioning and real-time configuration and allocation of capacity. The capacity tracker <b>1516</b> maintains a pool of available inventory in a capacity pool database <b>1518</b>. The capacity tracker <b>1516</b> can also monitor capacity levels so as to know whether resources are readily available or limited. An instance manager <b>1550</b> controls launching and termination of instances in the network. When an instruction is received (such as through an API request) to launch an instance, the instance manager pulls resources from the capacity pool <b>1518</b> and launches the instance on a decided upon host server computer. Similar to the instance manager are the storage manager <b>1522</b> and the network resource manager <b>1524</b>. The storage manager <b>1522</b> relates to initiation and termination of storage volumes, while the network resource manager <b>1524</b> relates to initiation and termination of routers, switches, subnets, etc. Data can be communicated using RDMA transactions to send data between any of computers depicted in <figref idref="DRAWINGS">FIG. <b>13</b></figref>, including the client device <b>1510</b>, the network resource manager <b>1524</b>, and the network of partitions <b>1540</b>. A network of partitions <b>1540</b> is described further in relation to <figref idref="DRAWINGS">FIG. <b>9</b></figref> and includes a physical layer upon which the instances are launched.</p><p id="p-0121" num="0119">A health monitoring service <b>1560</b> can provide monitoring for resources and the applications customers run on the compute service provider <b>1400</b>. System administrators can use the monitoring service <b>1560</b> to collect and track metrics, and gain insight to how applications are running. For example, the monitoring service <b>1560</b> can allow system-wide visibility into application performance and operational health. Metrics generated by the health monitoring service <b>1560</b> can be stored in the metrics database <b>1562</b>.</p><heading id="h-0021" level="1">XVII. Example Partitions and Associated Hardware</heading><p id="p-0122" num="0120"><figref idref="DRAWINGS">FIG. <b>16</b></figref> illustrates a network of partitions <b>1640</b> and the physical hardware associated therewith. The network of partitions <b>1640</b> can include a plurality of data centers, such as data center <b>1610</b>, coupled together by routers <b>1616</b>. The routers <b>1616</b> read address information in a received packet and determine the packet's destination. If the router decides that a different data center contains a host server computer, then the packet is forwarded to that data center. If the packet is addressed to a host in the data center <b>1610</b>, then it is passed to a network address translator (NAT) <b>1618</b> that converts the packet's public IP address to a private IP address. The NAT also translates private addresses to public addresses that are bound outside of the datacenter <b>1610</b>. Additional routers <b>1620</b> can be coupled to the NAT to route packets to one or more racks of host server computers <b>1630</b>. Each rack <b>1630</b> can include a switch <b>1632</b> coupled to multiple host server computers. A particular host server computer is shown in an expanded view at <b>1635</b>.</p><p id="p-0123" num="0121">Each host <b>1640</b> has underlying hardware <b>1650</b> including one or more CPUs, memory, storage devices, etc. The hardware <b>1650</b> can include one or more RDMA controllers <b>1655</b> for acceleration of RDMA transactions between partitions on the same server or between partitions residing on different servers. Running a layer above the hardware <b>1650</b> is a hypervisor or kernel layer <b>1660</b>. The hypervisor or kernel layer can be classified as a type 1 or type 2 hypervisor. A type 1 hypervisor runs directly on the host hardware <b>1650</b> to control the hardware and to manage the guest operating systems. A type 2 hypervisor runs within a conventional operating system environment. Thus, in a type 2 environment, the hypervisor can be a distinct layer running above the operating system and the operating system interacts with the system hardware. Different types of hypervisors include Xen-based, Hyper-V, ESXi/ESX, Linux, etc., but other hypervisors can be used. A management layer <b>1670</b> can be part of the hypervisor or separated therefrom and generally includes device drivers needed for accessing the hardware <b>1650</b>. The partitions <b>1680</b> are logical units of isolation by the hypervisor. Each partition <b>1680</b> can be allocated its own portion of the hardware layer's memory, CPU allocation, storage, etc. Further, any of the partitions can initiate and perform RDMA transactions using the technologies described herein. For examples, the partitions can act as target and/or source hosts and use one or more RDMA controllers in the hardware <b>1650</b> to accelerate RDMA transactions using transaction identifiers and local memory. Additionally, each partition can include a virtual machine and its own guest operating system. As such, each partition is an abstract portion of capacity designed to support its own virtual machine independent of the other partitions.</p><p id="p-0124" num="0122">Any applications executing on the instances can be monitored using the management layer <b>1670</b>, which can then pass the metrics to the health monitoring service <b>1460</b> for storage in the metrics database <b>1562</b>. Additionally, the management layer <b>1670</b> can pass to the monitoring service <b>1560</b> the number of instances that are running, when they were launched, the operating system being used, the applications being run, etc. All such metrics can be used for consumption by the health monitoring service <b>1560</b> and stored in database <b>1562</b>.</p><heading id="h-0022" level="1">XVIII. Example Computing Environment</heading><p id="p-0125" num="0123"><figref idref="DRAWINGS">FIG. <b>17</b></figref> depicts a generalized example of a suitable computing environment <b>1700</b> in which the described innovations may be implemented. The computing environment <b>1700</b> is not intended to suggest any limitation as to scope of use or functionality, as the innovations may be implemented in diverse general-purpose or special-purpose computing systems. For example, the computing environment <b>1700</b> can be any of a variety of computing devices (e.g., desktop computer, laptop computer, server computer, tablet computer, etc.)</p><p id="p-0126" num="0124">With reference to <figref idref="DRAWINGS">FIG. <b>17</b></figref>, the computing environment <b>1700</b> includes one or more processing units <b>1710</b>, <b>1715</b> and memory <b>1720</b>, <b>1725</b>. In <figref idref="DRAWINGS">FIG. <b>17</b></figref>, this basic configuration <b>1730</b> is included within a dashed line. The processing units <b>1710</b>, <b>1715</b> execute computer-executable instructions, including instructions for implementing host operations for RDMA transactions. A processing unit can be a general-purpose central processing unit (CPU), processor in an application-specific integrated circuit (ASIC) or any other type of processor. In a multi-processing system, multiple processing units execute computer-executable instructions to increase processing power. For example, <figref idref="DRAWINGS">FIG. <b>17</b></figref> shows a central processing unit <b>1710</b> as well as a graphics processing unit or co-processing unit <b>1715</b>. The tangible memory <b>1720</b>, <b>1725</b> may be volatile memory (e.g., registers, cache, RAM), non-volatile memory (e.g., ROM, EEPROM, flash memory, etc.), or some combination of the two, accessible by the processing unit(s). The memory <b>1720</b>, <b>1725</b> stores software <b>1780</b> implementing one or more innovations described herein, in the form of computer-executable instructions suitable for execution by the processing unit(s).</p><p id="p-0127" num="0125">A computing system may have additional features. For example, the computing environment <b>1700</b> includes storage <b>1740</b>, one or more input devices <b>1750</b>, one or more output devices <b>1760</b>, and one or more communication connections <b>1770</b>. An interconnection mechanism (not shown) such as a bus, controller, or network interconnects the components of the computing environment <b>1700</b>. Typically, operating system software (not shown) provides an operating environment for other software executing in the computing environment <b>1700</b>, and coordinates activities of the components of the computing environment <b>1700</b>.</p><p id="p-0128" num="0126">The tangible storage <b>1740</b> may be removable or non-removable, and includes magnetic disks, magnetic tapes or cassettes, CD-ROMs, DVDs, or any other medium which can be used to store information in a non-transitory way and which can be accessed within the computing environment <b>1700</b>. The storage <b>1740</b> stores instructions for the software <b>1780</b> implementing one or more innovations described herein.</p><p id="p-0129" num="0127">The input device(s) <b>1750</b> may be a touch input device such as a keyboard, mouse, pen, or trackball, a voice input device, a scanning device, or another device that provides input to the computing environment <b>1700</b>. The output device(s) <b>1760</b> may be a display, printer, speaker, CD-writer, or another device that provides output from the computing environment <b>1700</b>.</p><p id="p-0130" num="0128">The communication connection(s) <b>1770</b> enable communication over a communication medium to another computing entity. The communication medium conveys information such as computer-executable instructions, audio or video input or output, or other data in a modulated data signal. RDMA transactions can be accelerated using an RDMA controller coupled to the communications connections(s) <b>1770</b>. A modulated data signal is a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media can use an electrical, optical, RF, or other carrier.</p><p id="p-0131" num="0129">Although the operations of some of the disclosed methods are described in a particular, sequential order for convenient presentation, it should be understood that this manner of description encompasses rearrangement, unless a particular ordering is required by specific language set forth below. For example, operations described sequentially may in some cases be rearranged or performed concurrently. Moreover, for the sake of simplicity, the attached figures may not show the various ways in which the disclosed methods can be used in conjunction with other methods.</p><p id="p-0132" num="0130">Any of the disclosed methods can be implemented as computer-executable instructions stored on one or more computer-readable storage media (e.g., one or more optical media discs, volatile memory components (such as DRAM or SRAM), or non-volatile memory components (such as flash memory or hard drives)) and executed on a computer (e.g., any commercially available computer, including smart phones or other mobile devices that include computing hardware). The term computer-readable storage media does not include communication connections, such as signals and carrier waves. Any of the computer-executable instructions for implementing the disclosed techniques as well as any data created and used during implementation of the disclosed embodiments can be stored on one or more computer-readable storage media. The computer-executable instructions can be part of, for example, a dedicated software application or a software application that is accessed or downloaded via a web browser or other software application (such as a remote computing application). Such software can be executed, for example, on a single local computer (e.g., any suitable commercially available computer) or in a network environment (e.g., via the Internet, a wide-area network, a local-area network, a client-server network (such as a cloud computing network), or other such network) using one or more network computers.</p><p id="p-0133" num="0131">For clarity, only certain selected aspects of the software-based implementations are described. Other details that are well known in the art are omitted. For example, it should be understood that the disclosed technology is not limited to any specific computer language or program. For instance, the disclosed technology can be implemented by software written in C++, Java, Perl, assembly code, or any other suitable programming language. Likewise, the disclosed technology is not limited to any particular computer or type of hardware. Certain details of suitable computers and hardware are well known and need not be set forth in detail in this disclosure.</p><p id="p-0134" num="0132">It should also be well understood that any functionality described herein can be performed, at least in part, by one or more hardware logic components, instead of software. For example, and without limitation, illustrative types of hardware logic components that can be used include Field-programmable Gate Arrays (FPGAs), Program-specific Integrated Circuits (ASICs), Program-specific Standard Products (ASSPs), System-on-a-chip systems (SOCs), Complex Programmable Logic Devices (CPLDs), etc.</p><p id="p-0135" num="0133">Furthermore, any of the software-based embodiments (comprising, for example, computer-executable instructions for causing a computer to perform any of the disclosed methods) can be uploaded, downloaded, or remotely accessed through a suitable communication means. Such suitable communication means include, for example, the Internet, the World Wide Web, an intranet, software applications, cable (including fiber optic cable), magnetic communications, electromagnetic communications (including RF, microwave, and infrared communications), electronic communications, or other such communication means.</p><p id="p-0136" num="0134">The disclosed methods, apparatus, and systems should not be construed as limiting in any way. Instead, the present disclosure is directed toward all novel and nonobvious features and aspects of the various disclosed embodiments, alone and in various combinations and subcombinations with one another. The disclosed methods, apparatus, and systems are not limited to any specific aspect or feature or combination thereof, nor do the disclosed embodiments require that any one or more specific advantages be present or problems be solved.</p><p id="p-0137" num="0135">In view of the many possible embodiments to which the principles of the disclosed technology may be applied, it should be recognized that the illustrated embodiments are only examples and should not be taken as limiting the scope of the claimed subject matter. Rather, the scope of the invention is defined by the following claims. We therefore claim as our invention all that comes within the scope of these claims.</p><?detailed-description description="Detailed Description" end="tail"?></description><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. An apparatus for processing remote direct memory access (RDMA) packets encoded in one of a plurality of RDMA protocols, the apparatus comprising:<claim-text>a host coupled to memory;</claim-text><claim-text>a network adapter configured to transmit and receive RDMA packets via a network connection; and</claim-text><claim-text>an RDMA controller coupled to the memory and the network adapter, the controller configured to:<claim-text>produce a protocol index for the received RDMA packets, the protocol index indicating an RDMA protocol in which the received RDMA packets are encoded,</claim-text><claim-text>based on reading a memory using the protocol index, produce field extraction control information for extracting fields from a header of one of the received RDMA packets, and</claim-text><claim-text>based on the produced field extraction control information, performing a generic RDMA operation with the memory based on the control information.</claim-text></claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The apparatus of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the RDMA controller further comprises:<claim-text>a control table configured to, responsive to receiving data based on the extracted header fields, produce command processing control information for performing the generic RDMA operation.</claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The apparatus of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the data based on the extracted header fields is generated from a header field indexed by an offset and a size.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The apparatus of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>a protocol table configured to produce the field extraction control information responsive to a lookup based on the protocol index;</claim-text><claim-text>a field extraction circuit configured to produce command field translation data for accessing a control table;</claim-text><claim-text>the control table, the control table being configured to produce the field extraction control information; and</claim-text><claim-text>a reconfigurable field extraction unit configured to, responsive to receiving the field extraction control information, extract the fields from the received RDMA packets, the fields being used for the performing the generic RDMA operation.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The apparatus of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the RDMA controller is further configured to extract a transaction identifier from the received RDMA packets by performing one of the following:<claim-text>extracting a transaction identifier directly from a header of the RDMA packets, looking up a transaction identifier in a table indexed by an extracted field of the RDMA header, or looking up a transaction identifier in a content-addressable memory (CAM); and</claim-text><claim-text>if the extracted transaction identifier matches a transaction identifier stored in an active transaction database, then accelerating the generic RDMA operation by bypassing the host to perform the generic RDMA operation.</claim-text></claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. An apparatus configured to process transactions for two or more remote direct memory access (RDMA) protocols, the apparatus comprising:<claim-text>a network interface configured to receive an RDMA packet via a computer network;</claim-text><claim-text>a translation memory configured to generate control information based on data received in a field of the RDMA packet, the generated control information being used to determine a generic RDMA command; and</claim-text><claim-text>a processing circuit configured to perform an RDMA operation based on data in the RDMA packet and the generic RDMA command.</claim-text></claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The apparatus of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the processing circuit is further configured to validate the RDMA operation by comparing context data stored in a transactional database to data in the received RDMA packet.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The apparatus of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the control information is generated by a table lookup performed with a protocol index indicating an RDMA protocol in which the received RDMA packet is encoded.</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The apparatus of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the control information is generated by a table lookup performed with a field extracted from the RDMA packet.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The apparatus of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the processing circuit is further configured to determine a target location in a main memory for the RDMA operation.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The apparatus of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the processing circuit comprises a plurality of multiplexers configured to generate an offset value and a size value for extracting the field from the RDMA packet.</claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The apparatus of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the processing circuit comprises a plurality of arithmetic and logic units (ALUs), the ALUs being configured to select data from the RDMA packet based on a field extracted from the RDMA packet.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The apparatus of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the processing circuit comprises a Field-programmable Gate Array (FPGAs), a Program-specific Integrated Circuits (ASICs), a Program-specific Standard Products (ASSPs), a System-on-a-chip system (SOCs), and/or a Complex Programmable Logic Device (CPLDs).</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The apparatus of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the apparatus is configured to perform RDMA transactions encoded in at least two of the RDMA protocols concurrently.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. A method comprising:<claim-text>receiving remote direct memory access (RDMA) packets via a network adapter;</claim-text><claim-text>deriving a protocol index identifying an RDMA protocol used to encode data for an RDMA transaction associated with the RDMA packets;</claim-text><claim-text>applying the protocol index to generate RDMA commands from header information in one of the received RDMA packets; and</claim-text><claim-text>performing an RDMA operation using the RDMA commands.</claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The method of <claim-ref idref="CLM-00015">claim 15</claim-ref>, further comprising extracting field data from the RDMA packets using the RDMA commands, the extracted field data being used to provide parameters for the performing the RDMA operation.</claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The method of <claim-ref idref="CLM-00015">claim 15</claim-ref>, further comprising generating command fields for the RDMA commands by accessing a command field translation table with the protocol index.</claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The method of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the performing the RDMA operation comprises a direct memory access that copies data from the RDMA packets to host memory without using a host processor.</claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The method of <claim-ref idref="CLM-00015">claim 15</claim-ref>, further comprising comparing data encoded in a field of the RDMA packets to data stored in a transaction identifier table to validate the RDMA operation.</claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The method of <claim-ref idref="CLM-00015">claim 15</claim-ref>, further comprising determining a transaction identifier for the RDMA operation based on a table lookup performed using the protocol index and the RDMA commands; and<claim-text>based on the transaction identifier, accelerating the RDMA operations by bypassing a host performing the RDMA transaction.</claim-text></claim-text></claim><claim id="CLM-21-34" num="21-34"><claim-text><b>21</b>-<b>34</b>. (canceled)</claim-text></claim></claims></us-patent-application>