<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004420A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004420</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17942558</doc-number><date>20220912</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>455</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>45558</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>2009</main-group><subgroup>45562</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>2009</main-group><subgroup>45583</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>2009</main-group><subgroup>45587</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>2009</main-group><subgroup>45579</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">Virtual Machine Register in a Computer Processor</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>16520310</doc-number><date>20190723</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11481241</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17942558</doc-number></document-id></child-doc></relation></continuation><us-provisional-application><document-id><country>US</country><doc-number>62725118</doc-number><date>20180830</date></document-id></us-provisional-application><us-provisional-application><document-id><country>US</country><doc-number>62724896</doc-number><date>20180830</date></document-id></us-provisional-application><us-provisional-application><document-id><country>US</country><doc-number>62724913</doc-number><date>20180830</date></document-id></us-provisional-application><us-provisional-application><document-id><country>US</country><doc-number>62724929</doc-number><date>20180830</date></document-id></us-provisional-application><us-provisional-application><document-id><country>US</country><doc-number>62724999</doc-number><date>20180830</date></document-id></us-provisional-application><us-provisional-application><document-id><country>US</country><doc-number>62725030</doc-number><date>20180830</date></document-id></us-provisional-application></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Micron Technology, Inc.</orgname><address><city>Boise</city><state>ID</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Wallach</last-name><first-name>Steven Jeffrey</first-name><address><city>Dallas</city><state>TX</state><country>US</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">Systems, apparatuses, and methods related to a virtual machine register in a computer processor are described. For example, a memory coupled to the computer processor can store instructions of routines of predefined, non-hierarchical domains. The computer processor can store, in the virtual machine register, an identifier of a virtual machine for which the processor is currently executing instructions in a current domain in the set of domains. For example, the processor can implement resource restriction/mapping and/or perform address translation for the virtual machine based on the identifier stored in the virtual machine register.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="155.79mm" wi="158.75mm" file="US20230004420A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="194.99mm" wi="172.13mm" file="US20230004420A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="158.50mm" wi="140.38mm" file="US20230004420A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="194.99mm" wi="140.38mm" file="US20230004420A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="206.08mm" wi="143.59mm" file="US20230004420A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="202.95mm" wi="159.43mm" file="US20230004420A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="196.60mm" wi="157.82mm" file="US20230004420A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="191.18mm" wi="116.92mm" file="US20230004420A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="213.44mm" wi="136.06mm" file="US20230004420A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="193.38mm" wi="118.19mm" file="US20230004420A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">RELATED APPLICATIONS</heading><p id="p-0002" num="0001">The present application is a continuation application of U.S. patent application Ser. No. 16/520,310 filed Jul. 23, 2019, which claims priority to Prov. U.S. Pat. App. Ser. No. 62/725,118 filed Aug. 30, 2018, where U.S. patent application Ser. No. 16/520,310 claims priority to Prov. U.S. Pat. App. Ser. No. 62/724,896 filed Aug. 30, 2018, where U.S. patent application Ser. No. 16/520,310 claims priority to Prov. U.S. Pat. App. Ser. No. 62/724,913 filed Aug. 30, 2018, where U.S. patent application Ser. No. 16/520,310 claims priority to Prov. U.S. Pat. App. Ser. No. 62/724,929 filed Aug. 30, 2018, where U.S. patent application Ser. No. 16/520,310 claims priority to Prov. U.S. Pat. App. Ser. No. 62/724,999 filed Aug. 30, 2018, where U.S. patent application Ser. No. 16/520,310 claims priority to Prov. U.S. Pat. App. Ser. No. 62/725,030 filed Aug. 30, 2018, the entire disclosures of which applications are hereby incorporated herein by reference.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">TECHNICAL FIELD</heading><p id="p-0003" num="0002">At least some embodiments disclosed herein relate generally to computer architecture and more specifically, but not limited to, a virtual machine register in a computer processor.</p><heading id="h-0003" level="1">BACKGROUND</heading><p id="p-0004" num="0003">Instructions programmed for a computer can be structured in layers. Once layer can provide resources and services for another layer. For example, a hypervisor can create or provision virtual machines that are implemented on the hardware components of the computer. An operating system can offer resources and services using resources available in a computer having predefined architecture. The computer resources or computer operated upon by the operating system can be actual computer hardware components, or virtual machine components provisioned by a hypervisor. An application can provide application specific functions using the services and resources provided by an operating system.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0005" num="0004">The embodiments are illustrated by way of example and not limitation in the figures of the accompanying drawings in which like references indicate similar elements.</p><p id="p-0006" num="0005"><figref idref="DRAWINGS">FIG. <b>1</b></figref> shows a computer processor having a set of registers configured to control the operations of the computer processor according to some embodiments.</p><p id="p-0007" num="0006"><figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates the identification of a table base of an address translation table in absence of an operating hypervisor in some embodiments.</p><p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates the identification of a table base of an address translation table in the presence of an operating hypervisor in some embodiments.</p><p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. <b>4</b></figref> illustrates separate address translation tables for respective domains.</p><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. <b>5</b></figref> shows a technique to retrieve an entry from an address translation table to convert a virtual address.</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. <b>6</b></figref> shows a system to control security operations applied to resources in accordance with a domain register.</p><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>7</b></figref> illustrates a page table entry having a security configuration for execution domains.</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. <b>8</b></figref> shows a computer system having a domain register controlling security operations.</p><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. <b>9</b></figref> shows a method to perform address translation for a virtual machine in accordance with a virtual machine register.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0005" level="1">DETAILED DESCRIPTION</heading><p id="p-0015" num="0014">The present disclosure includes a virtual machine register in a computer processor that stores the identifier of a virtual machine for which the computer processor is currently executing instructions. A hypervisor or virtual machine monitor (VMM) creates and manages virtual machines. The hypervisor can control basic functions such as physical memory and input/output (I/O). In general, a computer can run with or without a hypervisor. When a hypervisor is operating/present in a computer system (e.g., as indicated by the value stored in a hypervisor status register of the computer processor), the computer processor can configure its operations to enforce resource/access restrictions to that allocated by the hypervisor to the virtual machine for which the computer processor is currently executing instructions. The virtual machine register allows the processor to isolate its states and/or resources for instructions execution in one virtual machine from the states and/or resources for instruction executions in other virtual machines.</p><p id="p-0016" num="0015">In a traditional system, different layers of instructions (e.g., user applications vs. operating system) may be given different levels of privilege and/or trust. Conventionally, protection rings have been constructed and implemented in computers to protect data and functionality from fault and malicious behaviors based on a hierarchy of rings. Rings are statically arranged in the hierarchy from most privileged (and thus most trusted) to least privileged (and thus least trusted). For example, the hierarchy can include a ring of operating system kernel that is the most privileged, a ring of device drivers, and a ring of applications that are the least privileged. A program or routine in a lower privilege ring can be limited by a respective special hardware enforced control gate to access the resources and services of a higher privilege ring in the hierarchy. Gating access between rings can improve security.</p><p id="p-0017" num="0016">In the techniques of the present disclosure, instructions or routines programmed for a computer system can be classified into a set of predefined, non-hierarchical, domains, such as a domain of hypervisor, a domain of operating system, a domain of application, etc. Addresses used in different domains can be translated using different address translation tables such that the virtual address spaces of different domains can be isolated from each other. If a hypervisor is present (e.g., operating and controlling the lowest level of machine architecture in the computer system), addresses used in different virtual machines managed by the hypervisor can also be translated using different address tables; and thus, the virtual address spaces of different virtual machines can also be isolated from each other. Further, virtual address spaces of different running processes can also be optionally isolated from each other. For example, the virtual machine register can be configured to store an identifier of the current virtual machine for which the processor is executing instructions; and the address translation function of a memory management unit of the processor can be configured, in accordance with the identifier stored in the virtual machine register, the identifier stored in the domain register, and/or the status indication stored in the hypervisor status register, to perform address translation for the execution of a routine in a particular domain for a particular virtual machine.</p><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>1</b></figref> shows a computer processor (<b>169</b>) having a set of registers (<b>183</b>) configured to control the operations of the computer processor (<b>169</b>) according to some embodiments. The set of registers (<b>183</b>) can include at least a domain register (<b>117</b>), a virtual machine register (<b>231</b>), and/or a hypervisor status register (<b>233</b>).</p><p id="p-0019" num="0018">The domain register (<b>117</b>) is configured to store an identifier or indication of the current domain of the instructions that are being executed in the processor (<b>169</b>).</p><p id="p-0020" num="0019">For example, the computer processor (<b>169</b>) of <figref idref="DRAWINGS">FIG. <b>1</b></figref> can be coupled to physical memory (<b>109</b>). The physical memory (<b>109</b>) can store data and instructions for various routines programmed for a computer system. Routines can be classified into various predefined, non-hierarchical, domains (<b>101</b>, <b>103</b>, . . . , <b>105</b>), such as a domain (<b>101</b>) of hypervisor (<b>102</b>), a domain (<b>103</b>) of operating system (<b>104</b>), a domain (<b>105</b>) of application (<b>106</b>).</p><p id="p-0021" num="0020">For example, routines of a hypervisor (<b>102</b>) can be classified in a domain A (<b>101</b>); routines of an operating system (<b>104</b>) can be classified in another domain B (<b>103</b>); and routines of applications (<b>106</b>) can be classified in a further domain C (<b>105</b>). A hypervisor or virtual machine monitor (VMM) creates and manages virtual machines. The hypervisor can control basic functions such as physical memory and input/output (I/O).</p><p id="p-0022" num="0021">The computer processor (<b>169</b>) can be optionally used with or without an operating hypervisor (<b>102</b>). When no hypervisor (<b>102</b>) is operating or present in the computer system of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the operating system (<b>104</b>) can control the entire computer system. When the hypervisor (<b>102</b>) is operating or present in the computer system of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the hypervisor (<b>102</b>) can provision one or more virtual machines; each virtual machine can run its instance of the operating system (<b>104</b>); and the operating system (<b>104</b>) running in a virtual machine can control the resources of the virtual machine provisioned by the hypervisor (<b>102</b>) but not the resources not provisioned to virtual machine. Thus, when the hypervisor (<b>102</b>) is present or operating in the computer system, the operating system in a virtual machine hosted on the computer system may not have control over a portion of the computer system that would be controlled by the operating system when the hypervisor (<b>102</b>) is not present or operating. For example, when the hypervisor (<b>102</b>) provisions a portion of the memory (<b>109</b>) to a virtual machine, the operating system (<b>104</b>) running in the virtual machine can access the portion of the memory (<b>109</b>) via pseudo-physical memory addresses, where the operating system (<b>104</b>) can treat the pseudo-physical memory addresses as physical memory addresses which are actually mapped to the portion of the memory (<b>109</b>) that is allocated by the hypervisor (<b>102</b>) to the virtual machine.</p><p id="p-0023" num="0022">For example, the computer system of <figref idref="DRAWINGS">FIG. <b>1</b></figref> can be powered up or bootstrapped in a mode in which the computer system does not have an operating/running hypervisor (<b>102</b>). In such a mode, the operating system (<b>104</b>) directly controls the hardware resources (e.g., the processor (<b>169</b>) and the memory (<b>109</b>)). Alternatively, the computer system of <figref idref="DRAWINGS">FIG. <b>1</b></figref> can be started in a mode in which the computer system has an operating/running hypervisor (<b>102</b>); the hypervisor (<b>102</b>) can create and manage one or more virtual machines; and each virtual machine can run a copy of the operating system (<b>104</b>) where the operating system (<b>104</b>) can control the hardware resources provisioned by the hypervisor (<b>102</b>) for the respective virtual machine.</p><p id="p-0024" num="0023">In some instances, the processor (<b>169</b>) is coupled with the memory (<b>109</b>) having the hypervisor (<b>102</b>); and the computer system can optionally be bootstrapped into operation with or without an operating hypervisor (<b>102</b>). In other instances, the processor (<b>169</b>) can be optionally coupled to memory that does not have the hypervisor (<b>102</b>) and thus cannot run a hypervisor (<b>102</b>).</p><p id="p-0025" num="0024">The hypervisor status register (<b>233</b>) is configured to store an indicator of whether a hypervisor (<b>102</b>) is present in the computer system. For example, the hypervisor status register (<b>233</b>) can have an initialized value during powering up to indicate the lack of hypervisor (<b>102</b>). If the hypervisor (<b>102</b>) is loaded for execution during the bootstrap process, the hypervisor status register (<b>233</b>) is set to indicate the presence of an operating hypervisor (<b>102</b>). The content of the hypervisor status register (<b>233</b>) allows the processor (<b>169</b>) to customize its operations, such as address translation (<b>235</b>) of a memory management unit (MMU) (<b>181</b>), based on whether or not a hypervisor (<b>102</b>) is present.</p><p id="p-0026" num="0025">For example, when the hypervisor status register (<b>233</b>) indicates that no hypervisor (<b>102</b>) is present, the operating system (<b>104</b>) running in the computer system does not rely upon a hypervisor (<b>102</b>) for the management of resources and/or services. The domain (<b>101</b>) of the hypervisor (<b>102</b>) is not applicable for the instruction execution in the processor (<b>169</b>); and the operating system (<b>104</b>) is provided with full access to resources, such as the entire physical memory (<b>109</b>).</p><p id="p-0027" num="0026">However, when the hypervisor status register (<b>233</b>) indicates that a hypervisor (<b>102</b>) is present, the operating system (<b>104</b>) running in a virtual machine is restricted to resources and/or services provisioned by the hypervisor (<b>102</b>) for the virtual machine. The domain (<b>101</b>) of the hypervisor (<b>102</b>) is thus relevant for the instruction execution in the processor (<b>169</b>). For example, certain operations performed in the routines of the operating system (<b>104</b>) can trigger corresponding operations in the hypervisor (<b>102</b>).</p><p id="p-0028" num="0027">In general, a hypervisor (<b>102</b>) can be present, even though the current domain of execution as indicated by the domain register (<b>117</b>) is different from the domain (<b>101</b>) of hypervisor (<b>102</b>). For example, the processor (<b>169</b>) can execute an application (<b>106</b>) in the domain (<b>105</b>) and rely upon the operating system (<b>104</b>) to access memory (<b>109</b>); and the hypervisor (<b>102</b>) can restrict the operating system (<b>104</b>) in accessing the memory (<b>109</b>) to a portion that is provisioned by the hypervisor (<b>102</b>) to a virtual machine in which the operating system (<b>104</b>) is running. Thus, the execution of the application (<b>106</b>) in the domain (<b>105</b>) can shift to execution in the domain (<b>103</b>) of operating system (<b>104</b>) and/or to execution in the domain (<b>101</b>) of hypervisor (<b>102</b>).</p><p id="p-0029" num="0028">In general, the content of the hypervisor status register (<b>233</b>) indicates whether a hypervisor (<b>102</b>) is present, which is an indication of whether the domains (<b>103</b>, . . . , <b>105</b>) are operating within the constraint of a hypervisor (<b>102</b>) or a virtual machine.</p><p id="p-0030" num="0029">When a hypervisor (<b>102</b>) is present, the virtual machine register (<b>231</b>) can store an identifier of the current virtual machine for which the processor (<b>169</b>) is currently running a routine in a domain (e.g., <b>101</b>, <b>103</b>, . . . , or <b>105</b>). For example, when the processor (<b>169</b>) is executing a routine in the domain (<b>103</b>) of operating system (<b>104</b>), the virtual machine register (<b>231</b>) stores the identifier of the virtual machine for which the routine is being executed in the processor (<b>169</b>). For example, when the processor (<b>169</b>) is executing a routine in the domain (<b>105</b>) of applications (<b>106</b>), the virtual machine register (<b>231</b>) stores the identifier of the virtual machine in which the application is running.</p><p id="p-0031" num="0030">In some implementations, the virtual machine register (<b>231</b>) and the hypervisor status register (<b>233</b>) can be combined. For example, when the virtual machine register (<b>231</b>) has a predetermined value (e.g., zero), the virtual machine register (<b>231</b>) indicates that no hypervisor is present in the computer system; and when the virtual machine register (<b>231</b>) has a value different from the predetermined value, the content of the virtual machine register (<b>231</b>) uniquely identifies a virtual machine for which the processor (<b>169</b>) is currently executing instructions.</p><p id="p-0032" num="0031">In some implementations, the virtual machine register (<b>231</b>) and the hypervisor status register (<b>233</b>) are separate registers and/or have different access privileges for different domains (e.g., <b>101</b>, <b>103</b>, . . . , <b>105</b>). For example, the hypervisor status register (<b>233</b>) cannot be changed without restarting the computer system in a bootstrap process. For example, the hypervisor status register (<b>233</b>) can be accessed by the domain (<b>101</b>) of the hypervisor (<b>102</b>) but not by the domain (<b>103</b>) of the operating system and/or the domain (<b>105</b>) of the applications; and the virtual machine register (<b>231</b>) can be accessed by both the domain (<b>101</b>) of the hypervisor (<b>102</b>) and the domain (<b>103</b>) of the operating system (<b>104</b>).</p><p id="p-0033" num="0032">The processor (<b>169</b>) of <figref idref="DRAWINGS">FIG. <b>1</b></figref> includes a memory management unit (MMU) (<b>181</b>) that implements a function of address translation (<b>235</b>). The processor (<b>169</b>) can configure the address translation (<b>235</b>) based on the content of the hypervisor status register (<b>233</b>).</p><p id="p-0034" num="0033">For example, when the hypervisor status register (<b>233</b>) has a first value (e.g., 0) indicating the absence of a hypervisor (<b>102</b>), the processor (<b>169</b>) configures the address translation (<b>235</b>) to function without using the virtual machine register (<b>231</b>). When the hypervisor status register (<b>233</b>) has a second value (e.g., 1) indicating the presence of a hypervisor (<b>102</b>), the processor (<b>169</b>) configures the address translation (<b>235</b>) to function using the virtual machine register (<b>231</b>) such that address translation is specific for a virtual machine.</p><p id="p-0035" num="0034">The processor (<b>169</b>) of <figref idref="DRAWINGS">FIG. <b>1</b></figref> has execution units (e.g., <b>185</b>), such as an arithmetic-logic unit. The processor (<b>169</b>) can include an internal cache (<b>187</b>) as a proxy of a portion of the memory (<b>109</b>). In additional to the domain register (<b>117</b>), the virtual machine register (<b>231</b>), and the hypervisor status register (<b>233</b>), the processor (<b>169</b>) can have other registers (<b>183</b>) to hold instructions for execution, data as operands of instructions, and/or results of instruction executions.</p><p id="p-0036" num="0035">In general, a routine can include a pre-programmed set of instructions stored in the memory (<b>109</b>). The routine can also have input data, output data, and/or, temporary data stored in the memory (<b>109</b>). A routine can invoke or call another routine for services and/or resources. The calling routine and the called routine can be in a same domain or different domains (e.g., <b>101</b>, <b>103</b>, . . . , <b>105</b>).</p><p id="p-0037" num="0036">Optionally, the content of the domain register (<b>117</b>) can control security operations in the processor (<b>169</b>) as discussed further below.</p><p id="p-0038" num="0037">In one implementation, when a computer system having the processor (<b>169</b>) is initially powered on (bootstrapped), the processor (<b>169</b>) is configured to automatically execute routines of a hypervisor (<b>102</b>) or an operating system (<b>104</b>) (if no hypervisor is used), as part of the bootstrap process. Thus, the domain register (<b>117</b>) is initially set to indicate the domain (<b>101</b>) of the hypervisor (<b>102</b>) or the domain (<b>103</b>) of the operating system (<b>104</b>). Subsequently, the execution control can move from one domain to another domain using instructions that identify the destination domains; and the content of the domain register (<b>117</b>) can be updated according to the processing of such instructions. Some examples and details of domain crossing can be found in U.S. Pat. No. 11,182,507, issued Nov. 23, 3021, which claims priority to U.S. Pat. App. Ser. No. 62/725,030, filed on Aug. 30, 2018 and entitled &#x201c;Domain Crossing in Executing Instructions in Computer Processors,&#x201d; the entire disclosure of which application is hereby incorporated herein by reference.</p><p id="p-0039" num="0038">Alternatively, or in combination, the domain of the currently running routine can be identified based on memory addresses, stored attributes of the routines, etc. For example, some techniques to specify the current domain (<b>123</b>) in the domain register (<b>117</b>) in the computer processor (<b>169</b>) can be found in U.S. Pat. No. 10,915,465, issued on Feb. 9, 2021, which claims priority to U.S. Pat. App. Ser. No. 62/724,999, filed on Aug. 30, 2018 and entitled &#x201c;Domain Register for Instructions being Executed in Computer Processors,&#x201d; the entire disclosure of which application is hereby incorporated herein by reference.</p><p id="p-0040" num="0039">In some instances, the current domain can be identified from a memory address used to load an instruction of a routine for execution.</p><p id="p-0041" num="0040">For example, a virtual memory address (e.g., <b>195</b> illustrated in <figref idref="DRAWINGS">FIG. <b>5</b></figref>) can have a predetermined width (e.g., a predetermined number of bits) for the processor (<b>169</b>). The memory address can include a portion representing an object ID (e.g., <b>199</b> illustrated in <figref idref="DRAWINGS">FIG. <b>5</b></figref>) and a portion representing an offset (e.g., <b>196</b> illustrated in <figref idref="DRAWINGS">FIG. <b>5</b></figref>) within the object represented by the object ID (e.g., <b>199</b>). For example, the routine can be an object located at the address; and the object ID of the address can be used to identify certain proprieties of the instruction and/or the routine; and the current domain can be determined from the properties.</p><p id="p-0042" num="0041">For example, a static object ID of a predetermined value (e.g., 0) can be used to represent a kernel object of an operating system (<b>104</b>). Thus, the static object ID specified in the memory address can be used to identify the current domain for the execution of the routine. Some details and examples of static object IDs in memory addresses for computer processors to load instructions for execution can be found in U.S. patent application Ser. No. 16/028,840, filed Jul. 6, 2018, issued as U.S. Pat. No. 11,275,587 on Mar. 15, 2022, and entitled &#x201c;Static Identifications in Object-based Memory Access,&#x201d; the entire disclosure of which application is hereby incorporated herein by reference.</p><p id="p-0043" num="0042">In some instances, a memory address and/or the object ID (e.g., <b>199</b>) of the memory address can include a portion representing an object type (e.g., <b>198</b> illustrated in <figref idref="DRAWINGS">FIG. <b>5</b></figref>). For example, an object type (<b>198</b>) of a value from 0 to 3 can be used to identify a kernel object of an operating system. For example, an object type (<b>198</b>) of a value of 4 to 5 can be used to specify that the offset is an address of different widths (e.g., a 64-bit address or 32-bit address included within the memory address that has 128 bits). For example, an object type (<b>198</b>) of a value of 6 to 7 can be used to specify that a predetermined portion of the object ID is to be interpreted as an identifier of a local object or an object in partitioned global address space (PGAS). For example, an object type (<b>198</b>) of a value of 32 can be used to specify that the remaining portion of the object ID is to be interpreted as an identifier of an object defined in a server. For example, an object name server can store data indicating the name of an object represented by an object ID, access control parameters of the object, and/or other attributes of the object.</p><p id="p-0044" num="0043">For example, the object ID (<b>199</b>) of the memory address used to load the routine for execution can have attributes stored in the object name server; and the attributes can be used to determine or infer the current domain of the routine loaded from the memory address.</p><p id="p-0045" num="0044">In some instances, a routine to be executed in the processor (<b>169</b>) can have attributes that are stored in association with the routine (e.g., in the memory (<b>109</b>), in a page table entry for the determination of a physical address of the instruction, in an entry table for making calls for the execution of routines). When the routine is loaded for execution, the attributes of the routine are used to determine the current domain for the execution of the routine.</p><p id="p-0046" num="0045">In one embodiment, when the hypervisor status register (<b>233</b>) indicates the absence of a hypervisor, the processor (<b>169</b>) configures the memory management unit (MMU) (<b>181</b>) to identify a table base of an address translation table in accordance with <figref idref="DRAWINGS">FIG. <b>2</b></figref>. However, when the hypervisor status register (<b>233</b>) indicates the presence of a hypervisor (<b>102</b>), the processor (<b>169</b>) configures the memory management unit (MMU) (<b>181</b>) to identify a table base of an address translation table in accordance with <figref idref="DRAWINGS">FIG. <b>3</b></figref>. <figref idref="DRAWINGS">FIG. <b>5</b></figref> shows a technique to retrieve an entry from an address translation table to convert a virtual address to a physical address.</p><p id="p-0047" num="0046"><figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates the identification of a table base (<b>249</b>) of an address translation table in absence of an operating hypervisor in some embodiments.</p><p id="p-0048" num="0047">In <figref idref="DRAWINGS">FIG. <b>2</b></figref>, separate table base registers (<b>241</b>, <b>243</b>, . . . , <b>245</b>) are configured for the different domains (<b>101</b>, <b>103</b>, . . . , <b>105</b>) respectively.</p><p id="p-0049" num="0048">The domain register (<b>117</b>) of the processor (<b>169</b>) stores the identifier of a current domain in which the processor (<b>169</b>) is currently executing instructions. The domain register (<b>117</b>) is coupled to a multiplexer (<b>247</b>) to select, as the table base (<b>249</b>) of address translation table used in the address translation. The table base (<b>249</b>) identifies a memory location of an address translation table that is to be used to perform address translation (<b>235</b>) in the memory management unit (MMU) (<b>181</b>) (e.g., as discussed below in connection with <figref idref="DRAWINGS">FIG. <b>5</b></figref> and/or <figref idref="DRAWINGS">FIG. <b>7</b></figref>).</p><p id="p-0050" num="0049"><figref idref="DRAWINGS">FIG. <b>2</b></figref> shows an example of a processor having multiple table base registers (<b>241</b>, <b>243</b>, . . . , <b>245</b>).</p><p id="p-0051" num="0050">Alternatively, or in combination, each domain (<b>101</b>, <b>103</b>, . . . , or <b>105</b>) can have a separate memory area configured to store the values of domain specific registers used for instruction execution in the respective domain (<b>101</b>, <b>103</b>, . . . , or <b>105</b>).</p><p id="p-0052" num="0051">For example, each domain (<b>101</b>, <b>103</b>, . . . , or <b>105</b>) can have a separate memory area storing the domain specific values of registers used during the execution of the last executed instruction, before the execution transitions temporarily across into another domain (e.g., via a domain call instruction to execute a routine in another domain). Such a separate memory area for storing the values of registers specific to a particular domain (e.g., <b>101</b>) is accessible for instruction execution in the respective domain (e.g., <b>101</b>) but not accessible for instruction execution in other domains (e.g., <b>105</b>). Since other domains (e.g., <b>101</b>) are prevented from accessing the register value region of a given domain (e.g., <b>105</b>), the register states of the given domain (e.g., <b>105</b>) are isolated and protected from executions in the other domains (e.g., <b>101</b>).</p><p id="p-0053" num="0052">For example, the memory area for domain specific values of registers of a particular domain (e.g., <b>101</b>) can store the value of the program counter (PC) of instructions being executed in the processor, the value of the stack pointer (SP) of a stack for instruction execution, the value of the frame pointer (FP) of the stack, the value of the argument pointer (AP) for the stack, and/or the value of the processor status word (PSW), etc. The value of the table based register for the particular domain (e.g., <b>101</b>) can also be saved in the register value region of the particular domain (e.g., <b>101</b>). In such an implementation, it is not necessary to configure separate registers (<b>241</b>, <b>243</b>, . . . , <b>245</b>) for the domains (<b>101</b>, <b>103</b>, . . . , <b>105</b>) respectively. A single register can be used to store the table base for the current domain (e.g., <b>101</b>, <b>103</b>, . . . , <b>105</b>) as indicated by the domain register (<b>117</b>); and when the execution enters a new domain, the register can be updated using the table base previously stored in the register value region of the new domain. Alternatively, the content of the domain register (<b>117</b>) can be used as an index in a table of table bases to look up the base (<b>249</b>) of address translation table.</p><p id="p-0054" num="0053">In one embodiment, when a domain (<b>101</b>) is specifically configured for hypervisor (<b>102</b>), the absence of a hypervisor, as indicated by the hypervisor status register (<b>233</b>), allows the processor (<b>169</b>) to skip the table base register for the domain (<b>101</b>) of hypervisor (<b>102</b>); and the domain (<b>101</b>) of hypervisor (<b>102</b>) becomes not relevant to the subsequent operations of the processor (<b>169</b>) (e.g., until the hypervisor status register (<b>233</b>) is changed during a subsequent powering up/bootstrap process).</p><p id="p-0055" num="0054"><figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates the identification of a table base (<b>249</b>) of an address translation table in the presence of an operating hypervisor (<b>102</b>) in some embodiments.</p><p id="p-0056" num="0055">In <figref idref="DRAWINGS">FIG. <b>3</b></figref>, an intermediate base (<b>248</b>) is selected by the multiplexer (<b>247</b>) as an output from the table base registers (<b>241</b>, <b>243</b>, . . . , <b>245</b>). The intermediate base (<b>248</b>) is further combined with the content of the virtual machine register (<b>231</b>) to generate the table base (<b>249</b>) of address translation table.</p><p id="p-0057" num="0056">In general, for each execution domain (<b>101</b>, <b>103</b>, . . . , <b>105</b>) and each virtual machine hosted in the computer system of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, a separate address translation table can be created for the conversion of virtual addresses assigned by the operating system (<b>104</b>) to physical addresses. When an operating hypervisor (<b>102</b>) is present in the computer system, the operating system (<b>104</b>) running in a virtual machine uses pseudo-physical addresses in that the operating system (<b>104</b>) allocates the pseudo-addresses for virtual memory addresses in a way as if the pseudo-addresses were physical addresses, since the operating system (<b>104</b>) cannot tell apart a virtual machine provided by the hypervisor (<b>102</b>) from a physical machine. The hypervisor (<b>102</b>) can translate the pseudo-physical addresses allocated by the operating system (<b>104</b>) running in a virtual machine to the physical address of the memory (<b>109</b>) in the computer system (e.g., illustrated in <figref idref="DRAWINGS">FIG. <b>1</b></figref>).</p><p id="p-0058" num="0057">Preferably, the hypervisor (<b>102</b>) performs the translation at the time of the creation of a page table entry mapping a page of virtual memory addresses and a page of physical addresses. Since the operating system (<b>104</b>) running in a virtual machine operates on pseudo-physical addresses, the page table entry specified by the operating system maps the page of virtual memory addresses to a page of pseudo-physical addresses. The hypervisor (<b>102</b>) can translate the page of pseudo-physical addresses to a page of physical addresses assigned to the virtual machine such that the page table entry can subsequently be used to translate the virtual addresses directly into the physical addresses assigned to the virtual machine. Such a page table entry modified by the hypervisor (<b>102</b>) can improve the memory access performance in the presence of an operating hypervisor (<b>102</b>) by eliminating the need to separately translate a pseudo-physical address in a virtual machine to a physical address for the physical memory (<b>109</b>) at the time of the usage of a virtual address.</p><p id="p-0059" num="0058">For example, when the operating system (<b>104</b>) executes an instruction to create a page table entry to map a virtual memory page to a pseudo-physical memory page, the instruction can be trapped to cause the hypervisor (<b>102</b>) to translate the pseudo-physical memory page to a physical memory page and modify the page table entry to map the virtual memory page to the translated physical memory page. Subsequently, the page table entry can be used to directly translate the virtual memory page to the physical memory page.</p><p id="p-0060" num="0059">The content of the virtual machine register (<b>231</b>) can be combined with the base (<b>248</b>) via a table to look up the base (<b>249</b>) specific to a virtual machine identified by the virtual machine register (<b>231</b>). Alternatively, the content of the virtual machine register (<b>231</b>) can be used as part of the input for a hash function (e.g., <b>121</b> illustrated in <figref idref="DRAWINGS">FIG. <b>5</b></figref>) to index into a table at the base (<b>248</b>) to retrieve a virtual machine specific entry of an address translation table (<b>249</b>), as further discussed below in connection with <figref idref="DRAWINGS">FIG. <b>5</b></figref>.</p><p id="p-0061" num="0060">For example, for a particular domain (e.g., <b>103</b>), the processor (<b>169</b>) can store a table of table bases of the virtual machines hosted in the computer system. The table base register (e.g., <b>243</b>) of the domain (e.g., <b>103</b>) can store the base (<b>248</b>) of the table of table bases for the virtual machines. The content of the virtual machine register (<b>231</b>) can be used as an index into the table at the base (<b>248</b>) to look up the base (<b>249</b>) of an address translation table that is specify for the domain (e.g., <b>103</b>) and for the virtual machine identified by the virtual machine register (<b>231</b>).</p><p id="p-0062" num="0061"><figref idref="DRAWINGS">FIG. <b>3</b></figref> shows an example of a processor having multiple table base registers (<b>241</b>, <b>243</b>, . . . , <b>245</b>).</p><p id="p-0063" num="0062">Alternatively, or in combination, each domain (<b>101</b>, <b>103</b>, . . . , or <b>105</b>) can have a separate memory area configured to store the domain specific values of registers used for instruction execution in the respective domain (<b>101</b>, <b>103</b>, . . . , or <b>105</b>), as discussed above in connection with <figref idref="DRAWINGS">FIG. <b>2</b></figref>. The values of the table base registers (<b>241</b>, <b>243</b>, . . . , <b>245</b>) can be stored in the register value region of the respective domains (e.g., <b>101</b>, <b>103</b>, . . . , <b>105</b>). In such an implementation, it is not necessary to configure separate registers (<b>241</b>, <b>243</b>, . . . , <b>245</b>) for the domains (<b>101</b>, <b>103</b>, . . . , <b>105</b>) respectively. A single register can be used to store the base (<b>248</b>) retrieved from the register value region of the respective domains (e.g., <b>101</b>, <b>103</b>, . . . , <b>105</b>). In some implementations, the base (<b>248</b>) is further combined with the content of the virtual machine register (<b>231</b>) to obtain the base (<b>249</b>) of address translation table and update that register to hold the base (<b>249</b>) for address translation (<b>235</b>). Alternatively, separate registers are used to store the intermediate base (<b>248</b>) and the base (<b>249</b>) of address translation table to avoid the need to reload the base (<b>248</b>) from the register value region of the respective domains (e.g., <b>101</b>, <b>103</b>, . . . , <b>105</b>) when the content of the virtual machine register (<b>231</b>) changes. The register value regions of the domains (<b>101</b>, <b>103</b>, . . . , <b>105</b>) are be cached in the internal cache (<b>187</b>) to facilitate efficient state changes of the processor (<b>169</b>) in response to the changes in the domain register (<b>117</b>) and/or the virtual machine register (<b>231</b>). Alternatively, the content of the domain register (<b>117</b>) and the content of the virtual machine register (<b>231</b>) can be combined as an index in a table of table bases to look up the base (<b>249</b>) of address translation table.</p><p id="p-0064" num="0063"><figref idref="DRAWINGS">FIG. <b>4</b></figref> illustrates separate address translation tables (<b>217</b>, . . . , <b>227</b>) for respective domains (<b>101</b>, . . . , <b>105</b>).</p><p id="p-0065" num="0064">In <figref idref="DRAWINGS">FIG. <b>4</b></figref>, the domain register (<b>117</b>) can store an identifier of a current domain of instruction execution in the processor (<b>169</b>) of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. For example, the content of the domain register (<b>117</b>) can identify domain A (<b>101</b>) or domain C (<b>105</b>).</p><p id="p-0066" num="0065">Each of the domains (<b>101</b>, . . . , <b>105</b>) has a corresponding table base (<b>219</b>, . . . , <b>229</b>) that identifies the memory location of a respective address translation table (<b>217</b>, . . . , <b>227</b>).</p><p id="p-0067" num="0066">For example, when the hypervisor status register (<b>233</b>) indicates the absence of an operating hypervisor (<b>102</b>) in the computer system, the table bases (<b>219</b>, . . . , <b>229</b>) can be loaded from the register value regions of the respective domains (<b>101</b>, . . . , <b>105</b>) and/or retrieved from respective registers (<b>241</b>, . . . , <b>245</b>), as discussed above in connection with <figref idref="DRAWINGS">FIG. <b>2</b></figref>.</p><p id="p-0068" num="0067">When the hypervisor status register (<b>233</b>) indicates the presence of an operating hypervisor (<b>102</b>) in the computer system, the table bases (<b>219</b>, . . . , <b>229</b>) can be loaded for a particular virtual machine identified by the virtual machine register (<b>231</b>) from the register value regions of the respective domains (<b>101</b>, . . . , <b>105</b>) and/or looked up for the particular virtual machine using table bases retrieved from respective registers (<b>241</b>, . . . , <b>245</b>), in a way similar to that discussed above in connection with <figref idref="DRAWINGS">FIG. <b>3</b></figref>.</p><p id="p-0069" num="0068">Alternatively, when the hypervisor status register (<b>233</b>) indicates the presence of an operating hypervisor (<b>102</b>) in the computer system, the table bases (<b>219</b>, . . . , <b>229</b>) can be loaded from the register value regions of the respective domains (<b>101</b>, . . . , <b>105</b>); and the content of the virtual machine register (<b>231</b>) can be used to generate an index into the address translation tables (<b>217</b>, . . . , <b>227</b>) at the table bases (<b>219</b>, . . . , <b>229</b>).</p><p id="p-0070" num="0069">In <figref idref="DRAWINGS">FIG. <b>4</b></figref>, each address translation table (<b>217</b>, . . . , or <b>227</b>) stores a number/count (<b>211</b>, . . . , or <b>221</b>) of entries (<b>213</b>, . . . , <b>215</b>; or <b>223</b>, . . . , <b>225</b>) the respective table (<b>217</b>, . . . , or <b>227</b>) has. The number/count (<b>211</b>, . . . , or <b>221</b>) allows the processor (<b>169</b>) to check whether an index used on the address translation table (<b>217</b>, . . . , or <b>227</b>) is within the valid bound defined by the number/count (<b>211</b>, . . . , or <b>221</b>).</p><p id="p-0071" num="0070">During the translation of a virtual address to a physical address, an index is generated from and/or for the virtual address to retrieve an entry that facilities the translation of the virtual address to the physical address. <figref idref="DRAWINGS">FIG. <b>5</b></figref> illustrates an example of the generation of the index in address translation (<b>235</b>).</p><p id="p-0072" num="0071"><figref idref="DRAWINGS">FIG. <b>5</b></figref> shows a technique to retrieve an entry (<b>250</b>) from an address translation table (<b>217</b>) to convert a virtual address (<b>195</b>).</p><p id="p-0073" num="0072">The virtual address (<b>195</b>) can include an object ID (<b>199</b>), an object type (<b>198</b>), and an offset (<b>196</b>). For example, the virtual address (<b>195</b>) can have a width of 128 bits; a number of bits (e.g., 59 or 58) of the virtual address (<b>195</b>) can be used to store the object ID (<b>199</b>), another number of bits (e.g., 5 or 6) of the virtual address (<b>195</b>) can be used to store the object type (<b>198</b>), and the remaining bits (e.g., 64) of the virtual address can be used to store the offset (<b>196</b>) relative to the object that has the type (<b>198</b>) and the ID (<b>199</b>). For example, the virtual address (<b>195</b>) can be an address stored in the memory (<b>109</b>), as configured, programmed, and/or seen by a programmer or user of a routine in a domain (e.g., <b>105</b>).</p><p id="p-0074" num="0073">In <figref idref="DRAWINGS">FIG. <b>5</b></figref>, a hash (<b>121</b>) is applied on the object ID (<b>199</b>) to generate an index (<b>125</b>). The index (<b>125</b>) has a smaller number of bits than the object ID (<b>199</b>) and thus reduces the size of the address translation table (<b>217</b>) for looking up an entry (e.g., <b>213</b>, . . . , <b>215</b>) from the table (<b>217</b>). However, hash collision can occur when multiple items are hashed into a same index. Chaining is one of the techniques to resolve hash collisions. The index resulting from a collision can be used to retrieve a list/chain of key-value pairs. Each item that is hashed into the index can be configured as the key in a corresponding key-value pair in the list; and the look up result for the item can be configured as the value in the corresponding key-value pair. To retrieve the look up result of one of the items that are hashed into the same index, the list/chain of key-value pairs identified via the index can be searched to find a key-value pair where the key matches with the item. The value of the matching key-value pair provides the look up result. When there is no hash collision for the index (<b>125</b>), the entry (e.g., <b>213</b>, . . . , or <b>215</b>) at the index (<b>125</b>) in the address translation table (<b>217</b>) can be retrieved as the resulting entry (<b>250</b>). When there is hash collision for the index (<b>125</b>), the entry (e.g., <b>213</b>, . . . , or <b>215</b>) at the index (<b>125</b>) in the address translation table (<b>217</b>) identifies a collision chain (<b>260</b>). The collision chain (<b>260</b>) has a list/chain showing the entries (e.g., <b>262</b>, <b>264</b>, . . . ) for the object IDs (e.g., <b>261</b>, <b>263</b>) that are hashed (<b>121</b>) into the same index (<b>125</b>). The collision chain (<b>260</b>) can be searched to locate the entry (e.g., <b>262</b>, or <b>264</b>) that is specified for an object ID (e.g., <b>261</b> or <b>263</b>) that matches with the object ID (<b>199</b>) before the hash (<b>121</b>). The located entry (e.g., <b>262</b>, or <b>264</b>) is illustrated as the resulting entry (<b>250</b>).</p><p id="p-0075" num="0074">In general, the hash (<b>121</b>) can be applied to a combination of the object ID (<b>199</b>), optionally the object type (<b>198</b>), a portion of the offset, the content of the virtual machine register (<b>231</b>), and/or other information, such as the processor ID of the current process running in the processor (<b>169</b>) and/or the content of the domain register (<b>117</b>). In some instances, the content of the domain register (<b>117</b>) and/or the content of the virtual machine register (<b>231</b>) can be appended/added to the result of the hash (<b>121</b>) to generate the index (<b>125</b>).</p><p id="p-0076" num="0075">A typical entry (<b>250</b>) looked up from the address translation table (<b>217</b>) using the index (<b>125</b>) can have fields for subsequent operations in address translation (<b>235</b>). For example, a valid field (<b>251</b>) can have a value indicating whether the entry (<b>250</b>) is a valid for address translation; a type field (<b>253</b>) can have a value indicating a type of translation to be performed using the entry; a page size field (<b>255</b>) can have a value indicating the memory page size for the determination of a page table entry; an address field (<b>257</b>); etc. For example, the entry (<b>250</b>) can further include a field identifying the page table structure, and/or a field specifying security configuration (e.g., <b>107</b> illustrated in <figref idref="DRAWINGS">FIG. <b>6</b></figref>) for accessing the memory region corresponding to the entry (<b>250</b>).</p><p id="p-0077" num="0076">The address (<b>257</b>) provided in the entry (<b>250</b>) of the address translation table (<b>217</b>) can be the memory address of a page table or page directory. At least a portion of the offset (<b>196</b>) can be used as a virtual page number and an index in the page table or page directory to look up the next page table or page directory. The process of looking up the next page table or page directory can be repeated, until an entry looked up using the last virtual page number in the offset (<b>196</b>) is used to locate a page table entry (e.g., <b>153</b> illustrated in <figref idref="DRAWINGS">FIG. <b>7</b></figref>). A base (<b>157</b>) of a physical memory page identified in the page table entry (<b>153</b>) can be combined with the remaining portion of the offset (<b>196</b>) (e.g., as the offset (<b>147</b>) illustrated in <figref idref="DRAWINGS">FIG. <b>7</b></figref>) to generate a physical address (e.g., <b>159</b> illustrated in <figref idref="DRAWINGS">FIG. <b>7</b></figref>).</p><p id="p-0078" num="0077">Optionally, the hash (<b>121</b>) can be applied to the entire virtual address (<b>195</b>) such that the address (<b>257</b>) looked up using the index (<b>125</b>) is a physical address. In such an implementation, the entry (<b>250</b>) can be considered as a page table entry and can include security configuration (e.g., <b>107</b> illustrated in <figref idref="DRAWINGS">FIG. <b>6</b></figref>) for the memory address. However, such an implementation can require a large address translation table (<b>217</b>).</p><p id="p-0079" num="0078">Alternatively, the hash (<b>121</b>) can be applied to a combination of the object ID (<b>199</b>), optionally the object type (<b>198</b>), and a portion of the offset (<b>196</b>); and the address (<b>257</b>) looked up using the index (<b>125</b>) is a base (e.g., <b>157</b> illustrated in <figref idref="DRAWINGS">FIG. <b>7</b></figref>) of a page of physical addresses. The remaining portion of the offset (<b>196</b>) can be combined with the base (e.g., as illustrated in <figref idref="DRAWINGS">FIG. <b>7</b></figref>) to generate the physical address (e.g., <b>159</b>). In such an implementation, the address translation table (<b>217</b>) can be considered as a page table (e.g., <b>151</b> illustrated in <figref idref="DRAWINGS">FIG. <b>7</b></figref>); the portion of the address (<b>195</b>) used to generate the index (<b>125</b>) from hashing (<b>121</b>) can be considered an entry ID (e.g., <b>145</b> illustrated in <figref idref="DRAWINGS">FIG. <b>7</b></figref>) or a virtual page number (VPN); and the entry (<b>250</b>) can be considered as a page table entry (e.g., <b>153</b> illustrated in <figref idref="DRAWINGS">FIG. <b>7</b></figref>) and can optionally include a security configuration (e.g., <b>107</b>) for the memory address.</p><p id="p-0080" num="0079">Alternatively, the hash (<b>121</b>) can be applied to a combination of the object ID (<b>199</b>), optionally the object type (<b>198</b>), and a portion of the offset (<b>196</b>); and the address (<b>257</b>) in the entry (<b>250</b>) looked up using the index (<b>125</b>) is the physical address of a page table (e.g., <b>153</b> illustrated in <figref idref="DRAWINGS">FIG. <b>7</b></figref>). Since the entry (<b>250</b>) identifies a page table (e.g., <b>153</b>), the portion of the address (<b>195</b>) used to generate the index (<b>125</b>) from hashing (<b>121</b>) can be considered a table ID (e.g., <b>143</b> illustrated in <figref idref="DRAWINGS">FIG. <b>7</b></figref>). A portion of the offset (<b>196</b>) can be used as an entry ID (<b>145</b>) or a virtual page number (VPN) in the page table (e.g., <b>153</b>) to look up the page table entry (e.g., <b>153</b>) that contains the base (<b>157</b>) of a memory page or memory region (<b>137</b>); and the remaining portion of the offset (<b>196</b>) can be combined with the base (<b>157</b>) to generate the physical address (<b>159</b>).</p><p id="p-0081" num="0080">Alternatively, the hash (<b>121</b>) can be applied to a combination of the object ID (<b>199</b>), optionally the object type (<b>198</b>), and a portion of the offset (<b>196</b>); and the address (<b>257</b>) in the entry (<b>250</b>) looked up using the index (<b>125</b>) is the address of a page directory. The offset (<b>196</b>) can have one or more virtual page numbers for one or more page directories or page tables. A virtual page number (VPN) in the offset (<b>196</b>) is used to index into the page directory to look up the base of a subsequent page directory or page table. The last virtual page number (VPN) in the offset (<b>196</b>) is used to index into a page table (e.g., <b>153</b>) to retrieve the page table entry (<b>153</b>) containing the base (<b>157</b>) of the memory region (<b>137</b>). In such an implementation, the leading portion of the address (<b>195</b>), including the virtual page number (VPN) before the last virtual page number (VPN) can be considered a table ID (<b>143</b>).</p><p id="p-0082" num="0081">In some instances, when different object IDs are hashed to generate the same index (<b>125</b>), a collision chain (<b>260</b>) can be used to identify a unique address associated with each of the object IDs. In such a situation, the address (<b>257</b>) can be used to identify a table, list, or chain storing the collision chain (<b>260</b>), from which a unique entry (e.g., <b>262</b>, or <b>264</b>) for address translation for the object ID (<b>199</b>) can be located. The unique entry (e.g., <b>262</b>, or <b>264</b>) looked up from the collision chain (<b>260</b>) can have a structure similar to the entry (<b>250</b>) looked up directly from the address translation table (<b>217</b>) without collision.</p><p id="p-0083" num="0082">In some implementations, different processes running in the computer system illustrated in <figref idref="DRAWINGS">FIG. <b>1</b></figref> can have different virtual address spaces and thus different entries in the address translation table (<b>217</b>). In such a situation, the process ID can be combined with a portion of the address (<b>195</b>) for the hash (<b>121</b>) to generate the index (<b>125</b>). Optionally, the object ID (<b>199</b>) includes or indicates the process ID.</p><p id="p-0084" num="0083">In some implementations, different virtual machines use different page tables or page directories looked up from the address translation table (<b>217</b>). Thus, the content of the virtual machine register (<b>231</b>) can be combined with the object ID (<b>199</b>) and/or a further portion of the virtual address (<b>195</b>) to generate the index (<b>125</b>) through the function of the hash (<b>121</b>).</p><p id="p-0085" num="0084">The domain register (<b>117</b>) of the computer processor (<b>169</b>) can be used to store the domain identifier of the routine that is currently being executed in the computer processor (<b>169</b>). For example, upon the execution of an instruction that causes domain crossing, the content of the domain register (<b>117</b>) can be updated to store the domain identifier specified in the instruction, after the instruction is successfully processed. The content of the domain register can control various security operations of the processor (<b>169</b>).</p><p id="p-0086" num="0085">For example, when the execution of an instruction results in a request to access a memory location identified using a virtual memory address, the virtual memory address can be translated to a physical memory address using one or more page tables. The content of the domain register can be used to select, from a page table entry, a permission bit for the memory access made in the current domain. The selected permission bit can control the processing of the request to access a memory unit identified by the virtual memory address.</p><p id="p-0087" num="0086">For example, when a call is made to execution a routine having a virtual memory address, the content of the domain register can be used to select a security bit from a page table entry that is used to translate the virtual memory address to a physical memory address. The security bit is selected for executing the routine in providing services for the current domain identified by the domain register. The selected security bit controls security operations of separating resources and/or data between the called routine and the calling routine.</p><p id="p-0088" num="0087">For example, when the execution of an instruction generates a request to access a privileged register, the content of the domain register can be used to select, from a permission register for example, a permission bit for the current domain to access the privileged register. The permission bit can control the acceptance or rejection of the request to access the privileged register.</p><p id="p-0089" num="0088"><figref idref="DRAWINGS">FIG. <b>6</b></figref> shows a system to control security operations applied to resources (e.g., <b>131</b>) in accordance with a domain register (<b>117</b>).</p><p id="p-0090" num="0089">In <figref idref="DRAWINGS">FIG. <b>6</b></figref>, a security control (<b>119</b>) is implemented based on the current domain (<b>123</b>) specified in the domain register (<b>117</b>), and the security configuration (<b>107</b>) having settings (<b>111</b>, <b>113</b>, . . . , <b>115</b>) specified separately for the predefined domains (<b>101</b>, <b>103</b>, . . . , <b>105</b>) respectively. The security control (<b>119</b>) is applied to a resource (<b>131</b>), which can be a privileged register (<b>133</b>), a called routine (<b>135</b>), a memory region (<b>137</b>), etc.</p><p id="p-0091" num="0090">The security configuration (<b>107</b>) can have settings (<b>111</b>, <b>113</b>, . . . , <b>115</b>) for the domains (<b>101</b>, <b>103</b>, . . . , <b>105</b>) respectively, without relying upon a static hierarchy of trust among the domains (<b>101</b>, <b>103</b>, . . . , <b>105</b>).</p><p id="p-0092" num="0091">During the executing of a routine in the processor (<b>169</b>), the domain register (<b>117</b>) causes the security control (<b>119</b>) to select a setting (e.g., <b>111</b>, <b>113</b>, . . . , or <b>115</b>) that is pre-associated with a domain (e.g., <b>101</b>, <b>103</b>, . . . , or <b>105</b>) matching with the current domain (<b>123</b>). The selected setting (e.g., <b>111</b>, <b>113</b>, . . . , or <b>115</b>) is used by the security control (<b>119</b>) to customize security operations for the resource (<b>131</b>).</p><p id="p-0093" num="0092">For example, when the execution of an instruction of the routine in the processor (<b>169</b>) requests memory access to the memory region (<b>137</b>), the selected setting (e.g., <b>111</b>, <b>113</b>, . . . , or <b>115</b>) having its pre-associated domain (e.g., <b>101</b>, <b>103</b>, . . . , <b>105</b>) matching the current domain (<b>123</b>) is used by the security control (<b>119</b>) to determine whether the memory access permissible.</p><p id="p-0094" num="0093">For example, different regions (e.g., <b>137</b>) in the memory (<b>109</b>) can be configured with different security configurations (e.g., <b>107</b>); and each security configuration (e.g., <b>107</b>) can include different permissions (e.g., <b>111</b>, <b>113</b>, . . . , <b>115</b>) for different domains (<b>101</b>, <b>103</b>, . . . , <b>105</b>). The security configuration (<b>107</b>) can be specified, for example, in a page table entry used in logical to physical address translation of virtual memory addresses, such that the structure of the memory regions can correspond to the memory page structure, as further discussed below in connection with <figref idref="DRAWINGS">FIG. <b>7</b></figref>.</p><p id="p-0095" num="0094">For example, the physical memory (<b>109</b>) can be divided into multiple regions; each region (e.g., <b>137</b>) can be a page of physical memory (<b>109</b>) for memory management, or a set of pages of physical memory (<b>109</b>).</p><p id="p-0096" num="0095">For example, a typical memory region (<b>137</b>) can have a respective security configuration (<b>107</b>) specified for the set of predefined domains (<b>101</b>, <b>103</b>, . . . , <b>105</b>). The security configuration (<b>107</b>) explicitly identify the permissions (e.g., <b>111</b>, <b>113</b>, . . . , <b>115</b>) for the domains (<b>101</b>, <b>103</b>, . . . , <b>105</b>) respectively. Thus, the privileges of routines to access the memory region (<b>137</b>) are not dependent on a hierarchy of the domains (<b>102</b>, <b>103</b>, . . . , <b>105</b>).</p><p id="p-0097" num="0096">In one example, when a routine executed in the current domain (<b>123</b>) causes memory access to the memory region (<b>137</b>) for read, write, or execution of instructions, the domain register (<b>117</b>) causes the security control (<b>119</b>) to check the permission specified in the setting (<b>111</b>, <b>113</b>, . . . , or <b>115</b>) that is corresponding to the current domain (<b>123</b>). Whether to block (or reject) an access to the memory region (<b>137</b>) for a particular type of operations (e.g., read, write, execution) by the execution of an instruction of the routine in the current domain (<b>123</b>) can be determined based on a respective permission bit that is selected according to the current domain (<b>123</b>) for the memory region (<b>137</b>), and for the type of operations. Some details and examples of permissions for memory access to the memory region (<b>137</b>) can be found in U.S. Pat. No. 10,915,457, issued on Feb. 9, 2021, which claims priority to U.S. Pat. App. Ser. No. 62/724,896, filed on Aug. 30, 2018 and entitled &#x201c;Memory Access Control through Permissions Specified in Page Table Entries for Execution Domains,&#x201d; the entire disclosure of which application is hereby incorporated herein by reference.</p><p id="p-0098" num="0097">In general, different routines of a same domain (e.g., <b>103</b>) can be configured to in different memory regions and thus configured to have different permissions and security settings for the same domain (e.g., <b>103</b>).</p><p id="p-0099" num="0098">Further, a routine can be configured to store different portions of its data in different memory regions (e.g., <b>137</b>) and thus configured to have different permissions for accessing from a same domain (e.g., <b>101</b>, <b>103</b>, . . . , or <b>105</b>).</p><p id="p-0100" num="0099">In another example, when a routine executed in the current domain (<b>123</b>) calls a called routine (<b>135</b>) stored in the memory region (<b>137</b>) for execution, the domain register (<b>117</b>) causes the security control (<b>119</b>) to check the permission specified in the setting (<b>111</b>, <b>113</b>, . . . , or <b>115</b>) that is corresponding to the current domain (<b>123</b>). Whether or not to deploy a security measure to protect the resources of the calling routine against the called routine (<b>135</b>) and/or protect the resources of the called routine (<b>135</b>) against the calling routine can be determined based on a respective permission bit that is specified for the current domain (<b>123</b>) and for the memory region (<b>137</b>).</p><p id="p-0101" num="0100">Security measures can include sandboxing. Sandboxing in general includes a computer security measure that isolates the execution of a set of instructions (e.g., an application) from certain system resources and/or other sets of instructions/programs. For example, sandboxing can be implemented using a shadow stack structure where the calling routine and the called routine are configured to use separate stacks and control registers related to the stacks, the calling routine can be prevented from accessing the stack assigned to the called routine, and the called routine can be prevented from accessing the stack assigned to the calling routine. Some details and examples of a shadow stack structure can be found in U.S. Pat. No. 10,942,863, issued Mar. 9, 2021, which claims priority to U.S. Pat. App. Ser. No. 62/724,913, filed on Aug. 30, 2018 and entitled &#x201c;Security Configurations in Page Table Entries for Execution Domains,&#x201d; the entire disclosure of which application is hereby incorporated herein by reference.</p><p id="p-0102" num="0101">For example, the security configuration (<b>107</b>) of a typical memory region (<b>137</b>) can have sandboxing settings (e.g., <b>111</b>, <b>113</b>, . . . , <b>115</b>) specified for the set of predefined domains (e.g., <b>101</b>, <b>103</b>, . . . , <b>105</b>) respectively. The sandboxing configuration (<b>107</b>) explicitly identifies whether or not a sandboxing operating is required for a call to execution a called routine (<b>135</b>) stored in the region (<b>137</b>). Calls to execute the same routine (<b>135</b>) from routines executed in the different domains (<b>101</b>, <b>103</b>, . . . , <b>105</b>) can have different settings (<b>111</b>, <b>113</b>, . . . , <b>115</b>); and the settings (<b>111</b>, <b>113</b>, . . . , <b>115</b>) specify whether the calls from the respectively domains (<b>101</b>, <b>103</b>, . . . , <b>105</b>) require sandboxing (e.g., to protect the called routine (<b>135</b>) and the calling routine from each other). Thus, the sandboxing operations can be selectively applied for the execution of the called routine (<b>135</b>) stored in the memory region (<b>137</b>), based on the current domain (<b>123</b>) identified in the domain register (<b>117</b>) and the explicit settings (e.g., <b>111</b>, <b>113</b>, . . . , <b>115</b>) configured for the respective domains (<b>101</b>, <b>103</b>, . . . , <b>105</b>), without relying upon a predefined hierarchy of domains (<b>102</b>, <b>103</b>, . . . , <b>105</b>).</p><p id="p-0103" num="0102">For example, a calling routine in the current domain (<b>123</b>) can call the called routine (<b>135</b>). Whether to invoke a sandboxing operation for the call to execute the called routine (<b>135</b>) stored in the memory region (<b>137</b>) can be determined based on the sandbox setting (e.g., <b>111</b>, <b>113</b>, . . . , or <b>115</b>) that is specified for the respective domain (e.g., <b>101</b>, <b>103</b>, . . . , or <b>105</b>) matching with the current domain (<b>123</b>) for the memory region (<b>137</b>). Thus, the sandboxing operation can be invoked independent of a relative hierarchy between the domain of the called routine (<b>135</b>) and the current calling domain (<b>123</b>).</p><p id="p-0104" num="0103">The sandbox settings (<b>107</b>) for routines stored in the memory region (<b>137</b>) can be specified, for example, in a page table entry used in logical to physical address translation of virtual memory addresses, such that the structure of the memory regions can correspond to the memory page structure, as further discussed below in connection with <figref idref="DRAWINGS">FIG. <b>7</b></figref>.</p><p id="p-0105" num="0104">In a further example, when a routine executed in the current domain (<b>123</b>) requests access to a privileged register (<b>133</b>), the domain register (<b>117</b>) causes the security control (<b>119</b>) to check the permission specified in the setting (<b>111</b>, <b>113</b>, . . . , or <b>115</b>) for the privileged register (<b>133</b>). Whether to permit or block the access can be determined based on a respective permission bit that is specified for the current domain (<b>123</b>) and for the privilege register (<b>133</b>).</p><p id="p-0106" num="0105">For example, the privileged register (<b>133</b>) can have different permissions (<b>111</b>, <b>113</b>, . . . , <b>115</b>) for the different domains (<b>101</b>, <b>103</b>, . . . , <b>105</b>) respectively. When an instruction executed in the current domain (<b>123</b>) requests to access the register privileged (<b>133</b>), the domain register (<b>117</b>) causes the security control (<b>119</b>) to select a respective permission (e.g., <b>111</b>, <b>113</b>, . . . , or <b>115</b>) corresponding to the current domain (<b>123</b>) to control the access.</p><p id="p-0107" num="0106">The register (<b>133</b>) can have explicit permissions (<b>111</b>, <b>113</b>, . . . , <b>115</b>) specified separately for the domains (<b>101</b>, <b>103</b>, . . . , <b>105</b>) respectively (e.g., non-hierarchical), without relying upon a predefined hierarchy of trust for the domains (<b>102</b>, <b>103</b>, . . . , <b>105</b>).</p><p id="p-0108" num="0107">In some instances, the privileged register (<b>133</b>) can be accessed for different types of operations, such as read, write, execution, etc. The permission (e.g., <b>111</b>, <b>113</b>, . . . , or <b>115</b>) for a particular domain (e.g., <b>101</b>, <b>103</b>, . . . , or <b>105</b>) to access the privileged register (<b>133</b>) can have separate permission bits for the respective types of operations (e.g., read, write, and/or execution).</p><p id="p-0109" num="0108">The security configuration (<b>107</b>) can be configured to allow an instruction running in one domain (e.g., <b>101</b>, <b>103</b>, . . . , <b>105</b>) to access the register (<b>133</b>) for one type of operations (e.g., read) but not for another type of operations (e.g., write).</p><p id="p-0110" num="0109">The security configuration (<b>107</b>) can be configured to allow an instruction executing in one domain (e.g., <b>103</b>) to access the register (e.g., <b>133</b>) via one permission setting (e.g., <b>113</b>) for the domain (e.g., <b>103</b>), but prohibit the same instruction running in another domain (e.g., <b>101</b>) from accessing the register (<b>133</b>) via another concurrent setting (e.g., <b>111</b>) for that domain (e.g., <b>101</b>), even when the disallowed domain (e.g., <b>101</b>) can be more privileged (and thus trusted) than the allowed domain (e.g., <b>103</b>) in traditional protection rings.</p><p id="p-0111" num="0110">In one implementation, the security configuration (<b>107</b>) is hardwired in a processor for the privileged register (<b>133</b>). In another implementation, the security configuration (<b>107</b>) can be set via firmware for the register (<b>133</b>) of a processor during a start-up/boot up process of a computer system. In a further implementation, the security configuration (<b>107</b>) can be changed via privileged software during the normal operations of the computer system.</p><p id="p-0112" num="0111">For example, the security configuration (<b>107</b>) for the privileged register (<b>133</b>) can be changed when the processor (<b>169</b>) switches from running a program in one domain (e.g., <b>101</b>) to running a program in another domain (e.g., <b>103</b>).</p><p id="p-0113" num="0112">For example, the security configuration (<b>107</b>) for the privileged register (<b>133</b>) can be changed in accordance with a request when the computer system switches from running one routine to another routine, where the routines can be in the same domain (e.g., <b>101</b>).</p><p id="p-0114" num="0113">For example, the security configuration (<b>107</b>) for the privileged register (<b>133</b>) can be configured in a permission register that controls access to the privileged register (<b>133</b>) using permission bits stored in the permission register; and the content of the permission register can be updated by an authorized process to adjust/customize the security level of the computer system for the current computation. Alternatively, permissions bits for different domains (<b>101</b>, <b>103</b>, . . . , <b>105</b>) can be specified in separate registers that correspond to the domains (<b>101</b>, <b>103</b>, . . . , <b>105</b>) respectively. Some details and examples of permission registers can be found in U.S. Pat. App. Pub. No. 2020/0074093, published Mar. 5, 2020, which claims priority to U.S. Pat. App. Ser. No. 62/724,929, filed on Aug. 30, 2018 and entitled &#x201c;Access Control for Processor Registers based on Execution Domains,&#x201d; the entire disclosure of which application is hereby incorporated herein by reference.</p><p id="p-0115" num="0114">Since the security control system of <figref idref="DRAWINGS">FIG. <b>6</b></figref> does not rely upon a predefined domain hierarchy of trust (i.e., non-hierarchical), it can provide better flexibility and finer control granularity than the conventional protection rings.</p><p id="p-0116" num="0115"><figref idref="DRAWINGS">FIG. <b>7</b></figref> illustrates a page table entry (<b>153</b>) having a security configuration (<b>107</b>) for execution domains (e.g., <b>101</b>, <b>103</b>, . . . , <b>105</b>).</p><p id="p-0117" num="0116">For example, the security configuration (<b>107</b>) in the page table entry can be permissions for accessing the memory region (<b>137</b>) identified by the page table entry (<b>153</b>) and/or sandboxing configuration for calling routines stored in the memory region (<b>137</b>) that is identified by the page table entry (<b>153</b>).</p><p id="p-0118" num="0117">A typical virtual address (<b>141</b>) in a virtual address space (<b>127</b>) can be translated into a corresponding physical address (<b>159</b>) in a physical address space (<b>129</b>) using a page table (<b>151</b>). In general, multiple page tables (e.g., <b>151</b>) can be used to map the virtual address space (<b>127</b>) to the physical address space (<b>129</b>).</p><p id="p-0119" num="0118">The virtual address (<b>141</b>) can include a table ID (<b>143</b>), an entry ID (<b>145</b>), and an offset (<b>147</b>). The table ID (<b>143</b>) can be used to identify a page table (<b>151</b>) that contains a page table entry (<b>153</b>) for a page that contains the memory unit that is identified by the virtual address (<b>141</b>) and the physical address (<b>159</b>). The entry ID (<b>145</b>) is used as an index into the page table (<b>151</b>) to locate the page table entry (<b>153</b>) efficiently. The page table entry (<b>153</b>) provides a base (<b>157</b>) of the physical address (<b>159</b>). Physical addresses in the same page of memory share the same base (<b>157</b>). Thus, the base (<b>157</b>) identifies the region (<b>137</b>) in the memory (<b>109</b>). The offset (<b>147</b>) of the virtual address (<b>141</b>) is used as a corresponding offset (<b>147</b>) in the page or region (<b>137</b>) in the memory (<b>109</b>). The combination of the base (<b>157</b>) and the offset (<b>147</b>) provides the physical address (<b>159</b>) corresponding to the virtual address (<b>141</b>).</p><p id="p-0120" num="0119">In <figref idref="DRAWINGS">FIG. <b>7</b></figref>, the page table entry (<b>153</b>) specifies not only the base (<b>157</b>) for the page or region (<b>137</b>), but also the security configuration (<b>107</b>) for the page or memory region (<b>137</b>), such as permissions for reading data into the memory region (<b>137</b>) corresponding to the base (<b>157</b>), permissions for writing data into the memory region (<b>137</b>), permissions for executing instructions stored in the memory region (<b>137</b>), sandboxing requirements for calling routines stored in the memory region (<b>137</b>). The security configuration (<b>107</b>) can have separate settings (<b>111</b>, <b>113</b>, . . . , <b>115</b>) respectively for the predefined, non-hierarchical domains (<b>101</b>, <b>103</b>, . . . , <b>105</b>) illustrated in <figref idref="DRAWINGS">FIGS. <b>1</b> and <b>6</b></figref>. The current domain (<b>123</b>) in the domain register (<b>117</b>) controls which one of the settings (<b>111</b>, <b>113</b>, . . . , <b>115</b>) is used for a current memory access, or a current call to a routine (<b>135</b>) stored in the memory region (<b>137</b>).</p><p id="p-0121" num="0120">Optionally, the page table entry (<b>153</b>) can specify other attributes (<b>155</b>) of the page of physical memory, such as whether the data in the page is valid, whether the page is in main memory, whether the page is dirty (e.g., the changes in data in the page of physical memory have not yet been flushed to a longer-term memory/storage device relative to the memory region (<b>137</b>)). For example, the attributes (<b>155</b>) can include a page fault bit indicating whether the page is in the main memory of the computer or in a storage device of the computer. If the permissions in the security configuration (<b>107</b>) allow the current access to the page of memory and the page fault bit indicate that the page is currently not in the main memory of the computer, the memory management unit (<b>181</b>) can swap the page from the storage device into the main memory of the computer to facilitate the access to the page identified by the page table entry (<b>153</b>). However, if the permissions in the security configuration (<b>107</b>) deny the current access to the page for the current execution domain, it is not necessary to evaluate the page fault bit and/or to swap in the page corresponding to the page table entry (<b>153</b>).</p><p id="p-0122" num="0121">In general, the table ID (<b>143</b>) can be divided into multiple fields used to locate the page table (<b>151</b>). For example, the table ID (<b>143</b>) can include a top table ID identifying a top-level page table and a top table entry ID that is used as an index into the top-level page table to retrieve a page table entry containing an identifier of the page table (<b>151</b>), in a way similar to the entry ID (<b>145</b>) indexing into the page table (<b>151</b>) to identify the page table entry (<b>153</b>) containing the base (<b>157</b>).</p><p id="p-0123" num="0122">In general, an entry ID (<b>145</b>) can be considered a virtual page number in the page table (<b>151</b>); and the virtual page number (e.g., <b>145</b>) can be used in the page table (<b>151</b>) to look up the page table entry (<b>153</b>) containing the base (<b>157</b>).</p><p id="p-0124" num="0123">For example, the table ID (<b>143</b>) can include a set of virtual page numbers that can be used to identify a chain of page tables (e.g., <b>151</b>). Each virtual page number is used as an index in a page table (or page directory) to identify the page table entry (or page directory entry) that contains the identity or base of the next level page table (or page directory).</p><p id="p-0125" num="0124">In some instances, different running processes in a computer can have different virtual address spaces (e.g., <b>127</b>); and the process ID of a running process can be used in determine the top-level page table (or page directory). In some instances, a hash of a portion of the virtual address (<b>141</b>), the process ID, and/or an identification of a virtual machine hosted in the computer system can be used to locate the top-level page table (or page directory). In some instances, a hash is used as an index or key to look up a page table entry. Regardless of how the page table entry (<b>153</b>) is located (e.g., via indexing through multiple page tables, via the use of a hash as an index or key), the content of the page table entry (<b>153</b>) can be configured in a way as illustrated in <figref idref="DRAWINGS">FIG. <b>7</b></figref> to provide the security configuration (<b>107</b>) for different domains (<b>101</b>, <b>103</b>, . . . , <b>105</b>) to access the page/memory region (<b>137</b>) and/or the routines stored in the memory region (<b>137</b>) that corresponds to the base (<b>157</b>).</p><p id="p-0126" num="0125">In <figref idref="DRAWINGS">FIG. <b>7</b></figref>, the security configuration (<b>107</b>) for a page or region (<b>137</b>) is specified in the bottom-level page table (<b>151</b>), where the page table entry (<b>153</b>) in the bottom-level page table (<b>151</b>) provides the base (<b>157</b>) of the physical address (<b>159</b>).</p><p id="p-0127" num="0126">Alternatively, or in combination, higher-level page tables (or page directories) can also have security configurations for their page table entries (or page directory entries). For example, a page table entry (or page directory entry) identifying the page table (<b>151</b>) can have security configurations for all of the pages in the page table (<b>151</b>); and thus, the domain permission data in the page table entry is applicable to the memory region defined by the page table (<b>151</b>). The hierarchy of security configurations in the chain of page table entries leading to the page table (<b>151</b>) and the security configuration (<b>107</b>) in the bottom-level page table entry (<b>153</b>) can be combined via a logic AND operation or a logic OR operation.</p><p id="p-0128" num="0127">For example, a routine running in a domain (e.g., <b>101</b>, <b>103</b>, . . . , <b>105</b>) can be allowed to access a page identified by the base (<b>157</b>) if all of the permission bits in the chain of page table entries leading to the base (<b>157</b>), including the bottom-level table entry (<b>153</b>), have the value that allows access. Alternatively, a routine running in a domain (e.g., <b>101</b>, <b>103</b>, . . . , <b>105</b>) can be allowed to access a page identified by the base (<b>157</b>) if any of the permission bits in the chain of page table entries leading to the base (<b>157</b>), including the bottom-level table entry (<b>153</b>), have the value that allows access.</p><p id="p-0129" num="0128">For example, a routine running in a domain (e.g., <b>101</b>, <b>103</b>, . . . , <b>105</b>) can be denied of access to a page identified by the base (<b>157</b>) if any of the permission bits in the chain of page table entries leading to the base (<b>157</b>), including the bottom-level table entry (<b>153</b>), have the value that denies access. Alternatively, a routine running in a domain (e.g., <b>101</b>, <b>103</b>, . . . , <b>105</b>) can be denied of access to a page identified by the base (<b>157</b>) only when all of the permission bits in the chain of page table entries leading to the base (<b>157</b>), including the bottom-level table entry (<b>153</b>), have the value that denies access.</p><p id="p-0130" num="0129">For example, when a non-bottom-level page table entry (or page directory entry) indicates that the memory access is prohibited, the operations to translate from the virtual address (<b>141</b>) to the physical address (<b>159</b>) can be interrupted to reject the memory access associated with the virtual address (<b>141</b>). In response to the rejection, a trap to the software designated to handle the rejection is used.</p><p id="p-0131" num="0130">For example, the security configuration (<b>107</b>) can include a set of sandbox setting bits (e.g., <b>111</b>, <b>113</b>, . . . , <b>115</b>) for the set of domains (<b>101</b>, <b>103</b>, . . . , <b>105</b>) respectively. When a sandbox setting bit (e.g., <b>111</b>, <b>113</b>, . . . , or <b>115</b>) corresponding to the current domain (<b>123</b>) in the domain register (<b>117</b>) is set to have a first value (e.g., 1 or 0), a current call from a routine in the current domain (<b>123</b>) to a called routine (<b>135</b>) stored in the region (<b>137</b>) is implemented to use a sandboxing operation to protect the calling routine and the called routine (<b>135</b>) from each other (e.g., by using a shadow stack to separate the caller and callee in stack usage). When a sandbox setting bit (e.g., <b>111</b>, <b>113</b>, . . . , or <b>115</b>) corresponding to the current domain (<b>123</b>) in the domain register (<b>117</b>) is set to have a second value (e.g., 0 or 1), a call from the routine in the current domain (<b>123</b>) to the called routine (<b>135</b>) stored in the memory region (<b>137</b>) is implemented without using the sandboxing operation to isolate the caller and callee from each other (e.g., without using a shadow stack).</p><p id="p-0132" num="0131">Optionally, the security configuration (e.g., <b>107</b>) is specified in the bottom-level page table (<b>151</b>) but not in the higher-level page tables (directories).</p><p id="p-0133" num="0132"><figref idref="DRAWINGS">FIG. <b>8</b></figref> shows a computer system having a domain register (<b>117</b>) controlling security operations.</p><p id="p-0134" num="0133">For example, the computer system of <figref idref="DRAWINGS">FIG. <b>8</b></figref> can optionally have a page table (e.g., <b>151</b>) storing security configuration (<b>107</b>) for accessing memory region identified by a page table entry (<b>153</b>) of <figref idref="DRAWINGS">FIG. <b>7</b></figref> by routines in predefined domains (<b>101</b>, <b>103</b>, . . . , <b>105</b>) illustrated in <figref idref="DRAWINGS">FIGS. <b>1</b> and <b>6</b></figref>. Further the computer system of <figref idref="DRAWINGS">FIG. <b>8</b></figref> can optionally have the domain access tables (<b>217</b>, . . . , <b>227</b>) of <figref idref="DRAWINGS">FIGS. <b>1</b> and <b>2</b></figref> to facilitate and secure domain crossing.</p><p id="p-0135" num="0134">For example, the computer system of <figref idref="DRAWINGS">FIG. <b>8</b></figref> can have one or more permission registers storing the security configuration (<b>107</b>) for accessing the privileged register (<b>133</b>) for predefined domains (<b>101</b>, <b>103</b>, . . . , <b>105</b>) illustrated in <figref idref="DRAWINGS">FIGS. <b>1</b> and <b>6</b></figref>.</p><p id="p-0136" num="0135">The domain register (<b>117</b>) of the processor (<b>169</b>) stores the identifier of the current domain (<b>123</b>). The content of the domain register (<b>117</b>) selects a set of applicable settings of the security configuration (<b>107</b>) corresponding to the current domain (<b>123</b>).</p><p id="p-0137" num="0136">The computer system of <figref idref="DRAWINGS">FIG. <b>8</b></figref> has a host system (<b>165</b>) coupled to a memory system (<b>161</b>) via one or more buses (<b>163</b>). The memory system (<b>161</b>) has memory components (<b>171</b>, . . . , <b>173</b>).</p><p id="p-0138" num="0137">For example, the buses (<b>163</b>) can include a memory bus connecting to one or more memory modules and/or include a peripheral internet connecting to one or more storage devices. Some of the memory components (<b>171</b>, . . . , <b>173</b>) can provide random access; and the some of the memory components (<b>171</b>, . . . , <b>173</b>) can provide persistent storage capability. Some of the memory components (<b>171</b>, . . . , <b>173</b>) can be volatile in that when the power supply to the memory component is disconnected temporarily, the data stored in the memory component will be corrupted and/or erased. Some of the memory components (<b>171</b>, . . . , <b>173</b>) can be non-volatile in that the memory component is capable of retaining content stored therein for an extended period of time without power.</p><p id="p-0139" num="0138">In general, a memory system (<b>161</b>) can also be referred to as a memory device. An example of a memory device is a memory module that is connected to a central processing unit (CPU) via a memory bus. Examples of memory modules include a dual in-line memory module (DIMM), a small outline DIMM (SO-DIMM), a non-volatile dual in-line memory module (NVDIMM), etc. Another example of a memory device is a storage device that is connected to the central processing unit (CPU) via a peripheral interconnect (e.g., an input/output bus, a storage area network). Examples of storage devices include a solid-state drive (SSD), a flash drive, a universal serial bus (USB) flash drive, and a hard disk drive (HDD). In some instances, the memory device is a hybrid memory/storage system that provides both memory functions and storage functions.</p><p id="p-0140" num="0139">The memory components (<b>171</b>, . . . , <b>173</b>) can include any combination of the different types of non-volatile memory components and/or volatile memory components. An example of non-volatile memory components includes a negative-and (NAND) type flash memory with one or more arrays of memory cells such as single level cells (SLCs) or multi-level cells (MLCs) (e.g., triple level cells (TLCs) or quad-level cells (QLCs)). In some instances, a particular memory component can include both an SLC portion and an MLC portion of memory cells. Each of the memory cells can store one or more bits of data (e.g., data blocks) used by the host system (<b>165</b>). Alternatively, or in combination, a memory component (<b>171</b>, . . . , or <b>173</b>) can include a type of volatile memory. In some instances, a memory component (<b>171</b>, . . . , or <b>173</b>) can include, but is not limited to, random access memory (RAM), read-only memory (ROM), dynamic random access memory (DRAM), synchronous dynamic random access memory (SDRAM), phase change memory (PCM), magneto random access memory (MRAM), spin transfer torque (STT)-MRAM, ferroelectric random-access memory (FeTRAM), ferroelectric RAM (FeRAM), conductive bridging RAM (CBRAM), resistive random access memory (RRAM), oxide based RRAM (OxRAM), negative-or (NOR) flash memory, electrically erasable programmable read-only memory (EEPROM), nanowire-based non-volatile memory, memory that incorporates memristor technology, and/or a cross-point array of non-volatile memory cells. A cross-point array of non-volatile memory can perform bit storage based on a change of bulk resistance, in conjunction with a stackable cross-gridded data access array. Additionally, in contrast to many flash-based memories, cross-point non-volatile memory can perform a write in-place operation, where a non-volatile memory cell can be programmed without the non-volatile memory cell being previously erased.</p><p id="p-0141" num="0140">In general, a host system (<b>165</b>) can utilize a memory system (<b>161</b>) as physical memory (<b>109</b>) that includes one or more memory components (<b>171</b>, . . . , <b>173</b>). The host system (<b>165</b>) can load instructions from the memory system (<b>161</b>) for execution, provide data to be stored at the memory system (<b>161</b>), and request data to be retrieved from the memory system (<b>161</b>).</p><p id="p-0142" num="0141">In <figref idref="DRAWINGS">FIG. <b>8</b></figref>, the host system (<b>165</b>) includes a memory management unit (MMU) (<b>181</b>) and a processor (<b>169</b>). The processor (<b>169</b>) has execution units (e.g., <b>185</b>), such as an arithmetic-logic unit. The processor (<b>169</b>) has registers (<b>183</b>, e.g., <b>133</b>) to hold instructions for execution, data as operands of instructions, and/or results of instruction executions. The processor (<b>169</b>) can have an internal cache (<b>187</b>) as a proxy of a portion of the memory system (<b>161</b>).</p><p id="p-0143" num="0142">In some instances, the host system (<b>165</b>) can include multiple processors (e.g., <b>169</b>) integrated on a same silicon die as multiple processing cores of a central processing unit (CPU).</p><p id="p-0144" num="0143">Routines programmed for executing in the processor (<b>169</b>) can be initially stored in the memory system (<b>161</b>). The routines can include instructions for a hypervisor (<b>102</b>), an operating system (<b>104</b>), and an application (<b>106</b>). The routines stored initially in the memory system (<b>161</b>) can be loaded to the internal cache (<b>187</b>) and/or the registers (<b>183</b>, e.g., <b>133</b>) for execution in the execution units (<b>185</b>).</p><p id="p-0145" num="0144">The running instances of the routines form the executions (<b>167</b>) of the hypervisor (<b>102</b>), the operating system (<b>104</b>), and the application (<b>106</b>). In some instances, a hypervisor (<b>102</b>) is not used; and the operating system (<b>104</b>) controls the hardware components (e.g., the memory system (<b>161</b>), peripheral input/output devices, and/or network interface cards) without a hypervisor.</p><p id="p-0146" num="0145">The executions (<b>167</b>) of the hypervisor (<b>102</b>), the operating system (<b>104</b>), and/or the application (<b>106</b>) access memory (<b>137</b>) (e.g., in memory components (<b>171</b>, . . . , <b>173</b>)) using virtual memory addresses (e.g., <b>141</b>) defined in one or more virtual memory spaces (e.g., <b>127</b>). At least one page table (<b>151</b>) (e.g., as illustrated in the <figref idref="DRAWINGS">FIG. <b>7</b></figref>) can be used to translate the virtual memory addresses (e.g., <b>141</b>) used in the execution to the physical memory addresses (e.g., <b>159</b>) of the memory components (e.g., <b>171</b>, . . . , <b>173</b>).</p><p id="p-0147" num="0146">As illustrated in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the executions of the routines of hypervisor (<b>102</b>), the operating system (<b>104</b>), and the application (<b>106</b>) can be organized into a plurality of domains (<b>101</b>, <b>103</b>, . . . , <b>105</b>). For each of the execution domains (<b>101</b>, <b>103</b>, . . . , <b>105</b>) and a memory region (<b>137</b>) identified by a page table entry (<b>153</b>), the page table entry (<b>153</b>) identifies a set (e.g., <b>111</b>, <b>113</b>, . . . , <b>115</b>) of security configuration bits for accessing the region (<b>137</b>) in predefined types of operations such as read, write, execution, etc. The configuration bits of the corresponding security configuration (e.g., <b>107</b>) controls the memory accesses of the corresponding types from a respective execution domain (e.g., <b>101</b>) and/or controls the sandboxing operations for isolating calling routines and called routines (e.g., <b>135</b>).</p><p id="p-0148" num="0147">The security configuration (<b>107</b>) of the privileged register (<b>133</b>) can be stored in separate permission registers. Each of the permission registers is pre-associated with a domain (e.g., <b>101</b>, <b>103</b>, . . . , <b>105</b>). A permission register stores a permission bit for accessing the privileged register (<b>133</b>) from the corresponding domain (e.g., <b>101</b>, <b>103</b>, . . . , or <b>105</b>). Different permission bits in the permission register can be configured for different privileged registers (e.g., <b>133</b>). In some instances, a privileged register (<b>133</b>) can have multiple permission bits in a permission register for different types of accesses (e.g., read, write, execution).</p><p id="p-0149" num="0148">Alternatively, permission bits for the privileged register (<b>133</b>) can be specified in a same permission register. Further, permission bits for different privileged register (e.g., <b>133</b>) can be stored in different portions of the same permission register.</p><p id="p-0150" num="0149"><figref idref="DRAWINGS">FIG. <b>9</b></figref> shows a method to perform address translation for a virtual machine in accordance with a virtual machine register.</p><p id="p-0151" num="0150">For example, the method of <figref idref="DRAWINGS">FIG. <b>9</b></figref> can be performed in a computer system of <figref idref="DRAWINGS">FIG. <b>1</b> or <b>8</b></figref>. The method of <figref idref="DRAWINGS">FIG. <b>9</b></figref> can be performed in combination of address translation techniques of <figref idref="DRAWINGS">FIGS. <b>2</b>-<b>5</b> and <b>7</b></figref> and/or the security techniques of <figref idref="DRAWINGS">FIGS. <b>6</b>-<b>8</b></figref>.</p><p id="p-0152" num="0151">At block <b>301</b>, a memory (<b>109</b>) stores at least instructions of routines of a predefined set of domains (<b>101</b>, <b>103</b>, . . . , <b>105</b>).</p><p id="p-0153" num="0152">For example, the predefined set of domains can include at least one of a domain for hypervisor, a domain for operating system, or a domain for application, or any combination thereof.</p><p id="p-0154" num="0153">At block <b>303</b>, a computer system provides, in a processor (<b>169</b>) coupled with the memory (<b>109</b>), a virtual machine register (<b>231</b>).</p><p id="p-0155" num="0154">At block <b>305</b>, the processor (<b>169</b>) stores, in the virtual machine register (<b>231</b>) an identifier of a virtual machine for which the processor (<b>169</b>) is currently executing instructions in one of the domains.</p><p id="p-0156" num="0155">At block <b>307</b>, the processor (<b>169</b>) implements resource restrictions for the virtual machine based on the identifier stored in the virtual machine register (<b>231</b>) in executing instructions in the virtual machine.</p><p id="p-0157" num="0156">For example, the processor (<b>169</b>) can be configured to trap an operation performed in execution of an operating system (<b>104</b>) running in the virtual machine in generating a page table entry mapping a virtual address page to a pseudo-physical address page. In response to the operation of the operating system (<b>104</b>) running in the virtual machine is trapped, the processor (<b>169</b>) is configured to execute a routine of a hypervisor (<b>102</b>) to identify a physical address page corresponding to the pseudo-physical address page in the virtual machine. The processor (<b>169</b>) is configured to modify the page table entry mapping the virtual address page to the pseudo-physical address page into a page table entry mapping the virtual address page to the physical address page, such that subsequent translation from the pseudo-physical addresses in the virtual machine to the physical addresses in the memory (<b>109</b>) can be avoided for the virtual address page.</p><p id="p-0158" num="0157">At block <b>309</b>, the processor (<b>169</b>) translates a virtual memory address (<b>195</b> or <b>141</b>) to a physical memory address (<b>129</b>) based at least in part on the identifier stored in the virtual machine register (<b>231</b>).</p><p id="p-0159" num="0158">For example, the processor (<b>169</b>) can look up an address translation table using the identifier stored in the virtual machine register, as discussed above in connection with <figref idref="DRAWINGS">FIG. <b>3</b></figref>.</p><p id="p-0160" num="0159">For example, the processor (<b>169</b>) can generate an index (<b>125</b>) based at least in part on the identifier stored in the virtual machine register (<b>231</b>) and retrieve an entry (<b>250</b>) from an address translation table (<b>217</b>) using the index (<b>125</b>) to convert a virtual address (<b>195</b> or <b>141</b>) to a physical address (<b>159</b>).</p><p id="p-0161" num="0160">For example, the processor (<b>169</b>) can combine a portion of the virtual address (<b>195</b> or <b>141</b>) and the identifier stored in the virtual machine register (<b>231</b>) and hashes (<b>121</b>) the combination to generate the index (<b>125</b>). The portion of the virtual address (<b>195</b> or <b>141</b>) used to generate the index via hashing (<b>121</b>) can include an object identifier (<b>199</b>), an object type (<b>198</b>), and/or a portion of an offset (<b>196</b>) within the object identified by the object identifier (<b>199</b>). In some instances, the combination that is hashed (<b>121</b>) to generate the index (<b>125</b>) can further include a process identifier and/or the identifier of current domain (<b>123</b>) stored in the domain register (<b>117</b>).</p><p id="p-0162" num="0161">The techniques disclosed herein can be applied to at least to computer systems where processors are separated from memory and processors communicate with memory and storage devices via communication buses and/or computer networks. Further, the techniques disclosed herein can be applied to computer systems in which processing capabilities are integrated within memory/storage. For example, the processing circuits, including executing units and/or registers of a typical processor, can be implemented within the integrated circuits and/or the integrated circuit packages of memory media to perform processing within a memory device. Thus, a processor (e.g., <b>101</b>) as discussed above and illustrated in the drawings is not necessarily a central processing unit in the von Neumann architecture. The processor can be a unit integrated within memory to overcome the von Neumann bottleneck that limits computing performance as a result of a limit in throughput caused by latency in data moves between a central processing unit and memory configured separately according to the von Neumann architecture.</p><p id="p-0163" num="0162">The description and drawings of the present disclosure are illustrative and are not to be construed as limiting. Numerous specific details are described to provide a thorough understanding. However, in certain instances, well known or conventional details are not described in order to avoid obscuring the description. References to one or an embodiment in the present disclosure are not necessarily references to the same embodiment; and, such references mean at least one.</p><p id="p-0164" num="0163">In the foregoing specification, the disclosure has been described with reference to specific exemplary embodiments thereof. It will be evident that various modifications can be made thereto without departing from the broader spirit and scope as set forth in the following claims. The specification and drawings are, accordingly, to be regarded in an illustrative sense rather than a restrictive sense.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A device, comprising:<claim-text>a processor, having:<claim-text>at least one execution unit;</claim-text><claim-text>a memory management unit; and</claim-text><claim-text>a virtual machine register;</claim-text></claim-text><claim-text>wherein the processor is configured to:<claim-text>store, in the virtual machine register, an identifier of a virtual machine having instructions being executed by the at least one execution unit;</claim-text><claim-text>store, in the memory management unit, entries of address translation tables;</claim-text><claim-text>determine a first base of address translation table;</claim-text><claim-text>combine the first base and the identifier of the virtual machine to generate a second base of address translation table; and</claim-text><claim-text>translate, using the memory management unit, virtual memory addresses used by the instructions to physical memory addresses using the second base.</claim-text></claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>a memory having the physical memory addresses.</claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the processor is further configured to select the first base from a plurality of candidates.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The device of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the processor is further configured to confine an operating system executed on the virtual machine to a portion of the memory provisioned to the virtual machine.</claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The device of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the processor is further configured to select the first base from the plurality of candidates configured for a current domain of routines.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the processor is configured to convert pseudo-physical addresses used in the virtual machine to physical addresses in the memory based on the identifier stored in the virtual machine register.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the processor is configured to use a portion of a virtual address to generate an index to access an entry in an address translation table.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The device of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein the processor is configured to hash a combination of the portion of the virtual address and the identifier to generate the index.</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The device of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the portion of the virtual address includes an object identifier specified in the virtual address.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. A method, comprising:<claim-text>storing, in a virtual machine register configured in a processor having at least one execution unit, an identifier of a virtual machine having instructions being executed by the at least one execution unit;</claim-text><claim-text>storing, in a memory management unit of the processor, entries of address translation tables;</claim-text><claim-text>determining a first base of address translation table;</claim-text><claim-text>combining the first base and the identifier of the virtual machine to generate a second base of address translation table; and</claim-text><claim-text>translating, using the memory management unit, virtual memory addresses used by the instructions to physical memory addresses of a memory using the second base.</claim-text></claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, further comprising:<claim-text>selecting the first base from a plurality of candidates.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, further comprising:<claim-text>confining an operating system executed on the virtual machine to a portion of the memory provisioned to the virtual machine.</claim-text></claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the plurality of candidates are configured for a current domain of routines.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, further comprising:<claim-text>converting pseudo-physical addresses used in the virtual machine to physical addresses in the memory based on the identifier stored in the virtual machine register.</claim-text></claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, further comprising:<claim-text>generating, using a portion of a virtual address, an index to access an entry in an address translation table.</claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The method of <claim-ref idref="CLM-00015">claim 15</claim-ref>, further comprising:<claim-text>hashing a combination of the portion of the virtual address and the identifier to generate the index.</claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The method of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the portion of the virtual address includes an object identifier specified in the virtual address.</claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. An apparatus, comprising:<claim-text>a memory;</claim-text><claim-text>a memory management unit configured to store entries of address translation tables and perform address translation using the address translation tables;</claim-text><claim-text>at least one execution unit; and</claim-text><claim-text>a register configured to store an identifier of a virtual machine having instructions loaded from the memory for execution in the at least one execution unit;</claim-text><claim-text>wherein the apparatus is configured to:<claim-text>determine a first base of address translation table;</claim-text><claim-text>combine the first base and the identifier of the virtual machine to generate a second base of address translation table; and</claim-text><claim-text>translate, using the memory management unit, virtual memory addresses used by the instructions to physical memory addresses using the second base.</claim-text></claim-text></claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The apparatus of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein the memory management unit is configured to hash a combination of the identifier stored in the register and a portion of the virtual memory address to generate an index and apply the index to locate a page table entry to translate the virtual memory address to a physical memory address in the memory.</claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The apparatus of <claim-ref idref="CLM-00019">claim 19</claim-ref>, wherein the apparatus is further configured to convert a page table entry mapping a virtual memory page to a pseudo-physical memory page in the virtual machine to a page table entry mapping the virtual memory page to a physical memory page.</claim-text></claim></claims></us-patent-application>