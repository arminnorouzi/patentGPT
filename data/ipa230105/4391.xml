<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004392A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004392</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17367367</doc-number><date>20210704</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>30</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>02</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>30101</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>023</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>2212</main-group><subgroup>251</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">Processor with Split Read</invention-title><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>MELLANOX TECHNOLOGIES, LTD.</orgname><address><city>Yokneam</city><country>IL</country></address></addressbook><residence><country>IL</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Haramaty</last-name><first-name>Zachy</first-name><address><city>Hemed</city><country>IL</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Strassberg</last-name><first-name>Yaniv</first-name><address><city>Yokneam</city><country>IL</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>Levi</last-name><first-name>Itsik</first-name><address><city>Shapir</city><country>IL</country></address></addressbook></inventor><inventor sequence="03" designation="us-only"><addressbook><last-name>Singer</last-name><first-name>Alon</first-name><address><city>Tel Aviv</city><country>IL</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">An apparatus includes a processor and split-read control circuitry (SRCC). The processor is to issue a set of one or more split-read requests for loading one or more data values to one or more respective local registers of the processor. The SRCC is to receive the set of one or more split-read requests, to read the one or more data values on behalf of the processor, and to write the data values into the one or more respective local registers. The processor and the SRCC are to coordinate a status of the split-read requests via a split-read-status indication.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="101.52mm" wi="158.75mm" file="US20230004392A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="187.11mm" wi="134.11mm" orientation="landscape" file="US20230004392A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="246.04mm" wi="148.84mm" orientation="landscape" file="US20230004392A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="241.38mm" wi="151.13mm" orientation="landscape" file="US20230004392A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="236.22mm" wi="159.17mm" orientation="landscape" file="US20230004392A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">FIELD OF THE INVENTION</heading><p id="p-0002" num="0001">The present invention relates generally to computer systems, and particularly to methods and systems for split read cycles in computer systems.</p><heading id="h-0002" level="1">BACKGROUND OF THE INVENTION</heading><p id="p-0003" num="0002">Computer systems sometimes use split response memory read cycles (referred to hereinbelow as Split-Read cycles), wherein a processor requests a memory read operation, and a memory-subsystem responds with the requested data (and, sometimes, with an Acknowledge (ACK) or a Negative Acknowledge (HACK) indication).</p><p id="p-0004" num="0003">U.S. Pat. No. 8,244,950 describes an interface technique where non-split read requests are received from at least one requestor, and upstream commands based on these requests are transmitted, wherein response data is received in reply to commands that were previously transmitted, and responses are transmitted to a requester based on the response data; including a buffer unit for storing command identification data that identifies commands that were already transmitted or that are still to be transmitted, and response availability data that specifies response data that has been received by the receive engine.</p><heading id="h-0003" level="1">SUMMARY OF THE INVENTION</heading><p id="p-0005" num="0004">An embodiment of the present invention that is described herein provides an apparatus including a processor and split-read control circuitry (SRCC). The processor is to issue a set of one or more split-read requests for loading one or more data values to one or more respective local registers of the processor. The SRCC is to receive the set of one or more split-read requests, to read the one or more data values on behalf of the processor, and to write the data values into the one or more respective local registers. The processor and the SRCC are to coordinate a status of the split-read requests via a split-read-status indication.</p><p id="p-0006" num="0005">In some embodiments, the processor is to specify, in the split-read-status indication, a number of the split-read requests in the set, and the SRCC is to update the split-read-status indication upon writing each of the data values into the local registers. In an embodiment, the split-read-status indication includes a respective indicator for each split-read request in the set, each indicator indicating whether the respective split-read request has been completed by the SRCC. In a disclosed embodiment, the processor is to suspend an instruction that accesses a local register, in response to identifying in the split-read-status indication that a split-read request corresponding to the local register is not yet completed</p><p id="p-0007" num="0006">In some embodiments, the processor is to specify, in the set, two or more local registers having sequential indices. In an example embodiment, the processor is to specify to the SRCC an index of a first local register in the set. In an embodiment, the SRCC is to serve a split-read request on behalf of the processor by (i) issuing an external memory read request corresponding to the split-read request, (ii) assigning a tag to the external memory read request, and upon receiving an external memory read response having the tag, storing a data value provided in the external memory read response in a local register specified by the split-read request.</p><p id="p-0008" num="0007">There is additionally provided, in accordance with an embodiment of the present invention, a method including issuing, by a processor, a set of one or more split-read requests for loading one or more data values to one or more respective local registers of the processor. Using spit-read control circuitry (SRCC), the set of one or more split-read requests is received from the processor, the one or more data values are read on behalf of the processor, and the data values are written into the one or more respective local registers. A status of the split-read requests is coordinated between the processor and the SRCC via a split-read-status indication.</p><p id="p-0009" num="0008">There also provided, in accordance with an embodiment of the present invention, a method for executing read requests on behalf of a processor. The method includes receiving, from the processor, a set of read requests that request loading data values to respective local registers of the processor. The data values are read on behalf of the processor from a memory. The data values, which were read from the memory, are written into the local registers of the processor.</p><p id="p-0010" num="0009">The present invention will be more fully understood from the following detailed description of the embodiments thereof, taken together with the drawings in which:</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram that schematically describes a Processor System, in accordance with an embodiment of the present invention;</p><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a block diagram that schematically illustrates the structure of a Split Read Control Circuit (SRCC), in accordance with an embodiment of the present invention;</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a sequence diagram that schematically illustrates timed messages in a split-read sequence, accordance with an embodiment of the present invention; and</p><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a flowchart that schematically illustrates a method for executing split reads in a processor system, in accordance with an embodiment of the present invention.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0005" level="1">DETAILED DESCRIPTION OF EMBODIMENTS</heading><heading id="h-0006" level="1">Overview</heading><p id="p-0015" num="0014">The performance of processor systems is often limited by memory access latency. With small Random-Access Memories (RAMS) that are near the processor, performance degradation may be small (e.g., one additional clock cycle), but when large memory subsystems are accessed, performance may be severely degraded.</p><p id="p-0016" num="0015">In the description hereinbelow we will refer to processors and processor systems, wherein a processor is an apparatus that is configured to execute instructions, such as one or more central processing units (CPUs), Graphic Processor Units&#x2014;(CPUs), and similar; whereas a processor system is an apparatus comprising a processor and processor peripheral circuits, such as encryption circuits, DMA circuits etc.</p><p id="p-0017" num="0016">To mitigate the memory access performance degradation problem, two main techniques can be used&#x2014;a hierarchical memory structure and/or posted memory cycles. Hierarchical memory structure refers to a computer that has a hierarchy of memories, from a very small and very fast cache memory and down to very large memories that are very slow (e.g., Flash memories).</p><p id="p-0018" num="0017">The other technique to mitigate memory-access related performance degradation is posted memory cycles (sometimes called posted memory cycles). In posted-Write, for example, a processor posts a write request; a memory controller then executes the write; the processor does not have to wait for the write operation to complete, until the processor (or, sometimes, another processor that can access the memory) reads the written data. In Split-Read, the processor posts a read request, and may proceed to execute other instructions (including posting other read requests) until the processor needs the requested data (Various techniques are used to guarantee data integrity, particularly in multi-processing systems, including, for example, memory fencing.)</p><p id="p-0019" num="0018">While posted-Write implementation is relatively simple, Split-Read is more demanding. For example, memory responses may arrive out-of-order, and the processor should be notified when the read operation (or a sequence of read operations) completes.</p><p id="p-0020" num="0019">Embodiments according to the present invention provide apparatuses and methods for efficient split-read operations in a processor system. In some embodiments, a processor issues a series of split read requests to load data in a group of local registers of the processor, to a Split-Reads Control Circuit (SRCC). The SRCC is configured to receive the series of split read requests, to immediately acknowledge the request, and to submit a corresponding series of memory read requests to a memory subsystem In an embodiment, the SRCC is configured, upon receiving a response from the memory subsystem, to immediately write the received data into a corresponding local register of the processor. In some embodiments, the processor indicates to the SRCC the number of read requests in a group of split read requests that the processor will issue, and the SRCC indicates to the processor when the series of split reads has been fully completed; in an embodiment, the indication is stored in a bit-map status register and in another embodiment, the indication is a request-completion count.</p><p id="p-0021" num="0020">In some embodiments, the SRCC is configured to add tags to the memory subsystem requests, and to use the tags to reorder responses that the SRCC may receive of from the memory subsystem.</p><p id="p-0022" num="0021">In an embodiment, the local registers to which the split reads correspond are sequentially-indexed; the processor is configured to send to the SRCC, prior to the series of split reads, the index of the first local register to which the first split read corresponds, and the SRCC is configured to increment the index of the first local register in further split read requests, so as to obtain a pointer to the local register for each split read.</p><p id="p-0023" num="0022">Thus, according to embodiments of the present invention, processor systems may post read requests, and a SRCC handles the requests efficiently and with minimal processor intervention.</p><heading id="h-0007" level="1">System Description</heading><p id="p-0024" num="0023">In the description of embodiments hereinbelow, we will refer mainly to processors comprising a Central Processing Unit (CPU) that executes a software program. Embodiments in accordance with the present invention, however, are not limited to processors that comprise a CPU. In alternative embodiments, the processor may comprise multiple CPUs; in an embodiment, the processor comprises one or more Graphic Processor Units (CPUs); in other embodiments, other types of processors may be used, such as network processors, video processors, and any combination of processors.</p><p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram that schematically describes a Processor System <b>100</b>, in accordance with an embodiment of the present invention Processor System <b>100</b> is coupled to a memory subsystem <b>102</b>, which is configured to store data and instructions that the processor system may access.</p><p id="p-0026" num="0025">Processor System <b>100</b> comprises a Processor <b>104</b>, which is configured to run software programs that may include accessing memory subsystem <b>102</b> for instructions and/or for data. In an embodiment, the processor is configured to post read requests for efficient execution of one or more read operations.</p><p id="p-0027" num="0026">In some embodiments, processor <b>104</b> further comprises local registers <b>106</b>, and the split read requests read data from the memory subsystem to one or more of processor local registers <b>106</b>. Each one of local registers <b>106</b> is identified by a unique index; in embodiments, the indices of the local register are sequential. (For brevity, we will refer hereinbelow to a register with index=n as register-n, or local register-n.)</p><p id="p-0028" num="0027">According to the example embodiment illustrated in</p><p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. <b>1</b></figref>, Processor System <b>100</b> further comprises a Split-Read-Control-Circuit (SRCC) <b>108</b>. The SRCC is configured to: i) receive from processor <b>104</b> one or more split-read requests, ii) falsely acknowledging the Read requests (so that the processor will not wait for the read to complete), send in the requests to Memory Subsystem <b>102</b>, iv) upon receiving a response from the memory subsystem&#x2014;writing the read data into a respective local register of processor registers <b>106</b> and, v) updating a split-read status register that the processor may read.</p><p id="p-0030" num="0029">In the description hereinbelow we will sometimes refer to the local register into which a split-read request loads the read data, as the target register of the respective read request.</p><p id="p-0031" num="0030">In an embodiment, after sending the group of split read requests to the SRCC, the processor continues program execution until a point in which program execution requires reading a local register which is the target register of one of the split reads. When this point is reached, the processor may check the split-read status indication, and, responsively, either continue program execution or wait.</p><p id="p-0032" num="0031">Thus, according to the example embodiment illustrated in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the processor may issue a group of split-read requests; a SRCC accesses the memory subsystem to execute the read requests; the processor may continue program execution until all read requests are split, and then, when needed, waits until the split read requests are fulfilled.</p><p id="p-0033" num="0032">As would be appreciated, the configuration of processor system <b>100</b> illustrated in <figref idref="DRAWINGS">FIG. <b>1</b></figref> and described above is an example configuration that is cited by way of example. Other suitable configurations may be used in alternative embodiments. For example, in some embodiments, a single SRCC may support split reads for more than a single processor. In some embodiments, SRCC <b>108</b> may comprise memory mapping functions and in other embodiments the SRCC may comprise memory protection functions.</p><p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a block diagram that schematically illustrates the structure of Split Read Control Circuit (SRCC) <b>108</b>, in accordance with an embodiment of the present invention. As explained above with reference to <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the SRCC executes split read instructions from memory subsystem <b>102</b> that processor <b>104</b> requests and writes the results directly in local registers <b>106</b>. Each of local registers <b>106</b> is accessed by an index number.</p><p id="p-0035" num="0034">SRCC <b>100</b> comprises a SRCC Controller <b>200</b>. A First-Reg-index Register <b>202</b>, a Num-of-Split-Reads Register <b>204</b>, a Completion-Bitmap Register <b>206</b>, and a Tag-to-Reg-Index Translator <b>208</b>. Prior to sending a group of split read requests, the processor may send to the SRCC the index of the target local processor register of the first split-read, to be stored in the First-Reg-Index Register <b>202</b>. The processor may then send to the SRCC the number of split read requests in the group, to be stored in the Num-of-Split-Reads Register <b>204</b>.</p><p id="p-0036" num="0035">After storing the first register index and the number of split reads in the corresponding SRCC registers, the processor may issue the group of split read requests. In an embodiment, the requests pertain to target local registers having sequential indexes, wherein the index of the first register is the number stored in First-Reg-Index Register <b>202</b>. For example, if the processor sends a value &#x201c;8&#x201d; to the SRCC, to be stored in First-Reg-Index Register <b>202</b>, and a value &#x201c;3&#x201d;, to be stored in the Num-of-Split-Reads Register <b>204</b>; then, the first subsequent split-read request that the processor sends will request reading data from memory and storing the data in local register-8, the second request will request storing the read data in local register-9 and the third read request will read data to local register-10. In embodiments, the SRCC immediately acknowledges each split-read request (although the corresponding read has not finished), allowing the processor to proceed rather than wait for the read completion.</p><p id="p-0037" num="0036">The SRCC Controller issues memory read requests that correspond to the split-read requests, to memory subsystem <b>102</b>. In an embodiment, the SRCC Controller attaches a 0-tag to the first request, a 1-tag to the second request, and so on. When the SRCC receives from the memory subsystem responses to the memory requests, the Tag-to-Reg-Index Translator circuit <b>208</b> translates the received tag to a target local register index (e.g., by adding the contents of the First-Reg-Index register to the received tag). The SRCC control then writes the data returned from the memory subsystem into the target local processor register.</p><p id="p-0038" num="0037">In parallel, responsively to the memory subsystem response, Completion-Bitmap Register <b>206</b> updates, for example, by setting a bit that corresponds to the respective target register. The processor will, by examining the contents of the Completion-Bitmap Register, determine whether the program should wait or proceed.</p><p id="p-0039" num="0038">As would be appreciated, the configuration of SRCC <b>108</b> illustrated in <figref idref="DRAWINGS">FIG. <b>2</b></figref> and described above is cited by way of example. Any other suitable configurations may be used in alternative embodiments. For example, in some embodiments, a Split-Read-Completion counter replaces the completion bitmap register; in an embodiment, the Num-of-Split-Reads register is replaced by a Last-Reg-Index register, and in another embodiments the register index or a mapping thereof is used as the tag.</p><heading id="h-0008" level="1">Order of Events</heading><p id="p-0040" num="0039"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a sequence diagram that schematically illustrates timed messages in a spilt-read sequence <b>300</b>, in accordance with an embodiment of the present invention. The sequence diagram illustrates messages communicated between processor <b>104</b>, SRCC <b>108</b> and memory subsystem <b>102</b> (<figref idref="DRAWINGS">FIG. <b>1</b></figref>). In addition, sequence diagram <b>300</b> illustrates the status of Completion Bitmap Register <b>206</b> (<figref idref="DRAWINGS">FIG. <b>2</b></figref>).</p><p id="p-0041" num="0040">The first communication message is a message <b>302</b>, wherein the processor writes &#x201c;10&#x201d; into the SRCC's First_Reg_Index register <b>206</b> (<figref idref="DRAWINGS">FIG. <b>2</b></figref>), indicating that the target local register of the first split-read in the ensuing split-read sequence will be local register-10. Next, at a message <b>304</b>, the processor writes &#x201c;3&#x201d; into SRCC Num-of-Split-Reads register <b>204</b> (<figref idref="DRAWINGS">FIG. <b>2</b></figref>). In some embodiments, the order of messages <b>302</b> and <b>304</b> may be interchanged; in embodiment, both messages <b>302</b> and <b>304</b> may be coalesced to a single message.</p><p id="p-0042" num="0041">Next, the processor sends a first split read request <b>306</b>, asking that the data in memory subsystem <b>102</b>, located at an address ADDR <b>1</b>, be fetched, and copied to a processor local register. As the First_Reg_Index register has been programmed with &#x201c;10&#x201d;, the target local register is register-10. The SRCC next sends a READ ADDRESS-<b>1</b> message to the memory subsystem, with a Tag=0 (the tag is sent so that the response to the request could be differentiated from responses to other requests, which may be received out-of-order). Right thereafter, the SPEC sends an Acknowledge message <b>310</b> to the processor, which can then proceed to the next instruction in the program that the processor executes. In embodiments, the order of messages <b>308</b> and <b>310</b> may be interchanged; in some embodiments, messages <b>308</b> and <b>310</b> may be sent at the same time.</p><p id="p-0043" num="0042">The sequence of messages <b>306</b>, wherein the processor sends a split read request; <b>308</b>, wherein the SRCC sends a corresponding request to the memory subsystem, and <b>310</b>, wherein the SRCC acknowledges the request, now repeats three times&#x2014;messages <b>312</b>, <b>314</b>, and <b>316</b> for the second split-read (ADDR <b>2</b>, Tag=1), and messages <b>312</b>, <b>314</b> and <b>316</b> for the third split-read (ADDR <b>3</b>, Tag=2). The first response from the memory subsystem is a message <b>324</b>, which returns the data stored in ADDR-<b>1</b>, with tag=0 indication</p><p id="p-0044" num="0043">Responsively, the SRCC writes the returned data to local register-10 (the first target register, as defined in First_Reg_Index register <b>202</b>).</p><p id="p-0045" num="0044">The next message from the memory subsystem is an out-of-order response message <b>328</b>, which is a response to the third split-read request <b>320</b>. The SRCC recognizes that this is the tag sent with the third split read request and, in a message <b>330</b>, writes the returned data in local register-12. Similarly, the target local register for a message <b>332</b> from the memory subsystem, with tag=1, is register-11; and, accordingly, in a message <b>334</b>, the SRCC writes the returned data in processor local register-11.</p><p id="p-0046" num="0045">The status of Completion Bitmap Register <b>206</b> (<figref idref="DRAWINGS">FIG. <b>2</b></figref>) is illustrated at the top portion of <figref idref="DRAWINGS">FIG. <b>3</b></figref>. In the example embodiment illustrated in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, Completion-Bitmap register <b>206</b> comprises four bits, and supports up to four split-read requests in each group of split-reads; in other embodiments, the Completion-Bitmap register may comprise any other suitable number of bits, e.g., 32.</p><p id="p-0047" num="0046">After sending message <b>318</b> (the last split read request), the processor may wish to check if all split read requests have been fulfilled, e.g., in order to execute instructions that access local registers which are the target registers of some of the split read requests. In a Read Completion Bitmap message <b>336</b>, the processor reads the Completion Bitmap Register, which stores binary 0000&#x2014;no request has been fulfilled, and the processor will not continue execution. In a Read Completion Bitmap message <b>338</b>, the processor, again, reads the Completion Bitmap Register, this time getting binary 0101 meaning that not all requests have been fulfilled. Lastly, in a Read Completion Bitmap message <b>340</b>, the processor reads the Completion-Bitmap register, this time getting binary 0111&#x2014;all Three requests of the current split-read group have been fulfilled, and the processor may access the corresponding target registers.</p><p id="p-0048" num="0047">As would be appreciated, the sequence diagram illustrated in <figref idref="DRAWINGS">FIG. <b>3</b></figref> and described herein is an example that is cited for the purpose of conceptual clarity. Other suitable sequence charts may be used in alternative embodiments. For example, in an embodiment, rather than waiting for all requests to be fulfilled, the processor may continue operation when the SRCC loads data in a given target register, until a point where other registers are needed.</p><p id="p-0049" num="0048"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a flowchart <b>400</b> that schematically illustrates a method for executing split reads in a processor system, in accordance with an embodiment of the present invention. The flowchart is executed by SRCC <b>108</b> (<figref idref="DRAWINGS">FIG. <b>1</b></figref>).</p><p id="p-0050" num="0049">The flowchart starts at a Get First-Index step, wherein the SRCC gets the index of the target register, for the first split read. The SRCC may store the index, for example, in First_Reg_Index register <b>202</b> (<figref idref="DRAWINGS">FIG. <b>2</b></figref>).</p><p id="p-0051" num="0050">Next, the SRCC enters a Clear-Completion-Map-and-Tag step <b>404</b>, wherein the SRCC clears a Completion Map Register (e.g., Completion-Bitmap register <b>206</b>, <figref idref="DRAWINGS">FIG. <b>2</b></figref>) and clears a TAG register which will be used to access the memory system in response to the split-read requests. The SRCC then enters a Check-Received-Requests/Responses step <b>406</b>, wherein the SRCC waits until the processor sends a split-Read request, or until the memory subsystem sends a response (the earlier). (Step <b>406</b> is a root of two loops in flowchart <b>400</b>&#x2014;a loop that handles requests, and a loop that handles responses.)</p><p id="p-0052" num="0051">If, in step <b>406</b>, the SRCC receives a split-read request, the SRCC enters an ACM step <b>408</b> and sends an Acknowledge signal to the processor, enters an Increment-TAG step <b>410</b> and increments the TAG register, and then, in a Read-Request step <b>412</b>, sends a memory access to the memory subsystem, with a tag that is equal to the TAG register, and an address that is equal to the address in the split-read request. The SRCC then reenters step <b>406</b>.</p><p id="p-0053" num="0052">It, in step <b>406</b>, the SRCC is a response for the memory subsystem, the SRCC enters a Get-Tag-and-DATA step <b>414</b> wherein the SRCC extracts the returned data and the tag from the response, and then enters a Write-Register step <b>416</b>. In step <b>416</b>, the SRCC writes the data that the memory subsystem has sent to the target register; the index of the register is calculated by adding the contents of the First-Reg-Index register to the tag that the memory subsystem returns. The SRCC then enters an Update Completion Map step <b>418</b> and updates the completion map to indicate that the corresponding request has been fulfilled. Next, the SRCC enters a Check-Completion-Map-Full step <b>420</b> and checks the completion map to see if all completion indications are set. If so, the flowchart ends. If one or more requests are not fulfilled yet, the SRCC reenters step <b>406</b>, for another loop.</p><p id="p-0054" num="0053">Thus, a method according to the example embodiment illustrated in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, provides split-read capabilities to a processor that is attached to a SRCC, wherein the SPEC accesses a memory subsystem to execute the split read requests, and writes the read data directly into the processor local registers.</p><p id="p-0055" num="0054">As would be appreciated, the flowchart described herein is cited by way of example. Other suitable flowcharts may be used in alternative embodiments. For example, in some embodiments, Increment-Tag step <b>410</b> may precede ACK step <b>408</b>; in other embodiments, some of the steps may be executed in parallel.</p><heading id="h-0009" level="1">Register Space</heading><p id="p-0056" num="0055">According to embodiments, the processor communicates with the SRCC by writing and reading registers. This includes writing the number-of-split-reads, writing the first-reg-index, reading the completion-bitmap and writing the split read requests. In some embodiments, some or ail the accesses are done using a predefined set of processor Control-Registers (CR) Space. In other embodiments, some or all the accesses are memory mapped registers that the processor accesses using a memory access; the access is intercepted by the SRCC and directed to internal SRCC registers.</p><p id="p-0057" num="0056">In some embodiments, the CR space is further divided to local and non-local CR space, wherein the local CR space registers have faster access time. In an embodiment, registers like Num-of-Split-Reads are in the local CR-space, whereas the split-read requests access a non-local CR-space; thus, the configuration of the SRCC is local (fast) and the split reads are from the non-local CR-space.</p><heading id="h-0010" level="1">Software Support</heading><p id="p-0058" num="0057">To use the split-read feature, the software program should issue split read requests for reading data to sequentially indexed processor registers. This can be done, for example, by the C compiler.</p><p id="p-0059" num="0058">In some embodiments, two macros are defined for split-read support:<ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0059">i) PRED_START(number), indicates the number of split reads, to the PRM (writes Num-Split-Reads register)</li>        <li id="ul0002-0002" num="0060">ii) PRED_END&#x2014;a loop that reads the Completion Bitmap register until all Num-Split-Reads bits are set.</li>    </ul>    </li></ul></p><p id="p-0060" num="0061">The configurations of processor system <b>100</b>, processor <b>104</b> (including local registers <b>106</b>), SRCC <b>108</b>, SRCC Controller <b>200</b>, SRCC registers <b>202</b>, <b>204</b>, <b>206</b> and Tag-to-REG-Index Translator <b>208</b>; sequence chart <b>300</b> and flowchart <b>400</b>, illustrated in <figref idref="DRAWINGS">FIGS. <b>1</b> through <b>4</b></figref> and described hereinabove, are example configurations, sequence charts and flowcharts that are shown purely for the sake of conceptual clarity. Any other suitable configurations, sequence charts and flowcharts can be used in alternative embodiments. The different sub-units of processor system <b>100</b> including SRCC <b>108</b> may be implemented using suitable hardware, such as in one or more Application-Specific Integrated Circuits (ASICs) or Field-Programmable Gate Arrays (FPGAs), using software, using hardware, or using a combination of hardware and software elements.</p><p id="p-0061" num="0062">Processor <b>104</b> (<figref idref="DRAWINGS">FIG. <b>1</b></figref>) and/or SRCC controller <b>200</b> (<figref idref="DRAWINGS">FIG. <b>2</b></figref>) may comprise a general-purpose processor, which is programmed in software to carry out the functions described herein. The software may be downloaded to the processor in electronic form, over a network or from a host, for example, or it may, alternatively or additionally, be provided and/or stored on non-transitory tangible media, such as magnetic, optical, or electronic memory.</p><p id="p-0062" num="0063">It will be appreciated that the embodiments described above are cited by way of example, and that the present invention is not limited to what has been particularly shown and described hereinabove. Rather, the scope of the present invention includes both combinations and sub-combinations of the various features described hereinabove, as well as variations and modifications thereof which would occur to persons skilled in the art upon reading the foregoing description and which are not disclosed in the prior art. Documents incorporated by reference in the present patent application are to be considered an integral part of the application except that to the extent any terms are defined in these incorporated documents in a manner that conflicts with the definitions made explicitly or implicitly in the present specification, only the definitions in the present specification should be considered.</p><?detailed-description description="Detailed Description" end="tail"?></description><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. An apparatus, comprising:<claim-text>a processor, to issue a set of one or more split-read requests for loading one or more data values to one or more respective local registers of the processor; and</claim-text><claim-text>split-read control circuitry (SRCC), to receive the set of one or more split-read requests, to read the one or more data values on behalf of the processor, and to write the data values into the one or more respective local registers,</claim-text><claim-text>wherein the processor and the SRCC are to coordinate a status of the split-read requests via a split-read-status indication.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The apparatus according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the processor is to specify, in the split-read-status indication, a number of the split-read requests in the set, and wherein the SRCC is to update the split-read-status indication upon writing each of the data values into the local registers.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The apparatus according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the split-read-status indication comprises a respective indicator for each split-read request in the set, each indicator indicating whether the respective split-read request has been completed by the SRCC.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The apparatus according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the processor is to suspend an instruction that accesses a local register, in response to identifying in the split-read-status indication that a split-read request corresponding to the local register is not yet completed.</claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The apparatus according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the processor is to specify, in the set, two or more local registers having sequential indices.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The apparatus according to <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the processor is to specify to the SRCC an index of a first local register in the set.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The apparatus according to <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the SRCC is to serve a split-read request on behalf of the processor by:<claim-text>issuing an external memory read request corresponding to the split-read request;</claim-text><claim-text>assigning a tag to the external memory read request; and</claim-text><claim-text>upon receiving an external memory read response having the tag, storing a data value provided in the external memory read response in a local register specified by the split-read request.</claim-text></claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. A method, comprising:<claim-text>issuing, by a processor, a set of one or more split-read requests for loading one or more data values to one or more respective local registers of the processor;</claim-text><claim-text>using split-read control circuitry (SRCC), receiving the set of one or more split-read requests from the processor, reading the one or more data values on behalf of the processor, and writing the data values into the one or more respective local registers; and</claim-text><claim-text>coordinating a status of the split-read requests between the processor and the SRCC via a split-read-status indication.</claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The method according to <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein coordinating the status of the split-read requests comprises specifying by the processor, in the split-read-status indication, a number of the split-read requests in the set, and updating the split-read-status indication by the SRCC upon writing each of the data values into the local registers.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The method according to <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the split-read-status indication comprises a respective indicator for each split-read request in the set, each indicator indicating whether the respective split-read request has been completed by the SRCC.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The method according to <claim-ref idref="CLM-00008">claim 8</claim-ref>, and comprising suspending, by the processor, an instruction that accesses a local register, in response to identifying in the split-read-status indication that a split-read request corresponding to the local register is not vet completed.</claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The method according to <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein issuing the set of the one or more split-read requests comprises specifying, in the set, two or more local registers having sequential indices.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The method according to <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein specifying the local registers comprises specifying to the SRCC an index of a first local register in the set.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The method according to <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein serving a split-read request on behalf of the processor using the SRCC comprises:<claim-text>issuing an external memory read request corresponding to the split-read request;</claim-text><claim-text>assigning a tag to the external memory read request; and</claim-text><claim-text>upon receiving an external memory read response having the tag, storing a data value provided in the external memory read response in a local register specified by the split-read request.</claim-text></claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. A method for executing read requests on behalf of a processor, the method comprising:<claim-text>receiving, from the processor, a set of read requests that request loading data values to respective local registers of the processor;</claim-text><claim-text>reading the data values on behalf of the processor from a memory; and</claim-text><claim-text>writing the data values, which were read from the memory, into the local registers of the processor.</claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The method according to <claim-ref idref="CLM-00015">claim 15</claim-ref>, and comprising coordinating a progress of the read requests with the processor using a read-status indication.</claim-text></claim></claims></us-patent-application>