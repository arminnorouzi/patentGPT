<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004433A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004433</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17781317</doc-number><date>20200427</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><priority-claims><priority-claim sequence="01" kind="national"><country>CN</country><doc-number>202010080853.6</doc-number><date>20200205</date></priority-claim></priority-claims><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>50</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>15</main-group><subgroup>173</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>505</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>15</main-group><subgroup>17331</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e61">DATA PROCESSING METHOD AND APPARATUS, DISTRIBUTED DATA FLOW PROGRAMMING FRAMEWORK, AND RELATED COMPONENT</invention-title><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>INSPUR SUZHOU INTELLIGENT TECHNOLOGY CO., LTD.</orgname><address><city>Suzhou, Jiangsu</city><country>CN</country></address></addressbook><residence><country>CN</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>KAN</last-name><first-name>Hongwei</first-name><address><city>Suzhou, Jiangsu</city><country>CN</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>WU</last-name><first-name>Nan</first-name><address><city>Suzhou, Jiangsu</city><country>CN</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>LI</last-name><first-name>Rengang</first-name><address><city>Suzhou, Jiangsu</city><country>CN</country></address></addressbook></inventor><inventor sequence="03" designation="us-only"><addressbook><last-name>WANG</last-name><first-name>Yanwei</first-name><address><city>Suzhou, Jiangsu</city><country>CN</country></address></addressbook></inventor></inventors></us-parties><pct-or-regional-filing-data><document-id><country>WO</country><doc-number>PCT/CN2020/087157</doc-number><date>20200427</date></document-id><us-371c12-date><date>20220531</date></us-371c12-date></pct-or-regional-filing-data></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A data processing method, a data processing apparatus, a distributed data flow programming framework, an electronic device, and a storage medium. The data processing method includes: dividing a data processing task into a plurality of data processing subtasks (S<b>101</b>); determining, in a Field Programmable Gate Array (FPGA) accelerator side, a target FPGA acceleration board corresponding to each of the data processing subtasks (S<b>102</b>); and sending data to be computed to the target FPGA acceleration board, and executing the corresponding data processing subtask by use of each of the target FPGA acceleration boards to obtain a data processing result (S<b>103</b>). According to the method, a physical limitation of host interfaces on the number of FPGA acceleration boards in an FPGA accelerator side may be avoided, thereby improving the data processing efficiency.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="71.63mm" wi="142.07mm" file="US20230004433A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="119.21mm" wi="120.40mm" file="US20230004433A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="117.09mm" wi="120.06mm" file="US20230004433A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="228.35mm" wi="143.85mm" file="US20230004433A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="202.69mm" wi="144.10mm" file="US20230004433A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="173.40mm" wi="146.64mm" file="US20230004433A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="96.18mm" wi="145.03mm" file="US20230004433A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><p id="p-0002" num="0001">The present application claims priority to Chinese Patent Application No. 202010080853.6, filed to the Patent Office of the People's Republic of China on Feb. 5, 2020, and entitled &#x201c;Data Processing Method and Apparatus, Distributed Data Flow Programming Framework, and Related Component&#x201d;, the contents of which are hereby incorporated by reference in its entirety.</p><heading id="h-0001" level="1">FIELD</heading><p id="p-0003" num="0002">The present application relates to the technical field of cloud computing, and particularly to a data processing method and apparatus, a distributed data flow programming framework, an electronic device, and a storage medium.</p><heading id="h-0002" level="1">BACKGROUND</heading><p id="p-0004" num="0003">With the rapid development of Artificial Intelligence (AI) and big data, data in a data center has been multiplied. Meanwhile, the rapid development of AI also brings requirements for high performance computing of data. As a result, data grows exponentially on one hand, on the other hand the computing resources needed for processing the data increases correspondingly. Conventional computing is implemented by a Central Processing Unit (CPU). With the constant development of technology, the performance of the CPU cannot be improved exponentially. A reconfigurable chip, such as a Field Programmable Gate Array (FPGA), has the potential to accelerate many workloads, and may perform decryption operation, image processing, decompression, and AI related computing. In related arts, communication-intensive and computing-intensive tasks are processed by an FPGA accelerator side. However, when data interaction is needed between two FPGA acceleration boards in the FPGA accelerator side in the related arts, the FPGA acceleration board needs to send data to a host side by Peripheral Component Interconnect Express (PCIE), and then the host side sends the data to the other board. As a result, the data computing efficiency is relatively low, and the number of boards capable of supporting PCIE at the host side forms a physical limitation on the number of devices supporting a plurality of boards in an FPGA cloud server.</p><p id="p-0005" num="0004">Therefore, how to avoid a physical limitation of host interfaces on the number of FPGA acceleration boards in an FPGA accelerator side to improve the data processing efficiency is a technical problem needed to be solved by a person skilled in the art at present.</p><heading id="h-0003" level="1">SUMMARY</heading><p id="p-0006" num="0005">An objective of the present application is to provide a data processing method and apparatus, a distributed data flow programming framework, an electronic device, and a storage medium, which may avoid a physical limitation of host interfaces on the number of FPGA acceleration boards in an FPGA accelerator side, thereby improving the data processing efficiency.</p><p id="p-0007" num="0006">In order to solve the foregoing technical problem, the present application provides a data processing method for applying to a host side, wherein the host side is connected to a Field Programmable Gate Array (FPGA) accelerator side, the FPGA accelerator side comprises a plurality of FPGA acceleration boards, and the FPGA acceleration boards are connected to each other through a network, the data processing method comprising:<ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0007">dividing a data processing task into a plurality of data processing subtasks, and determining, in the FPGA accelerator side, target FPGA acceleration boards corresponding to each of the data processing subtasks; and</li>        <li id="ul0002-0002" num="0008">sending data to be computed to the target FPGA acceleration boards, and executing the corresponding data processing subtask by use of each of the target FPGA acceleration boards to obtain a data processing result, wherein the data processing result comprises intermediate computing data or a final processing result of the data processing task, source data of each of the data processing subtasks comprises the data to be computed and/or the intermediate computing data, and the intermediate computing data is transmitted through the network between the target FPGA acceleration boards.</li>    </ul>    </li></ul></p><p id="p-0008" num="0009">Optionally, after the sending data to be computed to the target FPGA acceleration boards, the method further includes:<ul id="ul0003" list-style="none">    <li id="ul0003-0001" num="0000">    <ul id="ul0004" list-style="none">        <li id="ul0004-0001" num="0010">configuring a data address and data length of the data to be computed into the target FPGA acceleration boards, whereby the target FPGA acceleration boards store the data to be computed according to the data address and the data length.</li>    </ul>    </li></ul></p><p id="p-0009" num="0011">Optionally, the method further includes:<ul id="ul0005" list-style="none">    <li id="ul0005-0001" num="0000">    <ul id="ul0006" list-style="none">        <li id="ul0006-0001" num="0012">configuring a computation result storage address into the target FPGA acceleration boards, whereby the target FPGA acceleration boards store the intermediate computing data and/or the final processing result into the computation result storage address.</li>    </ul>    </li></ul></p><p id="p-0010" num="0013">Optionally, the method further includes:<ul id="ul0007" list-style="none">    <li id="ul0007-0001" num="0000">    <ul id="ul0008" list-style="none">        <li id="ul0008-0001" num="0014">selecting a first target FPGA acceleration board from all of the target FPGA acceleration boards;</li>        <li id="ul0008-0002" num="0015">sending all of the data processing subtasks and task distribution information to the first target FPGA acceleration board; wherein the task distribution information comprising correspondences between the data processing subtasks and the target FPGA acceleration boards; and</li>        <li id="ul0008-0003" num="0016">sending, by use of the first target FPGA acceleration board, the data processing subtasks to the corresponding target FPGA acceleration boards according to the task distribution information.</li>    </ul>    </li></ul></p><p id="p-0011" num="0017">Optionally, after the sending data to be computed to the target FPGA acceleration boards, the method further includes:<ul id="ul0009" list-style="none">    <li id="ul0009-0001" num="0000">    <ul id="ul0010" list-style="none">        <li id="ul0010-0001" num="0018">selecting a second target FPGA acceleration board from all of the target FPGA acceleration boards;</li>        <li id="ul0010-0002" num="0019">sending all of the data to be computed and data distribution information to the second target FPGA acceleration board; wherein the data distribution information comprising correspondences between the data to be computed and the target FPGA acceleration boards; and</li>        <li id="ul0010-0003" num="0020">sending, by use of the second target FPGA acceleration board, the data to be computed to the corresponding FPGA acceleration boards according to the data distribution information.</li>    </ul>    </li></ul></p><p id="p-0012" num="0021">Optionally, after the sending data to be computed to the target FPGA acceleration boards, the method further includes:<ul id="ul0011" list-style="none">    <li id="ul0011-0001" num="0000">    <ul id="ul0012" list-style="none">        <li id="ul0012-0001" num="0022">sending the corresponding data to be computed to the target FPGA acceleration boards in a self-defined Remote Direct Memory Access (RDMA) transmission mode; and</li>        <li id="ul0012-0002" num="0023">sending the corresponding data processing subtask to the target FPGA acceleration boards in a preset transmission mode; wherein the preset transmission mode comprising streaming or integral packet transmission.</li>    </ul>    </li></ul></p><p id="p-0013" num="0024">Optionally, the method further includes:<ul id="ul0013" list-style="none">    <li id="ul0013-0001" num="0000">    <ul id="ul0014" list-style="none">        <li id="ul0014-0001" num="0025">when the target FPGA acceleration boards sends the intermediate computing data to other target FPGA acceleration boards based on the network, sending a data address and data length of the intermediate computing data to the other target FPGA acceleration boards, whereby the other target FPGA acceleration boards store the intermediate computing data according to the data address and data length of the intermediate computing data.</li>    </ul>    </li></ul></p><p id="p-0014" num="0026">Optionally, data is transmitted between the target FPGA acceleration boards by a Medium Access Control (MAC) interface; data is transmitted between the host side and the target FPGA acceleration boards by a Peripheral Component Interconnect Express (PCIE) interface; and data is transmitted between a remote device and the target FPGA acceleration boards by a MAC interface.</p><p id="p-0015" num="0027">Optionally, when the host side and the target FPGA acceleration boards are devices in a local area network, a packing operation is performed in a MAC layer on communication data between the host side and the target FPGA acceleration boards; and<ul id="ul0015" list-style="none">    <li id="ul0015-0001" num="0000">    <ul id="ul0016" list-style="none">        <li id="ul0016-0001" num="0028">when the host side and the target FPGA acceleration boards are devices in a public network, a packing operation is performed in a User Datagram Protocol (UDP) payload layer on communication data between the host side and the target FPGA acceleration boards, and a packing operation is performed in the UDP payload layer on communication data between the target FPGA acceleration boards.</li>    </ul>    </li></ul></p><p id="p-0016" num="0029">The present application further provides a data processing apparatus. The data processing apparatus is connected to a Field Programmable Gate Array (FPGA) accelerator side, the FPGA accelerator side comprises a plurality of FPGA acceleration boards, and the FPGA acceleration boards are connected to each other through a network, the data processing apparatus comprises:<ul id="ul0017" list-style="none">    <li id="ul0017-0001" num="0000">    <ul id="ul0018" list-style="none">        <li id="ul0018-0001" num="0030">a task distribution module, configured for dividing a data processing task into a plurality of data processing subtasks, and determining, in the FPGA accelerator side, a target FPGA acceleration boards corresponding to each of the data processing subtasks; and</li>        <li id="ul0018-0002" num="0031">a task execution module, configured for sending data to be computed to the target FPGA acceleration boards, and executing the corresponding data processing subtask by use of each of the target FPGA acceleration boards to obtain a data processing result, wherein the data processing result comprises intermediate computing data or a final processing result of the data processing task, source data of each of the data processing subtasks comprises the data to be computed and/or the intermediate computing data, and the intermediate computing data is transmitted through the network between the target FPGA acceleration boards.</li>    </ul>    </li></ul></p><p id="p-0017" num="0032">The present application further provides a distributed data flow programming framework, including a Central Processing Unit (CPU) acceleration stack and a Field Programmable Gate Array (FPGA) acceleration stack;<ul id="ul0019" list-style="none">    <li id="ul0019-0001" num="0000">    <ul id="ul0020" list-style="none">        <li id="ul0020-0001" num="0033">the CPU acceleration stack is configured to provide an underlying support for dividing a data processing task, and is further configured to provide a host-side Application Programming Interface (API) for scheduling a data processing subtask;</li>        <li id="ul0020-0002" num="0034">the FPGA acceleration stack is configured to provide an acceleration interface corresponding to the host-side API, and is further configured to provide an acceleration data control program and a kernel control program during the execution of the data processing subtask;</li>        <li id="ul0020-0003" num="0035">wherein when the distributed data flow programming framework is operating, the CPU acceleration stack divides the data processing task into a plurality of data processing subtasks, and determines, in an FPGA accelerator side, target FPGA acceleration boards corresponding to each of the data processing subtasks; and sends data to be computed to the target FPGA acceleration boards; and the FPGA acceleration stack executes the corresponding data processing subtask by use of each of the target FPGA acceleration boards to obtain a data processing result, wherein the data processing result comprises intermediate computing data or a final processing result of the data processing task, source data of each of the data processing subtasks comprises the data to be computed and/or the intermediate computing data, and the intermediate computing data is transmitted through the network between the target FPGA acceleration boards.</li>    </ul>    </li></ul></p><p id="p-0018" num="0036">Optionally, the FPGA acceleration stack includes:<ul id="ul0021" list-style="none">    <li id="ul0021-0001" num="0000">    <ul id="ul0022" list-style="none">        <li id="ul0022-0001" num="0037">a static region, configured to execute the data processing subtask distributed by the CPU acceleration stack, and further configured to send the data processing result to the CPU acceleration stack or another target FPGA acceleration board; and</li>        <li id="ul0022-0002" num="0038">an FPGA acceleration engine, configured to send the data processing subtask to a local acceleration unit or an acceleration unit of other target FPGA acceleration boards to perform an accelerated computation operation.</li>    </ul>    </li></ul></p><p id="p-0019" num="0039">A storage medium, characterized by storing computer-executable instructions thereon which, when loaded and executed by a processor, implements the steps of the above data processing method.</p><p id="p-0020" num="0040">The present application also provides an electronic device, including a memory and a processor, wherein the memory has a computer program stored thereon; and the processor, when calling the computer program stored in the memory, implements the steps of the above data processing method.</p><p id="p-0021" num="0041">The present application further provides a data processing method for applying to a host side, wherein the host side is connected to a Field Programmable Gate Array (FPGA) accelerator side, the FPGA accelerator side comprises a plurality of FPGA acceleration boards, and the FPGA acceleration boards are connected to each other through a network, the data processing method comprises: dividing a data processing task into a plurality of data processing subtasks, and determining, in the FPGA accelerator side, target FPGA acceleration boards corresponding to each of the data processing subtasks; and sending data to be computed to the target FPGA acceleration boards, and executing the corresponding data processing subtask by use of each of the target FPGA acceleration boards to obtain a data processing result, wherein the data processing result comprises intermediate computing data or a final processing result of the data processing task, source data of each of the data processing subtasks comprises the data to be computed and/or the intermediate computing data, and the intermediate computing data is transmitted through the network between the target FPGA acceleration boards.</p><p id="p-0022" num="0042">According to the present application, the data processing task is divided into the a plurality of data processing subtasks first. Then, the target FPGA acceleration boards corresponding to each of the data processing subtasks are determined in the FPGA accelerator side. The corresponding data processing subtask is executed by use of the target FPGA acceleration boards. When the target FPGA acceleration boards process the data processing subtask, the data processing result of other target FPGA acceleration boards may be taken as input data, and the data processing result computed by itself may also be sent to other target FPGA acceleration boards. The data processing result is transmitted between the target FPGA acceleration boards by the network rather than sent to the host side first and then forwarded by the host side. It can be seen that, according to the present application, a physical limitation of host interfaces on the number of FPGA acceleration boards in an FPGA accelerator side may be avoided, thereby improving the data processing efficiency. The present application also provides a data processing apparatus, a distributed data flow programming framework, an electronic device, and a storage medium, which have the foregoing beneficial effects. Elaborations are omitted herein.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0023" num="0043">In order to describe the technical solutions in the embodiments of the present application or the conventional art more clearly, the drawings needed to be used in descriptions about the embodiments or the conventional art will be simply introduced below. It is apparent that the drawings described below are merely some embodiments of the present application. Other drawings may further be obtained by those of ordinary skill in the art according to these drawings without creative work.</p><p id="p-0024" num="0044"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a flowchart of a data processing method according to an embodiment of the present application.</p><p id="p-0025" num="0045"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a flowchart of a method for distributing a data processing subtask according to an embodiment of the present application.</p><p id="p-0026" num="0046"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a flowchart of a method for sending data to be computed according to an embodiment of the present application.</p><p id="p-0027" num="0047"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is an architecture diagram of a Reconfigurable Data Center (RDC) according to an embodiment of the present application.</p><p id="p-0028" num="0048"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a diagram of an acceleration framework of an RDC according to an embodiment of the present application.</p><p id="p-0029" num="0049"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a schematic architecture diagram of a CPU acceleration stack according to an embodiment of the present application.</p><p id="p-0030" num="0050"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a functional structure diagram of an FPGA acceleration stack according to an embodiment of the present application.</p><p id="p-0031" num="0051"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a framework diagram of an FPGA acceleration stack according to an embodiment of the present application.</p><p id="p-0032" num="0052"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is a schematic diagram of a computation principle of an FPGA cloud platform according to an embodiment of the present application.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0005" level="1">DETAILED DESCRIPTION</heading><p id="p-0033" num="0053">The technical solutions in the embodiments of the present application will be clearly and completely described below with reference to the accompanying drawings in the embodiments of the present application. Obviously, the described embodiments are only a part of the embodiments of the present application, rather than all the embodiments. Based on the embodiments of the present application, all other embodiments obtained by those skilled in the art without creative work shall fall within the protection scope of the present application.</p><p id="p-0034" num="0054">References are made to <figref idref="DRAWINGS">FIG. <b>1</b></figref> below, which is a flowchart of a data processing method according to an embodiment of the present application.</p><p id="p-0035" num="0055">The following specific steps may be included.</p><p id="p-0036" num="0056">At S<b>101</b>, a data processing task is divided into a plurality of data processing subtasks.</p><p id="p-0037" num="0057">The present embodiment is applicable to a host side connected with an FPGA accelerator side. The FPGA accelerator side includes a plurality of FPGA acceleration boards. The FPGA acceleration boards are connected to each other through a network. A CPU (Central Processing Unit) in the host side may be configured to implement the division of data processing subtasks.</p><p id="p-0038" num="0058">Specifically, in the present embodiment, data to be computed and all computation operations for the data to be computed may be determined according to the data processing task. In the present embodiment, the data processing task may be divided into a plurality of data processing subtasks according to the number of the computation operations and/or types of the computation operations. For example, a data processing task includes nine steps of computation operations, wherein the first to third computation operations may be divided as a first data processing subtask, the fourth to sixth computation operations may be divided as a second data processing subtask, and the seventh to ninth computation operations may be divided as a third data processing subtask. For another example, a data processing task includes three types of computation operations, i.e., lexical analysis, semantic analysis, and hash mapping, wherein all lexical analysis operations may be divided as a fourth data processing subtask, all semantic analysis operations may be divided as a fifth data processing subtask, and all hash mapping operations may be divided as a sixth data processing subtask.</p><p id="p-0039" num="0059">It can be understood that, after the plurality of data processing subtasks are obtained, firmware corresponding to each of the data processing subtasks may be generated for burning to the corresponding FPGA acceleration boards, such that the FPGA acceleration boards execute a corresponding data processing operation by executing the firmware.</p><p id="p-0040" num="0060">At S<b>102</b>, target FPGA acceleration boards corresponding to each of the data processing subtasks are determined in a FPGA accelerator side.</p><p id="p-0041" num="0061">The FPGA accelerator side may include a plurality of FPGA acceleration boards. In the present embodiment, the same number of FPGA acceleration boards may be selected from the FPGA accelerator side according to the subtask number of the data processing subtasks. After the target FPGA acceleration boards are determined, a correspondence between each of the target FPGA acceleration boards and a data processing subtask may further be determined, and the data processing subtask is sent to the corresponding target FPGA acceleration boards based on the correspondence, namely the firmware corresponding to the data processing subtask is burnt to the corresponding target FPGA acceleration board.</p><p id="p-0042" num="0062">At S<b>103</b>, data to be computed is sent to the target FPGA acceleration boards, and the corresponding data processing subtask is executed by use of each of the target FPGA acceleration boards to obtain a data processing result.</p><p id="p-0043" num="0063">In the present embodiment, corresponding data to be computed may be determined according to the data processing task, and the data to be computed is sent to the target FPGA acceleration boards. It can be understood that source data during the execution of the data processing subtask by the target FPGA acceleration boards may be the data to be computed, or an intermediate computing result of other target FPGA acceleration board, or the data to be computed and the intermediate computing result. The data processing result obtained from executing the corresponding data processing subtask by each of the target FPGA acceleration boards may include intermediate computing data and/or a final processing result of the data processing task. Source data of each of the data processing subtasks includes the data to be computed and/or the intermediate computing data. The intermediate computing data is transmitted by the network between the target FPGA acceleration boards.</p><p id="p-0044" num="0064">As a possible implementation mode, after the data to be computed is sent to the target FPGA acceleration boards, a data address and data length of the data to be computed may further be configured into the target FPGA acceleration boards, whereby the target FPGA acceleration boards store the data to be computed according to the data address and the data length. In the above-mentioned implementation mode, the host side sends the data address and data length of the data to be computed to the target FPGA acceleration boards, whereby the target FPGA acceleration boards store the data to be computed according to the data address and the data length.</p><p id="p-0045" num="0065">As other possible implementation mode, the host side may also configure a computation result storage address into the target FPGA acceleration board, whereby the target FPGA acceleration boards store the intermediate computing data and/or the final processing result into the computation result storage address. In the above-mentioned implementation mode, the host side sends the computation result storage address to the target FPGA acceleration boards, whereby the target FPGA acceleration boards store the intermediate computing data and/or the final processing result according to the computation result storage address, other target FPGA acceleration boards may read the intermediate computing data according to the computation result storage address, and the host side may read the final processing result according to the computation result storage address.</p><p id="p-0046" num="0066">When the target FPGA acceleration boards send the intermediate computing data to other target FPGA acceleration board based on the network, a data address and data length of the intermediate computing data may be sent to the other target FPGA acceleration boards, whereby the other target FPGA acceleration boards store the intermediate computing data according to the data address and data length of the intermediate computing data. Specifically, the intermediate computing data may be transmitted between the target FPGA acceleration boards by a MAC interface. The final processing result and/or the data to be computed may be transmitted between the host side and the target FPGA acceleration board by a PCIE interface. Data may be transmitted between a remote device and the target FPGA acceleration board by a MAC interface.</p><p id="p-0047" num="0067">According to the present embodiment, the data processing task is divided into the a plurality of data processing subtasks first. Then, the target FPGA acceleration boards corresponding to each of the data processing subtasks are determined in the FPGA accelerator side. The corresponding data processing subtask is executed by use of the target FPGA acceleration boards. When the target FPGA acceleration boards process the data processing subtask, the data processing result of other target FPGA acceleration boards may be taken as input data, and the data processing result computed by itself may also be sent to other target FPGA acceleration boards. The data processing result is transmitted between the target FPGA acceleration boards by the network rather than sent to the host side first and then forwarded by the host side. It can be seen that, according to the present embodiment, a physical limitation of host interfaces on the number of FPGA acceleration boards in an FPGA accelerator side may be avoided, thereby improving the data processing efficiency.</p><p id="p-0048" num="0068">Referring to <figref idref="DRAWINGS">FIG. <b>2</b></figref>, <figref idref="DRAWINGS">FIG. <b>2</b></figref> is a flowchart of a method for distributing a data processing subtask according to an embodiment of the present application. Further introductions after the determination of the data processing subtasks in the embodiment corresponding to <figref idref="DRAWINGS">FIG. <b>1</b></figref> are made in the present embodiment. The present embodiment may be combined with the embodiment corresponding to <figref idref="DRAWINGS">FIG. <b>1</b></figref> to obtain a further implementation mode. The present embodiment may include the following steps.</p><p id="p-0049" num="0069">At S<b>201</b>, a first target FPGA acceleration board is selected from all of the target FPGA acceleration boards.</p><p id="p-0050" num="0070">At S<b>202</b>, all of the data processing subtasks and task distribution information are sent to the first target FPGA acceleration board.</p><p id="p-0051" num="0071">At S<b>203</b>, the data processing subtasks to the corresponding target FPGA acceleration boards are sent by use of the first target FPGA acceleration board according to the task distribution information.</p><p id="p-0052" num="0072">An execution subject of the present embodiment may be the host side connected to the FPGA accelerator side. A first target FPGA acceleration board is determined from all of the selected target FPGA acceleration boards, so as to send all of the data processing subtasks to the first target FPGA acceleration board. The host side sends task distribution information to the first FPGA acceleration board while sending all of the data processing subtasks to the first target FPGA acceleration board. The task distribution information stores correspondences between the data processing subtasks and the target FPGA acceleration boards. The first target FPGA acceleration board may send the data processing subtasks to the corresponding target FPGA acceleration boards based on the correspondences.</p><p id="p-0053" num="0073">Certainly, the host side may send the corresponding data processing subtask to each of the target FPGA acceleration boards, besides the operation of distributing all of the data processing subtasks by use of one target FPGA acceleration board, as described in the embodiment corresponding to <figref idref="DRAWINGS">FIG. <b>2</b></figref>. As a possible implementation mode, the host side may send the corresponding data processing subtask to the target FPGA acceleration board in a streaming or integral packet transmission mode.</p><p id="p-0054" num="0074">Referring to <figref idref="DRAWINGS">FIG. <b>3</b></figref>, <figref idref="DRAWINGS">FIG. <b>3</b></figref> is a flowchart of a method for sending data to be computed according to an embodiment of the present application. Further introductions about S<b>103</b> in the embodiment corresponding to <figref idref="DRAWINGS">FIG. <b>1</b></figref> are made in the present embodiment. The present embodiment may be combined with the embodiment corresponding to <figref idref="DRAWINGS">FIG. <b>1</b></figref> to obtain a further implementation mode. The present embodiment may include the following steps.</p><p id="p-0055" num="0075">In S<b>301</b>, a second target FPGA acceleration board is selected from all of the target FPGA acceleration boards.</p><p id="p-0056" num="0076">In S<b>302</b>, all of the data to be computed and data distribution information are sent to the second target FPGA acceleration board. The data distribution information includes correspondences between the data to be computed and the target FPGA acceleration boards.</p><p id="p-0057" num="0077">In S<b>303</b>, the data to be computed is sent to the corresponding FPGA acceleration boards by use of the second target FPGA acceleration board according to the data distribution information.</p><p id="p-0058" num="0078">An execution subject of the present embodiment may be the host side connected to the FPGA accelerator side. A second target FPGA acceleration board is determined from all of the selected target FPGA acceleration boards, so as to send all of the data to be computed to the second target FPGA acceleration board. The host side sends data distribution information to the first FPGA acceleration board while sending all of the data processing subtasks to the first target FPGA acceleration board. The data distribution information stores the correspondence between each piece of the data to be computed and the target FPGA acceleration boards. The second target FPGA acceleration board may send the data to be computed to the corresponding target FPGA acceleration boards based on the correspondence. As a possible implementation mode, the host side may send the corresponding data to be computed to the target FPGA acceleration boards in a self-defined RDMA (Remote Direct Memory Access) transmission mode.</p><p id="p-0059" num="0079">Further, when the host side and the target FPGA acceleration board are devices in a local area network, a packing operation is performed in a MAC layer on communication data (such as the data to be computed and/or the final processing result) between the host side and the target FPGA acceleration boards. When the host side and the target FPGA acceleration board are devices in a public network, a packing operation is performed in a UDP payload layer on communication data (such as the data to be computed and/or the final processing result) between the host side and the target FPGA acceleration board, and a packing operation is performed in the UDP payload layer on communication data (such as the data to be computed and/or the intermediate computing result) between the target FPGA acceleration boards. The payload layer refers to a UDP load layer, and load refers to information needed to be transmitted in data transmission.</p><p id="p-0060" num="0080">Referring to <figref idref="DRAWINGS">FIG. <b>4</b></figref>, <figref idref="DRAWINGS">FIG. <b>4</b></figref> is an architecture diagram of an RDC according to an embodiment of the present application. The RDC may include a host side and a box of FPGA (i.e., an FPGA accelerator side). The RDC disclosed in the present embodiment pools FPGA resources based on a network. The FPGA acceleration boards are connected by the network (a 10G network, 40G network, or 100G network). On one hand, a machine-card binding form is retained, namely a server is provided with one or more FPGA accelerators. On the other hand, a BOX OF FPGA mode is introduced. Various types of FPGA acceleration boards (including Intel chip and a Xilinx chip) in the box of FPGA perform data interaction through the network. The FPGA acceleration boards in the box of FPGA are also interconnected with the FPGA acceleration boards provided at the host side through the network. In this manner, tight coupling between an FPGA and a CPU is released, and communication data needs not to be forwarded by the CPU of the host side, and may be transmitted by a MAC layer a lightweight high-reliability protocol above or a UDP, thus reducing the system throughput delay. Optical module in <figref idref="DRAWINGS">FIG. <b>4</b></figref> is fiber interface module.</p><p id="p-0061" num="0081">The RDC shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref> has the following characteristic: the CPU of the host side, the FPGA acceleration board in the host side, and the FPGA acceleration board in the box of FPGA work collaboratively. The CPU of the host side is responsible for logical processing. The FPGA acceleration board in the box of FPGA is responsible for communication-intensive and computation-intensive tasks. The RDC shares memory resources through the network, and a distributed topology is formed between nodes. A related logical function of a reconfigurable device is loaded in a distributed manner, and a standard Ethernet interface and protocol are supported.</p><p id="p-0062" num="0082">Task division and scheduling, software pipelining construction, data communication, and other processing methods under a conventional CPU-based distributed platform cannot be applied to the RDC directly. For a parallel structure and reconfigurability of heterogeneous computation resources in the RDC, based on data flow programming, a distributed data flow programming framework oriented to the RDC in the present application provides a distributed parallel API to complete mapping from a computation task to a reconfigurable device. The distributed data flow programming framework consists of a CPU acceleration stack, an FPGA acceleration stack, and a mapping model.</p><p id="p-0063" num="0083">The CPU acceleration stack provides a host-side API for parallel task model division and scheduling as well as an underlying support, and includes a lightweight high-reliability protocol module, an RDC internal memory management module, and an FPGA accelerator driver module.</p><p id="p-0064" num="0084">The FPGA acceleration stack provides an Intellectual Property (IP) such as acceleration data control and kernel control for the implementation of a specific computation task, and the FPGA IP provides a completely same interface for a function that the host-side API may provide, thereby implementing a unified distributed multi-engine acceleration engine. Through the above-mentioned interface, the multi-engine acceleration stack mainly implements remote loading and updating of the FPGA, loading and offloading for an algorithm application in the FPGA, loading of an algorithm parameter, controlling of a data migration path, startup and termination of an application, etc., thereby achieving controlling each instruction of an FPGA cloud platform. The FPGA acceleration stack may provide an acceleration interface corresponding to the host-side API, and may further provide an acceleration data control program and a kernel control program during the execution of a data processing subtask. When the FPGA acceleration board executes the data processing subtask, the FPGA acceleration stack may implement data distribution and migration by use of the acceleration data control program, such that the FPGA acceleration board obtains original data needed to be processed and stores a data processing result in a specific region. The kernel control program refers to a kernel control program of the FPGA acceleration board. The FPGA acceleration stack may implement computation for the original data to obtain the corresponding data processing result by use of the kernel control program. When the distributed data flow programming framework is operating, the CPU acceleration stack divides a data processing task into a plurality of data processing subtasks, determines, in an FPGA accelerator side, a target FPGA acceleration board corresponding to each of the data processing subtasks, and sends data to be computed to the target FPGA acceleration board. The FPGA acceleration stack executes the corresponding data processing subtask by use of each of the target FPGA acceleration boards to obtain a data processing result, wherein the data processing result includes intermediate computing data or a final processing result of the data processing task, source data of each of the data processing subtasks includes the data to be computed and/or the intermediate computing data, and the intermediate computing data is transmitted by the network between the target FPGA acceleration boards. The FPGA acceleration stack may include a static region and an FPGA acceleration engine. The static region is configured to execute the data processing subtask distributed by the CPU acceleration stack, and is further configured to send the data processing result to the CPU acceleration stack or other target FPGA acceleration board. The FPGA acceleration engine is configured to send the data processing subtask to a local acceleration unit or an acceleration unit of other target FPGA acceleration board to perform an accelerated computation operation.</p><p id="p-0065" num="0085">Referring to <figref idref="DRAWINGS">FIG. <b>5</b></figref>, <figref idref="DRAWINGS">FIG. <b>5</b></figref> is a diagram of an acceleration framework of an RDC according to an embodiment of the present application. FPGA accelerator in <figref idref="DRAWINGS">FIG. <b>5</b></figref> is the FPGA acceleration board mentioned herein. An FPGA-based distributed heterogeneous system may perform logical subnetwork division as required by a user. A whole subnetwork consists of a plurality of computation task nodes. Data transmission and communication based on control instructions are implemented between a server node and an FPGA acceleration unit and between FPGA nodes based on a self-defined lightweight high-reliability transmission protocol. Each computation task includes a logical control module running in the server node and an accelerated computation module running in the FPGA. The logical control module of the server node is implemented by an FPGA cloud platform function library provided by an extensible distributed programming framework. The accelerated computation module running in the FPGA is implemented by a Run-Time Library (RTL), and completes the parallel computation task of the RDC by use of an Internet Protocol (IP)-layer control interface provided by the distributed programming framework. In <figref idref="DRAWINGS">FIG. <b>5</b></figref>, NIC refers to a network card, User Application refers to a user application, PCIe refers to a high-speed serial computer extended bus standard, MAC refers to a medium access control protocol, KERNEL refers to a kernel of the FPGA acceleration board, FPGA OF BOX refers to an FPGA accelerator side with a plurality of FPGA acceleration boards, Data Flow refers to data flow transmission between the FPGA acceleration boards, Control Flow refers to a control process of each FGPA acceleration board by the FPGA accelerator side, and Switch refers to a switch.</p><p id="p-0066" num="0086">Referring to <figref idref="DRAWINGS">FIG. <b>6</b></figref>, <figref idref="DRAWINGS">FIG. <b>6</b></figref> is a schematic architecture diagram of a CPU acceleration stack according to an embodiment of the present application. The CPU acceleration stack may be divided into an underlying FPGA accelerator driver module, a RDC Software Development Kit (RDC SDK), an authorization management module, an internal memory management layer, a flow table matching layer, an acceleration data management module, an acceleration control management module, and a Relay Layer-Transfer Layer (RLTL) protocol support layer. A user may complete application data migration, kernel updating, running monitoring, and other tasks through the RDC SDK. The authorization management module mainly completes an FPGA-based work group management and authorization mechanism according to different requirements of the user, and completes a chip-Identifier (ID)-based security checking mechanism, thereby improving the security of a netlist/BIT file of the user. The flow table matching module mainly parses a related content according to a protocol, and finds a matched related function model. Acceleration data and control management mainly completes management over a control flow and a data flow.</p><p id="p-0067" num="0087">Referring to Table 1, Table 1 is a function description table of the RDC SDK. The present SDK supports the user to migrate data to a specified address of a Double Data Rate (DDR) memory by use of RDMA, perform PR (an operating system command), configure a kernel parameter, etc.</p><p id="p-0068" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 1</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Function Description Table of RDC SDK</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="91pt" align="left"/><colspec colname="2" colwidth="126pt" align="left"/><tbody valign="top"><row><entry>RDC-oriented SDK</entry><entry>Detailed function descriptions</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>icfTransterData</entry><entry>DDR address of the board specified by</entry></row><row><entry/><entry>the user</entry></row><row><entry>icfTransterDataRDMA</entry><entry>RDMA migration interface</entry></row><row><entry>icfCreateProgramToFPGA</entry><entry>Interface for streaming loading of PR to</entry></row><row><entry/><entry>FPGA</entry></row><row><entry>icfLoadProgramToFPGA</entry><entry>Instruction interface for loading of PR to</entry></row><row><entry/><entry>FPGA</entry></row><row><entry>icfLoadProgramToFlash</entry><entry>Instruction interface for loading to Flash</entry></row><row><entry>icfConfigKernel</entry><entry>Kernel parameter configuration interface</entry></row><row><entry>icfConfig KernelReturn</entry><entry>Kernel return value configuration</entry></row><row><entry/><entry>interface</entry></row><row><entry>icfStartKernel</entry><entry>Kernel startup interface</entry></row><row><entry>icfEndKernel</entry><entry>Kernel forced termination interface</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0069" num="0088">Referring to <figref idref="DRAWINGS">FIG. <b>7</b></figref>, <figref idref="DRAWINGS">FIG. <b>7</b></figref> is a functional structure diagram of an FPGA acceleration stack according to an embodiment of the present application. In <figref idref="DRAWINGS">FIG. <b>7</b></figref>, Match engine refers to a match engine configured to distribute a data flow, Actions refers to a control operation of the FPGA acceleration stack, RDMA refers to remote direct memory access, pool KEY refers to a key of a memory pool, PR loading refers to operating system command loading, FLASH refers to a flash memory, and vFPGA refers to a user acceleration engine. The acceleration stack of the FPGA acceleration board includes a static region and an FPGA acceleration engine. The static region is configured to execute a data computation instruction, perform information interaction with the host side, and provide a physical interface. The FPGA acceleration engine is configured to send data to be computed to an acceleration unit to perform an accelerated computation operation. The FPGA acceleration engine is configured to send the data to be computed through a PCIE interface to perform a local accelerated computation operation, and is further configured to send the data to be computed through the PCIE interface and a MAC interface to perform a remote accelerated computation operation. The static region performs data interaction with the FPGA acceleration engine through a target bus. The target bus includes any one or combination of BUSA, BUSC, BUSD, and BUSE.</p><p id="p-0070" num="0089">The FPGA acceleration stack consists of a static region and a user application acceleration engine. The static part includes two parts, i.e., a control plane and a data plane. The control plane mainly cooperates with a host to complete routing, flow control, authorization, and other management functions, executes a control command transmitted by the host, and reports local information of the FPGA, thereby completing interactive processing with the host. The data plane mainly including various types of physical interfaces, including 10/100G MAC and PCIE channels, etc.</p><p id="p-0071" num="0090">Specifically, the FPGA acceleration engine may send data to the acceleration unit through the PCIE interface for local acceleration, or output data to other board through a PCIE&#x2192;MAC interface for remote acceleration. The dynamically reconfigurable acceleration unit may implement remote dynamic reconfiguration by a PR technology. A route forwarding table of a route forwarding module is software-configurable. The route forwarding table is looked up in the FPGA to implement routing.</p><p id="p-0072" num="0091">Referring to <figref idref="DRAWINGS">FIG. <b>8</b></figref>, <figref idref="DRAWINGS">FIG. <b>8</b></figref> is a framework diagram of an FPGA acceleration stack according to an embodiment of the present application. Table 2 is a function table of a fiber interface. The static region and user application acceleration engine shown in Table 2 interact through buses BUSA, BUSB, BUSC, BUSD, and BUSE. FIM in Table 2 refers to FPGA Interface Manager.</p><p id="p-0073" num="0000"><tables id="TABLE-US-00002" num="00002"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 2</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Management Function Table of FPGA Interface</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="35pt" align="left"/><colspec colname="2" colwidth="35pt" align="left"/><colspec colname="3" colwidth="35pt" align="left"/><colspec colname="4" colwidth="77pt" align="left"/><tbody valign="top"><row><entry/><entry>Bus type</entry><entry>Kernel</entry><entry>FIM</entry><entry>Function descriptions</entry></row><row><entry/><entry namest="offset" nameend="4" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="35pt" align="left"/><colspec colname="2" colwidth="35pt" align="left"/><colspec colname="3" colwidth="35pt" align="left"/><colspec colname="4" colwidth="35pt" align="left"/><colspec colname="5" colwidth="77pt" align="left"/><tbody valign="top"><row><entry>BUSA</entry><entry>MM</entry><entry>MASTER</entry><entry>SLAVE</entry><entry>The kernel accesses</entry></row><row><entry/><entry/><entry/><entry/><entry>DDRA through the FIM</entry></row><row><entry>BUSB</entry><entry>MM</entry><entry>MASTER</entry><entry>SLAVE</entry><entry>The kernel accesses</entry></row><row><entry/><entry/><entry/><entry/><entry>DDRB through the FIM</entry></row><row><entry>BUSC</entry><entry>LOCAL</entry><entry>MASTER</entry><entry>SLAVE</entry><entry>The kernel configures</entry></row><row><entry/><entry>BUS</entry><entry/><entry/><entry>the other board register</entry></row><row><entry/><entry/><entry/><entry/><entry>through the FIM</entry></row><row><entry>BUSD</entry><entry>MM</entry><entry>MASTER</entry><entry>SLAVE</entry><entry>The kernel configures</entry></row><row><entry/><entry/><entry/><entry/><entry>the present board</entry></row><row><entry/><entry/><entry/><entry/><entry>register through the</entry></row><row><entry/><entry/><entry/><entry/><entry>FIM</entry></row><row><entry>BUSE</entry><entry>MM</entry><entry>SLAVE</entry><entry>MASTER</entry><entry>The FIM configures the</entry></row><row><entry/><entry/><entry/><entry/><entry>kernel register</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0074" num="0092">The flow described in the above-mentioned embodiment will be described below with an embodiment in a practical application.</p><p id="p-0075" num="0093">This embodiment includes a host side used by a user. Four boards allocated to the user by an FPGA cloud platform are FPGA acceleration board <b>1</b> (referred to as FPGA <b>1</b> hereinafter for short), FPGA acceleration board <b>2</b> (referred to as FPGA <b>2</b> hereinafter for short), FPGA acceleration board <b>3</b> (referred to as FPGA <b>3</b> hereinafter for short), and FPGA acceleration board <b>4</b> (referred to as FPGA <b>4</b> hereinafter for short) respectively.</p><p id="p-0076" num="0094">Kernels in the FPGA acceleration boards have the following main functions. Kernel <b>1</b> performs plus 1 and plus 2 operations on data a and b migrated from the host side respectively. Kernel <b>2</b> performs addition or subtraction or multiplication or division on a result of a plus 1 and data c migrated from the host side to FPGA <b>2</b>. Kernel <b>3</b> performs addition or subtraction or multiplication or division on a result of b plus 2 and data d migrated from the host side to FPGA <b>3</b>. Kernel <b>4</b> multiplies results output by Kernel <b>2</b> and Kernel <b>3</b>, and an obtained result is sent to the host side.</p><p id="p-0077" num="0095">A functional procedure of the example in the present embodiment is as follows. The host side migrates data a and b to FPGA <b>1</b> through a standard network card. Kernel <b>1</b> adds 1 to a, adds 2 to b, migrates the result of a plus 1 to FPGA <b>2</b>, and migrates the result of b plus 2 to FPGA <b>3</b>. The host side migrates data c and d to FPGA <b>2</b> and FPGA <b>3</b> respectively. Kernel <b>2</b> executes algorithm (+&#x2212;*/optional) on (a+1) and c. Kernel <b>3</b> executes algorithm (+&#x2212;*/optional) on (b+2) and d. The operation results are migrated to FPGA <b>4</b>. Kernel <b>4</b> multiplies the results, and stores the result locally as required by the host side. A host migrates the operation result to the host side.</p><p id="p-0078" num="0096">A computation process of the FPGA acceleration board in the embodiment corresponding to <figref idref="DRAWINGS">FIG. <b>9</b></figref> is as follows.</p><p id="p-0079" num="0097">Step 1: the host loads Kernel <b>1</b> to FPGA <b>1</b> in a streaming mode.</p><p id="p-0080" num="0098">Standard interface: icfCreateProgramToFPGA( ).</p><p id="p-0081" num="0099">Step 2: the host migrates aocx files of Kernel <b>2</b>, Kernel <b>3</b>, and Kernel <b>4</b> to FPGA <b>2</b> respectively.</p><p id="p-0082" num="0100">Standard interface: icfTransterDataRDMA( ).</p><p id="p-0083" num="0101">Step 3: the host sends an instruction to FPGA <b>2</b> to load Kernelif<b>2</b> to FPGA <b>2</b>.</p><p id="p-0084" num="0102">Standard interface: icfLoadProgramToFPGA( ).</p><p id="p-0085" num="0103">Step 4: FPGA <b>2</b> loads Kernel <b>1</b> to FPGA <b>3</b> in the streaming mode.</p><p id="p-0086" num="0104">Standard interface: provided by an FPGA IP core.</p><p id="p-0087" num="0105">Step 5: FPGA <b>2</b> migrates the aocx file of Kernel <b>4</b> to FPGA <b>2</b>.</p><p id="p-0088" num="0106">Standard interface: needs to be provided by the FPGA IP core.</p><p id="p-0089" num="0107">Step 6: FPGA <b>2</b> sends an instruction to FPGA <b>4</b> to load Kernel <b>4</b> to FPGA <b>4</b>.</p><p id="p-0090" num="0108">Standard interface: needs to be provided by the FPGA IP core.</p><p id="p-0091" num="0109">Steps 1 to 6 present an FPGA kernel loading process, including loading from the host side (steps 1 to 3 involve a host-side code) and loading from an FPGA side (steps 4 to 6 involve a project of FPGA <b>2</b>).</p><p id="p-0092" num="0110">Step 7: the host migrates data A to FPGA <b>1</b> in an RDMA mode.</p><p id="p-0093" num="0111">Standard interface: icfTransterDataRDMA( ).</p><p id="p-0094" num="0112">Step 8: the host migrates data B to FPGA <b>1</b> in a direct transmission mode.</p><p id="p-0095" num="0113">Standard interface: icfTransterData( ).</p><p id="p-0096" num="0114">Step 9: the host configures an address and data length of A in FPGA <b>1</b> to FPGA <b>1</b>.</p><p id="p-0097" num="0115">Standard interface: icfConfigKernelParam( ).</p><p id="p-0098" num="0116">Step 10: the host configures an address and data length of B in FPGA <b>1</b> to FPGA <b>1</b>.</p><p id="p-0099" num="0117">Standard interface: icfConfigKernelParam( ).</p><p id="p-0100" num="0118">Step 11: the host configures a storage address of a computation result A1 of Kernel <b>1</b>-<b>1</b> to FPGA <b>1</b>.</p><p id="p-0101" num="0119">Standard interface: icfConfigKernelReturn( ).</p><p id="p-0102" num="0120">Step 12: the host configures a storage address of a computation result A2 of Kernel <b>1</b>-<b>2</b> to FPGA <b>1</b>.</p><p id="p-0103" num="0121">Standard interface: icfConfigKernelReturn( ).</p><p id="p-0104" num="0122">Sep 13: the host side starts Kernel <b>1</b>-<b>1</b>.</p><p id="p-0105" num="0123">Standard interface: icfStartKernel( ).</p><p id="p-0106" num="0124">Step 14: the host side starts Kernel <b>1</b>-<b>2</b>.</p><p id="p-0107" num="0125">Standard interface: icfStartKernel( ).</p><p id="p-0108" num="0126">In steps 7 to 14, the host side interacts with FPGA <b>1</b> by use of software application-layer interfaces, and controls FPGA <b>1</b> to start the kernel.</p><p id="p-0109" num="0127">Step 15: FPGA <b>1</b> migrates A1 to FPGA <b>2</b> in the RDMA mode.</p><p id="p-0110" num="0128">Standard interface: provided by the FPGA IP core.</p><p id="p-0111" num="0129">Step 16: the host migrates data c to FPGA <b>2</b> in the RDMA mode.</p><p id="p-0112" num="0130">Standard interface: icfTransterDataRDMA( ).</p><p id="p-0113" num="0131">Step 17: FPGA <b>1</b> configures an address and data length of A1 in FPGA <b>2</b> to FPGA <b>2</b>.</p><p id="p-0114" num="0132">Standard interface: provided by the FPGA IP core.</p><p id="p-0115" num="0133">Step 18: the host configures an address and data length of c in FPGA <b>2</b> to FPGA <b>2</b>.</p><p id="p-0116" num="0134">Standard interface: icfConfigKernelParam( ).</p><p id="p-0117" num="0135">Sep 19: FPGA <b>1</b> configures a storage address of a computation result A2 of Kernel <b>2</b> to FPGA <b>2</b>.</p><p id="p-0118" num="0136">Standard interface: needs to be provided by the FPGA IP core.</p><p id="p-0119" num="0137">Step 20: FPGA <b>1</b> starts Kernel <b>2</b> of FPGA <b>2</b>, and sends formal parameters A1 and c.</p><p id="p-0120" num="0138">Standard interface: needs to be provided by the FPGA IP core.</p><p id="p-0121" num="0139">In steps 15 to 20, FPGA <b>1</b> and the host interact with FPGA <b>2</b> by use of the provided interfaces, and FPGA <b>1</b> controls FPGA <b>2</b> to start the kernel.</p><p id="p-0122" num="0140">Step 21: FPGA <b>1</b> migrates B1 to FPGA <b>3</b> in the direct transmission mode.</p><p id="p-0123" num="0141">Step 22: the host migrates data d to FPGA <b>3</b> in the direct transmission mode.</p><p id="p-0124" num="0142">Step 23: FPGA <b>1</b> configures an address and data length of B1 in FPGA <b>3</b> to FPGA <b>3</b>.</p><p id="p-0125" num="0143">Step 24: the host configures an address and data length of d in FPGA <b>3</b> to FPGA <b>3</b>.</p><p id="p-0126" num="0144">Step 25: FPGA <b>1</b> configures a storage address of a computation result B2 of Kernel <b>3</b> to FPGA <b>3</b>.</p><p id="p-0127" num="0145">Step 26: FPGA <b>1</b> starts Kernel <b>3</b> of FPGA <b>3</b>, and sends formal parameters B1 and d.</p><p id="p-0128" num="0146">Steps 21 to 26, FPGA <b>1</b> and the host interact with FPGA <b>3</b> by use of the provided interfaces, and FPGA <b>1</b> controls FPGA <b>3</b> to start the kernel.</p><p id="p-0129" num="0147">Step 27: FPGA <b>2</b> migrates A2 to FPGA <b>4</b> in the RDMA mode.</p><p id="p-0130" num="0148">Step 28: FPGA <b>3</b> migrates B2 to FPGA <b>4</b> in the direct transmission mode.</p><p id="p-0131" num="0149">Step 29: FPGA <b>2</b> configures an address and data length of A2 in FPGA <b>4</b> to FPGA <b>4</b>.</p><p id="p-0132" num="0150">Step 30: FPGA <b>3</b> configures an address and data length of B2 in FPGA <b>4</b> to FPGA <b>4</b>.</p><p id="p-0133" num="0151">Step 31: FPGA <b>2</b> configures a storage address of a computation result AB3 of Kernel <b>4</b> to FPGA <b>4</b>.</p><p id="p-0134" num="0152">Step 32: FPGA <b>2</b> starts Kernel <b>4</b> of FPGA <b>4</b>, and sends formal parameters A2 and B2.</p><p id="p-0135" num="0153">Steps 27 to 32, FPGA <b>2</b> and FPGA <b>3</b> interact with FPGA <b>4</b> by use of the provided interfaces, and FPGA <b>2</b> controls FPGA <b>4</b> to start the kernel.</p><p id="p-0136" num="0154">Step 33: FPGA <b>4</b> starts Kernel <b>3</b> of FPGA <b>3</b>, and sends formal parameters B1 and d.</p><p id="p-0137" num="0155">An embodiment of the present application also provides a data processing apparatus, connected to an FPGA accelerator side. The FPGA accelerator side includes a plurality of FPGA acceleration boards. The FPGA acceleration boards are connected through a network. The data processing apparatus includes:<ul id="ul0023" list-style="none">    <li id="ul0023-0001" num="0000">    <ul id="ul0024" list-style="none">        <li id="ul0024-0001" num="0156">a task distribution module, configured for dividing a data processing task into a plurality of data processing subtasks, and determining, in the FPGA accelerator side, a target FPGA acceleration boards corresponding to each of the data processing subtasks; and</li>        <li id="ul0024-0002" num="0157">a task execution module, configured for sending data to be computed to the target FPGA acceleration boards, and executing the corresponding data processing subtask by use of each of the target FPGA acceleration boards to obtain a data processing result, wherein the data processing result comprises intermediate computing data or a final processing result of the data processing task, source data of each of the data processing subtasks comprises the data to be computed and/or the intermediate computing data, and the intermediate computing data is transmitted through the network between the target FPGA acceleration boards.</li>    </ul>    </li></ul></p><p id="p-0138" num="0158">According to the present embodiment, the data processing task is divided into the a plurality of data processing subtasks first. Then, the target FPGA acceleration boards corresponding to each of the data processing subtasks are determined in the FPGA accelerator side. The corresponding data processing subtask is executed by use of the target FPGA acceleration boards. When the target FPGA acceleration boards process the data processing subtask, the data processing result of other target FPGA acceleration boards may be taken as input data, and the data processing result computed by itself may also be sent to other target FPGA acceleration boards. The data processing result is transmitted between the target FPGA acceleration boards by the network rather than sent to the host side first and then forwarded by the host side. It can be seen that, according to the present embodiment, a physical limitation of host interfaces on the number of FPGA acceleration boards in an FPGA accelerator side may be avoided, thereby improving the data processing efficiency.</p><p id="p-0139" num="0159">The embodiment of the apparatus part is in mutual correspondence with the embodiment of the method part. Therefore, the embodiment of the system part refers to the descriptions about the embodiment of the method part, and will not be elaborated temporarily herein.</p><p id="p-0140" num="0160">The present application also provides a storage medium, having a computer program stored thereon which, when executed, may implement the steps provided in the above-mentioned embodiment. The storage medium may include various media capable of storing program codes such as a U disk, a mobile hard disk, a Read-Only Memory (ROM), a Random Access Memory (RAM), a magnetic disk, or an optical disk.</p><p id="p-0141" num="0161">The present application also provides an electronic device, which may include a memory and a processor. The memory stores a computer program. The processor, when calling the computer program in the memory, may implement the steps provided in the above-mentioned embodiment. Certainly, the electronic device may further include various network interfaces, a power supply, and other components.</p><p id="p-0142" num="0162">All the embodiments in this specification are described in a progressive manner. Contents mainly described in each embodiment are different from those described in other embodiments. Same or similar parts of all the embodiments refer to each other. For the system disclosed in the embodiments, since it corresponds to the method disclosed in the embodiments, the description is relatively simple, and the relevant part can be referred to the description of the method part. It should be noted that for a person of ordinary skill in the art, several improvements and modifications can be made to the present application without departing from the principle of the present application, and these improvements and modifications also fall within the scope of protection of the claims of the present application.</p><p id="p-0143" num="0163">It is also noted that in this specification, relationship terms such as first and second are used only to distinguish one entity or operation from another entity or operation, without necessarily requiring or implying any such actual relationship or order between those entities or operations. Further, the terms &#x201c;include&#x201d; &#x201c;comprise&#x201d; or any other variation thereof are intended to cover non-exclusive inclusion, such that a process, method, article, or apparatus that includes a set of elements includes not only those elements, but also other elements not expressly listed, or also include elements that are inherent to such process, method, article, or apparatus. With no more restrictions, an element defined by statement &#x201c;including a/an&#x201d; does not exclude the existence of the same other elements in a process, method, object, or device including the element.</p><?detailed-description description="Detailed Description" end="tail"?></description><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A data processing method, for applying to a host side, wherein the host side is connected to a Field Programmable Gate Array (FPGA) accelerator side, the FPGA accelerator side comprises a plurality of FPGA acceleration boards, and the FPGA acceleration boards are connected to each other through a network, the data processing method comprises:<claim-text>dividing a data processing task into a plurality of data processing subtasks, and determining, in the FPGA accelerator side, target FPGA acceleration boards corresponding to each of the data processing subtasks; and</claim-text><claim-text>sending data to be computed to the target FPGA acceleration boards, and executing the corresponding data processing subtask by use of each of the target FPGA acceleration boards to obtain a data processing result, wherein the data processing result comprises intermediate computing data or a final processing result of the data processing task, source data of each of the data processing subtasks comprises at least one of the data to be computed or the intermediate computing data, and the intermediate computing data is transmitted through the network between the target FPGA acceleration boards.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The data processing method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein after the sending data to be computed to the target FPGA acceleration boards, the method further comprises:<claim-text>configuring a data address and data length of the data to be computed into the target FPGA acceleration boards, whereby the target FPGA acceleration boards store the data to be computed according to the data address and the data length.</claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The data processing method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>configuring a computation result storage address into the target FPGA acceleration boards, whereby the target FPGA acceleration boards store at least one of the intermediate computing data or the final processing result into the computation result storage address.</claim-text></claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The data processing method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>selecting a first target FPGA acceleration board from all of the target FPGA acceleration boards;</claim-text><claim-text>sending all of the data processing subtasks and task distribution information to the first target FPGA acceleration board; wherein the task distribution information comprises correspondences between the data processing subtasks and the target FPGA acceleration boards; and</claim-text><claim-text>sending, by use of the first target FPGA acceleration board, the data processing subtasks to the corresponding target FPGA acceleration boards according to the task distribution information.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The data processing method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the sending data to be computed to the target FPGA acceleration boards comprises:<claim-text>selecting a second target FPGA acceleration board from all of the target FPGA acceleration boards;</claim-text><claim-text>sending all of the data to be computed and data distribution information to the second target FPGA acceleration board; wherein the data distribution information comprises correspondences between the data to be computed and the target FPGA acceleration boards; and</claim-text><claim-text>sending, by use of the second target FPGA acceleration board, the data to be computed to the corresponding FPGA acceleration boards according to the data distribution information.</claim-text></claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The data processing method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the sending data to be computed to the target FPGA acceleration boards comprises:<claim-text>sending the corresponding data to be computed to the target FPGA acceleration boards in a self-defined Remote Direct Memory Access (RDMA) transmission mode; and</claim-text><claim-text>correspondingly, the method further comprises:<claim-text>sending the corresponding data processing subtask to the target FPGA acceleration boards in a preset transmission mode; wherein the preset transmission mode comprises streaming or integral packet transmission.</claim-text></claim-text></claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The data processing method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>when the target FPGA acceleration boards send the intermediate computing data to other target FPGA acceleration boards based on the network, sending a data address and data length of the intermediate computing data to the other target FPGA acceleration boards, whereby the other target FPGA acceleration boards store the intermediate computing data according to the data address and the data length of the intermediate computing data.</claim-text></claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The data processing method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein data is transmitted between the target FPGA acceleration boards by a Medium Access Control (MAC) interface; data is transmitted between the host side and the target FPGA acceleration boards by a Peripheral Component Interconnect Express (PCIE) interface; and data is transmitted between a remote device and the target FPGA acceleration boards by a second MAC interface.</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The data processing method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein when the host side and the target FPGA acceleration boards are devices in a local area network, a packing operation is performed in a Medium Access Control (MAC) layer on communication data between the host side and the target FPGA acceleration boards; and<claim-text>When the host side and the target FPGA acceleration boards are devices in a public network, a packing operation is performed in a User Datagram Protocol (UDP) payload layer on communication data between the host side and the target FPGA acceleration boards, and a second packing operation is performed in the UDP payload layer on communication data between the target FPGA acceleration boards.</claim-text></claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. (canceled)</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. A distributed data flow programming framework, comprising a Central Processing Unit (CPU) acceleration stack and a Field Programmable Gate Array (FPGA) acceleration stack;<claim-text>the CPU acceleration stack is configured to provide an underlying support for dividing a data processing task, and is further configured to provide a host-side Application Programming Interface (API) for scheduling a data processing subtask;</claim-text><claim-text>the FPGA acceleration stack is configured to provide an acceleration interface corresponding to the host-side API, and is further configured to provide an acceleration data control program and a kernel control program during execution of the data processing subtask;</claim-text><claim-text>wherein when the distributed data flow programming framework is operating, the CPU acceleration stack divides the data processing task into a plurality of data processing subtasks, and determines, in an FPGA accelerator side, target FPGA acceleration boards corresponding to each of the data processing subtasks; and sends data to be computed to the target FPGA acceleration boards; and the FPGA acceleration stack executes the corresponding data processing subtask by use of each of the target FPGA acceleration boards to obtain a data processing result, wherein the data processing result comprises intermediate computing data or a final processing result of the data processing task, source data of each of the data processing subtasks comprises at least one of the data to be computed or the intermediate computing data, and the intermediate computing data is transmitted through a network between the target FPGA acceleration boards.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The distributed data flow programming framework of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the FPGA acceleration stack comprises:<claim-text>a static region, configured to execute the data processing subtask distributed by the CPU acceleration stack, and further configured to send the data processing result to the CPU acceleration stack or another target FPGA acceleration board; and</claim-text><claim-text>an FPGA acceleration engine, configured to send the data processing subtask to a local acceleration unit or an acceleration unit of other target FPGA acceleration boards to perform an accelerated computation operation.</claim-text></claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. An electronic device, comprising a memory and a processor, wherein the memory has a computer program thereon; and the processor, when calling the computer program in the memory, implements the steps of a data processing method, wherein the data processing method comprises:<claim-text>dividing a data processing task into a plurality of data processing subtasks, and determining, in a Field Programmable Gate Array (FPGA) accelerator side, target FPGA acceleration boards corresponding to each of the data processing subtasks; and</claim-text><claim-text>sending data to be computed to the target FPGA acceleration boards, and executing the corresponding data processing subtask by use of each of the target FPGA acceleration boards to obtain a data processing result, wherein the data processing result comprises intermediate computing data or a final processing result of the data processing task, source data of each of the data processing subtasks comprises at least one of the data to be computed or the intermediate computing data, and the intermediate computing data is transmitted through a network between the target FPGA acceleration boards.</claim-text></claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. (canceled)</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The electronic device of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein after the sending data to be computed to the target FPGA acceleration boards, the method further comprises:<claim-text>configuring a data address and data length of the data to be computed into the target FPGA acceleration boards, whereby the target FPGA acceleration boards store the data to be computed according to the data address and the data length.</claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The electronic device of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the data processing method further comprises:<claim-text>configuring a computation result storage address into the target FPGA acceleration boards, whereby the target FPGA acceleration boards store at least one of the intermediate computing data or the final processing result into the computation result storage address.</claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The electronic device of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the data processing method further comprises:<claim-text>selecting a first target FPGA acceleration board from all of the target FPGA acceleration boards;</claim-text><claim-text>sending all of the data processing subtasks and task distribution information to the first target FPGA acceleration board; wherein the task distribution information comprises correspondences between the data processing subtasks and the target FPGA acceleration boards; and</claim-text><claim-text>sending, by use of the first target FPGA acceleration board, the data processing subtasks to the corresponding target FPGA acceleration boards according to the task distribution information.</claim-text></claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The electronic device of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the sending data to be computed to the target FPGA acceleration boards comprises:<claim-text>selecting a second target FPGA acceleration board from all of the target FPGA acceleration boards;</claim-text><claim-text>sending all of the data to be computed and data distribution information to the second target FPGA acceleration board; wherein the data distribution information comprises correspondences between the data to be computed and the target FPGA acceleration boards; and</claim-text><claim-text>sending, by use of the second target FPGA acceleration board, the data to be computed to the corresponding FPGA acceleration boards according to the data distribution information.</claim-text></claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The electronic device of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the sending data to be computed to the target FPGA acceleration boards comprises:<claim-text>sending the corresponding data to be computed to the target FPGA acceleration boards in a self-defined Remote Direct Memory Access (RDMA) transmission mode; and</claim-text><claim-text>correspondingly, the method further comprises:<claim-text>sending the corresponding data processing subtask to the target FPGA acceleration boards in a preset transmission mode; wherein the preset transmission mode comprises streaming or integral packet transmission.</claim-text></claim-text></claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The electronic device of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the data processing method further comprises:<claim-text>when the target FPGA acceleration boards send the intermediate computing data to other target FPGA acceleration boards based on the network, sending a data address and data length of the intermediate computing data to the other target FPGA acceleration boards, whereby the other target FPGA acceleration boards store the intermediate computing data according to the data address and the data length of the intermediate computing data.</claim-text></claim-text></claim><claim id="CLM-00021" num="00021"><claim-text><b>21</b>. The electronic device of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein data is transmitted between the target FPGA acceleration boards by a Medium Access Control (MAC) interface; data is transmitted between the host side and the target FPGA acceleration boards by a Peripheral Component Interconnect Express (PCIE) interface; and data is transmitted between a remote device and the target FPGA acceleration boards by a second MAC interface.</claim-text></claim><claim id="CLM-00022" num="00022"><claim-text><b>22</b>. The electronic device of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein when the host side and the target FPGA acceleration boards are devices in a local area network, a packing operation is performed in a Medium Access Control (MAC) layer on communication data between the host side and the target FPGA acceleration boards; and<claim-text>When the host side and the target FPGA acceleration boards are devices in a public network, a packing operation is performed in a User Datagram Protocol (UDP) payload layer on communication data between the host side and the target FPGA acceleration boards, and a second packing operation is performed in the UDP payload layer on communication data between the target FPGA acceleration boards.</claim-text></claim-text></claim></claims></us-patent-application>