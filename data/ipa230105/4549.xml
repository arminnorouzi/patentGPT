<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004550A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004550</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17364606</doc-number><date>20210630</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>23</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>22</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>2365</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20190101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>16</main-group><subgroup>2272</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">VERIFYING DATA CONSISTENCY USING VERIFIERS IN A CONTENT MANAGEMENT SYSTEM FOR A DISTRIBUTED KEY-VALUE DATABASE</invention-title><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Dropbox, Inc.</orgname><address><city>San Francisco</city><state>CA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Le</last-name><first-name>Preslav</first-name><address><city>Belmont</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Walker</last-name><first-name>Braden</first-name><address><city>San Francisco</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>Tu</last-name><first-name>Leslie</first-name><address><city>San Francisco</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="03" designation="us-only"><addressbook><last-name>Lathia</last-name><first-name>Tanay</first-name><address><city>San Francisco</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="04" designation="us-only"><addressbook><last-name>Sosa</last-name><first-name>Alexander</first-name><address><city>San Francisco</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="05" designation="us-only"><addressbook><last-name>He</last-name><first-name>Lihao</first-name><address><city>San Mateo</city><state>CA</state><country>US</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A consistency verification system that verifies data consistency in a content item management system. The system maintains a plurality of verifiers for checking data consistency, each verifier comprising instructions for verifying consistency for a type of requests. The system may verify the original request by selecting a verifier from the plurality of verifiers based on a type of the original request. Using the selected verifier, the consistency verification system may send verification requests to the content item management system at a second timestamp that is a period of time after the original timestamp. The system may determine whether the second response is consistent with the first response. If the responses are not consistent, the system may output information describing data inconsistency. If the responses are consistent, the system may output results and perform further verifications to help ensure data accuracy.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="213.53mm" wi="158.75mm" file="US20230004550A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="234.44mm" wi="163.41mm" file="US20230004550A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="128.78mm" wi="159.09mm" file="US20230004550A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="213.53mm" wi="167.81mm" file="US20230004550A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="180.59mm" wi="165.44mm" file="US20230004550A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="200.15mm" wi="154.43mm" file="US20230004550A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="228.01mm" wi="153.25mm" orientation="landscape" file="US20230004550A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="228.01mm" wi="164.25mm" orientation="landscape" file="US20230004550A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="231.73mm" wi="146.73mm" file="US20230004550A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="238.84mm" wi="170.10mm" orientation="landscape" file="US20230004550A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="151.98mm" wi="154.35mm" file="US20230004550A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="239.10mm" wi="162.81mm" orientation="landscape" file="US20230004550A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="230.89mm" wi="129.37mm" file="US20230004550A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">TECHNICAL FIELD</heading><p id="p-0002" num="0001">The disclosed embodiments generally relate to database technologies, and particularly to verifiers that check data consistency in a content management system for a distributed key-value database.</p><heading id="h-0002" level="1">BACKGROUND</heading><p id="p-0003" num="0002">Distributed database system often involves managing large-scale distributed data tables and supporting concurrent access to a database. The distributed database system may maintain data tables distributed across multiple clusters and may process various types of requests such as read or write requests from multiple clients concurrently. Therefore, the distributed database system may face a challenge to ensure data consistency and accuracy with multiple clients accessing and modifying data simultaneously in the database system. For example, the database should perform consistently such that multiple requests with the same parameters should yield consistent results from the database system. As such, it is helpful to maintain a verification system that can effectively verify whether the database system is reliable and performs consistently without causing data corruptions.</p><heading id="h-0003" level="1">SUMMARY</heading><p id="p-0004" num="0003">Systems and methods are disclosed herein for a consistency verification system that verifies data consistency in a content management system. The consistency verification system may maintain a plurality of verifiers for checking data consistency in the content management system, where each verifier comprises a set of instructions for verifying consistency for a type of requests. The content management system may receive requests for accessing or processing data in the database and the consistency verification system may sample one or more requests from the requests received by the content management system. A sampled request may be referred to as an original request that was processed at a first timestamp T<b>1</b>. The original request may be associated with a set of parameters and a first response received at the first timestamp T<b>1</b>. The consistency verification system may verify the original request by selecting a verifier from the plurality of verifiers based on a type of the original request. Using the selected verifier, the consistency verification system may send one or more verification requests to the content management system at a second timestamp T<b>2</b> that is after the first timestamp T<b>1</b>. The consistency verification system may determine whether the second response matches the first response. Based on a determination that the second response does not match the first response, the consistency verification system may output information describing data inconsistency to the content management system. Based on a determination that the second response matches the first response, the consistency verification system may output results to the content management system and may further perform further verifications to help ensure data consistency and accuracy.</p><p id="p-0005" num="0004">The systems and methods disclosed herein provide various technical advantages. Because the content management system manages simultaneous execution of requests from multiple clients and manages data tables distributed across multiple clusters, it is challenging for the content management system to ensure that the requests don't interfere with each other and that data accuracy and consistency is maintained in the database. The systems and methods disclosed herein provide a verification system that effectively checks data consistency and accuracy by replaying previously processed requests. The verification system verifies results by sampling a plurality of requests and replay the sampled requests with the same parameters but with one or more hold off periods. The replayed requests may be referred to as verification requests. Depending on whether the verification requests yield the same results as the original requests, the verification system may output results to the content management system. Furthermore, the system and methods disclosed herein increase reliability and reduce the chance that errors occur during operations on slices by including various invariant checks, where the invariants are certain properties that the database needs to hold to ensure safe slice operations. Therefore, the content management system addresses the challenges faced by a large-scale distributed database through the systems and methods disclosed herein.</p><p id="p-0006" num="0005">The features and advantages described in this summary and the following detailed description are not all-inclusive. Many additional features and advantages will be apparent to one of ordinary skill in the art in view of the drawings, specification, and claims hereof.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0007" num="0006"><figref idref="DRAWINGS">FIG. <b>1</b></figref> shows a diagram of a system environment of a content management system and a collaborative content management system according to one example embodiment.</p><p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. <b>2</b></figref> shows a block diagram of components of a client device, according to one example embodiment.</p><p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. <b>3</b></figref> shows a block diagram of a content management system, according to one example embodiment.</p><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. <b>4</b></figref> shows a block diagram of a collaborative content management system, according to one example embodiment.</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. <b>5</b></figref> shows a block diagram of modules in a content item management system, the content item management system including a consistency verification system, according to one example embodiment.</p><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>6</b></figref> shows exemplary data structures for local slice datastore, according to one example embodiment.</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. <b>7</b>-<b>8</b></figref> illustrate exemplary data structures for slice registry datastore, according to one example embodiment.</p><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. <b>9</b></figref> shows an exemplary process for transferring a source slice to a destination slice and various states that the slices go through, according to one example embodiment.</p><p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. <b>10</b></figref> shows a block diagram of modules in the consistency verification system of the content item management system, according to one example embodiment.</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. <b>11</b></figref> illustrates an exemplary verification process performed by the consistency verification system, according to one example embodiment.</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>12</b></figref> illustrates an exemplary process for verifying a previously performed request, according to one example embodiment.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><p id="p-0018" num="0017">The figures depict various embodiments of the present invention for purposes of illustration only. One skilled in the art will readily recognize from the following description that other alternative embodiments of the structures and methods illustrated herein may be employed without departing from the principles of the invention described herein.</p><heading id="h-0005" level="1">DETAILED DESCRIPTION</heading><heading id="h-0006" level="2">System Overview</heading><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>1</b></figref> shows a system environment including content management system <b>100</b>, collaborative content management system <b>130</b>, and client devices <b>120</b><i>a</i>, <b>120</b><i>b</i>, and <b>120</b><i>c </i>(collectively or individually &#x201c;<b>120</b>&#x201d;). Content management system <b>100</b> provides functionality for sharing content items with one or more client devices <b>120</b> and synchronizing content items between content management system <b>100</b> and one or more client devices <b>120</b>.</p><p id="p-0020" num="0019">The content stored by content management system <b>100</b> can include any type of content items, such as documents, spreadsheets, collaborative content items, text files, audio files, image files, video files, webpages, executable files, binary files, placeholder files that reference other content items, etc. In some implementations, a content item can be a portion of another content item, such as an image that is included in a document. Content items can also include collections, such as folders, namespaces, playlists, albums, etc., that group other content items together. The content stored by content management system <b>100</b> may be organized in one configuration in folders, tables, or in other database structures (e.g., object oriented, key/value etc.).</p><p id="p-0021" num="0020">In one embodiment, the content stored by content management system <b>100</b> includes content items created by using third party applications, e.g., word processors, video and image editors, database management systems, spreadsheet applications, code editors, and so forth, which are independent of content management system <b>100</b>.</p><p id="p-0022" num="0021">In some embodiments, content stored by content management system <b>100</b> includes content items, e.g., collaborative content items, created using a collaborative interface provided by collaborative content management system <b>130</b>. In various implementations, collaborative content items can be stored by collaborative content management system <b>130</b>, with content management system <b>100</b>, or external to content management system <b>100</b>. A collaborative interface can provide an interactive content item collaborative platform whereby multiple users can simultaneously create and edit collaborative content items, comment in the collaborative content items, and manage tasks within the collaborative content items.</p><p id="p-0023" num="0022">Users may create accounts at content management system <b>100</b> and store content thereon by sending such content from client device <b>120</b> to content management system <b>100</b>. The content can be provided by users and associated with user accounts that may have various privileges. For example, privileges can include permissions to: see content item titles, see other metadata for the content item (e.g. location data, access history, version history, creation/modification dates, comments, file hierarchies, etc.), read content item contents, modify content item metadata, modify content of a content item, comment on a content item, read comments by others on a content item, or grant or remove content item permissions for other users.</p><p id="p-0024" num="0023">Client devices <b>120</b> communicate with content management system <b>100</b> and collaborative content management system <b>130</b> through network <b>110</b>. The network may be any suitable communications network for data transmission. In one embodiment, network <b>110</b> is the Internet and uses standard communications technologies and/or protocols. Thus, network <b>110</b> can include links using technologies such as Ethernet, 802.11, worldwide interoperability for microwave access (WiMAX), 3G, 4G, digital subscriber line (DSL), asynchronous transfer mode (ATM), InfiniBand, PCI Express Advanced Switching, etc. Similarly, the networking protocols used on network <b>110</b> can include multiprotocol label switching (MPLS), the transmission control protocol/Internet protocol (TCP/IP), the User Datagram Protocol (UDP), the hypertext transport protocol (HTTP), the simple mail transfer protocol (SMTP), the file transfer protocol (FTP), etc. The data exchanged over network <b>110</b> can be represented using technologies and/or formats including the hypertext markup language (HTML), the extensible markup language (XML), JavaScript Object Notation (JSON), etc. In addition, all or some of links can be encrypted using conventional encryption technologies such as the secure sockets layer (SSL), transport layer security (TLS), virtual private networks (VPNs), Internet Protocol security (IPsec), etc. In another embodiment, the entities use custom and/or dedicated data communications technologies instead of, or in addition to, the ones described above.</p><p id="p-0025" num="0024">In some embodiments, content management system <b>100</b> and collaborative content management system <b>130</b> are combined into a single system. The system may include one or more servers configured to provide the functionality discussed herein for the systems <b>100</b> and <b>130</b>.</p><heading id="h-0007" level="2">Client Device</heading><p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. <b>2</b></figref> shows a block diagram of the components of a client device <b>120</b> according to one embodiment. Client devices <b>120</b> generally include devices and modules for communicating with content management system <b>100</b> and a user of client device <b>120</b>. Client device <b>120</b> includes display <b>210</b> for providing information to the user, and in certain client devices <b>120</b> includes a touchscreen. Client device <b>120</b> also includes network interface <b>220</b> for communicating with content management system <b>100</b> via network <b>110</b>. There are additional components that may be included in client device <b>120</b> but that are not shown, for example, one or more computer processors, local fixed memory (RAM and ROM), as well as optionally removable memory (e.g., SD-card), power sources, and audio-video outputs.</p><p id="p-0027" num="0026">In certain embodiments, client device <b>120</b> includes additional components such as camera <b>230</b> and location module <b>240</b>. Location module <b>240</b> determines the location of client device <b>120</b>, using, for example, a global positioning satellite signal, cellular tower triangulation, or other methods. Location module <b>240</b> may be used by client application <b>200</b> to obtain location data and add the location data to metadata about a content item.</p><p id="p-0028" num="0027">Client devices <b>120</b> maintain various types of components and modules for operating the client device and accessing content management system <b>100</b>. The software modules can include operating system <b>250</b> or a collaborative content item editor <b>270</b>. Collaborative content item editor <b>270</b> is configured for creating, viewing and modifying collaborative content items such as text documents, code files, mixed media files (e.g., text and graphics), presentations or the like. Operating system <b>250</b> on each device provides a local file management system and executes the various software modules such as content management system client application <b>200</b> and collaborative content item editor <b>270</b>. A contact directory <b>290</b> stores information on the user's contacts, such as name, telephone numbers, company, email addresses, physical address, website URLs, and the like.</p><p id="p-0029" num="0028">Client devices <b>120</b> access content management system <b>100</b> and collaborative content management system <b>130</b> in a variety of ways. Client device <b>120</b> may access these systems through a native application or software module, such as content management system client application <b>200</b>. Client device <b>120</b> may also access content management system <b>100</b> through web browser <b>260</b>. As an alternative, the client application <b>200</b> may integrate access to content management system <b>100</b> with the local file management system provided by operating system <b>250</b>. When access to content management system <b>100</b> is integrated in the local file management system, a file organization scheme maintained at the content management system is represented at the client device <b>120</b> as a local file structure by operating system <b>250</b> in conjunction with client application <b>200</b>.</p><p id="p-0030" num="0029">Client application <b>200</b> manages access to content management system <b>100</b> and collaborative content management system <b>130</b>. Client application <b>200</b> includes user interface module <b>202</b> that generates an interface to the content accessed by client application <b>200</b> and is one means for performing this function. The generated interface is provided to the user by display <b>210</b>. Client application <b>200</b> may store content accessed from a content storage at content management system <b>100</b> in local content <b>204</b>. While represented here as within client application <b>200</b>, local content <b>204</b> may be stored with other data for client device <b>120</b> in non-volatile storage. When local content <b>204</b> is stored this way, the content is available to the user and other applications or modules, such as collaborative content item editor <b>270</b>, when client application <b>200</b> is not in communication with content management system <b>100</b>. Content access module <b>206</b> manages updates to local content <b>204</b> and communicates with content management system <b>100</b> to synchronize content modified by client device <b>120</b> with content maintained on content management system <b>100</b>, and is one means for performing this function. Client application <b>200</b> may take various forms, such as a stand-alone application, an application plug-in, or a browser extension.</p><heading id="h-0008" level="2">Content Management System</heading><p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. <b>3</b></figref> shows a block diagram of the content management system <b>100</b> according to one embodiment. To facilitate the various content management services, a user can create an account with content management system <b>100</b>. The account information can be maintained in user account database <b>316</b>, and is one means for performing this function. User account database <b>316</b> can store profile information for registered users. In some cases, the only personal information in the user profile is a username and/or email address. However, content management system <b>100</b> can also be configured to accept additional user information, such as password recovery information, demographics information, payment information, and other details. Each user is associated with a userID and a username. For purposes of convenience, references herein to information such as collaborative content items or other data being &#x201c;associated&#x201d; with a user are understood to mean an association between a collaborative content item and either of the above forms of user identifier for the user. Similarly, data processing operations on collaborative content items and users are understood to be operations performed on derivative identifiers such as collaborativeContentItemID and userIDs. For example, a user may be associated with a collaborative content item by storing the information linking the userID and the collaborativeContentItemID in a table, file, or other storage formats. For example, a database table organized by collaborativeContentItemIDs can include a column listing the userID of each user associated with the collaborative content item. As another example, for each userID, a file can list a set of collaborativeContentItemID associated with the user. As another example, a single file can list key values pairs such as &#x3c;userID, collaborativeContentItemID&#x3e;representing the association between an individual user and a collaborative content item. The same types of mechanisms can be used to associate users with comments, threads, text elements, formatting attributes, and the like.</p><p id="p-0032" num="0031">User account database <b>316</b> can also include account management information, such as account type, e.g. free or paid; usage information for each user, e.g., file usage history; maximum storage space authorized; storage space used; content storage locations; security settings; personal configuration settings; content sharing data; etc. Account management module <b>304</b> can be configured to update and/or obtain user account details in user account database <b>316</b>. Account management module <b>304</b> can be configured to interact with any number of other modules in content management system <b>100</b>.</p><p id="p-0033" num="0032">An account can be used to store content items, such as collaborative content items, audio files, video files, etc., from one or more client devices associated with the account. Content items can be shared with multiple users and/or user accounts. In some implementations, sharing a content item can include associating, using sharing module <b>310</b>, the content item with two or more user accounts and providing for user permissions so that a user that has authenticated into one of the associated user accounts has a specified level of access to the content item. That is, the content items can be shared across multiple client devices of varying type, capabilities, operating systems, etc. The content items can also be shared across varying types of user accounts.</p><p id="p-0034" num="0033">Individual users can be assigned different access privileges to a content item shared with them, as discussed above. In some cases, a user's permissions for a content item can be explicitly set for that user. A user's permissions can also be set based on: a type or category associated with the user (e.g., elevated permissions for administrator users or manager), the user's inclusion in a group or being identified as part of an organization (e.g., specified permissions for all members of a particular team), and/or a mechanism or context of a user's accesses to a content item (e.g., different permissions based on where the user is, what network the user is on, what type of program or API the user is accessing, whether the user clicked a link to the content item, etc.). Additionally, permissions can be set by default for users, user types/groups, or for various access mechanisms and contexts.</p><p id="p-0035" num="0034">In some implementations, shared content items can be accessible to a recipient user without requiring authentication into a user account. This can include sharing module <b>310</b> providing access to a content item through activation of a link associated with the content item or providing access through a globally accessible shared folder.</p><p id="p-0036" num="0035">The content can be stored in content storage <b>318</b>, which is one means for performing this function. Content storage <b>318</b> can be a storage device, multiple storage devices, or a server. Alternatively, content storage <b>318</b> can be a cloud storage provider or network storage accessible via one or more communications networks. The cloud storage provider or network storage may be owned and managed by the content management system <b>100</b> or by a third party. In one configuration, content management system <b>100</b> stores the content items in the same organizational structure as they appear on the client device. However, content management system <b>100</b> can store the content items in its own order, arrangement, or hierarchy.</p><p id="p-0037" num="0036">Content storage <b>318</b> can also store metadata describing content items, content item types, and the relationship of content items to various accounts, folders, or groups. The metadata for a content item can be stored as part of the content item or can be stored separately. In one configuration, each content item stored in content storage <b>318</b> can be assigned a system-wide unique identifier.</p><p id="p-0038" num="0037">In one embodiment, content storage <b>318</b> may be a distributed system that stores data as key-value pairs in tables distributed across multiple nodes, where a node may be a system or a device (such as a computer or a server) that stores a portion of the data. In one embodiment, a data table (or table) is a collection of key-value pairs (may also be referred to as entries) that are stored in one node or distributed across multiple nodes. A set of related tables may be grouped as a family of tables.</p><p id="p-0039" num="0038">In one embodiment, the keys are tuples and are used to partition data tables into slices. A slice is a portion of a family of tables including a contiguous key range across one or more tables. For example, a node may contain a first slice and a second slice, with the first slice covering key range [a, d) (i.e. a through d, not including d) from family 1, table 1, and the second slice covering key range [c, e] (i.e. c through e) from family 2, table 1. Each slice is associated with a set of metadata (e.g. slice ID, timestamp, state, etc.) which is stored and managed by content item management module <b>308</b>, which is discussed in greater detail below in accordance with <figref idref="DRAWINGS">FIG. <b>5</b></figref>.</p><p id="p-0040" num="0039">Content storage <b>318</b> can decrease the amount of storage space required by identifying duplicate files or duplicate segments of files. Instead of storing multiple copies of an identical content item, content storage <b>318</b> can store a single copy and then use a pointer or other mechanism to link the duplicates to the single copy. Similarly, content storage <b>318</b> stores files using a file version control mechanism that tracks changes to files, different versions of files (such as a diverging version tree), and a change history. The change history can include a set of changes that, when applied to the original file version, produces the changed file version.</p><p id="p-0041" num="0040">Content storage <b>318</b> may further decrease the amount of storage space required by deleting content items based on expiration time of the content items. An expiration time for a content item may indicate that the content item is no longer needed after the expiration time and may therefore be deleted. Content storage <b>318</b> may periodically scan through the content items and compare expiration time with current time. If the expiration time of a content item is earlier than the current time, content storage <b>318</b> may delete the content item from content storage <b>318</b>.</p><p id="p-0042" num="0041">Content management system <b>100</b> automatically synchronizes content from one or more client devices, using synchronization module <b>312</b>, which is one means for performing this function. The synchronization is platform agnostic. That is, the content is synchronized across multiple client devices <b>120</b> of varying type, capabilities, operating systems, etc. For example, client application <b>200</b> synchronizes, via synchronization module <b>312</b> at content management system <b>100</b>, content in client device <b>120</b>'s file system with the content in an associated user account on system <b>100</b>. Client application <b>200</b> synchronizes any changes to content in a designated folder and its sub-folders with the synchronization module <b>312</b>. Such changes include new, deleted, modified, copied, or moved files or folders. Synchronization module <b>312</b> also provides any changes to content associated with client device <b>120</b> to client application <b>200</b>. This synchronizes the local content at client device <b>120</b> with the content items at content management system <b>100</b>.</p><p id="p-0043" num="0042">Conflict management module <b>314</b> determines whether there are any discrepancies between versions of a content item located at different client devices <b>120</b>. For example, when a content item is modified at one client device and a second client device, differing versions of the content item may exist at each client device. Synchronization module <b>312</b> determines such versioning conflicts, for example by identifying the modification time of the content item modifications. Conflict management module <b>314</b> resolves the conflict between versions by any suitable means, such as by merging the versions, or by notifying the client device of the later-submitted version.</p><p id="p-0044" num="0043">A user can also view or manipulate content via a web interface generated by user interface module <b>302</b>. For example, the user can navigate in web browser <b>260</b> to a web address provided by content management system <b>100</b>. Changes or updates to content in content storage <b>318</b> made through the web interface, such as uploading a new version of a file, are synchronized back to other client devices <b>120</b> associated with the user's account. Multiple client devices <b>120</b> may be associated with a single account and files in the account are synchronized between each of the multiple client devices <b>120</b>.</p><p id="p-0045" num="0044">Content management system <b>100</b> includes communications interface <b>300</b> for interfacing with various client devices <b>120</b>, and with other content and/or service providers via an Application Programming Interface (API), which is one means for performing this function. Certain software applications access content storage <b>318</b> via an API on behalf of a user. For example, a software package, such as an app on a smartphone or tablet computing device, can programmatically make calls directly to content management system <b>100</b>, when a user provides credentials, to read, write, create, delete, share, or otherwise manipulate content. Similarly, the API can allow users to access all or part of content storage <b>318</b> through a web site.</p><p id="p-0046" num="0045">Content management system <b>100</b> can also include authenticator module <b>306</b>, which verifies user credentials, security tokens, API calls, specific client devices, etc., to determine whether access to requested content items is authorized, and is one means for performing this function. Authenticator module <b>306</b> can generate one-time use authentication tokens for a user account. Authenticator module <b>306</b> assigns an expiration period or date to each authentication token. In addition to sending the authentication tokens to requesting client devices, authenticator module <b>306</b> can store generated authentication tokens in authentication token database <b>320</b>. After receiving a request to validate an authentication token, authenticator module <b>306</b> checks authentication token database <b>320</b> for a matching authentication token assigned to the user. Once the authenticator module <b>306</b> identifies a matching authentication token, authenticator module <b>306</b> determines if the matching authentication token is still valid. For example, authenticator module <b>306</b> verifies that the authentication token has not expired or was not marked as used or invalid. After validating an authentication token, authenticator module <b>306</b> may invalidate the matching authentication token, such as a single-use token. For example, authenticator module <b>306</b> can mark the matching authentication token as used or invalid, or delete the matching authentication token from authentication token database <b>320</b>.</p><p id="p-0047" num="0046">In some embodiments, content management system <b>100</b> includes a content item management module <b>308</b> for maintaining a content directory that identifies the location of each content item in content storage <b>318</b>, and allows client applications to request access to content items in the storage <b>318</b>, and which is one means for performing this function. A content entry in the content directory can also include a content pointer that identifies the location of the content item in content storage <b>318</b>. For example, the content entry can include a content pointer designating the storage address of the content item in memory. In some embodiments, the content entry includes multiple content pointers that point to multiple locations, each of which contains a portion of the content item.</p><p id="p-0048" num="0047">In addition to a content path and content pointer, a content entry in some configurations also includes user account identifier that identifies the user account that has access to the content item. In some embodiments, multiple user account identifiers can be associated with a single content entry indicating that the content item has shared access by the multiple user accounts.</p><p id="p-0049" num="0048">Content item management module <b>308</b> may process various types of requests such as read and write requests. A read request may specify input parameters such as a timestamp and a key. Responsive to receiving the read request, content item management module <b>308</b> may return a response including data for the respective key and the data is retrieved from the database snapshotted at the specified timestamp. A write request may specify parameters such as a timestamp and a key. The write request may further specify other parameters such as pre-conditions for the write request. The write request may not be executed if the one or more preconditions are not met at the time when the write request is to be processed. For example, a write request may specify that a write operation should be processed only if a precondition is achieved. A precondition may be a state that the database should meet at a timestamp (which may be referred to as a precondition timestamp) that is before the request timestamp. For example, a write request may request to perform a write operation to the database at timestamp T<b>1</b> if a precondition is met such that the precondition requires that, at time T<b>0</b>, the database is in a particular state. As a more specific example, a precondition may specify that a request to the database with key K<b>1</b> at timestamp T<b>0</b> should return response R<b>1</b>, and if the precondition is met, a write request may be issued. In one embodiment, a write request specifies a set of preconditions. Responsive to receiving the write request, content item management module <b>308</b> may evaluate the preconditions by verifying whether the preconditions hold for the latest data (e.g. data associated with the latest timestamp) stored in the database. If the preconditions hold, a timestamp may be generated for the write request and respective write operations may be performed. In one embodiment, a precondition may be any constraints regarding parameters or behaviors associated with the database.</p><p id="p-0050" num="0049">In one embodiment, content item management module <b>308</b> manages slices stored in content storage <b>318</b> and stores metadata associated with the slices. In one configuration, content item management module <b>308</b> stores metadata such as a slice identifier (ID), a key range that identifies the keys covered by the slice, state information that implies read or write permissions that the slice is able to serve, and timestamp information that indicates the order in time when a state transition of the slice took place. The state information may also indicate whether a slice is claimed or unclaimed. If a slice is claimed, the slice has the most up-to-date data for the key range that the slice covers (which may be also referred to as the slice has claim for the key range), and if a slice is unclaimed, the slice may not have the most updated data, which may also be referred to as the slice does not have claim for the key range.</p><p id="p-0051" num="0050">In one embodiment, content item management module <b>318</b> may rebalance data stored across multiple nodes by performing various operations such as transferring slices from one node to another node, merging slices, and splitting a slice into multiple slices. Content item management module <b>308</b> may rebalance data among nodes if content item management module <b>308</b> determines that data distribution across nodes is uneven (e.g. a node stores significantly more data compared to other nodes or a slice grows in size faster than other slices). In such situations, content item management module <b>308</b> may, for example, decide to transfer the data in a slice from the current node to another node that stores less data. Each operation (e.g. transferring, merging or splitting) may be accomplished by performing multiple actions, and each action may cause changes in states for one or more slices. For example, if content item management module <b>308</b> transfers data from a first slice to a second slice, during the transfer process, the two slices may each move through a series of states according to their respective state machines. Further detail regarding state transitions for slices during a slice transfer is discussed in accordance with state management module <b>532</b> in <figref idref="DRAWINGS">FIG. <b>5</b></figref> and also discussed in accordance with the example illustrated in <figref idref="DRAWINGS">FIG. <b>9</b></figref>.</p><p id="p-0052" num="0051">Content item management module <b>308</b> may also store a centralized slice registry log that contains a tracked history of timestamped states for slices globally (i.e. for slices on a collection of nodes as opposed to slices on a single node). For example, during a slice transfer operation, each state transition may be associated with a timestamp that indicates when the transition took place. For each complete state transition, content item management module <b>308</b> may assign the slice a global timestamp such as a real time stamp (e.g. date and time) or a representation of real time (e.g. 1, 2, 3) to the slice according to the time and order when the state transition took place. Assigning global timestamps to slices across a collection of nodes may provide a serial view of the time and order in which each state transition took place globally. Maintaining historical timestamps and state transitions for each slice may provide consistent snapshot views for each slice given a certain point in time. If multiple requests from different nodes are received to read a slice for a certain timestamp, the requests always get the same results because of the centralized slice registry log.</p><p id="p-0053" num="0052">Content item management module <b>308</b> may also include a consistency verification system that verifies data consistency and accuracy with a plurality of verifiers. The consistency verification system may sample a plurality of requests from requests sent to the content item management module <b>308</b> and verify the sampled requests by replaying the requests with the same request parameters but with various holdoff periods. Consistency verification system may also include an invariant checking module that performs various invariants checks on metadata such as checking state information and timestamps to ensure that a state transition is valid. Consistency verification system may output verification results to content item management module <b>308</b>, and content item management module <b>308</b> may reject any state transition that is determined to be invalid and allow state transitions that are determined to be valid. Consistency verification system is discussed in further detail in accordance with <figref idref="DRAWINGS">FIGS. <b>10</b>-<b>12</b></figref>.</p><p id="p-0054" num="0053">In some embodiments, the content management system <b>100</b> can include a mail server module <b>322</b>. The mail server module <b>322</b> can send (and receive) collaborative content items to (and from) other client devices using the collaborative content management system <b>100</b>. The mail server module can also be used to send and receive messages between users in the content management system.</p><heading id="h-0009" level="2">Collaborative Content Management System</heading><p id="p-0055" num="0054"><figref idref="DRAWINGS">FIG. <b>4</b></figref> shows a block diagram of the collaborative content management system <b>130</b>, according to one embodiment. Collaborative content items can be files that users can create and edit using a collaborative content items editor <b>270</b> and can contain collaborative content item elements. Collaborative content item elements may include any type of content such as text; images, animations, videos, audio, or other multi-media; tables; lists; references to external content; programming code; tasks; tags or labels; comments; or any other type of content. Collaborative content item elements can be associated with an author identifier, attributes, interaction information, comments, sharing users, etc. Collaborative content item elements can be stored as database entities, which allows for searching and retrieving the collaborative content items. As with other types of content items, collaborative content items may be shared and synchronized with multiple users and client devices <b>120</b>, using sharing <b>310</b> and synchronization <b>312</b> modules of content management system <b>100</b>. Users operate client devices <b>120</b> to create and edit collaborative content items, and to share collaborative content items with other users of client devices <b>120</b>. Changes to a collaborative content item by one client device <b>120</b> are propagated to other client devices <b>120</b> of users associated with that collaborative content item.</p><p id="p-0056" num="0055">In the embodiment of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, collaborative content management system <b>130</b> is shown as separate from content management system <b>100</b> and can communicate with it to obtain its services. In other embodiments, collaborative content management system <b>130</b> is a subsystem of the component of content management system <b>100</b> that provides sharing and collaborative services for various types of content items. User account database <b>316</b> and authentication token database <b>320</b> from content management system <b>100</b> are used for accessing collaborative content management system <b>130</b> described herein.</p><p id="p-0057" num="0056">Collaborative content management system <b>130</b> can include various servers for managing access and edits to collaborative content items and for managing notifications about certain changes made to collaborative content items. Collaborative content management system <b>130</b> can include proxy server <b>402</b>, collaborative content item editor <b>404</b>, backend server <b>406</b>, and collaborative content item database <b>408</b>, access link module <b>410</b>, copy generator <b>412</b>, collaborative content item differentiator <b>414</b>, settings module <b>416</b>, metadata module <b>418</b>, revision module <b>420</b>, notification server <b>422</b>, and notification database <b>424</b>. Proxy server <b>402</b> handles requests from client applications <b>200</b> and passes those requests to the collaborative content item editor <b>404</b>. Collaborative content item editor <b>404</b> manages application level requests for client applications <b>200</b> for editing and creating collaborative content items, and selectively interacts with backend servers <b>406</b> for processing lower level processing tasks on collaborative content items, and interfacing with collaborative content items database <b>408</b> as needed. Collaborative content items database <b>408</b> contains a plurality of database objects representing collaborative content items, comment threads, and comments. Each of the database objects can be associated with a content pointer indicating the location of each object within the CCI database <b>408</b>. Notification server <b>422</b> detects actions performed on collaborative content items that trigger notifications, creates notifications in notification database <b>424</b>, and sends notifications to client devices.</p><p id="p-0058" num="0057">Client application <b>200</b> sends a request relating to a collaborative content item to proxy server <b>402</b>. Generally, a request indicates the userID (&#x201c;UID&#x201d;) of the user, and the collaborativeContentItemID (&#x201c;NID&#x201d;) of the collaborative content item, and additional contextual information as appropriate, such as the text of the collaborative content item. When proxy server <b>402</b> receives the request, the proxy server <b>402</b> passes the request to the collaborative content item editor <b>404</b>. Proxy server <b>402</b> also returns a reference to the identified collaborative content items proxy server <b>402</b> to client application <b>200</b>, so the client application can directly communicate with the collaborative content item editor <b>404</b> for future requests. In an alternative embodiment, client application <b>200</b> initially communicates directly with a specific collaborative content item editor <b>404</b> assigned to the userID.</p><p id="p-0059" num="0058">When collaborative content item editor <b>404</b> receives a request, it determines whether the request can be executed directly or by a backend server <b>406</b>. When the request adds, edits, or otherwise modifies a collaborative content item the request is handled by the collaborative content item editor <b>404</b>. If the request is directed to a database or index inquiry, the request is executed by a backend server <b>406</b>. For example, a request from client device <b>120</b> to view a collaborative content item or obtain a list of collaborative content items responsive to a search term is processed by backend server <b>406</b>.</p><p id="p-0060" num="0059">The access module <b>410</b> receives a request to provide a collaborative content item to a client device. In one embodiment, the access module generates an access link to the collaborative content item, for instance in response to a request to share the collaborative content item by an author. The access link can be a hyperlink including or associated with the identification information of the CCI (i.e., unique identifier, content pointer, etc.). The hyperlink can also include any type of relevant metadata within the content management system (i.e., author, recipient, time created, etc.). In one embodiment, the access module can also provide the access link to user accounts via the network <b>110</b>, while in other embodiments the access link can be provided or made accessible to a user account and is accessed through a user account via the client device. In one embodiment, the access link will be a hyperlink to a landing page (e.g., a webpage, a digital store front, an application login, etc.) and activating the hyperlink opens the landing page on a client device. The landing page can allow client devices not associated with a user account to create a user account and access the collaborative content item using the identification information associated with the access link. Additionally, the access link module can insert metadata into the collaborative content item, associate metadata with the collaborative content item, or access metadata associated with the collaborative content item that is requested.</p><p id="p-0061" num="0060">The access module <b>410</b> can also provide collaborative content items via other methods. For example, the access module <b>410</b> can directly send a collaborative content item to a client device or user account, store a collaborative content item in a database accessible to the client device, interact with any module of the collaborative content management system to provide modified versions of collaborative content items (e.g., the copy generator <b>412</b>, the CCI differentiator <b>414</b>, etc.), sending content pointer associated with the collaborative content item, sending metadata associated with the collaborative content item, or any other method of providing collaborative content items between devices in the network. The access module can also provide collaborative content items via a search of the collaborative content item database (i.e., search by a keyword associated with the collaborative content item, the title, or a metadata tag, etc.).</p><p id="p-0062" num="0061">The copy generator <b>412</b> can duplicate a collaborative content item. Generally, the copy generator duplicates a collaborative content item when a client device selects an access link associated with the collaborative content item. The copy generator <b>412</b> accesses the collaborative content item associated with the access link and creates a derivative copy of the collaborative content item for every request received. The copy generator <b>412</b> stores each derivative copy of the collaborative content item in the collaborative content item database <b>408</b>. Generally, each copy of the collaborative content item that is generated by the copy generator <b>412</b> is associated with both the client device from which the request was received and the user account associated with the client device requesting the copy. When the copy of the collaborative content item is generated it can create a new unique identifier and content pointer for the copy of the collaborative content item. Additionally, the copy generator <b>412</b> can insert metadata into the collaborative content item, associate metadata with the copied collaborative content item, or access metadata associated with the collaborative content item that was requested to be copied.</p><p id="p-0063" num="0062">The collaborative content item differentiator <b>414</b> determines the difference between two collaborative content items. In one embodiment, the collaborative content item differentiator <b>414</b> determines the difference between two collaborative content items when a client device selects an access hyperlink and accesses a collaborative content item that the client device has previously used the copy generator <b>412</b> to create a derivative copy. The content item differentiator can indicate the differences between the content elements of the compared collaborative content items. The collaborative content item differentiator <b>414</b> can create a collaborative content item that includes the differences between the two collaborative content items, i.e. a differential collaborative content item. In some embodiments, the collaborative content item differentiator provides the differential collaborative content item to a requesting client device <b>120</b>. The differentiator <b>414</b> can store the differential collaborative content item in the collaborative content item database <b>408</b> and generate identification information for the differential collaborative content item. Additionally, the differentiator <b>414</b> can insert metadata into the accessed and created collaborative content items, associate metadata with the accessed and created collaborative content item, or access metadata associated with the collaborative content items that were requested to be differentiated.</p><p id="p-0064" num="0063">The settings and security module <b>416</b> can manage security during interactions between client devices <b>120</b>, the content management system <b>100</b>, and the collaborative content management system <b>130</b>. Additionally, the settings and security module <b>416</b> can manage security during interactions between modules of the collaborative content management system. For example, when a client device <b>120</b> attempts to interact within any module of the collaborative content management system <b>100</b>, the settings and security module <b>416</b> can manage the interaction by limiting or disallowing the interaction. Similarly, the settings and security module <b>416</b> can limit or disallow interactions between modules of the collaborative content management system <b>130</b>. Generally, the settings and security module <b>416</b> accesses metadata associated with the modules, systems <b>100</b> and <b>130</b>, devices <b>120</b>, user accounts, and collaborative content items to determine the security actions to take. Security actions can include: requiring authentication of client devices <b>120</b> and user accounts, requiring passwords for content items, removing metadata from collaborative content items, preventing collaborative content items from being edited, revised, saved or copied, or any other security similar security action. Additionally, settings and security module can access, add, edit or delete any type of metadata associated with any element of content management system <b>100</b>, collaborative content management system <b>130</b>, client devices <b>120</b>, or collaborative content items.</p><p id="p-0065" num="0064">The metadata module <b>418</b> manages metadata within with the collaborative content management system. Generally, metadata can take three forms within the collaborative content management system: internal metadata, external metadata, and device metadata. Internal metadata is metadata within a collaborative content item, external metadata is metadata associated with a CCI but not included or stored within the CCI itself, and device metadata is associated with client devices. At any point the metadata module can manage metadata by changing, adding, or removing metadata.</p><p id="p-0066" num="0065">Some examples of internal metadata can be: identifying information within collaborative content items (e.g., email addresses, names, addresses, phone numbers, social security numbers, account or credit card numbers, etc.); metadata associated with content elements (e.g., location, time created, content element type; content element size; content element duration, etc.); comments associated with content elements (e.g., a comment giving the definition of a word in a collaborative content item and its attribution to the user account that made the comment); or any other metadata that can be contained within a collaborative content item.</p><p id="p-0067" num="0066">Some examples of external metadata can be: content tags indicating categories for the metadata; user accounts associated with a CCI (e.g., author user account, editing user account, accessing user account etc.); historical information (e.g., previous versions, access times, edit times, author times, etc.); security settings; identifying information (e.g., unique identifier, content pointer); collaborative content management system <b>130</b> settings; user account settings; or any other metadata that can be associated with the collaborative content item.</p><p id="p-0068" num="0067">Some examples of device metadata can be: device type; device connectivity; device size; device functionality; device sound and display settings; device location; user accounts associated with the device; device security settings; or any other type of metadata that can be associated with a client device <b>120</b>.</p><p id="p-0069" num="0068">The collaborative content item revision module <b>420</b> manages application level requests for client applications <b>200</b> for revising differential collaborative content items and selectively interacts with backend servers <b>406</b> for processing lower level processing tasks on collaborative content items, and interfacing with collaborative content items database <b>408</b> as needed. The revision module can create a revised collaborative content item that is some combination of the content elements from the differential collaborative content item. The revision module <b>420</b> can store the revised collaborative content item in the collaborative content item database or provide the revised collaborative content item to a client device <b>120</b>. Additionally, the revision module <b>420</b> can insert metadata into the accessed and created collaborative content items, associate metadata with the accessed and created collaborative content item, or access metadata associated with the collaborative content items that were requested to be differentiated.</p><p id="p-0070" num="0069">Content management system <b>100</b> and collaborative content management system <b>130</b> may be implemented using a single computer, or a network of computers, including cloud-based computer implementations. The operations of content management system <b>100</b> and collaborative content management system <b>130</b> as described herein can be controlled through either hardware or through computer programs installed in computer storage and executed by the processors of such server to perform the functions described herein. These systems include other hardware elements necessary for the operations described here, including network interfaces and protocols, input devices for data entry, and output devices for display, printing, or other presentations of data, but which are not described herein. Similarly, conventional elements, such as firewalls, load balancers, collaborative content items servers, failover servers, network management tools and so forth are not shown so as not to obscure the features of the system. Finally, the functions and operations of content management system <b>100</b> and collaborative content management system <b>130</b> are sufficiently complex as to require implementation on a computer system and cannot be performed in the human mind simply by mental steps.</p><heading id="h-0010" level="2">Content Item Management Module</heading><p id="p-0071" num="0070"><figref idref="DRAWINGS">FIG. <b>5</b></figref> illustrates an exemplary embodiment of content item management module <b>308</b>. The content item management module <b>308</b> includes a local slice datastore <b>510</b> that stores slice metadata locally on each node and a permission checking module <b>511</b> that determines the read and/or write permission to serve. The content item management module <b>308</b> further includes a slice registry <b>530</b> with a slice registry datastore <b>520</b> that stores a centralized slice registry table and slice registry log, a new slice creation module <b>531</b> that creates new slices, a state management module <b>532</b> that manages state transitions and state information of slices, and a consistency verification system <b>535</b> that performs verifications and ensures data consistency. The modules shown in <figref idref="DRAWINGS">FIG. <b>5</b></figref> are non-limiting and are for illustrative purposes only; more or fewer modules may be used to achieve the functionality described herein.</p><p id="p-0072" num="0071">Local slice datastore <b>510</b> is a data structure that stores metadata associated with slices on a node. In one embodiment, the local slice datastore <b>510</b> may reside on each node and record metadata of the slices on the node. Local slice datastore <b>510</b> may further store timestamp information associated with slices on the node. Local slice datastore <b>510</b> and exemplary metadata are discussed in further detail below in <figref idref="DRAWINGS">FIG. <b>6</b></figref>.</p><p id="p-0073" num="0072"><figref idref="DRAWINGS">FIG. <b>6</b></figref> illustrates exemplary particulars of local slice datastore <b>510</b> in further detail. <figref idref="DRAWINGS">FIG. <b>6</b></figref> includes an example local slice table <b>610</b> for a first node and an example local slice table <b>620</b> for a second node. In one embodiment, the information associated with each slice may be referred to as an entry, a record, or a row of a table. Each local slice table <b>610</b> and <b>620</b> stores metadata associated with slices on respective nodes. For example, as illustrated in <figref idref="DRAWINGS">FIG. <b>6</b></figref>, local slice table <b>610</b> stores metadata associated with slices located on node <b>1</b>, i.e. slice <b>1</b>-<b>1</b> and slice <b>1</b>-<b>2</b>, with the name &#x201c;slice <b>1</b>-<b>1</b>&#x201d; suggesting a first slice on node <b>1</b> and the name &#x201c;slice <b>1</b>-<b>2</b>&#x201d; suggesting a second slice on node <b>1</b> (the names are for illustration purpose). Similarly, local slice table <b>620</b> stores metadata for slices <b>3</b> through <b>6</b> for node <b>2</b>. Each local slice table contains one or more fields which are discussed in further detail below.</p><p id="p-0074" num="0073">In one embodiment, the fields for local slice datastore <b>510</b> are as follows:</p><p id="p-0075" num="0074">Slice ID: As used herein, the term Slice Identifier (ID) may refer to a unique identifier assigned by the content item management module <b>308</b> to identify a particular slice. The slice ID may contain information such as the node that slice is located on and a unique slice identifier within the node (e.g. slice <b>1</b>-<b>2</b> suggests a slice <b>2</b> on node <b>1</b>).</p><p id="p-0076" num="0075">Range: As used herein, the term range may refer to a contiguous range of keys that is covered by the respective slice. For example, the range [a, i) for slice <b>1</b>-<b>1</b> in table <b>610</b> suggests that slice <b>1</b>-<b>1</b> covers key range from a to i (excluding i). The range for a slice is assigned to the slice when the slice is created and may not be change until the slice is dropped (i.e. deleted).</p><p id="p-0077" num="0076">Current state: As used herein, the term current state refers to the current state that the respective slice is associated with. For example, a current state may be one of the following: provisioning, owned, transfer-out-read-only, transfer-out-hand-off, transfer-out-committed, transfer-in, transfer-in-hand-off, unowned and dropped. Each state is associated with a set of permissions such as read permission, write permission, or if a slice is claimed. If a state transition is complete, the current state will be updated to the next state and if a state transition is rejected, the current state may remain unchanged or change to an alternative state. The various states are discussed in further detail in accordance with state management module <b>532</b> in <figref idref="DRAWINGS">FIG. <b>5</b></figref>.</p><p id="p-0078" num="0077">Next state: As used herein, the term next state refers to the next state that the respective slice is expected to move to. For example, during a slice transfer, the slice may move through a series of states and the field next state indicates the expected state that the slice may move to. A next state may be one of the following: owned, transfer-out-read-only, transfer-out-hand-off, transfer-out-committed, transfer-in, transfer-in-hand-off, unowned and dropped. In one embodiment, for each current state, only a specific set of next states are possible to move to, which means that a slice may only transition to one or more specific next states from the current state. If a state transition is complete, the current state may be updated to the next state and the next state may be updated to null. On the other hand, if a state transition is rejected, the next state may remain the same or may be updated to an alternative state (e.g. null state). The various states and transitions between states are discussed in further detail in accordance with state management module <b>532</b> in <figref idref="DRAWINGS">FIG. <b>5</b></figref>.</p><p id="p-0079" num="0078">Last registry timestamp: As used herein, the term last registry timestamp is the latest timestamp information retrieved from the slice registry table. A timestamp is the time indicating when a state transition takes place. The timestamp may be in a time format (e.g. date and time), or the timestamp may be a representation reflecting the order when the state transition took place in real time (e.g. 1, 2, 3).</p><p id="p-0080" num="0079">Referring back to <figref idref="DRAWINGS">FIG. <b>5</b></figref>, permission checking module <b>511</b> determines a set of permissions (e.g. read and write permissions) associated with a slice by ensuring that a slice serves the minimum of permissions granted by current state or next state. Each slice is associated with a current state and a next state, each state associated with a set of permissions. Responsive to receiving a request to access the slice, permission checking module <b>511</b> determines a minimum permission based on a first set of permissions associated with the current state and a second set of permissions associated with the next state. This is because, during a state transition, a node keeps record of both the current state and the next state for a slice. The node may not have the most up-to-date knowledge regarding which state the slice is actually in, as the most updated state information is not yet retrieved back from slice registry <b>530</b>. Therefore, to ensure incoming requests always retrieve accurate results, the slice has the minimum of the permissions granted by either the current state or the next state. Further details regarding slice registry <b>530</b> are discussed below.</p><p id="p-0081" num="0080">Slice registry <b>530</b> includes a slice registry datastore <b>520</b> and <figref idref="DRAWINGS">FIGS. <b>7</b>-<b>8</b></figref> illustrate exemplary particulars of data structures stored in slice registry datastore <b>520</b> in further detail. In one embodiment, slice registry datastore <b>520</b> stores a centralized slice registry table as illustrated in <figref idref="DRAWINGS">FIG. <b>7</b></figref> and a slice registry log as illustrated in <figref idref="DRAWINGS">FIG. <b>8</b></figref>.</p><p id="p-0082" num="0081"><figref idref="DRAWINGS">FIG. <b>7</b></figref> illustrates an example slice registry table <b>710</b> that stores centralized metadata for slices stored across nodes. In one embodiment, the fields for slice registry table <b>710</b> are as follows:</p><p id="p-0083" num="0082">Slice ID: As used herein, the term Slice Identifier (ID) refers to a unique identifier assigned by the content item management module <b>308</b> to identify a particular slice. The slice ID may contain information such as the node that slice is located and a unique slice identifier within the node.</p><p id="p-0084" num="0083">Range: As used herein, the term range may refer to a contiguous range of keys that is covered by the respective slice. For example, the range [a, i) for slice <b>1</b>-<b>1</b> in table <b>710</b> suggests that slice <b>1</b>-<b>1</b> covers key range from a to i (excluding i).</p><p id="p-0085" num="0084">State: As used herein, the term state refers to the state that the respective slice is associated with. For example, a state may be one of the following: provisioning, owned, transfer-out-read-only, transfer-out-hand-off, transfer-out-committed, transfer-in, transfer-in-hand-off, unowned and dropped. Each state is associated with a set of permissions, such as read permission (i.e. if the slice is able to serve read requests), write permission (i.e. if the slice is able to serve write requests), and whether a slice is claimed (i.e. if the slice has the most updated data). The various states are discussed in further detail in accordance with state management module <b>532</b> in <figref idref="DRAWINGS">FIG. <b>5</b></figref>.</p><p id="p-0086" num="0085">The state information stored in slice registry datastore <b>520</b> is the source of truth for state information associated with a slice. This is because slice registry <b>530</b> manages state transitions through state management module <b>532</b> and makes decisions if a state transition is allowed or rejected. On the other hand, the current state and the next state information stored in the local slice datastore <b>510</b> is local information that may not be the most up to date. For example, a slice may not know for sure if the slice is in the current state or the next state as the true state information may not have been transmitted back from slice registry. As a result, the state information maintained in slice registry datastore <b>520</b> is the source of truth but could match with either the current state or the next state.</p><p id="p-0087" num="0086">Timestamp: As used herein, the term timestamp is the latest timestamp information for a respective slice. A timestamp is the time at which a state transition takes place. In one embodiment, slice registry <b>530</b> may assign a global timestamp to each complete state transition. A timestamp may be in a time format (e.g. date and time), while in another embodiment, the timestamp maybe a representation reflecting the order when the state transition took place in real time (e.g. 1, 2, 3).</p><p id="p-0088" num="0087">Last timestamp: As used herein, the term last timestamp is the latest timestamp information associated with a slice before the latest timestamp (i.e. field &#x201c;Timestamp&#x201d;).</p><p id="p-0089" num="0088"><figref idref="DRAWINGS">FIG. <b>8</b></figref> illustrates an example slice registry log <b>720</b> that stores a list of timestamped slices with corresponding states. The slice registry log <b>720</b> is a centralized log recording timestamps and states for slices on different nodes. In one embodiment, slice registry <b>530</b> may assign global timestamps to slices across different nodes according to the order in time when the state transitions took place and, therefore, providing a serial view of timestamped state transitions. Maintaining historical timestamps and states for each slice may provide consistent snapshot views for each slice at a certain point in time. For example, if slice registry <b>530</b> receives multiple requests from different nodes to read a slice at a certain timestamp, the different requests may always retrieve the same results because of the centralized slice registry log <b>720</b>. If a slice ID and a timestamp are provided, the slice registry log <b>720</b> may always provide a consistent snapshot view of the respective slice at the timestamp, which ensures consistency of data reads.</p><p id="p-0090" num="0089">Returning to the description of <figref idref="DRAWINGS">FIG. <b>5</b></figref>, slice creation module <b>531</b> creates slices for various operations such as transfer, split and merge of slices. When a slice is created, slice creation module <b>531</b> may assign the slice a contiguous range of keys that does not change. In one embodiment, slice creation module <b>531</b> may create new slices for slice transfer, split and merge. For example, content item management module <b>308</b> may determine that distribution of data among nodes is uneven and decides to transfer a slice from a first node to a second node. In such situation, the slice creation module <b>531</b> may need to create a new slice on the second node that covers the same range of keys of the first node. As another example, if content item management module <b>308</b> determines that a slice contains data whose size is over a threshold, but the capacity of the node is not as large, content item management module <b>308</b> may determine to split the slice into multiple slices. In such situation, the slice creation module <b>531</b> may create two or more new slices such that the combined key range of the new slices covers the key range of the original slice. In yet another embodiment, if content item management module <b>308</b> determines to merge two slices that are small in size, the slice creation module <b>531</b> may create a new slice that covers the combined range of the two small slices. As another example, during a slice transfer from a source slice located on node <b>1</b> to a destination slice located on node <b>2</b>, slice creation module <b>531</b> may create a new slice on node <b>2</b> and initialize the new slice with a current provisioning state and set the next state to transfer-in, which indicates that the new slice is expected to copy data from the source slice. In another embodiment, slice creation module <b>531</b> may create a new slice with new key range of data. In this case, slice creation module <b>531</b> may set the current state for the slice to provisioning and set the next state to owned. The different states are further discussed below in accordance with state management module <b>532</b>.</p><p id="p-0091" num="0090">State management module <b>532</b> manages state transitions for slices. In one embodiment, the various states and respective next states are as follows:</p><p id="p-0092" num="0091">Provisioning: as used herein, the term provisioning refers to a state of a slice that is newly created. The provisioning state may only be used in local slice datastore <b>510</b> as a slice in provisioning state may not contain any data yet and therefore the slice registry table <b>520</b> may not store metadata for a slice that is in a provisioning state. A slice in provisioning state does not have permissions to serve read or write requests and does not have claim for the range of keys that it covers. A slice in provisioning state may transition to following states: owned, transfer-in and unowned.</p><p id="p-0093" num="0092">Owned: as used herein, the term owned refers to a state when a slice has full permissions for the key range of data, including read and write permissions. A slice in owned state has claim of the key range that the slice covers. A slice in owned state may transition to the following state: transfer-out-read-only.</p><p id="p-0094" num="0093">Transfer-out-read-only: as used herein, the term transfer-out-read-only may refer to the state of a source slice when the source slice is in a process of transferring data to a destination slice. When the destination slice has copied a threshold of data (e.g. 90% of data), the source slice may transition to the transfer-out-read-only state, such that the source slice only serves read requests but does not serve write requests. A slice in the transfer-out-read-only state has permission to serve read requests and has claim of the key range of data. A slice may transition from the state transfer-out-read-only to transfer-out-hand-off and owned.</p><p id="p-0095" num="0094">Transfer-out-handoff: as used herein, the term transfer-out-handoff refers to a state of a source slice when the source slice is in a process of transferring data to a destination slice and stops serving read requests. A source slice may transition to the transfer-out-handoff state when the destination slice has copied all the data. A source slice in this state indicates that the two slices are ready for checksum verification to ensure that the copied data matches data on the source slice. A slice in transfer-out-handoff state does not have permissions to serve read or write requests but has claim to the key range of data as the slice still has the most up-to-date data. A slice may transition from transfer-out-handoff state to following states: transfer-out-committed and owned.</p><p id="p-0096" num="0095">Transfer-out-committed: as used herein, the term transfer-out-committed refers to the state of a source slice when the source slice is in a process of transferring data to a destination slice and the source slice no longer has claim to the key range of data. A slice in transfer-out-committed state may not terminate the current operation at this point. A slice in transfer-out-committed state does not have permission to serve read or write requests and does not have claim to the key range of data. A slice in transfer-out-committed state may transition to the following state: unowned.</p><p id="p-0097" num="0096">Transfer-in: as used herein, the term transfer-in refers to the state of a destination slice when a source slice is in a process of transferring data to the destination slice. A slice in transfer-in state does not have permission to serve read or write requests and does not have claim of the key range of data. A slice in transfer-in state may transition to the following states: transfer-in-handoff, unowned.</p><p id="p-0098" num="0097">Transfer-in-handoff: as used herein, the term transfer-in-handoff refers to the state of a destination slice when a source slice is in a process of transferring data to the destination slice and the destination slice has the most updated data copied from the source slice. A slice in state transfer-in-handoff may not serve read or write requests but has claim to the key range of data that it covers. A slice may transition from transfer-in-handoff to the following states: owned and unowned.</p><p id="p-0099" num="0098">Unowned: as used herein, the term unowned refers to a state when a slice that is ready to be deleted. A slice in the state unowned may not serve read or write requests and does not have claim to the key range of data. Unowned is a terminal state in the slice registry datastore <b>520</b>. A slice may transition to a dropped state but the dropped state may only exist on the local slice datastore <b>510</b>.</p><p id="p-0100" num="0099">Dropped: as used herein, the term dropped refers to the state when a slice is deleted from the slice registry datastore <b>520</b> and therefore the slice registry datastore <b>520</b> may not have a slice that is in a dropped state. A slice in the dropped state does not serve read or write requests and does not have claim to the key range of data. A slice does not transition from a dropped state to other states as the slice is expected to be deleted from the node that it locates.</p><p id="p-0101" num="0100">In one embodiment, state management module <b>532</b> allows or rejects an action based on a determination whether a state transition is valid. The determination may be based on results outputted from consistency verification system <b>535</b>. State management module <b>532</b> may allow a state transition if consistency verification system <b>535</b> determines that invariants still hold after transitioning to next state. On the other hand, state management module <b>532</b> may reject any invalid state transitions based on results from the consistency verification system <b>535</b> indicating that a transition violates certain invariant checks. The invariant checks are discussed in further detail below in accordance with consistency verification system <b>535</b>.</p><heading id="h-0011" level="2">Example Process of a Slice Transfer</heading><p id="p-0102" num="0101"><figref idref="DRAWINGS">FIG. <b>9</b></figref> illustrates an example process that the content item management module <b>308</b> executes to transfer data from a source slice to a destination slice. Furthermore, <figref idref="DRAWINGS">FIG. <b>9</b></figref> also illustrates how each slice moves through its respective state machine.</p><p id="p-0103" num="0102">Slice creation module <b>531</b> creates <b>910</b> a destination slice covering a contiguous key range on a destination node, with the contiguous key range cover the same key range that the source slice covers. The destination slice may be assigned a provisioning <b>912</b> state. The source slice is originally in an owned <b>911</b> state that has permissions to serve both read and write requests. When the destination slice starts to copy <b>920</b> data from the source slice, the destination slice transitions from provisioning <b>912</b> state to transfer-in state <b>922</b>, while the source slice remains in owned <b>921</b> state. Responsive to detecting <b>930</b> that the destination slice has copied a threshold amount of data (e.g. a threshold of 90% data), the source slice may transition to transfer-out-read-only <b>931</b> state and stops serving write requests so that the destination slice may catch up and finish copying the rest of the data. Responsive to detecting <b>940</b> that the destination slice has copied all the data, the source slice transitions to transfer-out-hand-off <b>941</b> state and stops serving read requests. The content item management module <b>308</b> may verify that the destination slice has an accurate copy of data by checking set sums and responsive to ensuring <b>950</b> that the destination has an up-to-date copy of the data, the destination slice transitions to transfer-in-hand-off <b>952</b> state, which enables the destination slice to claim the key range of data that it covers. Then, the source slice may give up <b>960</b> the claim for the range of data by transitioning to transfer-out-committed <b>961</b> state. Finally, the source slice is deleted <b>970</b> from the slice registry datastore <b>520</b> by transferring to an unowned <b>971</b> state and the destination slice has both read and write permissions by transitioning to owned <b>972</b> state.</p><heading id="h-0012" level="2">Consistency Verification System</heading><p id="p-0104" num="0103">Consistency verification system <b>535</b> may verify data accuracy and consistency for data stored in the content item management module <b>308</b>. Consistency verification system <b>535</b> is discussed in further details in accordance with <figref idref="DRAWINGS">FIGS. <b>10</b>-<b>12</b></figref>.</p><p id="p-0105" num="0104"><figref idref="DRAWINGS">FIG. <b>10</b></figref> illustrates an exemplary block diagram of the consistency verification system <b>535</b> of the content item management module <b>308</b>. In the exemplary embodiment illustrated in <figref idref="DRAWINGS">FIG. <b>10</b></figref>, consistency verification system <b>535</b> includes an invariant checking module <b>1030</b> that performs verifications by checking whether certain properties for the database (e.g. invariants) hold for each slice during state transition, a request sampling module <b>1010</b> that samples requests from requests sent to the content item management module <b>308</b> for verification, a verification module <b>1020</b> that selects one or more verifiers for verifying each sampled request, a request datastore <b>1001</b> that stores requests sampled by the request sampling module <b>1010</b>, and a verifiers module <b>1002</b> that stores instructions for various verifiers for verifying different types of requests.</p><p id="p-0106" num="0105">Invariant checking module <b>1030</b> may perform various invariant checks on the slices and determine validity of invariants by performing various checks on metadata associated with slices. Invariant checking module <b>1030</b> may send results of invariants checks to state management module <b>532</b>. In one embodiment, invariant checking module <b>1030</b> performs the following checks on metadata.</p><p id="p-0107" num="0106">State information checks: invariants checking module <b>1030</b> may check if the state stored in slice registry datastore <b>520</b> matches either the current state or the next state stored in local slice datastore <b>510</b>. As discussed previously, because the state information stored in slice registry datastore <b>520</b> is the true state for a slice, the metadata is valid only if the state stored in slice registry datastore <b>520</b> matches either current state or next state in local slice datastore <b>510</b>.</p><p id="p-0108" num="0107">Timestamp checks: invariants checking module <b>1030</b> may also check if the timestamp stored in local slice datastore <b>510</b> matches either the timestamp or the last timestamp stored in slice registry datastore <b>520</b>. Because the timestamp information stored in local slice datastore <b>520</b> is retrieved from the slice registry <b>530</b>, invariants checking module <b>1030</b> performs timestamp checks to ensure that the timestamp information stored in local slice datastore <b>510</b> is consistent with the latest timestamp information stored in the slice registry <b>530</b>.</p><p id="p-0109" num="0108">Concurrency checks: invariants checking module <b>1030</b> may also ensure that for the same range of keys, at most one slice has either read or write permission. For example, if a first slice that covers key range [a, c] has read or write permission, then invariants checking module <b>1030</b> may send instructions to state management module <b>532</b> to reject any state transition that grants a second slice read or write permission to the key range [a, c]. In another embodiment, invariants checking module <b>1030</b> may allow multiple read permissions to a same range of keys and only reject read/write permissions to a slice with write permission. For example, if a first slice that covers key range [a, c] has read permission, then invariants checking module <b>1030</b> may send instructions to state management module <b>532</b> to allow a state transition that grants a second slice read permission to the key range [a, c].</p><p id="p-0110" num="0109">Claim check: invariants checking module <b>1030</b> may also ensure that for every range of keys, there is at least one slice that has claim of the range of keys, which guarantees that at least one slice has the most updated data for the range of keys. During an operation such as a slice transfer, invariants checking module <b>1030</b> may perform the claim check to ensure that there is always at least one slice that has claim for every range of keys.</p><p id="p-0111" num="0110">Slice registry check: The invariants checking module may also ensure that the slice registry datastore <b>520</b> maintains an entry for each slice not in provisioning or dropped state. As the states provisioning and dropped may only exist locally on local slice datastore <b>510</b>, the slice registry datastore <b>520</b> may maintain an entry for slices not in the state provisioning or dropped. The slice registry check ensures that slice registry <b>530</b> monitors state transitions and state information for every slice.</p><p id="p-0112" num="0111">Continuing with the discussion in <figref idref="DRAWINGS">FIG. <b>10</b></figref>, request sampling module <b>1010</b> may sample requests from requests previously processed by the content item management module <b>308</b> for verification. In one embodiment, request sampling module <b>1010</b> samples requests and logs the sampled requests to request datastore <b>1001</b>. Request sampling module <b>1010</b> may randomly samples request, or alternatively, may sample a specific type of request if a particular type of requests is to be verified. Request sampling module <b>1010</b> may save, in the request datastore <b>1001</b>, information associated with each request, such as a key, a parameter timestamp included in the request that specifies a version of data to access, a request timestamp that specifies when the request was originally requested, a response received for the request, and other types of request information. In one embodiment, request sampling module <b>1010</b> may further record information such as pre-conditions associated with the request. A pre-condition may be one or more requirements that the database needed to meet at the time when the request was requested. For example, suppose the original request was requested at time T<b>1</b> and a precondition may specify one or more restrictions for the database at a time before T<b>1</b>, such as T<b>0</b>.</p><p id="p-0113" num="0112">Verification module <b>1020</b> may consume sampled requests stored in the request datastore <b>1001</b> and perform verification of the requests by replaying the sampled requests. In one embodiment, verification module <b>1020</b> may consume requests from the datastore and issue verification requests to content item management module <b>308</b> with various holdoff periods. For each sampled request to verify, verification module <b>1020</b> may determine and select one or more verifiers from the verifiers module <b>1002</b> based, for example, on a type of the request. Following are some examples of verifiers included in the verifiers module <b>1002</b>. The verifiers discussed below are for illustration purposes only and more verifiers with additional functionalities may be included.</p><p id="p-0114" num="0113">A &#x201c;get verifier&#x201d; <b>1003</b> may verify a read request. A read request to be verified may be referred to as an original request. The get verifier <b>1003</b> may verify the original request by replaying the original request with a same set of parameters associated with the original request, and the replayed request may be referred to as a verification request. For example, the original request may request to access data with a key K<b>1</b> at timestamp T<b>1</b>. The timestamp T<b>1</b> may refer to a version of the data to access. The original request may be applied at another timestamp that is after T<b>1</b>. For example, the original request was issued to the content item management system at T<b>2</b> to read data at T<b>1</b>. The original request may receive a response R<b>1</b>. To verify the read request, the get verifier <b>1003</b> may issue a verification request to content item management module <b>308</b> with the verification request being a read request with the parameters key K<b>1</b> and timestamp T<b>1</b>. If the verification request receives a same response R<b>1</b>, the verification module <b>1020</b> may determine that no issues are found during the verification process. On the other hand, if the response is different from R<b>1</b>, verification module <b>1020</b> may determine that data inconsistency is detected in the database and output the results to content item management module <b>308</b>.</p><p id="p-0115" num="0114">In one embodiment, the get verifier <b>1003</b> may verify data consistency for a range of keys. For example, the original read request may read data for a range of keys such as K<b>1</b>-K<b>9</b>, and the original response may be R<b>1</b>-R<b>9</b>. The get verifier <b>1003</b> may issue a verification read request to the content item management module <b>308</b> to read data for the range of keys K<b>1</b>-K<b>9</b> and verify the results by comparing the returned results with R<b>1</b>-R<b>9</b>.</p><p id="p-0116" num="0115">A &#x201c;get latest verifier&#x201d; <b>1004</b> may verify the latest timestamp associated with data corresponding to a key specified in the original request. In one embodiment, an original request may specify a key and receive a timestamp that indicates the latest timestamp associated with the latest operation for respective data, such as state change or write operation performed on the data. The get latest verifier <b>1004</b> may be used as a checking step in a write verifier.</p><p id="p-0117" num="0116">A &#x201c;write verifier&#x201d; <b>1005</b> may verify a write request. The write verifier <b>1005</b> may verify a previous write request issued to the content item management module <b>308</b>. In one embodiment, an original write request may include a set of parameters including a set of preconditions, a key, and data to write (or insert, modify, delete, etc.). The original write request may be committed at a commit timestamp T<b>1</b>. In one embodiment, the commit timestamp T<b>1</b> is assigned to the write request only when the preconditions are met. The set of preconditions may specify one or more conditions to meet before executing the write operation, and if the preconditions are not met, the write operation may not be executed. The write verifier <b>1005</b> may verify the original requests by issuing one or more verification requests. For example, the write verifier <b>1005</b> may issue one or more read requests to check whether preconditions were met, one or more read requests to check whether the write operation was applied successfully, and a get latest verifier <b>1004</b> to check whether the write operation causes timestamps to move forward and data associated with pervious timestamps are not affected. To illustrate with a concrete example, suppose an original write request was to apply a write operation to key K<b>1</b>, and write data K<b>1</b>=&#x201c;peanut butter&#x201d; at commit timestamp T<b>1</b>. A precondition for the request was that the data should be K<b>1</b>=&#x201c;peanut&#x201d; at T<b>0</b>, where T<b>0</b> is a time before T<b>1</b>. In one embodiment, the preconditions may be required in any situation when the write operation should only be performed if the latest data needs to meet a predetermined requirement (e.g. only write if the data is updated to a specific version). The write verifier <b>1005</b> may issue a verification read request to content item management module <b>308</b> to verify that at T<b>0</b>, the data for key K<b>1</b> is R<b>0</b>. After checking the precondition, the write verifier <b>1005</b> may issue another verification read request to verify that at T<b>1</b> the data for K<b>1</b> is &#x201c;peanut butter.&#x201d; The write verifier <b>1005</b> may issue a get latest verifier <b>1004</b> to verify that the latest timestamp for key K<b>1</b> is a timestamp that is T<b>1</b> or a timestamp after T<b>1</b>, which helps ensure that the write operation moves forward the timestamps.</p><p id="p-0118" num="0117">Verifiers module <b>1002</b> may further include verifiers for verifying other types of requests. For example, a &#x201c;history verifier&#x201d; may verify a history request that requests to retrieve historical data for a given key. The history verifier may send a verification request to content item management module <b>308</b> to retrieve historical data, compare with the original response received for the original history request, and verify if the verification response is consistent with the original response. Similarly, a version history verifier may verify a version history request that requests to retrieve a history of versions (e.g. timestamps) for a give key.</p><p id="p-0119" num="0118">Verification module <b>1020</b> may also control timing when the requests are to be replayed. The request may be replayed after the original request time with a holdoff period. In one embodiment, multiple verification requests with multiple holdoff periods may be performed for verifying a request. For example, a request may be replayed after 1 min, 5 mins, and 10 mins. In one embodiment the holdoff period is determined by a user, for example, a system administrator, in another embodiment, the holdoff period is determined by the system based on the amount of traffic of requests to the content item management module <b>308</b>.</p><p id="p-0120" num="0119">In one embodiment, verification module <b>1020</b> may attach tags to verification requests. A tag may indicate that the request is a verification request that is distinguishable from a normal request. Requests that are marked as verification requests are not sampled and no more verification request/process is performed on the verification requests.</p><p id="p-0121" num="0120"><figref idref="DRAWINGS">FIG. <b>11</b></figref> illustrates an exemplary verification process performed by the consistency verification system <b>535</b>, according to one embodiment. In <figref idref="DRAWINGS">FIG. <b>11</b></figref>, requests <b>1100</b> may include requests (e.g. requests <b>1</b>-<b>4</b>) sent from clients <b>120</b> to content item management module <b>308</b> for processing. The requests <b>1100</b> may be referred to as original requests. In one embodiment, the original requests <b>1100</b> have been processed by the content item management module <b>308</b> and each of the request <b>1100</b> may be associated with a response received from the content item management module <b>308</b>. The request sampling module <b>1010</b> may perform a request sampling process <b>1110</b> to sample requests for verification and store the sampled requests in request datastore <b>1001</b>. Request sampling module <b>1010</b> may sample requests based on a probability that each request may be selected. In the embodiment illustrated in <figref idref="DRAWINGS">FIG. <b>11</b></figref>, request <b>1130</b> (i.e. request <b>1</b>) and request <b>1120</b> (i.e. request <b>2</b>) are sampled and information related to the sampled requests are stored in the request datastore <b>1001</b>. For example, as illustrated in request <b>1130</b>, request <b>1</b> may include parameters such as a key, or a key range, and request <b>1</b> may be requested at timestamp T<b>1</b>. The request may be a write request associated with a pre-condition <b>1</b>, where the precondition may specify that at time T<b>0</b>, the value for the key K<b>1</b> is R<b>0</b>, and if the value for key K<b>1</b> at T<b>0</b> is not R<b>0</b>, the write request should not be processed. Request <b>3</b> may be a read request that was requested at time T<b>3</b> and the request may be also associated with a key K<b>3</b> and a response R<b>3</b>. The verification module <b>1020</b> may consume and verify the sampled requests stored in <b>1001</b> by selecting a verifier from the verifiers module <b>1002</b>. The verifier may be selected based on type of the original request to verify. For example, if the original request is a read request, the verifier selected may be a read verifier; if the original request is a get latest request, the verifier selected may be a get latest request, and if the original request is a write request, the verifier selected may be a write verifier.</p><p id="p-0122" num="0121">In one embodiment, each verifier may include a set of instructions that indicate one or more properties associated with the request to verify. To verify the one or more properties, the verification module <b>1020</b> may send one or more verification requests to content item management module <b>308</b>. For example, to verify a write request, the verification module <b>1020</b> may select a write verifier that includes instructions to verify precondition, operation and latest timestamp associated with the write request. To verify the precondition, verification module <b>1020</b> may send a verification read request; to verify whether the write operation is successful, verification module <b>1020</b> may send a second verification read request to read data at a commit timestamp when the write operation was committed. To verify that the write operation advanced the timestamp, verification module <b>1020</b> may use a get latest verifier to send a get latest timestamp request to content item management module <b>308</b>, and verify that the latest timestamp is after or equal to the commit timestamp.</p><p id="p-0123" num="0122">In one embodiment, the verification module <b>1020</b> may control holdoff periods such that each request is replayed with multiple different holdoff periods (such as 10 seconds, 1 minute and 10 minutes). The verification module <b>1020</b> may control when each instance of each verification request may be performed. For example, requests <b>1101</b>-<b>1103</b> may be three verification requests with different holdoff periods for replaying request <b>1</b> (e.g. request <b>1101</b> may be verification request with holdoff period of 10 seconds, request <b>1102</b> may have a holdoff period of 1 minute, and request <b>1103</b> may have a holdoff period of 100 minutes). In one embodiment, the verification module <b>1020</b> may interweave the verification requests for different original requests based on holdoff periods. For example, verification request <b>1101</b> may be request <b>1</b> with 10 seconds holdoff period, verification request <b>1102</b> may be request <b>3</b> with 10 seconds holdoff period, and verification request <b>1103</b> may be request <b>1</b> with 1 min holdoff period. In one embodiment, the verification requests <b>1101</b>-<b>1104</b> are tagged with a verification tag such that the verification requests are not sampled again by the sampling process <b>1110</b>.</p><p id="p-0124" num="0123"><figref idref="DRAWINGS">FIG. <b>12</b></figref> illustrates an exemplary verification process. The process may start with the consistency verification system <b>535</b> maintaining <b>1202</b> a plurality of verifiers in the verifiers module <b>1002</b> for verifying data consistency, where each verifier comprises a set of instructions for verifying data consistency for type of requests. The content item management module <b>308</b> may receive a plurality of requests and perform operations such as read or write operations in response to each request. The request sampling module <b>1010</b> may select <b>1204</b> a request from the plurality of requests. The selected request may be processed at a first timestamp and is associated with a first response. The selected request may further associate with a set of parameters. The verification module <b>1020</b> may identify <b>1206</b> a verifier from the plurality of verifiers and verify data consistency using the verifier. The verification module <b>1020</b> may send <b>1208</b> a replay request with the set of parameters specified in the original request to the content item management module <b>308</b> and receive <b>1210</b> a second response for the replay request. The verification module <b>1020</b> may determine whether the second response is consistent with the first response received for the original request. Based on a determination that the second response is not consistent with the first response, the verification module <b>1020</b> may output information describing data inconsistency to the content item management system.</p><heading id="h-0013" level="2">Additional Considerations</heading><p id="p-0125" num="0124">Reference in the specification to &#x201c;one embodiment&#x201d; or to &#x201c;an embodiment&#x201d; means that a particular feature, structure, or characteristic described in connection with the embodiments is included in at least one embodiment. The appearances of the phrase &#x201c;in one embodiment&#x201d; in various places in the specification are not necessarily all referring to the same embodiment.</p><p id="p-0126" num="0125">In this description, the term &#x201c;module&#x201d; refers to a physical computer structure of computational logic for providing the specified functionality. A module can be implemented in hardware, firmware, and/or software. In regards to software implementation of modules, it is understood by those of skill in the art that a module comprises a block of code that contains the data structure, methods, classes, header and other code objects appropriate to execute the described functionality. Depending on the specific implementation language, a module may be a package, a class, or a component. It will be understood that any computer programming language may support equivalent structures using a different terminology than &#x201c;module.&#x201d;</p><p id="p-0127" num="0126">It will be understood that the named modules described herein represent one embodiment of such modules, and other embodiments may include other modules. In addition, other embodiments may lack modules described herein and/or distribute the described functionality among the modules in a different manner. Additionally, the functionalities attributed to more than one module can be incorporated into a single module. Where the modules described herein are implemented as software, the module can be implemented as a standalone program, but can also be implemented through other means, for example as part of a larger program, as a plurality of separate programs, or as one or more statically or dynamically linked libraries. In any of these software implementations, the modules are stored on the computer readable persistent storage devices of a system, loaded into memory, and executed by the one or more processors of the system's computers.</p><p id="p-0128" num="0127">The operations herein may also be performed by an apparatus. This apparatus may be specially constructed for the required purposes, or it may comprise a general-purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium, such as, but is not limited to, any type of disk including optical disks, CD-ROMs, read-only memories (ROMs), random access memories (RAMs), magnetic or optical cards, or any type of media suitable for storing electronic instructions, and each coupled to a computer system bus. Furthermore, the computers referred to in the specification may include a single processor or may be architectures employing multiple processor designs for increased computing capability.</p><p id="p-0129" num="0128">The algorithms presented herein are not inherently related to any particular computer or other apparatus. Various general-purpose systems may also be used with programs in accordance with the teachings herein, or it may prove convenient to construct more specialized apparatus to perform the required method steps. The required structure for a variety of these systems will appear from the description above. In addition, the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the present invention as described herein, and any references above to specific languages are provided for disclosure of enablement and best mode of the present invention.</p><p id="p-0130" num="0129">While the invention has been particularly shown and described with reference to a preferred embodiment and several alternate embodiments, it will be understood by persons skilled in the relevant art that various changes in form and details can be made therein without departing from the spirit and scope of the invention.</p><p id="p-0131" num="0130">As used herein, the word &#x201c;or&#x201d; refers to any possible permutation of a set of items. Moreover, claim language reciting &#x2018;at least one of&#x2019; an element or another element refers to any possible permutation of the set of elements.</p><p id="p-0132" num="0131">Although this description includes a variety of examples and other information to explain aspects within the scope of the appended claims, no limitation of the claims should be implied based on particular features or arrangements these examples. This disclosure includes specific embodiments and implementations for illustration, but various modifications can be made without deviating from the scope of the embodiments and implementations. For example, functionality can be distributed differently or performed in components other than those identified herein. This disclosure includes the described features as non-exclusive examples of systems components, physical and logical structures, and methods within its scope.</p><p id="p-0133" num="0132">Finally, it should be noted that the language used in the specification has been principally selected for readability and instructional purposes, and may not have been selected to delineate or circumscribe the inventive subject matter. Accordingly, the disclosure of the present invention is intended to be illustrative, but not limiting, of the scope of the invention, which is set forth in the following claims.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A method for checking data consistency in a distributed key-value pair database, the method comprising:<claim-text>maintaining a plurality of verifiers for verifying data consistency in the database, wherein each verifier comprises a set of instructions for verifying data consistency for a type of request;</claim-text><claim-text>processing, by a content item management system, a plurality of requests, wherein processing each request comprises performing, by the content item management system one or more operations;</claim-text><claim-text>selecting a request from the processed plurality of requests, wherein the selected request was processed at a first timestamp, received a first response, and specified a set of one or more parameters;</claim-text><claim-text>identifying a verifier from the plurality of verifiers to verify data consistency associated with the selected request; and</claim-text><claim-text>verifying, by the identified verifier, data consistency associated with the selected request, the verification comprising:<claim-text>sending a replay request corresponding to the selected request, the replay request including the set of parameters;</claim-text><claim-text>receiving a second response associated with the replay request;</claim-text><claim-text>determining whether the second response is consistent with the first response; and</claim-text><claim-text>based on a determination that the second response is not consistent with the first response, outputting information describing data inconsistency.</claim-text></claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the replay request is sent at a second timestamp after the first timestamp, the first timestamp and the second timestamp separated by a predefined holdoff period.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the selected verifier is a write verifier, and the selected request is a write request associated with a precondition, wherein the write request commits a write operation at the first timestamp.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the verification further comprises:<claim-text>verifying the precondition associated with the write request; and</claim-text><claim-text>verifying a latest timestamp associated with the write request by checking whether the latest timestamp is greater than or equal to the first timestamp.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein verifying the precondition comprises:<claim-text>sending a read request, the read request specifying a read operation associated with a timestamp before the first timestamp;</claim-text><claim-text>receiving a response; and</claim-text><claim-text>determining whether the response is consistent with the precondition.</claim-text></claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the set of parameters comprise a key and a timestamp.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the set of parameters comprise a range of keys.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>checking whether a plurality of invariants associated with the database satisfy a set of rules during a state transition process; and</claim-text><claim-text>responsive to at least one invariant of the plurality of invariants failing to satisfy a rule of the set of rules during the state transition process, sending information describing the failure.</claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. A non-transitory computer-readable storage medium storing executable computer instructions that, when executed by one or more processors, cause the one or more processors to perform steps comprising:<claim-text>maintaining a plurality of verifiers for verifying data consistency in the database, wherein each verifier comprises a set of instructions for verifying data consistency for a type of requests;</claim-text><claim-text>receiving, by a content item management system, a plurality of requests, wherein the content item management system performs operations in response to each request;</claim-text><claim-text>selecting a request from the plurality of requests, wherein the selected request was processed at a first timestamp and is associated with a first response, the request specifying a set of parameters;</claim-text><claim-text>identifying a verifier from the plurality of verifiers to verify data consistency of the data processed in response to the selected request; and</claim-text><claim-text>verifying, by the identified verifier, data consistency of the data processed in response to the selected request, the verification comprising:<claim-text>sending a replay request corresponding to the selected request, the replay request including the set of parameters;</claim-text><claim-text>receiving a second response associated with the replay request;</claim-text></claim-text><claim-text>determining, based on the first and the second response, whether to output information describing data inconsistency to the content item management system.</claim-text></claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The non-transitory computer-readable storage medium of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the replay request is sent at a second timestamp after the first timestamp, the first timestamp and the second timestamp separated by a predefined holdoff period.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The non-transitory computer-readable storage medium of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the selected verifier is a write verifier that is selected based on a type associated with the request, and the selected request is a write request associated with a precondition, wherein the write request commits a write operation at the first timestamp.</claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The non-transitory computer-readable storage medium of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the verification further comprises:<claim-text>verifying the precondition associated with the write request; and</claim-text><claim-text>verifying a latest timestamp associated with the write request by checking whether the latest timestamp is greater than or equal to the first timestamp.</claim-text></claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The non-transitory computer-readable storage medium of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein verifying the precondition comprises:<claim-text>sending a read request, the read request specifying a read operation associated with a timestamp before the first timestamp;</claim-text><claim-text>receiving a response; and</claim-text><claim-text>determining whether the response is consistent with the precondition.</claim-text></claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The non-transitory computer-readable storage medium of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the steps further comprising:<claim-text>checking whether a plurality of invariants associated with the database satisfy a set of rules during a state transition process; and</claim-text><claim-text>responsive to at least one invariant of the plurality of invariants failing to satisfy a rule of the set of rules during the state transition process, sending information describing the failure.</claim-text></claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. A system comprising:<claim-text>one or more processors configured to execute instructions; and</claim-text><claim-text>a memory storing instructions for execution on the one or more processors, including instructions causing the one or more processors to:<claim-text>maintain a plurality of verifiers for verifying data consistency in the database, wherein each verifier comprises a set of instructions for verifying data consistency for a type of requests;</claim-text><claim-text>receive, by a content item management system, a plurality of requests, wherein the content item management system performs operations in response to each request;</claim-text><claim-text>select a request from the plurality of requests, wherein the selected request was processed at a first timestamp and is associated with a first response, the request specifying a set of parameters;</claim-text><claim-text>identify a verifier from the plurality of verifiers, based on a type of the request, to verify data consistency of data processed in response to the selected request; and</claim-text><claim-text>verify, by the identified verifier, data consistency of the data processed in response to the selected request, wherein the verification comprises sending a second request and receiving a second response; and</claim-text><claim-text>determine, based on the first response and the second response, whether to output information describing data inconsistency.</claim-text></claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The system of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the second request is sent at a second timestamp after the first timestamp, and wherein the first timestamp and the second timestamp are separated by a predefined holdoff period.</claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The system of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the selected verifier is a write verifier, and the selected request is a write request associated with a precondition, wherein the write request commits a write operation at the first timestamp.</claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The system of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the verification further comprises:<claim-text>verifying the precondition associated with the write request; and</claim-text><claim-text>verifying a latest timestamp associated with the write request by checking whether the latest timestamp is greater than or equal to the first timestamp.</claim-text></claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The system of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein verifying the precondition comprises:<claim-text>sending a read request with the set of parameters, the read request specifying a read operation associated with a timestamp before the first timestamp;</claim-text><claim-text>receiving a response; and</claim-text><claim-text>determining whether the response is consistent with the precondition.</claim-text></claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The system of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the instructions further cause the one or more processors to:<claim-text>check whether a plurality of invariants associated with the database satisfy a set of rules during a state transition process; and</claim-text><claim-text>responsive to at least one invariant of the plurality of invariants failing to satisfy a rule of the set of rules during the state transition process, send information describing the failure.</claim-text></claim-text></claim></claims></us-patent-application>