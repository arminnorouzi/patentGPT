<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004479A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004479</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17463622</doc-number><date>20210901</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><priority-claims><priority-claim sequence="01" kind="national"><country>IN</country><doc-number>202121025701</doc-number><date>20210609</date></priority-claim></priority-claims><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>11</main-group><subgroup>36</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>11</main-group><subgroup>30</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>11</main-group><subgroup>3636</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>11</main-group><subgroup>3624</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>11</main-group><subgroup>302</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>11</main-group><subgroup>3075</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e61">SYSTEMS AND METHODS FOR SELECTIVE PATH SENSITIVE INTERVAL ANALYSIS</invention-title><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="obligated-assignee"><addressbook><orgname>Tata Consultancy Services Limited</orgname><address><city>Mumbai</city><country>IN</country></address></addressbook><residence><country>IN</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>CHIMDYALWAR</last-name><first-name>Bharti</first-name><address><city>Pune</city><country>IN</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Kumar</last-name><first-name>Shrawan</first-name><address><city>Pune</city><country>IN</country></address></addressbook></inventor></inventors></us-parties><assignees><assignee><addressbook><orgname>Tata Consultancy Services Limited</orgname><role>03</role><address><city>Mumbai</city><country>IN</country></address></addressbook></assignee></assignees></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">Abstract interpretation based static analysis tools use relational/non-relational abstract domains to verify program properties. Precision and scalability of analysis vary basis usage of abstract domains. K-limited path-sensitive interval domain is an abstract domain that was conventionally proposed for analysis on industry strength programs. The domain maintains variables' intervals along a configurable K subsets of paths at each program point, which implicitly provides co-relation among variables. When the number of paths at the join point exceeds K, set of paths are partitioned into K subsets, arbitrarily, which results in loss of precision required to verify program properties. To address the above problem, embodiments of the present disclosure provide selective merging of paths in such a way that the intervals computed help verifying more properties. The selective path-sensitive method of the present disclosure is based on the knowledge of variables whose values influence the verification outcome of program properties.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="175.68mm" wi="134.37mm" file="US20230004479A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="139.28mm" wi="73.32mm" file="US20230004479A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="186.86mm" wi="136.40mm" file="US20230004479A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">PRIORITY CLAIM</heading><p id="p-0002" num="0001">This U.S. patent application claims priority under 35 U.S.C. &#xa7; 119 to: India Application No. 202121025701, filed on Jun. 9, 2021. The entire contents of the aforementioned application are incorporated herein by reference.</p><heading id="h-0002" level="1">TECHNICAL FIELD</heading><p id="p-0003" num="0002">The disclosure herein generally relates to path sensitive analysis, and, more particularly, to systems and methods for selective path sensitive interval analysis.</p><heading id="h-0003" level="1">BACKGROUND</heading><p id="p-0004" num="0003">Static code analysis based on abstract interpretation is widely used to detect bugs in large software systems. Analyses performed to detect potential bugs using relational abstract domains produce precise results as they track relations among variables by computing extra information, however, that limits their scalability while analyzing large software systems in practice. Whereas non-relational abstract domains such as interval domain scales on million lines of code but at the cost of precision. To combine the benefits of both the domains, conventional industrial static analysis tools either selectively apply both kinds of domains or design a new domain which is scalable and captures useful relationship among program variables showing effectiveness in practice.</p><p id="p-0005" num="0004">The static analysis using K-limited path sensitive interval domain has shown precision with scalability on million lines of code. The domain maintains path-wise information of variables in the form of intervals, along limited K subsets of paths. Maintaining path-wise interval information for variables implicitly provides co-relation among values of variables. During the join operation at a program point, when the number of paths exceeds K, the set of paths are partitioned into K subsets, arbitrarily. The arbitrary partitioning or merging of paths can lead to imprecise intervals of variables which are influencing (in)validity of program properties. This imprecision makes the analyzer unable to determine verification result of program properties. If the paths are merged in such a way that these variables can retain precise values, analyzer can determine verification results of more program properties.</p><heading id="h-0004" level="1">SUMMARY</heading><p id="p-0006" num="0005">Embodiments of the present disclosure present technological improvements as solutions to one or more of the above-mentioned technical problems recognized by the inventors in conventional systems. For example, in one aspect, there is provided a processor implemented for selective path sensitive interval analysis. The method comprises obtaining, via one or more hardware processors, a program code comprising one or more program properties and a plurality of paths; reading, via the one or more hardware processors, one or more variables in the one or more program properties to obtain one or more read variables, each of the one or more read variables correspond to a value; computing, via the one or more hardware processors, one or more value impacting conditions (VICs) based the value being influenced in the one or more read variables; identifying, via the one or more hardware processors, one or more variables of interest (VoIs) based on one of (i) one or more variables read by the one or more value impacting conditions (VICs) and have transitive data dependence on the one or more read variables in the one or more program properties, (ii) the one or more read variables in the program properties, or (iii) one or more reset variables read in the one or more program properties, and wherein the one or more reset variables comprise a constant or a value defined via an external input; and selecting and merging, via the one or more hardware processors, two or more paths of the plurality of paths comprised in the program code based on the one or more identified VoIs, wherein the two or more paths are selected and merged based on a number of paths at a join point being identified.</p><p id="p-0007" num="0006">In an embodiment, the two or more paths are selected and merged to maintain a select subset of paths at the join point.</p><p id="p-0008" num="0007">In an embodiment, each of the two or more selected paths comprise at least one VoI from the one or more identified VoIs, wherein the at least one VoI comprise a variable interval in each of the two or more selected paths. The variable interval comprises an upper bound value and a lower bound value.</p><p id="p-0009" num="0008">In an embodiment, the step of selecting and merging two or more paths of the plurality of paths comprised in the program code is based on the upper bound value and the lower bound value comprised in the variable interval.</p><p id="p-0010" num="0009">In an embodiment, the step of selecting and merging two or more paths of the plurality of paths is based on one or more criteria, the one or more criteria being one of (i) the variable interval in the two or more paths are identical with each other. (ii) a union of the variable interval from the two or more paths forms a continual interval.</p><p id="p-0011" num="0010">In an embodiment, the step of selecting and merging two or more paths of the plurality of paths comprised in the program code is based on an order of the one or more identified VoIs comprised in the one or more program properties of the program code.</p><p id="p-0012" num="0011">In another aspect, there is provided a system for selective path sensitive interval analysis. The system comprises a memory storing instructions; one or more communication interfaces; and one or more hardware processors coupled to the memory via the one or more communication interfaces, wherein the one or more hardware processors are configured by the instructions to: obtain a program code comprising one or more program properties and a plurality of paths; read one or more variables in the one or more program properties to obtain one or more read variables, each of the one or more read variables correspond to a value; compute one or more value impacting conditions (VICs) based the value being influenced in the one or more read variables; identify one or more variables of interest (VoIs) based on one of (i) one or more variables read by the one or more value impacting conditions (VICs) and have transitive data dependence on the one or more read variables in the one or more program properties, (ii) the one or more variables read in the one or more program properties, or (iii) one or more reset variables read in the one or more program properties, and wherein the one or more reset variables comprise a constant or a value defined via an external input; and select and merge two or more paths of the plurality of paths comprised in the program code based on the one or more identified VoIs, wherein the two or more paths are selected and merged based on a number of paths at a join point being identified.</p><p id="p-0013" num="0012">In an embodiment, the two or more paths are selected and merged to maintain a select subset of paths at the join point.</p><p id="p-0014" num="0013">In an embodiment, each of the two or more selected paths comprise at least one VoI from the one or more identified VoIs, wherein the at least one VoI comprise a variable interval in each of the two or more selected paths. The variable interval comprises an upper bound value and a lower bound value.</p><p id="p-0015" num="0014">In an embodiment, the two or more paths of the plurality of paths comprised in the program code are selected and merged based on the upper bound value and the lower bound value comprised in the variable interval.</p><p id="p-0016" num="0015">In an embodiment, the two or more paths of the plurality of paths comprised in the program code are selected and merged are based on one or more criteria, the one or more criteria being one of (i) the variable interval in the two or more paths are identical with each other, (ii) a union of the variable interval from the two or more paths forms a continual interval.</p><p id="p-0017" num="0016">In an embodiment, the two or more paths of the plurality of paths comprised in the program code are selected and merged based on an order of the one or more identified VoIs comprised in the one or more program properties of the program code.</p><p id="p-0018" num="0017">In yet another aspect, there are provided one or more non-transitory machine-readable information storage mediums comprising one or more instructions which when executed by one or more hardware processors cause a method for selective path sensitive interval analysis. The method comprises obtaining, via one or more hardware processors, a program code comprising one or more program properties and a plurality of paths; reading, via the one or more hardware processors, one or more variables in the one or more program properties to obtain one or more read variables, each of the one or more read variables correspond to a value; computing, via the one or more hardware processors, one or more value impacting conditions (VICs) based the value being influenced in the one or more read variables; identifying, via the one or more hardware processors, one or more variables of interest (VoIs) based on one of (i) one or more variables read by the one or more value impacting conditions (VICs) and have transitive data dependence on the one or more read variables in the one or more program properties, (ii) the one or more variables read in the one or more program properties, or (iii) one or more reset variables read in the one or more program properties, and wherein the one or more reset variables comprise a constant or a value defined via an external input; and selecting and merging, via the one or more hardware processors, two or more paths of the plurality of paths comprised in the program code based on the one or more identified VoIs, wherein the two or more paths are selected and merged based on a number of paths at a join point being identified.</p><p id="p-0019" num="0018">In an embodiment, the two or more paths are selected and merged to maintain a select subset of paths at the join point.</p><p id="p-0020" num="0019">In an embodiment, each of the two or more selected paths comprise at least one VoI from the one or more identified VoIs, wherein the at least one VoI comprise a variable interval in each of the two or more selected paths. The variable interval comprises an upper bound value and a lower bound value.</p><p id="p-0021" num="0020">In an embodiment, the step of selecting and merging two or more paths of the plurality of paths comprised in the program code is based on the upper bound value and the lower bound value comprised in the variable interval.</p><p id="p-0022" num="0021">In an embodiment, the step of selecting and merging two or more paths of the plurality of paths is based on one or more criteria, the one or more criteria being one of (i) the variable interval in the two or more paths are identical with each other, (ii) a union of the variable interval from the two or more paths forms a continual interval.</p><p id="p-0023" num="0022">In an embodiment, the step of selecting and merging two or more paths of the plurality of paths comprised in the program code is based on an order of the one or more identified VoIs comprised in the one or more program properties of the program code</p><p id="p-0024" num="0023">It is to be understood that both the foregoing general description and the following detailed description are exemplary and explanatory only and are not restrictive of the invention, as claimed.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0025" num="0024">The accompanying drawings, which are incorporated in and constitute a part of this disclosure, illustrate exemplary embodiments and, together with the description, serve to explain the disclosed principles.</p><p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates an exemplary block diagram of a system for selective path sensitive interval analysis, in accordance with an embodiment of the present disclosure.</p><p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates an exemplary flow diagram of a method for selective path sensitive interval analysis using the system of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, in accordance with an embodiment of the present disclosure.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0006" level="1">DETAILED DESCRIPTION</heading><p id="p-0028" num="0027">Exemplary embodiments are described with reference to the accompanying drawings. In the figures, the left-most digit(s) of a reference number identifies the figure in which the reference number first appears. Wherever convenient, the same reference numbers are used throughout the drawings to refer to the same or like parts. While examples and features of disclosed principles are described herein, modifications, adaptations, and other implementations are possible without departing from the spirit and scope of the disclosed embodiments. It is intended that the following detailed description be considered as exemplary only, with the true scope and spirit being indicated by the following claims.</p><p id="p-0029" num="0028">Abstract interpretation based static analysis tools use relational/non-relational abstract domains to verify program properties. Precision and scalability of analysis vary basis usage of abstract domains. K-limited path-sensitive interval domain is an abstract domain that was conventionally proposed for analysis on industry strength programs. The domain maintains variables' intervals along a configurable K subsets of paths at each program point, which implicitly provides co-relation among variables. When the number of paths at the join point exceeds K, set of paths are partitioned into K subsets, arbitrarily, which results in loss of precision required to verify program properties. To address the above problem, embodiments of the present disclosure provide selective merging of paths in such a way that the intervals computed help verifying more properties. The selective path-sensitive method of the present disclosure is based on the knowledge of variables whose values influence the verification outcome of program properties.</p><p id="p-0030" num="0029">Referring now to the drawings, and more particularly to <figref idref="DRAWINGS">FIGS. <b>1</b> through <b>2</b></figref>, where similar reference characters denote corresponding features consistently throughout the figures, there are shown preferred embodiments and these embodiments are described in the context of the following exemplary system and/or method.</p><p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates an exemplary block diagram of a system for selective path sensitive interval analysis, in accordance with an embodiment of the present disclosure. In an embodiment, the system <b>100</b> includes one or more processors <b>104</b>, communication interface device(s) or input/output (I/O) interface(s) <b>106</b>, and one or more data storage devices or memory <b>102</b> operatively coupled to the one or more processors <b>104</b>, The one or more processors <b>104</b> may be one or more software processing modules and/or hardware processors. In an embodiment, the hardware processors can be implemented as one or more microprocessors, microcomputers, microcontrollers, digital signal processors, central processing units, state machines, logic circuitries, and/or any devices that manipulate signals based on operational instructions. Among other capabilities, the processor(s) is configured to fetch and execute computer-readable instructions stored in the memory. In an embodiment, the device <b>100</b> can be implemented in a variety of computing systems, such as laptop computers, notebooks, hand-held devices, workstations, mainframe computers, servers, a network cloud and the like.</p><p id="p-0032" num="0031">The I/O interface device(s) <b>106</b> can include a variety of software and hardware interfaces, for example, a web interface, a graphical user interface, and the like and can facilitate multiple communications within a wide variety of networks N/W and protocol types, including wired networks, for example, LAN, cable, etc., and wireless networks, such as WLAN, cellular, or satellite. In an embodiment, the I/O interface device(s) can include one or more ports for connecting a number of devices to one another or to another server.</p><p id="p-0033" num="0032">The memory <b>102</b> may include any computer-readable medium known in the art including, for example, volatile memory, such as static random access memory (SRAM) and dynamic random access memory (DRAM), and/or non-volatile memory, such as read only memory (ROM), erasable programmable ROM, flash memories, hard disks, optical disks, and magnetic tapes. In an embodiment a database <b>108</b> can be stored in the memory <b>102</b>, wherein the database <b>108</b> may comprise, but are not limited to program code, variables read in the program properties, variable intervals, value impacting conditions, variables of interest, paths being selected and merged, and like. The memory <b>102</b> further comprises (or may further comprise) information pertaining to input(s)/output(s) of each step performed by the systems and methods of the present disclosure. In other words, input(s) fed at each step and output(s) generated at each step are comprised in the memory <b>102</b> and can be utilized in further processing and analysis.</p><p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. <b>2</b></figref>, with reference to <figref idref="DRAWINGS">FIG. <b>1</b></figref>, illustrates an exemplary flow diagram of a method for selective path sensitive interval analysis using the system <b>100</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, in accordance with an embodiment of the present disclosure. In an embodiment, the system(s) <b>100</b> comprises one or more data storage devices or the memory <b>102</b> operatively coupled to the one or more hardware processors <b>104</b> and is configured to store instructions for execution of steps of the method by the one or more processors <b>104</b>. The steps of the method of the present disclosure will now be explained with reference to the components of the system <b>100</b> as depicted in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, and the flow diagram of <figref idref="DRAWINGS">FIG. <b>2</b></figref>. In an embodiment of the present disclosure, at step <b>202</b>, the one or more hardware processors <b>104</b> obtain a program code comprising one or more program properties and a plurality of paths. Below considered is sample program code (C code) as shown below with a valid property encoded as an assertion at line 20.</p><heading id="h-0007" level="2">Sample C Code:</heading><p id="p-0035" num="0034"></p><p id="p-0036" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="56pt" align="right"/><colspec colname="2" colwidth="161pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>1.</entry><entry>....</entry></row><row><entry>2.</entry><entry>unsigned inf b=0, c=0, d=0, s=c,i =0;</entry></row><row><entry>3.</entry><entry>while (1){</entry></row><row><entry>4.</entry><entry>&#x2003;&#x2003;if(s == 0){</entry></row><row><entry>5.</entry><entry>&#x2003;&#x2003;&#x2003;&#x2003;c = 2;</entry></row><row><entry>6.</entry><entry>&#x2003;&#x2003;&#x2003;&#x2003;b = c+6;</entry></row><row><entry>7.</entry><entry>&#x2003;&#x2003;&#x2003;&#x2003;s = 1;</entry></row><row><entry>8.</entry><entry>&#x2003;&#x2003;}</entry></row><row><entry>9.</entry><entry>&#x2003;&#x2003;else if(s == 1){</entry></row><row><entry>10.</entry><entry>&#x2003;&#x2003;&#x2003;&#x2003;c = 1;</entry></row><row><entry>11.</entry><entry>&#x2003;&#x2003;&#x2003;&#x2003;d = c +2;</entry></row><row><entry>12.</entry><entry>&#x2003;&#x2003;&#x2003;&#x2003;b = d;</entry></row><row><entry>13.</entry><entry>&#x2003;&#x2003;&#x2003;&#x2003;s = 2;</entry></row><row><entry>14.</entry><entry>&#x2003;&#x2003;}</entry></row><row><entry>15.</entry><entry>&#x2003;&#x2003;else if(s == 2){</entry></row><row><entry>16.</entry><entry>&#x2003;&#x2003;&#x2003;if(d &#x3e; 1)</entry></row><row><entry>17.</entry><entry>&#x2003;&#x2003;&#x2003;&#x2003;b = d;</entry></row><row><entry>18.</entry><entry>&#x2003;&#x2003;&#x2003;else</entry></row><row><entry>19.</entry><entry>&#x2003;&#x2003;&#x2003;&#x2003;b = c;</entry></row><row><entry>20.</entry><entry>&#x2003;&#x2003;&#x2003;assert (b == 3);</entry></row><row><entry>21.</entry><entry>&#x2003;}</entry></row><row><entry>22.</entry><entry>}</entry></row><row><entry>23.</entry><entry>....</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0037" num="0035">In the present disclosure, a method is provided to identify variables which are influencing the verification outcome of program properties and termed them as Variables of Interest (VoIs), Obvious choice of such VoIs is variables read in program properties. However, this choice is useful when variables read in properties do not have any transitive data dependence on other variables, which is very uncommon in industrial applications. Therefore, to make K-limited path sensitive interval analysis more effective in industrial settings, more intelligent identification of VoIs is needed Once VoIs are identified, the identified VoIs are used to make existing K-limited path sensitive interval analysis as selective path-sensitive interval analysis. Therefore, at step <b>204</b>, the one or more hardware processors read one or more variables in the one or more program properties to obtain one or more read variables, each of the one or more read variables correspond to a value.</p><p id="p-0038" num="0036">The above example of C code is to be analyzed with K=2. In this example, at the third iteration of the loop, three paths P<sub>0</sub>, P<sub>1</sub>, and P<sub>2 </sub>meets at loop node (line 3). These paths are given as follows:</p><p id="p-0039" num="0000">P<sub>0</sub>:{s=[0,0], d=[0,0], c=[0,0], b=[0,0]} //from top of the loop<br/>P<sub>1</sub>:{s=[1,1], d=[0,0], c=[2,2], b=[8,8]} //from first block of if statement<br/>P<sub>2</sub>:{s=[2,2], d=[3,3], c=[1,1], b=[3,3]} //from second block of if statement</p><p id="p-0040" num="0037">To decide verification result of the property, path P<sub>2 </sub>should not be merged with other paths. Arbitrarily deciding which paths to merge may result into merging of P<sub>2 </sub>with P<sub>0 </sub>or P<sub>1</sub>. This leads to an imprecise interval [0,3] or [3,8] of variable b at the loop node, with which analysis cannot decide validity of the encoded program property. Moreover, just looking at a value of read variable b in the property, here, it cannot be decided which two paths to merge. However, if one tracks the value of a variable d, which is actually controlling value assigned to variable b, one can decide merging of paths P<sub>0</sub>, P<sub>1 </sub>in one and keeping P<sub>2 </sub>un-merged to retain K=2 and precise interval for d. The resultant paths after this merging at loop node at the start of third iteration of loop will be as follows:</p><p id="p-0041" num="0000">P<sub>0</sub>+P<sub>1</sub>: {s=[0,1], d=[0,0], c=[0,2], b=[0,8]}<br/>P<sub>2</sub>: {s=[2,2], d=[3,3], c=[1,1], b=[3,3]}</p><p id="p-0042" num="0038">This results only path P<sub>2 </sub>to enter in third else-if block and helps validate the property.</p><p id="p-0043" num="0039">In an embodiment, at step <b>206</b>, the one or more hardware processors <b>104</b> compute, via the one or more hardware processors, one or more value impacting conditions (VICs) based the value being influenced in the one or more read variables. In an embodiment, at step <b>208</b>, the one or more hardware processors <b>104</b> identify one or more variables of interest (VoIs) based on one of (i) one or more variables read by the one or more value impacting conditions and have transitive data dependence on the one or more read variables (or the one or more variables read) in the one or more program properties, (ii) the one or more variables read in the one or more program properties, or (iii) one or more reset variables read in the one or more program properties. The one or more reset variables comprise a constant or a value defined via an external input (e.g., a user defined value). In an embodiment, statements &#x2018;one or more variables read by&#x2019; the one or more variables read in the one or more program properties' and &#x2018;the one or more read variables in the one or more program properties&#x2019; refer to variables read from/in the program properties and may be interchangeably used herein. The steps <b>206</b> and <b>208</b> are better understood by way of following description.</p><p id="p-0044" num="0040">Variable of interest with respect to a property &#x3d5; is denoted as VoIs(&#x3d5;). Let V<sub>r </sub>be the variables read in &#x3d5; and DD(&#x3d5;) be the transitive data dependence of V<sub>r</sub>. V(DD(&#x3d5;)) represents set of variables defined at each statement present in DD(&#x3d5;). Value impacting conditions (VICs) are computed, which influence the values of variables in V<sub>r</sub>. In the above program code, assert at line 20 represents a property &#x3d5;, V(DD(&#x3d5;))={b, c, d} and VICs={4, 9, 16} (condition expressions at given line numbers). VoIs(&#x3d5;) are those variables from V(DD(&#x3d5;)) which are read by some VICs. Since, only variable d is being read in VIC at line 16, VoIs(&#x3d5;)={d}.</p><p id="p-0045" num="0000">In general, VoIs(&#x3d5;) is given as follows:</p><p id="p-0046" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>VoIs(&#x3d5;)={<i>v&#x2208;V</i>(<i>DD</i>(&#x3d5;))|<i>v </i>read in some <i>c</i>&#x2208;VICs&#x2228;<i>v </i>is a reset variable}&#x2003;&#x2003;(1)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0047" num="0041">if (VoIs(&#x3d5;) is empty) then VoIs(&#x3d5;)=V<sub>r </sub></p><p id="p-0048" num="0042">Currently; computation of VoIs is intra-procedural. Program dependence graph as known in the art (e.g., &#x201c;Gianfranco Bilardi and Keshav Pingali. 1996. A Framework for Generalized Control Dependence. In Proceedings of the ACM SIGPLAN 1996 Conference on Programming Language Design and Implementation (Philadelphia, Pa., USA) (PLDI '96). ACM, New York, N.Y., USA, 291-300. https://doi.org/10.1145/231379.231435&#x201d;) is used for computing transitive data dependence and VICs is computed accordingly (e.g., refer &#x201c;Shrawan Kumar, Amitabha Sanyal, and Uday Khedker. 2015. Value Slice: A New Slicing Concept for Scalable Property Checking. In International Conference on Tools and Algorithms for the Construction and Analysis of Systems. Springer, 101-115&#x201d; for VICs computation).</p><p id="p-0049" num="0043">Once the VoIs are identified, at step <b>210</b> of the present disclosure, the one or more hardware processors <b>104</b> select and merge two or more paths of the plurality of paths comprised in the program code based on the one or more identified VoIs. The two or more paths are selected and merged based on a number of paths at a join point being identified. For instance, at a given join point, if the number of paths say &#x2018;n&#x2019; exceeds a predefined threshold &#x2018;K&#x2019; (e.g., wherein K is also referred predefined paths for a given join point), the two or more paths are selected and merged accordingly. The selection and merging of paths are performed to maintain a select subset of paths at the join point, in one embodiment of the present disclosure. The above step of <b>210</b> is better understood by way of following description:</p><p id="p-0050" num="0044">As described above, when the number of paths at a join point exceeds K, at least few (or subset of) paths are merged to maintain K subsets at the join point. The present disclosure uses the identified VoIs to select and merge subset of paths. For simplicity of presentation, consider there is VoI v, and interval for v is present in all n paths p<sub>1</sub>, p<sub>2 </sub>. . . p<sub>K </sub>. . . p<sub>n</sub>, where n&#x3e;K, meeting at a join point. Criteria applied on intervals of v to decide merging of n&#x2212;(K&#x2212;1) paths is given as follows: Let v has interval v<sub>i</sub>=[l<sub>i</sub>, u<sub>i</sub>] and v<sub>j</sub>=[l<sub>j</sub>, u<sub>j</sub>] in path p<sub>i </sub>and p<sub>j</sub>, respectively, where l<sub>i</sub>, l<sub>j </sub>are lower bound of interval and u<sub>i</sub>, u<sub>j </sub>are upper bound.</p><p id="p-0051" num="0045">Therefore, each of the two or more selected paths comprise at least one VoI from the one or more identified VoI. The at least one VoI comprise a variable interval in each of the two or more selected paths. Further, the variable interval comprises an upper bound value (e.g., u<sub>i</sub>, u<sub>j</sub>, and the like) and a lower bound value (e.g., l<sub>i</sub>, l<sub>j</sub>, and the like). Therefore, the selection and merging of two or more paths is performed by the present disclosure when the step of selecting and merging two or more paths of the plurality of paths when one or more criteria are met. For instance, the one or more criteria being one of (i) the variable interval in the two or more paths are identical with each other, (ii) a union of the variable interval from the two or more paths forms a continual interval. Thus, Paths p<sub>i </sub>and p<sub>j </sub>are merged if any one of the below criteria is met, wherein the one or more criteria are better understood by following expressions:</p><p id="p-0052" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>l</i><sub>i</sub><i>=l</i><sub>j</sub><i>&#x2227;u</i><sub>i</sub><i>=u</i><sub>j </sub><?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0053" num="0000">v<sub>i</sub>&#x222a;v<sub>j </sub>results into continuous interval when any of the below conditions satisfy.</p><p id="p-0054" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>l</i><sub>i</sub><i>&#x3c;l</i><sub>j</sub>&#x2227;(<i>l</i><sub>j</sub><i>=u</i><sub>i</sub>)&#x2228;<i>l</i><sub>j</sub><i>=u</i><sub>i</sub>+1 or<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0055" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>l</i><sub>j</sub><i>&#x3c;l</i><sub>i</sub>&#x2227;(<i>l</i><sub>i</sub><i>=u</i><sub>j</sub>)&#x2228;<i>l</i><sub>i</sub><i>=u</i><sub>j</sub>+1 or<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0056" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>l</i><sub>i</sub><i>&#x3c;l</i><sub>j</sub>&#x2228;(<i>l</i><sub>i</sub><i>=l</i><sub>j</sub>+1)&#x2228;(<i>l</i><sub>j</sub><i>=l</i><sub>i</sub>+1)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0057" num="0046">Union (&#x222a;) over intervals is defined as per research work known in the art (e.g., refer &#x201c;Patrick Cousot and Radhia Cousot. 1977. Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixpoints. In Proceedings of the 4th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages (Los Angeles, Calif.) (POPL '77), ACM, New York, N.Y., USA, 238-252. https://doi.org/10.1145/512950.512973&#x201d;).</p><p id="p-0058" num="0047">During a join (or merging of paths) operation, above checks are performed for one VoI at a time until total number of paths become K at that join point. In above program code example, for identified VoI d, very first criterion is satisfied for path P<sub>0 </sub>and P<sub>1</sub>, so, those two paths are merged. It is observed above, with this merging of paths, the program property at line 20 has correctly verified as valid. When above defined criteria do not match for any of the identified VoIs (mostly, when set of n paths are disjoint), paths can be arbitrarily selected for merging.</p><p id="p-0059" num="0048">However, there could be instances/scenarios, that for a given property, more than one VoIs can be identified. In the experiments conducted by the present disclosure, it has been observed that up to four VoIs were identified for a given property, however, at most two were used to make n paths into K paths. It is to be further noted that when there are more than one VoIs, order in which VoIs are picked to match defined criteria is also important, Consider below exemplary program code with encoded valid property (EVP) at line 16, to be analyze with K=2 having two VoIs={c,b}. Sample program code:</p><p id="p-0060" num="0000"><tables id="TABLE-US-00002" num="00002"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="42pt" align="right"/><colspec colname="2" colwidth="175pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>1.</entry><entry>unsigned int a = 0, f = 0, c = *, b = *;</entry></row><row><entry>2.</entry><entry>func ( ){</entry></row><row><entry>3.</entry><entry/></row><row><entry>4.</entry><entry>if(c &#x3c; 10){</entry></row><row><entry>5.</entry><entry>&#x2003;a = c;</entry></row><row><entry>6.</entry><entry>&#x2003;b=0;</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="42pt" align="right"/><colspec colname="2" colwidth="77pt" align="left"/><colspec colname="3" colwidth="98pt" align="left"/><tbody valign="top"><row><entry>7.</entry><entry>}</entry><entry>// Path P<sub>1</sub></entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="42pt" align="right"/><colspec colname="2" colwidth="175pt" align="left"/><tbody valign="top"><row><entry>8.</entry><entry>else {</entry></row><row><entry>9.</entry><entry>&#x2003;if(b == 0)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="42pt" align="right"/><colspec colname="2" colwidth="77pt" align="left"/><colspec colname="3" colwidth="98pt" align="left"/><tbody valign="top"><row><entry>10.</entry><entry>&#x2003;&#x2003;f = 0;</entry><entry>// Path P<sub>2</sub></entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="42pt" align="right"/><colspec colname="2" colwidth="175pt" align="left"/><tbody valign="top"><row><entry>11.</entry><entry>&#x2003;else {</entry></row><row><entry>12.</entry><entry>&#x2003;&#x2003;f = 1;</entry></row><row><entry>13.</entry><entry>&#x2003;&#x2003;b = f;</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="42pt" align="right"/><colspec colname="2" colwidth="77pt" align="left"/><colspec colname="3" colwidth="98pt" align="left"/><tbody valign="top"><row><entry>14.</entry><entry>&#x2003;}</entry><entry>// Path P<sub>3</sub></entry></row><row><entry>15.</entry><entry>}</entry><entry>// join point</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="42pt" align="right"/><colspec colname="2" colwidth="175pt" align="left"/><tbody valign="top"><row><entry>16.</entry><entry>if(f != 0)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="42pt" align="right"/><colspec colname="2" colwidth="77pt" align="left"/><colspec colname="3" colwidth="98pt" align="left"/><tbody valign="top"><row><entry>17.</entry><entry>&#x2003;assert (a &#x3c; b); </entry><entry>// EVP</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="42pt" align="right"/><colspec colname="2" colwidth="175pt" align="left"/><tbody valign="top"><row><entry>18.</entry><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0061" num="0049">At the join point (end of line 14), three paths&#x2014;</p><p id="p-0062" num="0050">P<sub>1</sub>:{a=[0,9],b=[0,0],c=[0, 9],f=[0,0]}</p><p id="p-0063" num="0051">P<sub>2</sub>:{a=[0,0],b=[0,0],c=[10,Max],f=[0,0]}</p><p id="p-0064" num="0052">P<sub>3</sub>:{a=[0,0],b=[1,1],c=[10,Max],f=[1,1]}</p><p id="p-0065" num="0000">meet at that program point. To retain K=2, two paths need to be merged. Variable c as VoI results into merging of P<sub>2 </sub>and P<sub>3</sub>; resulting into paths&#x2014;P<sub>1</sub>:{a=[0,9] b=[0,0], c=[0,9], f=[0,0]}<br/>P<sub>2</sub>+P<sub>3</sub>:{a=[0,0], b=[0,1], c=[10,Max], f=[0,1]}. With this, path P<sub>2</sub>+P<sub>3 </sub>reaches at property A<sub>1 </sub>and with the intervals of a and b in this path, verification result of the property cannot be decided (because property satisfy for b=1, but for b=0 it do not), and it will be unknown. Whereas variable b as VoI results into merging of P<sub>1 </sub>and P<sub>2</sub>, resulting into following paths&#x2014;P<sub>1</sub>+P<sub>2</sub>:{a=[0,9], b=[0,0], c=[0,MAX], f=[0,0]} and P<sub>3</sub>:{a=[0,0], b=[1,1], c=[10,Max], f=[1,1]}. With this, path P<sub>3 </sub>reaches at the property and with the intervals of a and b in this path, assert EVP can be proved as valid. Thus, along with effective VoIs, their order also plays an effective role in verification of properties.</p><p id="p-0066" num="0053">Based on above observation, if list of identified VoIs contains variables read in given property, then those variables take precedence in VoIs order while selecting paths (based on VoI) for merging at join point. In above example, read variable &#x2018;b&#x2019; is present in identified VoIs list, so VoI &#x2018;b&#x2019; has chosen first for selecting paths to be merged. In the present disclosure effective order of VoIs is made use by the system and method, which help to (in)validate program properties. It is ensured in the present disclosure that, on an application, with same analysis setting, for given program properties, identified VoIs order is always same. This further ensures that re-execution of an application with same setting always yields same result for given program properties.</p><heading id="h-0008" level="2">Experimentation:</heading><p id="p-0067" num="0054">To evaluate the effectiveness of identified VoIs for selective path-sensitive interval analysis, the present disclosure has performed experiments on three industrial applications and academic benchmarks. The evaluation was focused on how many more properties could be (in)validated when the present disclosure the system and method perform the method of VoIs aware selective path-sensitive interval analysis as described herein.</p><heading id="h-0009" level="2">Applications and Benchmarks:</heading><p id="p-0068" num="0055">Present disclosure selected three industrial C applications and 36 benchmarks belonging to the control-flow sub-category of international software verification competition (SV-COMP) 2021 repository (e.g., refer &#x2018;2021. SV-COMP 2021&#x2014;10th International Competition on Software Verification. http://sv-comp.sosy-lab.org/2021/.&#x2019;). These selected industry applications and benchmarks are respectively shown as A<sub>1-3 </sub>and SV in Table 1. More specifically, Table 1 depicts selective path sensitive interval analysis results.</p><p id="p-0069" num="0000"><tables id="TABLE-US-00003" num="00003"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="28pt" align="left"/><colspec colname="3" colwidth="49pt" align="left"/><colspec colname="4" colwidth="84pt" align="center"/><thead><row><entry namest="1" nameend="4" rowsep="1">TABLE 1</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row><row><entry/><entry/><entry/><entry>Number of</entry></row><row><entry/><entry/><entry/><entry>(in)validated asserts</entry></row><row><entry/><entry/><entry/><entry>using Vols as</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="28pt" align="center"/><colspec colname="3" colwidth="49pt" align="center"/><colspec colname="4" colwidth="35pt" align="center"/><colspec colname="5" colwidth="49pt" align="center"/><tbody valign="top"><row><entry/><entry/><entry/><entry/><entry>As per</entry></row><row><entry/><entry/><entry/><entry>Variables</entry><entry>method of</entry></row><row><entry/><entry/><entry/><entry>read in</entry><entry>the</entry></row><row><entry/><entry/><entry>Number</entry><entry>assert</entry><entry>present</entry></row><row><entry>Application</entry><entry>KLOC</entry><entry>of asserts</entry><entry>(prior art*)</entry><entry>disclosure</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="28pt" align="char" char="."/><colspec colname="3" colwidth="49pt" align="char" char="."/><colspec colname="4" colwidth="35pt" align="char" char="."/><colspec colname="5" colwidth="49pt" align="char" char="."/><tbody valign="top"><row><entry>A1</entry><entry>7.7</entry><entry>196</entry><entry>11</entry><entry>50</entry></row><row><entry>A2</entry><entry>8</entry><entry>94</entry><entry>30</entry><entry>54</entry></row><row><entry>A3</entry><entry>18.3</entry><entry>341</entry><entry>56</entry><entry>140</entry></row><row><entry>SV</entry><entry>62</entry><entry>36</entry><entry>24</entry><entry>24</entry></row><row><entry>Total</entry><entry>96</entry><entry>667</entry><entry>121</entry><entry>268</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row><row><entry namest="1" nameend="5" align="left" id="FOO-00001">*refer - Mohammad Afzal et al. 2020. VeriAbs: Verification by Abstraction and Test Generation (Competition Contribution). In International Conference on Tools and Algorithms for the Construction and Analysis of Systems, TACAS 2020. Springer, 383-387. https://dol.org/10.1007/978-3-030-45237-7_25.</entry></row></tbody></tgroup></table></tables></p><p id="p-0070" num="0056">The industrial application A<sub>1 </sub>implements a smart-card functionality. A<sub>2 </sub>and A<sub>3 </sub>implements a protocol stack and a CAN Driver application of a vehicle, respectively. In SV-COMP benchmarks, the present disclosure selected all 36 programs contributed by predicate abstraction-based tool, BLAST (as known in the art tool). The selected programs have intensive control flow with size ranges from 1.6-1.8 KLOC.</p><heading id="h-0010" level="2">Analysis of Applications and Benchmarks:</heading><p id="p-0071" num="0057">The present disclosure analyzed all three industrial applications for invalid array indexing, division by zero, integer overflows and underflows. To verify these properties, first the method of the present disclosure applied K-limited path sensitive interval analysis with K=10. The unresolved properties (which cannot be determined as valid/invalid) are flagged as warnings. These warnings are automatically encoded as assertions (assert function calls) under #ifdef labels. The present disclosure evaluated one assert at a time by defining appropriate #ifdef label, VoIs with respect to an assert are computed and using these VoIs, selective path-sensitive interval analysis with same value of K is applied to verify the assert.</p><p id="p-0072" num="0058">The SV-COMP benchmarks have conditional error reachability labels. The present disclosure considers error reachable condition as the program property. None of the 36 programs were validated using K-limited path sensitive interval analysis with K=150. So, VoIs aware selective path-sensitive interval analysis with same value of K was applied by the present disclosure to these programs. All applications and benchmarks have been analyzed using 2.11 GHz Intel processor, 16 GB of RAM and a 64-bit Windows OS.</p><heading id="h-0011" level="2">Evaluation Results:</heading><p id="p-0073" num="0059">To assess the benefits of VoIs computation as described by the method of the present disclosure, the present disclosure verified a total of 667 asserts by considering VoIs in both ways, directly read variables in assert (prior art) and method of the present disclosure as described in <figref idref="DRAWINGS">FIG. <b>2</b></figref>. The evaluation result presented in above Table 1 indicates that the selective path-sensitive interval analysis using VoIs identification of <figref idref="DRAWINGS">FIG. <b>2</b></figref> results in verifying 268 (approximately 40%) more asserts as compared to arbitrarily merging of subset of paths. Also, VoIs identification of the present disclosure has led to verifying 147 (23%) more asserts as valid/invalid as compared to considering read variables as VoIs in an assert (prior art technique).</p><p id="p-0074" num="0060">All (in)validated asserts in A<sub>1-3 </sub>and SV by considering VoIs as read variables in assert are also (in)validated using the VoIs identification of the present disclosure. Reason is, in A<sub>1</sub>, A<sub>3</sub>, and SV, 11, 56, and 24 (in)validated asserts, respectively, reads only reset variables. While 30 asserts in A<sub>2 </sub>fall in the scenario given in below sample code, whereby both approaches, identified VoI is {x}.</p><heading id="h-0012" level="2">Sample Program Code Depicting Scenario in A<sub>2</sub>:</heading><p id="p-0075" num="0061"></p><p id="p-0076" num="0000"><tables id="TABLE-US-00004" num="00004"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="70pt" align="right"/><colspec colname="2" colwidth="147pt" align="left"/><thead><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>1.</entry><entry>white (arr[x] != &#x2019;\O &#x2019;){</entry></row><row><entry>2.</entry><entry>&#x2003;assert (x &#x3c;0 &#x26;&#x26; x &#x3e;100);</entry></row><row><entry>3.</entry><entry>&#x2003;x ++;</entry></row><row><entry>4.</entry><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>However, 12 non-verified programs from SV, where program property reads only reset variables have VICs which are controlling values assigned to these reset variables. Present disclosure does not consider VCs for reset variables; hence, these programs did not get benefit from present disclosure. The non-verified 387 properties on industrial applications (A<sub>1</sub>-A<sub>3</sub>) either had their computed VoIs set as empty as per equation (1) (resulting V becomes VoIs) or identified VoIs did not satisfy the criteria defined for join operation. So, during join operation, in former case, path merging did not result into effective paths to help (in)validate properties; and in the later one path merging fell back to arbitrary selection and merging thus resulting into loss of precision required to verify properties.</p><p id="p-0077" num="0062">In the experiments conducted by the present disclosure, the method applied VoIs aware selective path-sensitive interval analysis to one property at a time. However, in general, it can be effectively applied to a group of related program properties which share common data and/or control dependence. Because due to common program dependence, identified VoIs tend to be common for each individual property in such a group of properties. Overall, through experiments, it has been observed that selective path sensitivity with effective VoIs has the practical advantage.</p><p id="p-0078" num="0063">Embodiments of the present disclosure provide system and method for selective path-sensitive interval analysis for precise and scalable property verification in practice. The analysis is selective using variables of interest (VoIs) with respect to program properties. The method of the present disclosure included identification of these variables of interest with respect to a property which can help (in)validate that property. The present disclosure further demonstrated the effectiveness of the approach by verifying 40% more properties as compared to analysis which do not use knowledge of VoIs over industrial automotive applications. This shows that the selective analysis is the need for effective property verification in practice and guided selection with respect to program properties is the key to achieve precision with scalability.</p><p id="p-0079" num="0064">The written description describes the subject matter herein to enable any person skilled in the art to make and use the embodiments. The scope of the subject matter embodiments is defined by the claims and may include other modifications that occur to those skilled in the art. Such other modifications are intended to be within the scope of the claims if they have similar elements that do not differ from the literal language of the claims or if they include equivalent elements with insubstantial differences from the literal language of the claims.</p><p id="p-0080" num="0065">It is to be understood that the scope of the protection is extended to such a program and in addition to a computer-readable means having a message therein; such computer-readable storage means contain program-code means for implementation of one or more steps of the method, when the program runs on a server or mobile device or any suitable programmable device. The hardware device can be any kind of device which can be programmed including e.g., any kind of computer like a server or a personal computer, or the Ike, or any combination thereof. The device may also include means which could be e.g., hardware means like e.g., an application-specific integrated circuit (ASIC), a field-programmable gate array (FPGA), or a combination of hardware and software means, e.g., an ASIC and an FPGA, or at least one microprocessor and at least one memory with software processing components located therein. Thus, the means can include both hardware means and software means. The method embodiments described herein could be implemented in hardware and software. The device may also include software means. Alternatively, the embodiments may be implemented on different hardware devices, e.g., using a plurality of CPUs.</p><p id="p-0081" num="0066">The embodiments herein can comprise hardware and software elements. The embodiments that are implemented in software include but are not limited to, firmware, resident software, microcode, etc. The functions performed by various components described herein may be implemented in other components or combinations of other components. For the purposes of this description, a computer-usable or computer readable medium can be any apparatus that can comprise, store, communicate, propagate, or transport the program for use by or in connection with the instruction execution system, apparatus, or device.</p><p id="p-0082" num="0067">The illustrated steps are set out to explain the exemplary embodiments shown, and it should be anticipated that ongoing technological development will change the manner in which particular functions are performed. These examples are presented herein for purposes of illustration, and not limitation. Further, the boundaries of the functional budding blocks have been arbitrarily defined herein for the convenience of the description. Alternative boundaries can be defined so long as the specified functions and relationships thereof are appropriately performed. Alternatives (including equivalents, extensions, variations, deviations, etc., of those described herein) will be apparent to persons skilled in the relevant art(s) based on the teachings contained herein. Such alternatives fall within the scope of the disclosed embodiments. Also, the words &#x201c;comprising,&#x201d; &#x201c;having,&#x201d; &#x201c;containing,&#x201d; and &#x201c;including,&#x201d; and other similar forms are intended to be equivalent in meaning and be open ended in that an item or items following any one of these words is not meant to be an exhaustive listing of such item or items, or meant to be limited to only the listed item r items. It must also be noted that as used herein and in the appended claims, the singular forms &#x201c;a,&#x201d; &#x201c;an,&#x201d; and &#x201c;the&#x201d; include plural references unless the context clearly dictates otherwise.</p><p id="p-0083" num="0068">Furthermore, one or more computer-readable storage media may be utilized in implementing embodiments consistent with the present disclosure. A computer-readable storage medium refers to any type of physical memory on which information or data readable by a processor may be stored. Thus, a computer-readable storage medium may store instructions for execution by one or more processors, including instructions for causing the processor(s) to perform steps or stages consistent with the embodiments described herein. The term &#x201c;computer-readable medium&#x201d; should be understood to include tangible items and exclude carrier waves and transient signals, i.e., be non-transitory. Examples include random access memory (RAM), read-only memory (ROM), volatile memory, nonvolatile memory, hard drives, CD ROMs, DVDs, flash drives, disks, and any other known physical storage media.</p><p id="p-0084" num="0069">It is intended that the disclosure and examples be considered as exemplary only, with a true scope and spirit of disclosed embodiments being indicated by the following claims.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A processor implemented method, comprising:<claim-text>obtaining, via one or more hardware processors, a program code comprising one or more program properties and a plurality of paths;</claim-text><claim-text>reading, via the one or more hardware processors, one or more variables in the one or more program properties to obtain one or more read variables, each of the one or more read variables correspond to a value;</claim-text><claim-text>computing, via the one or more hardware processors, one or more value impacting conditions (VICs) based the value being influenced in the one or more read variables;</claim-text><claim-text>identifying, via the one or more hardware processors, one or more variables of interest (VoIs) based on one of (i) one or more variables read by the one or more value impacting conditions (VICs) and have transitive data dependence on the one or more read variables in the one or more program properties, (ii) the one or more read variables in the one or more program properties, or (iii) one or more reset variables read in the one or more program properties, and wherein the one or more reset variables comprise a constant or a value defined via an external input; and</claim-text><claim-text>selecting and merging, via the one or more hardware processors, two or more paths of the plurality of paths comprised in the program code based on the one or more identified VoIs, herein the two or more paths are selected and merged based on a number of paths at a join point being identified.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The processor implemented method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the two or more paths are selected and merged to maintain a select subset of paths at the join point.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The processor implemented method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein each of the two or ore selected paths comprise at least one VoI from the one or more identified VoI, wherein the at least one VoI comprise a variable interval in each of the two or more selected paths, and wherein the variable interval comprises an upper bound value and a lower bound value.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The processor implemented method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the step of selecting and merging two or more paths of the plurality of paths comprised in the program code is based on the upper bound value and the lower bound value comprised in the variable interval.</claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The processor implemented method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the step of selecting and merging two or more paths of the plurality of paths is based on one or more criteria, the one or more criteria being one of (i) the variable interval in the two or more paths are identical with each other, (ii) a union of the variable interval from the two or more paths forms a continual interval.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. A system, comprising:<claim-text>a memory storing instructions;</claim-text><claim-text>one or more communication interfaces; and</claim-text><claim-text>one or more hardware processors coupled to the memory via the one or more communication interfaces, wherein the one or more hardware processors are configured by the instructions to:</claim-text><claim-text>obtain a program code comprising one or more program properties and a plurality of paths;</claim-text><claim-text>read one or more variables in the one or more program properties to obtain one or more read variables, each of the one or more read variables correspond to a value;</claim-text><claim-text>compute one or more value impacting conditions (VICs) based the value being influenced in the one or ore read variables;</claim-text><claim-text>identify one or more variables of interest (VoIs) based on one of (i) one or more variables read by the one or more value impacting conditions (VICs) and have transitive data dependence on the one or more read variables in the one or more program properties, (ii) the one or more read variables in the one or more program properties, or (iii) one or more reset variables read in the one or more program properties, and wherein the one or more reset variables comprise a constant or a value defined via an external input; and</claim-text><claim-text>select and merge two or more paths of the plurality of paths comprised in the program code based on the one or more identified VoIs, wherein the two or more paths are selected and merged based on a number of paths at a join point being identified.</claim-text></claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The system of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the two or ore paths are selected and merged to maintain a select subset of paths at the join point.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The system of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein each of the two or more selected paths comprise at least one VoI from the one or more identified VoI, wherein the at least one VoI comprise a variable interval in each of the two or more selected paths, and wherein the variable interval comprises an upper bound value and a lower bound value.</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The system of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the two or more paths of the plurality of paths comprised in the program code are selected and merged are based on the upper bound value and the lower bound value comprised in the variable interval.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The system of <claim-ref idref="CLM-00006">claim 6</claim-ref>; wherein the two or more paths of the plurality of paths are selected and merged based on one or more criteria, the one or more criteria being one of (i) the variable interval in the two or more paths are identical with each other, (ii) a union of the variable interval from the two or more paths forms a continual interval.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. One or more non-transitory machine-readable information storage mediums comprising one or more instructions which when executed by one or more hardware processors cause a method for selective path sensitive interval analysis by:<claim-text>obtaining, via one or more hardware processors, a program code comprising one or more program properties and a plurality of paths;</claim-text><claim-text>reading, via the one or more hardware processors, one or more variables in the one or more program properties to obtain one or more read variables, each of the one or more read variables correspond to a value;</claim-text><claim-text>computing, via the one or more hardware processors; one or more value impacting conditions (VICs) based the value being influenced in the one or more read variables;</claim-text><claim-text>identifying, via the one or more hardware processors, one or more variables of interest (VoIs) based on one of (i) one or more variables read by the one or more value impacting conditions (VICs) and have transitive data dependence on the one or more read variables in the one or more program properties, (ii) the one or more read variables in the one or more program properties, or (iii) one or more reset variables read in the one or more program properties, and wherein the one or more reset variables comprise a constant or a value defined via an external input; and</claim-text><claim-text>selecting and merging, via the one or more hardware processors, two or more paths of the plurality of paths comprised in the program code based on the one or more identified VoIs, wherein the two or more paths are selected and merged based on a number of paths at a join point being identified.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The one or more non-transitory machine-readable information storage mediums of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the two or more paths are selected and merged to maintain a select subset of paths at the join point.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The one or ore non-transitory machine-readable information storage mediums of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein each of the two or more selected paths comprise at least one VoI from the one or more identified VoI, wherein the at least one VoI comprise a variable interval in each of the two or more selected paths, and wherein the variable interval comprises an upper bound value and a lower bound value.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The one or more non-transitory machine-readable information storage mediums of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the step of selecting and merging two or more paths of the plurality of paths comprised in the program code is based on the upper bound value and the lower bound value comprised in the variable interval.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The one or more non-transitory machine-readable information storage mediums of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the step of selecting and merging two or more paths of the plurality of paths is based on one or more criteria, the one or more criteria being one of (i) the variable interval in the two or more paths are identical with each other, (ii) a union of the variable interval from the two or more paths forms a continual interval.</claim-text></claim></claims></us-patent-application>