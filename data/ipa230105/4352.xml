<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004353A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004353</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17943078</doc-number><date>20220912</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>7</main-group><subgroup>544</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>7</main-group><subgroup>483</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>7</main-group><subgroup>5443</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>7</main-group><subgroup>483</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">FLOATING POINT ACCUMULATER WITH A SINGLE LAYER OF SHIFTERS IN THE SIGNIFICAND FEEDBACK</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>17534376</doc-number><date>20211123</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11442696</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17943078</doc-number></document-id></child-doc></relation></continuation><continuation-in-part><relation><parent-doc><document-id><country>US</country><doc-number>17397241</doc-number><date>20210809</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11429349</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17534376</doc-number></document-id></child-doc></relation></continuation-in-part><us-provisional-application><document-id><country>US</country><doc-number>63190749</doc-number><date>20210519</date></document-id></us-provisional-application><us-provisional-application><document-id><country>US</country><doc-number>63174460</doc-number><date>20210413</date></document-id></us-provisional-application><us-provisional-application><document-id><country>US</country><doc-number>63166221</doc-number><date>20210325</date></document-id></us-provisional-application><us-provisional-application><document-id><country>US</country><doc-number>63165073</doc-number><date>20210323</date></document-id></us-provisional-application><us-provisional-application><document-id><country>US</country><doc-number>63239384</doc-number><date>20210831</date></document-id></us-provisional-application></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>SambaNova Systems, Inc.</orgname><address><city>Palo Alto</city><state>CA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Oklobdzija</last-name><first-name>Vojin G.</first-name><address><city>Berkeley</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Kim</last-name><first-name>Matthew M.</first-name><address><city>Frankston South</city><country>AU</country></address></addressbook></inventor></inventors></us-parties><assignees><assignee><addressbook><orgname>SambaNova Systems, Inc.</orgname><role>02</role><address><city>Palo Alto</city><state>CA</state><country>US</country></address></addressbook></assignee></assignees></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A floating-point accumulator circuit includes a floating-point input having an input significand field and a first shifter coupled to the input significand field and providing an output of the input significand field shifted by a first amount. A carry-save adder has a first, second, and third input and an output. The first input is coupled to the output of the first shifter and the output provides carry bits and sum bits representing a summation of the first input, the second input, and the third input as a significand of the accumulated value. Shifters are also coupled to the carry bits and the sum bits of the output of the carry-save adder to respectively provide the carry bits and the sum bits, both shifted by a second amount, to the second input and the third input of the carry-save adder.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="106.00mm" wi="158.75mm" file="US20230004353A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="130.05mm" wi="165.02mm" file="US20230004353A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="217.00mm" wi="142.49mm" file="US20230004353A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="178.65mm" wi="166.88mm" orientation="landscape" file="US20230004353A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="160.53mm" wi="151.30mm" file="US20230004353A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="180.76mm" wi="172.55mm" orientation="landscape" file="US20230004353A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="94.15mm" wi="81.45mm" orientation="landscape" file="US20230004353A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="227.50mm" wi="165.10mm" file="US20230004353A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="227.41mm" wi="180.00mm" orientation="landscape" file="US20230004353A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="189.99mm" wi="165.78mm" orientation="landscape" file="US20230004353A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="216.58mm" wi="133.94mm" orientation="landscape" file="US20230004353A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="225.72mm" wi="179.49mm" orientation="landscape" file="US20230004353A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="225.89mm" wi="178.48mm" orientation="landscape" file="US20230004353A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="212.01mm" wi="171.70mm" orientation="landscape" file="US20230004353A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00014" num="00014"><img id="EMI-D00014" he="221.74mm" wi="174.58mm" orientation="landscape" file="US20230004353A1-20230105-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00015" num="00015"><img id="EMI-D00015" he="227.92mm" wi="173.82mm" orientation="landscape" file="US20230004353A1-20230105-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00016" num="00016"><img id="EMI-D00016" he="212.01mm" wi="171.70mm" orientation="landscape" file="US20230004353A1-20230105-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00017" num="00017"><img id="EMI-D00017" he="226.06mm" wi="163.32mm" file="US20230004353A1-20230105-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00018" num="00018"><img id="EMI-D00018" he="215.14mm" wi="175.51mm" orientation="landscape" file="US20230004353A1-20230105-D00018.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00019" num="00019"><img id="EMI-D00019" he="207.60mm" wi="136.23mm" orientation="landscape" file="US20230004353A1-20230105-D00019.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00020" num="00020"><img id="EMI-D00020" he="222.93mm" wi="162.48mm" orientation="landscape" file="US20230004353A1-20230105-D00020.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00021" num="00021"><img id="EMI-D00021" he="211.24mm" wi="156.72mm" orientation="landscape" file="US20230004353A1-20230105-D00021.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00022" num="00022"><img id="EMI-D00022" he="202.86mm" wi="154.69mm" orientation="landscape" file="US20230004353A1-20230105-D00022.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00023" num="00023"><img id="EMI-D00023" he="197.27mm" wi="151.81mm" orientation="landscape" file="US20230004353A1-20230105-D00023.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00024" num="00024"><img id="EMI-D00024" he="226.65mm" wi="160.53mm" file="US20230004353A1-20230105-D00024.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00025" num="00025"><img id="EMI-D00025" he="229.79mm" wi="147.40mm" file="US20230004353A1-20230105-D00025.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00026" num="00026"><img id="EMI-D00026" he="187.62mm" wi="153.84mm" orientation="landscape" file="US20230004353A1-20230105-D00026.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00027" num="00027"><img id="EMI-D00027" he="211.50mm" wi="159.09mm" orientation="landscape" file="US20230004353A1-20230105-D00027.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00028" num="00028"><img id="EMI-D00028" he="226.40mm" wi="151.47mm" file="US20230004353A1-20230105-D00028.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00029" num="00029"><img id="EMI-D00029" he="217.42mm" wi="154.77mm" file="US20230004353A1-20230105-D00029.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00030" num="00030"><img id="EMI-D00030" he="223.01mm" wi="153.16mm" file="US20230004353A1-20230105-D00030.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00031" num="00031"><img id="EMI-D00031" he="212.60mm" wi="156.13mm" file="US20230004353A1-20230105-D00031.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00032" num="00032"><img id="EMI-D00032" he="215.56mm" wi="153.42mm" file="US20230004353A1-20230105-D00032.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">REFERENCE TO PRIORITY APPLICATIONS</heading><p id="p-0002" num="0001">This application is a continuation of co-pending U.S. patent application Ser. No. 17/534,376 (now U.S. Pat. No. 11,442,696) filed on Nov. 23, 2021, which is a continuation-in-part of co-pending U.S. patent application Ser. No. 17/397,241 (now U.S. Pat. No. 11,429,349) filed on 9 Aug. 2021, which application claims the benefit of U.S. Provisional Patent Application Nos. 63/190,749 filed 19 May 2021, No. 63/174,460 filed 13 Apr. 2021, No. 63/166,221 filed 25 Mar. 2021, and No. 63/165,073 filed 23 Mar. 2021, which applications are incorporated herein by reference; and benefit of U.S. Provisional Patent Application No. 62/239,384, filed 31 Aug. 2021 is also claimed, which application is incorporated herein by reference.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">FIELD OF THE DISCLOSURE</heading><p id="p-0003" num="0002">The field of the disclosure is implementation of arithmetic logic circuits, including floating point, multiply-add-accumulate circuits, also sometimes referred to as multiply and accumulate circuits, for high speed processors, including processors configured for efficient execution of training and inference.</p><heading id="h-0003" level="1">BACKGROUND OF THE DISCLOSURE</heading><p id="p-0004" num="0003">Arithmetic logic circuits, including floating point, multiply-and-accumulate units, as implemented in high performance processors, are relatively complicated logic circuits. Multiply-and-accumulate circuits are applied for matrix multiplication and other complex mathematical operations, applied in machine learning and inference engines.</p><p id="p-0005" num="0004">Basically, a multiply-and-accumulate circuit generates a summation S(i) of a sequence of terms A(i)*B(i), expressed typically as follows:</p><p id="p-0006" num="0000"><maths id="MATH-US-00001" num="00001"><math overflow="scroll"> <mrow>  <mi>Si</mi>  <mo>=</mo>  <mrow>   <munderover>    <mo>&#x2211;</mo>    <mrow>     <mi>i</mi>     <mo>=</mo>     <mn>0</mn>    </mrow>    <mrow>     <mi>N</mi>     <mo>-</mo>     <mn>1</mn>    </mrow>   </munderover>   <mtext> </mtext>   <mrow>    <mrow>     <mi>A</mi>     <mo>&#x2061;</mo>     <mo>(</mo>     <mi>i</mi>     <mo>)</mo>    </mrow>    <mo>&#x22c6;</mo>    <mrow>     <mi>B</mi>     <mo>&#x2061;</mo>     <mo>(</mo>     <mi>i</mi>     <mo>)</mo>    </mrow>   </mrow>  </mrow> </mrow></math></maths></p><p id="p-0007" num="0005">Here, the summation S(i) at cycle (i) is equal to the addition of term A(i)*B(i) to the summation S(i&#x2212;1) which is the accumulation of terms A(0)*B(0) to A(i&#x2212;1)*B(i&#x2212;1). The final summation S(N&#x2212;1) is a summation output of the multiply- and accumulate operation over N cycles, 0 to N&#x2212;1.</p><p id="p-0008" num="0006">In a floating point implementation, each cycle multiplies two input floating point operands, A(i) and B(i), including exponent values and significand values to produce multiplier output terms A(i)*B(i), and then computes an accumulator output summation S(i) by adding the multiplier output term A(i)*B(i), of a current cycle with the accumulator output summation S(i&#x2212;1) of the previous cycle.</p><p id="p-0009" num="0007">In floating point encoding formats used in computing to encode floating point numbers, the numbers can be normalized so that the significand includes a one digit integer (which in binary is always &#x201c;1&#x201d;) to the left of the binary point, and a fraction represented by a number of bits to the right of the binary point, and the number is encoded using only the fraction. The binary 1 integer is omitted in the encoding, because it can be implied by the normalized form. Operations on the floating point encoding format numbers, encoded in this manner, take into account the integer, referred to as an &#x201c;implied 1&#x201d;, to the left of the binary point.</p><p id="p-0010" num="0008">Multiplication of floating point numbers can be implemented by adding the exponents, multiplying the significands, and then normalizing the result, by shifting the resulting significand of the output and adjusting the exponent of the output to accommodate the shift.</p><p id="p-0011" num="0009">Addition of floating point numbers can be implemented by first identifying the larger exponent, and the difference between the exponents of the operands, and shifting the significand of the operand with the smallest exponent to align with the larger exponent. Finally, the result is normalized, which can involve an additional shift in the significand and adjustment of the exponent.</p><p id="p-0012" num="0010">Computations which result in numbers not supported by the formats, such as floating point encoding formats, result in signaling of exceptions. In data flow architectures, and other architectures executing complex algorithms such as machine learning algorithms, these exceptions can cause the algorithms to stall or fail. Exceptions in real time systems that cause algorithms to stall or fail can result in system failures or other problems in performance.</p><p id="p-0013" num="0011">It is desirable to provide systems for handling exceptions that can be applied in complex data processing settings.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0014" num="0012"><figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates encoding formats of a BFloat16 and the Floating-Point IEEE-754 standard.</p><p id="p-0015" num="0013"><figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates a high-level block diagram of the floating point multiply-add, accumulate unit with carry-save accumulator in BF16 and FP32 format.</p><p id="p-0016" num="0014"><figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates a hierarchical block diagram of a Multiplier circuit with two inputs, Operand-A and Operand-B.</p><p id="p-0017" num="0015"><figref idref="DRAWINGS">FIG. <b>4</b><i>a </i></figref>illustrates an example Multiplier &#x26; Adder block comprising an 8&#xd7;8 Multiplier Partial Product Reduction Tree.</p><p id="p-0018" num="0016"><figref idref="DRAWINGS">FIG. <b>4</b><i>b </i></figref>illustrates an example Exponent Unit with Special Exponent Detection block.</p><p id="p-0019" num="0017"><figref idref="DRAWINGS">FIG. <b>5</b>A</figref> illustrates a hierarchical block diagram showing a Base-8 Converter comprising an example Final Addition, Significand Selection and Base-8 Conversion block and an example Exponent Exception Processing block.</p><p id="p-0020" num="0018"><figref idref="DRAWINGS">FIG. <b>5</b>B</figref> illustrates an exemplary schematic representation of the final partial product addition, Significand Selection and Base-8 Conversion block.</p><p id="p-0021" num="0019"><figref idref="DRAWINGS">FIG. <b>5</b>C</figref> illustrates an exemplary schematic representation of an Exception Processing block.</p><p id="p-0022" num="0020"><figref idref="DRAWINGS">FIG. <b>6</b></figref> illustrates a high-level hierarchical block diagram of the Carry-Save Accumulation Unit.</p><p id="p-0023" num="0021"><figref idref="DRAWINGS">FIG. <b>7</b>A</figref> illustrates a high-level hierarchical block diagram of an Accumulator comprising two hierarchical blocks: Exponents Control Unit and the Significand Unit.</p><p id="p-0024" num="0022"><figref idref="DRAWINGS">FIG. <b>7</b>B</figref> illustrates an exemplary hierarchical block and schematic diagram of the Exponents Control Unit.</p><p id="p-0025" num="0023"><figref idref="DRAWINGS">FIG. <b>7</b>C</figref> illustrates an exemplary hierarchical block and schematic diagram of the Significand Unit.</p><p id="p-0026" num="0024"><figref idref="DRAWINGS">FIG. <b>8</b>A</figref> illustrates an exemplary hierarchical block showing the Normalization, Conversion to Sign Magnitude Format block comprising two sub-blocks, a first Conversion from Carry-Save To Sign Magnitude sub-block and a second Conversion from Radix-8 To Radix-2 Floating Point Number sub-block.</p><p id="p-0027" num="0025"><figref idref="DRAWINGS">FIG. <b>8</b>B</figref> illustrates an exemplary schematic diagram for the Conversion from Carry-Save To Sign Magnitude block.</p><p id="p-0028" num="0026"><figref idref="DRAWINGS">FIG. <b>8</b>C</figref> illustrates an exemplary schematic diagram for the Conversion from Radix-8 To Radix-2 Floating Point Number block.</p><p id="p-0029" num="0027"><figref idref="DRAWINGS">FIG. <b>9</b>A</figref> illustrates an exemplary hierarchical block showing Rounding and Conversion into BF16 or IEEE 754 32-Bit Single Precision Format sub-block and an exponent and exception handling sub-block.</p><p id="p-0030" num="0028"><figref idref="DRAWINGS">FIG. <b>9</b>B</figref> illustrates an exemplary schematic diagram showing the Rounding and Conversion into BF16 or IEEE 754 32-Bit SP Format block.</p><p id="p-0031" num="0029"><figref idref="DRAWINGS">FIG. <b>9</b>C</figref> illustrates an exemplary schematic diagram showing an Exponent and Exception Handling block.</p><p id="p-0032" num="0030"><figref idref="DRAWINGS">FIG. <b>10</b></figref> illustrates the floating point number range processed by the exception processing in carry-save accumulation unit for machine learning.</p><p id="p-0033" num="0031"><figref idref="DRAWINGS">FIG. <b>11</b></figref> shows a high level architecture block diagram depicting elements of exception processing in a carry-save accumulation unit for machine learning.</p><p id="p-0034" num="0032"><figref idref="DRAWINGS">FIG. <b>12</b>A</figref> illustrates a first operating mode high level block diagram architecture comprising Input-A in BF16 format, Input-B in BF16 format, and Input-C in FP32 format, where BF16 designates 16-bit Machine Learning Floating point encoding format known as &#x201c;B-float&#x201d;, or (Brain Floating Point) developed by Google, while FP32 designates 32-bit Single Precision IEEE 754 standard representation.</p><p id="p-0035" num="0033"><figref idref="DRAWINGS">FIG. <b>12</b>B</figref> illustrates a second operating mode high level block diagram architecture comprising Input-A in BF16 format, Input-B in BF16 format, and executing accumulation.</p><p id="p-0036" num="0034"><figref idref="DRAWINGS">FIG. <b>12</b>C</figref> illustrates a third operating mode high level block diagram architecture comprising Input-A in FP32 format and Input-C in FP32 format.</p><p id="p-0037" num="0035"><figref idref="DRAWINGS">FIG. <b>13</b></figref> illustrates a high level block diagram of the exception processing structure.</p><p id="p-0038" num="0036"><figref idref="DRAWINGS">FIG. <b>14</b>A</figref> depicts a multiplier overflow flag condition circuit.</p><p id="p-0039" num="0037"><figref idref="DRAWINGS">FIG. <b>14</b>B</figref> shows a multiplier underflow flag condition circuit.</p><p id="p-0040" num="0038"><figref idref="DRAWINGS">FIG. <b>15</b></figref> illustrates a multiplier invalid flag condition circuit.</p><p id="p-0041" num="0039"><figref idref="DRAWINGS">FIG. <b>16</b></figref> depicts a multiplier sign generation condition circuit.</p><p id="p-0042" num="0040"><figref idref="DRAWINGS">FIG. <b>17</b>A</figref> shows a multiplier exponent generation condition circuit.</p><p id="p-0043" num="0041"><figref idref="DRAWINGS">FIG. <b>17</b>B</figref> depicts a multiplier fraction generation condition circuit.</p><p id="p-0044" num="0042"><figref idref="DRAWINGS">FIG. <b>18</b>A</figref> illustrates an adder overflow flag condition circuit.</p><p id="p-0045" num="0043"><figref idref="DRAWINGS">FIG. <b>18</b>B</figref> shows an adder underflow flag condition circuit.</p><p id="p-0046" num="0044"><figref idref="DRAWINGS">FIG. <b>19</b>A</figref> shows an adder invalid flag condition circuit.</p><p id="p-0047" num="0045"><figref idref="DRAWINGS">FIG. <b>19</b>B</figref> depicts an adder sign positive condition circuit.</p><p id="p-0048" num="0046"><figref idref="DRAWINGS">FIG. <b>20</b>A</figref> depicts an adder sign negative circuit.</p><p id="p-0049" num="0047"><figref idref="DRAWINGS">FIG. <b>20</b>B</figref> illustrates an adder exponent generation all &#x201c;0&#x201d; condition circuit.</p><p id="p-0050" num="0048"><figref idref="DRAWINGS">FIG. <b>21</b>A</figref> illustrates an adder exponent generation all &#x201c;1&#x201d; condition circuit.</p><p id="p-0051" num="0049"><figref idref="DRAWINGS">FIG. <b>21</b>B</figref> shows an adder fraction generation condition circuit.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0005" level="1">DETAILED DESCRIPTION</heading><p id="p-0052" num="0050">A detailed description of a technology implementing an arithmetic unit for a configurable, and reconfigurable, data flow architecture with exception handling is provided. An example reconfigurable data flow architecture is described in U.S. Pat. No. 10,831,507, by Shah et al., issued Nov. 10, 2020, which is incorporated by reference as if fully set forth herein. The arithmetic unit can execute a plurality of floating point arithmetic operations using input operands and generating at least one output operand, where the source of the input operands, the destination of the output operand and the operation are configurable, and reconfigurable by configuration data that can be static during a data flow operation.</p><p id="p-0053" num="0051">In the execution of at least one of the floating point arithmetic operations, exceptions related to illegal operations and to generation of results not normally represented in the floating point encoding format utilized are detected, and results of the operation are set to values usable for further processing during the operation, without requiring special interrupt handling by, for example, a runtime processor. As a result, the data flow operation is able to complete without interruption due to as least some exceptions.</p><p id="p-0054" num="0052">In some embodiments, arithmetic operations and arithmetic units used on control flow architectures can implement exceptions processing technologies described herein.</p><p id="p-0055" num="0053">Floating Point Carry-Save MAC (FP-CS-MAC)</p><p id="p-0056" num="0054">A FP-CS-MAC is described which can be operated in three operation modes, such as:</p><p id="p-0057" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>Input-<i>A</i>(<i>BF</i>16)&#xd7;Input-<i>B</i>(<i>BF</i>16)+Accumulation Loop<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0058" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>Input-<i>A</i>(<i>BF</i>16)&#xd7;Input-<i>B</i>(<i>BF</i>16)+Input-<i>C</i>(<i>FP</i>32)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0059" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>or a single 32-bit floating point addition such as:<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0060" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>Input-<i>A</i>(<i>FP</i>32)+Input-<i>C</i>(<i>FP</i>32)<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0061" num="0000">Operand A can be in any format, while in this implementation it is in either of one of the two formats: BF16 or FP32, where BF16 is a format containing 8-bit exponent, 1-sign bit, 7-bit significand with 1 implied integer bit, for a total of 8 significand bits. FP32 is referred to as Single Precision 32-bit, IEEE Floating-Point 754 standard.</p><p id="p-0062" num="0055">Other encoding formats can be used, and appropriate adjustments of the implementations described can be made.</p><p id="p-0063" num="0056">A three-mode Floating point Carry-Save MAC (FP-CS-MAC) unit is described, comprising a circuit implemented as a pipeline, running in response to a pipeline clock. A pipeline clock in some implementations can be on the order of GHz or faster. As the pipeline clock runs, each period of the clock corresponds to a pipeline cycle. Accordingly, a pipeline cycle can be less than a nanosecond in some embodiments. In a pipeline, stages of the pipeline include input registers or data stores that hold stage input data at a first pipeline clock pulse (e.g., a leading edge of a clock pulse), and output registers or data stores that register stage output data of the stage at a next pipeline clock pulse (e.g., a leading edge of the next clock pulse, defining one pipeline clock period). At the time of the first pipeline clock pulse starting a pipeline cycle (i), the output registers of the stage hold the stage output data of the previous pipeline cycle (i&#x2212;1), and the stage output data of one stage in the pipeline are at least part of the stage input data of the next. The circuitry in each stage must settle reliably within the pipeline cycle, and so fast pipeline clocks impose significant difficulties for timing critical stages.</p><p id="p-0064" num="0057">One implementation of a three-mode Floating point Carry-Save MAC (FP-CS-MAC) unit comprises 6 pipeline stages. Further increases in speed are possible by increasing the number of pipeline stages. Further decrease in power is possible by reducing the number of pipeline stages. In general, the optimal number of pipeline stages depends on a particular technology and design requirements. A first main unit is the BF16 Multiplier which is implemented in two pipeline stages in this example and includes a conversion unit to convert the multiplier result into a 16-bit 2's complement significand and an exponent. The third pipeline stage is a Carry-Save Accumulate stage. The next two stages convert the result in carry-sum format back into regular normalized sign-magnitude format, such as BF16 or FP32 desired for the output encoding format.</p><p id="p-0065" num="0058">The last pipeline stage performs normalization and rounding to produce results. In this case, the final format is in BF16 or FP32 format. The input operand significands are between 1&#x2264;lal&#x3c;2 as they contain an implied 1 to the left of the decimal point, and include only the fraction part of the significand. The unit does not support denormalized numbers and truncates them to zero. Therefore, using BF16 or FP32, the range of the input operands is &#xb1;2-126 to (2&#x2212;2&#x2212;7)&#xd7;2127. Numbers outside this range truncate to zero if smaller than &#xb1;2-126 or convert to &#xb1;infinity if larger than &#xb1;(2&#x2212;2&#x2212;7)&#xd7;2127.</p><heading id="h-0006" level="2">Floating Point Encoding Formats</heading><p id="p-0066" num="0059"><figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates bit patterns for two encoding formats, A first exemplary diagram of the first bit format illustrates a Bfloat16 <b>110</b>. The Bfloat16 floating point encoding format (sometimes &#x201c;BF16&#x201d;) is a 16-bit numerical format. BF16 retains an approximate dynamic range of an IEEE single precision number. The illustrated BF16 format includes a 7-bit fraction, an &#x201c;implied bit&#x201d; or &#x201c;hidden bit&#x201d; to complete the significand, an 8-bit exponent, and one sign bit.</p><p id="p-0067" num="0060">A second diagram illustrates the IEEE 754 single-precision 32-bit floating point (FP32) <b>130</b> encoding format. The illustrated IEEE 754 single-precision 32-bit floating point <b>130</b> includes a 23-bit fraction, &#x201c;implied&#x201d; bit or &#x201c;hidden bit&#x201d; to complete the significand, an 8-bit exponent, and one sign bit. A characteristic of these two encoding formats is that the number in FP32 format can be converted to a BF16 format by dropping the 16 less significant bits of the 23-bit fraction, with rounding in some embodiments to select the lower order bit.</p><heading id="h-0007" level="2">System Block Diagram</heading><p id="p-0068" num="0061"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a high-level block diagram of a floating point multiply-add, accumulate unit with carry-save accumulator in BF16 and FP32 format. Operand-A <b>213</b> is illustrated as either a BF16 format or an FP32 format <b>217</b>. Operand-B <b>214</b> is a BF16 format and is a first input to the Multiplier circuit <b>202</b>. The second input is a BF16 Operand-A <b>213</b>. Operand-A and Operand-B can occupy a single 32-bit register, using 16-bits each, when both Operand-A and Operand-B are in BF16 format, representing multiplier and multiplicand inputs to the multiplier. The product (A*B) output of the Multiplier circuit <b>210</b> is produced in the Carry-Sum form on line <b>218</b>, which is the input to a Final Adder in block <b>220</b>. Block <b>220</b> also converts the result into 2's complement form, and a includes Radix-8 Converter circuit to support radix-8 operations.</p><p id="p-0069" num="0062">When the pipeline is operated in a single 32-bit addition, one operand, Operand-A can bypass the Multiplier circuit <b>202</b>, while the second operand C for the addition, comes from line <b>216</b>.</p><p id="p-0070" num="0063">Operand-C <b>216</b>, in this example, is a 32-bit operand, and it is input to a Radix-8 Converter <b>215</b> which outputs a result on line <b>219</b> to the first input of one of the Multiplexers <b>210</b> and <b>211</b>. The second inputs to the Multiplexers <b>210</b> &#x26; <b>211</b> are the two buses for the carry and sum values C/S-ACC on lines <b>224</b> and <b>226</b> (and exponents not shown) fed back from the output of Accumulator <b>240</b>. The Multiplexers <b>211</b> and <b>212</b> output the exponent and significand as two values to the bus <b>223</b>.</p><p id="p-0071" num="0064">A Carry-Save Adder <b>230</b> receives the output of block <b>220</b> on line <b>221</b>, and the output of the multiplexers <b>211</b>, <b>212</b> on bus <b>223</b>. The Carry-Save Adder <b>230</b> outputs the exponent and C/S values of the sum on twin bus <b>222</b> which enters the Accumulator <b>240</b>. The Accumulator <b>240</b> provides C/S-ACC exponents and significands in carry-save form on output buses <b>224</b> and <b>225</b> which feedback to the Multiplexer <b>211</b>, Multiplexer <b>212</b>, and provides the C/S-ACC exponents and significands in carry save form on and bus <b>226</b> to the Carry-Save to Sign-Magnitude Conversion block <b>250</b>, which performs a final add of the carry and sum values of the significand on bus <b>226</b>, and converts the resulting significand to sign-magnitude format on bus <b>227</b>. Buses <b>252</b> and <b>251</b> carry data from the Accumulator <b>240</b> to the Carry-Save to Sign-Magnitude Conversion block <b>250</b>.</p><p id="p-0072" num="0065">A Radix-8 to Radix-2 Conversion and Normalization block <b>260</b> has an input on bus <b>227</b> and outputs normalized results on bus <b>228</b> to the Post-Normalization, Rounding, and Conversion to FP32 or BF16 block <b>270</b> which converts the output into FP32 or BF16 format on bus <b>229</b>. The operations output the result &#x201c;Z&#x201d; on bus <b>229</b> in either 32-bit FP32 format or 16-bit BF16 format.</p><p id="p-0073" num="0066">Thus, <figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates an example of a circuit which can be implemented as a multistage pipeline configured to execute in three modes, including a multiply-and-accumulate operation for a sequence of input floating point operands. The circuit can be configured as a pipeline in this example including a first stage including a floating point multiplier with sum-and-carry outputs, a second stage including a multiplier output adder for the sum-and-carry outputs of the multiplier and circuits to convert the multiplier adder output to radix-8 format with a 2's complement significand, a third stage including a significand circuit and an exponent circuit of an accumulator adder, a fourth stage to convert the accumulator sign bit, an accumulator exponent and accumulator significand sum-and-carry values to a sign-magnitude significand format, a fifth stage to convert the sign-magnitude significand format from radix-8 alignment to radix-2 alignment, and produce a normalized exponent and significand, and a sixth stage to perform rounding and conversion to a standard floating point representation.</p><p id="p-0074" num="0067">The technology described herein provides a multiply-and-accumulate method to calculate a summation S(i) of terms A(i)*B(i), where (i) goes from 0 to N&#x2212;1, and N is the number of terms in the summation. The method can comprise receiving a sequence of operands A(i) and operands B(i) in floating point encoding format, for (i) going from 0 to N&#x2212;1; multiplying operand A(i) and operand B(i) to generate term A(i)*B(i) in a format including a multiplier output exponent and a multiplier output significand, and converting the multiplier output significand to a 2's complement format; using a carry-save adder to add the 2's complement format significand of term A(i)*B(i) to a significand of summation S(i&#x2212;1), and generate sum-and-carry values for summation S(i); selecting an exponent of summation S(i) from the multiplier output exponent of A(i)*B(i) and the exponent of summation S(i&#x2212;1), to generate exponent of summation S(i); and converting the sum-and-carry values and the exponent of summation S(i) to a normalized floating point encoding format.</p><p id="p-0075" num="0068">Also, the method can include providing the multiplier output exponent and multiplier output significand of term A(i)*B(i) in a radix-8 format, and generating the sum-and-carry values and the exponent of summation S(i) in radix-8 format before converting to the normalized floating point encoding format, which can be radix-2.</p><p id="p-0076" num="0069">The alignment required in the accumulate addition stage depends on a number of conditions, including summation S(i&#x2212;1) significand overflow, summation S(i&#x2212;1) sign extensions and difference between the exponents of the addends: term A(i)*B(i) and summation S(i&#x2212;1). These conditions can be determined and combined for use for alignment in a same pipeline cycle (e.g., the third stage in the six stage example), enabling fast execution and faster pipeline clocks. In an embodiment provided herein, the unit executes a method to calculate a summation S(i) of terms A(i)*B(i), where (i) goes from 0 to N&#x2212;1, and N is the number of terms in the summation, the method comprising:<ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0070">receiving a sequence of operands A(i) and operands B(i) in floating point encoding format, for (i) going from 0 to N&#x2212;1;</li>        <li id="ul0002-0002" num="0071">multiplying operand A(i) and operand B(i) to generate term A(i)*B(i) during a first pipeline cycle in a format including a multiplier output exponent of term A(i)*B(i) and a multiplier output significand of term A(i)*B(i), and comparing during the first pipeline cycle the multiplier output exponent of term A(i)*B(i) to an accumulator output exponent of summation S(i&#x2212;1) to generate comparison signals for summation S(i);</li>        <li id="ul0002-0003" num="0072">adding the term A(i)*B(i) to the summation S(i&#x2212;1) to generate a summation S(i) during a next pipeline cycle in a format including an accumulator output exponent of summation S(i) and an accumulator output significand of summation S(i), wherein said adding includes</li>        <li id="ul0002-0004" num="0073">determining the accumulator output exponent for summation S(i) and shifting one or both of the accumulator output significand of summation S(i&#x2212;1) and the multiplier output significand of term A(i)*B(i) as a consequence of said comparison signals for summation S(i).</li>    </ul>    </li></ul></p><p id="p-0077" num="0074">Executing the step of comparing during the first pipeline cycle the multiplier output exponent of term A(i)*B(i) to an accumulator output exponent of summation S(i&#x2212;1) to generate comparison signals for summation S(i), while executing the adjustments to the operands in a next pipeline cycle (early exponent compare) enables use of a pipeline having an accumulator stage with a shorter critical timing path and operable at higher clock speeds.</p><heading id="h-0008" level="2">Floating Point Multiplier</heading><p id="p-0078" num="0075">The Floating point Multiplier includes exponent circuits and significand circuits. The Exponent part performs addition of operand exponents, while the significand part performs binary multiplication of the operand significands. The operands entering the multiplier are &#x201c;normalized&#x201d; floating point numbers, where the first bit is 1. Therefore, the operand significand (m) is between 1&#x2264;m&#x3c;2, meaning it is greater or equal to 1, and less than 2. As such, the product of the two operand significands is in the range of is 1&#x2264;p&#x3c;4 and can never be equal to or greater than 4.</p><p id="p-0079" num="0076">If the product p, which is the result of the significand multiplication, is in a range of 2&#x2264;p&#x3c;4, the exponent will be incremented, and the significand shifted one binary position to the right for normalization.</p><p id="p-0080" num="0077">The first pipeline stage performs addition of exponents and multiplication of operand significands using an 8&#xd7;8-bit integer multiplier including carry-save adders for the partial products. The result from the multiplier array, after summing all the partial products using the carry-save adders, can include two parts: 8-bits of Sum and 9-bits of Carry from carry-save adders for the partial products in the most significant portion of the multiplier array, and an 8-bit product from the least significant portion of the multiplier array. Partial products for the 8-bits in the least significant portion are added together in this example using a ripple-carry adder, as the bits arrive from the partial product reduction tree. This summation can be done using a Ripple-Carry Adder, because the time arrival profile from the least significant portion of the multiplier is such that bits arriving in time from the Least Significant Bit (LSB) to the Most Significant Bit (MSB), of that portion, make a ripple-carry adder adequate. Applying a Ripple-Carry Adder (RCA), reduces the complexity of the multiplier significantly (<figref idref="DRAWINGS">FIG. <b>4</b><i>a</i></figref>).</p><p id="p-0081" num="0078">This stage includes a multiplier circuit to provide multiplier significand and multiplier exponent values prior to the pipeline clock in response to first and second input operands which are registered on the pipeline clock. The multiplier circuit includes a significand multiplier circuit and an exponent adder circuit, the significand multiplier circuit having a carry-save adder for partial products used to generate carry-and-sum values to generate higher order bits of the multiplier output significand and a ripple-carry adder for partial products used to generate lower order bits of the significand carry-and-sum outputs. Also, the multiplier circuit includes a radix-8 conversion circuit to convert the multiplier significand and multiplier exponent values to radix-8 format for the multiplier output exponent and significand; and a 2's complement conversion circuit to convert the multiplier significand value to a 2's complement representation for the multiplier output significand.</p><p id="p-0082" num="0079">The exponents are added separately. Both exponents are positive numbers larger than zero. When the addition result is a number greater than 256, an indication is the carry-out signal from the exponent adder. If the resulting exponent is equal to 255, the positive infinity indication is asserted. If the exponent equals zero, the significand is set to zero, according to the IEEE 754 standard rules. In this implementation, if the exponent of the product is 0, the significand of the result is forced 0, thus representing +/&#x2212; zero floating point number (<figref idref="DRAWINGS">FIG. <b>4</b><i>b</i></figref>). In other embodiments, sub-normal numbers may be treated differently.</p><p id="p-0083" num="0080">The exponent addition requires subtracting 127 from the result, since both operands contain a 127 bias in the BF16 and FP32 encoding formats. The conversion process is made faster by adding 129 to the result, which is achieved by inverting the MSB of the exponent of one of the inputs and introducing <b>1</b> into the carry input of the adder. This greatly simplifies the circuit and can reduce time required for the pipeline stage (<figref idref="DRAWINGS">FIG. <b>4</b><i>b</i></figref>).</p><p id="p-0084" num="0081">We prove the correctness of this procedure in the following way: the addition results in two biases of 127 being added, making bias to be 254. However, since the carry-out of the adder, which amounts to 256, is ignored, the resulting bias will be &#x2212;2. We can make up to 127 by adding 129 to the result of the operation. This is achieved by inverting the MSB of an operand, which in the case of a negative operand is equivalent to adding 128, as the MSB position contains zero. In the case of a positive operand, where MSB is equal to one, this is also equivalent to adding 128. An additional 1 at the carry input makes the result to be biased by: &#x2212;2+129, which is equal to the required 127 bias.</p><p id="p-0085" num="0082">The same pipeline stage converts the result into a radix-8 number which contains a 5-bit exponent, and a significand appropriately shifted 7 positions to the right. Conversion to a 5-bit exponent requires a shift left from the 7th position, for the amount represented by the value of the remaining 3 exponent bits. This requires the significand to be passed through a left shifter which will shift the significand from 0 to 7 bit positions to the left as required by the 3-LSB bits of the 8-bit exponent. (<figref idref="DRAWINGS">FIG. <b>5</b><i>b</i></figref>)</p><p id="p-0086" num="0083">A multiplier saves compute time by recognizing that the signal arrival profile originating from a Partial Product Reduction Tree (PPRT) is uneven. The LSB bit arrives first, followed by the next one and so on for the first 8 least significant bits (LSB) of the PPRT. Because of the unequal arrival profile, the addition of the LSB portion can be masked (&#x201c;hidden&#x201d;) under the delay of the multiplier array, thus providing savings (in terms of time) for a pipeline stage (e.g. the second pipeline stage in the example outlined above. Summing the LSB portion uses an 8-bit Ripple-Carry Adder (RCA) to reduce the size of the Carry-Propagate Adder (CPA) using carry-save adders for the partial products from 17 to 9 bits. The MSB portion used in a next pipeline stage, includes a final adder which is only 9 bits long. The significand of the product is formed in a pipeline stage by adding the most significant 9 bits from the final adder and augmenting it with the least significant 8 bits previously formed in using the ripple-carry adder of the preceding pipeline stage (<figref idref="DRAWINGS">FIG. <b>4</b><i>a</i></figref>).</p><p id="p-0087" num="0084"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a simplified block diagram <b>300</b> of a Multiplier circuit <b>202</b> with two inputs, Operand-A on line <b>213</b>, and Operand-B on line <b>214</b>. The Multiplier circuit <b>202</b> comprises two blocks, Multiplier &#x26; Adder block <b>210</b><i>a </i>and the Exponents block <b>210</b><i>b. </i></p><p id="p-0088" num="0085"><figref idref="DRAWINGS">FIG. <b>4</b><i>a </i></figref>illustrates an example of a Multiplier &#x26; Adder block <b>210</b><i>a</i>, showing an 8&#xd7;8 Multiplier Partial Product Reduction Tree with carry-save adders for partial products of the more significant bits without a Final 16-Bit Adder (provided in the next stage) with a 7-LSB Ripple-Carry Adder block for partial product additions of the less significant bits. Operand-A <b>213</b> is stored in a register <b>420</b> comprising three fields: Sa, Ea and Fa. Sa is the sign bit. Ea is the eight exponent bits and Fa is the fraction part of the significand. The Fa field is applied on line <b>422</b> to a first input to the 8&#xd7;8 BF16 Multiplier circuit <b>410</b>. Operand-B <b>214</b> is stored in a register <b>421</b> comprising three fields: Sb, Eb and Fb. Sb is the sign bit. Eb is the eight exponent bits and Fb is the fraction part of the significand. The Fb field is applied on line <b>423</b> to a second input to the 8&#xd7;8 BF16 Multiplier circuit <b>410</b>. The input to the Multiplier circuit <b>410</b> on line <b>440</b> is a forced zero bit, which, when zero, forces 8&#xd7;8 BF16 Multiplier circuit to produce zero output.</p><p id="p-0089" num="0086">The 8&#xd7;8 BF16 Multiplier circuit <b>410</b> outputs two 7-bit LSB buses, <b>428</b> and <b>429</b>, which are the inputs to a 7-bit Ripple-Carry Adder <b>430</b>. Also, the 8&#xd7;8 BF16 Multiplier circuit <b>410</b> outputs eight sum bits S<b>8</b> <b>426</b>, and nine carry bits C<b>9</b> <b>427</b>. The 7-bit Ripple-Carry Adder <b>430</b> outputs 7 bits on line <b>424</b> and a carry-out bit COUT on line <b>425</b> into register <b>450</b>. The register <b>450</b> has the following mapping: line <b>424</b> maps to PL [6:0], COUT on line <b>425</b> to C<b>7</b>, S<b>8</b> on line <b>426</b> to Sp [14:7] and C<b>9</b> on line <b>427</b> to Cp [14:6].</p><p id="p-0090" num="0087"><figref idref="DRAWINGS">FIG. <b>4</b><i>b </i></figref>illustrates an example Exponent Unit (e.g. <b>210</b><i>b </i>of <figref idref="DRAWINGS">FIG. <b>3</b></figref>) with Special Exponent Detection block <b>467</b>. Operand-A <b>213</b> is in register <b>420</b> as in <figref idref="DRAWINGS">FIGS. <b>4</b><i>a</i></figref>, and Operand-B is in register <b>421</b> as in <figref idref="DRAWINGS">FIG. <b>4</b><i>a</i></figref>. Ea on line <b>465</b> is one input to a Special Exponent Detection Block and to the Exponents Adder circuit <b>464</b>. Eb on line <b>462</b> is a second input to a Special Exponent Detection Block. The seven least significant bits of Eb on line <b>462</b> are input to the Exponents Adder circuit <b>464</b> and the 8th-bit is inverted by inverter <b>461</b> before entering the Exponents Adder circuit <b>464</b> in the 8th-bit position. A carry in value is set to &#x201c;1&#x201d; for the Exponents Adder circuit <b>464</b>.</p><p id="p-0091" num="0088">The Exponents Adder circuit <b>464</b> operates on Ea <b>465</b> and Eb <b>462</b>, adding them together and subtracting the bias value of 127. The output is a 10-bit value <b>466</b> to register <b>470</b>. Two extra bits, beyond the necessary 8 bits for encoding the exponent, are carried to detect an exponent overflow situation. Those 10 bits are further examined in the Exponent Exception Processing circuit <b>524</b>, shown in <figref idref="DRAWINGS">FIG. <b>5</b>C</figref>.</p><p id="p-0092" num="0089">The input exponent signals are examined in the Special Exponent Detection block <b>467</b> for being Zero as indicated by a signal on line <b>468</b>, or Invalid as indicated by a signal on line <b>469</b>. Sign bits Sa and Sb from registers <b>420</b> and <b>421</b> are input to an XNOR gate <b>471</b><i>a</i>, the output of which is applied to XNOR gate <b>471</b><i>b</i>. Also, the Invalid signal on line <b>469</b> is input to XNOR gate <b>471</b><i>c</i>. If the Invalid signal is zero, the resulting sign is an XOR function of Sa and Sb. If the Invalid is true (equal &#x201c;F&#x201d;) the product sign Sp is set to &#x201c;zero&#x201d;, as specified in the encoding standard.</p><heading id="h-0009" level="2">Base-8 Conversion</heading><p id="p-0093" num="0090"><figref idref="DRAWINGS">FIG. <b>5</b>A</figref> is a simplified diagram showing a Radix-8 Converter block <b>592</b> (e.g. block <b>220</b> of <figref idref="DRAWINGS">FIG. <b>2</b></figref>). The Radix-8 Converter block <b>592</b> comprises two sub-blocks, in this example, the Final Addition, Significand Selection and Radix-8 Conversion sub-block <b>592</b><i>a </i>and Exponent Exception Processing sub-block <b>592</b><i>b. </i></p><heading id="h-0010" level="2">Conversion to Radix-8, 2's Complement Significand</heading><p id="p-0094" num="0091">External input Operand-A is converted to a Radix-8 encoding in the second pipeline stage. The operand-A significand is converted into a 2s complement significand. The significand is extended to 34 bits, including two significand sign bits. The resulting pipeline register <b>520</b>, shown in <figref idref="DRAWINGS">FIG. <b>5</b><i>b</i></figref>, comprises a 5-bit exponent, a 34-bit significand, and two additional status bits for a total of 41 bits.</p><p id="p-0095" num="0092">Conversion to Radix-8 is implemented using the last 3 bits of the exponents to align the 24-bit Operand significand from register <b>450</b> of <figref idref="DRAWINGS">FIG. <b>4</b><i>a</i></figref>, into a 32-bit radix-8 significand, where the LSB of the significand aligns with the LSB of the 32-bit significand, if the 3-LSB of the exponent are equal to zero (i.e., shifted 8 positions to the right from the binary point). Any value represented by the 3-LSB of the exponent is the amount for which the significand shifts to the left (from the 8th bit position), to compensate for those bits truncated from the exponent. The rest of the bits up to the binary point, and two bits beyond, are filled with sign extension bits. In the case where all three exponent LSB s are b&#x2032; <b>1</b>, i.e., equal to decimal <b>7</b>, the first significant bit of the 32-bit significand will be a non-zero bit, i.e., normalizes the significand. Since the significand is represented as 2's complement, two extra bits to the left of the significand point will be used to store sign bits (including an extended sign bit). An additional second sign bit is used, instead of one, in order to preserve the sign because of a possible overflow situation which results in a 2-bit integer overwriting the lower sign bit (<figref idref="DRAWINGS">FIG. <b>5</b><i>b</i></figref>).</p><p id="p-0096" num="0093">Depending on the sign of the product, the significand is either passed through, or it is inverted, to create 2's complement negative representation of the significand. This implementation differs from IEEE 754 where a significand can be positive or negative. This operation is performed by adding a sign bit to the 24-bit significand and inverting the bits if the sign is equal to 1 (negative).</p><p id="p-0097" num="0094">The exponent is checked for values between &#x2212;126 to 126. If greater than 126, it is treated as infinity, or if less than &#x2212;126 it is a denormalized number (less than &#x2212;126) and converts to zero (<figref idref="DRAWINGS">FIG. <b>5</b><i>c</i></figref>).</p><p id="p-0098" num="0095">In some implementations, a final register of this stage of the pipeline contains a normalized floating point product with 5-bit exponent and 34-bit 2's complement significand, (containing duplicate sign of the product, and without the implied 1) and three exponent status bits.</p><p id="p-0099" num="0096"><figref idref="DRAWINGS">FIG. <b>5</b>B</figref> illustrates an exemplary schematic representation of the final partial product addition, Significand Selection and Radix-8 Conversion sub-block <b>592</b><i>a</i>. Register <b>450</b> (<figref idref="DRAWINGS">FIG. <b>4</b><i>a</i></figref>) comprises fields for PL [6:0], C<b>7</b>, Sp [14:7], and Cp[14:6]. Register <b>470</b> (<figref idref="DRAWINGS">FIG. <b>4</b><i>b</i></figref>) comprises fields for the 10-bit Product Exponent (Ep) value. Register <b>504</b> includes a status bit.</p><p id="p-0100" num="0097">In the case the pipeline is operated in the FP32 addition mode, Operand-A is in FP32 format and it bypasses the multiplier. In this case Operand-A originates from the register <b>460</b>, occupying two combined 16-bit registers, <b>420</b> and <b>421</b>. An add_op control signal on line <b>511</b> indicates when the pipeline mode is set for Addition (Single Precision Floating point in this example) or Accumulation.</p><p id="p-0101" num="0098">A Significand Final Adder circuit <b>502</b> receives as input Sp[14:7] on line <b>503</b>, Cp[14:6] on line <b>501</b> and the carry bit C<b>7</b> on line <b>507</b>, outputting an Overflow signal <b>519</b> to the Overflow Selection circuit <b>506</b>. The Overflow Selection circuit <b>506</b> has input bus <b>523</b> which is a combination of PL[6:0] on line <b>509</b> and the Significand Final Adder circuit <b>502</b> output on line <b>521</b>. A NOR gate <b>522</b> has the inputs Exponent Overflow bit on line <b>525</b> and Zero force bit on line <b>468</b> and outputs the signal on line <b>527</b>. The signal on line <b>527</b> and the bus <b>529</b> output by the overflow selection circuit <b>506</b>, route into an AND gate <b>544</b>, which sets the Significand to all zeroes in case of an exponent overflow, as well as in case the Significand is forced to zero. Further, the Significand Selection circuit <b>512</b> chooses between the bypass significand Fa [22:0] on bus <b>515</b> or the AND gate <b>544</b> output on bus <b>553</b> using the add_op control signal on line <b>511</b>.</p><p id="p-0102" num="0099">An Exponent Selection circuit <b>510</b> chooses between the 8 exponents bits, Ep [7:0] on line <b>517</b> or the bypass exponent bits Ea[30:23] bits on line <b>513</b> and outputs the selected exponent on line <b>533</b> to the E_mult field of register <b>520</b>. A sign bit selection circuit <b>508</b> receives the Sp sign bit (<figref idref="DRAWINGS">FIG. <b>4</b><i>b</i></figref>) and the bypass sign bit Sa on line <b>473</b>, as inputs, and outputs a sign bit <b>531</b> to the S_mult field in register <b>520</b>.</p><p id="p-0103" num="0100">The add_op control signal on line <b>511</b> routes to the Significand Selection circuit <b>512</b>, the Exponent Selection circuit <b>510</b>, and the Sign bit selection circuit <b>508</b> for their control inputs.</p><p id="p-0104" num="0101">Output from the Significand Selection circuit <b>512</b>, enters 8-bit Left Shifter circuit <b>514</b>. The lower three bits [2:0] of the line <b>533</b> from the Exponent Selection circuit <b>510</b> output on line <b>533</b> control the 8-bit Left Shifter circuit <b>514</b>. The 8-bit Left Shifter circuit <b>514</b> output bus <b>537</b> feeds into multiplexer circuit <b>518</b> which chooses between input on line <b>537</b> (in case the significand is positive) and line <b>539</b> (in case the significand is negative). This is selected by the sign bit <b>531</b>. 2's compliment Invert+1 circuit <b>516</b> creates 2's complement of the shifter output on line <b>537</b> and outputs the complemented values on line <b>539</b>. The output of the Multiplexer circuit <b>518</b> on line <b>541</b> enters the pipeline register <b>520</b> in a 34-bit F_mult significand. This process converts the selected significand into 2's complement represented significand which is 32 bits long with 2 sign bits, stored in the pipeline register <b>520</b>.</p><p id="p-0105" num="0102"><figref idref="DRAWINGS">FIG. <b>5</b>C</figref> illustrates a block diagram of Exponent Exception Processing sub-block <b>592</b><i>b</i>. A Significand Final Adder circuit <b>502</b> receives the inputs Sp[14:7] <b>503</b>, Cp[14:6] <b>501</b> and the carry bit C<b>7</b> <b>507</b> from register <b>450</b> as described with reference to <figref idref="DRAWINGS">FIG. <b>5</b><i>b</i></figref>. Overflow output of the Significand Final Adder circuit <b>502</b> is connected to the Exponent Exception Processing circuit <b>524</b>. Upon detection of overflow conditions, the Significand Final Adder circuit <b>502</b> asserts the Overflow signal <b>519</b> as a first input to the Exponent Exception Processing circuit <b>524</b>. A second input to the Exponent Exception Processing circuit <b>524</b> is the exponent bits Ep [9:0] (sum of input operand exponents) from register <b>470</b> on bus <b>517</b>. A third input is the Exponent Overflow Detection circuit <b>522</b> output signal on line <b>523</b>. The output of the Exponent Exception Processing circuit <b>524</b> is then input on line <b>549</b> to the Exponent Exception Detection circuit <b>526</b>, and the exponent selection circuit <b>510</b> (described with reference to <figref idref="DRAWINGS">FIG. <b>5</b><i>b</i></figref>).</p><p id="p-0106" num="0103">The exponent bits Ep [9:0] on a bus <b>517</b> are input to the Exponent Overflow Detection circuit <b>522</b> which detects the overflow conditions:</p><p id="p-0107" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>exp_<i>ovf=Ec</i>[8]: meaning that if bit 8 is one, there is overflow on exponent detected,<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0108" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>exp_povf=&#x2dc;<i>Ec</i>[9]&#x26; <i>Ec</i>[8]: If bit 9 is zero and bit 8 is one; Positive Overflow,<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0109" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>exp_novf=<i>Ec</i>[9]&#x26; <i>Ec</i>[8]: If both bit 9 and bit 8 <i>are </i>one; Negative Overflow.<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0110" num="0000">The first output on line <b>523</b> of circuit <b>522</b> routes to the Exponent Exception Processing circuit <b>524</b>, a second output on line <b>543</b> routes to the Output Exception Control Signal Generation circuit <b>528</b>, and a third output includes the Exponent Overflow bit on line <b>525</b> to the gate <b>522</b> in <figref idref="DRAWINGS">FIG. <b>5</b>B</figref>.</p><p id="p-0111" num="0104">The Exponent Exception Detection circuit <b>526</b> outputs, for example via bus <b>547</b>, an exception to register <b>532</b> including the following three bits: of (overflow); of (underflow); and nv (not valid).</p><p id="p-0112" num="0000">This occurs on the detection of the following conditions:</p><p id="p-0113" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>of (Overflow)&#x2014;Meaning if <i>Ec </i>is 11111111, and no Infinity is detected, it is interpreted as Overflow.<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0114" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>of (Underflow)&#x2212;Meaning if <i>Ec </i>is 00000000 and Zero (Significand) is not signaled, it is Underflow situation.<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0115" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?><i>nv</i>(Invalid) &#x2018;1&#x2019;&#x2212;Meaning result is Invalid.<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0116" num="0105">The Output Exception Control Signal Generation circuit <b>528</b> has four inputs. The first input is the add_op control signal on line <b>511</b> which indicates the accumulate or bypass add mode, the second input is the status bit on line <b>509</b> (infinity, zero, or invalid), the third input on line <b>545</b> routes from the Exponent Selection circuit <b>510</b> which multiplexes between the Ea[30:23] bits of register <b>460</b> or the output of the Exponent Exception Processing circuit <b>524</b>, and the fourth input is from a second output on line <b>543</b> of the Exponent Overflow Detection circuit <b>522</b>. The Output Exception Control Signal Generation circuit <b>528</b> outputs five bits on line <b>551</b> representing exp_mul_zero, exp_mul_inf, exp_zero_en, exp_inf_en, and f_zero_en, which are stored into the register <b>530</b>.<ul id="ul0003" list-style="none">    <li id="ul0003-0001" num="0000">    <ul id="ul0004" list-style="none">        <li id="ul0004-0001" num="0106">exp_mul_zero meaning: Multiplier Product Exponent is Zero,</li>        <li id="ul0004-0002" num="0107">exp_mul_inf meaning: Multiplier Product Exponent is Infinity</li>        <li id="ul0004-0003" num="0108">exp_zero_en meaning: Enabled when (one of the multiplier input Exponent is Zero, and both of the multiplier input Exponents are not Zero), or Multiplier product Exponent has negative overflow,</li>        <li id="ul0004-0004" num="0109">exp_inf_en meaning: Enabled when one of the multiplier input</li>        <li id="ul0004-0005" num="0110">Exponent is Infinity, or Multiplier product Exponent has positive overflow</li>        <li id="ul0004-0006" num="0111">f_zero_en meaning: Enabled when exp_zero_en signal is Enabled or</li>        <li id="ul0004-0007" num="0112">Multiplier product Exponent has overflow (Positive or Negative) or when the Multiplier product Exponent is Zero.</li>    </ul>    </li></ul></p><heading id="h-0011" level="2">Carry-Save Accumulation Unit</heading><p id="p-0117" num="0113"><figref idref="DRAWINGS">FIG. <b>6</b></figref> illustrates a block diagram <b>600</b> of a Carry-Save Accumulator (e.g. <b>240</b> of <figref idref="DRAWINGS">FIG. <b>2</b></figref>) for the significands. A Radix-8 Converter <b>215</b> receives Operand-C as an input and outputs operand C in Radix-8 format on line <b>219</b> to the Multiplexer <b>210</b> and Multiplexer <b>211</b>. Two additional inputs to the Multiplexers <b>210</b> &#x26; <b>211</b> are the buses <b>224</b> &#x26; <b>225</b> fed back from the accumulator Sum register <b>242</b> and accumulator Carry register <b>241</b>. The outputs of the Multiplexer <b>210</b> and Multiplexer <b>211</b> route to the shifter circuits <b>609</b> &#x26; <b>610</b> which execute a shifting right 8/16/24 bits or shifting left 8 bits. The outputs of shifter circuits <b>609</b> &#x26; <b>610</b> route to the Carry-save Adder circuit (CSA) <b>614</b>. The Carry-save Adder circuit <b>614</b> has a third input from the shift right circuits for 8/16/24 circuit <b>608</b> whose input is either the product of a A*B (BF16) or the A (FP32) operand alone, <b>602</b>. The outputs of the Carry-save Adder circuit <b>614</b> on lines <b>667</b> and <b>669</b> route to a LZA circuit <b>606</b> which provides an output to an S-bit register <b>636</b>, and to Overflow Detection block <b>605</b> which provides an output to the 0-bit register <b>634</b>.</p><p id="p-0118" num="0114">The carry-save accumulation unit includes a significand circuit receiving at a first pipeline clock for cycle (i) a multiplier output significand of term A(i)*B(i) and feedback sum-and-carry values of a previous accumulator output representing summation value S(i&#x2212;1). The significand circuit includes a 2's complement, carry-save adder, to generate sum-and-carry accumulator output significand values for summation S(i) on a second pipeline clock. The carry-save accumulation unit includes an exponent circuit receiving, at the first pipeline clock, a multiplier output exponent of term A(i)*B(i), and a fed back exponent value of a previous accumulator output representing summation value S(i&#x2212;1), to generate an accumulator output exponent value on the second pipeline clock for summation value S(i). The significand circuit includes a significand shifter, responsive to exponent comparison signals, stored at the first pipeline clock, to align the multiplier output significand and the feedback sum-and-carry values for addition. The exponent circuit is responsive to the exponent comparison signals, stored at the first pipeline clock, to generate the accumulator output exponent value. The pipeline includes exponent comparison circuits to compare, prior to the first pipeline clock, the multiplier output exponent of term A(i)*B(i) to the fed back exponent value of summation S(i&#x2212;1), to generate the exponent comparison signals stored at the first pipeline clock.</p><p id="p-0119" num="0115">The carry-save accumulation unit in this embodiment includes an overflow detector circuit to generate a first condition signal indicating an overflow condition for at least one of the fed back sum-and-carry values at the first pipeline clock, and a leading sign bit detector circuit to generate a second condition signal indicating that at least one of the fed back sum-and-carry values has more than, or equal to, a number <b>8</b> of extended sign bits at the first pipeline clock. The exponent circuit and significand circuit are also responsive to the first condition signal and the second condition signal. The overflow and leading sign bit adjustments and exponent comparison adjustments are combined for implementation by shifters in a same pipeline cycle, as described with reference to Table 1: CSA Unit Control below.</p><p id="p-0120" num="0116">Also, this stage of the pipeline has an accumulator mode and a summing mode, and includes a selector to provide the fed back accumulator output in the accumulator mode, and to provide a third floating point input operand in the summing mode to the significand circuit and exponent circuit. The significand circuit can include a significand shifter, responsive to exponent comparison signals stored at the first pipeline clock, to align in the accumulator mode the multiplier output significand and the fed back sum-and-carry values for addition, and to align in the summing mode the multiplier output significand and a significand of the third input operand for addition. The exponent circuit is responsive to the exponent comparison signals stored at the first pipeline clock, to generate the accumulator output exponent value. The pipeline includes exponent comparison circuits to compare, prior to the first pipeline clock, the multiplier output exponent to the fed back exponent value in the accumulator mode, and to compare the multiplier output exponent to an exponent of the third input operand in the summing mode, to generate the exponent comparison signals stored at the first pipeline clock.</p><heading id="h-0012" level="2">Significand Circuit:</heading><p id="p-0121" num="0117">There are two paths in the Carry-Save Adder (CSA) significand stage: The Accumulator path where the operand from the accumulator can shift to the right for 8, 16 or 24 bits and can shift to the left for 8 bits, and the Multiplier path where the operand from the multiplier can shift to the right for 8, 16 or 24 bits. Shifting right for 8, 16 or 24 bits corresponds to the exponent difference of 1, 2 or 3, between the operands, when using a radix-8 exponent. Shifting Left for 8-bits is done when the carry-save adder outputs a number in which sign extension exceeds 8-bits.</p><p id="p-0122" num="0118">If the difference between operand exponents is greater than 3, that means that one of the operands shifts to the right over 24 bits, which aligns the operand too far to the right to be within the range of the greater operand. This case is equivalent to adding zero to the greater operand, or simply passing the greater operand to the accumulator unchanged using a bypass multiplexer (<figref idref="DRAWINGS">FIG. <b>7</b><i>c</i></figref>).</p><p id="p-0123" num="0119">This implementation eliminates the bypass multiplexer by adding zero to the CSA when the difference in the exponents is greater than 3, and is equivalent to bypassing the operand. Inputs to the CSA are from both the multiplier as well as the accumulator and are gated by AND gates. The Shifter and Exponent Control Unit detects this situation and sets the appropriate operand to zero. This implementation saves one multiplexer stage in each path.</p><p id="p-0124" num="0120">Detection of sign extension occurs after the 3:2 Carry-Save Adder stage. The sign extension bit S, and the overflow bit <b>0</b> are set if the situation is detected, and it is handled in the following pipeline clock. In order not to lose the sign bit due to overflow, a duplicate sign is carried thought the computation. The additional complexity is introduced to increase precision. This involves extending the accumulator to 36 or 40 bits. In another implementation, introducing detection logic improves timing and accuracy. The detection logic takes inputs from three inputs, <b>683</b>, <b>685</b>, <b>689</b> to the Carry-save Adder circuit (CSA) <b>614</b>, as opposed to two outputs of the Carry-save Adder circuit (CSA) <b>614</b>, and is subject of another related disclosure.</p><heading id="h-0013" level="2">Exponent Circuit:</heading><p id="p-0125" num="0121">An &#x201c;Exponent Control Unit&#x201d; compares the exponent difference between a first exponent operand from the Multiplier and a second exponent operand from the Accumulator. The Exponent Control Unit checks conditions resulting from comparing Multiplier and Accumulator exponents and selects the operand path according to Table 1. Simultaneously, the new accumulator exponent is determined and stored into the Exponent Accumulator (Eacc) register <b>654</b> (<figref idref="DRAWINGS">FIG. <b>7</b><i>b</i></figref>).</p><p id="p-0126" num="0122">The exponent part has two branches: left and right branch. The left branch, consisting of inputs <b>671</b> and <b>673</b> (into the OR gate), selects the greater of the two exponents, which then becomes the resulting exponent. This condition is selected according to the Table 1. The right branch consisting of inputs <b>675</b> and <b>677</b> (into the exponent output OR gate) will select Ea+1 or Ea&#x2212;1 according to the conditions described in Table 1. If significand Overflow is signaled, the accumulator significand should be shifted 8-bits to the right (SHR_8) and the exponent incremented by 1.</p><p id="p-0127" num="0123">Overflow (O) detection is performed during the CS Addition. If Overflow is detected, the 0 bit is latched into the output pipeline register. The overflow situation will be corrected in the next cycle according to Table 1.</p><heading id="h-0014" level="2">Implementation of CS-Accumulation</heading><p id="p-0128" num="0124">The functioning of both Exponent and Significand paths is interdependent, and it depends on the status of the exponent and &#x201c;sign extension&#x201d; (SE) and &#x201c;overflow&#x201d; (O) signal produced in the significand part. There are two accumulators, one for carry and the other for sum. They are summed with the product using a 3:2 Carry-Save Adder (CSA) and passing through the two separate paths, one for carry and the other for sum.</p><p id="p-0129" num="0125">The destination registers of the pipeline stage are an Accumulator comprising Carry and Sum (two registers). Performing the conversion into the conventional format occurs in the next pipeline stages (pipeline-4 and pipeline-5). The Carry-Save stage can be a timing critical stage. Therefore, particular attention is given to timing and area guiding the design decisions described in this section. The critical path in this pipeline stage comprises: Exponent control, three 2:1 multiplexers, one 5-bit subtractor, one 5-bit decrementer, and comparison unit, in the exponent part, and, in the significand part, Exponent control, 5-bit incrementer, 3:2 Carry-Save Adder (CSA), and one AND gate. The critical path can traverse exponent and significand paths, as is the case in this design.</p><heading id="h-0015" level="2">Accumulator Design</heading><p id="p-0130" num="0126"><figref idref="DRAWINGS">FIG. <b>7</b>A</figref> illustrates a simplified block diagram <b>610</b> of an Accumulator <b>240</b> comprising three circuit blocks: Exponents Control Unit <b>240</b>A, Exponents Comparator Unit <b>240</b>B, and the Significand Section <b>240</b>C.</p><p id="p-0131" num="0127"><figref idref="DRAWINGS">FIG. <b>7</b>B</figref> illustrates an exemplary hierarchical block and schematic diagram of the Exponents Control Unit <b>240</b>A and Exponent Comparator Unit <b>240</b>B. A Shifter Exponent Control Signal Generation/Bypass Control circuit <b>630</b> receives the inputs from: accum_ld, exp_zero_en, f_zero_en, e_cin_zero, <b>551</b>, csa_ovf bit <b>634</b> O, and signext, which is the S-bit <b>636</b> in addition to the output of the 16-bit Multiplier Exponent Comparison circuit <b>652</b>, which stores into the 16-bit condition register <b>650</b>, sixteen Exponent Comparison Bits*:</p><p id="p-0132" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="35pt" align="left"/><colspec colname="1" colwidth="63pt" align="left"/><colspec colname="2" colwidth="119pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>z_diff</entry><entry>emult and eaccu are same</entry></row><row><entry/><entry>mgrt</entry><entry>emult is greater than eaccu</entry></row><row><entry/><entry>agrt</entry><entry>eaccu is greater than emult</entry></row><row><entry/><entry>em1p</entry><entry>emult is 1 bigger</entry></row><row><entry/><entry>em2p</entry><entry>emult is 2 bigger</entry></row><row><entry/><entry>em3p</entry><entry>emult is 3 bigger</entry></row><row><entry/><entry>ea1p</entry><entry>eaccu is 1 bigger</entry></row><row><entry/><entry>ea2p</entry><entry>eaccu is 2 bigger</entry></row><row><entry/><entry>ea3p</entry><entry>eaccu is 3 bigger</entry></row><row><entry/><entry>ea4p</entry><entry>eaccu is 4 bigger</entry></row><row><entry/><entry>emz</entry><entry>emult is zero</entry></row><row><entry/><entry>eaz</entry><entry>eaccu is zero</entry></row><row><entry/><entry>eminf</entry><entry>emult is infinity</entry></row><row><entry/><entry>eainf</entry><entry>eaccu is infinity</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row><row><entry/><entry namest="offset" nameend="2" align="left" id="FOO-00001">*where:</entry></row><row><entry/><entry namest="offset" nameend="2" align="left" id="FOO-00002">emult: is Product Exponent</entry></row><row><entry/><entry namest="offset" nameend="2" align="left" id="FOO-00003">eaccu: is Accumulator Exponent</entry></row><row><entry/><entry namest="offset" nameend="2" align="left" id="FOO-00004">emmp meaning, emult is bigger for more than 3</entry></row><row><entry/><entry namest="offset" nameend="2" align="left" id="FOO-00005">eamp meaning, eaccu is bigger for more than 4</entry></row></tbody></tgroup></table></tables><br/>There are additional control signals:<ul id="ul0005" list-style="none">    <li id="ul0005-0001" num="0000">    <ul id="ul0006" list-style="none">        <li id="ul0006-0001" num="0128">accum_ld&#x2014;meaning: Accumulator receiving input C value.</li>        <li id="ul0006-0002" num="0129">exp_zero_en&#x2014;meaning: setting the Product Exponent to zero.</li>        <li id="ul0006-0003" num="0130">f_zero_en&#x2014;meaning: setting product significand to 0 if Exponent=0 (because denormal is not allowed)</li>        <li id="ul0006-0004" num="0131">e_cin_zero&#x2014;meaning: Input C Exponent equal zero</li>    </ul>    </li></ul></p><p id="p-0133" num="0132">Outputs of the Shifter Exponent Control Signal Generation/Bypass Control circuit <b>630</b> are the control signals Accum Shifter Control on line <b>638</b>, Accum bypass Control on line <b>636</b>, Multiplier bypass Control on line <b>634</b>, and Multiplier Shifter Control on line <b>632</b>, Ea_sel on line <b>646</b>, Ealm_sel on line <b>642</b>, Em_sel on line <b>648</b> and Ealp_sel on line <b>645</b>.</p><p id="p-0134" num="0133">The Comparison circuit <b>652</b> compares the exponents of the two operands arriving from: (1) the multiplier exponent E_mult on line <b>521</b> and accumulator exponent on line <b>679</b>; (2) or input A (from exponent E_mult on line <b>521</b> in bypass mode) and the accumulator exponent on line <b>679</b>; (3) or input A (from exponent E_mult on line <b>521</b> in bypass mode) and input C (from the exponent Ec on line <b>460</b>). The Comparison circuit <b>652</b> generates the following condition bits that are stored in the 16-bit condition register <b>650</b>: emult: Multiplier Exponent; eaccu: Accumulator Exponent; z_diff&#x2014;emult and eaccu are same; mgrt&#x2014;emult is greater than eaccu; agrt&#x2014;eaccu is greater than emult; emlp&#x2014;emult is 1 bigger; em2p&#x2014;emult is 2 bigger; em3p-emult is 3 bigger; emmp&#x2014;emult is more than 3 bigger; ealp&#x2014;eaccu is 1 bigger; ea2p&#x2014;eaccu is 2 bigger; ea3p&#x2014;eaccu is 3 bigger; ea4p&#x2014;eaccu is 4 bigger; eamp&#x2014;eaccu is more than 4 bigger; emz&#x2014;emult is zero; eaz&#x2014;eaccu is zero; eminf&#x2014;emult is infinity; and eainf&#x2014;eaccu is infinity. The 16-bit condition register <b>650</b> interfaces to the Shifter Exponent Control Signal Generation/Bypass Control circuit <b>630</b> via bus <b>621</b>. The 16-bit condition register <b>650</b> stores the results of a comparison of the Eacc from summation S(i&#x2212;1) and the E_mult register <b>520</b> stores the term A(i)*B(i) in the accumulation mode, during the generation of the Eacc for summation S(i).</p><p id="p-0135" num="0134">Inputs on line <b>647</b> to the Comparison circuit <b>652</b> come from the Subtractor circuit <b>646</b>. The subtractor circuit <b>646</b> receives E_mult on line <b>521</b> from the pipeline register <b>520</b> and the output of Multiplexer <b>642</b>, which chooses between Ec of register <b>460</b> and the New Exponent output on line <b>679</b> of OR Gate <b>670</b>, where Multiplexer <b>642</b> is controlled by the accum_en signal on line <b>665</b> which indicate the mode. (<figref idref="DRAWINGS">FIG. <b>7</b><i>b</i></figref>)</p><p id="p-0136" num="0135">Exp_Zero_En on line <b>618</b> is applied to inverter <b>619</b>, the output of which is applied as an input to AND gate <b>617</b>. The E_mult exponent bits from the pipeline register <b>520</b> are input to the AND gate <b>617</b> as well, the output of which on line <b>681</b> which feeds into to the AND gate <b>668</b>, with the Em_sal bit on line <b>648</b> from Shifter Exponent Control Signal Generation/Bypass Control circuit <b>630</b> to pass or block E_mult. The output on line <b>671</b> of AND gate <b>668</b> connects to a four input OR gate <b>670</b>. The OR gate <b>670</b> has three other inputs, including the output of AND gate <b>615</b>, which is selected by signal Ea_sel to pass or block Eaccum, and the outputs of the incrementer <b>660</b> on line <b>616</b> and decrementor <b>661</b> on line <b>663</b>, are each controlled at AND gates <b>664</b> and <b>665</b> by outputs Ealp_sel and Ealm_sel, respectively. Depending on the select signals (of which only one can be 1), <b>648</b>, <b>646</b>, <b>645</b>, <b>642</b>, a proper exponent is selected as an output of the OR gate <b>670</b>. This output is the Eacc signal, also known as the New-Exponent which is an input to Exponent Accumulator (Eacc) register <b>654</b>, also input to the Multiplexer <b>642</b>.</p><p id="p-0137" num="0136">The output of multiplexer <b>665</b> (either the &#x201c;new exponent for summation S(i), or the exponent of the operand C, depending on the mode) is also registered in this embodiment in register <b>460</b>, which is connected on line <b>644</b> as inputs to the incrementer <b>660</b> and to the decrementer <b>661</b>.</p><p id="p-0138" num="0137">So, as the new exponent on line <b>679</b> is developed representing summation S(i) using the comparison bits produced with summation S(i&#x2212;1), the new exponent is compared to the E-mult value for term A(i&#x2212;1)*B(i&#x2212;1) in register <b>520</b> to generate the comparison signals to be latched with summation S(i), and used for shifter control during generation of summation S(i+1).</p><p id="p-0139" num="0138"><figref idref="DRAWINGS">FIG. <b>7</b>C</figref> is a schematic diagram of the Significand Section <b>240</b>C. A Shifter Exponent Control Signal Generation/Bypass Control circuit <b>630</b> is illustrated showing four output control signals. The first control signal is the Accum Shifter Control on line <b>638</b> which is the select signal for the shifter circuits SHR8/16/24/SHL8 <b>609</b> and <b>610</b>. Two shifter circuits: SHR8/16/24/SHL8 <b>609</b> and <b>610</b> receive their inputs on line <b>682</b> and on line <b>683</b> from a set of Multiplexers, <b>210</b> and <b>211</b>. The accum_en signal on line <b>665</b>, controls Multiplexer <b>210</b> and Multiplexer <b>211</b> to choose between the SUM on line <b>224</b>, CARRY on line <b>225</b> or the value on line <b>219</b>, originating from register Fcin <b>560</b> or logic &#x201c;0&#x201d; as another input of the multiplexer <b>211</b>. Multiplexer <b>210</b> and Multiplexer <b>211</b> output the selected values on bus <b>682</b> and bus <b>683</b> into shifter circuits SHR8/16/24/SHL8 <b>609</b> and <b>610</b>. Shifter circuits <b>609</b> and <b>610</b> output shifted values on buses <b>692</b> and <b>693</b>. Bus <b>692</b> can interface directly to bus <b>613</b> or can traverse an optional Carry Rounding block <b>604</b> which appends rounding bits to the bus <b>613</b>. Bus <b>693</b> can interface directly to bus <b>611</b> or can traverse an optional Sum Rounding block <b>612</b>, and append rounding bits to <b>693</b>. Buses <b>611</b> and <b>613</b> are inputs to the AND gates <b>687</b> and <b>688</b>, the outputs of which are applied as inputs to the Carry-save Adder circuit <b>614</b> on line <b>689</b> and <b>685</b> (the AND symbol represents a multiplicity of AND gates for each signal line on the busses: <b>613</b>, <b>611</b> and <b>607</b>. The inputs for the AND gates <b>688</b> and the AND gates <b>686</b> are selected by control signals on line <b>633</b> and on line <b>634</b>, respectively.</p><p id="p-0140" num="0139">The F_mult value in the pipeline register <b>520</b> is input to a Simple Product Rounding block <b>684</b> which inputs on line <b>603</b> directly to a shift registers SHR 8/16/24 circuit <b>608</b>. The select signal for SHR 8/16/24 circuit <b>608</b> is the Multi-Shifter Control on line <b>632</b> which selects between the F_mult input on line <b>601</b> and rounded product on line <b>603</b>. The output is the Product containing 42-bits (34+8) on bus <b>607</b>, which is applied to an input to the AND gates <b>686</b>, the output of which is an input to the Carry-save Adder circuit <b>614</b>.</p><p id="p-0141" num="0140">The 42-Bits 3:2 Carry-save Adder circuit <b>614</b> has three inputs, including the output <b>683</b> of the AND gates <b>686</b>, the output <b>689</b> of the AND gates <b>687</b>, and the output <b>685</b> of the AND gates <b>688</b>. The 42-Bits 3:2 Carry-save Adder circuit <b>614</b> outputs are two buses: Sum bus <b>669</b> and Carry bus <b>667</b>. The two outputs, <b>669</b> and <b>667</b> enter the 42-bit Frac Sum register <b>242</b> via bus <b>669</b> and the 42-bit Frac Carry register <b>241</b> via Carry bus <b>667</b> respectively. Bus <b>669</b> and bus <b>667</b> are also inputs to an Overflow Detection block <b>605</b> and Sign Extension Detection Unit <b>662</b>. The two blocks, Overflow Detection block <b>605</b> and Sign Extension Detection Unit <b>662</b> provide output to the 0-bit <b>634</b>, which is the csa_ovf signal and the S-bit <b>636</b> which is the Sign Extension signal. The Sign Extension Detection unit <b>662</b> has an enable bit accum_en signal on line <b>665</b> which is set to a logic &#x201c;1&#x201d; when the operation is Accumulate. The Sign Extension Detection block is operational only working when the &#x201c;accum_en&#x201d; signal is enabled. There are three operation modes available, which are:</p><p id="p-0142" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>Input-<i>A</i>(<i>BF</i>16)&#xd7;Input-<i>B</i>(<i>BF</i>16)+Input-<i>C</i>(<i>FP</i>32),<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0143" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>Input-<i>A</i>(<i>BF</i>16)&#xd7;Input-<i>B</i>(<i>BF</i>16)+Accumulation Loop (summation),<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0144" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>Input-<i>A</i>(<i>FP</i>32)+Input-<i>C</i>(<i>FP</i>32).<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0145" num="0000">The &#x201c;accum_en&#x201d; signal is only enabled during the second mode condition (accumulation). In addition mode, Sign Extension Detection is not needed. It is only required in the Accumulation mode as gradual growth of the sign extension bits can only occur during the Accumulation operation.</p><heading id="h-0016" level="2">Sign Extension Detection Unit <b>662</b>:</heading><p id="p-0146" num="0141">According to some aspects, the Sign Extension Detection Unit <b>662</b> is attached to the accumulator output of both Sum and Carry. When detecting 10-bits sign (that includes two sign bits, plus additional 8 bits in the first byte of the Sum or Carry) the output shifts left in the following cycle (SHL_8) to preserve operand accuracy. If Sign Extension Detection is not implemented, during the normal operation, the significant bits of the operand gradually shift to the right until being replaced with extended sign bits, thus, resulting in the loss of accuracy. In this implementation, every time one of the operands has at least 10 leading sign bits detected, an adjustment executes a shifting of the operands left for 8-bit positions. The exponent is adjusted accordingly by decrementing exponent value by one, which is executed in the same cycle. When S is detected on the Carry or Sum portion of the accumulator, S bit is latched in the output pipeline register <b>636</b>, for a correction in the next cycle. The corrective action executes a shift of the accumulator to the left for 8-bit positions (SHL_8). Sometimes this situation may cancel itself with the next action (requiring SHR_8), often leaving things unchanged as shown in Table 1.</p><heading id="h-0017" level="2">Normalization and Conversion to Sign Magnitude Format</heading><p id="p-0147" num="0142"><figref idref="DRAWINGS">FIG. <b>8</b>A</figref> illustrates the Normalization, Conversion to Sign Magnitude Format block <b>270</b> comprising two sub-blocks, a first sub-block is Conversion from Carry-Save To Sign-Magnitude format block <b>270</b><i>a </i>and a second sub-block is Conversion from Radix-8 To Radix-2 Floating Point Number block <b>270</b><i>b. </i></p><p id="p-0148" num="0143"><figref idref="DRAWINGS">FIG. <b>8</b>B</figref> illustrates an exemplary schematic diagram for the Conversion from Carry-Save To Sign-Magnitude format block <b>270</b><i>a</i>. Two registers, a 42-bit Frac Sum register <b>242</b>, and a 42-bit Frac Carry register <b>241</b> output the Shifted Carry [42:0] bus <b>704</b> and the Sign Extended Sum [42:0] bus <b>702</b> as inputs to a 43-BIT ADDER circuit <b>708</b>. A second circuit LZA/LOA <b>710</b> receives input bus <b>702</b> and bus <b>704</b>. The second circuit LZA/LOA <b>710</b> outputs two buses POS_P [5:0] on line <b>711</b> and POS_N [5:0] on line <b>712</b> to a third LZA POS Selection circuit <b>714</b>. The output, for example, via bus <b>715</b>, of the LZA POS Selection circuit <b>714</b> is the POS [5:0] which maps to the register <b>730</b> as the 6-bit position, designating the amount of shift left required to normalize significand.</p><p id="p-0149" num="0144">A 43-BIT ADDER circuit <b>708</b> outputs the signal SIGN on line <b>719</b> to control the LZA POS Selection circuit <b>714</b>, routes bus <b>716</b> to the Significand Selection Multiplexer circuit <b>720</b> on the &#x201c;0&#x201d; leg input, and routes bus <b>716</b> to the input of Negative: Invert+1 circuit <b>718</b>. The &#x201c;1&#x201d; leg of the 2'S Significand Selection Multiplexer circuit <b>720</b> receives bus <b>717</b>, which represents negative significand, converted into a positive one. The SIGN <b>719</b> controls the Significand Selection multiplexer, so that the output <b>738</b> contains always a positive significand. The output of the 2'S Complement Selection Multiplexer circuit <b>720</b> is the bus <b>738</b> which maps to the register <b>730</b> as the 41-bit positive significand. A 5-bit exponent maps on line <b>706</b> directly to the register <b>730</b> as well as the SIGN bit <b>726</b>. This step finishes conversion of the Accumulator significand represented in the Carry-Save format into a Sign-Magnitude Radix-8 format.</p><p id="p-0150" num="0145">In this stage the two values on Sum bus <b>702</b> and Carry bus <b>704</b> (representing significand in carry-save format), are summed together in the 43-BIT ADDER circuit <b>708</b> to produce Sign-Magnitude format of the significand. Leading Zero/Leading One Anticipator (second LZA/LOA circuit) <b>710</b> will calculate two numbers: number of Leading Zeroes <b>711</b> (in case the significand <b>716</b> is positive) and number of leading Ones <b>712</b> (in case the significand <b>716</b> is negative). Depending on the significand sign bit <b>719</b>, the correct position will be selected by the multiplexer, LZA POS Selection circuit <b>714</b> and will be stored into the register <b>730</b>. Both LZ and LO positions, POS_P and POS_N are 6-bit long numbers, anticipating the situation containing 32 leading zeroes or ones.</p><p id="p-0151" num="0146">If the significand at the output of the 43-BIT ADDER circuit <b>708</b> is negative, this negative number is converted into a positive number (as IEEE 754 uses sign-magnitude representation, i.e., positive significand). For that purpose, 2's complement converter <b>718</b> is used. The sign bit <b>719</b> controls the multiplexer circuit <b>720</b>, so that if the number is positive, it will be stored directly into the 41-bit significand register <b>730</b>. In case the output is negative, the output on line <b>717</b>, which is the value on <b>716</b> converted into a positive value, will be passed to register <b>730</b> on line <b>738</b>.</p><p id="p-0152" num="0147">The predicted 6-bit position of the significand will be added to the 5-bit exponent to produce the new 8-bit exponent compliant with the standard floating point number representation, and the significand will be aligned with respect to the floating point significand, using the same 6-bit predicted position (<figref idref="DRAWINGS">FIG. <b>8</b><i>c</i></figref>).</p><p id="p-0153" num="0148"><figref idref="DRAWINGS">FIG. <b>8</b>C</figref> illustrates an exemplary schematic diagram for the Conversion from Radix-8 To Radix-2 Floating Point Number block <b>270</b><i>b</i>. The register <b>730</b> interfaces to the SHL Left shifter circuit <b>735</b> via the 41-bit bus <b>731</b>. The register <b>730</b> interfaces to the Significand Zero Detection circuit <b>728</b> via the 41-bit bus <b>734</b>. The 6-bit position field of register <b>730</b> provides Pos [5:0] on line <b>723</b> to control the SHL Left shifter circuit <b>735</b>. The Pos [5:0] on line <b>723</b> is also an input to the Exponent adder circuit <b>740</b>. The Exponent 5-bit field of register <b>730</b> is a second input on line <b>721</b> to the Exponent adder circuit <b>740</b>. Exponent adder circuit <b>740</b> adjusts (increments) the exponent for the number of positions the significand is shifted to the left as indicated by the POS [5:0], and provides an output on line <b>736</b> to register <b>748</b>. However, given that the predictor can be in error for one position, the output of the shifter is passed to the Over/Under Detection circuit <b>752</b> which will signal the error by issuing the signal <b>739</b> which is applied to the carry input of Exponent adder circuit <b>740</b> and to a control input of under detection multiplexer <b>760</b>. Under Detection Multiplexer <b>760</b> has an input on line <b>746</b> where the significand on line <b>742</b> from shifter circuit <b>735</b> is in the same position (no error detected), and an input on line <b>747</b> where the significand on line <b>742</b> is shifted for one bit position to the left (error detected). If the signal <b>739</b> indicates under detection, correct output will be latched into the register <b>770</b> via bus <b>745</b>. The error in exponent adjustment is corrected by entering <b>1</b> into the adder via carry-in input. The SIGN value is copied from register <b>730</b> to register <b>747</b>.</p><p id="p-0154" num="0149">The sign bit in register <b>730</b> is passed through on line <b>744</b> to register <b>747</b>.</p><p id="p-0155" num="0150">The Exception Control (8-bit) register <b>750</b> passes its value on line <b>724</b> to Exception Control register <b>751</b>. The meaning of the Exception Control register bits is given as:<ul id="ul0007" list-style="none">    <li id="ul0007-0001" num="0000">    <ul id="ul0008" list-style="none">        <li id="ul0008-0001" num="0151">exp_inf_en: Operand A is infinity or Operand B is infinity</li>        <li id="ul0008-0002" num="0152">z_diff Accumulator exponent equal to Product exponent</li>        <li id="ul0008-0003" num="0153">s_mult: Product Sign</li>        <li id="ul0008-0004" num="0154">s_cin: Input C Sign</li>        <li id="ul0008-0005" num="0155">e_mul_zero: Product Exponent=0</li>        <li id="ul0008-0006" num="0156">e_cin_zero: Input C Exponent=0</li>        <li id="ul0008-0007" num="0157">e_mul_inf: Product Exponent is equal to infinity.</li>        <li id="ul0008-0008" num="0158">e_cin_inf: Input C Exponent is equal to infinity.<br/>The bit six <b>726</b> of the Exception Control (8-bit) register <b>750</b>, is &#x201c;z_diff&#x201d; and indicates the result of the exponent comparison between accumulator and product exponent. When equal to 1, The exponent of the Accumulator is equal to the exponent of the product. When &#x201c;z_diff&#x201d;=zero, it indicates that the Accumulator exponent is smaller than or equal to the product exponent. The bit [6] &#x201c;z_diff&#x201d; is the first input on line <b>726</b> to the Significand Zero Detection circuit <b>728</b>. The Significand Zero Detection circuit <b>728</b> outputs a 1-bit signal on line <b>753</b>, which replaces bit [<b>6</b>] &#x201c;z_diff&#x201d;, in the Exception Control register <b>751</b> now becoming &#x201c;pos_zero&#x201d; <b>753</b>, indicating that the resulting significand is zero. A second output of the Significand Zero Detection circuit <b>728</b> provides a signal on line <b>755</b> for the Frac-Zero register <b>756</b> once the accumulation operation is finished and the operation proceeds to normalization.</li>    </ul>    </li></ul></p><p id="p-0156" num="0159"><figref idref="DRAWINGS">FIG. <b>9</b>A</figref> illustrates block <b>270</b> performing <b>700</b> the Final Conversion into BF16 or IEEE 754 32-Bit Single Precision Format, consisting of a Sign-Magnitude format block <b>270</b><i>a </i>performing Rounding and Conversion into BF16 or IEEE 754 32-Bit Single Precision Format and sub-block <b>270</b><i>b </i>performing Exponent and Exception Handling.</p><heading id="h-0018" level="2">Rounding and Conversion to FP32 Format</heading><p id="p-0157" num="0160">According to some aspects, the final stage is pipeline-6 which performs rounding of the result to a standard Floating point Sign/Magnitude number with the following: sign bit, 8-bit exponent, 23 bit, normalized significand (+1 implied integer bit). In the process of converting from the 31-bit significand to 24-bit normalized significand with one implied bit, rounding of the result from 31 to 24-bit is performed. In this implementation two rounding modes are implemented: Round Towards Zero (RTZ) truncate, Round to Nearest Even, (RNE). However, any other rounding modes e.g., Round to Nearest Odd (RNO) are easily incorporated.</p><p id="p-0158" num="0161">According to some aspects, rounding logic checks the last 15 LSB bits out of 39 significand bits (not counting GRS bits which make the total 42-bits, 39+3 GRS bits) from the register <b>770</b> and determines if the remaining 24 bits require rounding (according to the rule applied: RNE or RTZ). The Incrementer needed for RNE is contained in the Rounding box. The three bits, GRS, carried over from the accumulator (CSA) operations are ignored in this implementation. They can be incorporated in the final rounding in other possible implementations.</p><p id="p-0159" num="0000">Rounding is done in one of the several ways:<ul id="ul0009" list-style="none">    <li id="ul0009-0001" num="0000">    <ul id="ul0010" list-style="none">        <li id="ul0010-0001" num="0162">(a) During CS Accumulate operation Rounding to Nearest Odd (RNO) is applied,        <ul id="ul0011" list-style="none">            <li id="ul0011-0001" num="0163">on Sum signal only with rounding bit being inserted into the Carry LSB open position,</li>            <li id="ul0011-0002" num="0164">on each Sum and Carry signal separately,</li>        </ul>        </li>        <li id="ul0010-0002" num="0165">(b) During CS Accumulate, and in the pipeline-6 stage (final rounding), and</li>        <li id="ul0010-0003" num="0166">(c) Only in the pipeline-6 stage, while CSA is disabled.<br/>Each of the rounding modes is applied according to the accuracy and particular requirement imposed by a particular application program.</li>    </ul>    </li></ul></p><p id="p-0160" num="0167">The output to pipeline-6 is either FP32 or BF16, as required. Therefore, the significand length is either 24 (23+implied bit) or 8-bit (7+implied bit). That is controlled by the &#x201c;Out_FP32&#x201d; signal applied to the first Multiplexer. In case rounding resulted in 25-bit significand, the significand will be right-shifted one position and the exponent will be incremented by one.</p><p id="p-0161" num="0168">The properly normalized and rounded result is stored in the output register of the pipeline-6, as either BF16 number consisting of 1-bit sign, 8-bit exponent, and 7-bit fraction of the significand, or FP32 number consisting of 1-bit sign, 8-bit exponent, and 23-bit fraction of the significand.</p><p id="p-0162" num="0169"><figref idref="DRAWINGS">FIG. <b>9</b>B</figref> illustrates an exemplary schematic diagram showing the Rounding and Conversion into BF16 or IEEE 754 32-Bit SP Format. The 39-bit significand register <b>770</b> bus fpst_<b>1</b> [38:0] <b>837</b> provides fpst_<b>1</b> [32:0] <b>819</b> or fpst_<b>1</b> [16:0] <b>819</b> to a Rounding circuit <b>830</b> comprising the guard, round, and sticky bits. The control Out_FP32 selects the portion of the significand on line <b>819</b> which is to be rounded by Rounding circuit <b>830</b>. In case 32-bit SP format is selected, the upper 24-bits [38:16] are augmented with 3 round bits. A Multiplexer <b>840</b> chooses between a &#x201c;0&#x201d; input on line <b>835</b> or the Rounding circuit <b>830</b> output on line <b>825</b> where the Multiplexer <b>840</b> is controlled by the Round to Zero select line <b>823</b>. This situation occurs when the exponent exceeds &#x2212;126 and the significand becomes de-normalized, which in this implementation results in rounding to zero. The output on line <b>827</b> routes 23-bits (one implied) and 3-rounding bits to a first Round Increment circuit <b>860</b> resulting in properly rounded significand in IEEE 754 SP 32-bit format on line <b>819</b>.</p><p id="p-0163" num="0170">The second Round Increment circuit <b>850</b> is operative for rounding into BF-16 format, when BF16 output format is selected. The conversion of the 39-bit significand on line <b>817</b> from fpst_<b>1</b> [38:0] <b>817</b> to the BF-16 output is done in Round Increment circuit <b>850</b> resulting in 7-bits (one implied), augmented with 1 rounding decision bit, and with 16 zeros appended. This represents significand at the output on line <b>821</b> as one of the Multiplexer <b>802</b> inputs.</p><p id="p-0164" num="0171">A first Multiplexer <b>802</b> selects the FP-32 or BF16 output using the control line signal Out_FP32 801. When Out_FP32 801 is active, it outputs the FP-32 format significand on line <b>805</b>. When the Out_FP32 801 control signal is inactive, the output on line <b>805</b> is in BF-16 format significand. The output of the first Multiplexer <b>802</b> is bus <b>805</b> which divides into bus <b>807</b> and bus <b>809</b>, entering the second Multiplexer <b>810</b>. The Multiplexer <b>810</b> is controlled by the 24-th bit of the output bus on line <b>805</b>, frnd [23] signal on line <b>803</b>. In case rounding produced 25-bit significand as discussed in [0093] 24-th bit will be one. In this case, signal on line <b>803</b> frnd [23] bit selects the input bus <b>807</b> which is bus <b>805</b> shifted for one bit position to the right. (frnd [23] signal will also increment the exponent of the result for 1, to adjust for the right shift. In case frnd [23] is equal 0, right shift is not needed and the bus <b>805</b> will pass straight to the output on line <b>831</b>, via selected input bus <b>809</b>.</p><p id="p-0165" num="0172">The third Multiplexer (Zero) <b>820</b> chooses between an all &#x201c;0&#x201d; on line <b>829</b> input or the fnorm [22:0] on line <b>831</b>. If the Output Exponent is Infinity or Denormal, Output Significands are forced to Zero which is done via Zero_Sel on line <b>788</b> control signal, which choses all &#x2018;0&#x2019; input <b>829</b>. If there is no exception the normalized significand bus <b>831</b> is routed as bus <b>833</b> and maps to the 23-bit Significand (IEEE 754) register <b>930</b>.</p><p id="p-0166" num="0173"><figref idref="DRAWINGS">FIG. <b>9</b>C</figref> illustrates an exemplary schematic diagram showing Exponent and Exception Handling block <b>270</b><i>b</i>. An 8-bit Exponent <b>748</b> provides the EPST_L [9:0] <b>964</b> bus and is incremented by 1 if frnd[23]=1. This is accomplished by routing frnd[23] into the carry-in position of the incrementer <b>982</b>. The output of exponent incrementer <b>982</b> is the 9-bit Enorm [8:0] bus <b>968</b> which is a first input to a first Multiplexer (Zero) <b>974</b>. The second input to the first Multiplexer (Zero) <b>974</b> are ALL &#x2018;0&#x2019;s bus <b>829</b>. The purpose of the first Multiplexer (Zero) <b>974</b> is to set the exponent to all &#x2018;0&#x2019; in case this is required by an exception, indicated by Exception Control (8-bit) register <b>750</b>, via Zero Control logic <b>970</b>.</p><p id="p-0167" num="0174">The Exception Control (8-bit) register <b>750</b> operates on the following eight conditions <b>953</b>: exp_inf_en, pos_zero, s_mult, s_cin, e_mul_zero, e_cin_zero, e_mul_zero and e_cin_inf.</p><p id="p-0168" num="0175">The Zero Control logic <b>970</b> has three inputs: sign_diff on line <b>961</b> from the XOR gate and, e_cin_zero on line <b>959</b>, e_mul_zero on line <b>957</b> from an Exception Control (8-bit) register <b>750</b>, and the output on line <b>972</b> controls the first Multiplexer (Zero) <b>974</b>. The output on line <b>975</b> of the first Multiplexer (Zero) <b>974</b> passes through the Multiplexer <b>976</b> providing the exponent signal bus <b>979</b> which is stored in the Exponent register <b>980</b>. In case Infinity Control <b>962</b> signals infinity on line <b>963</b>, ALL &#x2018;1&#x2019; input on line <b>907</b> is passed through the multiplexer <b>976</b> setting all exponent bits to &#x2018;1&#x2019;, as recommended by the IEEE 754 standard.</p><p id="p-0169" num="0000">The meaning of signals is: (explained in paragraph 089)</p><p id="p-0170" num="0000"><tables id="TABLE-US-00002" num="00002"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="147pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/><entry>exp_inf_en</entry><entry>Operand A is infinity or Operand B is infinity</entry></row><row><entry/><entry>pos_zero</entry><entry>resulting significand is zero</entry></row><row><entry/><entry>s_mult</entry><entry>Product Sign</entry></row><row><entry/><entry>s_cin</entry><entry>Input C Sign</entry></row><row><entry/><entry>e_mul_zero</entry><entry>Product Exponent = 0</entry></row><row><entry/><entry>e_cin_zero</entry><entry>Input C Exponent = 0</entry></row><row><entry/><entry>e_mul_inf</entry><entry>Product Exponent is equal to infinity.</entry></row><row><entry/><entry>e_cin_inf</entry><entry>Input C Exponent is equal to infinity.</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>In addition, signal &#x201c;sign_diff&#x201d; indicating that the sign of the product &#x201c;s_mult&#x201d; and sign of the input C, &#x201c;s_cin&#x201d; are different. This signal is obtained by applying an XOR function to s_mult and s_cin signals taken from the Exception Control (8-bit) register <b>750</b>.</p><p id="p-0171" num="0176">The Exception Control (8-bit) register <b>750</b> provides the following signals: s_cin, s_mult, exp_inf_en, e_cin_inf, e_mul_inf, pos_zero, sign_diff, on the bus <b>965</b> to the Sign Generation and Exception Processing circuit <b>988</b> and the Underflow/Overflow Detection and Exponent Exception Detection circuit <b>986</b>. The control signals for the circuit <b>986</b> are norm_en <b>758</b> on line <b>969</b> and Frac Zero register <b>756</b> on line <b>971</b>. The outputs of the circuit <b>986</b> are three signals ov (Overflow), of (Underflow) and (Invalid) nv. A fourth output on line <b>991</b> is sent to the Sign Generation and Exception Processing circuit <b>988</b> from the Infinity detection circuit <b>992</b> indicating overflow.</p><p id="p-0172" num="0177">Signals have the following abbreviations as follows: s_cin (Input C Sign), s_mult (Product Sign), e_mul_zero (Product Exponent Zero), e_cin_zero (Input C Exponent Zero), e_mul_inf (Product Exponent Infinity), and e_cin_inf (Input C Exponent Infinity).</p><p id="p-0173" num="0178">Two correlated events contribute to underflow. One is the creation of a tiny nonzero result between &#xb1;2-126 [where &#x2212;126 is minimal exponent value] which, because it is so small, may later cause some other exception such as overflow upon division. The other event is the extraordinary loss of accuracy during the approximation of such small numbers. Loss of accuracy may be detected when the delivered result differs from what would have been computed were both exponent range and precision unbounded. The IEEE Standard 754 does not track accuracy other than to require single and double precision. In this disclosed implementation, &#x201c;denormal&#x201d; numbers are not used and any value where exponent value is &#x2212;126, and significand is smaller than 1, will be converted to zero. Zero is represented by setting all the significand bits to zero and exponent value to zero, which is handled by Exception Processing Circuits in our disclosed implementation.</p><p id="p-0174" num="0179">The Sign Generation and Exception Processing circuit <b>988</b> receives an input from the Exception Control (8-bit) register <b>750</b> via bus <b>965</b> and Infinity detection circuit <b>992</b>. The output of Sign Generation and Exception Processing circuit <b>988</b> is a SIGN bit which is stored into the register <b>990</b> via signal line <b>983</b>.</p><p id="p-0175" num="0180">An Infinity detection circuit <b>992</b> operates on the exponent signal bus <b>979</b> input and if it detects all exponent bits to be 1, it will provide &#x2018;1&#x2019; to the OR gate <b>987</b> which will in turn set its output <b>788</b> to &#x2018;1&#x2019;. This sets ZERO-SEL signal <b>788</b> which sets significand to all zero (Mux <b>820</b>, <figref idref="DRAWINGS">FIG. <b>9</b>B</figref>).</p><p id="p-0176" num="0181">Denormal Circuit <b>994</b> detects the situation when the exponent value on exponent signal bus <b>979</b> is out of range, and signals underflow situation on signal line <b>967</b>. This condition is also signaled to the OR gate <b>987</b> which generates the signal ZERO-SEL on line <b>788</b>. ZERO-SEL signal on line <b>788</b> (<figref idref="DRAWINGS">FIG. <b>9</b>B</figref>) will instruct the Multiplexer <b>820</b> to insert all &#x201c;0&#x201d;s into the significand, thus creating proper IEEE 754 &#x201c;Zero&#x201d; representation (both exponent and significand contain all &#x201c;0&#x201d;s).</p><p id="p-0177" num="0000"><tables id="TABLE-US-00003" num="00003"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="301pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 1</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>CSA Unit Control</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="offset" colwidth="49pt" align="left"/><colspec colname="1" colwidth="105pt" align="center"/><colspec colname="2" colwidth="84pt" align="left"/><colspec colname="3" colwidth="63pt" align="center"/><tbody valign="top"><row><entry/><entry>Input Conditions</entry><entry/><entry>Output Control</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="offset" colwidth="91pt" align="left"/><colspec colname="1" colwidth="63pt" align="left"/><colspec colname="2" colwidth="84pt" align="center"/><colspec colname="3" colwidth="63pt" align="center"/><tbody valign="top"><row><entry/><entry>Overflow</entry><entry>Significand Output Mux</entry><entry>Exponent Output</entry></row><row><entry/><entry>Signext Inputs</entry><entry>Control</entry><entry>(alternate)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="offset" colwidth="49pt" align="left"/><colspec colname="1" colwidth="42pt" align="left"/><colspec colname="2" colwidth="63pt" align="left"/><colspec colname="3" colwidth="49pt" align="left"/><colspec colname="4" colwidth="35pt" align="left"/><colspec colname="5" colwidth="63pt" align="left"/><tbody valign="top"><row><entry/><entry>Exponent</entry><entry>Condition</entry><entry>Mult.</entry><entry>Accu.</entry><entry>Bypass</entry></row><row><entry/><entry namest="offset" nameend="5" align="center" rowsep="1"/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="8"><colspec colname="1" colwidth="35pt" align="left"/><colspec colname="2" colwidth="14pt" align="center"/><colspec colname="3" colwidth="42pt" align="left"/><colspec colname="4" colwidth="63pt" align="left"/><colspec colname="5" colwidth="49pt" align="left"/><colspec colname="6" colwidth="35pt" align="left"/><colspec colname="7" colwidth="28pt" align="left"/><colspec colname="8" colwidth="35pt" align="left"/><tbody valign="top"><row><entry>Ea = Em</entry><entry>1</entry><entry>Ea = Em</entry><entry>(OV = 0 &#x26; SE = 0)</entry><entry>Fm</entry><entry>Fa</entry><entry>Ea</entry><entry>(Em)</entry></row><row><entry/><entry/><entry/><entry>(OV = 1 &#x26; SE = 1)</entry></row><row><entry/><entry/><entry/><entry>(OV = 0 &#x26; SE = 1)</entry></row><row><entry/><entry/><entry/><entry>OV = 1 &#x26; SE = 0</entry><entry>Fm &#x3e;&#x3e; 8</entry><entry>Fa &#x3e;&#x3e; 8</entry><entry>Ea + 1</entry><entry>(Em + 1)</entry></row><row><entry>Ea &#x3e; Em</entry><entry>2</entry><entry>Ea = Em + 1</entry><entry>(OV = 0 &#x26; SE = 0)</entry><entry>Fm &#x3e;&#x3e; 8</entry><entry>Fa</entry><entry>Ea</entry></row><row><entry/><entry/><entry/><entry>(OV = 1 &#x26; SE = 1)</entry></row><row><entry/><entry/><entry/><entry>OV = 1 &#x26; SE = 0</entry><entry>Fm &#x3e;&#x3e; 16</entry><entry>Fa &#x3e;&#x3e; 8</entry><entry>Ea + 1</entry></row><row><entry/><entry/><entry/><entry>OV = 0 &#x26; SE = 1</entry><entry>Fm</entry><entry>Fa &#x3c;&#x3c; 8</entry><entry>Ea &#x2212; 1</entry><entry>(Em)</entry></row><row><entry/><entry>3</entry><entry>Ea = Em + 2</entry><entry>(OV = 0 &#x26; SE = 0)</entry><entry>Fm &#x3e;&#x3e; 16</entry><entry>Fa</entry><entry>Ea</entry></row><row><entry/><entry/><entry/><entry>(OV = 1 &#x26; SE = 1)</entry></row><row><entry/><entry/><entry/><entry>OV = 1 &#x26; SE = 0</entry><entry>Fm &#x3e;&#x3e; 24</entry><entry>Fa &#x3e;&#x3e; 8</entry><entry>Ea + 1</entry></row><row><entry/><entry/><entry/><entry>OV = 0 &#x26; SE = 1</entry><entry>Fm &#x3e;&#x3e; 8</entry><entry>Fa &#x3c;&#x3c; 8</entry><entry>Ea &#x2212; 1</entry><entry>(Em + 1)</entry></row><row><entry/><entry>4</entry><entry>Ea = Em + 3</entry><entry>(OV = 0 &#x26; SE = 0)</entry><entry>Fm &#x3e;&#x3e; 24</entry><entry>Fa</entry><entry>Ea</entry></row><row><entry/><entry/><entry/><entry>(OV = 1 &#x26; SE = 1)</entry></row><row><entry/><entry/><entry/><entry>OV = 1 &#x26; SE = 0</entry><entry>(Fm)</entry><entry>Fa &#x3e;&#x3e; 8</entry><entry>Ea + 1</entry><entry>Bypass</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry/><entry/><entry>(Acc)</entry></row><row><entry/><entry/><entry/><entry>OV = 0 &#x26; SE = 1</entry><entry>Fm &#x3e;&#x3e; 16</entry><entry>Fa &#x3c;&#x3c; 8</entry><entry>Ea &#x2212; 1</entry><entry>(Em + 1)</entry></row><row><entry/><entry>5</entry><entry>Ea &#x3e; Em + 3</entry><entry>(OV = 0 &#x26; SE = 0)</entry><entry>(Fm)</entry><entry>Fa</entry><entry>Ea</entry><entry>Bypass</entry></row><row><entry/><entry/><entry/><entry>(OV = 1 &#x26; SE = 1)</entry><entry/><entry/><entry/><entry>(Acc)</entry></row><row><entry/><entry/><entry/><entry>OV = 1 &#x26; SE = 0</entry><entry>(Fm)</entry><entry>Fa &#x3e;&#x3e; 8</entry><entry>Ea + 1</entry><entry>Bypass</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry/><entry/><entry>(Acc)</entry></row><row><entry/><entry/><entry/><entry>OV = 0 &#x26; SE = 1</entry><entry>If Ea = Em + 4</entry><entry>Fa &#x3c;&#x3c; 8</entry><entry>Ea &#x2212; 1</entry></row><row><entry/><entry/><entry/><entry/><entry>Fm &#x3e;&#x3e; 24</entry></row><row><entry/><entry/><entry/><entry/><entry>If Ea &#x3e; Em + 4</entry><entry>Fa &#x3c;&#x3c; 8</entry><entry>Ea &#x2212; 1</entry><entry>Bypass</entry></row><row><entry/><entry/><entry/><entry/><entry>(Fm)</entry><entry/><entry/><entry>(Acc)</entry></row><row><entry>Ea &#x3c; Em</entry><entry>6</entry><entry>Em = Ea + 1</entry><entry/><entry>Fm</entry><entry>Fa &#x3e;&#x3e; 8</entry><entry>Em</entry></row><row><entry/><entry>7</entry><entry>Em = Ea + 2</entry><entry/><entry>Fm</entry><entry>Fa &#x3e;&#x3e; 16</entry><entry>Em</entry></row><row><entry/><entry>8</entry><entry>Em = Ea + 3</entry><entry/><entry>Fm</entry><entry>Fa &#x3e;&#x3e; 24</entry><entry>Em</entry></row><row><entry/><entry>9</entry><entry>Em &#x3e; Ea + 3</entry><entry/><entry>Fm</entry><entry>(Fa)</entry><entry>Em</entry><entry>Bypass</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry/><entry/><entry>(Mult)</entry></row><row><entry namest="1" nameend="8" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0178" num="0182">A Floating point Multiply-Add Accumulate Unit using Carry-Save addition and accumulation with a radix-8 exponent is described. This balances the critical timing in the exponent unit against that of the significand unit. Also, unlike utilizing sign-magnitude representation as proposed in the Floating point IEEE-754 standard, a 2's complement number system is used to represent a positive and a negative significand which also carries the sign of the operand. This avoids unnecessary subtraction of significands when the exponents are equal to determine the greater of the two as imposed by the IEEE-754 standard. Introducing 2's complement representation requires novel Leading Zero (Leading One) Detector (Predictor) which works on both positive and negative numbers. The same applies to Overflow (OV) detection. In addition, it is necessary to determine when addition of Carry and Sum results in a long Sign Extension (SE), requiring introduction of novel design features.</p><p id="p-0179" num="0183">Floating point Multiply-Add-Accumulate Unit, supporting BF16 format for Multiply-Accumulate operations, and FP32 Single-Precision Addition complying to IEEE 754 Standard is described. The Multiply-Accumulate unit uses higher internal precision and longer accumulator by converting the operands into a higher-radix and longer internal 2's complement significand representation to facilitate precision as well as comparison and operation with negative numbers. The addition is performed using Carry-Save format to avoid long carry propagation and speed up the operation. Operations including overflow detection, zero detection and sign extension are adopted for 2s complement and Carry-Save format. Handling of Overflow and Sign Extension allows for fast operation relatively independent on the size of the accumulator. Rounding suitable for Machine Learning is introduced in the Accumulate operation without timing impact, considerably improving the accuracy of the computation.</p><heading id="h-0019" level="2">Exception Handling</heading><p id="p-0180" num="0184"><figref idref="DRAWINGS">FIGS. <b>10</b> to <b>21</b></figref> are referred to in connection with exception handling in circuits and methods like those described above. Floating point numbers can assume values which are special cases such as: positive or negative infinity, zero, and de-normalized numbers according to the particular encoding format utilized to represent the significand and exponent.</p><p id="p-0181" num="0185"><figref idref="DRAWINGS">FIG. <b>10</b></figref> illustrates a Floating Point Number Range <b>1000</b> shown in block <b>1010</b> as a horizontal number line divided into regions of interest by numerous terms. The definitions of the terms are defined in Table-1.</p><heading id="h-0020" level="2">Floating Point Special Numbers</heading><p id="p-0182" num="0186">The following list shown in Table-1 comprises three columns. The first column lists the definition of a special floating point numbers. The second column lists the value in BF16 floating point encoding format. The third column shows the value in floating point encoding FP32 format.</p><p id="p-0183" num="0187">In the comment columns of Table 1, the term (+)Nan includes the value 7F81 in BF16 and the value 7F800001 in FP32, as both conventions for representing NaN. The term (+)Norm is listed as (+)Pi, (3.14 . . . ) and the term (&#x2212;)Norm is listed as (&#x2212;)Pi for testing purposes. The terms (+)DeNorm and (&#x2212;)DeNorm are the smallest representable values. There are two representations of (+)Zero and the (&#x2212;)Zero, the difference being the most significant sign bit. This is also true for all the other terms regarding the sign bit.</p><p id="p-0184" num="0000"><tables id="TABLE-US-00004" num="00004"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="49pt" align="left"/><colspec colname="2" colwidth="35pt" align="left"/><colspec colname="3" colwidth="49pt" align="left"/><colspec colname="4" colwidth="42pt" align="left"/><colspec colname="5" colwidth="42pt" align="left"/><thead><row><entry namest="1" nameend="5" rowsep="1">TABLE 1</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row><row><entry/><entry/><entry/><entry>BF16</entry><entry>FP32</entry></row><row><entry>Definition</entry><entry>BF16</entry><entry>FP32</entry><entry>Comments</entry><entry>Comments</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>(+)Infinity</entry><entry>0x7F80</entry><entry>0x7F800000</entry><entry/><entry/></row><row><entry>(&#x2212;)Infinity</entry><entry>0xFF80</entry><entry>0xFF800000</entry><entry/><entry/></row><row><entry>(+)Zero</entry><entry>0x0000</entry><entry>0x00000000</entry><entry/><entry/></row><row><entry>(&#x2212;)Zero</entry><entry>0x8000</entry><entry>0x80000000</entry><entry/><entry/></row><row><entry>(+)Nan</entry><entry>0x7FC0</entry><entry>0x7FC00000</entry><entry>or 7F81</entry><entry>or 7F800001</entry></row><row><entry>(&#x2212;)Nan</entry><entry>0xFFC0</entry><entry>0xFFC00000</entry><entry/><entry/></row><row><entry/><entry/><entry/><entry>(+)Pi is a</entry><entry/></row><row><entry>(+)Norm</entry><entry>0x4049</entry><entry>0x40490FDB</entry><entry>value for</entry><entry/></row><row><entry/><entry/><entry/><entry>testing</entry><entry/></row><row><entry/><entry/><entry/><entry>(&#x2212;)Pi is a</entry><entry/></row><row><entry>(&#x2212;)Norm</entry><entry>0xC049</entry><entry>0xC0490FDB</entry><entry>value for</entry><entry/></row><row><entry/><entry/><entry/><entry>testing</entry><entry/></row><row><entry>(+)MaxNorm</entry><entry>0x7F7F</entry><entry>0x7F7FFFFF</entry><entry/><entry/></row><row><entry>(&#x2212;)MaxNorm</entry><entry>0xFF7F</entry><entry>0xFF7FFFFF</entry><entry/><entry/></row><row><entry>(+)MinNorm</entry><entry>0x0080</entry><entry>0x00800000</entry><entry/><entry/></row><row><entry>(&#x2212;)MinNorm</entry><entry>0x8080</entry><entry>0x80800000</entry><entry/><entry/></row><row><entry>(+)DeNorm</entry><entry>0x0001</entry><entry>0x00000001</entry><entry>Smallest</entry><entry/></row><row><entry>(&#x2212;)DeNorm</entry><entry>0x8001</entry><entry>0x80000001</entry><entry>Smallest</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0185" num="0188">The BFloat16 floating-point format, also known as the brain floating-point format, (sometimes &#x201c;BF16&#x201d;) is a 16-bit numerical encoding format. BF16 retains an approximate dynamic range of an IEEE single precision number. The BF16 format includes a 7-bit fraction, also known as a mantissa or significand, an &#x201c;implied bit&#x201d; or &#x201c;hidden bit&#x201d;, an 8-bit exponent, and one sign bit. Single-precision floating point values can convert to BF16 for accelerating machine learning. The dynamic range is the same as single-precision FP32 (8-bit exponent) using an 8-bit precision rather than a 24-bit fraction. BFloat16 can lower memory requirements, can lower storage requirements, and can increase machine learning algorithm calculation speeds. BF16 is a truncated 16-bit version of the 32-bit single-precision IEEE 754 format with the intent of accelerating Machine Learning.</p><p id="p-0186" num="0189">A second numerical format is the IEEE 754 single-precision 32-bit floating point (FP32). The IEEE 754 single-precision 32-bit floating point includes a 23-bit fraction, an &#x201c;implied&#x201d; bit or &#x201c;hidden bit&#x201d;, an 8-bit exponent, and one sign bit.</p><p id="p-0187" num="0190">The following contents of Table-2 lists BFloat16 terms and their numerical definitions.</p><p id="p-0188" num="0000"><tables id="TABLE-US-00005" num="00005"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="42pt" align="left"/><colspec colname="3" colwidth="56pt" align="center"/><colspec colname="4" colwidth="63pt" align="left"/><thead><row><entry namest="1" nameend="4" rowsep="1">TABLE 2</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row><row><entry>Term Name</entry><entry>Hex Value</entry><entry>Decimal Value</entry><entry>Comments</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="42pt" align="left"/><colspec colname="3" colwidth="56pt" align="char" char="."/><colspec colname="4" colwidth="63pt" align="left"/><tbody valign="top"><row><entry>Zero offset</entry><entry>0x7F</entry><entry>127</entry><entry/></row><row><entry>Exponent Bias</entry><entry>0x7F</entry><entry>127</entry><entry/></row><row><entry>Emin</entry><entry>0x01-0x7F</entry><entry>&#x2212;126</entry><entry>1-127</entry></row><row><entry>Emax</entry><entry>0xFE-0x7F</entry><entry>+127</entry><entry>254-127</entry></row><row><entry>Exponent</entry><entry>0x00</entry><entry>0</entry><entry>(+)Zero or (&#x2212;)Zero</entry></row><row><entry>Exponent</entry><entry>0x01-0xFE</entry><entry>1-254</entry><entry>Normalized Value</entry></row><row><entry>Exponent</entry><entry>0xFF</entry><entry>255</entry><entry>&#xb1;Infinity</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0189" num="0191">The following contents of Table-3 lists additional BFloat16 terms and their numerical definitions in binary format. Positive and negative infinity are defined as when all the exponent bits equal one and when all the fraction bits equal zero. Positive and negative NaN (not a number) are defined as when all the exponent bits equal one and when not all the fraction bits equal zero. Positive and negative DeNorm are defined as when all the exponent bits equal zero and when not all the fraction bits equal zero. Positive or negative infinity, NaN, or DeNorm depend on the sign bit.</p><p id="p-0190" num="0000"><tables id="TABLE-US-00006" num="00006"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="42pt" align="left"/><colspec colname="2" colwidth="21pt" align="center"/><colspec colname="3" colwidth="42pt" align="left"/><colspec colname="4" colwidth="28pt" align="left"/><colspec colname="5" colwidth="84pt" align="left"/><thead><row><entry namest="1" nameend="5" rowsep="1">TABLE 3</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row><row><entry>Term</entry><entry>Sign</entry><entry>Exponent</entry><entry>Fraction</entry><entry>Comments</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>+Inf</entry><entry>0</entry><entry>11111111</entry><entry>0000000</entry><entry>Positive Infinity</entry></row><row><entry>&#x2212;Inf</entry><entry>1</entry><entry>11111111</entry><entry>0000000</entry><entry>Negative Infinity</entry></row><row><entry>+NaN</entry><entry>0</entry><entry>11111111</entry><entry>xxxxxxx</entry><entry>(Not a Number)</entry></row><row><entry/><entry/><entry/><entry/><entry>Not all fraction bits are Zero</entry></row><row><entry>&#x2212;NaN</entry><entry>1</entry><entry>11111111</entry><entry>xxxxxxx</entry><entry>(Not a Number)</entry></row><row><entry/><entry/><entry/><entry/><entry>Not all fraction bits are Zero</entry></row><row><entry>+DeNorm</entry><entry>0</entry><entry>00000000</entry><entry>xxxxxxx</entry><entry>Denormalized Numbers</entry></row><row><entry/><entry/><entry/><entry/><entry>Not all fraction bits are Zero</entry></row><row><entry>&#x2212;DeNorm</entry><entry>1</entry><entry>00000000</entry><entry>xxxxxxx</entry><entry>Denormalized Numbers Not</entry></row><row><entry/><entry/><entry/><entry/><entry>all fraction bits are Zero</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0191" num="0192">In some embodiments, the exception processing unit for machine learning operations does not support DeNormal or NaN Operations. The DeNormal numbers are treated as zero, and the NaN numbers are treated as infinity.</p><heading id="h-0021" level="2">Exceptions</heading><p id="p-0192" num="0193">Chapter 7 of the IEEE std 754-2019 specification describes the five categories of floating-point exceptions listed below. According to one embodiment, three of the following categories are implemented: (1) Invalid Operation, (3) overflow, and (4) underflow. This embodiment does not support division by zero and inexact.<ul id="ul0012" list-style="none">    <li id="ul0012-0001" num="0000">    <ul id="ul0013" list-style="none">        <li id="ul0013-0001" num="0194">1) Invalid Operation</li>        <li id="ul0013-0002" num="0195">2) Division by zero</li>        <li id="ul0013-0003" num="0196">3) Overflow</li>        <li id="ul0013-0004" num="0197">4) Underflow</li>        <li id="ul0013-0005" num="0198">5) Inexact</li>    </ul>    </li></ul></p><p id="p-0193" num="0199">According to some other embodiments, four of the categories are implemented: (1) Invalid Operation, (2) division by zero, (3) overflow, and (4) underflow. According to other embodiments, all five categories are implemented.</p><heading id="h-0022" level="2">Invalid Operation</heading><p id="p-0194" num="0200">The IEEE std 754-2019 specification describes the following as invalid operations:<ul id="ul0014" list-style="none">    <li id="ul0014-0001" num="0201">a) any general-computational operation on a signalling NaN;</li>    <li id="ul0014-0002" num="0202">b) multiplication: multiplication(0, &#x221e;) or multiplication(&#x221e;, 0);</li>    <li id="ul0014-0003" num="0203">c) fusedMultiplyAdd: fusedMultiplyAdd(0, &#x221e;, c) or fusedMultiplyAdd(&#x221e;, 0, c);</li>    <li id="ul0014-0004" num="0204">d) addition or subtraction or fusedMultiplyAdd: magnitude subtraction of infinities, such as addition(+&#x221e;, &#x2212;&#x221e;);</li>    <li id="ul0014-0005" num="0205">e) division: division(0, 0) or division(&#x221e;, &#x221e;);</li>    <li id="ul0014-0006" num="0206">f) remainder: remainder(x, y), when y is zero or x is infinite, and neither is a NaN;</li>    <li id="ul0014-0007" num="0207">g) SquareRoot if the operand is negative; and</li>    <li id="ul0014-0008" num="0208">h) quantize when the result does not fit in the destination format or when one operand is finite and the other is infinite.</li></ul></p><p id="p-0195" num="0209">According to one embodiment, the exception processing in a carry-save accumulation unit implements the invalid operations a/b/c/d listed above. According to another embodiment, any combination of the categories (a) through (h) are possible.</p><heading id="h-0023" level="2">Invalid Operation Exception</heading><p id="p-0196" num="0210">The following contents of Table-4 list invalid operations that generate exceptions.</p><p id="p-0197" num="0000"><tables id="TABLE-US-00007" num="00007"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="49pt" align="left"/><colspec colname="2" colwidth="28pt" align="left"/><colspec colname="3" colwidth="35pt" align="left"/><colspec colname="4" colwidth="49pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><thead><row><entry namest="1" nameend="5" rowsep="1">TABLE 4</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row><row><entry/><entry>First</entry><entry>Second</entry><entry/><entry/></row><row><entry>Action</entry><entry>Operand</entry><entry>Operand</entry><entry>Comment</entry><entry>Result</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>Multiplier</entry><entry>(&#xb1;)Inf</entry><entry>(&#xb1;)0</entry><entry>And vice versa</entry><entry>Positive infinity</entry></row><row><entry>Adder Norm/</entry><entry>(+)Inf</entry><entry>(&#x2212;)Inf</entry><entry>And vice versa</entry><entry>Positive infinity</entry></row><row><entry>Rounding</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0024" level="2">Overflow Exception</heading><p id="p-0198" num="0211">The following contents of Table-5 list overflow exceptions for the one example of the two operands MaxNorm is multiplied by MaxNorm. These overflow exceptions generate the result &#x201c;Signed Infinity&#x201d;. This overflow exception occurs when the results are larger than Signed MaxNorm and only when no Infinity value exists on the input to the operand.</p><p id="p-0199" num="0000"><tables id="TABLE-US-00008" num="00008"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="49pt" align="left"/><colspec colname="2" colwidth="35pt" align="left"/><colspec colname="3" colwidth="42pt" align="left"/><colspec colname="4" colwidth="35pt" align="left"/><colspec colname="5" colwidth="56pt" align="left"/><thead><row><entry namest="1" nameend="5" rowsep="1">TABLE 5</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row><row><entry/><entry>First</entry><entry>Second</entry><entry/><entry/></row><row><entry>Action</entry><entry>Operand</entry><entry>Operand</entry><entry>Comment</entry><entry>Result</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>Multiplier</entry><entry>MaxNorm</entry><entry>MaxNorm</entry><entry>And vice</entry><entry>Signed Infinity</entry></row><row><entry/><entry/><entry/><entry>versa</entry><entry/></row><row><entry>Adder Norm/</entry><entry>MaxNorm</entry><entry>MaxNorm</entry><entry>And vice</entry><entry>Signed Infinity</entry></row><row><entry>Rounding</entry><entry/><entry/><entry>versa</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0025" level="2">Underflow Exception</heading><p id="p-0200" num="0212">In one embodiment, several cases exist where the results are smaller than signed MinNorm. This exception occurs when there is no exact Zero value on the operand input. When adder Norm/Rounding: (+) Norm+(&#x2212;)Norm occurs, the result is the DeNormal value (but not Exact Zero), but the Actual result will be &#x201c;Signed Zero&#x201d;. See Table-6 showing one example where the two operands MinNorm is multiplied by MinNorm.</p><p id="p-0201" num="0000"><tables id="TABLE-US-00009" num="00009"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="49pt" align="left"/><colspec colname="2" colwidth="35pt" align="left"/><colspec colname="3" colwidth="42pt" align="left"/><colspec colname="4" colwidth="49pt" align="left"/><colspec colname="5" colwidth="42pt" align="left"/><thead><row><entry namest="1" nameend="5" rowsep="1">TABLE 6</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row><row><entry/><entry>First</entry><entry>Second</entry><entry/><entry/></row><row><entry>Action</entry><entry>Operand</entry><entry>Operand</entry><entry>Comment</entry><entry>Result</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>Multiplier</entry><entry>MinNorm</entry><entry>MinNorm</entry><entry>And vice versa</entry><entry>Signed Zero</entry></row><row><entry>Adder Norm/</entry><entry>(+)Norm</entry><entry>(&#x2212;)Norm</entry><entry>And vice versa</entry><entry>Signed Zero</entry></row><row><entry>Rounding</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0202" num="0213">In some embodiments, exception processing can be divided into &#x201c;exception flag generation&#x201d; and &#x201c;exception result generation&#x201d;. Exceptions are processed for example on both floating-point multiplier block <b>1110</b> and the floating-point carry-save adder block <b>1130</b> of <figref idref="DRAWINGS">FIG. <b>12</b>A</figref>.</p><heading id="h-0026" level="2">Exception Flag Generation</heading><p id="p-0203" num="0214">In some embodiments, Floating-Point multiplier exception flags are provided for: (1) overflow, (2) underflow, and (3) Invalid.</p><p id="p-0204" num="0215">In some embodiments, the following floating-point adder exception flags are provided: (1) the overflow, (2) the underflow, and (3) and the invalid.</p><heading id="h-0027" level="2">Exception Result Generation</heading><p id="p-0205" num="0216">The operations of exception processing are explained on the IEEE std 754-2019 Chapter 6. The following two tables summarize one embodiment and implementation for multiplication and adder operations.</p><heading id="h-0028" level="2">Multiplier Operations</heading><p id="p-0206" num="0217">According to one embodiment, the contents of Table-7 list multiplication operations with comments of invalid, underflow, and overflow operations.</p><p id="p-0207" num="0000"><tables id="TABLE-US-00010" num="00010"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="56pt" align="left"/><colspec colname="2" colwidth="42pt" align="left"/><colspec colname="3" colwidth="49pt" align="left"/><colspec colname="4" colwidth="28pt" align="left"/><colspec colname="5" colwidth="42pt" align="left"/><thead><row><entry namest="1" nameend="5" rowsep="1">TABLE 7</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row><row><entry>Operation</entry><entry>Operand #1</entry><entry>Operand #2</entry><entry>Result</entry><entry>Comment</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>Multiplication</entry><entry>(+)Zero</entry><entry>(+)Zero</entry><entry>(+)Zero</entry><entry/></row><row><entry>Multiplication</entry><entry>(+)Zero</entry><entry>(&#x2212;)Zero</entry><entry>(&#x2212;)Zero</entry><entry/></row><row><entry>Multiplication</entry><entry>(+)Zero</entry><entry>(+)Inf</entry><entry>(+)Inf</entry><entry>Invalid</entry></row><row><entry>Multiplication</entry><entry>(+)Zero</entry><entry>(&#x2212;)Inf</entry><entry>(+)Inf</entry><entry>Invalid</entry></row><row><entry>Multiplication</entry><entry>(+)Zero</entry><entry>(+)Norm</entry><entry>(+)Zero</entry><entry/></row><row><entry>Multiplication</entry><entry>(+)Zero</entry><entry>(&#x2212;)Norm</entry><entry>(&#x2212;)Zero</entry><entry/></row><row><entry>Multiplication</entry><entry>(&#x2212;)Zero</entry><entry>(&#x2212;)Zero</entry><entry>(+)Zero</entry><entry/></row><row><entry>Multiplication</entry><entry>(&#x2212;)Zero</entry><entry>(+)Inf</entry><entry>(+)Inf</entry><entry>Invalid</entry></row><row><entry>Multiplication</entry><entry>(&#x2212;)Zero</entry><entry>(&#x2212;)Inf</entry><entry>(+)Inf</entry><entry>Invalid</entry></row><row><entry>Multiplication</entry><entry>(&#x2212;)Zero</entry><entry>(+)Norm</entry><entry>(&#x2212;)Zero</entry><entry/></row><row><entry>Multiplication</entry><entry>(&#x2212;)Zero</entry><entry>(&#x2212;)Norm</entry><entry>(+)Zero</entry><entry/></row><row><entry>Multiplication</entry><entry>(+)Inf</entry><entry>(+)Inf</entry><entry>(+)Inf</entry><entry/></row><row><entry>Multiplication</entry><entry>(+)Inf</entry><entry>(&#x2212;)Inf</entry><entry>(&#x2212;)Inf</entry><entry/></row><row><entry>Multiplication</entry><entry>(+)Inf</entry><entry>(+)Norm</entry><entry>(+)Inf</entry><entry/></row><row><entry>Multiplication</entry><entry>(+)Inf</entry><entry>(&#x2212;)Norm</entry><entry>(&#x2212;)Inf</entry><entry/></row><row><entry>Multiplication</entry><entry>(&#x2212;)Inf</entry><entry>(&#x2212;)Inf</entry><entry>(+)Inf</entry><entry/></row><row><entry>Multiplication</entry><entry>(&#x2212;)Inf</entry><entry>(+)Norm</entry><entry>(&#x2212;)Inf</entry><entry/></row><row><entry>Multiplication</entry><entry>(&#x2212;)Inf</entry><entry>(&#x2212;)Norm</entry><entry>(+)Inf</entry><entry/></row><row><entry>Multiplication</entry><entry>(+)Norm</entry><entry>(&#x2212;)Norm</entry><entry>(&#x2212;)Norm</entry><entry/></row><row><entry>Multiplication</entry><entry>(+)Norm</entry><entry>(+)Norm</entry><entry>(+)Norm</entry><entry/></row><row><entry>Multiplication</entry><entry>(&#x2212;)Norm</entry><entry>(&#x2212;)Norm</entry><entry>(+)Norm</entry><entry/></row><row><entry>Multiplication</entry><entry>(+)MaxNorm</entry><entry>(+)MaxNorm</entry><entry>(+)Inf</entry><entry>Overflow</entry></row><row><entry>Multiplication</entry><entry>(+)MaxNorm</entry><entry>(&#x2212;)MaxNorm</entry><entry>(&#x2212;)Inf</entry><entry>Overflow</entry></row><row><entry>Multiplication</entry><entry>(+)MaxNorm</entry><entry>(+)MinNorm</entry><entry>(+)Norm</entry><entry/></row><row><entry>Multiplication</entry><entry>(+)MaxNorm</entry><entry>(&#x2212;)MinNorm</entry><entry>(&#x2212;)Norm</entry><entry/></row><row><entry>Multiplication</entry><entry>(+)MaxNorm</entry><entry>(+)DeNorm</entry><entry>(+)Zero</entry><entry/></row><row><entry>Multiplication</entry><entry>(+)MaxNorm</entry><entry>(&#x2212;)DeNorm</entry><entry>(&#x2212;)Zero</entry><entry/></row><row><entry>Multiplication</entry><entry>(&#x2212;)MaxNorm</entry><entry>(&#x2212;)MaxNorm</entry><entry>(+)Inf</entry><entry>Overflow</entry></row><row><entry>Multiplication</entry><entry>(&#x2212;)MaxNorm</entry><entry>(+)MaxNorm</entry><entry>(&#x2212;)Inf</entry><entry/></row><row><entry>Multiplication</entry><entry>(&#x2212;)MaxNorm</entry><entry>(&#x2212;)MaxNorm</entry><entry>(+)Inf</entry><entry/></row><row><entry>Multiplication</entry><entry>(&#x2212;)MaxNorm</entry><entry>(+)DeNorm</entry><entry>(&#x2212;)Zero</entry><entry/></row><row><entry>Multiplication</entry><entry>(&#x2212;)MaxNorm</entry><entry>(&#x2212;)DeNorm</entry><entry>(+)Zero</entry><entry/></row><row><entry>Multiplication</entry><entry>(+)MinNorm</entry><entry>(+)MinNorm</entry><entry>(+)Zero</entry><entry>Underflow</entry></row><row><entry>Multiplication</entry><entry>(+)MinNorm</entry><entry>(&#x2212;)MinNorm</entry><entry>(&#x2212;)Zero</entry><entry>Underflow</entry></row><row><entry>Multiplication</entry><entry>(+)MinNorm</entry><entry>(+)DeNorm</entry><entry>(+)Zero</entry><entry/></row><row><entry>Multiplication</entry><entry>(+)MinNorm</entry><entry>(&#x2212;)DeNorm</entry><entry>(&#x2212;)Zero</entry><entry/></row><row><entry>Multiplication</entry><entry>(&#x2212;)MinNorm</entry><entry>(&#x2212;)MinNorm</entry><entry>(+)Zero</entry><entry>Underflow</entry></row><row><entry>Multiplication</entry><entry>(&#x2212;)MinNorm</entry><entry>(+)DeNorm</entry><entry>(&#x2212;)Zero</entry><entry/></row><row><entry>Multiplication</entry><entry>(&#x2212;)MinNorm</entry><entry>(&#x2212;)DeNorm</entry><entry>(+)Zero</entry><entry/></row><row><entry>Multiplication</entry><entry>(+)DeNorm</entry><entry>(+)DeNorm</entry><entry>(+)Zero</entry><entry/></row><row><entry>Multiplication</entry><entry>(+)DeNorm</entry><entry>(&#x2212;)DeNorm</entry><entry>(&#x2212;)Zero</entry><entry/></row><row><entry>Multiplication</entry><entry>(&#x2212;)DeNorm</entry><entry>(&#x2212;)DeNorm</entry><entry>(+)Zero</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><heading id="h-0029" level="2">Addition Operations</heading><p id="p-0208" num="0218">According to one embodiment, the contents of Table-8 list of adder operations with comments of Invalid and Overflow operations.</p><p id="p-0209" num="0000"><tables id="TABLE-US-00011" num="00011"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="42pt" align="left"/><colspec colname="2" colwidth="42pt" align="left"/><colspec colname="3" colwidth="49pt" align="left"/><colspec colname="4" colwidth="42pt" align="left"/><colspec colname="5" colwidth="42pt" align="left"/><thead><row><entry namest="1" nameend="5" rowsep="1">TABLE 8</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row><row><entry>Operation</entry><entry>Operand #1</entry><entry>Operand #2</entry><entry>Result</entry><entry>Comment</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>Adder</entry><entry>(+)Zero</entry><entry>(+)Zero</entry><entry>(+)Zero</entry><entry/></row><row><entry>Adder</entry><entry>(+)Zero</entry><entry>(&#x2212;)Zero</entry><entry>(+)Zero</entry><entry/></row><row><entry>Adder</entry><entry>(+)Zero</entry><entry>(+)Inf</entry><entry>(+)Inf</entry><entry/></row><row><entry>Adder</entry><entry>(+)Zero</entry><entry>(&#x2212;)Inf</entry><entry>(&#x2212;)Inf</entry><entry/></row><row><entry>Adder</entry><entry>(+)Zero</entry><entry>(+)Norm</entry><entry>(+)Norm</entry><entry/></row><row><entry>Adder</entry><entry>(+)Zero</entry><entry>(&#x2212;)Norm</entry><entry>(&#x2212;)Norm</entry><entry/></row><row><entry>Adder</entry><entry>(&#x2212;)Zero</entry><entry>(&#x2212;)Zero</entry><entry>(&#x2212;)Zero</entry><entry/></row><row><entry>Adder</entry><entry>(&#x2212;)Zero</entry><entry>(+)Inf</entry><entry>(+)Inf</entry><entry/></row><row><entry>Adder</entry><entry>(&#x2212;)Zero</entry><entry>(&#x2212;)Inf</entry><entry>(&#x2212;)Inf</entry><entry/></row><row><entry>Adder</entry><entry>(&#x2212;)Zero</entry><entry>(+)Norm</entry><entry>(+)Norm</entry><entry/></row><row><entry>Adder</entry><entry>(&#x2212;)Zero</entry><entry>(&#x2212;)Norm</entry><entry>(&#x2212;)Norm</entry><entry/></row><row><entry>Adder</entry><entry>(+)Inf</entry><entry>(+)Inf</entry><entry>(+)Inf</entry><entry/></row><row><entry>Adder</entry><entry>(+)Inf</entry><entry>(&#x2212;)Inf</entry><entry>(+)Inf</entry><entry>Invalid</entry></row><row><entry>Adder</entry><entry>(+)Inf</entry><entry>(+)Norm</entry><entry>(+)Inf</entry><entry/></row><row><entry>Adder</entry><entry>(+)Inf</entry><entry>(&#x2212;)Norm</entry><entry>(+)Inf</entry><entry/></row><row><entry>Adder</entry><entry>(&#x2212;)Inf</entry><entry>(&#x2212;)Inf</entry><entry>(&#x2212;)Inf</entry><entry/></row><row><entry>Adder</entry><entry>(&#x2212;)Inf</entry><entry>(+)Norm</entry><entry>(&#x2212;)Inf</entry><entry/></row><row><entry>Adder</entry><entry>(&#x2212;)Inf</entry><entry>(&#x2212;)Norm</entry><entry>(&#x2212;)Inf</entry><entry/></row><row><entry>Adder</entry><entry>(+)Norm</entry><entry>(&#x2212;)Norm</entry><entry>(+)Norm</entry><entry/></row><row><entry>Adder</entry><entry>(+)Norm</entry><entry>(+)Norm</entry><entry>(+)Norm</entry><entry/></row><row><entry>Adder</entry><entry>(&#x2212;)Norm</entry><entry>(&#x2212;)Norm</entry><entry>(&#x2212;)Norm</entry><entry/></row><row><entry>Adder</entry><entry>(+)MaxNorm</entry><entry>(+)MaxNorm</entry><entry>(+)Inf</entry><entry>Overflow</entry></row><row><entry>Adder</entry><entry>(+)MaxNorm</entry><entry>(&#x2212;)MaxNorm</entry><entry>(+)Zero</entry><entry/></row><row><entry>Adder</entry><entry>(+)MaxNorm</entry><entry>(+)MinNorm</entry><entry>(+)MaxNorm</entry><entry/></row><row><entry>Adder</entry><entry>(+)MaxNorm</entry><entry>(&#x2212;)MinNorm</entry><entry>(+)MaxNorm</entry><entry/></row><row><entry>Adder</entry><entry>(+)MaxNorm</entry><entry>(+)DeNorm</entry><entry>(+)MaxNorm</entry><entry/></row><row><entry>Adder</entry><entry>(+)MaxNorm</entry><entry>(&#x2212;)DeNorm</entry><entry>(+)MaxNorm</entry><entry/></row><row><entry>Adder</entry><entry>(&#x2212;)MaxNorm</entry><entry>(&#x2212;)MaxNorm</entry><entry>(&#x2212;)Inf</entry><entry>Overflow</entry></row><row><entry>Adder</entry><entry>(&#x2212;)MaxNorm</entry><entry>(+)MinNorm</entry><entry>(&#x2212;)MaxNorm</entry><entry/></row><row><entry>Adder</entry><entry>(&#x2212;)MaxNorm</entry><entry>(&#x2212;)MinNorm</entry><entry>(&#x2212;)MaxNorm</entry><entry/></row><row><entry>Adder</entry><entry>(&#x2212;)MaxNorm</entry><entry>(+)DeNorm</entry><entry>(&#x2212;)MaxNorm</entry><entry/></row><row><entry>Adder</entry><entry>(&#x2212;)MaxNorm</entry><entry>(&#x2212;)DeNorm</entry><entry>(&#x2212;)MaxNorm</entry><entry/></row><row><entry>Adder</entry><entry>(+)MinNorm</entry><entry>(+)MinNorm</entry><entry>(+)Norm</entry><entry/></row><row><entry>Adder</entry><entry>(+)MinNorm</entry><entry>(&#x2212;)MinNorm</entry><entry>(+)Zero</entry><entry/></row><row><entry>Adder</entry><entry>(+)MinNorm</entry><entry>(+)DeNorm</entry><entry>(+)MinNorm</entry><entry/></row><row><entry>Adder</entry><entry>(+)MinNorm</entry><entry>(&#x2212;)DeNorm</entry><entry>(+)MinNorm</entry><entry/></row><row><entry>Adder</entry><entry>(&#x2212;)MinNorm</entry><entry>(&#x2212;)MinNorm</entry><entry>(&#x2212;)Norm</entry><entry/></row><row><entry>Adder</entry><entry>(&#x2212;)MinNorm</entry><entry>(+)DeNorm</entry><entry>(&#x2212;)MinNorm</entry><entry/></row><row><entry>Adder</entry><entry>(&#x2212;)MinNorm</entry><entry>(&#x2212;)DeNorm</entry><entry>(&#x2212;)MinNorm</entry><entry/></row><row><entry>Adder</entry><entry>(+)DeNorm</entry><entry>(+)DeNorm</entry><entry>(+)Zero</entry><entry/></row><row><entry>Adder</entry><entry>(+)DeNorm</entry><entry>(&#x2212;)DeNorm</entry><entry>(+)Zero</entry><entry/></row><row><entry>Adder</entry><entry>(&#x2212;)DeNorm</entry><entry>(&#x2212;)DeNorm</entry><entry>(&#x2212;)Zero</entry></row><row><entry namest="1" nameend="5" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0210" num="0219">An exception handling circuit is described herein to detect at least one invalid operation or result in the multiplier and at least one invalid operation or result in the adder, according to the floating point encoding format, and to set the output operand of the multiplier or adder to a value useable in further processing.</p><heading id="h-0030" level="2">High Level Architecture</heading><p id="p-0211" num="0220"><figref idref="DRAWINGS">FIG. <b>11</b></figref> illustrates one example high level architecture block diagram <b>1100</b> depicting elements of exception processing in carry-save accumulation unit for machine learning.</p><p id="p-0212" num="0221">In one embodiment, the exception processing in a carry-save accumulation unit design comprises three different input signals. These are Operand-A <b>1113</b>, Operand-B <b>1114</b>, and Operand-C <b>1116</b>. Operand-A <b>1113</b> can be in both BF16 and FP32 formats. Operand-B <b>1114</b> is a BF16 format and Operand-C <b>1116</b> is FP32 format. The Operands are also known as inputs.</p><p id="p-0213" num="0222">A multiplier exception Processing block <b>1102</b> ingests Operand-A <b>1113</b> and Operand-B <b>1114</b>. The output of the multiplier exception Processing block <b>1102</b> is connected to the following: (1) multiplier exception flags <b>1104</b> via bus <b>1106</b>, (2) exception output control signal generation <b>1126</b> via bus multiplier exception condition signals <b>1108</b>, and (3) multiplier exception results <b>1115</b>.</p><p id="p-0214" num="0223">Operand-C, <b>1116</b>, in FP32 format enters the Operand-C Base Conversion block <b>1118</b> and outputs to: (1) the exception output control signal generation <b>1126</b>, via Operand-C exception condition signals bus <b>1120</b>, and (2) to the carry-save adder block <b>1130</b> via bus <b>1122</b>.</p><p id="p-0215" num="0224">The carry-save adder (CSA) block <b>1130</b> processes the two inputs: (1) the multiplier exception results <b>1115</b>, and (2) the output from the Operand-C Base Conversion block <b>1118</b>, via bus <b>1122</b>. In one embodiment, the CSA block <b>1130</b> has an Accumulator Loop <b>1124</b> which will output data only at the end of the loop. The CSA block <b>1130</b> outputs via bus <b>1132</b>.</p><p id="p-0216" num="0225">An adder normalization exception processing block <b>1134</b> ingests two inputs. The first input is the CSA block <b>1130</b> output via bus <b>1132</b>. The second input is the exception control <b>1128</b> from the exception output control signal generation <b>1126</b> block.</p><p id="p-0217" num="0226">The outputs from the adder normalization exception processing block <b>1134</b> are the adder exception results <b>1139</b> and the bus <b>1138</b> which routes to the adder exception flags block <b>1140</b>.</p><p id="p-0218" num="0227">Operand-A is a 32-Bit bus and provides BF16 input for a multiplication operation and FP32 for the addition operation. Operand-B is only used for multiplication operation purpose and always has BF16 16-Bit input format. Operand-C is used for addition operation or accumulator initialization, and always has an FP32 32-bit input format. The Multiplier part has separated output flags (overflow, underflow and invalid) and the multiplier exception results become the direct input of the adder. The exception condition signals for the adder are generated from the multiplier and connected to the &#x201c;exception control signals generation&#x201d; block and with the exception condition signals from Operand-C and the accumulator, is generating &#x201c;exception control&#x201d; signals for the adder normalization block for adder exception processing.</p><heading id="h-0031" level="2">Operating Modes</heading><p id="p-0219" num="0228">According to one embodiment, the exception processing in a carry-save accumulation unit design supports three different operating modes.</p><p id="p-0220" num="0229"><figref idref="DRAWINGS">FIG. <b>12</b>A</figref> illustrates a first operating mode <b>1200</b> according to the high level block diagram architecture of <figref idref="DRAWINGS">FIG. <b>11</b></figref>. A multiply-addition operation is shown with Operand-A <b>1113</b> in BF16 format which is first multiplied with Operand-B <b>1114</b> in BF16 format and then the product is added to Operand-C <b>1116</b> in FP32 format. The multiply-addition operation is done in a single operation. This operation generates both multiplication and addition exception flags and results.</p><p id="p-0221" num="0230">A multiplier block <b>1110</b> ingests Operand-A <b>1113</b> and Operand-B <b>1114</b>. The output of the multiplier block <b>1110</b> is connected to the following: (1) multiplier exception flags <b>1104</b> block via the bus <b>1106</b>, and (2) connects the multiplier exception results <b>1115</b> to the carry-save adder (CSA) block <b>1130</b>. In some embodiments, the first operating mode uses the multiplier exception flags <b>1104</b> for statistical purposes.</p><p id="p-0222" num="0231">The carry-save adder (CSA) block <b>1130</b> processes the following two inputs: (1) multiplier exception results <b>1115</b> and (2) Operand-C <b>1116</b>. The CSA block <b>1130</b> has two outputs. A first output is the adder exception results <b>1139</b> which routes to the output block <b>1129</b> in BF16 or FP32 format. A second output is the bus <b>1138</b> which routes to the adder exception flags block <b>1140</b>.</p><p id="p-0223" num="0232"><figref idref="DRAWINGS">FIG. <b>12</b>B</figref> illustrates a second operating mode <b>1202</b> according to the high level block diagram architecture of <figref idref="DRAWINGS">FIG. <b>11</b></figref>. A multiply-accumulation operation is shown with Operand-A <b>1113</b> in BF16 format multiplied with Operand-B <b>1114</b> in BF16 in a single operation. It generates the output results at the end of the accumulation loop. During the accumulation, the adder output and adder exceptions are disabled. This operation generates both multiplication and addition exception flags and results.</p><p id="p-0224" num="0233">A multiplier block <b>1110</b> ingests Operand-A <b>1113</b> and Operand-B <b>1114</b>. The output of the multiplier block <b>1110</b> is connected to the following blocks: (1) the multiplier exception flags <b>1104</b> via bus <b>1106</b>, and (2) the carry-save adder (CSA) <b>1130</b> via the multiplier exception results <b>1115</b>. In some embodiments, a second operating mode uses the multiplier exception flags <b>1104</b> for statistical purposes.</p><p id="p-0225" num="0234">The carry-save adder (CSA) block <b>1130</b> processes the following two inputs: (1) the multiplier exception results <b>1115</b> and the Accumulator Loop <b>1124</b>. The CSA block <b>1130</b> has two outputs. A first output is the adder exception results <b>1139</b> which routes to the output block <b>1131</b> in BF16 or FP32 format only at the end of the Accumulator Loop <b>1124</b>. A second output is the bus <b>1138</b> which routes to the adder exception flags block <b>1140</b>.</p><p id="p-0226" num="0235"><figref idref="DRAWINGS">FIG. <b>12</b>C</figref> illustrates a third operating mode <b>1203</b> according to the high level block diagram architecture of <figref idref="DRAWINGS">FIG. <b>11</b></figref>. An addition operation is shown with Operand-A <b>1113</b> in FP32 format summed with Operand-C <b>1116</b> in FP32 format. This operation generates only addition exception flags and results. The multiplier exception processing is disabled.</p><p id="p-0227" num="0236">The carry-save adder (CSA) block <b>1130</b> sums two inputs. The Operand-A <b>1113</b> in FP32 format is summed with Operand-C <b>1116</b> in FP32 format. The CSA block <b>1130</b> has two outputs. A first output is the adder exception results <b>1139</b> which routes to the output block <b>1129</b> in BF16 or FP32 format. A second output is the bus <b>1138</b> which routes to the adder exception flags block <b>1140</b>.</p><heading id="h-0032" level="2">Exception Processing Structure</heading><p id="p-0228" num="0237">According to some embodiments, exception processing is divided into &#x201c;exception flag generation&#x201d; and &#x201c;exception result generation&#x201d; and both parts can also be separated into multiplier and adder exceptions.</p><p id="p-0229" num="0238">The multiplier and adder flag generation produces the overflow, the underflow, and the invalid flags. These flags are shown below in the application as a group of circuit implementation.</p><p id="p-0230" num="0239">The multiplier and adder exception result generation comprises three conditions: (1) sign generation, (2) exponent generation, and (3) fraction generation. The sign has positive or negative outputs. The exponent can have All &#x2018;0&#x2019; and All &#x2018;1&#x2019; conditions when exception cases occur and normal output when there are no occurrences of exception cases. The fraction value can have two conditions; they are either All &#x2018;0&#x2019; for all the exception conditions and normal for non-exception cases.</p><p id="p-0231" num="0240"><figref idref="DRAWINGS">FIG. <b>13</b></figref> illustrates an exception processing structure <b>1300</b> depicted in a high level block diagram. A floating point multiply accumulator exceptions block <b>1308</b> outputs flags to the exceptions flag generation block <b>1304</b> and outputs results to the exceptions result generation block <b>1312</b>. The flags comprise state information, or data for processing by dedicated exception processing blocks as will be further described below.</p><p id="p-0232" num="0241">The exceptions flag generation block <b>1304</b> can output flags to either the multiplier exception flag generation block <b>1302</b> or the adder exception flag generation block <b>1306</b>. The multiplier exception flag generation block <b>1302</b> drives the multiplier overflow flag condition block <b>1381</b>, the multiplier underflow flag condition block <b>1382</b>, and the multiplier invalid flag condition block <b>1383</b>.</p><p id="p-0233" num="0242">The adder exception flag generation block <b>1306</b> drives the adder overflow flag condition block <b>1387</b>, the adder underflow flag condition block <b>1388</b>, and the adder Invalid flag condition block <b>1389</b>.</p><p id="p-0234" num="0243">The exceptions result generation block <b>1312</b> provides the results to the multiplier exception result generation block <b>1310</b> and the adder exception result generation block <b>1314</b>.</p><p id="p-0235" num="0244">The multiplier exception result generation block <b>1310</b> outputs the results to: (1) the multiplier sign generation condition block <b>1320</b>A, (2) the multiplier exponent generation condition block <b>1322</b>A, and (3) the multiplier fraction generation condition block <b>1324</b>A.</p><p id="p-0236" num="0245">The adder exception result generation block <b>1314</b> outputs the results to: (1) the adder sign generation condition block <b>1326</b>A, (2) the adder exponent generation condition block <b>1328</b>A, and (3) the adder fraction generation condition block <b>1330</b>A.</p><p id="p-0237" num="0246">The multiplier sign generation condition block <b>1320</b>A outputs conditions to blocks <b>1320</b>B and <b>1320</b>C. The multiplier exponent generation condition block <b>1322</b>A outputs conditions to blocks <b>1322</b>B, <b>1322</b>C, and <b>1322</b>D. The multiplier fraction generation condition block <b>1324</b>A outputs conditions to blocks <b>1324</b>B and <b>1324</b>C.</p><p id="p-0238" num="0247">The adder sign generation condition block <b>1326</b>A outputs conditions to blocks <b>1326</b>B and <b>1326</b>C. The adder exponent generation condition block <b>1328</b>A outputs conditions to blocks <b>1328</b>B, <b>1328</b>C, and <b>1328</b>D. The adder fraction generation condition block <b>1330</b>A outputs conditions to blocks <b>1330</b>B and <b>1330</b>C.</p><p id="p-0239" num="0248">The following figures, from <figref idref="DRAWINGS">FIG. <b>14</b>A</figref> to <figref idref="DRAWINGS">FIG. <b>21</b>B</figref>, illustrate schematic implementations of high level blocks shown in <figref idref="DRAWINGS">FIG. <b>13</b></figref>. For example, block <b>1381</b> in <figref idref="DRAWINGS">FIG. <b>13</b></figref> is implemented in <figref idref="DRAWINGS">FIGS. <b>14</b>A</figref>, block <b>1382</b> is implemented in <figref idref="DRAWINGS">FIG. <b>14</b>B</figref>. The following figure titles correspond to the block names of <figref idref="DRAWINGS">FIG. <b>13</b></figref>.</p><heading id="h-0033" level="2">Condition Circuitry</heading><p id="p-0240" num="0249"><figref idref="DRAWINGS">FIG. <b>14</b>A</figref> depicts one implementation <b>1400</b> of a multiplier overflow flag condition circuit <b>1381</b>. The schematic shows the multiplier overflow flag condition <b>1446</b> is active on a high level output from the multiplier overflow AND gate <b>1444</b>. The AND gate <b>1444</b> has the following three inputs: (1) the multiplication operation enable <b>1414</b>, (2) the output of NOR gate <b>1445</b>, and (3) <b>1442</b>, which is the output of product exponent AND gate <b>1440</b> and is also known as Ep (exponent product) and the multiplier product exponent.</p><p id="p-0241" num="0250">The NOR gate <b>1445</b> has two inputs eainf and ebinf., The signal exponent A infinity (eainf) occurs if Input-A is Infinity and is detected when the exponent equals 0xFF (means all &#x2018;1&#x2019;). The signal exponent B infinity (ebinf) occurs if Input-B is Infinity and is detected when the exponent equals 0xFF (means all &#x2018;1&#x2019;). Table-2 shown above defines BFloat16 terms and their numerical definitions. Eainf is the output of AND gate <b>1420</b>. The input to AND gate <b>1420</b> is the exponent of Operand-A is and is shown having a least significant bit (LSB) <b>1402</b> and a most significant bit (MSB) <b>1404</b>, comprising eight exponent bits.</p><p id="p-0242" num="0251">Ebinf is the output of AND gate <b>1430</b>. The input to AND gate <b>1430</b> is the exponent of Operand-B is and is shown having a least significant bit (LSB) <b>1406</b> and a most significant bit (MSB) <b>1408</b>, comprising eight exponent bits.</p><p id="p-0243" num="0252">The inputs to the product exponent AND gate <b>1440</b> inputs are the least significant bit (LSB) <b>1410</b> and the most significant bit (MSB) <b>1412</b>, comprising eight exponent bits.</p><p id="p-0244" num="0253"><figref idref="DRAWINGS">FIG. <b>14</b>B</figref> depicts one implementation <b>1400</b> of a multiplier underflow flag condition circuit <b>1382</b>. The multiplier underflow flag condition <b>1482</b> is active on a high level output from the multiplier underflow AND gate <b>1480</b>. The AND gate <b>1480</b> has the following three inputs: (1) the multiplication operation enable <b>1418</b>, (2) the output of NOR gate <b>1475</b>, and (3) <b>1472</b>, which is the output of product exponent NOR gate <b>1470</b>.</p><p id="p-0245" num="0254">The NOR gate <b>1475</b> has two inputs, eaz (Input-A exponent is zero) and ebz (Input-B exponent is zero). Eaz is the output of NOR gate <b>1450</b>. The input to NOR gate <b>1450</b> is the exponent of Operand-A is and is shown having a least significant bit (LSB) <b>1422</b> and a most significant bit (MSB) <b>1424</b>, comprising eight exponent bits.</p><p id="p-0246" num="0255">Ebz is the output of NOR gate <b>1460</b>. The input to NOR gate <b>1460</b> is the exponent of Operand-B is and is shown having a least significant bit (LSB) <b>1426</b> and a most significant bit (MSB) <b>1428</b>, comprising eight exponent bits.</p><p id="p-0247" num="0256">The inputs to the product exponent NOR gate <b>1470</b> inputs are the least significant bit (LSB) <b>1432</b> and the most significant bit (MSB) <b>1434</b>, comprising eight exponent bits.</p><p id="p-0248" num="0257">Assertion of the multiplier underflow flag occurs when the multiplication operation is enabled, the Ep (product exponent) is 0x00, and any of multiplier exponent input is not zero. A multiplier exponent input which is not zero means any of the exponents of Operand-A or Operand-B are not 0x00.</p><p id="p-0249" num="0258">Assertion of the multiplier invalid flag occurs according to the following two conditions: (1) the multiplication operation is enabled and (2) the invalid is &#x2018;1&#x2019;. An invalid &#x201c;1&#x201d; is defined as the condition when either the Operand-A exponent is infinity (0xFF) and Operand-B exponent is zero (0x00), or when the Operand-B exponent is infinity (0xFF) and Operand-A exponent is zero(0x00).</p><p id="p-0250" num="0259"><figref idref="DRAWINGS">FIG. <b>15</b></figref> depicts one implementation <b>1500</b> of a multiplier Invalid flag condition circuit in block <b>1383</b>. The multiplier Invalid flag condition <b>1582</b> is active on a high level output from the multiplier Invalid AND gate <b>1580</b>. The AND gate <b>1580</b> has the following two inputs: (1) the multiplication operation enable <b>1501</b>, and (2) <b>1572</b>, the output of OR gate <b>1570</b>.</p><p id="p-0251" num="0260">The OR gate <b>1570</b> has two inputs, the first input is <b>1552</b> derived from AND gate <b>1550</b>: the second input is <b>1562</b>, derived from AND gate <b>1560</b>.</p><p id="p-0252" num="0261">The AND gate <b>1550</b> has the two inputs: eainf and ebz. The signal ebz occurs when Input-B is Zero, which is (+) Zero or (&#x2212;) Zero, and the condition is the exponent is 0x00 (means all &#x2018;0&#x2019;). Eainf is the output of AND gate <b>1510</b>. The input to AND gate <b>1510</b> is the exponent of Operand-A is and is shown having a least significant bit (LSB) <b>1502</b> and a most significant bit (MSB) eight bit <b>1504</b>. Ebz is the output of NOR gate <b>1520</b>. The input to NOR gate <b>1520</b> is the eight bit exponent of the Operand-B is and is shown having a least significant bit (LSB) <b>1506</b> and a most significant bit (MSB) <b>1508</b>.</p><p id="p-0253" num="0262">The AND gate <b>1560</b> has the two inputs: ebinf and eaz. Ebinf is the output of AND gate <b>1530</b>. The input to AND gate <b>1530</b> is the eight bit exponent of the Operand-B and is shown having the least significant bit (LSB) <b>1506</b> and the most significant bit (MSB) <b>1508</b>. Eaz is the output of NOR gate <b>1540</b>. The signal eaz occurs when Input-A is Zero, which is (+) Zero or (&#x2212;) Zero), and the exponent is 0x00 (means all &#x2018;0&#x2019;). The input to NOR gate <b>1540</b> is the exponent of Operand-A is and is shown having a least significant bit (LSB) <b>1502</b> and a most significant bit (MSB) eight bit <b>1504</b> comprising eight exponent bits.</p><p id="p-0254" num="0263"><figref idref="DRAWINGS">FIG. <b>16</b></figref> depicts one implementation <b>1600</b> of a multiplier sign generation condition circuit <b>1320</b>. A multiplier sign condition <b>1632</b> is generated by AND gate <b>1630</b>. The multiplier Invalid flag condition <b>682</b> of <figref idref="DRAWINGS">FIG. <b>15</b></figref> is a first input to the AND gate <b>1630</b>. The second input to AND gate <b>1630</b> is 1632 which is derived from the output of the EX-OR gate <b>1620</b>. The sign-A <b>1618</b> and sign-B <b>1622</b> comprise the inputs to the EX-OR gate <b>1620</b>.</p><p id="p-0255" num="0264"><figref idref="DRAWINGS">FIG. <b>17</b>A</figref> shows one implementation <b>1700</b> of a multiplier exponent generation condition circuit <b>1322</b>. The multiplier exponent <b>1752</b> is generated according to three conditions. These are: (1) All&#x2032;0&#x2032; (0x00=Zero), (2) All&#x2032;1&#x2032; (0xFF=infinity), and (3) Normal exponent.</p><p id="p-0256" num="0265">The first condition is exponent All&#x2018;0&#x2019;. This first condition can occur if any exponent of Operand-A or any exponent Operand-B is zero. The first condition can also occur if the multiplier exponent calculation results in negative overflow, which means the multiplier exponent calculation results in a number smaller than &#x2212;126.</p><p id="p-0257" num="0266">The second condition is All&#x2018;1&#x2019;. This second condition can occur if any exponent of Operand-A or any exponent Operand-B is infinity. The second condition can also occur if the multiplier exponent calculation result is positive overflow, which means the result of the multiplier exponent calculation is greater than Emax (+127).</p><p id="p-0258" num="0267">The third condition is Normal output and is defined as there is not a first or second condition that is occurring. This is defined as other than All&#x2018;0&#x2019; or All&#x2018;1&#x2019; conditions.</p><p id="p-0259" num="0268">An eight bit wide multiplexer <b>1750</b> has three 8-bit buses as inputs. These are the All&#x2018;0&#x2019;, the All&#x2018;1&#x2019; and Else buses. A Control gating using the OR gate <b>1710</b>, the AND gate <b>1720</b>, the OR gate <b>1730</b> and the NOR gate <b>1740</b> control the outputs of the multiplexer <b>1750</b>.</p><p id="p-0260" num="0269"><figref idref="DRAWINGS">FIG. <b>17</b>B</figref> shows one implementation <b>1700</b> of a multiplier fraction generation condition circuit <b>1324</b>. The multiplier fraction bus <b>1772</b> is 16 bits wide and generated according to two conditions: (1) exception, (2) normal fraction. The two multiplexer inputs are: (1) the All&#x2018;0&#x2019; condition (0x00=Zero), and (2) the normal fraction condition.</p><p id="p-0261" num="0270">The multiplexer <b>1770</b> has two 16 bit input buses. These are the All&#x2018;0&#x2019;, and fraction buses. The OR gate <b>1760</b> control the gating of the <b>1770</b> multiplex sixteen bit wide multiplex output.</p><p id="p-0262" num="0271">The signals exp_overflow and ezero are the two inputs to the OR gate <b>1760</b>. The signal exp_overflow is a logical OR of either a positive overflow or a negative overflow, where overflow is described above in <figref idref="DRAWINGS">FIG. <b>17</b>A</figref>. In some embodiments, there is one status bit provided after the exponent calculation to detect an exponent overflow. The term ezero is defined as eaz (Input-A exponent is zero) or ebz (Input-B exponent is zero). The output of the OR gate <b>1760</b> is 1762 which is the control to choose between the two sixteen bit wide multiplexer <b>1770</b> input buses. All&#x2018;0&#x2019; occurs when: (1) the product exponent is positive overflow, or (2) there is negative overflow, or (3) the exponent of Operand-A is zero, or (4) the exponent of Operand-B is zero.</p><p id="p-0263" num="0272">In some embodiments, exception processing in a carry-save accumulation unit does not support DeNormal or NaN operations. In this case, the DeNormal numbers are treated as zero, and the NaN numbers are treated as infinity. The fraction output will be All&#x2018;0&#x2019; when any of those exceptions happened. Otherwise the output of the multiplexer <b>1770</b> is Normalized Fraction.</p><p id="p-0264" num="0273"><figref idref="DRAWINGS">FIG. <b>18</b>A</figref> illustrates one schematic implementation <b>1800</b> of an adder overflow flag condition circuit in block <b>1387</b>. The signal named adder overflow <b>1832</b> demonstrates the overflow flag condition and is an output from the AND gate <b>1830</b>. The adder overflow flag conditions occurs when AND gate <b>1830</b> has the following three inputs: (1) the normalization_enable, (2) the AND gate <b>1810</b> output named overflow, and (3) the NOR gate <b>1820</b> output named not input exponent infinity <b>1822</b>. The inputs to the AND gate <b>1810</b> are the eight normalization exponent bits. The inputs to the NOR gate <b>1820</b> are the multiplier product exponent infinity and the input-C exponent infinity. In summary, during the normalization, an adder overflow <b>1832</b> flag condition can occur if the normalization exponent equals a 0xFF and there is no input having an exponent infinity condition.</p><p id="p-0265" num="0274"><figref idref="DRAWINGS">FIG. <b>18</b>B</figref> shows one implementation <b>1800</b> of an adder underflow flag condition circuit in block <b>1388</b>. The adder underflow <b>1892</b> is active on the AND gate <b>1890</b> high level output which has the following three inputs: (1) the normalization_enable, (2) the AND gate <b>1850</b> output named underflow, and (3) and the NOR gate <b>1880</b> output named not input exact zero <b>1882</b>. Inputs to the AND gate <b>1850</b> are the eight normalization exponent bits and the fraction output zero. In summary, generally the adder underflow flag condition can occur during normalization when the normalization exponent is 0x00 (equals 0) and the input is not exact zero. The following paragraph will describe one implementation of the circuit that can check for a not input exact zero <b>1882</b> condition.</p><p id="p-0266" num="0275">Further describing the circuit of <figref idref="DRAWINGS">FIG. <b>18</b>B</figref>, generation of the not input exact zero <b>1882</b> signal is via the three inputs to the NOR gate <b>1880</b>. These three inputs are: (1) the multiplier product exponent zero, (2) the input-C exponent zero, and (3) output exact zero <b>1872</b>, derived from the output of AND gate <b>1870</b>. The AND gate <b>1870</b> has two inputs. The first input is the EX-OR <b>1860</b> gate output named sign_diff. The EX-OR <b>1860</b> gate operates on the two inputs, multiplier product sign and the input-C sign. The second input to the AND gate <b>1870</b> is the (+) zero, where (+)zero is the Input-C Exponent greater than or equal to the multiplier product exponent logically ANDed with the fraction out zero signal.</p><p id="p-0267" num="0276">The adder underflow is a combination of the following conditions as shown in the circuit. The first condition; (1) is when the final normalization is enabled. The second condition; (2) is when the final addition exponent result, which is when the normalization exponent equals 0x00 and when the final addition fraction result (fraction output zero signal) is not exactly zero. The third condition; (3) is when neither the multiplier product exponent zero, input-C exponent zero, and output not exact zero are enabled, meaning one of them is zero. An adder underflow does not occur if any of the three condition are zero.</p><p id="p-0268" num="0277"><figref idref="DRAWINGS">FIG. <b>19</b>A</figref> shows one implementation <b>1900</b> of an adder Invalid flag condition circuit in block <b>1389</b>. Referring to Table-8, one Invalid condition can occur when adding (+)Infinity and (&#x2212;)Infinity. Adding (+)Infinity and (+)Infinity or (&#x2212;)Infinity and (&#x2212;)Infinity does not cause an Invalid flag condition <b>1389</b>. This circuit checks for two operands having Infinity with opposite signs. The adder Invalid <b>1932</b> flag is the output of AND gate <b>1930</b>. The AND gate <b>1930</b> has the following three inputs: (1) the normalization enable, (2) the OR gate <b>1910</b> output named <b>1912</b>, and (3) the sign_diff output from the EX-OR gate <b>1920</b>.</p><p id="p-0269" num="0278">The two inputs to the adder Invalid OR gate <b>1910</b> are the multiplier product exponent infinity and the input-C exponent infinity. The EX-OR gate <b>1920</b> operates on the two inputs, the multiplier product sign, and the input-C sign.</p><p id="p-0270" num="0279">To summarize the circuit function, an adder Invalid flag condition occurs when (1) the final normalization is enabled, (2) if input signs from input-A (or multiplier product) and input-C are different (positive and negative, or negative and positive), and (3) the exponents of the two inputs are infinity (0xFF).</p><heading id="h-0034" level="2">Adder Sign Generation Circuitry</heading><p id="p-0271" num="0280"><figref idref="DRAWINGS">FIG. <b>19</b>B</figref> shows one implementation <b>1900</b> of an adder sign positive condition circuit <b>810</b>A for generating the adder sign positive output. As discussed above, the exception result generation has three parts: sign generation; exponent generation; and fraction generation. The sign output generated can be either positive or negative. One implementation of the sign output has two circuits which combine to provide the correct sign output for the exception result generation. The first circuit is the adder sign positive condition circuit <b>810</b>A. The adder sign output has a positive condition (+) when the adder sign positive <b>1992</b> bit is equal to &#x2018;1&#x2019;.</p><p id="p-0272" num="0281">The sign output function forces a positive condition to zero according to the following additions: (1) (+)Zero+(&#x2212;)Zero, (2) (+)DeNorm+(&#x2212;)DeNorm, (and vice versa), (3) the sign is different and one of the exponent inputs are infinity ((+)Inf+(&#x2212;)Inf and vice versa), (4) the sign is different and multiplier product is positive and exponent is infinity ((+)Zero x (+)Inf=(+)Inf), (5) the sign is different and Operand-C exponent is greater than Operand-A (or multiplier product) exponent, (6) the equal and fraction output is zero, and (7) when both the multiplier product sign and the input-C sign is positive.</p><p id="p-0273" num="0282">One implementation of a first circuit for generating a sign bit forced to &#x201c;0&#x201d; for a positive condition is shown in <figref idref="DRAWINGS">FIG. <b>19</b>B</figref> is where the positive sign is the signal adder sign positive <b>1992</b> which is the output of the AND gate <b>1990</b>. The AND gate <b>1990</b> has two inputs. The first input is the OR gate <b>1980</b> output named <b>1982</b>, and the second input is the sign_diff, which comes from the EX-OR gate <b>1960</b>. The EX-OR gate <b>1960</b> gate operates on the two inputs, the multiplier product sign, and the input-C sign. The OR gate <b>1980</b> has four inputs. These are the underflow, <b>1967</b>, <b>1972</b> and plus zero and fraction out zero.</p><p id="p-0274" num="0283">The AND gate <b>1950</b> output is named underflow and is a combination of the NOR gate <b>1940</b> output <b>1942</b> ANDed Fraction output Zero. The input to the NOR gate <b>1940</b> is an 8 bit normalization exponent vector. The two inputs to the OR gate <b>1965</b> are the multiplier product exponent infinity and the input-C exponent infinity. The AND gate <b>1970</b> has a first input multiplier exponent infinity enable and a second input is the output of the NOT gate <b>1968</b> whose input is the multiplier product sign.</p><p id="p-0275" num="0284"><figref idref="DRAWINGS">FIG. <b>20</b>A</figref> depicts one implementation <b>2000</b> of an adder sign negative condition circuit block <b>1326</b>C for generating the adder sign negative (&#x2212;) condition output. This is the second circuit for generating a sign output as discussed above. The sign output comprises two circuits which combine to generate the positive (+) condition or negative (&#x2212;) condition. The adder sign negative condition circuit <b>810</b>B generates the negative (&#x2212;) condition when the adder sign negative condition <b>2042</b> bit is equal to &#x2018;1&#x2019;. This second circuit is first described as a schematic implementation and the function is summarized in a few paragraphs below.</p><p id="p-0276" num="0285">One implementation of a circuit generating a sign output bit forced to 1&#x2032; for the negative (&#x2212;) condition is shown in <figref idref="DRAWINGS">FIG. <b>20</b>A</figref>. The OR gate <b>2040</b> outputs the adder sign negative condition <b>2042</b>. The two inputs to the OR gate <b>2040</b> are the AND gate <b>2020</b> output <b>2022</b> and the AND gate <b>2030</b> output <b>2032</b>. The first adder sign negative condition can occur when the AND gate <b>2020</b> is asserted. The AND gate <b>2020</b> operates on the input multiplier product sign and the input-C exponent, and if both signs are negative, asserts the output.</p><p id="p-0277" num="0286">A second adder sign negative condition can occur with an assertion of the AND gate <b>2030</b>. This will occur when the following inputs to AND gate <b>2030</b> are asserted: the multiplier exponent infinity enable, the multiplier product sign, and <b>2012</b>. The output of the NAND gate <b>2010</b> is <b>2012</b> is enabled by the multiplier product exponent infinity and the NOT gate <b>2005</b> output with an Operand-C sign as an input.</p><p id="p-0278" num="0287">Summarizing the adder sign negative condition, the sign output is forced to logic &#x2018;1&#x2019; for a negative condition (&#x2212;) according to the following: (1) when both Operand-A (or multiplier product) and Operand-C signs are &#x2018;1&#x2019; (both negative); (2) or when Operand-A (or multiplier product) is negative infinity and Operand-C is not positive infinity.</p><heading id="h-0035" level="2">Adder Exponent Circuits</heading><p id="p-0279" num="0288">The adder exponent output is generated using three conditions. The first condition is an All&#x2018;0&#x2019;(0x00=Zero). The second condition is an All&#x2018;1&#x2019;, where 0xFF will equal an infinity condition. The third condition is a normal exponent.</p><p id="p-0280" num="0289"><figref idref="DRAWINGS">FIG. <b>20</b>B</figref> illustrates one implementation <b>2000</b> of an adder exponent generation in an All &#x201c;0&#x201d; condition circuit block <b>1328</b>B. The adder exponent All &#x201c;0&#x201d; selection <b>2082</b> is the output of the OR gate <b>2080</b> having three inputs. Each input represents a separate condition.</p><p id="p-0281" num="0290">A first adder exponent All &#x201c;0&#x201d; condition is generated when either the multiplier product exponent zero or the input-C exponent zero enters the OR gate <b>2050</b>. This condition asserts <b>2052</b> to trigger the adder exponent All &#x201c;0&#x201d; selection <b>2082</b>.</p><p id="p-0282" num="0291">A second adder exponent All &#x201c;0&#x201d; condition is generated when the AND gate <b>2060</b> has (+)zero and sign_diff inputs, where (+)zero is the Input-C Exponent greater than or equal to the Multiplier Product Exponent logically ANDed with the Fraction out Zero signal. The EX-OR gate <b>2070</b> operates on the multiplier product sign and the input-C sign to generate the sign_diff. When the AND gate <b>2060</b> is asserted, <b>2062</b> is operative to trigger the adder exponent All &#x201c;0&#x201d; selection <b>2082</b>.</p><p id="p-0283" num="0292">A third adder exponent All &#x201c;0&#x201d; condition is generated by the fraction output zero input to the OR gate <b>2080</b> to trigger the adder exponent All &#x201c;0&#x201d; selection <b>2082</b>.</p><p id="p-0284" num="0293"><figref idref="DRAWINGS">FIG. <b>21</b>A</figref> illustrates one schematic implementation <b>2100</b> of an adder exponent generation for all &#x201c;1&#x201d; condition circuit block <b>1328</b>B. An OR output function having three input conditions determines an all &#x201c;1&#x201d; output condition and is described in the following paragraphs. The condition circuit <b>811</b>B shows the adder exponent All &#x201c;1&#x201d; selection <b>2122</b> as the output of the OR gate <b>2120</b> comprising three inputs. Each input represents a separate condition.</p><p id="p-0285" num="0294">A first All &#x201c;1&#x201d; condition is generated when either the multiplier product exponent infinity or the input-C exponent infinity are active inputs to the OR gate <b>2110</b>. This condition asserts <b>2112</b>.</p><p id="p-0286" num="0295">A second All &#x201c;1&#x201d; condition is generated when the eighth bit of the adder normalization exponent [8] has an overflow result.</p><p id="p-0287" num="0296">A third All &#x201c;1&#x201d; condition is generated by multiplier exponent infinity enable where the multiplier output exponent is infinity or has positive overflow.</p><p id="p-0288" num="0297">To summarize, the All&#x2018;1&#x2019; condition is generated when any exponent of input-A (or multiplier product) or input-C is infinity, or final adder normalization exponent is overflow, or multiplier output exponent is infinity or positive overflow ((+)Zero x (+)Inf=(+)Inf).</p><p id="p-0289" num="0298"><figref idref="DRAWINGS">FIG. <b>21</b>B</figref> shows one schematic implementation <b>2100</b> of an adder fraction generation condition circuit <b>1330</b>A. This circuit routes either the actual normalization fraction value or 23 bits of zero depending upon the three selector conditions controlling a multiplexer. The three conditions which force the first 23 bit bus zero are: (1) any normalization exponent overflow; (2) normalization exponent underflow; or (3) or multiplier output exponent is infinity or positive overflow Otherwise, this condition is normal and the second bus comprising the 23 bit normalization fraction bus routes to the adder fraction <b>2132</b> output.</p><p id="p-0290" num="0299">The schematic of circuit <b>812</b>A shows the adder fraction <b>2132</b> output as a 23 bit bus sourced by the multiplexer <b>2150</b>. The OR gate <b>2130</b> outputs the selector control <b>2131</b> to choose between the two 23 bit input buses to the multiplexer <b>2150</b>. The multiplexer <b>2150</b> has two 23 bit buses as inputs. A first input bus is a 23 all zero bits bus. A second input bus is the 23 bit normalization fraction bus. The OR gate <b>2130</b> outputs the control <b>2131</b> to the multiplexer <b>2150</b> according to the three inputs conditions described in the paragraph above.</p><p id="p-0291" num="0300">The adder fraction <b>2132</b> output has two conditions which are All&#x2018;0&#x2019;(0x00=Zero) and normal fraction. In one embodiment, the exception processing in a carry-save accumulation unit does not support DeNormal or NaN operation, the DeNormal numbers are treated as zero, and NaN numbers are treated as infinity. The fraction output will be All&#x2018;0&#x2019; when any of those exceptions happened.</p><p id="p-0292" num="0301">All&#x2018;0&#x2019; occurs when the overflow or underflow exceptions happened, or multiplier output exponent is infinity or positive overflow ((+)Zero multiplied by (+)Inf=(+)Inf).</p><heading id="h-0036" level="2">Multiply-Adder Operation Case Consideration</heading><p id="p-0293" num="0302">In the following paragraph, x is a multiplication operator, while + is a summing operator and = is the equals operator.</p><p id="p-0294" num="0000"><tables id="TABLE-US-00012" num="00012"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="7"><colspec colname="1" colwidth="49pt" align="left"/><colspec colname="2" colwidth="14pt" align="left"/><colspec colname="3" colwidth="49pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="49pt" align="left"/><colspec colname="6" colwidth="14pt" align="left"/><colspec colname="7" colwidth="28pt" align="left"/><thead><row><entry namest="1" nameend="7" align="center" rowsep="1"/></row><row><entry>[VALUE1</entry><entry>&#xd7;</entry><entry>VALUE2]</entry><entry>+</entry><entry>VALUE3</entry><entry>=</entry><entry>RESULT</entry></row><row><entry namest="1" nameend="7" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>[(+)Zero</entry><entry>&#xd7;</entry><entry>(+)Inf]</entry><entry>+</entry><entry>(&#x2212;)Inf</entry><entry>=</entry><entry>(+)Inf</entry></row><row><entry>[(+)Zero</entry><entry>&#xd7;</entry><entry>(+)Inf]</entry><entry>+</entry><entry>(&#x2212;)Norm</entry><entry>=</entry><entry>(+)Inf</entry></row><row><entry>[(+)Inf</entry><entry>&#xd7;</entry><entry>(&#x2212;)Inf]</entry><entry>+</entry><entry>(+)Zero</entry><entry>=</entry><entry>(&#x2212;)Inf</entry></row><row><entry>[(+)Inf</entry><entry>&#xd7;</entry><entry>(&#x2212;)lnf]</entry><entry>+</entry><entry>(+)Inf</entry><entry>=</entry><entry>(+)Inf</entry></row><row><entry>[(+)Zero</entry><entry>&#xd7;</entry><entry>(+)Inf]</entry><entry>+</entry><entry>(+)Zero</entry><entry>=</entry><entry>(+)Inf</entry></row><row><entry>[(+)MaxNorm</entry><entry>&#xd7;</entry><entry>(+)MaxNorm]</entry><entry>+</entry><entry>(+)MaxNorm</entry><entry>=</entry><entry>(+)Inf</entry></row><row><entry>[(+)MaxNorm</entry><entry>&#xd7;</entry><entry>(+)DeNorm]</entry><entry>+</entry><entry>(+)MinNorm</entry><entry>=</entry><entry>(+)Min-</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry/><entry>Norm</entry></row><row><entry namest="1" nameend="7" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0295" num="0303">While the present invention is disclosed by reference to various embodiments and examples detailed above, it is to be understood that these examples are intended in an illustrative rather than in a limiting sense. It is contemplated that modifications and combinations will readily occur to those skilled in the art, which modifications and combinations will be within the spirit of the invention and the scope of the following claims.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-math idrefs="MATH-US-00001" nb-file="US20230004353A1-20230105-M00001.NB"><img id="EMI-M00001" he="8.13mm" wi="76.20mm" file="US20230004353A1-20230105-M00001.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A floating-point accumulator circuit comprising:<claim-text>a floating-point input having an input significand field;</claim-text><claim-text>a first shifter coupled to the input significand field and providing an output of the input significand field shifted by a first amount;</claim-text><claim-text>a three-input carry-save adder having a first input coupled to the output of the first shifter, a second input, a third input, and an output providing carry bits and sum bits representing a summation of the first input, the second input, and the third input, as a significand of an accumulated value;</claim-text><claim-text>a second shifter coupled to the carry bits of the output of the three-input carry-save adder and providing an output of the carry bits shifted by a second amount to the second input of the three-input carry-save adder; and</claim-text><claim-text>a third shifter coupled to the sum bits of the output of the three-input carry-save adder and providing an output of the sum bits shifted by the second amount to the third input of the three-input carry-save adder.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The floating-point accumulator circuit of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>an input pipeline register clocked by a first clock and having an input coupled to the input significand field of the floating-point input and a registered significand output coupled to an input of the first shifter;</claim-text><claim-text>a fractional carry pipeline register clocked by the first clock and having an input coupled to the carry bits of the output of the three-input carry-save adder and a registered output coupled to an input of the second shifter; and</claim-text><claim-text>a fractional sum pipeline register clocked by the first clock and having an input coupled to the sum bits of the output of the three-input carry-save adder and a registered output coupled to an input of the third shifter.</claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The floating-point accumulator circuit of <claim-ref idref="CLM-00002">claim 2</claim-ref>, further comprising:<claim-text>a first circuit path from the registered significand output of the input pipeline register to the input of the fractional sum pipeline register that passes through only one shifter and the three-input carry-save adder, the only one shifter being the first shifter.</claim-text></claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The floating-point accumulator circuit of <claim-ref idref="CLM-00002">claim 2</claim-ref>, further comprising:<claim-text>a second circuit path from the registered output of the fractional carry pipeline register to the input of the fractional carry pipeline register that passes through only one shifter and the three-input carry-save adder, the only one shifter being the second shifter; and</claim-text><claim-text>a third circuit path from the registered output of the fractional sum pipeline register to the input of the fractional sum pipeline register that passes through only one shifter and the three-input carry-save adder, the only one shifter being the third shifter.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The floating-point accumulator circuit of <claim-ref idref="CLM-00004">claim 4</claim-ref>, the third circuit path further comprising only one multiplexor.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The floating-point accumulator circuit of <claim-ref idref="CLM-00002">claim 2</claim-ref>, further comprising a carry-save conversion pipeline stage that includes:<claim-text>an adder coupled to the registered output of the fractional carry pipeline register and the registered output of the fractional sum pipeline register and having an output to provide their sum; and</claim-text><claim-text>a pipeline register clocked by the first clock with an input coupled to the output of the adder and a registered output to provide a significand value of the accumulated value.</claim-text></claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The floating-point accumulator circuit of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the significand value of the accumulated value includes a sign value and an unsigned magnitude value.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The floating-point accumulator circuit of <claim-ref idref="CLM-00002">claim 2</claim-ref>, further comprising:<claim-text>an addend input having an addend signficand field; and</claim-text><claim-text>a multiplexor having a first input coupled to the addend signficand field of the addend input, a second input coupled to the registered output of the fractional sum pipeline register, and an output coupled to the input of the second shifter.</claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The floating-point accumulator circuit of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the floating-point input has one and only one input significand field to represent a magnitude of a significand of a floating-point value received.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The floating-point accumulator circuit of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the input significand field of the floating-point input uses a 2's compliment representation of the significand of a floating-point value received.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The floating-point accumulator circuit of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>one and only one gate per bit of the output of the second shifter interposed between a bit of the output of the second shifter and a respective bit of the second input of the three-input carry-save adder; and</claim-text><claim-text>one and only one gate per bit of the output of the third shifter interposed between a bit of the output of the third shifter and a respective bit of the third input of the three-input carry-save adder.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The floating-point accumulator circuit of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the one and only one gate per bit of the output of the second shifter and the one and only one gate per bit of the output of the third shifter each consist of a two-input AND gate.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. An integrated circuit comprising:<claim-text>a floating-point input having an input significand field;</claim-text><claim-text>a first shifter coupled to the input significand field and providing an output of the input significand field shifted by a first amount;</claim-text><claim-text>a three-input carry-save adder having a first input coupled to the output of the first shifter, a second input, a third input, and an output providing carry bits and sum bits representing a summation of the first input, the second input, and the third input, as a significand of an accumulated value;</claim-text><claim-text>a second shifter coupled to the carry bits of the output of the three-input carry-save adder and providing an output of the carry bits shifted by a second amount to the second input of the three-input carry-save adder; and</claim-text><claim-text>a third shifter coupled to the sum bits of the output of the three-input carry-save adder and providing an output of the sum bits shifted by the second amount to the third input of the three-input carry-save adder.</claim-text></claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The integrated circuit of <claim-ref idref="CLM-00013">claim 13</claim-ref>, further comprising:<claim-text>an input pipeline register clocked by a first clock and having an input coupled to the floating-point input and a registered output coupled to an input of the first shifter;</claim-text><claim-text>a fractional carry pipeline register clocked by the first clock and having an input coupled to the carry bits of the output of the three-input carry-save adder and a registered output coupled to an input of the second shifter; and</claim-text><claim-text>a fractional sum pipeline register clocked by the first clock and having an input coupled to the sum bits of the output of the three-input carry-save adder and a registered output coupled to an input of the third shifter.</claim-text></claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The integrated circuit of <claim-ref idref="CLM-00014">claim 14</claim-ref>, further comprising:<claim-text>a first circuit path from the registered output of the input pipeline register to the input of the fractional sum pipeline register that passes through only one shifter and the three-input carry-save adder, the only one shifter being the first shifter.</claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The integrated circuit of <claim-ref idref="CLM-00014">claim 14</claim-ref>, further comprising:<claim-text>a second circuit path from the registered output of the fractional carry pipeline register to the input of the fractional carry pipeline register that passes through only one shifter and the three-input carry-save adder, the only one shifter being the second shifter; and</claim-text><claim-text>a third circuit path from the registered output of the fractional sum pipeline register to the input of the fractional sum pipeline register that passes through only one shifter and the three-input carry-save adder, the only one shifter being the third shifter.</claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The integrated circuit of <claim-ref idref="CLM-00016">claim 16</claim-ref>, the third circuit path further comprising only one multiplexor.</claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The integrated circuit of <claim-ref idref="CLM-00014">claim 14</claim-ref>, further comprising a carry-save conversion pipeline stage that includes:<claim-text>an adder coupled to the registered output of the fractional carry pipeline register and the registered output of the fractional sum pipeline register and having an output to provide their sum; and</claim-text><claim-text>a pipeline register clocked by the first clock with an input coupled to the output of the adder and a registered output to provide a significand value of the accumulated value.</claim-text></claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The integrated circuit of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein the significand value of the accumulated value includes a sign value and an unsigned magnitude value.</claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The integrated circuit of <claim-ref idref="CLM-00014">claim 14</claim-ref>, further comprising:<claim-text>an addend input having an addend signficand field; and</claim-text><claim-text>a multiplexor having a first input coupled to the addend signficand field of the addend input, a second input coupled to the registered output of the fractional sum pipeline register, and an output coupled to the input of the second shifter.</claim-text></claim-text></claim><claim id="CLM-00021" num="00021"><claim-text><b>21</b>. The integrated circuit of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the input significand field of the floating-point input uses a 2's compliment representation of a significand of a floating-point value received.</claim-text></claim><claim id="CLM-00022" num="00022"><claim-text><b>22</b>. The integrated circuit of <claim-ref idref="CLM-00013">claim 13</claim-ref>, further comprising:<claim-text>one and only one gate per bit of the output of the second shifter interposed between a bit of the output of the second shifter and a respective bit of the second input of the three-input carry-save adder; and</claim-text><claim-text>one and only one gate per bit of the output of the third shifter interposed between a bit of the output of the third shifter and a respective bit of the third input of the three-input carry-save adder.</claim-text></claim-text></claim><claim id="CLM-00023" num="00023"><claim-text><b>23</b>. The integrated circuit of <claim-ref idref="CLM-00022">claim 22</claim-ref>, wherein the one and only one gate per bit of the output of the second shifter and the one and only one gate per bit of the output of the third shifter each consist of a two-input AND gate.</claim-text></claim><claim id="CLM-00024" num="00024"><claim-text><b>24</b>. A method of accumulating floating-point values, the method comprising:<claim-text>latching, in a first clock cycle:<claim-text>a floating-point input having a significand field to generate a latched input significand field,</claim-text><claim-text>accumulated carry bits from a three-input carry-save adder to generate latched accumulated carry bits, and</claim-text><claim-text>accumulated sum bits from the three-input carry-save adder to generate latched accumulated sum bits;</claim-text></claim-text><claim-text>shifting the latched input significand field by a first amount to generate a shifted input significand field;</claim-text><claim-text>shifting the latched accumulated carry bits by a second amount to generate shifted carry bits; and</claim-text><claim-text>shifting the latched accumulated sum bits by the second amount to generate shifted sum bits;</claim-text><claim-text>wherein the shifted input significand field, the shifted carry bits, and the shifted sum bits are respectively coupled to a first input, a second input, and a third input of the three-input carry-save adder.</claim-text></claim-text></claim><claim id="CLM-00025" num="00025"><claim-text><b>25</b>. The method of <claim-ref idref="CLM-00024">claim 24</claim-ref>, wherein the significand field of the floating-point input uses a 2's compliment representation of a significand of a floating-point value received.</claim-text></claim><claim id="CLM-00026" num="00026"><claim-text><b>26</b>. The method of <claim-ref idref="CLM-00024">claim 24</claim-ref>, further comprising:<claim-text>adding the latched accumulated carry bits and the latched accumulated sum bits to generate a significand value; and</claim-text><claim-text>latching, in a second clock cycle immediately following the first clock cycle, the significand value into a pipleline register.</claim-text></claim-text></claim><claim id="CLM-00027" num="00027"><claim-text><b>27</b>. The method of <claim-ref idref="CLM-00026">claim 26</claim-ref>, wherein the significand value includes a sign value and an unsigned magnitude value.</claim-text></claim><claim id="CLM-00028" num="00028"><claim-text><b>28</b>. The method of <claim-ref idref="CLM-00024">claim 24</claim-ref>, further comprising:<claim-text>latching, in the first clock cycle, a second floating-point input having an addend signficand field; and</claim-text><claim-text>selecting between the addend signficand field of the second floating-point input, the latched accumulated sum bits to shift by the second amount and to provide to the third input of the three-input carry-save adder.</claim-text></claim-text></claim></claims></us-patent-application>