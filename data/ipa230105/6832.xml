<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230006833A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230006833</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17365707</doc-number><date>20210701</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>L</subclass><main-group>9</main-group><subgroup>32</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>8</main-group><subgroup>65</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>21</main-group><subgroup>57</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>L</subclass><main-group>9</main-group><subgroup>3239</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>8</main-group><subgroup>65</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>L</subclass><main-group>9</main-group><subgroup>3247</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>21</main-group><subgroup>572</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>2221</main-group><subgroup>033</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">RANKED HASH VALIDATION FOR NEW SOFTWARE UPDATE FILE</invention-title><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Lenovo (Singapore) Pte. Ltd.</orgname><address><city>Singapore</city><country>SG</country></address></addressbook><residence><country>SG</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Stolbikov</last-name><first-name>Igor</first-name><address><city>Apex</city><state>NC</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Li</last-name><first-name>Scott Wentao</first-name><address><city>Cary</city><state>NC</state><country>US</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>Novak</last-name><first-name>Joshua N.</first-name><address><city>Wake Forest</city><state>NC</state><country>US</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">In one aspect, a device may include a processor and storage with instructions executable to identify a ranking of different chunks of a new update file, with the different ranks associated with different hashing algorithms. The instructions may also be executable to determine whether a respective newly-received hash for a respective chunk of the new update file is different from a respective prior hash of a prior software version for the same respective chunk. Responsive to the respective newly-received hash being different from the respective prior hash for the same chunk, the instructions may be executable to attempt to validate the respective chunk using the respective hashing algorithm associated with the respective rank for the respective chunk. Responsive to the respective newly-received hash being the same as the respective prior hash for the same respective chunk, the instructions may be executable to decline to attempt to validate the respective chunk.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="224.87mm" wi="117.35mm" file="US20230006833A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="243.59mm" wi="161.88mm" file="US20230006833A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="170.69mm" wi="98.72mm" orientation="landscape" file="US20230006833A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="243.84mm" wi="122.85mm" file="US20230006833A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="247.99mm" wi="141.05mm" orientation="landscape" file="US20230006833A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="238.59mm" wi="129.03mm" file="US20230006833A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">FIELD</heading><p id="p-0002" num="0001">The disclosure below relates to technically inventive, non-routine solutions that are necessarily rooted in computer technology and that produce concrete technical improvements. In particular, the disclosure below relates to techniques for ranked hash validation for new software update files.</p><heading id="h-0002" level="1">BACKGROUND</heading><p id="p-0003" num="0002">As recognized herein, many peripheral devices have low-power microprocessor units that are many orders of magnitude less powerful than higher-powered central processing units (CPUs) that are included in many of today's high-powered computers. As such, it can take these microprocessor units much more time to perform certain tasks.</p><p id="p-0004" num="0003">As also recognized herein, one of these tasks may be firmware update validation for integrity and authenticity. This task can take hundreds of seconds using a microprocessor unit, which the present application recognizes is far too long and can unnecessarily consume processing resources that should be devoted to other tasks. Moreover, the present application recognizes that while these validation techniques use hashing tools that can take thousands and thousands of years to successfully crack, peripheral device security need not last nearly that long as the devices and firmware are typically only used for a few years.</p><p id="p-0005" num="0004">The present application further recognizes that while validation might sometimes be outsourced to a high-powered CPU connected to the peripheral device, this tactic provides hackers with a network gap that they can exploit to corrupt the process and compromise device security without the peripheral device or connected device even knowing about it, let alone remedying it.</p><p id="p-0006" num="0005">There are therefore currently no adequate solutions to the foregoing computer-related, technological problems.</p><heading id="h-0003" level="1">SUMMARY</heading><p id="p-0007" num="0006">Accordingly, in one aspect a first device includes at least one processor and storage accessible to the at least one processor. The storage includes instructions executable by the at least one processor to identify a ranking of different chunks of a new update file, with the ranking including at least two different ranks associated with different hashing algorithms. The instructions are also executable to determine whether a respective newly-received hash for a respective chunk of the new update file is different from a respective prior hash of a prior software version for the same respective chunk. The respective newly-received hash is received with the new update file and the respective prior hash relates to a previous update of the software or an original version of the software. Responsive to the respective newly-received hash for the respective chunk of the new update file being different from the respective prior hash for the same respective chunk, the instructions are executable to attempt to validate the respective chunk of the new update file using the respective hashing algorithm associated with the respective rank for the respective chunk of the new update file. Responsive to the respective newly-received hash for the respective chunk of the new update file being the same as the respective prior hash for the same respective chunk, the instructions are executable to decline to attempt to validate the respective chunk of the new update file.</p><p id="p-0008" num="0007">Thus, in some examples the instructions may be executable to perform an update of the respective chunk using the new update file responsive to validation of the respective chunk of the new update file using the respective hashing algorithm associated with the respective rank for the respective chunk of the new update file, and to decline to perform the update for the respective chunk using the new update file responsive to not validating the respective chunk of the new update file using the respective hashing algorithm associated with the respective rank for the respective chunk of the new update file. Declining to perform the update for the respective chunk using the new update file might include declining to perform any update of the software using the new update file. Additionally, in some examples the instructions may be executable to transmit a notification to a second device different from the first device indicating that the respective chunk of the new update file could not be validated responsive to not validating the respective chunk of the new update file using the respective hashing algorithm associated with the respective chunk of the new update file.</p><p id="p-0009" num="0008">In some example implementations, the determination may be performed by comparing hashes in a hash tree for the new update file and a hash tree for the prior software version to identify a hash for a particular leaf indicated in both trees as having changed relative to the prior software version. Furthermore, in some examples the instructions may be executable to verify a digital signature for the hash tree for the new update file prior to installing the new update file, where the digital signature may be received with the new update file.</p><p id="p-0010" num="0009">Also in various example implementations, the different hashing algorithms may be established at least in part by different numbers of permutations used for each hashing algorithm. Thus, a rank associated with a file directory chunk for the new update file may be associated with a hashing algorithm with more permutations than a hashing algorithm associated with a different rank.</p><p id="p-0011" num="0010">Still further, in some embodiments the instructions may be executable to identify, in a header for the new update file for the software, the ranking of different chunks of the new update file. Additionally, or alternatively, the instructions may be executable to identify, via a directory for the update file, the ranking of different chunks of the new update file.</p><p id="p-0012" num="0011">Also in some examples, the first device may include a peripheral device, where the new update file may pertain to a firmware update for the peripheral device. Also, if desired the processor may include a microprocessor and the microprocessor may execute the instructions locally in the peripheral device. The peripheral device itself may be established by a headset, headphones, a keyboard, a mouse, a wireless speaker, a dock or hub device, a display, a printer, a stylus, a camera, a microphone, a network repeater, a wireless access point, an external network adapter, a router, a modem, and/or an external hard drive.</p><p id="p-0013" num="0012">In another aspect, a method includes identifying a ranking of different chunks of a new update file. The ranking includes at least two different ranks, and the different chunks are associated with different hashing algorithms. The method also includes determining whether a respective newly-received hash for a respective chunk of the new update file is different from a respective prior hash of a prior software version for the same respective chunk. The respective prior hash relates to a previous update of the software or an original version of the software. Then responsive to the respective newly-received hash for the respective chunk of the new update file being different from the respective prior hash for the same respective chunk, the method includes attempting to validate the respective chunk of the new update file using the respective hashing algorithm associated with the respective chunk of the new update file. Responsive to the respective newly-received hash for the respective chunk of the new update file being the same as the respective prior hash for the same respective chunk, the method includes declining to attempt to validate the respective chunk of the new update file.</p><p id="p-0014" num="0013">Thus, in certain examples the method may include performing an update of the respective chunk using the new update file responsive to validating the respective chunk of the new update file using the respective hashing algorithm associated with the respective chunk of the new update file, and declining to perform the update for the respective chunk using the new update file responsive to not validating the respective chunk of the new update file using the respective hashing algorithm associated with the respective chunk of the new update file.</p><p id="p-0015" num="0014">Also, in various example implementations the determining may be performed by comparing hashes in a hash tree for the new update file with hashes in a hash tree for the prior software version to identify a hash for a particular leaf indicated in both trees as having changed relative to the prior software version.</p><p id="p-0016" num="0015">The different hashing algorithms may be established at least in part by different numbers of permutations used for each hashing algorithm in certain example implementations. Also, the new update file may pertain to a firmware update.</p><p id="p-0017" num="0016">In still another aspect, at least one computer readable storage medium (CRSM) that is not a transitory signal includes instructions executable by at least one processor to identify a ranking of different chunks of a new update file. Different rankings for different chunks are associated with different hashing algorithms of different strengths. The instructions are then executable to determine whether a respective newly-received hash for a respective chunk of the new update file is different from a respective prior hash of a prior software version for the same respective chunk. The respective prior hash relates to a previous update of the software or an original version of the software. Responsive to the respective newly-received hash for the respective chunk of the new update file being different from the respective prior hash for the same respective chunk, the instructions are executable to attempt to validate the respective chunk of the new update file using the respective hashing algorithm associated with the respective rank for the respective chunk of the new update file. Responsive to the respective newly-received hash for the respective chunk of the new update file being the same as the respective prior hash for the same respective chunk, the instructions are executable to decline to attempt to validate the respective chunk of the new update file.</p><p id="p-0018" num="0017">Thus, in certain examples the different strengths of the different hashing algorithms may be established at least in part by different numbers of iterations used for the different hashing algorithms. Also in certain examples, the determination may be performed by comparing hashes in a hash tree for the new update file with hashes in a hash tree for the prior software version to identify a hash for a particular leaf indicated in both trees as having changed relative to the prior software version.</p><p id="p-0019" num="0018">The details of present principles, both as to their structure and operation, can best be understood in reference to the accompanying drawings, in which like reference numerals refer to like parts, and in which:</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram of an example system consistent with present principles;</p><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a block diagram of an example network of devices consistent with present principles;</p><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates example logic in example flow chart format that may be executed by a device consistent with present principles;</p><p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. <b>4</b></figref> shows an example schematic diagram of an example hash tree consistent with present principles;</p><p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. <b>5</b></figref> shows an example data table ranking various firmware update chunks and indicating associated hash algorithms of different strengths to use for the various chunks consistent with present principles;</p><p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. <b>6</b></figref> shows an example graphical user interface (GUI) that may be presented on a display of a device of a manufacturer/distributor in the event an update file has been identified as potentially compromised consistent with present principles; and</p><p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. <b>7</b></figref> shows an example GUI that may be presented on a display of an end user's device in the event an update file has been identified as potentially compromised consistent with present principles.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0005" level="1">DETAILED DESCRIPTION</heading><p id="p-0027" num="0026">Among other things, the detailed description below discloses splitting firmware into chunks that are ranked based on the level of security desired for the corresponding chunk data. A header or other part of an update file may be used to describe the predefined chunks in the file.</p><p id="p-0028" num="0027">For example, a Windows binary file may have a portable executable (PE) header, located at the beginning of the binary, that describes the file's headers, sections, checksum, and certificate information. The chunks may be ranked in the header and indicate other high-security sections of the file such as a Windows-specific header (including the checksum, which may be located at the top of the file), a certificate table, executable code sections, and an authenticode signatures table (e.g., containing the file's digital certificates themselves, often located at bottom of the file). Then other sections of the file that can use less secure hashing methods/smaller numbers of permutations may include data sections, resource sections, debugging sections, etc. The manufacturer or developer of the peripheral device may adjust each section to be assigned a given security level based on various application-specific needs.</p><p id="p-0029" num="0028">Another example might be in the context of a zip file, where each file entry, and the file's data, is located in a central directory at the end of the file. Here too the chunks may be ranked using the directory for higher-security portions and lower-security portions. Thus, any file chunk assigned to a higher level of security may use a stronger hashing algorithm/bigger number of iterations than other chunks assigned to lower levels of security. The final central directory itself may in some examples be assigned the highest available security level and thus be protected by the most-secure hashing algorithm available.</p><p id="p-0030" num="0029">Thus, based on file type, the file definition may be parsed to determine which sections/chunks are more important to protect.</p><p id="p-0031" num="0030">The update package structure may also be reflected in a hash tree/Merkle tree assembled into the update package itself. Each leaf of the tree may for example include Type|id|hash value (and possibly also the chunk itself). Depending on the type of chunk, different numbers of permutations may be used. For example, for high-risk types, a &#x201c;full&#x201d; number of permutations, such as twenty-four, may be used. For lower-risk types, a small number of permutations may be used (e.g., eight). Since much of the data may be relatively low-risk, using eight permutations for those chunks may significantly improve the performance of the device's processor during validation while also providing adequate security for the life of the peripheral device. Thus, while using eight permutations is weaker than twenty-four, it still provides sufficiently strong security and matching (e.g., for 128-bit security).</p><p id="p-0032" num="0031">The tree itself may be hashed using the full number of permutations/strongest available hashing algorithm. The tree may also be signed by the firmware distributor.</p><p id="p-0033" num="0032">The verification process at the local peripheral device may then use the knowledge of the previous firmware version and any identified changes. For example, the verification process may start upside down in the hash tree so that it starts with the verification of the top signature as matching to the trusted provider. The process may then move to compare hashes of next, lower layers of nodes, and so on.</p><p id="p-0034" num="0033">The process may thus compare the hashes of the respective chunks of the new update file with existing firmware chunk hashes for the same respective chunks but for the prior version. Any chunks/nodes with matching hashes between versions may be skipped and not verified and/or installed. Thus, only modified file chunks may be verified using a certain number of hashing permutations during the hash calculations that is based on the assigned security level/importance of the respective chunks.</p><p id="p-0035" num="0034">Prior to delving further into the details of the instant techniques, note with respect to any computer systems discussed herein that a system may include server and client components, connected over a network such that data may be exchanged between the client and server components. The client components may include one or more computing devices including televisions (e.g., smart TVs, Internet-enabled TVs), computers such as desktops, laptops and tablet computers, so-called convertible devices (e.g., having a tablet configuration and laptop configuration), and other mobile devices including smart phones. These client devices may employ, as non-limiting examples, operating systems from Apple Inc. of Cupertino Calif., Google Inc. of Mountain View, Calif., or Microsoft Corp. of Redmond, Wash. A Unix&#xae; or similar such as Linux&#xae; operating system may be used. These operating systems can execute one or more browsers such as a browser made by Microsoft or Google or Mozilla or another browser program that can access web pages and applications hosted by Internet servers over a network such as the Internet, a local intranet, or a virtual private network.</p><p id="p-0036" num="0035">As used herein, instructions refer to computer-implemented steps for processing information in the system. Instructions can be implemented in software, firmware or hardware, or combinations thereof and include any type of programmed step undertaken by components of the system; hence, illustrative components, blocks, modules, circuits, and steps are sometimes set forth in terms of their functionality.</p><p id="p-0037" num="0036">A processor may be any general-purpose single- or multi-chip processor that can execute logic by means of various lines such as address lines, data lines, and control lines and registers and shift registers. Moreover, any logical blocks, modules, and circuits described herein can be implemented or performed with a general-purpose processor, a digital signal processor (DSP), a field programmable gate array (FPGA) or other programmable logic device such as an application specific integrated circuit (ASIC), discrete gate or transistor logic, discrete hardware components, or any combination thereof designed to perform the functions described herein. A processor can also be implemented by a controller or state machine or a combination of computing devices. Thus, the methods herein may be implemented as software instructions executed by a processor, suitably configured application specific integrated circuits (ASIC) or field programmable gate array (FPGA) modules, or any other convenient manner as would be appreciated by those skilled in those art. Where employed, the software instructions may also be embodied in a non-transitory device that is being vended and/or provided that is not a transitory, propagating signal and/or a signal per se (such as a hard disk drive, CD ROM or Flash drive). The software code instructions may also be downloaded over the Internet. Accordingly, it is to be understood that although a software application for undertaking present principles may be vended with a device such as the system <b>100</b> described below, such an application may also be downloaded from a server to a device over a network such as the Internet.</p><p id="p-0038" num="0037">Software modules and/or applications described by way of flow charts and/or user interfaces herein can include various sub-routines, procedures, etc. Without limiting the disclosure, logic stated to be executed by a particular module can be redistributed to other software modules and/or combined together in a single module and/or made available in a shareable library.</p><p id="p-0039" num="0038">Logic when implemented in software, can be written in an appropriate language such as but not limited to hypertext markup language (HTML)-5, Java/JavaScript, C# or C++, and can be stored on or transmitted from a computer-readable storage medium such as a random access memory (RAM), read-only memory (ROM), electrically erasable programmable read-only memory (EEPROM), a hard disk drive or solid state drive, compact disk read-only memory (CD-ROM) or other optical disk storage such as digital versatile disc (DVD), magnetic disk storage or other magnetic storage devices including removable thumb drives, etc.</p><p id="p-0040" num="0039">In an example, a processor can access information over its input lines from data storage, such as the computer readable storage medium, and/or the processor can access information wirelessly from an Internet server by activating a wireless transceiver to send and receive data. Data typically is converted from analog signals to digital by circuitry between the antenna and the registers of the processor when being received and from digital to analog when being transmitted. The processor then processes the data through its shift registers to output calculated data on output lines, for presentation of the calculated data on the device.</p><p id="p-0041" num="0040">Components included in one embodiment can be used in other embodiments in any appropriate combination. For example, any of the various components described herein and/or depicted in the Figures may be combined, interchanged or excluded from other embodiments.</p><p id="p-0042" num="0041">&#x201c;A system having at least one of A, B, and C&#x201d; (likewise &#x201c;a system having at least one of A, B, or C&#x201d; and &#x201c;a system having at least one of A, B, C&#x201d;) includes systems that have A alone, B alone, C alone, A and B together, A and C together, B and C together, and/or A, B, and C together, etc.</p><p id="p-0043" num="0042">The term &#x201c;circuit&#x201d; or &#x201c;circuitry&#x201d; may be used in the summary, description, and/or claims. As is well known in the art, the term &#x201c;circuitry&#x201d; includes all levels of available integration, e.g., from discrete logic circuits to the highest level of circuit integration such as VLSI and includes programmable logic components programmed to perform the functions of an embodiment as well as general-purpose or special-purpose processors programmed with instructions to perform those functions.</p><p id="p-0044" num="0043">Now specifically in reference to <figref idref="DRAWINGS">FIG. <b>1</b></figref>, an example block diagram of an information handling system and/or computer system <b>100</b> is shown that is understood to have a housing for the components described below. Note that in some embodiments the system <b>100</b> may be a desktop computer system, such as one of the ThinkCentre&#xae; or ThinkPad&#xae; series of personal computers sold by Lenovo (US) Inc. of Morrisville, N.C., or a workstation computer, such as the ThinkStation&#xae;, which are sold by Lenovo (US) Inc. of Morrisville, N.C.; however, as apparent from the description herein, a client device, a server or other machine in accordance with present principles may include other features or only some of the features of the system <b>100</b>. Also, the system <b>100</b> may be, e.g., a game console such as XBOX&#xae;, and/or the system <b>100</b> may include a mobile communication device such as a mobile telephone, notebook computer, and/or other portable computerized device.</p><p id="p-0045" num="0044">As shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the system <b>100</b> may include a so-called chipset <b>110</b>. A chipset refers to a group of integrated circuits, or chips, that are designed to work together. Chipsets are usually marketed as a single product (e.g., consider chipsets marketed under the brands INTEL&#xae;, AMD&#xae;, etc.).</p><p id="p-0046" num="0045">In the example of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the chipset <b>110</b> has a particular architecture, which may vary to some extent depending on brand or manufacturer. The architecture of the chipset <b>110</b> includes a core and memory control group <b>120</b> and an I/O controller hub <b>150</b> that exchange information (e.g., data, signals, commands, etc.) via, for example, a direct management interface or direct media interface (DMI) <b>142</b> or a link controller <b>144</b>. In the example of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the DMI <b>142</b> is a chip-to-chip interface (sometimes referred to as being a link between a &#x201c;northbridge&#x201d; and a &#x201c;southbridge&#x201d;).</p><p id="p-0047" num="0046">The core and memory control group <b>120</b> include one or more processors <b>122</b> (e.g., single core or multi-core, etc.) and a memory controller hub <b>126</b> that exchange information via a front side bus (FSB) <b>124</b>. As described herein, various components of the core and memory control group <b>120</b> may be integrated onto a single processor die, for example, to make a chip that supplants the &#x201c;northbridge&#x201d; style architecture.</p><p id="p-0048" num="0047">The memory controller hub <b>126</b> interfaces with memory <b>140</b>. For example, the memory controller hub <b>126</b> may provide support for DDR SDRAM memory (e.g., DDR, DDR2, DDR3, etc.). In general, the memory <b>140</b> is a type of random-access memory (RAM). It is often referred to as &#x201c;system memory.&#x201d;</p><p id="p-0049" num="0048">The memory controller hub <b>126</b> can further include a low-voltage differential signaling interface (LVDS) <b>132</b>. The LVDS <b>132</b> may be a so-called LVDS Display Interface (LDI) for support of a display device <b>192</b> (e.g., a CRT, a flat panel, a projector, a touch-enabled light emitting diode (LED) display or other video display, etc.). A block <b>138</b> includes some examples of technologies that may be supported via the LVDS interface <b>132</b> (e.g., serial digital video, HDMI/DVI, display port). The memory controller hub <b>126</b> also includes one or more PCI-express interfaces (PCI-E) <b>134</b>, for example, for support of discrete graphics <b>136</b>. Discrete graphics using a PCI-E interface has become an alternative approach to an accelerated graphics port (AGP). For example, the memory controller hub <b>126</b> may include a 16-lane (&#xd7;16) PCI-E port for an external PCI-E-based graphics card (including, e.g., one of more GPUs). An example system may include AGP or PCI-E for support of graphics.</p><p id="p-0050" num="0049">In examples in which it is used, the I/O hub controller <b>150</b> can include a variety of interfaces. The example of <figref idref="DRAWINGS">FIG. <b>1</b></figref> includes a SATA interface <b>151</b>, one or more PCI-E interfaces <b>152</b> (optionally one or more legacy PCI interfaces), one or more universal serial bus (USB) interfaces <b>153</b>, a LAN interface <b>154</b> (more generally a network interface for communication over at least one network such as the Internet, a WAN, a LAN, a Bluetooth network using Bluetooth 5.0 communication, etc. under direction of the processor(s) <b>122</b>), a general purpose I/O interface (GPIO) <b>155</b>, a low-pin count (LPC) interface <b>170</b>, a power management interface <b>161</b>, a clock generator interface <b>162</b>, an audio interface <b>163</b> (e.g., for speakers <b>194</b> to output audio), a total cost of operation (TCO) interface <b>164</b>, a system management bus interface (e.g., a multi-master serial computer bus interface) <b>165</b>, and a serial peripheral flash memory/controller interface (SPI Flash) <b>166</b>, which, in the example of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, includes basic input/output system (BIOS) <b>168</b> and boot code <b>190</b>. With respect to network connections, the I/O hub controller <b>150</b> may include integrated gigabit Ethernet controller lines multiplexed with a PCI-E interface port. Other network features may operate independent of a PCI-E interface.</p><p id="p-0051" num="0050">The interfaces of the I/O hub controller <b>150</b> may provide for communication with various devices, networks, etc. For example, where used, the SATA interface <b>151</b> provides for reading, writing, or reading and writing information on one or more drives <b>180</b> such as HDDs, SDDs or a combination thereof, but in any case, the drives <b>180</b> are understood to be, e.g., tangible computer readable storage mediums that are not transitory, propagating signals. The I/O hub controller <b>150</b> may also include an advanced host controller interface (AHCI) to support one or more drives <b>180</b>. The PCI-E interface <b>152</b> allows for wireless connections <b>182</b> to devices, networks, etc. The USB interface <b>153</b> provides for input devices <b>184</b> such as keyboards (KB), mice and various other devices (e.g., cameras, phones, storage, media players, etc.).</p><p id="p-0052" num="0051">In the example of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the LPC interface <b>170</b> provides for use of one or more ASICs <b>171</b>, a trusted platform module (TPM) <b>172</b>, a super I/O <b>173</b>, a firmware hub <b>174</b>, BIOS support <b>175</b> as well as various types of memory <b>176</b> such as ROM <b>177</b>, Flash <b>178</b>, and non-volatile RAM (NVRAM) <b>179</b>. With respect to the TPM <b>172</b>, this module may be in the form of a chip that can be used to authenticate software and hardware devices. For example, a TPM may be capable of performing platform authentication and may be used to verify that a system seeking access is the expected system.</p><p id="p-0053" num="0052">The system <b>100</b>, upon power on, may be configured to execute boot code <b>190</b> for the BIOS <b>168</b>, as stored within the SPI Flash <b>166</b>, and thereafter processes data under the control of one or more operating systems and application software (e.g., stored in system memory <b>140</b>). An operating system may be stored in any of a variety of locations and accessed, for example, according to instructions of the BIOS <b>168</b>.</p><p id="p-0054" num="0053">Additionally, though not shown for simplicity, in some embodiments the system <b>100</b> may include a gyroscope that senses and/or measures the orientation of the system <b>100</b> and provides related input to the processor <b>122</b>, as well as an accelerometer that senses acceleration and/or movement of the system <b>100</b> and provides related input to the processor <b>122</b>. Still further, the system <b>100</b> may include an audio receiver/microphone that provides input from the microphone to the processor <b>122</b> based on audio that is detected, such as via a user providing audible input to the microphone. The system <b>100</b> may also include a camera that gathers one or more images and provides the images and related input to the processor <b>122</b>. The camera may be a thermal imaging camera, an infrared (IR) camera, a digital camera such as a webcam, a three-dimensional (3D) camera, and/or a camera otherwise integrated into the system <b>100</b> and controllable by the processor <b>122</b> to gather still images and/or video. Also, the system <b>100</b> may include a global positioning system (GPS) transceiver that is configured to communicate with at least one satellite to receive/identify geographic position information and provide the geographic position information to the processor <b>122</b>. However, it is to be understood that another suitable position receiver other than a GPS receiver may be used in accordance with present principles to determine the location of the system <b>100</b>.</p><p id="p-0055" num="0054">It is to be understood that an example client device or other machine/computer may include fewer or more features than shown on the system <b>100</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. In any case, it is to be understood at least based on the foregoing that the system <b>100</b> is configured to undertake present principles.</p><p id="p-0056" num="0055">Turning now to <figref idref="DRAWINGS">FIG. <b>2</b></figref>, example devices are shown communicating over a network <b>200</b> such as the Internet in accordance with present principles. It is to be understood that each of the devices described in reference to <figref idref="DRAWINGS">FIG. <b>2</b></figref> may include at least some of the features, components, and/or elements of the system <b>100</b> described above. Indeed, any of the devices disclosed herein may include at least some of the features, components, and/or elements of the system <b>100</b> described above.</p><p id="p-0057" num="0056"><figref idref="DRAWINGS">FIG. <b>2</b></figref> shows a notebook computer and/or convertible computer <b>202</b>, a desktop computer <b>204</b>, a wearable device <b>206</b> such as a smart watch, a smart television (TV) <b>208</b>, a smart phone <b>210</b>, a tablet computer <b>212</b>, a wireless mouse <b>216</b>, a wireless keyboard <b>218</b>, a wireless camera <b>220</b>, and a server <b>214</b> such as an Internet server that may provide cloud storage accessible to the devices <b>202</b>-<b>212</b>, <b>216</b>-<b>220</b>. It is to be understood that the devices <b>202</b>-<b>220</b> may be configured to communicate with each other over the network <b>200</b> to undertake present principles.</p><p id="p-0058" num="0057">For example, the server <b>214</b> may push a firmware update to one of the peripheral devices <b>216</b>-<b>220</b> through the notebook computer <b>202</b> or desktop computer <b>204</b> based on the computer <b>202</b>/<b>204</b> being in Bluetooth or other short-range wireless communication with the respective peripheral device. Then after the server <b>214</b> routes the update through the computer <b>202</b>/<b>204</b> to the peripheral device, the peripheral device may use its local microprocessor/microcontroller within the peripheral device itself to install the update as described herein. An example microprocessor <b>222</b> for the mouse <b>216</b> is thus shown in <figref idref="DRAWINGS">FIG. <b>2</b></figref>, with microprocessors for the devices <b>218</b>, <b>220</b> being omitted from <figref idref="DRAWINGS">FIG. <b>2</b></figref> for simplicity. Each microprocessor in each peripheral device may be embodied in an application-specific integrated circuit (ASIC) or other integrated circuit, field-programmable gate array (FPGA), metal-oxide-semiconductor field-effect transistor (MOSFET), digital signal processor (DSP), or other suitable unit.</p><p id="p-0059" num="0058">Also note before describing <figref idref="DRAWINGS">FIG. <b>3</b></figref> that a peripheral device consistent with present principles is not limited to wired or wireless keyboards, mice, and cameras but may also include wired and/or wireless headsets (e.g., Bluetooth headset for phone calls), headphones, speakers, docks or hub devices, a displays/monitors, printers, styluses, microphones, network repeaters, wireless access points, external network adapters, routers, modems, external hard drives, various types of Internet of things (IoT) devices, smart home devices, etc.</p><p id="p-0060" num="0059">Referring now to <figref idref="DRAWINGS">FIG. <b>3</b></figref>, it shows example logic that may be executed locally by a processor within a peripheral device consistent with present principles in order to perform ranked hash validation for a new update file so that adequate digital security for software updates may be provided while also not over-burdening the device's local processor. The update file may be for, for example, updating the firmware of a device such as webcam, stand-alone microphone, keyboard, etc. The update file may be a zip file or Windows binary file, for example. Also note that while the logic of <figref idref="DRAWINGS">FIG. <b>3</b></figref> is shown in flow chart format, state logic or other suitable logic may also be used. Further note that the peripheral device will be described in reference to <figref idref="DRAWINGS">FIG. <b>3</b></figref> as a &#x201c;first device&#x201d;.</p><p id="p-0061" num="0060">Beginning at block <b>300</b>, the first device may receive and cache a new update file, such as a new firmware update for the first device's firmware that has been pushed to the peripheral device or otherwise downloaded. The update may be an update from a previous version of the first device's software/firmware, whether the previous version was itself an update or an original version of the software/firmware. The update file may be received from a local computer such as a laptop, tablet, or desktop computer that is in Wi-Fi, wireless USB, or Bluetooth communication with the first device, for example. After block <b>300</b> the logic may move to block <b>302</b>.</p><p id="p-0062" num="0061">At block <b>302</b> the first device may access a header for the new update file, a file directory for the new update file, or another portion of the new update file to identify a ranking of different chunks of a new update file as established by the provider or developer of the new update file. The ranking may include at least two different ranks associated with different hashing algorithms of different strengths. The chunks themselves may be established by discrete portions of the new update file, such as the file's executable, the file's directory, the file's text document, an image file, a new hash tree, etc. However, in other examples the chunks may be smaller chunks of data within those discrete portions, or even chunks of data across multiple discrete portions, where in either case the chunks may be of a preestablished size as specified by the developer (e.g., 100 megabytes (MB)). Regardless, as for the new hash tree, while it may be provided in the update file separate from the file's directory, in some examples it may be included in the directory or root itself.</p><p id="p-0063" num="0062">After block <b>302</b> the logic may proceed to block <b>304</b> where the first device may in some examples use public/private key asymmetric cryptography to verify the digital signature for the new hash tree received as part of the update file. This may be done using the appropriate public key that is reciprocal to the private key used to generate the digital signature itself. The digital signature may either sign just the new hash tree itself or sign the entire update file and/or root/root hash, for example.</p><p id="p-0064" num="0063">If the authenticity of the digital signature cannot be verified, the logic may end. But assuming the digital signature is verified, the logic may next move to decision diamond <b>306</b>. At diamond <b>306</b> the first device may determine, for each leaf of the new hash tree which itself may establish a respective chunk, whether the newly-received hash for the respective chunk as indicated in the new hash tree is different from an older/prior hash for the same respective chunk as indicated in an older hash tree for the prior version. The older hash tree may be stored locally at the first device and may be from an immediately prior update file or the original software version for the firmware.</p><p id="p-0065" num="0064">If the hashes for the respective chunk are determined to be the same once compared, this indicates that no new updates to the firmware are included in that respective chunk compared to the prior version for the same respective chunk, thus leading to a negative determination at diamond <b>306</b>. The negative determination may cause the logic to then proceed to block <b>308</b> where the first device may skip a validation attempt for the respective chunk. After block <b>308</b> the logic may then move on to another chunk of the received update file and perform the determination at diamond <b>306</b> again for that chunk. This process may continue for each chunk of the new update file until a chunk is reached for which an affirmative determination is made at diamond <b>306</b>.</p><p id="p-0066" num="0065">Then once hashes for a same respective chunk are determined to be different between the firmware versions at diamond <b>306</b>, this indicates that the respective chunk has been updated or otherwise changed compared to the immediately prior version. Accordingly, an affirmative determination may be made at diamond <b>306</b>, which may then cause the logic to then proceed to block <b>310</b> where the first device may attempt to validate the new version of the respective chunk.</p><p id="p-0067" num="0066">The validation attempt at block <b>310</b> may be performed using a particular hash algorithm assigned to the rank associated with the respective chunk itself. The different hashing algorithms for the different ranks may be pre-stored at the first device by the first device's manufacturer along with the different ranks assigned to each one. In various examples, the different hashing algorithms may vary in strength at least by the number of iterations/permutations performed as part of the respective algorithm so that higher-ranked algorithms use more iterations/permutations for hashing than other hash algorithms associated with lower ranks. The hash algorithms may be one or more from the family of Keccak algorithms, and specifically the family of Secure Hash Algorithms (SHAs) such as SHA-1, SHA-2, or SHA-3 algorithms (e.g., SHA-256, SHA-384, SHA-512). However, the algorithms may also be established by other hash algorithms such as MD5, BLAKE, BLAKE2, BLAKE3, KangarooTwelve, RIPEMD, etc.</p><p id="p-0068" num="0067">Thus, by using less-robust hashing algorithms with less permutations for chunks of the update file that have been assigned lower priorities, in combination with only attempting to validate respective chunks for which a respective newly-received hash is different from a prior hash version, processing constraints on the peripheral device's microprocessor are reduced and the efficiency and functionality of the microprocessor is enhanced in executing the update while still providing adequate security for the peripheral device's firmware. For instance, firmware updates may only need to withstand two to five years' worth of attacks instead of thousands or millions of years' worth of attacks as would be ensured by using a robust, high-permutation hashing algorithm for the entire update file. This is because peripheral devices are typically only used for a few years before being replaced or rendered obsolete by newer models, and/or their firmware rendered obsolete by further updates.</p><p id="p-0069" num="0068">Thus, from block <b>310</b> the logic of <figref idref="DRAWINGS">FIG. <b>3</b></figref> may then move to decision diamond <b>312</b>. At diamond <b>312</b> the first device may actually compare the hash it generated at block <b>310</b> for the respective chunk of the new update file to the corresponding hash for the same respective chunk of the new update file as indicated in the newly-received hash tree that was signed with the digital signature to determine whether the two hashes match.</p><p id="p-0070" num="0069">A negative determination at diamond <b>312</b> may cause the logic to proceed to block <b>314</b> where the first device may decline/refuse to execute any part of the firmware update using the new update file since the mismatch of the hashes indicates a hacker or other nefarious party might have compromised the firmware update in transit to the peripheral device itself and possibly inserted malware, viruses, etc. into the update file. If desired, at block <b>314</b> the first device may also route a message or other notification through the computer to which it is connected to the provider, developer, or system administrator for the update file that indicates the respective chunk could not be validated and that the update file has possibly been compromised owing to the hash mismatch. Also, if desired, at block <b>314</b> the first device may communicate with the computer to also present a message or other notification to the local end user via the computer's display and/or speakers that the respective chunk could not be validated and that the update file will not be installed.</p><p id="p-0071" num="0070">However, if an affirmative determination is made at diamond <b>312</b> instead (e.g., a hash match), then the logic may instead proceed to block <b>316</b>. At block <b>316</b> the logic may repeat the foregoing process of <figref idref="DRAWINGS">FIG. <b>3</b></figref> for remaining chunks of the new update file that have not yet been validated and ultimately perform/install the firmware update to update the respective chunk and any others that are new compared to prior versions and validated.</p><p id="p-0072" num="0071">Now referring to <figref idref="DRAWINGS">FIG. <b>4</b></figref>, it shows a schematic diagram <b>400</b> consistent with present principles of an example hash tree according to a root file structure, where a root for a particular firmware update/version has a root hash <b>402</b> for the root file. As a preliminary check, the microprocessor on the peripheral device may compare the root hash <b>402</b> as received as part of a new update file to a previous firmware root hash <b>404</b> of a previous root of an immediately prior version of the same firmware (as already stored at the peripheral device) to determine whether anything in any portion of the new update file is different from the previous version. If the hashes <b>402</b>, <b>404</b> are different, the logic of <figref idref="DRAWINGS">FIG. <b>3</b></figref> may then be executed.</p><p id="p-0073" num="0072">As also shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref>, the hash tree may include hashes for each respective intermediate node (an example of a discrete chunk) at levels one, two, and three as shown. The hash tree may also include hashes for each respective bottom-level leaf node (another example of a discrete but possibly smaller chunk) at the bottom of the hash tree. Guide <b>410</b> is included to illustrate, with different shadings, hashes for different chunks in the hash tree that have either changed or not changed compared to an older hash tree for an immediately prior version of the same firmware. Thus, indicators <b>412</b> indicate, at the leaf node level for different types of files/data (e.g., executable vs. an image file), that different hashes have been identified for a respective chunk when comparing older and new hashes for that respective chunk. Indicator <b>414</b> indicates that different hashes have been identified for a respective chunk when comparing older and new hashes for that respective chunk at the intermediate node level. Indicator <b>416</b> indicates nodes at various levels for which respective newly-received hashes match respective older hash versions.</p><p id="p-0074" num="0073">Continuing the detailed description in reference to <figref idref="DRAWINGS">FIG. <b>5</b></figref>, it shows an example data table <b>500</b> that may be stored locally at a peripheral device. The table <b>500</b> may have been preconfigured by the device's manufacturer, a software developer, system administrator, etc. The table <b>500</b> may indicate different chunk types in column <b>502</b>, different associated ranks in column <b>504</b>, and different associated hash algorithms of varying strengths in column <b>506</b>.</p><p id="p-0075" num="0074">As may be appreciated from <figref idref="DRAWINGS">FIG. <b>5</b></figref>, executables and file directory/final central directory chunks have the highest ranking and are therefore associated with a hashing algorithm with more permutations than a hashing algorithm associated with different, lower ranks for other chunk types such as text files and image files. Thus, after the peripheral device identifies the rankings or types of different chunks of a new update file (e.g., at block <b>302</b> of <figref idref="DRAWINGS">FIG. <b>3</b></figref>) as described above, the device may access the table <b>500</b> and determine which hash algorithm to use at block <b>310</b> based on the respective rank.</p><p id="p-0076" num="0075">Now describing <figref idref="DRAWINGS">FIG. <b>6</b></figref>, it shows an example graphical user interface (GUI) <b>600</b> that may be presented on the display of a device associated with a manufacturer or developer of a peripheral device as a notification that a new update file has been determined by the peripheral device itself to have been potentially compromised. For example, the GUI <b>600</b> may be presented responsive to receiving a message from the peripheral device per the description of block <b>314</b> above. Thus, the GUI <b>600</b> may include a prompt <b>602</b> indicating that at least one chunk of the new update file could not be validated, and that the firmware update is therefore compromised.</p><p id="p-0077" num="0076">The prompt <b>602</b> may prompt the manufacturer/admin to investigate the potential digital attack on the new update file by various means. Thus, the GUI <b>600</b> may include a selector <b>604</b> that may be selectable to transmit a request to the peripheral device itself to transmit the potentially compromised update file back to the manufacturer's device and sandbox it at the manufacturer's device (e.g., not giving it network access or access to other parts of the manufacturer's device) so that the manufacturer can compare the received and sandboxed update file to what the peripheral device was supposed to receive as a valid update file. However, if desired a selector <b>606</b> may also be selected to initiate other diagnostics at the manufacturer device, such as network diagnostics to identify a potential intrusion into the manufacturer's local network or the network between the peripheral device and manufacturer device itself.</p><p id="p-0078" num="0077">Turning now to <figref idref="DRAWINGS">FIG. <b>7</b></figref>, it shows another example GUI <b>700</b> that may be presented on a display. However, the GUI <b>700</b> may be presented on the display of an end user's computer that communicates with a local peripheral device consistent with present principles (and/or that may be presented on the display of the peripheral device itself, it the device has one). The GUI <b>700</b> may serve as a notification to an end user per block <b>314</b> above that a new update file has been determined by the peripheral device itself to have been potentially compromised.</p><p id="p-0079" num="0078">Thus, the GUI <b>700</b> may include a prompt <b>702</b> indicating that at least one chunk of the new update file could not be validated, and that the firmware update is therefore compromised. In some examples, like where the peripheral device does not autonomously notify the update file's system admins and/or the peripheral device manufacturer of the potentially compromised, the GUI <b>700</b> may include a selector <b>704</b> for the end user to command the computer to do so anyway.</p><p id="p-0080" num="0079">Before concluding, it is to be understood that in some instances, hashes in a newly-received hash tree for a new update file may be compared to all prior hash trees of prior updates and the original version of software as stored in the peripheral device. In these examples, if each hash of the new tree matches each respective hash of any of the older trees, the new update may be rejected even if it contains hashes that are different relative to a most-recent prior update. This may be done so that an older version of the device's firmware that might be two or three generations older is not installed on instigation of a bad actor who discovered a security flaw in the older version of the firmware that can then be exploited.</p><p id="p-0081" num="0080">It may now be appreciated that present principles provide for improved firmware/software updates that increase the functionality and efficiency of the underlying devices to which the firmware/software pertains. The disclosed concepts are thus rooted in computer technology for computers to carry out their functions.</p><p id="p-0082" num="0081">It is to be understood that whilst present principals have been described with reference to some example embodiments, these are not intended to be limiting, and that various alternative arrangements may be used to implement the subject matter claimed herein. Components included in one embodiment can be used in other embodiments in any appropriate combination. For example, any of the various components described herein and/or depicted in the Figures may be combined, interchanged or excluded from other embodiments.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A first device, comprising:<claim-text>at least one processor; and</claim-text><claim-text>storage accessible to the at least one processor and comprising instructions executable by the at least one processor to:</claim-text><claim-text>identify a ranking of different chunks of a new update file, the ranking comprising at least two different ranks, the different ranks associated with different hashing algorithms;</claim-text><claim-text>determine whether a respective newly-received hash for a respective chunk of the new update file is different from a respective prior hash of a prior software version for the same respective chunk, the respective newly-received hash being received with the new update file, the respective prior hash relating to a previous update of the software or an original version of the software;</claim-text><claim-text>responsive to the respective newly-received hash for the respective chunk of the new update file being different from the respective prior hash for the same respective chunk, attempt to validate the respective chunk of the new update file using the respective hashing algorithm associated with the respective rank for the respective chunk of the new update file; and</claim-text><claim-text>responsive to the respective newly-received hash for the respective chunk of the new update file being the same as the respective prior hash for the same respective chunk, decline to attempt to validate the respective chunk of the new update file.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The first device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the instructions are executable to:<claim-text>responsive to validation of the respective chunk of the new update file using the respective hashing algorithm associated with the respective rank for the respective chunk of the new update file, perform an update of the respective chunk using the new update file; and</claim-text><claim-text>responsive to not validating the respective chunk of the new update file using the respective hashing algorithm associated with the respective rank for the respective chunk of the new update file, decline to perform the update for the respective chunk using the new update file.</claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The first device of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein declining to perform the update for the respective chunk using the new update file comprises declining to perform any update of the software using the new update file.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The first device of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the instructions are executable to:<claim-text>responsive to not validating the respective chunk of the new update file using the respective hashing algorithm associated with the respective chunk of the new update file, transmit a notification to a second device different from the first device indicating that the respective chunk of the new update file could not be validated.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The first device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the determination is performed by comparing hashes in a hash tree for the new update file and a hash tree for the prior software version to identify a hash for a particular leaf indicated in both trees as having changed relative to the prior software version.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The first device of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the instructions are executable to:<claim-text>verify a digital signature for the hash tree for the new update file prior to installing the new update file, the digital signature received with the new update file.</claim-text></claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The first device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the different hashing algorithms are established at least in part by different numbers of permutations used for each hashing algorithm.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The first device of <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein a rank associated with a file directory chunk for the new update file is associated with a hashing algorithm with more permutations than a hashing algorithm associated with a different rank.</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The first device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the instructions are executable to:<claim-text>identify, in a header for the new update file for the software, the ranking of different chunks of the new update file.</claim-text></claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The first device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the instructions are executable to:<claim-text>identify, via a directory for the update file, the ranking of different chunks of the new update file.</claim-text></claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The first device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, comprising a peripheral device, wherein the new update file pertains to a firmware update for the peripheral device.</claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The first device of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the processor comprises a microprocessor, and wherein the microprocessor executes the instructions locally in the peripheral device.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The first device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the peripheral device is established by a headset, headphones, a keyboard, a mouse, a wireless speaker, a dock or hub device, a display, a printer, a stylus, a camera, a microphone, a network repeater, a wireless access point, an external network adapter, a router, a modem, and/or an external hard drive.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. A method, comprising:<claim-text>identifying a ranking of different chunks of a new update file, the ranking comprising at least two different ranks, the different chunks associated with different hashing algorithms;</claim-text><claim-text>determining whether a respective newly-received hash for a respective chunk of the new update file is different from a respective prior hash of a prior software version for the same respective chunk, the respective prior hash relating to a previous update of the software or an original version of the software;</claim-text><claim-text>responsive to the respective newly-received hash for the respective chunk of the new update file being different from the respective prior hash for the same respective chunk, attempting to validate the respective chunk of the new update file using the respective hashing algorithm associated with the respective chunk of the new update file; and</claim-text><claim-text>responsive to the respective newly-received hash for the respective chunk of the new update file being the same as the respective prior hash for the same respective chunk, declining to attempt to validate the respective chunk of the new update file.</claim-text></claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The method of <claim-ref idref="CLM-00014">claim 14</claim-ref>, comprising:<claim-text>responsive to validating the respective chunk of the new update file using the respective hashing algorithm associated with the respective chunk of the new update file, performing an update of the respective chunk using the new update file; and</claim-text><claim-text>responsive to not validating the respective chunk of the new update file using the respective hashing algorithm associated with the respective chunk of the new update file, declining to perform the update for the respective chunk using the new update file.</claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The method of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the determining is performed by comparing hashes in a hash tree for the new update file with hashes in a hash tree for the prior software version to identify a hash for a particular leaf indicated in both trees as having changed relative to the prior software version.</claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The method of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the different hashing algorithms are established at least in part by different numbers of permutations used for each hashing algorithm.</claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The method of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the new update file pertains to a firmware update.</claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. At least one computer readable storage medium (CRSM) that is not a transitory signal, the computer readable storage medium comprising instructions executable by at least one processor to:<claim-text>identify a ranking of different chunks of a new update file, wherein different rankings for different chunks are associated with different hashing algorithms of different strengths;</claim-text><claim-text>determine whether a respective newly-received hash for a respective chunk of the new update file is different from a respective prior hash of a prior software version for the same respective chunk, the respective prior hash relating to a previous update of the software or an original version of the software;</claim-text><claim-text>responsive to the respective newly-received hash for the respective chunk of the new update file being different from the respective prior hash for the same respective chunk, attempt to validate the respective chunk of the new update file using the respective hashing algorithm associated with the respective rank for the respective chunk of the new update file; and</claim-text><claim-text>responsive to the respective newly-received hash for the respective chunk of the new update file being the same as the respective prior hash for the same respective chunk, decline to attempt to validate the respective chunk of the new update file.</claim-text></claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The CRSM of <claim-ref idref="CLM-00019">claim 19</claim-ref>, wherein the different strengths of the different hashing algorithms are established at least in part by different numbers of iterations used for the different hashing algorithms, and wherein the determination is performed by comparing hashes in a hash tree for the new update file with hashes in a hash tree for the prior software version to identify a hash for a particular leaf indicated in both trees as having changed relative to the prior software version.</claim-text></claim></claims></us-patent-application>