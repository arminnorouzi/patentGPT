<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230007278A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230007278</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17780476</doc-number><date>20201126</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>174</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>70</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>159</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>132</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>91</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>174</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>70</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>159</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>132</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20141101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>N</subclass><main-group>19</main-group><subgroup>91</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">SLICE AND TILE CONFIGURATION FOR IMAGE/VIDEO CODING</invention-title><us-related-documents><us-provisional-application><document-id><country>US</country><doc-number>62941846</doc-number><date>20191128</date></document-id></us-provisional-application></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>LG ELECTRONICS INC.</orgname><address><city>Seoul</city><country>KR</country></address></addressbook><residence><country>KR</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>HENDRY</last-name><first-name>Hendry</first-name><address><city>Seoul</city><country>KR</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>PALURI</last-name><first-name>Seethal</first-name><address><city>Seoul</city><country>KR</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>KIM</last-name><first-name>Seunghwan</first-name><address><city>Seoul</city><country>KR</country></address></addressbook></inventor></inventors></us-parties><pct-or-regional-filing-data><document-id><country>WO</country><doc-number>PCT/KR2020/016883</doc-number><date>20201126</date></document-id><us-371c12-date><date>20220526</date></us-371c12-date></pct-or-regional-filing-data></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A video decoding method performed by a video decoding apparatus, according to the present document, comprises: parsing number information about the number of slices of which heights are explicitly signaled in a tile of a current picture from a bitstream; parsing height information about the heights of slices of which heights are explicitly signaled from the bitstream based on the number information; deriving the number of slices in the tile based on the number information and the height information; and decoding the current picture based on the slices in the tile, wherein the height information includes the same number of syntax elements as a value of the number information, and based on the value of the number information being n, the heights of a 0th slice to an n-1th slice in the tile may be derived based on the syntax elements.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="68.41mm" wi="158.75mm" file="US20230007278A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="187.88mm" wi="117.94mm" orientation="landscape" file="US20230007278A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="202.78mm" wi="146.98mm" orientation="landscape" file="US20230007278A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="200.41mm" wi="131.49mm" orientation="landscape" file="US20230007278A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="132.59mm" wi="106.68mm" file="US20230007278A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="93.98mm" wi="106.68mm" file="US20230007278A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="179.15mm" wi="140.72mm" orientation="landscape" file="US20230007278A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="171.37mm" wi="118.28mm" file="US20230007278A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="200.24mm" wi="121.75mm" orientation="landscape" file="US20230007278A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="135.21mm" wi="122.00mm" file="US20230007278A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="184.74mm" wi="125.31mm" orientation="landscape" file="US20230007278A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="173.65mm" wi="139.28mm" orientation="landscape" file="US20230007278A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">BACKGROUND OF THE DISCLOSURE</heading><heading id="h-0002" level="1">Field of the Disclosure</heading><p id="p-0002" num="0001">The present disclosure relates to a method and apparatus for coding an image/video based on a slice/tile configuration of a picture.</p><heading id="h-0003" level="1">Related Art</heading><p id="p-0003" num="0002">Recently, the demand for high resolution, high quality image/video such as <b>4</b>K, <b>8</b>K or more Ultra High Definition (UHD) image/video is increasing in various fields. As the image/video resolution or quality becomes higher, relatively more amount of information or bits are transmitted than for conventional image/video data. Therefore, if image/video data are transmitted via a medium such as an existing wired/wireless broadband line or stored in a legacy storage medium, costs for transmission and storage are readily increased.</p><p id="p-0004" num="0003">Moreover, interests and demand are growing for virtual reality (VR) and artificial reality (AR) contents, and immersive media such as hologram; and broadcasting of images/videos exhibiting image/video characteristics different from those of an actual image/video, such as game images/videos, are also growing.</p><p id="p-0005" num="0004">Therefore, a highly efficient image/video compression technique is required to effectively compress and transmit, store, or play high resolution, high quality images/videos showing various characteristics as described above.</p><heading id="h-0004" level="1">SUMMARY OF THE DISCLOSURE</heading><heading id="h-0005" level="2">Technical Objects</heading><p id="p-0006" num="0005">A technical object of the present disclosure is to provide a method and apparatus for increasing coding efficiency of an image/video.</p><p id="p-0007" num="0006">Another technical object of the present disclosure is to provide a method and apparatus for efficiently signaling information on a slice within a tile.</p><p id="p-0008" num="0007">Yet another technical object of the present disclosure is to provide a method and apparatus for reducing signaling overhead when delivering (or transferring) information on a slice within a tile.</p><p id="p-0009" num="0008">Yet another technical object of the present disclosure is to provide a method and apparatus for efficiently delivering (or transferring) information related to a number and height of slices within a tile.</p><p id="p-0010" num="0009">Yet another technical object of the present disclosure is to provide a method and apparatus for efficiently signaling information related to heights of corresponding slides, when two or more slides have the same height within a tile.</p><heading id="h-0006" level="1">Technical Solutions</heading><p id="p-0011" num="0010">According to an embodiment of the present disclosure, provided herein is a video decoding method performed by a video decoding apparatus. The method may include the steps of parsing number information related to a number of slices each having its height explicitly signaled within a tile of a current picture from a bitstream, parsing height information related to heights of slices each having its height explicitly signaled from the bitstream based on the number information, deriving a number of slices within the tile based on the number information and the height information, and decoding the current picture based on the slices within the tile, wherein the height information may include a same number of syntax elements as a value of the number information, wherein, based on the number information value being equal to n, heights of a 0-th slice to an (n-1)-th slice within the tile may be derived based on the syntax elements, wherein a height of an n-th slice within the tile may be derived based on the height of the (n-1)-th slice, and wherein a height of a last slice within the tile may be derived based on a remaining height after subtracting the heights of other slices within the tile from a height of the tile.</p><p id="p-0012" num="0011">According to another embodiment of the present disclosure, provided herein is a video encoding method performed by a video encoding apparatus. The method may include the steps of deriving slices within a tile of a current picture, generating prediction samples by performing at least one of intra prediction or inter prediction based on the derived slices, generating residual information based on the prediction samples, generating number information related to a number of slices each having its height explicitly signaled within the tile and height information related to heights of the slices each having its height explicitly signaled based on the derived slices, and encoding image information including the residual information, the number information, and the height information, wherein, based on a value of the number information being equal to n, the height information may include n number of syntax elements each indicating heights of a 0-th slice to an (n-1)-th slice within the tile, respectively, wherein a height of an n-th slice within the tile may be derived based on the height of the (n-1)-th slice, and wherein a height of a last slice within the tile may be derived based on a remaining height after subtracting the heights of other slices within the tile from a height of the tile.</p><p id="p-0013" num="0012">According to yet another embodiment of the present disclosure, provided herein is a computer readable digital recording medium having information stored therein that causes a video decoding method to be performed by a video decoding apparatus. The video decoding method may include the steps of parsing number information related to a number of slices each having its height explicitly signaled within a tile of a current picture from video information, parsing height information related to heights of slices each having its height explicitly signaled from the video information based on the number information, deriving a number of slices within the tile based on the number information and the height information, and decoding the current picture based on the slices within the tile, wherein the height information may include a same number of syntax elements as a value of the number information, wherein, based on the number information value being equal to n, heights of a 0-th slice to an (n-1)-th slice within the tile may be derived based on the syntax elements, wherein a height of an n-th slice within the tile may be derived based on the height of the (n-1)-th slice, and wherein a height of a last slice within the tile may be derived based on a remaining height after subtracting the heights of other slices within the tile from a height of the tile.</p><heading id="h-0007" level="1">Effects of the Disclosure</heading><p id="p-0014" num="0013">According to an embodiment of the present disclosure, overall compression efficiency of an image/video may be enhanced.</p><p id="p-0015" num="0014">According to an embodiment of the present disclosure, information on a slice within a tile may be efficiently signaled.</p><p id="p-0016" num="0015">According to an embodiment of the present disclosure, signaling overhead may be reduced when delivering (or transferring) information on a slice within a tile.</p><p id="p-0017" num="0016">According to an embodiment of the present disclosure, information related to a number and height of slices within a tile may be efficiently signaled.</p><p id="p-0018" num="0017">According to an embodiment of the present disclosure, when two or more slides have the same height within a tile, information related to heights of the corresponding slides may be efficiently signaled.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0008" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>1</b></figref> schematically illustrates an example of a video/image coding system to which embodiments of the present document are applicable.</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a diagram schematically illustrating a configuration of a video/image encoding apparatus to which the embodiments of the present document are applicable.</p><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a diagram schematically illustrating a configuration of a video/image decoding apparatus to which the embodiments of the present document are applicable.</p><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. <b>4</b></figref> shows an example of a picture decoding procedure.</p><p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. <b>5</b></figref> shows an example of a picture encoding procedure.</p><p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. <b>6</b></figref> shows an exemplary hierarchical structure of a coded image/video.</p><p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. <b>7</b></figref> and <figref idref="DRAWINGS">FIG. <b>8</b></figref> respectively show general examples of a video/image encoding method and a related component according to an embodiment of the present disclosure.</p><p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. <b>9</b></figref> and <figref idref="DRAWINGS">FIG. <b>10</b></figref> respectively show general examples of a video/image decoding method and a related component according to an embodiment of the present disclosure.</p><p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. <b>11</b></figref> shows an example of a contents streaming system to which the embodiment of the present disclosure may be applied.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0009" level="1">DESCRIPTION OF EXEMPLARY EMBODIMENTS</heading><p id="p-0028" num="0027">The present document relates to video/image coding. For example, a method/embodiment disclosed in the present document may be applied to a method disclosed in a versatile video coding (VVC) standard. In addition, the method/embodiment disclosed in the present document may be applied to a method disclosed in an essential video coding (EVC) standard, AOMedia Video 1 (AV1) standard, 2nd generation of audio video coding standard (AVS2), or a next-generation video/image coding standard (e.g., H.267, H.268, etc.).</p><p id="p-0029" num="0028">Various embodiments related to video/image coding are presented in the present document, and the embodiments may be combined with each other unless otherwise stated.</p><p id="p-0030" num="0029">In the present document, a video may refer to a series of images over time. A picture generally refers to the unit representing one image at a particular time frame, and a slice/tile refers to the unit constituting a part of the picture in terms of coding. A slice/tile may include one or more coding tree units (CTUs). One picture may consist of one or more slices/tiles. One picture may consist of one or more tile groups. One tile group may include one or more tiles. A brick may represent a rectangular region of CTU rows within a tile in a picture). A tile may be partitioned into multiple bricks, each of which consisting of one or more CTU rows within the tile. A tile that is not partitioned into multiple bricks may be also referred to as a brick. A brick scan is a specific sequential ordering of CTUs partitioning a picture in which the CTUs are ordered consecutively in CTU raster scan in a brick, bricks within a tile are ordered consecutively in a raster scan of the bricks of the tile, and tiles in a picture are ordered consecutively in a raster scan of the tiles of the picture. A tile is a rectangular region of CTUs within a particular tile column and a particular tile row in a picture. The tile column is a rectangular region of CTUs having a height equal to the height of the picture and a width specified by syntax elements in the picture parameter set. The tile row is a rectangular region of CTUs having a height specified by syntax elements in the picture parameter set and a width equal to the width of the picture). A tile scan is a specific sequential ordering of CTUs partitioning a picture in which the CTUs are ordered consecutively in CTU raster scan in a tile whereas tiles in a picture are ordered consecutively in a raster scan of the tiles of the picture. A slice includes an integer number of bricks of a picture that may be exclusively contained in a single NAL unit. A slice may consist of either a number of complete tiles or only a consecutive sequence of complete bricks of one tile. In the present document, tile group and slice may be used interchangeably. For example, in the present document, a tile group/tile group header may be referred to as a slice/slice header.</p><p id="p-0031" num="0030">A pixel or a pel may mean a smallest unit constituting one picture (or image). Also, &#x2018;sample&#x2019; may be used as a term corresponding to a pixel. A sample may generally represent a pixel or a value of a pixel, and may represent only a pixel/pixel value of a luma component or only a pixel/pixel value of a chroma component.</p><p id="p-0032" num="0031">A unit may represent a basic unit of image processing. The unit may include at least one of a specific region of the picture and information related to the region. One unit may include one luma block and two chroma (ex. Cb, cr) blocks. The unit may be used interchangeably with terms such as block or area in some cases. In a general case, an M&#xd7;N block may include samples (or sample arrays) or a set (or array) of transform coefficients of M columns and N rows. Alternatively, the sample may mean a pixel value in the spatial domain, and when such a pixel value is transformed to the frequency domain, it may mean a transform coefficient in the frequency domain.</p><p id="p-0033" num="0032">The unit may be interchangeably used with the term such as a block or an area in some cases. Generally, an M&#xd7;N block may represent samples composed of M columns and N rows or a group of transform coefficients. The sample may generally represent a pixel or a value of the pixel, and may also represent only the pixel/pixel value of a luma component, and also represent only the pixel/pixel value of a chroma component. The sample may be used as the term corresponding to a pixel or a pel configuring one picture (or image).</p><p id="p-0034" num="0033">The disclosure of the present document may be modified in various forms, and specific embodiments thereof will be described and illustrated in the drawings. The terms used in the present document are used to merely describe specific embodiments, but are not intended to limit the disclosed method in the present document. An expression of a singular number includes an expression of &#x2018;at least one&#x2019;, so long as it is clearly read differently. The terms such as &#x201c;include&#x201d; and &#x201c;have&#x201d; are intended to indicate that features, numbers, steps, operations, elements, components, or combinations thereof used in the document exist and it should be thus understood that the possibility of existence or addition of one or more different features, numbers, steps, operations, elements, components, or combinations thereof is not excluded.</p><p id="p-0035" num="0034">In addition, each configuration of the drawings described in the present document is an independent illustration for explaining functions as features that are different from each other, and does not mean that each configuration is implemented by mutually different hardware or different software. For example, two or more of the configurations may be combined to form one configuration, and one configuration may also be divided into multiple configurations. Without departing from the gist of the disclosed method of the present document, embodiments in which configurations are combined and/or separated are included in the scope of the disclosure of the present document.</p><p id="p-0036" num="0035">In the present document, the term &#x201c;/&#x201c;and&#x201d;,&#x201d; should be interpreted to indicate &#x201c;and/or.&#x201d; For instance, the expression &#x201c;A/B&#x201d; may mean &#x201c;A and/or B.&#x201d; Further, &#x201c;A, B&#x201d; may mean &#x201c;A and/or B.&#x201d; Further, &#x201c;A/B/C&#x201d; may mean &#x201c;at least one of A, B, and/or C.&#x201d; Also, &#x201c;A/B/C&#x201d; may mean &#x201c;at least one of A, B, and/or C.&#x201d;</p><p id="p-0037" num="0036">Further, in the document, the term &#x201c;or&#x201d; should be interpreted to indicate &#x201c;and/or.&#x201d; For instance, the expression &#x201c;A or B&#x201d; may comprise 1) only A, 2) only B, and/or 3) both A and B. In other words, the term &#x201c;or&#x201d; in the present document should be interpreted to indicate &#x201c;additionally or alternatively.&#x201d;</p><p id="p-0038" num="0037">Further, the parentheses used in the present document may mean &#x201c;for example&#x201d;. Specifically, in case that &#x201c;prediction (intra prediction)&#x201d; is expressed, it may be indicated that &#x201c;intra prediction&#x201d; is proposed as an example of &#x201c;prediction&#x201d;. In other words, the term &#x201c;prediction&#x201d; in the present document is not limited to &#x201c;intra prediction&#x201d;, and &#x201c;intra prediction&#x201d; is proposed as an example of &#x201c;prediction&#x201d;. Further, even in case that &#x201c;prediction (i.e., intra prediction)&#x201d; is expressed, it may be indicated that &#x201c;intra prediction&#x201d; is proposed as an example of &#x201c;prediction&#x201d;.</p><p id="p-0039" num="0038">In the present document, technical features individually explained in one drawing may be individually implemented or simultaneously implemented.</p><p id="p-0040" num="0039">Hereinafter, embodiments of the present document will be described in detail with reference to the accompanying drawings. In addition, like reference numerals are used to indicate like elements throughout the drawings, and the same descriptions on the like elements may be omitted.</p><p id="p-0041" num="0040"><figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates an example of a video/image coding system to which the embodiments of the present document may be applied.</p><p id="p-0042" num="0041">Referring to <figref idref="DRAWINGS">FIG. <b>1</b></figref>, a video/image coding system may include a first device (a source device) and a second device (a reception device). The source device may transmit encoded video/image information or data to the reception device through a digital storage medium or network in the form of a file or streaming.</p><p id="p-0043" num="0042">The source device may include a video source, an encoding apparatus, and a transmitter. The receiving device may include a receiver, a decoding apparatus, and a renderer. The encoding apparatus may be called a video/image encoding apparatus, and the decoding apparatus may be called a video/image decoding apparatus. The transmitter may be included in the encoding apparatus. The receiver may be included in the decoding apparatus. The renderer may include a display, and the display may be configured as a separate device or an external component.</p><p id="p-0044" num="0043">The video source may acquire video/image through a process of capturing, synthesizing, or generating the video/image. The video source may include a video/image capture device and/or a video/image generating device. The video/image capture device may include, for example, one or more cameras, video/image archives including previously captured video/images, and the like. The video/image generating device may include, for example, computers, tablets and smartphones, and may (electronically) generate video/images. For example, a virtual video/image may be generated through a computer or the like. In this case, the video/image capturing process may be replaced by a process of generating related data.</p><p id="p-0045" num="0044">The encoding apparatus may encode input video/image. The encoding apparatus may perform a series of procedures such as prediction, transform, and quantization for compaction and coding efficiency. The encoded data (encoded video/image information) may be output in the form of a bitstream.</p><p id="p-0046" num="0045">The transmitter may transmit the encoded image/image information or data output in the form of a bitstream to the receiver of the receiving device through a digital storage medium or a network in the form of a file or streaming. The digital storage medium may include various storage mediums such as USB, SD, CD, DVD, Blu-ray, HDD, SSD, and the like. The transmitter may include an element for generating a media file through a predetermined file format and may include an element for transmission through a broadcast/communication network. The receiver may receive/extract the bitstream and transmit the received bitstream to the decoding apparatus.</p><p id="p-0047" num="0046">The decoding apparatus may decode the video/image by performing a series of procedures such as dequantization, inverse transform, and prediction corresponding to the operation of the encoding apparatus.</p><p id="p-0048" num="0047">The renderer may render the decoded video/image. The rendered video/image may be displayed through the display.</p><p id="p-0049" num="0048"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a diagram schematically illustrating the configuration of a video/image encoding apparatus to which the embodiments of the present document may be applied. Hereinafter, what is referred to as the video encoding apparatus may include an image encoding apparatus.</p><p id="p-0050" num="0049">Referring to <figref idref="DRAWINGS">FIG. <b>2</b></figref>, the encoding apparatus <b>200</b> may include and be configured with an image partitioner <b>210</b>, a predictor <b>220</b>, a residual processor <b>230</b>, an entropy encoder <b>240</b>, an adder <b>250</b>, a filter <b>260</b>, and a memory <b>270</b>. The predictor <b>220</b> may include an inter predictor <b>221</b> and an intra predictor <b>222</b>. The residual processor <b>230</b> may include a transformer <b>232</b>, a quantizer <b>233</b>, a dequantizer <b>234</b>, and an inverse transformer <b>235</b>. The residual processor <b>230</b> may further include a subtractor <b>231</b>. The adder <b>250</b> may be called a reconstructor or reconstructed block generator. The image partitioner <b>210</b>, the predictor <b>220</b>, the residual processor <b>230</b>, the entropy encoder <b>240</b>, the adder <b>250</b>, and the filter <b>260</b>, which have been described above, may be configured by one or more hardware components (e.g., encoder chipsets or processors) according to an embodiment. In addition, the memory <b>270</b> may include a decoded picture buffer (DPB), and may also be configured by a digital storage medium. The hardware component may further include the memory <b>270</b> as an internal/external component.</p><p id="p-0051" num="0050">The image partitioner <b>210</b> may split an input image (or, picture, frame) input to the encoding apparatus <b>200</b> into one or more processing units. As an example, the processing unit may be called a coding unit (CU). In this case, the coding unit may be recursively split according to a Quad-tree binary-tree ternary-tree (QTBTTT) structure from a coding tree unit (CTU) or the largest coding unit (LCU). For example, one coding unit may be split into a plurality of coding units of a deeper depth based on a quad-tree structure, a binary-tree structure, and/or a ternary-tree structure. In this case, for example, the quad-tree structure is first applied and the binary-tree structure and/or the ternary-tree structure may be later applied. Alternatively, the binary-tree structure may also be first applied. A coding procedure according to the present document may be performed based on a final coding unit which is not split any more. In this case, based on coding efficiency according to image characteristics or the like, the maximum coding unit may be directly used as the final coding unit, or as necessary, the coding unit may be recursively split into coding units of a deeper depth, such that a coding unit having an optimal size may be used as the final coding unit. Here, the coding procedure may include a procedure such as prediction, transform, and reconstruction to be described later. As another example, the processing unit may further include a prediction unit (PU) or a transform unit (TU). In this case, each of the prediction unit and the transform unit may be split or partitioned from the aforementioned final coding unit. The prediction unit may be a unit of sample prediction, and the transform unit may be a unit for inducing a transform coefficient and/or a unit for inducing a residual signal from the transform coefficient.</p><p id="p-0052" num="0051">The encoding apparatus <b>200</b> may subtract the prediction signal (predicted block, prediction sample array) output from the inter predictor <b>221</b> or the intra predictor <b>222</b> from the input image signal (original block, original sample array) to generate a residual signal (residual block, residual sample array), and the generated residual signal is transmitted to the transformer <b>232</b>. In this case, as illustrated, a unit for subtracting the prediction signal (prediction block, prediction sample array) from an input image signal (original block, original sample array) in the encoder <b>200</b> may be referred to as a subtractor <b>231</b>. The predictor <b>220</b> may perform prediction on a processing target block (hereinafter, referred to as a current block) and generate a predicted block including prediction samples for the current block. The predictor <b>220</b> may determine whether intra prediction or inter prediction is applied in units of a current block or CU. The predictor <b>220</b> may generate various kinds of information on prediction, such as prediction mode information, and transmit the generated information to the entropy encoder <b>240</b>, as is described below in the description of each prediction mode. The information on prediction may be encoded by the entropy encoder <b>240</b> and output in the form of a bitstream.</p><p id="p-0053" num="0052">The intra predictor <b>222</b> may predict a current block with reference to samples within a current picture. The referenced samples may be located neighboring to the current block, or may also be located away from the current block according to the prediction mode. The prediction modes in the intra prediction may include a plurality of non-directional modes and a plurality of directional modes. The non-directional mode may include, for example, a DC mode or a planar mode. The directional mode may include, for example, 33 directional prediction modes or 65 directional prediction modes according to the fine degree of the prediction direction. However, this is illustrative and the directional prediction modes which are more or less than the above number may be used according to the setting. The intra predictor <b>222</b> may also determine the prediction mode applied to the current block using the prediction mode applied to the neighboring block.</p><p id="p-0054" num="0053">The inter predictor <b>221</b> may induce a predicted block of the current block based on a reference block (reference sample array) specified by a motion vector on a reference picture. At this time, in order to decrease the amount of motion information transmitted in the inter prediction mode, the motion information may be predicted in units of a block, a sub-block, or a sample based on the correlation of the motion information between the neighboring block and the current block. The motion information may include a motion vector and a reference picture index. The motion information may further include inter prediction direction (L0 prediction, L1 prediction, Bi prediction, or the like) information. In the case of the inter prediction, the neighboring block may include a spatial neighboring block existing within the current picture and a temporal neighboring block existing in the reference picture. The reference picture including the reference block and the reference picture including the temporal neighboring block may also be the same as each other, and may also be different from each other. The temporal neighboring block may be called the name such as a collocated reference block, a collocated CU (colCU), or the like, and the reference picture including the temporal neighboring block may also be called a collocated picture (colPic). For example, the inter predictor <b>221</b> may configure a motion information candidate list based on the neighboring blocks, and generate information indicating what candidate is used to derive the motion vector and/or the reference picture index of the current block. The inter prediction may be performed based on various prediction modes, and for example, in the case of a skip mode and a merge mode, the inter predictor <b>221</b> may use the motion information of the neighboring block as the motion information of the current block. In the case of the skip mode, the residual signal may not be transmitted unlike the merge mode. A motion vector prediction (MVP) mode may indicate the motion vector of the current block by using the motion vector of the neighboring block as a motion vector predictor, and signaling a motion vector difference.</p><p id="p-0055" num="0054">The predictor <b>220</b> may generate a prediction signal based on various prediction methods to be described below. For example, the predictor <b>220</b> may apply intra prediction or inter prediction for prediction of one block and may simultaneously apply intra prediction and inter prediction. This may be called combined inter and intra prediction (CIIP). In addition, the predictor may be based on an intra block copy (IBC) prediction mode or based on a palette mode for prediction of a block. The IBC prediction mode or the palette mode may be used for image/video coding of content such as games, for example, screen content coding (SCC). IBC basically performs prediction within the current picture, but may be performed similarly to inter prediction in that a reference block is derived within the current picture. That is, IBC may use at least one of the inter prediction techniques described in the present document. The palette mode may be viewed as an example of intra coding or intra prediction. When the palette mode is applied, a sample value in the picture may be signaled based on information on the palette table and the palette index.</p><p id="p-0056" num="0055">The prediction signal generated by the predictor (including the inter predictor <b>221</b> and/or the intra predictor <b>222</b>) may be used to generate a reconstructed signal or may be used to generate a residual signal.</p><p id="p-0057" num="0056">The transformer <b>232</b> may generate transform coefficients by applying a transform technique to the residual signal. For example, the transform technique may include at least one of a discrete cosine transform (DCT), a discrete sine transform (DST), a graph-based transform (GBT), or a conditionally non-linear transform (CNT). Here, GBT refers to transformation obtained from a graph when expressing relationship information between pixels in the graph. CNT refers to transformation obtained based on a prediction signal generated using all previously reconstructed pixels. Also, the transformation process may be applied to a block of pixels having the same size as a square or may be applied to a block of a variable size that is not a square.</p><p id="p-0058" num="0057">The quantizer <b>233</b> quantizes the transform coefficients and transmits the same to the entropy encoder <b>240</b>, and the entropy encoder <b>240</b> encodes the quantized signal (information on the quantized transform coefficients) and outputs the encoded signal as a bitstream. Information on the quantized transform coefficients may be referred to as residual information. The quantizer <b>233</b> may rearrange the quantized transform coefficients in the block form into a one-dimensional vector form based on a coefficient scan order and may generate information on the transform coefficients based on the quantized transform coefficients in the one-dimensional vector form.</p><p id="p-0059" num="0058">The entropy encoder <b>240</b> may perform various encoding methods such as, for example, exponential Golomb, context-adaptive variable length coding (CAVLC), and context-adaptive binary arithmetic coding (CABAC). The entropy encoder <b>240</b> may encode information necessary for video/image reconstruction (e.g., values of syntax elements, etc.) other than the quantized transform coefficients together or separately. Encoded information (e.g., encoded video/image information) may be transmitted or stored in units of a network abstraction layer (NAL) unit in the form of a bitstream. The video/image information may further include information on various parameter sets, such as an adaptation parameter set (APS), a picture parameter set (PPS), a sequence parameter set (SPS), or a video parameter set (VPS). Also, the video/image information may further include general constraint information. In the present document, information and/or syntax elements transmitted/signaled from the encoding apparatus to the decoding apparatus may be included in video/image information. The video/image information may be encoded through the encoding procedure described above and included in the bitstream. The bitstream may be transmitted through a network or may be stored in a digital storage medium. Here, the network may include a broadcasting network and/or a communication network, and the digital storage medium may include various storage media such as USB, SD, CD, DVD, Blu-ray, HDD, and SSD. A transmitting unit (not shown) and/or a storing unit (not shown) for transmitting or storing a signal output from the entropy encoder <b>240</b> may be configured as internal/external elements of the encoding apparatus <b>200</b>, or the transmitting unit may be included in the entropy encoder <b>240</b>.</p><p id="p-0060" num="0059">The quantized transform coefficients output from the quantizer <b>233</b> may be used to generate a prediction signal. For example, the residual signal (residual block or residual samples) may be reconstructed by applying dequantization and inverse transform to the quantized transform coefficients through the dequantizer <b>234</b> and the inverse transform unit <b>235</b>. The adder <b>250</b> may add the reconstructed residual signal to the prediction signal output from the inter predictor <b>221</b> or the intra predictor <b>222</b> to generate a reconstructed signal (reconstructed picture, reconstructed block, reconstructed sample array). When there is no residual for the processing target block, such as when the skip mode is applied, the predicted block may be used as a reconstructed block. The adder <b>250</b> may be referred to as a restoration unit or a restoration block generator. The generated reconstructed signal may be used for intra prediction of a next processing target block in the current picture, or may be used for inter prediction of the next picture after being filtered as described below.</p><p id="p-0061" num="0060">Meanwhile, luma mapping with chroma scaling (LMCS) may be applied during a picture encoding and/or reconstruction process.</p><p id="p-0062" num="0061">The filter <b>260</b> may improve subjective/objective image quality by applying filtering to the reconstructed signal. For example, the filter <b>260</b> may generate a modified reconstructed picture by applying various filtering methods to the reconstructed picture, and store the modified reconstructed picture in the memory <b>270</b>, specifically, in a DPB of the memory <b>270</b>. The various filtering methods may include, for example, deblocking filtering, a sample adaptive offset, an adaptive loop filter, a bilateral filter, and the like. The filter <b>260</b> may generate various kinds of information related to the filtering, and transfer the generated information to the entropy encoder <b>240</b> as described later in the description of each filtering method. The information related to the filtering may be encoded by the entropy encoder <b>240</b> and output in the form of a bitstream.</p><p id="p-0063" num="0062">The modified reconstructed picture transmitted to the memory <b>270</b> may be used as a reference picture in the inter predictor <b>221</b>. When the inter prediction is applied through the encoding apparatus, prediction mismatch between the encoding apparatus <b>200</b> and the decoding apparatus may be avoided and encoding efficiency may be improved.</p><p id="p-0064" num="0063">The DPB of the memory <b>270</b> may store the modified reconstructed picture for use as the reference picture in the inter predictor <b>221</b>. The memory <b>270</b> may store motion information of a block from which the motion information in the current picture is derived (or encoded) and/or motion information of blocks in the picture, having already been reconstructed. The stored motion information may be transferred to the inter predictor <b>221</b> to be utilized as motion information of the spatial neighboring block or motion information of the temporal neighboring block. The memory <b>270</b> may store reconstructed samples of reconstructed blocks in the current picture, and may transfer the reconstructed samples to the intra predictor <b>222</b>.</p><p id="p-0065" num="0064"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a diagram for schematically explaining the configuration of a video/image decoding apparatus to which the embodiments of the present document may be applied.</p><p id="p-0066" num="0065">Referring to <figref idref="DRAWINGS">FIG. <b>3</b></figref>, the decoding apparatus <b>300</b> may include and configured with an entropy decoder <b>310</b>, a residual processor <b>320</b>, a predictor <b>330</b>, an adder <b>340</b>, a filter <b>350</b>, and a memory <b>360</b>. The predictor <b>330</b> may include an inter predictor <b>331</b> and an intra predictor <b>332</b>. The residual processor <b>320</b> may include a dequantizer <b>321</b> and an inverse transformer <b>322</b>. The entropy decoder <b>310</b>, the residual processor <b>320</b>, the predictor <b>330</b>, the adder <b>340</b>, and the filter <b>350</b>, which have been described above, may be configured by one or more hardware components (e.g., decoder chipsets or processors) according to an embodiment. Further, the memory <b>360</b> may include a decoded picture buffer (DPB), and may be configured by a digital storage medium. The hardware component may further include the memory <b>360</b> as an internal/external component.</p><p id="p-0067" num="0066">When the bitstream including the video/image information is input, the decoding apparatus <b>300</b> may reconstruct the image in response to a process in which the video/image information is processed in the encoding apparatus illustrated in <figref idref="DRAWINGS">FIG. <b>2</b></figref>. For example, the decoding apparatus <b>300</b> may derive the units/blocks based on block split-related information acquired from the bitstream. The decoding apparatus <b>300</b> may perform decoding using the processing unit applied to the encoding apparatus. Therefore, the processing unit for the decoding may be, for example, a coding unit, and the coding unit may be split according to the quad-tree structure, the binary-tree structure, and/or the ternary-tree structure from the coding tree unit or the maximum coding unit. One or more transform units may be derived from the coding unit. In addition, the reconstructed image signal decoded and output through the decoding apparatus <b>300</b> may be reproduced through a reproducing apparatus.</p><p id="p-0068" num="0067">The decoding apparatus <b>300</b> may receive a signal output from the encoding apparatus of <figref idref="DRAWINGS">FIG. <b>2</b></figref> in the form of a bitstream, and the received signal may be decoded through the entropy decoder <b>310</b>. For example, the entropy decoder <b>310</b> may parse the bitstream to derive information (e.g., video/image information) necessary for image reconstruction (or picture reconstruction). The video/image information may further include information on various parameter sets such as an adaptation parameter set (APS), a picture parameter set (PPS), a sequence parameter set (SPS), or a video parameter set (VPS). In addition, the video/image information may further include general constraint information. The decoding apparatus may further decode picture based on the information on the parameter set and/or the general constraint information. Signaled/received information and/or syntax elements described later in the present document may be decoded may decode the decoding procedure and obtained from the bitstream. For example, the entropy decoder <b>310</b> decodes the information in the bitstream based on a coding method such as exponential Golomb coding, context-adaptive variable length coding (CAVLC), or context-adaptive arithmetic coding (CABAC), and output syntax elements required for image reconstruction and quantized values of transform coefficients for residual. More specifically, the CABAC entropy decoding method may receive a bin corresponding to each syntax element in the bitstream, determine a context model by using a decoding target syntax element information, decoding information of a decoding target block or information of a symbol/bin decoded in a previous stage, and perform an arithmetic decoding on the bin by predicting a probability of occurrence of a bin according to the determined context model, and generate a symbol corresponding to the value of each syntax element. In this case, the CABAC entropy decoding method may update the context model by using the information of the decoded symbol/bin for a context model of a next symbol/bin after determining the context model. The information related to the prediction among the information decoded by the entropy decoder <b>310</b> may be provided to the predictor (inter predictor <b>332</b> and intra predictor <b>331</b>), and residual values on which the entropy decoding has been performed in the entropy decoder <b>310</b>, that is, the quantized transform coefficients and related parameter information, may be input to the residual processor <b>320</b>.</p><p id="p-0069" num="0068">The residual processor <b>320</b> may derive a residual signal (residual block, residual samples, or residual sample array). Also, information on filtering among the information decoded by the entropy decoder <b>310</b> may be provided to the filter <b>350</b>. Meanwhile, a receiving unit (not shown) for receiving a signal output from the encoding apparatus may be further configured as an internal/external element of the decoding apparatus <b>300</b>, or the receiving unit may be a component of the entropy decoder <b>310</b>. Meanwhile, the decoding apparatus according to the present document may be called a video/image/picture decoding apparatus, and the decoding apparatus may be divided into an information decoder (video/image/picture information decoder) and a sample decoder (video/image/picture sample decoder). The information decoder may include the entropy decoder <b>310</b>, and the sample decoder may include at least one of the dequantizer <b>321</b>, the inverse transformer <b>322</b>, the adder <b>340</b>, the filter <b>350</b>, the memory <b>360</b>, an inter predictor <b>332</b>, and an intra predictor <b>331</b>.</p><p id="p-0070" num="0069">The dequantizer <b>321</b> may dequantize the quantized transform coefficients to output the transform coefficients. The dequantizer <b>321</b> may rearrange the quantized transform coefficients in a two-dimensional block form. In this case, the rearrangement may be performed based on a coefficient scan order performed by the encoding apparatus. The dequantizer <b>321</b> may perform dequantization for the quantized transform coefficients using a quantization parameter (e.g., quantization step size information), and acquire the transform coefficients.</p><p id="p-0071" num="0070">The inverse transformer <b>322</b> inversely transforms the transform coefficients to acquire the residual signal (residual block, residual sample array).</p><p id="p-0072" num="0071">In the present document, at least one of quantization/dequantization and/or transform/inverse transform may be omitted. When the quantization/dequantization is omitted, the quantized transform coefficient may be referred to as a transform coefficient. When the transform/inverse transform is omitted, the transform coefficient may be called a coefficient or a residual coefficient or may still be called the transform coefficient for uniformity of expression.</p><p id="p-0073" num="0072">In the present document, the quantized transform coefficient and the transform coefficient may be referred to as a transform coefficient and a scaled transform coefficient, respectively. In this case, the residual information may include information on transform coefficient(s), and the information on the transform coefficient(s) may be signaled through residual coding syntax. Transform coefficients may be derived based on the residual information (or information on the transform coefficient(s)), and scaled transform coefficients may be derived through inverse transform (scaling) on the transform coefficients. Residual samples may be derived based on inverse transform (transform) of the scaled transform coefficients. This may be applied/expressed in other parts of the present document as well.</p><p id="p-0074" num="0073">The predictor <b>330</b> may perform the prediction of the current block, and generate a predicted block including the prediction samples of the current block. The predictor may determine whether the intra prediction is applied or the inter prediction is applied to the current block based on the information on prediction output from the entropy decoder <b>310</b>, and determine a specific intra/inter prediction mode.</p><p id="p-0075" num="0074">The predictor <b>330</b> may generate a prediction signal based on various prediction methods to be described later. For example, the predictor may apply intra prediction or inter prediction for prediction of one block, and may simultaneously apply intra prediction and inter prediction. This may be called combined inter and intra prediction (CIIP). In addition, the predictor may be based on an intra block copy (IBC) prediction mode or based on a palette mode for prediction of a block. The IBC prediction mode or the palette mode may be used for image/video coding of content such as games, for example, screen content coding (SCC). IBC may basically perform prediction within the current picture, but may be performed similarly to inter prediction in that a reference block is derived within the current picture. That is, IBC may use at least one of the inter prediction techniques described in the present document. The palette mode may be considered as an example of intra coding or intra prediction. When the palette mode is applied, information on the palette table and the palette index may be included in the video/image information and signaled.</p><p id="p-0076" num="0075">The intra predictor <b>331</b> may predict the current block by referring to the samples in the current picture. The referred samples may be located in the neighborhood of the current block, or may be located apart from the current block according to the prediction mode. In intra prediction, prediction modes may include a plurality of non-directional modes and a plurality of directional modes. The intra predictor <b>331</b> may determine the prediction mode to be applied to the current block by using the prediction mode applied to the neighboring block.</p><p id="p-0077" num="0076">The inter predictor <b>332</b> may derive a predicted block for the current block based on a reference block (reference sample array) specified by a motion vector on a reference picture. In this case, in order to reduce the amount of motion information being transmitted in the inter prediction mode, motion information may be predicted in the unit of blocks, subblocks, or samples based on correlation of motion information between the neighboring block and the current block. The motion information may include a motion vector and a reference picture index. The motion information may further include information on inter prediction direction (L0 prediction, L1 prediction, Bi prediction, and the like). In case of inter prediction, the neighboring block may include a spatial neighboring block existing in the current picture and a temporal neighboring block existing in the reference picture. For example, the inter predictor <b>332</b> may construct a motion information candidate list based on neighboring blocks, and derive a motion vector of the current block and/or a reference picture index based on the received candidate selection information. Inter prediction may be performed based on various prediction modes, and the information on the prediction may include information indicating a mode of inter prediction for the current block.</p><p id="p-0078" num="0077">The adder <b>340</b> may generate a reconstructed signal (reconstructed picture, reconstructed block, or reconstructed sample array) by adding the obtained residual signal to the prediction signal (predicted block or predicted sample array) output from the predictor (including inter predictor <b>332</b> and/or intra predictor <b>331</b>). If there is no residual for the processing target block, such as a case that a skip mode is applied, the predicted block may be used as the reconstructed block.</p><p id="p-0079" num="0078">The adder <b>340</b> may be called a reconstructor or a reconstructed block generator. The generated reconstructed signal may be used for the intra prediction of a next block to be processed in the current picture, and as described later, may also be output through filtering or may also be used for the inter prediction of a next picture.</p><p id="p-0080" num="0079">Meanwhile, a luma mapping with chroma scaling (LMCS) may also be applied in the picture decoding process.</p><p id="p-0081" num="0080">The filter <b>350</b> may improve subjective/objective image quality by applying filtering to the reconstructed signal. For example, the filter <b>350</b> may generate a modified reconstructed picture by applying various filtering methods to the reconstructed picture, and store the modified reconstructed picture in the memory <b>360</b>, specifically, in a DPB of the memory <b>360</b>. The various filtering methods may include, for example, deblocking filtering, a sample adaptive offset, an adaptive loop filter, a bilateral filter, and the like.</p><p id="p-0082" num="0081">The (modified) reconstructed picture stored in the DPB of the memory <b>360</b> may be used as a reference picture in the inter predictor <b>332</b>. The memory <b>360</b> may store the motion information of the block from which the motion information in the current picture is derived (or decoded) and/or the motion information of the blocks in the picture having already been reconstructed. The stored motion information may be transferred to the inter predictor <b>332</b> so as to be utilized as the motion information of the spatial neighboring block or the motion information of the temporal neighboring block. The memory <b>360</b> may store reconstructed samples of reconstructed blocks in the current picture, and transfer the reconstructed samples to the intra predictor <b>331</b>.</p><p id="p-0083" num="0082">In the present document, the embodiments described in the filter <b>260</b>, the inter predictor <b>221</b>, and the intra predictor <b>222</b> of the encoding apparatus <b>200</b> may be applied equally or to correspond to the filter <b>350</b>, the inter predictor <b>332</b>, and the intra predictor <b>331</b>.</p><p id="p-0084" num="0083">Meanwhile, the video/image coding method according to the present document may be performed based on the following partitioning structure. Specifically, above described procedures of prediction, residual processing ((inverse) transform and (de)quantization), syntax element coding, and filtering may be performed based on CTU and CU (and/or TU and PU) derived based on the partitioning structure. A block partitioning procedure may be performed by the image partitioner <b>210</b> of the above-described encoding apparatus, and partitioning-related information may be (encoding) processed by the entropy encoder <b>240</b>, and may be transferred to the decoding apparatus in the form of a bitstream. The entropy decoder <b>310</b> of the decoding apparatus may derive the block partitioning structure of the current picture based on the partitioning-related information obtained from the bitstream, and based on this, may perform a series of procedures (e.g., prediction, residual processing, block/picture reconstruction, in-loop filtering, and the like) for image decoding. The CU size and the TU size may be equal to each other, or a plurality of TUs may be present within a CU region. Meanwhile, the CU size may generally represent a luma component (sample) coding block (CB) size. The TU size may generally represent a luma component (sample) transform block (TB) size. The chroma component (sample) CB or TB size may be derived based on the luma component (sample) CB or TB size in accordance with a component ratio according to a color format (chroma format, e.g., 4:4:4, 4:2:2, 4:2:0 and the like) of a picture/image. The TU size may be derived based on maxTbSize. For example, if the CU size is larger than the maxTbSize, a plurality of TUs (TBs) of the maxTbSize may be derived from the CU, and the transform/inverse transform may be performed in the unit of TU (TB). Further, for example, in case that intra prediction is applied, the intra prediction mode/type may be derived in the unit of CU (or CB), and neighboring reference sample derivation and prediction sample generation procedures may be performed in the unit of TU (or TB). In this case, one or a plurality of TUs (or TBs) may be present in one CU (or CB) region, and in this case, the plurality of TUs (or TBs) may share the same intra prediction mode/type.</p><p id="p-0085" num="0084">Further, in the video/image coding according to the present document, an image processing unit may have a hierarchical structure. One picture may be partitioned into one or more tiles, bricks, slices, and/or tile groups. One slice may include one or more bricks. On brick may include one or more CTU rows within a tile. The slice may include an integer number of bricks of a picture. One tile group may include one or more tiles. One tile may include one or more CTUs. The CTU may be partitioned into one or more CUs. A tile represents a rectangular region of CTUs within a particular tile column and a particular tile row in a picture. A tile group may include an integer number of tiles according to a tile raster scan in the picture. A slice header may carry information/parameters that can be applied to the corresponding slice (blocks in the slice). In case that the encoding/decoding apparatus has a multi-core processor, encoding/decoding processes for the tiles, slices, bricks, and/or tile groups may be processed in parallel. In the present document, the slice or the tile group may be used exchangeably. That is, a tile group header may be called a slice header. Here, the slice may have one of slice types including intra (I) slice, predictive (P) slice, and bi-predictive (B) slice. In predicting blocks in I slice, inter prediction may not be used, and only intra prediction may be used. Of course, even in this case, signaling may be performed by coding the original sample value without prediction. With respect to blocks in P slice, intra prediction or inter prediction may be used, and in case of using the inter prediction, only uni-prediction can be used. Meanwhile, with respect to blocks in B slice, the intra prediction or inter prediction may be used, and in case of using the inter prediction, up to bi-prediction can be maximally used.</p><p id="p-0086" num="0085">The encoding apparatus may determine the tile/tile group, brick, slice, and maximum and minimum coding unit sizes in consideration of the coding efficiency or parallel processing, or according to the characteristics (e.g., resolution) of a video image, and information for them or information capable of inducing them may be included in the bitstream.</p><p id="p-0087" num="0086">The decoding apparatus may obtain information representing the tile/tile group, brick, and slice of the current picture, and whether the CTU in the tile has been partitioned into a plurality of coding units. By making such information be obtained (transmitted) only under a specific condition, the efficiency can be enhanced.</p><p id="p-0088" num="0087">Meanwhile, as described above, one picture may include a plurality of slices, and one slice may include a slice header and slice data. In this case, one picture header may be further added to a plurality of slices (a slice header and a slice data set) in one picture. The picture header (picture header syntax) may include information/parameters commonly applicable to the picture. The slice header (slice header syntax) may include information/parameters that may be commonly applied to the slice. An adaptation parameter set (APS) or a picture parameter set (PPS) may include information/parameters that may be commonly applied to one or more slices or pictures. A sequence parameter set (SPS) may include information/parameters that may be commonly applied to one or more sequences. A video parameter set (VPS) may include information/parameters that may be commonly applied to multiple layers. A decoding parameter set (DPS) may include information/parameters that may be commonly applied to the overall video. The DPS may include information/parameters related to concatenation of a coded video sequence (CVS).</p><p id="p-0089" num="0088">A high level syntax (HLS) in the present disclosure include at least one of the APS syntax, the PPS syntax, the SPS syntax, the VPS syntax, the DPS syntax, and the slice header syntax.</p><p id="p-0090" num="0089">Additionally, for example, information on the partitioning and configuration, and so on, of a tile/tile group/brick/slice may be configured in an encoding apparatus based on the high level syntax and may then be delivered (or transferred) to a decoding apparatus in a bitstream format.</p><p id="p-0091" num="0090">A picture may be partitioned to one or more tile rows and one or more tile columns. A tile is a sequence of CTUs covering a rectangular region of a picture. A tile may be partitioned to one or more bricks, and each brick may be configured of multiple CTU rows. A tile that is not partitioned to a plurality of bricks may also be referred to as a brick. However, a brick being a subset of a tile is not referred to as a tile. A slice may include multiple tiles or multiple bricks of a tile.</p><p id="p-0092" num="0091"><figref idref="DRAWINGS">FIG. <b>4</b></figref> shows an example of a picture decoding procedure.</p><p id="p-0093" num="0092">In image/video coding, a picture that configures an image/video may be encoded/decoded according to a decoding order. A picture order that corresponds to an output order of a decoded picture may be configured differently from the decoding order. And, when performing inter prediction based on the configured picture order, forward prediction as well as reverse prediction may be performed.</p><p id="p-0094" num="0093"><figref idref="DRAWINGS">FIG. <b>4</b></figref> shows a general example of a picture decoding procedure to which an embodiment(s) of the present disclosure can be applied. In <figref idref="DRAWINGS">FIG. <b>4</b></figref>, S<b>400</b> may be performed by the entropy decoder <b>310</b> of the decoding apparatus that is described above in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, S<b>410</b> may be performed by the predictor <b>330</b>, S<b>420</b> may be performed by the residual processor <b>320</b>, S<b>430</b> may be performed by the adder <b>340</b>, and S<b>440</b> may be performed by the filter <b>350</b>. S<b>400</b> may include an information decoding procedure that is described in the present specification, S<b>410</b> may include an inter/intra prediction procedure that is described in the present specification, S<b>420</b> may include a residual processing procedure that is described in the present specification, S<b>430</b> may include a block/picture reconstruction procedure that is described in the present specification, and S<b>440</b> may include an in-loop filtering procedure that is described in the present specification.</p><p id="p-0095" num="0094">Referring to <figref idref="DRAWINGS">FIG. <b>4</b></figref>, as described above in <figref idref="DRAWINGS">FIG. <b>3</b></figref>, the picture decoding procedure may generally include a procedure of obtaining an image/video information (S<b>400</b>) from a bitstream (through decoding), a picture reconstruction procedure (S<b>410</b> to S<b>430</b>), and an in-loop filtering procedure (S<b>440</b>) for the reconstructed picture. The picture reconstruction procedure may be performed based on prediction samples and residual samples that are obtained by performing the inter/intra prediction procedure (S<b>410</b>) and the residual processing procedure (S<b>420</b>, dequantization and inverse transform procedures on quantized transform coefficients). By performing an in-loop filtering procedure on the reconstructed picture that is generated by performing the picture reconstruction procedure, a modified reconstructed picture may be generated, and the modified reconstructed picture may be outputted as a decoded picture, which is then stored in a decoding picture buffer or memory <b>360</b> of the decoding apparatus so as to be used as a reference picture during an inter prediction procedure when performing decoding of a picture in a later process. In some cases, the in-loop filtering procedure may be skipped. And, in this case, the reconstructed picture may be outputted as the decoded picture, which is then stored in a decoding picture buffer or memory <b>360</b> of the decoding apparatus so as to be used as a reference picture during an inter prediction procedure when performing decoding of a picture in a later process. As described above, the in-loop filtering procedure (S<b>440</b>) may include a deblocking filtering procedure, a sample adaptive offset (SAO) procedure, an adaptive loop filter (ALF) procedure, and/or a bi-lateral filter procedure, and so on, and part or all of the in-loop filtering procedure may be skipped. Additionally, one or part of the deblocking filtering procedure, the sample adaptive offset (SAO) procedure, the adaptive loop filter (ALF) procedure, and the bi-lateral filter procedure may be sequentially applied, or all of the deblocking filtering procedure, the sample adaptive offset (SAO) procedure, the adaptive loop filter (ALF) procedure, and the bi-lateral filter procedure may be sequentially applied. For example, after the deblocking filtering procedure is applied to a reconstructed picture, the SAO procedure may be performed. Alternatively, for example, after the deblocking filtering procedure is applied to a reconstructed picture, the ALF procedure may be performed. This may also be performed likewise in an encoding apparatus.</p><p id="p-0096" num="0095"><figref idref="DRAWINGS">FIG. <b>5</b></figref> shows an example of a picture encoding procedure.</p><p id="p-0097" num="0096"><figref idref="DRAWINGS">FIG. <b>5</b></figref> shows a general example of a picture encoding procedure to which an embodiment(s) of the present disclosure can be applied. In <figref idref="DRAWINGS">FIG. <b>5</b></figref>, S<b>500</b> may be performed by the predictor <b>220</b> of the encoding apparatus that is described above in <figref idref="DRAWINGS">FIG. <b>2</b></figref>, S<b>510</b> may be performed by the residual processor <b>230</b>, and S<b>520</b> may be performed by the entropy encoder <b>240</b>. S<b>500</b> may include an inter/intra prediction procedure that is described in the present specification, S<b>610</b> may include a residual processing procedure that is described in the present specification, and S<b>520</b> may include an information encoding procedure that is described in the present specification.</p><p id="p-0098" num="0097">Referring to <figref idref="DRAWINGS">FIG. <b>5</b></figref>, as described above in <figref idref="DRAWINGS">FIG. <b>2</b></figref>, the picture encoding procedure may generally include a procedure of encoding information for picture reconstruction (e.g., prediction information, residual information, partitioning information, and so on) and outputting the encoded information in a bitstream format, as well as a procedure of generating a reconstructed picture for a current picture and a procedure of applying in-loop filtering to the reconstructed picture (optional). The encoding apparatus may derive residual samples (that are modified) from quantized transform coefficients through the dequantizer <b>234</b> and the inverse transformer <b>235</b>, and, then, the encoding apparatus may generate a reconstructed picture based on prediction samples, which are the output of S<b>500</b>, and the (modified) residual samples. The reconstructed picture that is generated as described above may be the same as the above-described reconstructed picture that is generated in the decoding apparatus. A modified reconstructed picture may be generated by performing an in-loop filtering procedure on the reconstructed picture, which is then stored in a decoding picture buffer or memory <b>270</b> of the decoding apparatus. And, just as in the decoding apparatus, the modified reconstructed picture may be used as a reference picture during an inter prediction procedure when encoding a picture. As described above, in some cases, part or all of the in-loop filtering procedure may be skipped. When the in-loop filtering procedure is performed, (in-loop) filtering related information (parameter) may be encoded in the entropy encoder <b>240</b> and then transmitted in a bitstream format, and the decoding apparatus may perform the in-loop filtering procedure by using the same method as the encoding apparatus based on the filtering related information.</p><p id="p-0099" num="0098">By performing the above-described in-loop filtering procedure, noise occurring when coding an image/moving picture image, such as a blocking artifact and a ringing artifact, may be reduced, and subjective/objective visual quality may be enhanced. Additionally, by having both the encoding apparatus and the decoding apparatus perform the in-loop filtering procedure, the encoding apparatus and the decoding apparatus may derive the same prediction result, increase reliability in picture coding, and reduce the size (or amount) of data that should be transmitted for picture coding.</p><p id="p-0100" num="0099">As described above, the picture reconstruction procedure may be performed in the decoding apparatus as well as in the encoding apparatus. A reconstructed block may be generated for each block unit based on intra prediction/inter prediction, and a reconstructed picture including reconstructed blocks may be generated. When a current picture/slice/tile group is an I picture/slice/tile group, the blocks included in the current picture/slice/tile group may be reconstructed based only on intra prediction. Meanwhile, when the current picture/slice/tile group is a P or B picture/slice/tile group, the blocks included in the current picture/slice/tile group may be reconstructed based on intra prediction or inter prediction. In this case, inter prediction may be applied to part of the blocks within the current picture/slice/tile group, and intra prediction may be applied to the remaining blocks. Color components of a picture may include a luma component and a chroma component. And, unless it is explicitly limited (or restricted) in the present specification, the methods and embodiments that are proposed in the present specification may be applied to the luma component and the chroma component.</p><p id="p-0101" num="0100"><figref idref="DRAWINGS">FIG. <b>6</b></figref> shows an exemplary hierarchical structure of a coded image/video.</p><p id="p-0102" num="0101">Referring to <figref idref="DRAWINGS">FIG. <b>6</b></figref>, a coded image/video may be divided into a video coding layer (VCL), which handles decoding processing of an image/video and the image/video itself, a sub-system transmitting and storing coded information, and a network abstraction layer (NAL), which is present between the VCL and the sub-system, and which handles a network adaptation function.</p><p id="p-0103" num="0102">The VCL may generate VCL data including compressed image data (slice data) or may generate a parameter set including information, such as a picture parameter set (PPS), a sequence parameter set (SPS), a video parameter set (VPS), and so on, or a supplemental enhancement information (SEI) message that is additionally needed in the coding process of the image.</p><p id="p-0104" num="0103">In the NAL, a NAL unit may be generated by adding header information (NAL unit header) to a raw byte sequence payload (RBSP) that is generated in a VCL. At this point, the RBSP refers to slice data, a parameter set, an SEI message, and so on, that is/are generated in the VCL. The NAL unit header may include NAL unit type information that is specified according to RBSP data, which is included in the corresponding NAL unit.</p><p id="p-0105" num="0104">As shown in the drawing, the NAL unit may be divided into a VCL NAL unit and a Non-VCL NAL unit according to the RBSP, which is generated in the VCL. The VCL NAL unit may mean a NAL unit that includes information on the image (slice data), and the Non-VCL NAL unit may mean a NAL unit that includes information (parameter set or SEI message) that is needed for decoding the image.</p><p id="p-0106" num="0105">The above-described VCL NAL unit and Non-VCL NAL unit may be transmitted through a network by attaching header information according to the data standard of the sub-system. For example, the NAL unit may be transformed into a data format of a predetermined standard, such as an H.266/VVC file format, a real-time transport protocol (RTP), a transport stream (TS), and so on, and transmitted through various networks.</p><p id="p-0107" num="0106">As described above, the NAL unit may be specified with the NAL unit type according to the RBSP data structure that is included in the corresponding NAL unit, and information on the NAL unit type may be stored in the NAL unit header and signaled.</p><p id="p-0108" num="0107">For example, the NAL unit may be classified into a VCL NAL unit type and a Non-VCL NAL unit type depending upon whether the NAL unit includes information (slice data) on an image. The VCL NAL unit type may be classified according to the nature and type of pictures included in the VCL NAL unit, and the Non-VCL NAL unit type may be classified according to types of parameter sets.</p><p id="p-0109" num="0108">The following is an example of a NAL unit type that is specified in accordance with a parameter set type that is included in a Non-VCL NAL unit type.<ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0109">Adaptation Parameter Set (APS) NAL unit: a NAL unit type including an APS</li>        <li id="ul0002-0002" num="0110">Decoding Parameter Set (DPS) NAL unit: a NAL unit type including a DPS</li>        <li id="ul0002-0003" num="0111">Video Parameter Set (VPS) NAL unit: a NAL unit type including a VPS</li>        <li id="ul0002-0004" num="0112">Sequence Parameter Set (SPS) NAL unit: a NAL unit type including a SPS</li>        <li id="ul0002-0005" num="0113">Picture Parameter Set (PPS) NAL unit: a NAL unit type including a PPS</li>        <li id="ul0002-0006" num="0114">Picture header (PH) NAL unit: a NAL unit type including a PH</li>    </ul>    </li></ul></p><p id="p-0110" num="0115">The aforementioned NAL unit types may have syntax information for the NAL unit type, and the syntax information may be stored in a NAL unit header and signaled. For example, the syntax information may be nal_unit_type, and NAL unit types may be specified by a nal_unit_type value.</p><p id="p-0111" num="0116">Meanwhile, as described above, one picture may include a plurality of slices, and one slice may include a slice header and slice data. In this case, one picture header may be further added to a plurality of slices (a slice header and slice data set) in one picture. The picture header (picture header syntax) may include information/parameters commonly applicable to the picture. The slice header (slice header syntax) may include information/parameters commonly applicable to the slice. The APS (APS syntax) or the PPS (PPS syntax) may include information/parameters commonly applicable to one or more slices or pictures. The SPS (SPS syntax) may include information/parameters commonly applicable to one or more sequences. The VPS (VPS syntax) may include information/parameters commonly applicable to multiple layers. The DPS (DPS syntax) may include information/parameters commonly applicable to the overall video. The DPS may include information/parameters related to concatenation of a coded video sequence (CVS). In the present specification, a high level syntax (HLS) may include at least one of the APS syntax, the PPS syntax, the SPS syntax, the VPS syntax, the DPS syntax, the picture header syntax, and the slice header syntax.</p><p id="p-0112" num="0117">In the present specification, the image/image information encoded from the encoding apparatus and signaled to the decoding apparatus in a bitstream format includes not only information related to partitioning within a picture, intra/inter prediction information, residual information, in-loop filtering information, and so on, but also information included in the slice header, information included in the APS, information included in the PPS, information included in an SPS, and/or information included in the VPS.</p><p id="p-0113" num="0118">Meanwhile, as described above, a high level syntax (HLS) may be coded/signaled for video/image coding. A coded picture may be configured of one or more slices. A parameter describing the coded picture is signaled within a picture header, and a parameter describing a slice is signaled within a slice header. The picture header is carried in its own NAL unit format. And, the slice header is present at a beginning (or starting point) of a NAL unit including a payload of the slice (i.e., slice data).</p><p id="p-0114" num="0119">Each picture is associated with a picture header. A picture may be configured of different types of slices (an intra-coded slice (i.e., I slice) and inter-coded slices (i.e., P slice and B slice)). Therefore, a picture header may include syntax elements that are needed in an intra slice of a picture and an inter slice of a picture.</p><p id="p-0115" num="0120">A picture may be partitioned to (or divided into) sub-pictures, tiles, and/or slices. Sub-picture signaling may be present in a sequence parameter set (SPS). And, tile and square slice signaling may be present in a picture parameter set (PPS). Raster-scan slice signaling may be present in a slice header.</p><p id="p-0116" num="0121">For example, in relation to the partitioning of a picture, syntax elements shown below in Table 1 may be included in an SPS syntax.</p><p id="p-0117" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="175pt" align="left"/><colspec colname="1" colwidth="42pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" rowsep="1">TABLE 1</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="175pt" align="left"/><colspec colname="2" colwidth="42pt" align="left"/><tbody valign="top"><row><entry>seq_parameter_set_rbsp( ) {</entry><entry/></row><row><entry>&#x2003;...</entry></row><row><entry>&#x2003;subpics_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( subpics_present_flag ) {</entry></row><row><entry>&#x2003;&#x2003;sps_num_subpics_minus1</entry><entry>u(8)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c;= sps_num_subpics_minus1; i++ ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;subpic_ctu_top_left_x[ i ]</entry><entry>u(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;subpic_ctu_top_left_y[ i ]</entry><entry>u(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;subpic_width_minus1[ i ]</entry><entry>u(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;subpic_height_minus1[ i ]</entry><entry>u(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;subpic_treated_as_pic_flag[ i ]</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;loop_filter_across_subpic_enabled_flag[ i ]</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;}</entry></row><row><entry>&#x2003;...</entry></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0118" num="0122">Syntax elements shown below in Table 2 may be included in a PPS syntax.</p><p id="p-0119" num="0000"><tables id="TABLE-US-00002" num="00002"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="245pt" align="left"/><colspec colname="1" colwidth="35pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" rowsep="1">TABLE 2</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="245pt" align="left"/><colspec colname="2" colwidth="35pt" align="left"/><tbody valign="top"><row><entry>pic_parameter_set_rbsp( ) {</entry><entry/></row><row><entry>&#x2003;...</entry></row><row><entry>&#x2003;no_pic_partition_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( !no_pic_partition_flag ) {</entry></row><row><entry>&#x2003;&#x2003;pps_log2_ctu_size_minus5</entry><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;num_exp_tile_columns_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;num_exp_tile_rows_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c;= num_exp_tile_columns_minus1; i++ )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;tile_column_width_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i &#x3c;= num_exp_tile_rows_minus1; i++ )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;tile_row_height_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;rect_slice_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( rect_slice_flag )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;single_slice_per_subpic_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;if( rect_slice_flag&#x2002;&#x26;&#x26;&#x2002;!single_slice_per_subpic_flag ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;num_slices_in_pic_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;tile_idx_delta_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( i = 0; i &#x3c; num_slices_in_pic_minus1; i++ ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_width_in_tiles_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( slice_width_in_tiles_minus1[ i ]&#x2002;= =&#x2002;0&#x2002;&#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ]&#x2002;= =&#x2002;0 ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;num_slices_in_tile_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;numSlicesInTileMinus1 = num_slices_in_tile_minus1[ i ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c; numSlicesInTileMinus1; j++ )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;slice_height_in_ctu_minus1[ i++ ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( tile_idx_delta_present_flag&#x2002;&#x26;&#x26;&#x2002;i &#x3c; num_slices_in_pic_minus1 )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;tile_idx_delta[ i ]</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;loop_filter_across_tiles_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;loop_filter_across_slices_enabled_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;}</entry></row><row><entry>&#x2003;...</entry></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0120" num="0123">In Table 2, num_slices_in_tile_minus1[i]+1 indicates a number of slices within a current tile, when an i-th slice includes a subset of CTU rows in a single tile. A value of num_slices_in_tile_minus1 [i] should be within a range inclusive of 0 to RowHeight[tileY]&#x2212;1. Herein, tileY is an index of a tile row including an i-th slice. When num_slices_in_tile_minus1 [i] is not present in a PPS, the value of num_slices_in_tile_minus1[i] is derived as 0.</p><p id="p-0121" num="0124">slice_height_in_ctu_minus1[i]+1 indicates a height of an i-th rectangular slice in CTU row units, when an i-th slice includes a subset of CTU rows in a single tile. A value of slice_height_in_ctu_minus1[i] should be within a range inclusive of 0 to RowHeight[tileY]-1. Herein, tileY is an index of a tile row including an i-th slice.</p><p id="p-0122" num="0125">Syntax elements shown below in Table 3 may be included in a slice header syntax.</p><p id="p-0123" num="0000"><tables id="TABLE-US-00003" num="00003"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="168pt" align="left"/><colspec colname="1" colwidth="49pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" rowsep="1">TABLE 3</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="offset" colwidth="14pt" align="left"/><colspec colname="1" colwidth="154pt" align="left"/><colspec colname="2" colwidth="49pt" align="left"/><tbody valign="top"><row><entry/><entry>slice_header( ) {</entry><entry/></row><row><entry/><entry>&#x2003;...</entry></row><row><entry/><entry>&#x2003;if( rect_slice_flag&#x2002;| |&#x2002;NumTilesInPic &#x3e; 1 )</entry></row><row><entry/><entry>&#x2003;&#x2003;slice_address</entry><entry>u(v)</entry></row><row><entry/><entry>&#x2003;if( !rect_slice_flag&#x2002;&#x26;&#x26;&#x2002;NumTilesInPic &#x3e; 1 )</entry></row><row><entry/><entry>&#x2003;&#x2003;num_tiles_in_slice_minus1</entry><entry>ue(v)</entry></row><row><entry/><entry>&#x2003;...</entry></row><row><entry/><entry>}</entry></row><row><entry/><entry namest="offset" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0124" num="0126">Referring to Table 1 to Table 3, in the current tile and slice design, a rectangular slice may include one or more tiles. Alternatively, a rectangular slice may include an integer number (or whole number) of CTU rows within a single tile.</p><p id="p-0125" num="0127">When a rectangular slice includes an integer number (or whole number) of CTU rows within a single tile (this corresponds to a case where the tile is partitioned to two or more slices), in the current signaling, the height of each slice is explicitly signaled. However, this type of signaling is not an optimal signaling method.</p><p id="p-0126" num="0128">A layout of slices within one tile may include a case where the heights of the slices within the tile are uniform with the exception for the last slice and a case where the heights of the slices within the tile are not uniform. When the heights of the slices within the tile are uniform with the exception for the last slice, since the heights of all slices excluding the last slice within the tile are the same, only the height of one slice may be simply signaled without having to explicitly signal the height of each slice. When the heights of the slices within the tile are not uniform, the height of each slice within the tile needs to be signaled.</p><p id="p-0127" num="0129">The following drawings are illustrated in order to describe the detailed example(s) of the present specification. The detailed terms of the apparatus (or device) or the detailed terms of the signal(s)/information specified in the drawings are merely exemplary. And, therefore, the technical characteristics of the present specification will not be limited only to the detailed terms used in the following drawings.</p><p id="p-0128" num="0130">The present specification provides the following methods in order to resolve the above-described problems. The items of each method may be independently applied or may be applied in combination.</p><p id="p-0129" num="0131">For example, when one tile includes two or more slices, a number of slice heights being explicitly signaled within CTU rows may be signaled. This may be referred to as syntax element num_exp_slice_in_tile. In this case, syntax elements (an array of slice_row_height_minus1) for indexes starting from 0 to num_exp_slice_in_tile&#x2212;1 may be signaled. This may be signaled as ue(v) or u(v), and a number of bits signaling such syntax elements may vary in accordance with a number of CTU rows within a tile. Herein, ue(v) represents a 0-th order Exp-Golomb-coded syntax element, and u(v) indicates that v number of bits are used, where the value of v varies in accordance with the value of other syntax elements.</p><p id="p-0130" num="0132">The height of each slice starting from a first slice to an n-th slice within the tile is given the values of slice_row_height_minus1+1 starting from 0 to num_exp_slice_in_tile&#x2212;1, respectively. Herein, n is equal to a number of slices being explicitly signaled within the tile (num_exp_slice_in_tile).</p><p id="p-0131" num="0133">Although remaining CTU rows that are larger than num_exp_slice_in_tile_minus1+1 and (explicitly) signaled last within the tile are still present, a new slice is defined within the tile. In other words, a slice(s) that is/are not explicitly signaled is/are present within the tile. The last slice may have a height that is equal to or smaller than the num_exp_slice_in_tile_minus1+1 that was last signaled.</p><p id="p-0132" num="0134">As another example, when one tile includes two or more slices, a number of slices being included in the tile may be signaled. In this case, a flag indicating whether or not the heights of each slice within the tile are uniform may be signaled. When the heights of each slice within the tile are uniform, only one slice height may be signaled from the CTU rows. The height of each slice within the tile may be derived based on the signaled slice height. And, when the heights of each slice within the tile are not uniform, the heights of each slice excluding the last slice within the tile may be explicitly signaled.</p><p id="p-0133" num="0135">In the present specification, information on the slice(s) and/or tile(s) may include information and/or syntax element(s) disclosed in Table 1 to Table 3. Image/video information may include high level syntax (HLS) disclosed in Table 1 to Table 3, and the high level syntax (HLS) may include information related to slice(s) and/or information related to tile(s). The information related to slice(s) may include information indicating one or more slices within a current picture, and the information related to tile(s) may include information indicating one or more tiles within the current picture. A tile including one or more slices and a slice including one or more tiles may be present in a picture.</p><p id="p-0134" num="0136">As an embodiment, in order to represent a partitioned structure of a picture, syntaxes shown below in Table 4 and semantics shown below in Table 5 may be used fora PPS.</p><p id="p-0135" num="0000"><tables id="TABLE-US-00004" num="00004"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="245pt" align="left"/><colspec colname="1" colwidth="35pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" rowsep="1">TABLE 4</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="245pt" align="left"/><colspec colname="2" colwidth="35pt" align="left"/><tbody valign="top"><row><entry>pic_parameter_set_rbsp( ) {</entry><entry/></row><row><entry>&#x2003;...</entry></row><row><entry>&#x2003;no_pic_partition_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( !no_pic_partition_flag ) {</entry></row><row><entry>&#x2003;&#x2003;pps_log2_ctu_size_minus5</entry><entry>u(2)</entry></row><row><entry>&#x2003;&#x2003;num_exp_tile_columns_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;num_exp_tile_rows_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i&#x2002;&#x3c;=&#x2002;num_exp_tile_columns_minus1; i++ )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;tile_column_width_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;for( i = 0; i&#x2002;&#x3c;=&#x2002;num_exp_tile_rows_minus1; i++ )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;tile_row_height_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;...</entry></row><row><entry>&#x2003;&#x2003;if( rect_slice_flag&#x2002;&#x26;&#x26;&#x2002;!single_slice_per_subpic_flag ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;num_slices_in_pic_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;tile_idx_delta_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( i = 0; i &#x3c; num_slices_in_pic_minus1; i++ ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_width_in_tiles_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( slice_width_in_tiles_minus1[ i ]&#x2002;= =&#x2002;0&#x2002;&#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ]&#x2002;= =&#x2002;0 ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;num_exp_slices_in_tile[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;numExpSlicesInTile = num_exp_slices_in_tile[ i ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c; numExpSlicesInTile; j++ )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;exp_slice_height_in_ctu_minus[ j ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;i += NumSlicesInTile[ i ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( tile_idx_delta_present_flag&#x2002;&#x26;&#x26;&#x2002;i &#x3c; num_slices_in_pic_minus1 )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;tile_idx_delta[ i ]</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;...</entry></row><row><entry>&#x2003;}</entry></row><row><entry>&#x2003;...</entry></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0136" num="0000"><tables id="TABLE-US-00005" num="00005"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="329pt" align="left"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 5</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>num_exp_slices_in_tile[ i ] plus 1 specifies the number of exp_slice_height_in_ctu_minus1[ j ] present in the</entry></row><row><entry>PPS. When not present, the value of num_exp_slices_in_tile_minus1[ i ] is inferred to be equal to 0.</entry></row><row><entry>exp_slice_height_in_ctu_minus1[ j ] plus 1 specifies the j-th explicitly signalled rectangular slice height in units</entry></row><row><entry>of CTU rows for the case where the i-th slice contains a subset of CTU rows from a single tile. The value of</entry></row><row><entry>exp_slice_height_in_ctu_minus1[ j ] shall be in the range of 0 to RowHeight[ tileY ] &#x2212; 1, inclusive, where tileY</entry></row><row><entry>is the tile row index containing the slices.</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0137" num="0137">Referring to Table 4 and Table 5, num_exp_slices_in_tile[i]+1 represents a number of exp_slice_height_in_ctu_minus1[j] being present in a PPS. When num_exp_slices_in_tile[i] is not present in the PPS, a value of num_exp_slices_in_tile_minus1[i] is derived as 0.</p><p id="p-0138" num="0138">exp_slice_height_in_ctu_minus1[j]+1 indicates a height of a j-th rectangular slice being explicitly signaled in CTU row units, when an i-th slice includes a subset of CTU rows in a single tile. A value of exp_slice_height_in_ctu_minus1[j] should be within a range inclusive of 0 to RowHeight[tileY]&#x2212;1. Herein, tileY is an index of a tile row including a slice.</p><p id="p-0139" num="0139">That is, num_exp_slices_in_tile[i] may be referred to as information (number information) on a number of slices having its height explicitly signaled within the tile of a current picture. And, exp_slice_height_in_ctu_minus1[j] may be referred to as information (height information) on a height of each slice having its height explicitly signaled.</p><p id="p-0140" num="0140">The number information and the height information may be an Exp-Golomb-coded syntax element.</p><p id="p-0141" num="0141">The number information may be parsed based on information on a width and height of a slice including the tile. When the tile includes an i-th slice, the width information of the slice including the tile may correspond to the syntax element slice_width_in_tiles_minus1[i], and the height information of the slice including the tile may correspond to the syntax element slice_height_in_tiles_minus1[i]. The i-th slice may be a rectangular slice, and slices within the tile may also be partitioned to rectangular slices.</p><p id="p-0142" num="0142">For example, the encoding apparatus may generate the number information and the height information based on the information on the slices of the current picture. The number information and the height information may be included in the image information and signaled to the decoding apparatus in a bitstream format.</p><p id="p-0143" num="0143">When the number information is parsed from a PPS, as shown in Table 4, the decoding apparatus may parse the height information from the PPS based on the number information. For example, when a value of the number information is equal to n (wherein n is an integer equal to or larger than 0), the decoding apparatus may parse the height information on n number of slices (starting from the 0-th slice to the (n-1)-th slice within the tile) from the PPS. The height information may indicate each of the height of the 0-th slice to the height of the (n-1)-th slice in coding tree unit (CTU) rows.</p><p id="p-0144" num="0144">Thereafter, the decoding apparatus may derive the heights of the remaining slices within the tile based on the height of the (n-1)-th slice. More specifically, the decoding apparatus may derive the heights of the remaining slices excluding the last slice within the tile starting from the n-th slice within the tile to be equal to the higher of the (n-1)-th slice. For this, the decoding apparatus may compare a remaining height of the tile, which is calculated by subtracting a sum of the heights of the slices starting from the 0-th slice to the (n-1)-th slice from a total height of the tile, so as to determine whether the remaining height is equal to or larger than a uniform slice height. Herein, a uniform slice may mean slices having a uniform height (the same height) within the tile. That is, the height of a uniform slice may be the same as the height of the (n-1)-th slice.</p><p id="p-0145" num="0145">When the remaining height of the tile is equal to or larger than the height of a uniform slice, the height of the n-th slice may be derived as the height of the uniform slice. And, when the remaining height of the tile is less than the height of a uniform slice, the height of the n-th slice may be derived as the remaining height. Additionally, when the remaining height of the tile is equal to or larger than the height of a uniform slice, an updated remaining height may be derived by subtracting the height of the n-th slice from the remaining height. And, when the updated remaining height is equal to or larger than the height of a uniform slice, the decoding apparatus may derive the height of an (n+1)-th slice as the height of a uniform slice. When the updated remaining height is less than the height of a uniform slice, the decoding apparatus may derive the height of the height of an (n+1)-th slice as the updated remaining height. That is, excluding the last slice within the tile, the height of the slices starting from the n-th slice to the last slice may be derived as a uniform height. The height of the last slice may be equal to or less than the height of each uniform slice (slices starting from the (n-1)-th slice to a slice immediately before the last slice).</p><p id="p-0146" num="0146">As an example, when 5 slices are included in one tile, and when the number information indicates 3, the height information for the first slice to the third slice within the tile may be parsed from the PPS, and the height of the fourth slice within the tile may be derived to have the same height as the third slice. In this case, the height of the fifth slice may be larger or less than the height of the fourth slice.</p><p id="p-0147" num="0147">The decoding apparatus may derive a number of slices within the tile by performing the above-described scanning procedure. When the value of the number information is larger than 0, the procedure of deriving information on the height of each slice within the tile and information on a number of slices within the tile may be indicated as shown below in Table 5.</p><p id="p-0148" num="0000"><tables id="TABLE-US-00006" num="00006"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="273pt" align="left"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 6</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>Let tileHeight be equal to RowHeight[ tile Y ]</entry></row><row><entry>remainingHeightInCtbsY = RowHeight[ tileY ]</entry></row><row><entry>for( j = 0; j &#x3c; num_exp_slices_in_tile &#x2212; 1; j++ ) {</entry></row><row><entry>&#x2003;SliceHeightInCtuMinus1[ i++ ] = exp_slice_height_in_ctu_minus1[ j ]</entry></row><row><entry>&#x2003;remainingHeightInCtbsY &#x2212;= SliceHeightInCtuMinus1[ j ]</entry></row><row><entry>}</entry></row><row><entry>uniformSliceHeightMinus1 = exp_slice_height_in_ctu_minus1[ num_exp_slices_in tile &#x2212; 1 ]</entry></row><row><entry>while( remainingHeightInCtbsY &#x3e;= (uniformSliceHeightMinus1 + 1) ) {</entry></row><row><entry>&#x2003;SliceHeightInCtuMinus1[ i++ ] = uniformSliceHeightMinus1</entry></row><row><entry>&#x2003;remainingHeightInCtbsY &#x2212;= (uniformSliceHeightMinus1 + 1)</entry></row><row><entry>&#x2003;j++</entry></row><row><entry>}</entry></row><row><entry>if(remainingHeightInCtbsY &#x3e; 0 ) {</entry></row><row><entry>&#x2003;SliceHeightInCtuMinus1[ i++ ] = remainingHeightInCtbsY</entry></row><row><entry>&#x2003;j++</entry></row><row><entry>}</entry></row><row><entry>NumSlicesInTile[ i ] = j</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0149" num="0148">In case of a rectangular slice, a list NumCtuInSlice[i] for i of a range inclusive of 0 to num_slices_in_pic_minus1 may indicate a number of CTUs within an i-th slice, matrix CtbAddrInSlice[i][j] for i of a range inclusive of 0 to num_slices_in_pic_minus1 and j of a range inclusive of 0 to NumCtuInSlice[i]&#x2212;1 indicates a picture raster-scan address of a j-th CTB within the i-th slice and may be derived as shown below in Table 7.</p><p id="p-0150" num="0000"><tables id="TABLE-US-00007" num="00007"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="287pt" align="left"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 7</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>if ( subpics_present_flag &#x26;&#x26; single_slice_per_subpic_flag ) {</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c;= sps_num_subpics_minus1; i++ )</entry></row><row><entry>&#x2003;&#x2003;NumCtuInSlice[ i ] = 0</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c; PicSizeInCtbsY; i ++ ) {</entry></row><row><entry>&#x2003;&#x2003;sliceIdx = CtbToSubPicIdx[ i ]</entry></row><row><entry>&#x2003;&#x2003;CtbAddrInSlice[ sliceIdx ][ NumCtuInSlice[ sliceIdx ] ] = i</entry></row><row><entry>&#x2003;&#x2003;NumCtuInSlice[ sliceIdx ]++</entry></row><row><entry>&#x2003;}</entry></row><row><entry>} else {</entry></row><row><entry>&#x2003;tileIdx = 0</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c;= num_slices_in_pic_minus1; i++ )</entry></row><row><entry>&#x2003;&#x2003;NumCtuInSlice[ i ] = 0</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c;= num_slices_in_pic_minus1; i++ ) {</entry></row><row><entry>&#x2003;&#x2003;tileX = tileIdx % NumTileColumns</entry></row><row><entry>&#x2003;&#x2003;tileY = tileIdx / NumTileColumns</entry></row><row><entry>&#x2003;&#x2003;if( i = = num_slices_in_pic_minus1 ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;slice_width_in_tiles_minus1[ i ] = NumTileColumns &#x2212; 1 &#x2212; tileX</entry></row><row><entry>&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ] = NumTileRows &#x2212; 1 &#x2212; tileY</entry></row><row><entry>&#x2003;&#x2003;&#x2003;num_slices_in_tile_minus1[ i ] = 0</entry></row><row><entry>&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;if( slice_width_in_tiles_minus1[ i ] = = 0 &#x26;&#x26; slice_height_in_tiles_minus1[ i ] = = 0 ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;ctbY = tileRowBd[ tileY ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;numSlicesInTileMinus1 = NumSlicesInTile[ i ] &#x2212; 1</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c; numSlicesInTileMinus1; j++ )</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="7pt" align="left"/><colspec colname="2" colwidth="280pt" align="left"/><tbody valign="top"><row><entry>{</entry><entry>&#x2003;&#x2003;&#x2003;&#x2003;AddCtbsToSlice( i, tileColBd[ tilex ], tileColBd[ tileX + 1 ],</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;ctbY, ctbY + SliceHeightInCtuMinus1[ i ] + 1 )</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;ctbY += SliceHeightInCtuMinus1[ i ] + 1</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;i++</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="287pt" align="left"/><tbody valign="top"><row><entry>&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;&#x2003;AddCtbsToSlice( i, tileColBd[ tileX ], tileColBd[ tileX + 1 ], ctbY, tileRowBd[ tileY + 1 ] )</entry></row><row><entry>&#x2003;&#x2003;} else</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c;= slice_height_in_tiles_minus1[ i ]; j++ )</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="7pt" align="left"/><colspec colname="2" colwidth="280pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;for( k = 0; k &#x3c;= slice_width_in_tiles_minus1[ i ]; k++ )</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;AddCtbsToSlice( i, tileColBd[ tileX + k ], tileColBd[ tileX + k + 1 ],</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;tileRowBd[ tileY + j ], tileRowBd[ tileY + j + 1 ] )</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="287pt" align="left"/><tbody valign="top"><row><entry>&#x2003;&#x2003;if( tile_idx_delta_present_ flag )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;tileIdx += tile_idx_delta[ i ]</entry></row><row><entry>&#x2003;&#x2003;else {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;tileIdx += slice_width_in_tiles_minus1[ i ] + 1</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( tileIdx % NumTileColumns = = 0 )</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="7pt" align="left"/><colspec colname="2" colwidth="280pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;tileIdx += slice_height_in_tiles_minus1[ i ] * NumTileColumns</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="287pt" align="left"/><tbody valign="top"><row><entry>&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;}</entry></row><row><entry>}</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0151" num="0149">As another embodiment, in order to represent a partitioned structure of a picture, syntaxes shown below in Table 8 and semantics shown below in Table 9 may be used for a PPS.</p><p id="p-0152" num="0000"><tables id="TABLE-US-00008" num="00008"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="offset" colwidth="245pt" align="left"/><colspec colname="1" colwidth="35pt" align="left"/><thead><row><entry/><entry namest="offset" nameend="1" rowsep="1">TABLE 8</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row><row><entry/><entry>Descriptor</entry></row><row><entry/><entry namest="offset" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="245pt" align="left"/><colspec colname="2" colwidth="35pt" align="left"/><tbody valign="top"><row><entry>pic_parameter_set_rbsp( ) {</entry><entry/></row><row><entry>...</entry></row><row><entry>&#x2003;no_pic_partition_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;if( !no_pic_partition_flag ) {</entry></row><row><entry>&#x2003;&#x2003;...</entry></row><row><entry>&#x2003;&#x2003;if( rect_slice_flag&#x2002;&#x26;&#x26;&#x2002;!single_slice_per_subpic_flag ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;num_slices_in_pic_minus1</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;tile_idx_delta_present_flag</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( i = 0; i &#x3c; num_slices_in_pic_minus1; i++ ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_width_in_tiles_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( slice_width_in_tiles_minus1[ i ]&#x2002;= =&#x2002;0&#x2002;&#x26;&#x26;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ]&#x2002;= =&#x2002;0 ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;uniform_slice_spacing_flag[ i ]</entry><entry>u(1)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;if( uniform_slice_spacing_flag[ i ] )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;slice_row_height_in_ctu_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;else {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;num_slices_in_tile_minus1[ i ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;numSlicesInTileMinus1 = num_slices_in_tile_minus1[ i ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c; numSlicesInTileMinus1; j++ )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;slice_height_in_ctu_minus1[ j++ ]</entry><entry>ue(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if( tile_idx_delta_present_flag&#x2002;&#x26;&#x26;&#x2002;i &#x3c; num_slices_in_pic_minus1 )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;tile_idx_delta[ i ]</entry><entry>se(v)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;...</entry></row><row><entry>&#x2003;}</entry></row><row><entry>...</entry></row><row><entry>}</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0153" num="0000"><tables id="TABLE-US-00009" num="00009"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="343pt" align="left"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 9</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>uniform_slice_spacing_flag[ i ] equal to 1 specifics that CTU rows are distributed uniformly across the tile and</entry></row><row><entry>signalled using the syntax elements uniform_slice_height_in_ctu_minus1[ i ]. uniform_slice_spacing_flag[ i ]</entry></row><row><entry>equal to 0 specifies that CTU rows may or may not be distributed uniformly across the tile and signalled using the</entry></row><row><entry>syntax elements num_slices _in_tile minus1[ i ] and and slice_height_in ctu_minus1[ i ].</entry></row><row><entry>slice_rows_height_in_ctu_minus1[ i ] plus 1 specifies the height of the slice excluding the last slice of the tile</entry></row><row><entry>in units of CTBs when uniform_slice_spacing_flag[ i ] is equal to 1. The value of</entry></row><row><entry>slice_rows_height_in_ctu_minus1[ i ] shall be in the range of 0 to RowHeight[ tileY ] &#x2212; 1, inclusive, where tileY</entry></row><row><entry>is the tile row index containing the slices.</entry></row><row><entry>num_slices_in_tile_minus1[ i ] plus 1 specifies the number of slices in the current tile for the ease where the i-</entry></row><row><entry>th slice contains a subset of CTU rows from a single tile and uniform_slice_spacing_flag[ i ] is equal to 0. The</entry></row><row><entry>value of num_slices_in_tile_minus1[ i ] shall be in the range of 0 to RowHeight[ tileY ] &#x2212; 1, inclusive, where</entry></row><row><entry>tileY is the tile row index containing the i-th slice. When not present, the value of num_slices_in_tile_minus1[ i ]</entry></row><row><entry>is inferred to be equal to 0.</entry></row><row><entry>slice_height_in_ctu_minus1[ i ] plus 1 specifies the height of the i-th rectangular slice in units of CTU rows for</entry></row><row><entry>the case where the i-th slice contains a subset of CTU rows from a single tile. The value of</entry></row><row><entry>slice_height in_ctu_minus1[ i ] shall be in the range of 0 to RowHeight[ tileY ] &#x2212; 1, inclusive, where tileY is the</entry></row><row><entry>tile row index containing the i-th slice.</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0154" num="0150">Referring to Table 8 and Table 9, if a value of uniform_slice_spacing_flag[i] is equal to 1, this indicates that the CTU rows are uniformly distributed (or dispersed) throughout the entire tile and are signaled by using syntax elements uniform_slice_height_in_ctu_minus1[i]. If the value of uniform_slice_spacing_flag[i] is equal to 0, this indicates that the CTU rows may or may not be uniformly distributed (or dispersed) throughout the entire tile and are signaled by using syntax elements num_slices_in_tile_minus1[i] and slice_height_in_ctu_minus1[i].</p><p id="p-0155" num="0151">When the value of uniform_slice_spacing_flag[i] is equal to 1, slice_rows_height_in_ctu_minus1[i]+1 indicates the height of the slices excluding the last slice of the tile in CTB units. A value of slice_height_in_ctu_minus1[i] should be within a range inclusive of 0 to RowHeight[tileY]&#x2212;1. Herein, tileY is an index of a tile row including the slices.</p><p id="p-0156" num="0152">num_slices_in_tile_minus1[i]+1 indicates a number of slices within the current tile, when an i-th slice includes a subset of CTU rows in a single tile, and when the value of uniform_slice_spacing_flag[i] is equal to 0. A value of num_slices_in_tile_minus1[i] should be within a range inclusive of 0 to RowHeight[tileY]&#x2212;1. Herein, tileY is an index of a tile row including an i-th slice. When num_slices_in_tile_minus1[i] is not present, the value of num_slices_in_tile_minus1[i] is derived as 0.</p><p id="p-0157" num="0153">slice_height_in_ctu_minus1[i]+1 indicates a height of an i-th rectangular slice in CTU row units, when an i-th slice includes a subset of CTU rows in a single tile. A value of slice_height_in_ctu_minus1[i] should be within a range inclusive of 0 to RowHeight[tileY]&#x2212;1. Herein, tileY is an index of a tile row including an i-th slice.</p><p id="p-0158" num="0154">For example, the encoding apparatus may generate at least one of uniform_slice_spacing_flag, slice_rows_height_in_ctu_minus1, num_slices_in_tile_minus1, and slice_height_in_ctu_minus1 based on information on slices of the current picture.</p><p id="p-0159" num="0155">When uniform_slice_spacing_flag is parsed from a PPS, as shown in Table 8, the decoding apparatus may parse slice_rows_height_in_ctu_minus1 or num_slices_in_tile_minus1 from the PPS based on a value of uniform_slice_spacing_flag. For example, if the value of uniform_slice_spacing_flag is equal to 1, the decoding apparatus may parse slice_rows_height_in_ctu_minus1 from the PPS and may then derive the parsed result as the height of the remaining slices excluding the last slice within the tile based on the value of slice_rows_height_in_ctu_minus1. If the value of uniform_slice_spacing_flag is equal to 0, the decoding apparatus may parse num_slices_in_tile_minus1 and slice_height_in_ctu_minus1 from the PPS and may derive the slices within the tile based on the parsed result.</p><p id="p-0160" num="0156">For example, variables NumSlicesInTileMinus1[i] and SliceHeightInCtuMinus1[i+k] that are related to the number information and height information of slices within a tile may be derived as shown below. Herein, k may be within a range inclusive of 0 to NumSlicesInTileMinus1[i].</p><p id="p-0161" num="0000"><tables id="TABLE-US-00010" num="00010"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="left"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 10</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>if (uniform_slice_spacing_flag[ i ]) {</entry></row><row><entry>&#x2003;remainingHeightInCtbsY = RowHeight[ tileY ]</entry></row><row><entry>&#x2003;uniformSliceHeightMinus1 = slice_row_height_in_ctu_minus1[ i ]</entry></row><row><entry>&#x2003;NumSlicesInTileMinus1[ i ] = 0</entry></row><row><entry>&#x2003;while( remainingHeightInCtbsY &#x3e;= (uniformSliceHeightMinus1 + 1) ) {</entry></row><row><entry>&#x2003;&#x2003;NumSlicesInTileMinus1[ i ]++</entry></row><row><entry>&#x2003;&#x2003;SliceHeightInCtuMinus1[ i++ ] = uniformSliceHeightMinus1</entry></row><row><entry>&#x2003;&#x2003;remainingHeightInCtbsY &#x2212;= (uniformSliceHeightMinus1 + 1)</entry></row><row><entry>&#x2003;}</entry></row><row><entry>&#x2003;if(remainingHeightInCtbsY &#x3e; 0 ) {</entry></row><row><entry>&#x2003;&#x2003;NumSlicesInTileMinus1[ i ]++</entry></row><row><entry>&#x2003;&#x2003;SliceHeightInCtuMinus1[ i++ ] = remainingHeightInCtbsY</entry></row><row><entry>&#x2003;}</entry></row><row><entry>} else {</entry></row><row><entry>&#x2003;remainingHeightInCtbsY = RowHeight[ tileY ]</entry></row><row><entry>&#x2003;NumSlicesInTileMinus1[ i ] = 0</entry></row><row><entry>&#x2003;for (j = 0; j &#x3c; numSlicesInTileMinus1; j++ ) {</entry></row><row><entry>&#x2003;&#x2003;NumSlicesInTileMinus1[ i ]++</entry></row><row><entry>&#x2003;&#x2003;SliceHeightInCtuMinus1[ i++ ] = slice_height_in_ctu_minus1[ j ]</entry></row><row><entry>&#x2003;&#x2003;remainingHeightInCtbsY &#x2212;= (slice_height_in_ctu_minus1[ j ] + 1)</entry></row><row><entry>&#x2003;}</entry></row><row><entry>&#x2003;if(remainingHeightInCtbsY &#x3e; 0 ) {</entry></row><row><entry>&#x2003;&#x2003;NumSlicesInTileMinus1[ i ]++</entry></row><row><entry>&#x2003;&#x2003;SliceHeightInCtuMinus1[ i++ ] = remainingHeightInCtbsY</entry></row><row><entry>&#x2003;}</entry></row><row><entry>}</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0162" num="0157">In case of a rectangular slice, a list NumCtuInSlice[i] for i of a range inclusive of 0 to num_slices_in_pic_minus1 may indicate a number of CTUs within an i-th slice, matrix CtbAddrInSlice[i][j] for i of a range inclusive of 0 to num_slices_in_pic_minus1 and j of a range inclusive of 0 to NumCtuInSlice[i]&#x2212;1 indicates a picture raster-scan address of a j-th CTB within the i-th slice and may be derived as shown below in Table 11.</p><p id="p-0163" num="0000"><tables id="TABLE-US-00011" num="00011"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="287pt" align="left"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 11</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>if( subpics_present_flag &#x26;&#x26; single_slice_per_subpic_flag ) {</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c;= spa_num_subpics_minus1; i++ )</entry></row><row><entry>&#x2003;&#x2003;NumCtuInSlice[ i ] = 0</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c; PicSizeInCtbsY; i ++ ) {</entry></row><row><entry>&#x2003;&#x2003;sliceIdx = CtbToSubPicIdx[ i ]</entry></row><row><entry>&#x2003;&#x2003;CtbAddrInSlice[ sliceIdx ][ NumCtuInSlice[ sliceIdx ] ] = i</entry></row><row><entry>&#x2003;&#x2003;NumCtuInSlice[ sliceIdx ]++</entry></row><row><entry>&#x2003;}</entry></row><row><entry>} else {</entry></row><row><entry>&#x2003;tileIdx = 0</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c;= num_slices_in_pic_minus1; i++ )</entry></row><row><entry>&#x2003;&#x2003;NumCtuInSlice[ i ] = 0</entry></row><row><entry>&#x2003;for( i = 0; i &#x3c;= num_slices_in_pic_minus1; i++ ) {</entry></row><row><entry>&#x2003;&#x2003;tileX = tileIdx % NumTileColumns</entry></row><row><entry>&#x2003;&#x2003;tileY = tileIdx / NumTileColumns</entry></row><row><entry>&#x2003;&#x2003;if( i = = num_slices_in_pic_minus1 ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;slice_width_in_tiles_ minus1[ i ] = NumTileColumns &#x2212; 1 &#x2212; tileX</entry></row><row><entry>&#x2003;&#x2003;&#x2003;slice_height_in_tiles_minus1[ i ] =NumTileRows &#x2212; 1 &#x2212; tileY</entry></row><row><entry>&#x2003;&#x2003;&#x2003;num_slices_in_tile_minus1[ i ] = 0</entry></row><row><entry>&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;if( slice_width_in_tiles_minus1[ i ] = = 0 &#x26;&#x26; slice_height in_tiles_minus1[ i ] = = 0 ) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;ctbY = tileRowBd[ tileY ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;numSlicesInTileMinus1 = NumSlicesInTileMinus1[ i ]</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c; numSlicesInTileMinus1; j++ )</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="7pt" align="left"/><colspec colname="2" colwidth="280pt" align="left"/><tbody valign="top"><row><entry>{</entry><entry>&#x2003;&#x2003;&#x2003;AddCtbsToSlice( i, tileColBd[ tileX ], tileColBd[ tileX + 1 ],</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;ctbY, ctbY + SliceHeightInCtuMinus1[ i ] + 1 )</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;ctbY += SliceHeightInCtuMinus1[ i ] + 1</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;i++</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="287pt" align="left"/><tbody valign="top"><row><entry>&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;&#x2003;AddCtbsToSlice( i, tileColBd[ tileX ], tileColBd[ tileX + 1], ctbY, tileRowBd[ tileY + 1 ] )</entry></row><row><entry>&#x2003;&#x2003;} else</entry></row><row><entry>&#x2003;&#x2003;&#x2003;for( j = 0; j &#x3c;= slice_height_in_tiles_minus1[ i ]; j++ )</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="7pt" align="left"/><colspec colname="2" colwidth="280pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2003;&#x2003;&#x2003;for( k = 0; k &#x3c;= slice_width_in_tiles_minus1[ i ]; k++ )</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;AddCtbsToSlice( i, tileColBd[ tileX + k ], tileColBd[ tileX + k + 1 ],</entry></row><row><entry/><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;tileRowBd[ tileY + j ], tileRowBd[ tileY + j +1 ] )</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="287pt" align="left"/><tbody valign="top"><row><entry>&#x2003;&#x2003;if( tile_idx_delta_present_flag )</entry></row><row><entry>&#x2003;&#x2003;&#x2003;tileIdx += tile_idx_delta[ i ]</entry></row><row><entry>&#x2003;&#x2003;else {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;tileIdx += slice_width_in_tiles_minus1[ i ] + 1</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if( tileIdx % NumTileColumns = = 0 )</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="7pt" align="left"/><colspec colname="2" colwidth="280pt" align="left"/><tbody valign="top"><row><entry/><entry>&#x2003;&#x2003;&#x2003;tileIdx += slice_height_in_tiles_minus1[ i ] * NumTileColumns</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="287pt" align="left"/><tbody valign="top"><row><entry>&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;}</entry></row><row><entry>}</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0164" num="0158"><figref idref="DRAWINGS">FIG. <b>7</b></figref> and <figref idref="DRAWINGS">FIG. <b>8</b></figref> respectively show general examples of a video/image encoding method and a related component according to an embodiment of the present disclosure.</p><p id="p-0165" num="0159">The video/image encoding method disclosed in <figref idref="DRAWINGS">FIG. <b>7</b></figref> may be performed by a(n) (video/image) encoding apparatus <b>200</b> that is disclosed in <figref idref="DRAWINGS">FIG. <b>2</b></figref> and <figref idref="DRAWINGS">FIG. <b>8</b></figref>. More specifically, for example, S<b>700</b> of <figref idref="DRAWINGS">FIG. <b>7</b></figref> may be performed by the image partitioner <b>210</b> of the encoding apparatus <b>200</b>, and S<b>710</b> may be performed by the predictor <b>220</b> of the encoding apparatus <b>200</b>. S<b>720</b> may be performed by the residual processor <b>230</b> of the encoding apparatus <b>200</b>, and S<b>730</b> and S<b>740</b> may be performed by the entropy encoder <b>240</b> of the encoding apparatus <b>200</b>. The video/image encoding method disclosed in <figref idref="DRAWINGS">FIG. <b>7</b></figref> may include the embodiments that are described above in the present specification.</p><p id="p-0166" num="0160">More specifically, referring to <figref idref="DRAWINGS">FIG. <b>7</b></figref> and <figref idref="DRAWINGS">FIG. <b>8</b></figref>, the image partitioner <b>210</b> of the encoding apparatus may derive slices within a tile of a current picture (S<b>700</b>). For example, the image partitioner <b>210</b> may partition an input image (or picture, frame) to one or more CUs. The input image may include one or more pictures. A picture may be partitioned to one or more tiles, bricks, slices, and/or tile groups. A slice may include one or more bricks, tiles, and/or tile groups. A brick may include one or more CTU rows. A tile group may include one or more tiles. A tile may include one or more CTUs. The CTU may be partitioned to one or more CUs. When a specific slice within the current picture is a rectangular slice, the image partitioner <b>210</b> may partition the rectangular slice to a plurality of tiles, and, among the plurality of tiles, the image partitioner <b>210</b> may partition at least one tile and then derive a plurality of rectangular slices.</p><p id="p-0167" num="0161">The predictor <b>220</b> of the encoding apparatus may perform at least one of intra prediction or inter prediction on a current block based on the slices that are derived in the image partitioner <b>210</b> and may then generate prediction samples (prediction block) and prediction related information of the current block (S<b>710</b>). The predictor <b>220</b> may determine whether intra prediction is being applied, or whether inter prediction is being applied in the current block or CU units. The predictor <b>220</b> may deliver diverse information related to prediction (prediction related information) to the entropy encoder <b>240</b>. Herein, the prediction related information may include information related to an inter prediction mode and information related to an intra prediction mode. When the prediction mode of the current block is the inter prediction mode, the prediction samples may be generated in the inter predictor <b>221</b> of the predictor <b>220</b>. And, when the prediction mode of the current block is the intra prediction mode, the prediction samples may be generated in the intra predictor <b>222</b> of the predictor <b>220</b>.</p><p id="p-0168" num="0162">The residual processor <b>230</b> of the encoding apparatus may generate residual samples and residual information based on prediction samples generated from the predictor <b>220</b> and an original picture (original block, original samples) (S<b>720</b>). Herein, the residual information is information related to the residual samples, and the residual information may include information related to (quantized) transform coefficients for the residual samples.</p><p id="p-0169" num="0163">The adder (or reconstructor) of the encoding apparatus may generate reconstructed samples (reconstructed picture, reconstructed block, reconstructed sample array) by adding the residual samples that are generated in the residual processor <b>230</b> and the prediction samples that are generated in the inter predictor <b>221</b> or intra predictor <b>222</b>.</p><p id="p-0170" num="0164">The entropy encoder <b>240</b> of the encoding apparatus may generate information related to partitioning based on a partitioning structure, which is derived in the image partitioner <b>210</b>. The partitioning related information may include information (number information) on a number of slices each having its height explicitly signaled within a tile and information (height information) on a height of the slices each having its height explicitly signaled. For example, the entropy encoder <b>240</b> may generate number information related to a number of slices each having its height explicitly signaled (provided) within the tile and height information related to a height of the slices each having its height explicitly signaled (provided) based on the slices that are derived in the image partitioner <b>210</b> (S<b>730</b>). Herein, the number information may include the above-described syntax element(s) num_exp_slices_in_tile and/or num_slices_in_tile_minus1. The height information may include the above-described syntax element(s) exp_slice_height_in_ctu_minus1, slice_rows_height_in_ctu_minus1, and/or slice_height_in_ctu_minus1.</p><p id="p-0171" num="0165">The entropy encoder <b>240</b> may encode image information including partitioning related information, which includes the number information and the height information, prediction related information, which is generated in the predictor <b>220</b>, and/or residual information, which is generated in the residual processor <b>230</b> (S<b>740</b>). The information that is encoded in the entropy encoder <b>240</b> may be outputted in a bitstream format. The bitstream may be transmitted to the decoding apparatus through a network or storage medium.</p><p id="p-0172" num="0166">For example, the entropy encoder <b>240</b> may include image information, which include syntax element num_exp_slices_in_tile as the number information and syntax element exp_slice_height_in_ctu_minus1 as the height information based on the above-described Table 4 and Table 5. The height information may indicate the height of slices each having its height explicitly signaled within the tile in CTU row units, and, for this, the height information may include syntax elements for the slices each having its height explicitly signaled. The number of syntax elements being included in image information may be the same as the number information value.</p><p id="p-0173" num="0167">As another example, the entropy encoder <b>240</b> may encode image information including syntax elements uniform_slice_spacing_flag, num_slices_in_tile_minus1, slice_rows_height_in_ctu_minus1, and/or slice_height_in_ctu_minus1 based on the above-described Table 8 and Table 9. The syntax elements num_slices_in_tile_minus1, slice_rows_height_in_ctu_minus1, and slice_height_in_ctu_minus1 may be included, or may not be included in the image information based on the uniform_slice_spacing_flag value.</p><p id="p-0174" num="0168">The entropy encoder <b>240</b> may signal the number information and the height information through a picture parameter set (PPS) within the image information. In this case, the entropy encoder <b>240</b> may include the number information and/or the height information by using an Exp-Golomb method.</p><p id="p-0175" num="0169"><figref idref="DRAWINGS">FIG. <b>9</b></figref> and <figref idref="DRAWINGS">FIG. <b>10</b></figref> respectively show general examples of a video/image decoding method and a related component according to an embodiment of the present disclosure.</p><p id="p-0176" num="0170">The video/image decoding method disclosed in <figref idref="DRAWINGS">FIG. <b>9</b></figref> may be performed by a (video/image) decoding apparatus <b>300</b> that is disclosed in <figref idref="DRAWINGS">FIG. <b>3</b></figref> and <figref idref="DRAWINGS">FIG. <b>10</b></figref>. More specifically, for example, S<b>900</b> to S<b>920</b> of <figref idref="DRAWINGS">FIG. <b>9</b></figref> may be performed by the entropy decoder <b>310</b> of the decoding apparatus. And, S<b>930</b> of <figref idref="DRAWINGS">FIG. <b>9</b></figref> may be performed by the residual processor <b>320</b>, the predictor <b>330</b>, and the adder <b>340</b> of the decoding apparatus. The video/image decoding method disclosed in <figref idref="DRAWINGS">FIG. <b>9</b></figref> may include the embodiments that are described above in the present specification.</p><p id="p-0177" num="0171">Referring to <figref idref="DRAWINGS">FIG. <b>9</b></figref> and <figref idref="DRAWINGS">FIG. <b>10</b></figref>, the entropy decoder <b>310</b> of the decoding apparatus may obtain partitioning related information, residual information, prediction related information (inter/intra prediction differentiation information, intra prediction mode information, inter prediction mode information, and so on), in-loop filtering related information, and so on, from a bitstream. Herein, the partitioning related information may include information (number information) on a number of slices each having its height explicitly signaled, among slices within a tile of a current picture, information (height information) on the height of slices each having its height explicitly signaled, and so on.</p><p id="p-0178" num="0172">For example, the entropy decoder <b>310</b> may parse information (number information) related to a number of slices each having its height explicitly signaled, among slices within a tile of a current picture, from a bitstream (S<b>900</b>), and may parse information (height information) related to the height of slices each having its height explicitly signaled from the bitstream based on the number information (S<b>910</b>). More specifically, the entropy decoder <b>310</b> may parse the number information and the height information from a picture parameter set (PPS) of the bitstream based on the above-described Table 4. Herein, the number information may be parsed based on information on a width and height of a slice including the tile. At this point, the slice including the tile and/or slices within the tile may be a rectangular slice(s). The number information and the height information may be Exp-Golomb-coded syntax elements. The height information may include syntax elements for each slice having its height explicitly signaled. The number of syntax elements may be the same as the number information value.</p><p id="p-0179" num="0173">For example, the entropy decoder <b>310</b> may parse syntax elements slice_width_in_tiles_minus1 and slice_height_in_tiles_minus1 from the picture parameter set (PPS) based on Table 4, and the entropy decoder <b>310</b> may parse syntax element num_exp_slices_in_tile from the picture parameter set (PPS) based on the values of the syntax elements slice_width_in_tiles_minus1 and slice_height_in_tiles_minus1. And, the entropy decoder <b>310</b> may parse a number of exp_slice_height_in_ctu_minus1 that is equivalent to the value of the syntax element num_exp_slices_in_tile from the picture parameter set (PPS).</p><p id="p-0180" num="0174">When the value of the number information is equal to n, the entropy decoder <b>310</b> may derive heights of a 0-th slice to an (n-1)-th slice within the tile based on the height information. And, the entropy decoder <b>310</b> may derive a height of an n-th slice within the tile based on the height of the (n-1)-th slice. That is, the height of the n-th slice may be derived to be the same as the height of the (n-1)-th slice. Herein, the n-th slice may not be the last slice within the tile. In other words, the entropy decoder <b>310</b> may derive the heights of the remaining slices (slices that are not explicitly signaled) excluding the last slice within the tile to have the same height as the (n-1)-th slice. Therefore, the heights of the slices starting from the n-th slice to the last slice within the tile may be uniform with the exception for the last slice within the tile. The entropy decoder <b>310</b> may derive the height of the last slice within the tile based on a remaining height after subtracting the heights of other slices within the tile from the height of the tile. When the heights of all slices within the tile are derived, the entropy decoder <b>310</b> may derive a number of slices within the tile (S<b>920</b>). Herein, the number of slices within the tile may correspond to a number of slices stating from the 0-th slice to the last slice within the tile.</p><p id="p-0181" num="0175">The decoding apparatus <b>300</b> may decode the current picture based on the slices of the current picture that are derived by performing the above-described procedures (S<b>930</b>). More specifically, the residual processor <b>320</b> of the decoding apparatus may generate residual samples based on residual information that is obtained from the entropy decoder <b>310</b>. The predictor <b>330</b> of the decoding apparatus may perform inter prediction and/or intra prediction based on prediction related information that is obtained from the entropy decoder <b>310</b> so as to generate prediction samples. The adder <b>340</b> of the decoding apparatus may generate reconstructed samples based on the prediction samples that are generated in the predictor <b>330</b> and the residual samples that are generated in the residual processor <b>320</b>. And, the adder <b>340</b> of the decoding apparatus may generate a reconstructed picture (reconstructed block) based on the reconstructed samples.</p><p id="p-0182" num="0176">Thereafter, an in-loop filtering procedure, such as deblocking filtering, SAO, and/or ALF procedures, may be applied to the reconstructed picture as needed, in order to enhance subjective/objective picture quality.</p><p id="p-0183" num="0177">Meanwhile, as another example, the entropy decoder <b>310</b> may parse syntax elements slice_width_in_tiles_minus1 and slice_height_in_tiles_minus1 from a picture parameter set (PPS) of a bitstream based on Table 8, and the entropy decoder <b>310</b> may parse syntax element uniform_slice_spacing_flag from the picture parameter set (PPS) based on values of the syntax elements slice_width_in_tiles_minus1 and slice_height_in_tiles_minus1. In this case, the entropy decoder <b>310</b> may parse syntax element slice_rows_height_in_ctu_minus1 or parse syntax element num_slices_in_tile_minus1 from the picture parameter set (PPS) based on the value of syntax element uniform_slice_spacing_flag. The syntax element slice_rows_height_in_ctu_minus1 may be parsed, when the value of the syntax element uniform_slice_spacing_flag is equal to 1, and the syntax element num_slices_in_tile_minus1 may be parsed, when the value of the syntax element uniform_slice_spacing_flag is equal to 0.</p><p id="p-0184" num="0178">When the syntax element slice_rows_height_in_ctu_minus1 is parsed, the entropy decoder <b>310</b> may derive the heights of the remaining slices excluding the last slice within the tile as the value of slice_rows_height_in_ctu_minus1.</p><p id="p-0185" num="0179">When the syntax element num_slices_in_tile_minus1 is parsed, the entropy decoder <b>310</b> may parse a number of syntax element slice_height_in_ctu_minus1 corresponding to the value of the syntax element num_slices_in_tile_minus1, and the values may be each be derived as the heights of each slice within the tile, respectively.</p><p id="p-0186" num="0180">Although methods have been described on the basis of a flowchart in which steps or blocks are listed in sequence in the above-described embodiments, the steps of the present document are not limited to a certain order, and a certain step may be performed in a different step or in a different order or concurrently with respect to that described above. Further, it will be understood by those ordinary skilled in the art that the steps of the flowcharts are not exclusive, and another step may be included therein or one or more steps in the flowchart may be deleted without exerting an influence on the scope of the present document.</p><p id="p-0187" num="0181">The aforementioned method according to the present document may be in the form of software, and the encoding apparatus and/or decoding apparatus according to the present document may be included in a device for performing image processing, for example, a TV, a computer, a smart phone, a set-top box, a display device, or the like.</p><p id="p-0188" num="0182">When the embodiments of the present document are implemented by software, the aforementioned method may be implemented by a module (process or function) which performs the aforementioned function. The module may be stored in a memory and executed by a processor. The memory may be installed inside or outside the processor and may be connected to the processor via various well-known means. The processor may include Application-Specific Integrated Circuit (ASIC), other chipsets, a logical circuit, and/or a data processing device. The memory may include a Read-Only Memory (ROM), a Random Access Memory (RAM), a flash memory, a memory card, a storage medium, and/or other storage device. In other words, the embodiments according to the present document may be implemented and executed on a processor, a micro-processor, a controller, or a chip. For example, functional units illustrated in the respective figures may be implemented and executed on a computer, a processor, a microprocessor, a controller, or a chip. In this case, information on implementation (for example, information on instructions) or algorithms may be stored in a digital storage medium.</p><p id="p-0189" num="0183">In addition, the decoding apparatus and the encoding apparatus to which the embodiment(s) of the present document is applied may be included in a multimedia broadcasting transceiver, a mobile communication terminal, a home cinema video device, a digital cinema video device, a surveillance camera, a video chat device, and a real time communication device such as video communication, a mobile streaming device, a storage medium, a camcorder, a video on demand (VoD) service provider, an Over The Top (OTT) video device, an internet streaming service provider, a 3D video device, a Virtual Reality (VR) device, an Augment Reality (AR) device, an image telephone video device, a vehicle terminal (for example, a vehicle (including an autonomous vehicle) terminal, an airplane terminal, or a ship terminal), and a medical video device; and may be used to process an image signal or data. For example, the OTT video device may include a game console, a Blu-ray player, an Internet-connected TV, a home theater system, a smartphone, a tablet PC, and a Digital Video Recorder (DVR).</p><p id="p-0190" num="0184">In addition, the processing method to which the embodiment(s) of the present document is applied may be produced in the form of a program executed by a computer and may be stored in a computer-readable recording medium. Multimedia data having a data structure according to the embodiment(s) of the present document may also be stored in the computer-readable recording medium. The computer readable recording medium includes all kinds of storage devices and distributed storage devices in which computer readable data is stored. The computer-readable recording medium may include, for example, a Blu-ray disc (BD), a universal serial bus (USB), a ROM, a PROM, an EPROM, an EEPROM, a RAM, a CD-ROM, a magnetic tape, a floppy disk, and an optical data storage device. The computer-readable recording medium also includes media embodied in the form of a carrier wave (for example, transmission over the Internet). In addition, a bitstream generated by the encoding method may be stored in the computer-readable recording medium or transmitted through a wired or wireless communication network.</p><p id="p-0191" num="0185">In addition, the embodiment(s) of the present document may be embodied as a computer program product based on a program code, and the program code may be executed on a computer according to the embodiment(s) of the present document. The program code may be stored on a computer-readable carrier.</p><p id="p-0192" num="0186"><figref idref="DRAWINGS">FIG. <b>11</b></figref> represents an example of a contents streaming system to which the embodiment of the present document may be applied.</p><p id="p-0193" num="0187">Referring to <figref idref="DRAWINGS">FIG. <b>11</b></figref>, the content streaming system to which the embodiments of the present document is applied may generally include an encoding server, a streaming server, a web server, a media storage, a user device, and a multimedia input device.</p><p id="p-0194" num="0188">The encoding server functions to compress to digital data the contents input from the multimedia input devices, such as the smart phone, the camera, the camcorder and the like, to generate a bitstream, and to transmit it to the streaming server. As another example, in a case in which the multimedia input device, such as, the smart phone, the camera, the camcorder or the like, directly generates a bitstream, the encoding server may be omitted.</p><p id="p-0195" num="0189">The bitstream may be generated by an encoding method or a bitstream generation method to which the embodiments of the present document is applied. And the streaming server may temporarily store the bitstream in a process of transmitting or receiving the bitstream.</p><p id="p-0196" num="0190">The streaming server transmits multimedia data to the user equipment on the basis of a user's request through the web server, which functions as an instrument that informs a user of what service there is. When the user requests a service which the user wants, the web server transfers the request to the streaming server, and the streaming server transmits multimedia data to the user. In this regard, the contents streaming system may include a separate control server, and in this case, the control server functions to control commands/responses between respective equipment in the content streaming system.</p><p id="p-0197" num="0191">The streaming server may receive contents from the media storage and/or the encoding server. For example, in a case the contents are received from the encoding server, the contents may be received in real time. In this case, the streaming server may store the bitstream for a predetermined period of time to provide the streaming service smoothly.</p><p id="p-0198" num="0192">For example, the user equipment may include a mobile phone, a smart phone, a laptop computer, a digital broadcasting terminal, a personal digital assistant (PDA), a portable multimedia player (PMP), a navigation, a slate PC, a tablet PC, an ultrabook, a wearable device (e.g., a watch-type terminal (smart watch), a glass-type terminal (smart glass), a head mounted display (HMD)), a digital TV, a desktop computer, a digital signage or the like.</p><p id="p-0199" num="0193">Each of servers in the contents streaming system may be operated as a distributed server, and in this case, data received by each server may be processed in distributed manner.</p><?detailed-description description="Detailed Description" end="tail"?></description><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A video decoding method performed by a video decoding apparatus, the method comprising:<claim-text>parsing number information related to a number of slices each having its height explicitly signaled within a tile of a current picture from a bitstream;</claim-text><claim-text>parsing height information related to heights of slices each having its height explicitly signaled from the bitstream based on the number information;</claim-text><claim-text>deriving a number of slices within the tile based on the number information and the height information; and</claim-text><claim-text>decoding the current picture based on the slices within the tile,</claim-text><claim-text>wherein, based on the number of the slices each having its height explicitly signaled being equal to n, heights of a 0-th slice to an (n-1)-th slice within the tile are derived based on the height information,</claim-text><claim-text>wherein a height of an n-th slice to a height of a directly previous slice of a last slice within the tile are derived based on the height of the (n-1)-th slice,</claim-text><claim-text>wherein a height of the last slice within the tile is derived based on a remaining height after subtracting the heights of other slices within the tile from a height of the tile, and</claim-text><claim-text>wherein the number information and the height information are included in a picture parameter set.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The video decoding method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the number of slices within the tile is equal to a number of slices stating from the 0-th slice to the last slice.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The video decoding method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the height of the n-th slice is derived to be the same as the height of the (n-1)-th slice.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The video decoding method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein heights of slices starting from the n-th slice to the directly previous slice within the tile are uniform.</claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The video decoding method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the height of the last slice is smaller or equal to the height of the (n-1)-th slice.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The video decoding method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>comparing a remaining height of the tile that is calculated by subtracting a sum of the heights of the slices starting from the 0-th slice to the (n-1)-th slice from a total height of the tile, so as to determine whether the remaining height is equal to or larger than a height of a uniform slice,</claim-text><claim-text>wherein the height of a uniform slice is the same as the height of the (n-1)-th slice,</claim-text><claim-text>wherein, based on the remaining height of the tile that is calculated by subtracting a sum of the heights of the slices starting from the 0-th slice to the (n-1)-th slice from a total height of the tile being equal to or larger than the height of the uniform slice, the n-th slice having the height of a uniform slice is derived, and</claim-text><claim-text>wherein, based on the remaining height of the tile that is calculated by subtracting a sum of the heights of the slices starting from the 0-th slice to the (n-1)-th slice from a total height of the tile being smaller than the height of the uniform slice, the n-th slice having the remaining height is derived.</claim-text></claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The video decoding method of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein, based on the remaining height being equal to or larger than the height of the uniform slice, an updated remaining height is derived, wherein the updated remaining height is updated by subtracting the height of the n-th slice from the remaining height of the tile that is calculated by subtracting the sum of the heights of the slices starting from the 0-th slice to the (n-1)-th slice from the total height of the tile,<claim-text>wherein, based on the updated remaining height being equal to or larger than the height of the uniform slice, an (n+1)-th slice having the height of the uniform slice is derived, and</claim-text><claim-text>wherein, based on the based on the updated remaining height being smaller than the height of the uniform slice, an (n+1)-th slice having the updated remaining height is derived.</claim-text></claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The video decoding method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the number information and the height information include an Exp-Golomb-coded syntax element.</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. (canceled)</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The video decoding method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the number information includes a syntax element num_exp_slices_in_tile, and<claim-text>wherein the height information includes a syntax element exp_slice_height_in_ctu_minus1.</claim-text></claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The video decoding method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein slices within the tile are rectangular slices.</claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The video decoding method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the number information is parsed based on information related to a width and height of a slice including the tile.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. (canceled)</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. A video encoding method performed by a video encoding apparatus, the method comprising:<claim-text>deriving slices within a tile of a current picture;</claim-text><claim-text>generating prediction samples by performing at least one of intra prediction or inter prediction based on at least one of the derived slices;</claim-text><claim-text>generating residual information based on the prediction samples;</claim-text><claim-text>generating number information related to a number of slices each having its height explicitly signaled within the tile and height information related to heights of the slices each having its height explicitly signaled based on the derived slices; and</claim-text><claim-text>encoding image information including the residual information, the number information, and the height information,</claim-text><claim-text>wherein, based on the number of the slices each having its height explicitly signaled being equal to n, the height information indicates heights of a 0-th slice to an (n-1)-th slice within the tile,</claim-text><claim-text>wherein a height of an n-th slice to a height of a directly previous slice of a last slice within the tile is represented based on the height of the (n-1)-th slice,</claim-text><claim-text>wherein a height of the last slice within the tile is represented based on a remaining height after subtracting the heights of other slices within the tile from a height of the tile, and</claim-text><claim-text>wherein the number information and the height information are included in a picture parameter set.</claim-text></claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. A non-transitory computer readable digital storage medium storing a bitstream generated by p video encoding method, wherein the video encoding method comprises:<claim-text>deriving slices within a tile of a current picture;</claim-text><claim-text>generating prediction samples by performing at least one of intra prediction or inter prediction based on at least one of the derived slices;</claim-text><claim-text>generating residual information based on the prediction samples;</claim-text><claim-text>generating number information related to a number of slices each having its height explicitly signaled within the tile and height information related to heights of the slices each having its height explicitly signaled based on the derived slices; and</claim-text><claim-text>encoding image information to generate the bitstream, wherein the image information includes the residual information, the number information, and the height information,</claim-text><claim-text>wherein, based on the number of the slices each having its height explicitly signaled being equal to n, the height information indicates heights of a 0-th slice to an (n-1)-th slice within the tile,</claim-text><claim-text>wherein a height of an n-th slice to a height of a directly previous slice of a last slice within the tile is represented based on the height of the (n-1)-th slice,</claim-text><claim-text>wherein a height of the last slice within the tile is represented based on a remaining height after subtracting the heights of other slices within the tile from a height of the tile, and</claim-text><claim-text>wherein the number information and the height information are included in a picture parameter set.</claim-text></claim-text></claim></claims></us-patent-application>