<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230003906A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230003906</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17379958</doc-number><date>20210719</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><priority-claims><priority-claim sequence="01" kind="national"><country>CN</country><doc-number>202110738240.1</doc-number><date>20210630</date></priority-claim></priority-claims><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>01</class><subclass>S</subclass><main-group>19</main-group><subgroup>42</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>01</class><subclass>S</subclass><main-group>19</main-group><subgroup>42</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc></classifications-cpc><invention-title id="d2e61">APPARATUS AND METHOD OF CALCULATING POSITION-VELOCITY-TIME RESULTS OF RECEIVER</invention-title><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Beken Corporation</orgname><address><city>Shanghai</city><country>CN</country></address></addressbook><residence><country>CN</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>GUO</last-name><first-name>Dawei</first-name><address><city>Shanghai</city><country>CN</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Zhang</last-name><first-name>Pengfei</first-name><address><city>Shanghai</city><country>CN</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A PVT calculation device includes a memory; and one or more processors in communication with the memory configured to perform operations including: receiving observations and ephemerides from satellites to obtain PVT data of the satellites and predicted PVT results of the receiver; setting up observation functions respectively corresponding to the satellites; calculating by a least square solution first estimated PVT results of the receiver based on the observation functions; iteratively eliminating by a Random-Sampling Iterative Kalman Filter (RSIKF) algorithm fault observation functions from the observation functions in an inner cluster until no fault observation functions detected in the inner cluster; calculating by the RSIKF algorithm a second estimated PVT results of the receiver using the observation functions in the inner cluster; and outputting final estimated PVT results of the receiver. The PVT calculation device may calculate the PVT results of the receiver with improved accuracy and stability.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="88.56mm" wi="157.73mm" file="US20230003906A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="111.25mm" wi="159.77mm" file="US20230003906A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="125.14mm" wi="164.68mm" file="US20230003906A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="195.83mm" wi="134.70mm" file="US20230003906A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="198.20mm" wi="161.29mm" file="US20230003906A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="203.96mm" wi="133.69mm" file="US20230003906A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">CROSS REFERENCE TO RELATED APPLICATION</heading><p id="p-0002" num="0001">This application claims priority to and incorporates by reference Chinese patent application number 202110738240.1 filed Jun. 30, 2021.</p><heading id="h-0002" level="1">TECHNICAL FIELD</heading><p id="p-0003" num="0002">The present application relates to an apparatus and a method of calculating positioning results of a Global Navigation Satellite System (GNSS) receiver, and more particularly an apparatus and a. method of calculating Position-Velocity-Time (PVT) results of a GNSS receiver.</p><heading id="h-0003" level="1">BACKGROUND</heading><p id="p-0004" num="0003">Typically, a GNSS receiver may obtain data from GNSS satellites (such as Beidou III satellites), and may calculate positioning results of the receiver based on the data. However, under some circumstances, for example, when the receiver is travelling along a path significantly affected by multipath delays, the calculated positioning results of the receiver may likely suffer inaccuracy and instability. Thus, an improved way of calculating the positioning results of the receiver with increased accuracy and stability is required.</p><heading id="h-0004" level="1">BRIEF DESCRIPTION</heading><p id="p-0005" num="0004">According to an embodiment, a PVT calculation device comprises: a memory; and one or more processors in communication with the memory, the one or more processors configured to perform operations including: receiving observations and ephemerides from satellites to obtain PVT data of the satellites and predicted PVT results of the receiver; setting up observation functions respectively corresponding to the satellites, based on the PVT data of the satellites and the predicted PVT results of the receiver; calculating by a least square solution first estimated PVT results of the receiver based on the observation functions; iteratively eliminating by a Random-Sampling Iterative Kalman Filter (RSIKF) algorithm fault observation functions from the observation functions in an inner cluster until no fault observation functions detected in the inner cluster; calculating by the RSIKF algorithm second estimated PVT results of the receiver using the observation functions in the inner cluster; and outputting final estimated PVT results of the receiver.</p><p id="p-0006" num="0005">According to an embodiment, a method of calculating PVT results of a receiver using a PVT calculation device (<b>200</b>) comprises: receiving observations and ephemerides from satellites to obtain PVT data of the satellites and predicted PVT results of the receiver; setting up observation functions respectively corresponding to the satellites, based on the PVT data of the satellites and the predicted PVT results of the receiver; calculating, by a least square solution, first estimated PVT results of the receiver based on the observation functions; iteratively eliminating, by a Random-Sampling Iterative Kalman Filter (RSIKF) algorithm, fault observation functions from the observation functions in an inner cluster until no fault observation functions detected in the inner cluster; calculating, by the RSIKF algorithm, second estimated PVT results of the receiver using the observation functions in the inner cluster; and outputting final estimated PVT results of the receiver.</p><p id="p-0007" num="0006">According to an embodiment, a non-transitory computer-readable medium storing instructions that, when executed by one or more computer processors of a PVT calculation device, cause the PVT calculation device to perform operations comprising: receiving observations and ephemerides from satellites to obtain PVT data of the satellites and predicted PVT results of the receiver; setting up observation functions respectively corresponding to the satellites, based on the PVT data of the satellites and the predicted PVT results of the receiver; calculating by a least square solution first estimated PVT results of the receiver based on the observation functions; iteratively eliminating by a Random-Sampling Iterative Kalman Filter (RSIKF) algorithm fault observation functions from the observation functions in an inner cluster until no fault observation functions detected in the inner cluster; calculating by the RSIKF algorithm a second estimated PVT results of the receiver using the observation functions in the inner cluster; and outputting final estimated PVT results of the receiver.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0008" num="0007">Non-limiting and non-exhaustive embodiments of the present application are described with reference to the following figures, wherein like reference numerals refer to like parts throughout the various views unless otherwise specified.</p><p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a diagram illustrating a GNSS receiver (<b>100</b>) according to an embodiment.</p><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a diagram illustrating a PVT calculation device (<b>200</b>) in the GNSS receiver (<b>100</b>) according to an embodiment.</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a diagram illustrating a Kalman filtering algorithm (<b>300</b>) of calculating PVT results of the receiver (<b>100</b>) using the PVT calculation device (<b>200</b>) according to an embodiment.</p><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a diagram illustrating a method (<b>400</b>) of calculating PVT results of the receiver (<b>100</b>) using the PVT calculation device (<b>200</b>) according to an embodiment.</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a block diagram showing a software architecture (<b>500</b>) within which examples may be implemented.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0006" level="1">DETAILED DESCRIPTION OF THE ILLUSTRATED EMBODIMENTS</heading><p id="p-0014" num="0013">Various aspects and examples of the application will now be described. The following description provides specific details for a thorough understanding and enabling description of these examples. Those skilled in the art will understand, however, that the application may be practiced without many of these details.</p><p id="p-0015" num="0014">Additionally, some well-known structures or functions may not be shown or described in detail, so as concise purpose and to avoid unnecessarily obscuring the relevant description.</p><p id="p-0016" num="0015">The terminology used in the description presented below is intended to be interpreted in its broadest reasonable manner, even though it is being used in conjunction with a detailed description of certain specific examples of the application. Certain terms may even be emphasized below, however, any terminology intended to be interpreted in any restricted manner will be overtly and specifically defined as such in this Detailed Description section.</p><p id="p-0017" num="0016">Without loss of generality, reference will be made to illustrative embodiments by taking an apparatus and a method of calculating Position-Velocity-Time (PVT) results of a GNSS receiver as example. Those of ordinary skills in the art understand that this is only to describe the application clearly and adequately, rather than limit the scope of the application, which is defined by the appended claims.</p><p id="p-0018" num="0017">The GNSS receiver may receive Radio Frequency (RF) signals from navigational satellites, may obtain data (such as original observations and ephemerides) from the satellites, and then may use a Kalman filter to calculate positioning results (such as PVT results) of the receiver based on the original observations and ephemerides for example. However, under some circumstances, for example, when the receiver carried by a vehicle is travelling along a path that is significantly affected by multipath delays (e.g., caused by urban high-rises, over-crosses, and canyons), the calculated PVT results of the receiver may likely suffer inaccuracy and instability.</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a diagram illustrating a GNSS receiver (<b>100</b>) according to an embodiment. The GNSS receiver (<b>100</b>) may include a signal processing device (<b>150</b>) and a PVT calculation device (<b>200</b>). The signal processing device (<b>150</b>) may include a signal input device (<b>110</b>), a baseband signal processing device (<b>120</b>), and a baseband observation processing device (<b>130</b>) coupled in series. According to an embodiment, the signal processing device (<b>150</b>) may receive and process RF navigation signals from GNSS satellites, and may output observations and ephemerides respectively corresponding to the satellites.</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a diagram illustrating the PVT calculation device (<b>200</b>) in the GNSS receiver (<b>100</b>) according to an embodiment. The PVT calculation device (<b>200</b>) may include a pre-processing module (<b>21</b>), an observation function forming module (<b>22</b>) coupled to the pre-processing module (<b>21</b>), a least square solution module (<b>23</b>) coupled to the observation function forming module (<b>22</b>) and a first convergence detector (<b>24</b>), a Random-Sampling Iterative Kalman filter (RSIKF) (<b>25</b>) coupled to the observation function forming module (<b>22</b>) and a second convergence detector (<b>27</b>), and a post-processing module (<b>26</b>) coupled to the least square solution module (<b>23</b>) and the RSIKF (<b>25</b>).</p><p id="p-0021" num="0020">The pre-processing module (<b>21</b>) may receive observations and ephemerides, may obtain positioning data (such as PVT data) of the satellites, and may obtain predicted PVT results of the receiver (<b>100</b>).</p><p id="p-0022" num="0021">The pre-processing module (<b>21</b>) may coarsely screens the observations and the ephemerides based on gross error detections of raw measurements of the observations and ephemeris validity detections of the ephemerides to obtain valid observations and ephemerides. For example, the pre-processing module (<b>21</b>) receives 20 observations and ephemerides from 20 satellites, screens out 2 invalid observations and ephemerides received from 2 corresponding satellites based on gross error detections of raw observation measurements and ephemeris validity detections, and thus obtains 18 valid observations and ephemerides to send to the observation function forming module (<b>22</b>).</p><p id="p-0023" num="0022">The observation function forming module (<b>22</b>) may set up observation functions respectively corresponding to the satellites based on the PVT data of the satellites and the predicted PVT results of the receiver (<b>100</b>). For example, the observation function forming module (<b>22</b>) may set up 18 observation functions respectively corresponding to the 18 satellites based on the PVT data of the satellites and the predicted PVT results of the receiver (<b>100</b>). The PVT data of the satellites may include the original observations and the ephemerides obtained from the satellites.</p><p id="p-0024" num="0023">The least square solution module (<b>23</b>) may receive the observation functions, and may calculate first estimated PVT results of the receiver using the observation functions.</p><p id="p-0025" num="0024">The RSIKF (<b>25</b>) may receive the observation functions, may iteratively eliminate fault observation functions from the observation functions in an inner cluster until no fault observation functions being detected in the inner cluster, and may calculate second estimated PVT results of the receiver using the observation functions.</p><p id="p-0026" num="0025">The post-processing module (<b>26</b> may output final estimated PVT results of the receiver. The final estimated PVT results of the receiver can be either the first estimated PVT results of the receiver using the observation functions calculated by the least square solution module (<b>23</b>) or the second estimated PVT results of the receiver using the observation functions calculated by the RSIKF (<b>25</b>).</p><p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a diagram illustrating a Kalman filtering algorithm (<b>300</b>) of calculating PVT results of the receiver (<b>100</b>) according to an embodiment. The RSIKF (<b>25</b>) as shown in <figref idref="DRAWINGS">FIG. <b>2</b></figref> may use the Kalman filtering algorithm (<b>300</b>) as shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref> to calculate the PVT results of the receiver (<b>100</b>) in an embodiment. The algorithm (<b>300</b>) may be stored in a storage of the RSIKF (<b>25</b>) in the PVT calculation device (<b>200</b>) in an embodiment. Below explains how the algorithm (<b>300</b>) works to calculate the PVT results of a receiver (<b>100</b>).</p><p id="p-0028" num="0027">In block <b>30</b>, the observation function forming module (<b>22</b>) may set up observation functions respectively corresponding to the satellites based on the PVT data of the satellites and the predicted PVT results of the receiver (<b>100</b>).</p><p id="p-0029" num="0028">For example, e.g., 18 observation functions may be set up based on e.g., 18 valid observations and e.g., 18 sets of ephemerides received from e.g., 18 satellites, and may be used to calculate the PVT results of a receiver (<b>100</b>).</p><p id="p-0030" num="0029">In block <b>31</b>, the algorithm (<b>300</b>) checks whether or not the current iteration is the first iteration. If yes, the algorithm goes to block <b>32</b>, otherwise, if not, the algorithm goes to block <b>33</b>.</p><p id="p-0031" num="0030">In block <b>32</b>, the RSIKF (<b>25</b>) randomly samples a first number of observation functions from the observation functions as inner functions into an inner cluster, and puts a second number of observation functions from the observation functions as outlier functions in an outlier cluster. The inner and outlier clusters may be stored in the RSIKF (<b>25</b>).</p><p id="p-0032" num="0031">For example, the RSIKF (<b>25</b>) may randomly sample 10 observation functions from the 18 valid observation functions as inner observation functions in the inner cluster, and puts remaining 8 observation functions as outlier observation functions in the outlier cluster. In this way, the 18 valid observation functions are randomly assigned as 10 inner observation functions and 8 outlier observation functions in block <b>32</b>.</p><p id="p-0033" num="0032">In block <b>34</b>, the RSIKF (<b>25</b>) randomly ranks the inner observation functions in the inner cluster in a sequential order. For example, the RSIKF (<b>25</b>) may randomly rank the 10 inner observation functions in the inner cluster in a sequential order.</p><p id="p-0034" num="0033">In block <b>35</b>, the RSIKF (<b>25</b>) chi-square detects the inner observation functions in the inner cluster one-by-one in the sequential order. If one or more fault inner observation functions are chi-square detected in the inner cluster, the RSIKF (<b>25</b>) will move the one or more fault inner observation functions from the inner cluster to the outlier cluster.</p><p id="p-0035" num="0034">For example, the RSIKF (<b>25</b>) may chi-square detect the 10 inner observation functions in the inner cluster one-by-one in the sequential order. If e.g., 3 fault inner observation functions are chi-square detected in the inner cluster, the RSIKF (<b>25</b>) will move the 3 fault inner observation functions from the inner cluster to the outlier cluster.</p><p id="p-0036" num="0035">Then, in block <b>35</b>, if a first inner observation function in the inner cluster (e.g., with 10 inner observation functions at start) passes a RSIKF chi-square detection, the first inner observation function will update the predicted PVT results of the receiver to form an updated PVT results of the receiver.</p><p id="p-0037" num="0036">Next, in block <b>35</b>, if a subsequent (e.g., the second) inner observation function passes the RSIKF chi-square detection, the subsequent inner observation function will update the updated PVT results of the receiver. This process in block <b>35</b> goes on one by one with other inner observation functions of the 10 inner observation functions in the inner cluster.</p><p id="p-0038" num="0037">Finally, in block <b>35</b>, if a last inner observation function (e.g., the tenth) passes the RSIKF chi-square detection, the last inner observation function updates the updated PVT results of the receiver.</p><p id="p-0039" num="0038">In this way, each inner observation function in the inner cluster passing a RSIKF chi-square detection updates the predicted PVT results of the receiver to form a most currently updated PVT results of the receiver.</p><p id="p-0040" num="0039">In block <b>36</b>, the RSIKF (<b>25</b>) chi-square detects (<b>36</b>) the second number of observation functions in the outlier cluster. If one or more quality outlier observation functions are chi-square detected in the outlier cluster, the RSKKF (<b>25</b>) will move the one or more quality outlier observation functions from the outlier cluster to the inner cluster. For example, if e.g., 2 quality outlier observation functions are chi-square detected in the outlier cluster having 8 outlier observation functions, the RSKKF (<b>25</b>) will move the 2 quality outlier observation functions from the outlier cluster to the inner cluster.</p><p id="p-0041" num="0040">In this way, each quality outlier observation function in the outlier cluster passing a RSIKF chi-square detection is moved from the outlier cluster to the inner cluster.</p><p id="p-0042" num="0041">In block <b>37</b>, at the end of the current iteration, upon detecting at least one observation function moving between the inner and outlier clusters in the current iteration, a RSIKF convergence detection is set false. Otherwise, upon detecting no functions moving between the inner and outlier clusters in the current iteration, the RSIKF convergence detection is set true. After that, the current iteration is done.</p><p id="p-0043" num="0042">For example, in the current iteration, since 3 fault inner observation functions are detected moving from the inner cluster to the outlier cluster, as well as <b>2</b> quality outlier observation functions are detected moving from the outlier cluster to the inner cluster, the RSIKF convergence detection is set false.</p><p id="p-0044" num="0043">As long as the RSIKF convergence detection is false, the Kalman filtering algorithm (<b>300</b>) will continue to run a subsequent iteration starting from block <b>31</b> again. The subsequent iteration is described as follows.</p><p id="p-0045" num="0044">In block <b>31</b>, the algorithm (<b>300</b>) checks that the subsequent iteration is not the first (or initial) iteration, and thus goes to block <b>33</b>.</p><p id="p-0046" num="0045">In block <b>33</b>, the RSIKF (<b>25</b>) adjusts the inner and the outlier clusters for the subsequent iteration.</p><p id="p-0047" num="0046">In block <b>34</b>, the RSIKF (<b>25</b>) randomly ranks the adjusted inner observation functions in the adjusted inner cluster (<b>34</b>) in the sequential order in the subsequent iteration. For example, the RSIKF randomly ranks the 9 adjusted inner observation functions in the adjusted inner cluster in the sequential order in the subsequent iteration.</p><p id="p-0048" num="0047">In block <b>35</b>, the RSIKF (<b>25</b>) sequentially chi-square detects the adjusted inner observation functions (e.g., the 9 adjusted inner observation functions) in the adjusted inner cluster in the sequential order in the subsequent iteration.</p><p id="p-0049" num="0048">The operations performed in the block <b>35</b> with respect to the subsequent iteration are the same as those performed in the block <b>35</b> as described with respect to the first iteration.</p><p id="p-0050" num="0049">For example, in block <b>35</b>, a first inner observation function passing the RSIKF chi-square detection updates the predicted PVT results of the receiver from the pre-processing module (<b>21</b>) to form an updated PVT results of the receiver in the subsequent iteration. Next, in block <b>35</b>, a subsequent inner observation function passing the RSIKF chi-square detection updates the updated PVT results of the receiver in the subsequent iteration. Finally, in block <b>35</b>, a last inner observation function passing the RSIKF chi-square detection finally updates the updated PVT results of the receiver in the subsequent iteration.</p><p id="p-0051" num="0050">In block <b>36</b>, the RSIKF chi-square detects the outlier observation functions in the outlier cluster to find one or more quality outlier observations to move to the inner cluster in the subsequent iteration.</p><p id="p-0052" num="0051">In block <b>37</b>, based on whether at least a moving function is found moving between the inner and the outlier clusters in the subsequent iteration, the RSIKF convergence detection is set false or true in the subsequent iteration. If the RSIKF convergence detection is detected false in the subsequent iteration, another subsequent iteration will carry out, until the RSIKF convergence detection is detected true.</p><p id="p-0053" num="0052">In an embodiment, responsive to the RSIKF convergence detection being true, the RSIKF (<b>25</b>) outputs the updated PVT results of the receiver, which is calculated by the RSIKF (<b>25</b>) as the final estimated PVT results of the receiver. In this way, improved positioning results of the receiver with increased accuracy and robustness can be calculated by the RSIKF.</p><p id="p-0054" num="0053">In an embodiment, responsive to the RSIKF convergence detection being false after a limited number of iterations (e.g., 20 times), the post-processing module (<b>26</b>) outputs the first estimated PVT results of the receiver, which is calculated by the least square solution module (<b>23</b>), as the final estimated PVT results of the receiver. In this way, the first estimated PVT results of the receiver calculated by the least square solution module (<b>23</b>) can be used as a backup, when the second estimated PVT results of the receiver calculated by the RSIKF (<b>25</b>) is unavailable due to the final false result of the RSIKF convergence detection.</p><p id="p-0055" num="0054">The Kalman filtering algorithm (<b>300</b>), a random sampling iterative filtering algorithm, may randomly sample the observation functions into the inner cluster at the beginning, may randomly rank the inner observation functions in the inner cluster in each iteration, may iteratively eliminate fault inner observation functions from the inner cluster in each iteration, and may keep on updating the predicted PVT results of the receiver obtained from the pre-processing module by each inner observation function passing the RSIKF chi-square detection in each iteration. Thus, the Kalman filtering algorithm (<b>300</b>) can improve the accuracy and stability of the PVT results of the receiver, especially when the receiver is located on a patch that is significantly affected by multiple delays, for example, caused by urban high-rises, overpasses, and canyons. A course of a vehicle carrying the GNSS receiver (<b>100</b>) can be changed based on the final estimated PVT results of the receiver.</p><p id="p-0056" num="0055"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a diagram illustrating a method (<b>400</b>) of calculating PVT results of a receiver (<b>100</b>) using a PVT calculation device (<b>200</b>) according to an embodiment. As shown in <figref idref="DRAWINGS">FIG. <b>2</b></figref>, the PVT calculation device (<b>200</b>) may include a pre-processing module (<b>21</b>), an observation function forming module (<b>22</b>) coupled to the pre-processing module (<b>21</b>), a least square solution module (<b>23</b>) coupled to a first convergence detector (<b>24</b>) and the observation function forming module (<b>22</b>), a RSIKF (<b>25</b>) coupled to a second convergence detector (<b>27</b>) and the observation function forming module (<b>22</b>), and a post-processing module (<b>26</b>) coupled to the least square solution module (<b>23</b>) and the RSIKF (<b>25</b>).</p><p id="p-0057" num="0056">The method (<b>400</b>) of calculating PVT results of a receiver (<b>100</b>) using a PVT calculation device (<b>200</b>) according to an embodiment is described as follows.</p><p id="p-0058" num="0057">In block <b>401</b>, receiving, by a pre-processing module (<b>21</b>), observations and ephemerides from satellites, to obtain PVT data of the satellites and predicted PVT results of the receiver (<b>401</b>).</p><p id="p-0059" num="0058">In block <b>402</b>, setting up, by the observation function forming module (<b>22</b>), observation functions respectively corresponding to the satellites, based on the PVT data of the satellites and the predicted PVT results of the receiver (<b>402</b>).</p><p id="p-0060" num="0059">In block <b>403</b>, calculating, by the least square solution module (<b>23</b>), first estimated PVT results of the receiver based on the observation functions (<b>403</b>).</p><p id="p-0061" num="0060">In block <b>404</b>, iteratively eliminating, by the RSIKF (<b>25</b>), fault observation functions from the observation functions in an inner cluster until no fault observation functions detected in the inner cluster (<b>404</b>).</p><p id="p-0062" num="0061">In block <b>405</b>, calculating, by the RSIKF (<b>25</b>), second estimated PVT results of the receiver using the observation functions in the inner cluster (<b>405</b>).</p><p id="p-0063" num="0062">In block <b>406</b>, outputting, by the post-processing module (<b>26</b>), final estimated PVT results of the receiver (<b>406</b>).</p><p id="p-0064" num="0063">In an embodiment, in a first iteration (<b>31</b>), the RSIKF (<b>25</b>) randomly samples a first number of observation functions into the inner cluster (<b>32</b>), and puts a remaining second number of observation functions in an outlier cluster.</p><p id="p-0065" num="0064">In the first iteration, the RSIKF (<b>25</b>) randomly ranks inner observation functions in the inner cluster (<b>34</b>) in a sequential order.</p><p id="p-0066" num="0065">In the first iteration, the RSIKF (<b>25</b>) sequentially chi-square detects (<b>35</b>) the inner observation functions in the inner cluster in the sequential order, and upon detecting one or more fault inner observation functions in the inner cluster, the RSIKF (<b>25</b>) moves the one or more fault inner observation functions from the inner cluster to the outlier cluster.</p><p id="p-0067" num="0066">In the first iteration, the RSIKF (<b>25</b>) chi-square detects (<b>36</b>) the second number of observation functions in the outlier cluster, and upon detecting at least a quality outlier observation function in the outlier cluster, the RSIKF (<b>25</b>) moves the at least quality outlier observation function from the outlier cluster to the inner cluster.</p><p id="p-0068" num="0067">How the RSIKF (<b>25</b>) calculates the second estimated PVT results of the receiver is further explained with respect to <figref idref="DRAWINGS">FIGS. <b>3</b> and <b>4</b></figref>. In the first iteration, responsive to detecting a first inner observation function passing a RSIKF chi-square detection, the first inner observation function updates (<b>35</b>) the predicted PVT results of the receiver to form an updated PVT results of the receiver. Next, responsive to detecting a subsequent inner observation function passing the RSIKF chi-square detection, the subsequent inner observation function updates (<b>35</b>) the updated PVT results of the receiver. Finally, responsive to detecting a last inner observation function passing the RSIKF chi-square detection, the last inner observation function updates (<b>35</b>) the updated PVT results of the receiver.</p><p id="p-0069" num="0068">In an embodiment, upon at least one function of the observation functions being found moving between the inner and outlier clusters in a current iteration in the first iteration, a RSIKF convergence detection is set false (<b>37</b>), and upon no functions being found moving between the inner and outlier clusters in the first iteration, the RSIKF convergence detection is set true.</p><p id="p-0070" num="0069">In case that the RSIKF convergence detection is detected false, the subsequent iteration will continue. In the subsequent iteration, the RSIKF first adjusts the inner cluster and the outlier cluster. Subsequently, the RSIKF randomly ranks the inner observation functions in the adjusted inner cluster in a sequential order. Next, RSIKF sequentially chi-square detects the inner observation functions in the adjusted inner cluster in the sequential order. Upon detecting one or more fault inner observation functions in the adjusted inner cluster, the RSIKF moves the one or more fault inner observation functions from the adjusted inner cluster to the adjusted outlier cluster.</p><p id="p-0071" num="0070">In the subsequent iteration, a further first inner observation functions passing the chi-square detecting by the RSIKF updates the predicted PVT results of the receiver obtained from the pre-processing module (<b>21</b>) to form a further updated PVT results of the receiver. Next, a further subsequent inner observation function passing the chi-square detecting by the RSIKF updates the further updated PVT results of the receiver. Finally, a further last inner observation function passing the chi-square detecting by the RSIKF updates the further updated PVT results of the receiver.</p><p id="p-0072" num="0071">In the subsequent iteration, the RSIKF chi-square detects the outlier observation functions in the adjusted outlier cluster. Upon detecting at least one quality outlier observation function in the adjusted outlier cluster, the RSIKF moves the at least quality outlier observation function from the adjusted outlier cluster to the adjusted inner cluster.</p><p id="p-0073" num="0072">In the subsequent iteration, whether to continue to perform another subsequent iteration depends on whether at least an observation function is found moving between the adjusted inner and outlier clusters. Iterations will continue until no observation functions are found moving between the adjusted inner and outlier clusters.</p><p id="p-0074" num="0073">Upon finding no observation functions moving between the adjusted inner and outlier clusters in the subsequent iteration, the updated PVT results of the receiver are output to the outside by the post-processing module (<b>26</b>) as the final estimated PVT results of the receiver. Upon finding at least one observation functions moving between the adjusted inner and outlier clusters in the subsequent iteration, a further subsequent iteration will carry out.</p><p id="p-0075" num="0074">In an embodiment, upon finding at least one observation function moving between the adjusted inner and outlier clusters after a limited number of iterations (for example, 30 times), the first estimated PVT results of the receiver are output by the post-processing module (<b>26</b>) as the final estimated PVT results of the receiver to outside.</p><p id="p-0076" num="0075"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a block diagram <b>500</b> illustrating a software architecture <b>504</b>, which can be installed on any one or more of the wireless smart devices (such as a smart socket) described herein. The software architecture <b>504</b> is supported by hardware such as a machine <b>502</b> that includes processors <b>520</b>, memory <b>526</b>, and I/O components <b>538</b>. In this example, the software architecture <b>504</b> can be conceptualized as a stack of layers, where each layer provides a particular functionality. The software architecture <b>504</b> includes layers such as an operating system <b>512</b>, libraries <b>510</b>, frameworks <b>508</b>, and applications <b>506</b>. Operationally, the applications <b>506</b> invoke API calls <b>550</b> through the software stack and receive messages <b>552</b> in response to the API calls <b>550</b>.</p><p id="p-0077" num="0076">The operating system <b>512</b> manages hardware resources and provides common services. The operating system <b>512</b> includes, for example, a kernel <b>514</b>, services <b>516</b>, and drivers <b>522</b>. The kernel <b>514</b> acts as an abstraction layer between the hardware and the other software layers. For example, the kernel <b>514</b> provides memory management, processor management (e.g., scheduling), component management, networking, and security settings, among other functionality. The services <b>516</b> can provide other common services for the other software layers. The drivers <b>522</b> are responsible for controlling or interfacing with the underlying hardware. For instance, the drivers <b>522</b> can include display drivers, camera drivers, BLUETOOTH&#xae; or BLUETOOTH&#xae; Low Energy drivers, flash memory drivers, serial communication drivers (e.g., USB drivers), WI-FI&#xae; drivers, audio drivers, power management drivers, and so forth.</p><p id="p-0078" num="0077">The libraries <b>510</b> provide a common low-level infrastructure used by the applications <b>506</b>. The libraries <b>510</b> can include system libraries <b>518</b> (e.g., C standard library) that provide functions such as memory allocation functions, string manipulation functions, mathematic functions, and the like. In addition, the libraries <b>510</b> can include API libraries <b>524</b> such as media libraries (e.g., libraries to support presentation and manipulation of various media formats such as Moving Picture Experts Group-4 (MPEG4), Advanced Video Coding (H.264 or AVC), Moving Picture Experts Group Layer-3 (MP3), Advanced Audio Coding (AAC), Adaptive Multi-Rate (AMR) audio codec, Joint Photographic Experts Group (JPEG or JPG), or Portable Network Graphics (PNG)), graphics libraries (e.g., an OpenGL framework used to render in two dimensions (2D) and three dimensions (3D) in a graphic content on a display), database libraries (e.g., SQLite to provide various relational database functions), web libraries (e.g., WebKit to provide web browsing functionality), and the like. The libraries <b>510</b> can also include a wide variety of other libraries <b>528</b> to provide many other APIs to the applications <b>506</b>.</p><p id="p-0079" num="0078">The frameworks <b>508</b> provide a common high-level infrastructure that is used by the applications <b>506</b>. For example, the frameworks <b>508</b> provide various graphical user interface (GUI) functions, high-level resource management, and high-level location services. The frameworks <b>508</b> can provide a broad spectrum of other APIs that can be used by the applications <b>506</b>, some of which may be specific to a particular operating system or platform.</p><p id="p-0080" num="0079">In an example, the applications <b>506</b> may include a home application <b>536</b>, a contacts application <b>530</b>, a browser application <b>532</b>, a book reader application <b>534</b>, a location application <b>542</b>, a media application <b>544</b>, a messaging application <b>546</b>, a game application <b>548</b>, and a broad assortment of other applications such as a third-party application <b>540</b>. The applications <b>506</b> are programs that execute functions defined in the programs. Various programming languages can be employed to create one or more of the applications <b>506</b>, structured in a variety of manners, such as object-oriented programming languages (e.g., Objective-C, Java, or C++) or procedural programming languages (e.g., C or assembly language). In a specific example, the third-party application <b>540</b> (e.g., an application developed using the ANDROID&#x2122; or IOS&#x2122; software development kit (SDK) by an entity other than the vendor of the particular platform) may be mobile software running on a mobile operating system such as IOS&#x2122;, ANDROID&#x2122;, WINDOWS&#xae; Phone, or another mobile operating system. In this example, the third-party application <b>540</b> can invoke the API calls <b>550</b> provided by the operating system <b>512</b> to facilitate functionality described herein.</p><p id="p-0081" num="0080">Features and aspects of various embodiments may be integrated into other embodiments, and embodiments illustrated in this document may be implemented without all of the features or aspects illustrated or described.</p><p id="p-0082" num="0081">One skilled in the art will appreciate that although specific examples and embodiments of the system and methods have been described for purposes of illustration, various modifications can be made without deviating from the spirit and scope of the present application. Moreover, features of one embodiment may be incorporated into other embodiments, even where those features are not described together in a single embodiment within the present document. Accordingly, the application is described by the appended claims.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A Position-Velocity-Time (PVT) calculation device (<b>200</b>) in a Global Navigation Satellite System (GLASS) receiver (<b>100</b>), comprising:<claim-text>a memory; and</claim-text><claim-text>one or more processors in communication with the memory, the one or more processors configured to perform operations including:<claim-text>receiving observations and ephemerides from satellites to obtain PVT data of the satellites and predicted PVT results of the receiver;</claim-text><claim-text>setting up observation functions respectively corresponding to the satellites, based on the PVT data of the satellites and the predicted PVT results of the receiver;</claim-text><claim-text>calculating by a least square solution first estimated PVT results of the receiver based on the observation functions;</claim-text><claim-text>iteratively eliminating, by a Random-Sampling Iterative Kalman Filter (RSIKF) algorithm, fault observation functions from the observation functions in an inner cluster until no fault observation functions detected in the inner cluster;</claim-text><claim-text>calculating, by the RSIKF algorithm, second estimated PVT results of the receiver using the observation functions in the inner cluster; and</claim-text></claim-text><claim-text>outputting final estimated PVT results of the receiver.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The PVT calculation device of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the iteratively eliminating fault functions from the observation functions comprises:<claim-text>in a first iteration (<b>31</b>), randomly sampling (<b>32</b>) a first number of observation functions into the inner cluster, and putting a remaining second number of observation functions in an outlier cluster;</claim-text><claim-text>in the first iteration, randomly ranking (<b>34</b>) inner observation functions in the inner cluster in a sequential order;</claim-text><claim-text>in the first iteration, sequentially chi-square detecting (<b>35</b>) the inner observation functions in the inner cluster in the sequential order, wherein upon detecting one or more fault inner observation functions in the inner cluster, the one or more fault inner observation functions are moved from the inner cluster to the outlier cluster; and</claim-text><claim-text>in the first iteration, chi-square detecting the second number of observation functions in the outlier cluster (<b>36</b>), wherein upon detecting at least a quality outlier observation function in the outlier cluster, the at least quality outlier observation function are moved from the outlier cluster to the inner cluster.</claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The PVT calculation device of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the calculating the second estimated PVT results of the receiver using the remaining observation functions comprises:<claim-text>in the first iteration, responsive to detecting a first inner observation function passing a RSIKF chi-square detection, updating by the first inner observation function the predicted PVT results of the receiver to form an updated PVT results of the receiver,</claim-text><claim-text>in the first iteration, responsive to detecting a subsequent inner observation function passing the RSIKF chi-square detection, updating by the subsequent inner observation function the updated PVT results of the receiver, and</claim-text><claim-text>in the first iteration, responsive to detecting a last inner observation function passing the RSIKF chi-square detection, updating by the last inner observation function the updated PVT results of the receiver.</claim-text></claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The PVT calculation device of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein upon at least one function of the observation functions being found moving between the inner and outlier clusters in a current iteration in the first iteration, a RSIKF convergence detection is set false, and<claim-text>wherein upon no functions being found moving between the inner and outlier clusters in the first iteration, the RSIKF convergence detection is set true.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The PVT calculation device of <claim-ref idref="CLM-00004">claim 4</claim-ref>, further comprising:<claim-text>in a subsequent iteration, if the RSIKF convergence detection is set false after the first iteration, adjusting (<b>33</b>) the inner cluster and the outlier cluster;</claim-text><claim-text>in the subsequent iteration, randomly ranking (<b>34</b>) by the RSIKF algorithm the inner observation functions in the adjusted inner cluster in a sequential order;</claim-text><claim-text>in the subsequent iteration, sequentially chi-square detecting (<b>35</b>) by the RSIKF algorithm the inner observation functions in the adjusted inner cluster in the sequential order,</claim-text><claim-text>wherein a further first inner observation functions passing the chi-square detecting by the RSIKF algorithm updates the predicted PVT results of the receiver to form a further updated PVT results of the receiver,</claim-text><claim-text>wherein a further subsequent inner observation function passing the chi-square detecting by the RSIKF algorithm updates the further updated PVT results of the receiver, and</claim-text><claim-text>wherein a further last inner observation function passing the chi-square detecting by the RSIKF algorithm updates the further updated PVT results of the receiver;</claim-text><claim-text>in the subsequent iteration, upon detecting one or more fault inner observation functions in the adjusted inner cluster, moving the one or more fault inner observation functions from the adjusted inner cluster to the adjusted outlier cluster;</claim-text><claim-text>in the subsequent iteration, chi-square detecting (<b>36</b>) the outlier observation functions in the adjusted outlier cluster, wherein upon detecting at least a quality outlier observation function in the adjusted outlier cluster, the at least quality outlier observation function is moved from the adjusted outlier cluster to the adjusted inner cluster; and</claim-text><claim-text>in the subsequent iteration, determining whether to continue to another subsequent iteration based on whether at least an observation function is found moving between the adjusted inner and outlier clusters, wherein iterations continues until no observation functions are found moving between the adjusted inner and outlier clusters.</claim-text></claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The PVT calculation device of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein upon finding no observation functions moving between the adjusted inner and outlier clusters in the subsequent iteration, the updated PVT results of the receiver are output as the final estimated PVT results of the receiver to outside, and wherein upon finding at least one observation functions moving between the adjusted inner and outlier clusters in the subsequent iteration, a further subsequent iteration carries out.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The PVT calculation device of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein upon finding at least one observation function moving between the adjusted inner and outlier clusters after a limited number of iterations, the first estimated PVT results of the receiver are output as the final estimated PVT results of the receiver to outside.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. A computer-implemented method (<b>400</b>) of calculating Position-Velocity-Time (PVT) results of a receiver (<b>100</b>) using a PVT calculation device (<b>200</b>), the method comprising:<claim-text>receiving observations and ephemerides from satellites to obtain PVT data of the satellites and predicted PVT results of the receiver;</claim-text><claim-text>setting up observation functions respectively corresponding to the satellites, based on the PVT data of the satellites and the predicted PVT results of the receiver;</claim-text><claim-text>calculating, by a least square solution, first estimated PVT results of the receiver based on the observation functions;</claim-text><claim-text>iteratively eliminating, by a Random-Sampling Iterative Kalman Filter (RSIKF) algorithm, fault observation functions from the observation functions in an inner cluster until no fault observation functions detected in the inner cluster;</claim-text><claim-text>calculating, by the RSIKF algorithm, second estimated PVT results of the receiver using the observation functions in the inner cluster; and</claim-text><claim-text>outputting final estimated PVT results of the receiver.</claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The computer-implemented method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the iteratively eliminating fault functions by the RSIKF algorithm from the observation functions comprises:<claim-text>in a first iteration (<b>31</b>), randomly sampling (<b>32</b>) a first number of observation functions into the inner cluster, and putting a remaining second number of observation functions in an outlier cluster;</claim-text><claim-text>in the first iteration, randomly ranking (<b>34</b>) inner observation functions in the inner cluster in a sequential order;</claim-text><claim-text>in the first iteration, sequentially chi-square detecting (<b>35</b>) the inner observation functions in the inner cluster in the sequential order, wherein upon detecting one or more fault inner observation functions in the inner cluster, the one or more fault inner observation functions are moved from the inner cluster to</claim-text><claim-text>the outlier cluster; and in the first iteration, chi-square detecting the second number of observation functions in the outlier cluster (<b>36</b>), wherein upon detecting at least a quality outlier observation function in the outlier cluster, the at least quality outlier observation function is moved from the outlier cluster to the inner cluster.</claim-text></claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The computer-implemented method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, wherein the calculating by the RSIKF algorithm the second estimated PVT results of the receiver using the remaining observation functions comprises:<claim-text>in the first iteration, responsive to detecting a first inner observation function passing a RSIKF chi-square detection, updating by the first inner observation function the predicted PVT results of the receiver to form an updated PVT results of the receiver,</claim-text><claim-text>in the first iteration, responsive to detecting a. subsequent inner observation function passing the RSIKF chi-square detection, updating by the subsequent inner observation function the updated PVT results of the receiver, and</claim-text><claim-text>in the first iteration, responsive to detecting a last inner observation function passing the RSIKF chi-square detection, updating by the last inner observation function the updated PVT results of the receiver.</claim-text></claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The computer-implemented method of <claim-ref idref="CLM-00010">claim 10</claim-ref>, wherein upon at least one function of the observation functions being found moving between the inner and outlier clusters in a current iteration in the first iteration, a RSIKF convergence detection is set false,<claim-text>and wherein upon no functions being found moving between the inner and outlier clusters in the first iteration, the RSIKF convergence detection is set true.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The computer-implemented method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, further comprising:<claim-text>in a subsequent iteration, if the RSIKF convergence detection is set false after the first iteration, adjusting (<b>33</b>) by the RSIKF the inner cluster and the outlier cluster;</claim-text><claim-text>in the subsequent iteration, randomly ranking (<b>34</b>) by the RSIKF algorithm the inner observation functions in the adjusted inner cluster in a sequential order;</claim-text><claim-text>in the subsequent iteration, sequentially chi-square detecting (<b>35</b>) by the RSIKF algorithm the inner observation functions in the adjusted inner cluster in the sequential order,</claim-text><claim-text>wherein upon detecting one or more fault inner observation functions in the adjusted inner cluster, the one or more fault inner observation functions are moved from the adjusted inner cluster to the adjusted outlier cluster,</claim-text><claim-text>wherein a further first inner observation functions passing the chi-square detecting by the RSIKF algorithm updates the predicted PVT results of the receiver to form a further updated PVT results of the receiver,</claim-text><claim-text>wherein a further subsequent inner observation function passing the chi-square detecting by the RSIKF algorithm updates the further updated PVT results of the receiver, and</claim-text><claim-text>wherein a further last inner observation function passing the chi-square detecting by the RSIKF algorithm updates the further updated PVT results of the receiver;</claim-text><claim-text>in the subsequent iteration, chi-square detecting (<b>36</b>) by the RSIKF algorithm the outlier observation functions in the adjusted outlier cluster, wherein upon detecting at least a quality outlier observation function in the adjusted outlier cluster, the at least quality outlier observation function is moved from the adjusted outlier cluster to the adjusted inner cluster; and</claim-text><claim-text>in the subsequent iteration, determining whether to continue to another subsequent iteration based on whether at least an observation function is found moving between the adjusted inner and outlier clusters, wherein iterations continues until no observation functions are found moving between the adjusted inner and outlier clusters.</claim-text></claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The computer-implemented method of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein upon finding no observation functions moving between the adjusted inner and outlier clusters in the subsequent iteration, the updated PVT results of the receiver are output as the final estimated PVT results of the receiver to outside, and wherein upon finding at least one observation functions moving between the adjusted inner and outlier clusters in the subsequent iteration, a further subsequent iteration carries out.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The computer-implemented method of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein upon finding at least one observation function moving between the adjusted inner and outlier clusters after a limited number of iterations, the first estimated PVT results of the receiver are output as the final estimated PVT results of the receiver to outside.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. A non-transitory computer-readable medium storing instructions that, when executed by one or more computer processors of a Position-Velocity-Time (PVT) calculation device (<b>200</b>) in a Global Navigation Satellite System (GNSS) receiver (<b>100</b>), cause the PVT calculation device to perform operations comprising:<claim-text>receiving observations and ephemerides from satellites to obtain PVT data of the satellites and predicted PVT results of the receiver;</claim-text><claim-text>setting up observation functions respectively corresponding to the satellites, based on the PVT data of the satellites and the predicted PVT results of the receiver;</claim-text><claim-text>calculating by a least square solution first estimated PVT results of the receiver based on the observation functions;</claim-text><claim-text>iteratively eliminating by a Random-Sampling Iterative Kalman Filter (RSIKF) algorithm fault observation functions from the observation functions in an inner cluster until no fault observation functions detected in the inner cluster;</claim-text><claim-text>calculating by the RSIKF algorithm a second estimated PVT results of the receiver using the observation functions in the inner cluster; and</claim-text><claim-text>outputting final estimated PVT results of the receiver.</claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The non-transitory computer-readable medium of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein a course of a vehicle carrying the GNSS receiver is changed based on the final estimated PVT results of the receiver.</claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The non-transitory computer-readable medium of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the iteratively eliminating fault functions by the RSIKF algorithm from the observation functions comprises:<claim-text>in a first iteration (<b>31</b>), randomly sampling (<b>32</b>) a first number of observation functions into the inner cluster, and putting a remaining second number of observation functions in an outlier cluster;</claim-text><claim-text>in the first iteration, randomly ranking (<b>34</b>) inner observation functions in the inner cluster in a sequential order;</claim-text><claim-text>in the first iteration, sequentially chi-square detecting (<b>35</b>) the inner observation functions in the inner cluster in the sequential order, wherein upon detecting one or more fault inner observation functions in the inner cluster, the one or more fault inner observation functions are moved from the inner cluster to the outlier cluster; and</claim-text><claim-text>in the first iteration, chi-square detecting the second number of observation functions in the outlier cluster (<b>36</b>), wherein upon detecting at least a quality outlier observation function in the outlier cluster, the at least quality outlier observation function is moved from the outlier cluster to the inner cluster.</claim-text></claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The non-transitory computer-readable medium of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the calculating by the RSIKF algorithm the second estimated PVT results of the receiver using the remaining observation functions comprises:<claim-text>in the first iteration, responsive to detecting a first inner observation function passing a RSIKF chi-square detection, updating by the first inner observation function the predicted PVT results of the receiver to form an updated PVT results of the receiver,</claim-text><claim-text>in the first iteration, responsive to detecting a. subsequent inner observation function passing the RSIKF chi-square detection, updating by the subsequent inner observation function the updated PVT results of the receiver, and</claim-text><claim-text>in the first iteration, responsive to detecting a last inner observation function passing the RSIKF chi-square detection, updating by the last inner observation function the updated PVT results of the receiver.</claim-text></claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The non-transitory computer-readable medium of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein the operations further comprise:<claim-text>in a subsequent iteration, if a RSIKF convergence detection is set false after the first iteration, adjusting (<b>33</b>) by the RSIKF algorithm the inner cluster and the outlier cluster;</claim-text><claim-text>in the subsequent iteration, randomly ranking (<b>34</b>) by the RSIKF algorithm the inner observation functions in the adjusted inner cluster in a sequential order;</claim-text><claim-text>in the subsequent iteration, sequentially chi-square detecting (<b>35</b>) by the RSIKF algorithm the inner observation functions in the adjusted inner cluster in the sequential order,</claim-text><claim-text>wherein upon detecting one or more fault inner observation functions in the adjusted inner cluster, the one or more fault inner observation functions are moved from the adjusted inner cluster to the adjusted outlier cluster,</claim-text><claim-text>wherein a further first inner observation functions passing the chi-square detecting by the RSIKF algorithm updates the predicted PVT results of the receiver to form a further updated PVT results of the receiver,</claim-text><claim-text>wherein a further subsequent inner observation function passing the chi-square detecting by the RSIKF algorithm updates the further updated PVT results of the receiver, and</claim-text><claim-text>wherein a further last inner observation function passing the chi-square detecting by the RSIKF algorithm updates the further updated PVT results of the receiver;</claim-text><claim-text>in the subsequent iteration, chi-square detecting (<b>36</b>) by the RSIKF algorithm the outlier observation functions in the adjusted outlier cluster, wherein upon detecting at least a quality outlier observation function in the adjusted outlier cluster, the at least quality outlier observation function is moved from the adjusted outlier cluster to the adjusted inner cluster; and</claim-text><claim-text>in the subsequent iteration, determining whether to continue to another subsequent iteration based on whether at least an observation function is found moving between the adjusted inner and outlier clusters, wherein iterations continues until no observation functions are found moving between the adjusted inner and outlier clusters.</claim-text></claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The non-transitory computer-readable medium of <claim-ref idref="CLM-00019">claim 19</claim-ref>, wherein upon finding no observation functions moving between the adjusted inner and outlier clusters in the subsequent iteration, the updated PVT results of the receiver are output as the final estimated PVT results of the receiver to outside, and wherein upon finding at least one observation functions moving between the adjusted inner and outlier clusters in the subsequent iteration, a further subsequent iteration carries out.</claim-text></claim></claims></us-patent-application>