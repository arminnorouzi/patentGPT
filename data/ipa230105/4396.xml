<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004397A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004397</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17943341</doc-number><date>20220913</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20180101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>38</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>3861</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc></classifications-cpc><invention-title id="d2e43">TRACKING EXACT CONVERGENCE TO GUIDE THE RECOVERY PROCESS IN RESPONSE TO A MISPREDICTED BRANCH</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>17323069</doc-number><date>20210518</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11494191</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17943341</doc-number></document-id></child-doc></relation></continuation></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Microsoft Technology Licensing, LLC</orgname><address><city>Redmond</city><state>WA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>KOTHINTI NARESH</last-name><first-name>Vignyan Reddy</first-name><address><city>Redmond</city><state>WA</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>PRIYADARSHI</last-name><first-name>Shivam</first-name><address><city>Apex</city><state>NC</state><country>US</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">Processors and methods related to tracking exact convergence to guide the recovery process in response to a mispredicted branch are provided. An example processor includes a pipeline having a frontend and a backend. The processor further includes a state table for maintaining information related to at least a subset of branches corresponding to instructions being processed by the processor. The processor further includes state logic configured to access the state table and track locations of any exact convergence points associated with branches corresponding to the instructions being processed by the processor. The state logic is further configured to identify a first recovery method for recovering from a misprediction associated with a branch if a location of an exact convergence point associated with the branch is determined to be in the frontend of the pipeline, else identify a second recovery method for recovering from the misprediction associated with the branch.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="69.26mm" wi="158.75mm" file="US20230004397A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="261.45mm" wi="115.23mm" orientation="landscape" file="US20230004397A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="255.86mm" wi="128.61mm" orientation="landscape" file="US20230004397A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="103.04mm" wi="64.94mm" orientation="landscape" file="US20230004397A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="260.43mm" wi="167.13mm" orientation="landscape" file="US20230004397A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="257.30mm" wi="136.14mm" orientation="landscape" file="US20230004397A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="232.41mm" wi="146.98mm" orientation="landscape" file="US20230004397A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="232.41mm" wi="115.99mm" orientation="landscape" file="US20230004397A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATION(S)</heading><p id="p-0002" num="0001">This application is a continuation of U.S. patent application Ser. No. 17/323,069, filed on May 18, 2021, entitled &#x201c;TRACKING EXACT CONVERGENCE TO GUIDE THE RECOVERY PROCESS IN RESPONSE TO A MISPREDICTED BRANCH,&#x201d; the entire contents of which are hereby incorporated herein by reference.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">BACKGROUND</heading><p id="p-0003" num="0002">A multi-threaded processor may fetch the instructions belonging to a thread and execute them. While executing instructions for a thread, the processor may execute an instruction that refers to a register or a memory location. Because of the delay associated with the access to the referenced memory location, the processor may have to wait until the referenced memory location is accessed. Similarly, if an instruction takes multiple cycles to execute, a subsequent instruction that depends on it will have to wait. In order to maintain efficiency, the processor may fetch instructions from a different thread and start executing them. This way, the processor may execute instructions more efficiently. This type of parallelism may be referred to as thread level parallelism. Another way to improve the processors performance is the use of instruction level parallelism.</p><p id="p-0004" num="0003">Instruction level parallelism may include determining the dependences of the instructions in a thread and issuing the instructions that are independent. The processor may speculatively try to predict dependences and execute the instructions in the thread based on that. Such predictions may turn out to be inaccurate and the processor may have to recover from the mispredicted branch, including having to discard the results of the incorrectly predicted dependences of the instructions, and re-execute the instructions in the correct order. The recovery from the mispredicted branch may be suboptimal.</p><heading id="h-0003" level="1">SUMMARY</heading><p id="p-0005" num="0004">In one example, the present disclosure relates to a processor including a pipeline comprising a first plurality of stages corresponding to a frontend of the pipeline and a second plurality of stages corresponding to a backend of the pipeline. The processor may further include a state table for maintaining information related to at least a subset of branches corresponding to instructions being processed by the processor. The processor may further include state logic configured to access the state table. The state logic may further be configured to track locations of any exact convergence points associated with at least a subset of branches corresponding to the instructions being processed by the processor. The state logic may further be configured to identify a first recovery method for recovering from a misprediction associated with a branch from at least the subset of branches if a location of an exact convergence point associated with the branch from at least the subset of branches is determined to be in the frontend of the pipeline, else identify a second recovery method, different from the first recovery method, for recovering from the misprediction associated with the branch.</p><p id="p-0006" num="0005">In another example, the present disclosure relates to a method for operating a processor including a pipeline comprising a first plurality of stages corresponding to a frontend of the pipeline and a second plurality of stages corresponding to a backend of the pipeline. The method may include tracking locations of any exact convergence points associated with at least a subset of branches corresponding to instructions being processed using the processor. The method may further include identifying a first recovery method for recovering from a misprediction associated with a branch from at least the subset of branches if a location of an exact convergence point associated with the branch is determined to be in the frontend of the pipeline, else identifying a second recovery method, different from the first recovery method, for recovering from the misprediction associated with the branch.</p><p id="p-0007" num="0006">In yet another example, the present disclosure relates to a method for operating a processor including a pipeline comprising a first plurality of stages corresponding to a frontend of the pipeline and a second plurality of stages corresponding to a backend of the pipeline. The method may include tracking locations of any exact convergence points associated with at least a subset of branches corresponding to instructions being processed using the processor. The method may further include maintaining a state table comprising information associated with at least the subset of branches corresponding to the instructions being processed using the processor. The method may further include based on the tracking and the information in the state table, identifying a first recovery method for recovering from a misprediction associated with a branch from at least the subset of branches if a location of an exact convergence point associated with the branch is determined to be in the frontend of the pipeline, else identifying a second recovery method, different from the first recovery method, for recovering from the misprediction associated with the branch.</p><p id="p-0008" num="0007">This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0009" num="0008">The present disclosure is illustrated by way of example and is not limited by the accompanying figures, in which like references indicate similar elements. Elements in the figures are illustrated for simplicity and clarity and have not necessarily been drawn to scale.</p><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a diagram of a processor including the tracking of exact convergence branches to guide the recovery process from a misprediction by a branch predictor in accordance with one example;</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a block diagram of immunity table logic associated with the processor of <figref idref="DRAWINGS">FIG. <b>1</b></figref> in accordance with one example;</p><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>3</b></figref> shows an example state table for use with the immunity table logic of <figref idref="DRAWINGS">FIG. <b>2</b></figref> in accordance with one example;</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a block diagram of immunity table logic associated with processor <b>100</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref> in accordance with one example;</p><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a block diagram of immunity table logic associated with processor <b>100</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref> in accordance with another example;</p><p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a flow chart of a method for operating a processor including a pipeline comprising a first plurality of stages corresponding to a frontend of the pipeline and a second plurality of stages corresponding to a backend of the pipeline in accordance with one example; and</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a flow chart of another method for operating a processor including a pipeline comprising a first plurality of stages corresponding to a frontend of the pipeline and a second plurality of stages corresponding to a backend of the pipeline.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0005" level="1">DETAILED DESCRIPTION</heading><p id="p-0017" num="0016">Examples described in this disclosure relate to tracking exact convergence to guide the recovery process in response to a mispredicted branch. Exact convergence may occur when the mispredicted path converges at the very beginning of the correct path. As noted earlier, instruction level parallelism in a processor may include determining the dependences of the instructions in a thread and issuing the instructions that are independent. The processor may speculatively try to predict dependences and execute the instructions in the thread based on that. Such predictions may turn out to be inaccurate resulting in the processor having to discard the results of the incorrectly predicted dependences of the instructions and re-execute the instructions in the correct order. Branch mispredictions are very expensive in terms of the performance penalty. One way to lower the misprediction penalty is to use control independence.</p><p id="p-0018" num="0017">Control independence refers to the region of code that executes regardless of a branch's direction (e.g., the region of code that is independent of the control decision associated with the branch). The region of the code that is executed based on the branch's control outcome is referred to as the control dependent (CD) region. Control independent (CI) instructions can be further classified based on their data dependence on the control dependent region. If a control independent (CI) instruction is dependent on data modified by the control dependent (CD) region, then it may be referred to as a control independent data dependent (CIDD) instruction, otherwise, it may be referred to as a control independent data independent (CIDI) instruction.</p><p id="p-0019" num="0018">If a qualified branch is predicted by the branch predictor as Taken, then the alternate target is the fall-through address (address of the next instruction if the branch were Not-Taken). If the qualified branch is predicted by the branch predictor as Not-Taken, then the alternate target is the branch target address (address of the next instruction if the branch were to be Taken). A qualified branch establishes apparatus to search for the alternate target in the instruction stream. There can be any number and types of dynamic instructions before the alternate target is found in the instruction stream. For example, this could be a simple single-sided hammock or a double-sided hammock where a future iteration of the branch was predicted in a different way. A single-sided hammock may correspond to an &#x201c;if-then&#x201d; idiom and a double-sided hammock may correspond to an &#x201c;if-then-else&#x201d; idiom. Alternatively, the branch may be a non-hammock type structure that just happened to get the alternate target in the fetch stream. The alternate target, however, may still need to be found before the qualified branch resolves in order to optimize the recovery process of a qualified branch if it mispredicts.</p><p id="p-0020" num="0019">In the present disclosure, as part of the misprediction resolution, a processor may use any of three types of recovery methods: (1) Conventional Flush Recovery, (2) Full-Pipeline Selective Recovery, or (3) Frontend Selective Recovery. As part of the Conventional Flush Recovery, all of the instructions younger than the mispredicted branch may be flushed from the pipeline of the processor, and the instruction fetch logic may be redirected to fetch the instructions corresponding to the correct path. One example of Full-Pipeline Selective Recovery is the selective branch recovery (SBR). As part of the SBR, the incorrect control dependent (CD) path may be replayed as predicate-fail instructions (with the destination registers getting their previously mapped values) to repair the dependence chain. Additionally, all the control independent data dependent (CIDD) instructions may be replayed by reinserting them into the instruction scheduler. One example of the Frontend Selective Recovery is selective pipeline flush (SPF). In one example, the SPF is similar to the SBR, but the exact convergence point is limited to the frontend of the pipeline of the processor to simplify the recovery hardware by using conventional flush recovery to clear out the backend and to repair the pipeline.</p><p id="p-0021" num="0020">In the present disclosure, techniques and structures are described that identify when the Full-Pipeline Selective Recovery is likely to hurt the processors performance and both track and guide the recovery process. It is observed that the Full-Pipeline Selective Recovery hurts the processor's performance when no control independent (CI) instructions are fetched into the backend of the pipeline of the processor. Tracking the exact convergence point to be either in the frontend of the pipeline or the backend of the pipeline of the processor can indicate if the Full-Pipeline Selective Recovery is likely to hurt performance. Performance can also be hurt because the control dependent (CD) instructions themselves have not very likely executed yet and are unlikely to be immediately ready for execution. This can also delay the execution of a critical program path leading to performance loss. If the exact convergence point is found in the frontend of the pipeline, indicating that there are no control independent (CI) instructions in the backend of the pipeline, then the Frontend Selective Recovery is used to recover from a pipeline flush. In this manner, instead of in the Conventional Flush Recovery, the correct path instructions are supplied quicker, just like the Full-Pipeline Selective Recovery. In this scenario, however, unlike the Full-Pipeline Selective Recovery, the Frontend Selective Recovery discards the overhead of the control dependent (CD) instructions as they are not useful.</p><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a diagram of a processor <b>100</b> including the tracking of exact convergence branches to guide the recovery process from a misprediction by a branch predictor in accordance with one example. Functional blocks corresponding to processor <b>100</b> may be implemented as part of an integrated circuit. Processor <b>100</b> may include a pipeline for processing instructions, including a frontend <b>110</b> and a backend <b>150</b>. As used herein the term &#x201c;frontend&#x201d; includes, but is not limited to, one or more stages of the instruction processing pipeline of a processor that are arranged towards the fetch side of the instruction processing pipeline of the processor. In this example, frontend <b>110</b> of the pipeline for processor <b>100</b> may include an instruction cache <b>112</b>, a decoder <b>114</b>, and micro-ops morphing logic <b>116</b>. As another example, any pipeline stages before rename/allocation logic <b>140</b> may be considered as part of frontend <b>110</b>. As used herein the term &#x201c;backend&#x201d; includes, but is not limited to, one or more stages of the instruction processing pipeline of the processor that are arranged towards the execution units side of the instruction processing pipeline of the processor. In this example, backend <b>150</b> of the pipeline for processor <b>100</b> may include an instruction scheduler <b>154</b>, a register file <b>156</b>, and execution units <b>158</b>. As another example, any pipeline stages after rename/allocation logic <b>140</b> may be considered as part of backend <b>150</b>. Processor <b>100</b> may further include a memory <b>170</b>, which may include one or more levels of caches. Processor <b>100</b> may further include a branch predictor <b>118</b>, a branch qualifier <b>120</b>, immunity table logic <b>122</b>, commit/flush logic <b>124</b>, and a reorder buffer <b>160</b>.</p><p id="p-0023" num="0022">With continued reference to <figref idref="DRAWINGS">FIG. <b>1</b></figref>, in this example, as part of the processing of the instructions in frontend <b>110</b>, instructions stored in instruction cache <b>112</b> may be decoded using decoder <b>114</b>. In one example, instructions predicted by branch predictor <b>118</b> may also be decoded by decoder <b>114</b>. After decoding, micro-ops morphing logic <b>116</b> may convert the decoded instructions when needed into micro-ops based on the specific architecture associated with processor <b>100</b>. In addition, micro-ops morphing logic <b>116</b> may modify the instructions to add any needed tracking information that may be required to facilitate the replaying of the instructions.</p><p id="p-0024" num="0023">Branch predictor <b>118</b> may be used to address some of the limitations of the instruction level parallelism. As an example, branch predictor <b>118</b> may speculatively predict the direction of a branch (e.g., an if-then-else type of branch). In this example, exact convergence tracking is accomplished by branch qualifier <b>120</b> and immunity table logic <b>122</b>. Exact convergence may occur when the mispredicted path converges at the very beginning of the correct path. As a result of the exact convergence, there may be no control dependent (CD) instructions that may be required to be re-inserted into the instruction pipeline. Branch qualifier <b>120</b> may determine if a branch is eligible for optimization based on the branch's static or dynamic characteristics, branch prediction confidence, or a compound metric. If branch qualifier <b>120</b> determines that the branch is eligible for optimization, then it may be considered a qualified branch. An entry for the qualified branch may be established in a state table (described in more detail later) associated with immunity table logic <b>122</b>. In this way the exact convergence point of the qualified branch may be tracked and other related characteristics of the qualified branch may be recorded. In this example, once the exact convergence of a qualified branch is detected, the corresponding entry for the branch in the state table may be updated to reflect the optimized nature of the qualified branch. The update from the qualified branch to the optimized branch is based on the location of the exact convergence point of the branch instruction within the pipeline of the processor. Thus, if the exact convergence point of the branch instruction is located in frontend <b>110</b>, then the qualified branch is updated as an optimized branch. The optimized branch may then be subject to a first type of recovery method unless the optimized branch is upgraded. As an example the upgrade may be based on the location of the exact convergence point moving into backend <b>150</b>. Other metrics may also be used to determine when to upgrade the optimized branch. As an example, the upgrade may be based on the tracking of the execution of the instructions in the exact convergence path. As another example, the upgrade may be based on when the instruction execution passes a certain stage (e.g., rename/allocation logic <b>140</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>) in the pipeline associated with the processor. Any of the aforementioned metrics may be used alone or combined in any manner to determine when to upgrade the optimized branch. The upgrade may result in the upgraded branch being subject to a second type of recovery method, different from the first type of recovery method.</p><p id="p-0025" num="0024">Still referring to <figref idref="DRAWINGS">FIG. <b>1</b></figref>, as part of the processing of the instructions in backend <b>150</b> of the pipeline, rename/allocation logic <b>140</b> may annotate the instructions with bit-vectors (e.g., ready bit-vectors) to indicate the control dependent (CD) or the control independent data dependent (CIDD) nature of an instruction in any of the in-flight qualified branches. Instruction scheduler <b>154</b> may schedule instructions for further processing using execution units <b>158</b>. Operands or other data may be accessed by execution units <b>158</b> from register file <b>154</b>. The results of the processing by execution units <b>158</b> may be stored in register file <b>154</b> or memory <b>170</b>. The replay logic, included as part of instruction scheduler <b>154</b>, may track the start point and the end point of the control dependent (CD) region for each qualified branch. The replay logic may be configured to manage the captured instructions based on at least three possible scenarios. The first scenario may include multiple qualified exact convergence branches in flight that resolve in out-of-order fashion. The second scenario may include a qualified mispredicted exact convergence branch that is not optimized. The third scenario may include a situation in which a qualified exact convergence branch did not mispredict. The instruction replay logic may track and store all the control dependent (CD) and control independent data dependent (CIDD) instructions of the qualified branches as they are allocated into the instruction scheduler. In this example, when a branch resolves, the outcome may be communicated to the replay logic and commit/flush logic <b>124</b>. If the branch mispredicts, the commit/flush logic <b>124</b> may consult the state table (described in more detail later) to determine if the mispredicted branch is optimized to initiate the appropriate exact convergence recovery.</p><p id="p-0026" num="0025">With continued reference to <figref idref="DRAWINGS">FIG. <b>1</b></figref>, immunity table logic <b>122</b> could also recommend different recovery flavors depending on the dynamic control path characteristics of the pipeline. In this example, commit/flush logic <b>124</b> may communicate the recovery method and the related information to the replay logic (e.g., included as part of instruction scheduler <b>154</b>) to initiate the exact convergence branch replay if needed. The allocated entries for the qualified branch in the replay logic and the immunity table may be reclaimed if the resolving branch is the oldest qualified branch. Table 1 below shows the three recovery methods that could be used to recover from the branch misprediction.</p><p id="p-0027" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="56pt" align="center"/><colspec colname="2" colwidth="70pt" align="center"/><colspec colname="3" colwidth="77pt" align="center"/><colspec colname="4" colwidth="63pt" align="center"/><thead><row><entry namest="1" nameend="4" rowsep="1">TABLE 1</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row><row><entry/><entry>Frontend</entry><entry>Backend</entry><entry>Instruction Fetch</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>Conventional</entry><entry>Flush</entry><entry>Flush</entry><entry>Redirect</entry></row><row><entry>Flush Recovery</entry><entry/><entry/><entry/></row><row><entry>Frontend</entry><entry>Range Flush</entry><entry>Flush</entry><entry>No Redirect</entry></row><row><entry>Selective</entry><entry/><entry/><entry/></row><row><entry>Recovery</entry><entry/><entry/><entry/></row><row><entry>Full-Pipeline</entry><entry>No Flush; Dynamic</entry><entry>Range Flush; Replay</entry><entry>No Redirect</entry></row><row><entry>Selective</entry><entry>Predicate-Fail of the</entry><entry>Control Dependent</entry><entry/></row><row><entry>Recovery</entry><entry>Control Dependent</entry><entry>(CD) Instructions,</entry><entry/></row><row><entry/><entry>(CD) Instructions in</entry><entry>Control Independent</entry><entry/></row><row><entry/><entry>the Frontend</entry><entry>Data Dependent</entry><entry/></row><row><entry/><entry/><entry>(CIDD) Instructions,</entry><entry/></row><row><entry/><entry/><entry>and Any Unissued</entry><entry/></row><row><entry/><entry/><entry>Control Independent</entry><entry/></row><row><entry/><entry/><entry>(CI) Instructions</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0028" num="0026">In one example, as part of the Conventional Flush Recovery, all the instructions younger than the mispredicted branch may be flushed from the pipeline of the processor, and the instruction fetch logic (not shown) may be redirected to fetch the instructions corresponding to the correct path. One example of the Full-Pipeline Selective Recovery is the Selective Branch Recovery (SBR). As part of the SBR, the incorrect control dependent (CD) path may be replayed as predicate-fail instructions (with the destination registers getting their previously mapped values) to repair the dependence chain. Additionally, all the control independent data dependent (CIDD) instructions may be replayed by reinserting them into the instruction scheduler. One example of the Frontend Selective Recovery is Selective Pipeline Flush (SPF). In one example, the SPF is similar to the SBR, but the exact convergence point is limited to the frontend of the processor (e.g., frontend <b>120</b>). This may simplify the recovery hardware by using conventional flush recovery to clear out the backend and to repair the pipeline. Although <figref idref="DRAWINGS">FIG. <b>1</b></figref> shows a certain number of components of processor <b>100</b> arranged in a certain manner, there could be more or fewer number of components arranged differently.</p><p id="p-0029" num="0027"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a block diagram of immunity table logic <b>200</b> associated with processor <b>100</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref> in accordance with one example. In this example, immunity table logic <b>200</b> may be used to implement immunity table logic <b>122</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. Since the exact convergence of a branch is opportunistic and depends on the future stream of instructions, in this example, a hardware structure is needed to track the state of qualified branches. A qualified branch may not be optimized due to a variety of reasons based on the exact convergence optimization (e.g., the alternate target of a qualified branch is not fetched before the branch resolves). Immunity table logic <b>200</b>, which corresponds to immunity table logic <b>122</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, may be used to track the qualified branches.</p><p id="p-0030" num="0028">Immunity table logic <b>200</b> may include a STATE TABLE <b>210</b> and TRACKERS <b>250</b>. A qualified branch may be allocated an entry in STATE TABLE <b>210</b> if there is no contention. State table <b>210</b> may receive each branches' program counter (BRPC) and if available the exact convergence program counter (ECPC) from branch qualifier <b>120</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. Immunity table logic <b>200</b> may receive a flush signal (FLUSH) from commit/flush logic <b>124</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. State table <b>210</b> may receive a flush query (FLUSH QUERY) from commit/flush logic <b>124</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. State table <b>210</b> may further receive an upgrade signal (UPGRADE), which is described in more detail later. State table <b>210</b> may setup a trackers (SET UP EC TRACKING). TRACKERS <b>250</b> may further provide an update signal (UPDATE) to STATE TABLE <b>210</b> and also may provide the TABLE INDEX corresponding to the table entry. In one example, a tracker may be associated with a respective entry in STATE TABLE <b>210</b>. Efficiency may be improved by sharing trackers between multiple entries of STATE TABLE <b>210</b>, as trackers are only needed until the exact convergence point is detected.</p><p id="p-0031" num="0029">With continued reference to <figref idref="DRAWINGS">FIG. <b>2</b></figref>, immunity table logic <b>200</b> may track all qualified branches for their exact convergence occurrence and the characteristics of the exact convergence. All qualified branches may get an entry in STATE TABLE <b>210</b>, and capture the expected instruction address for exact convergence. One example implementation can be allocating the entries in STATE TABLE <b>210</b> in a FIFO order, where the oldest entry is overwritten. An elaborate approach may be to use the dynamic branch characteristics to affect the replacement policy of the state table entries. If all the entries are occupied by qualified branches, the new qualified branch could simply be disqualified instead of forcing an eviction of the existing older branches.</p><p id="p-0032" num="0030">Still referring to <figref idref="DRAWINGS">FIG. <b>2</b></figref>, TRACKERS <b>250</b> may be fed a stream of fetched instruction addresses (FETCH PC STREAM) to detect the exact convergence point of the corresponding branch assuming the branch ultimately ends having an exact convergence point. Immunity table logic <b>200</b> is implemented to mark the branch optimized as long as there is one dynamic instance of the alternate target in the fetch stages of the pipeline (e.g., frontend <b>110</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>). In one example, this requires continuous tracking of a qualified branch till resolution as the corresponding optimized state can toggle multiple times depending on the location and occurrence of the alternate target. When a qualified branch resolves, frontend flush and fetch redirection are avoided only if the alternate target is found in the frontend of the pipeline, as indicated by a corresponding entry in STATE TABLE <b>210</b>. A variation of this could be to track the instruction program counters at different pipeline stages&#x2014;for example, the decode or the rename/allocation stages. Once the exact convergence of a branch is found, the corresponding branch entry in STATE TABLE <b>210</b> may be marked as optimized.</p><p id="p-0033" num="0031"><figref idref="DRAWINGS">FIG. <b>3</b></figref> shows an example STATE TABLE <b>300</b> for use with immunity table logic <b>200</b>. STATE TABLE <b>300</b> (corresponding to STATE TABLE <b>210</b>) may include several columns, including BR AGE <b>310</b>, EC AGE <b>320</b>, ECPC <b>330</b>, INFO <b>340</b>, OPT <b>350</b>, and VAL <b>360</b>. BR AGE <b>310</b> column may be used to capture the age of the branch. The age of the branch may be captured by incrementing the age of the branch every time an instruction is fetched by processor <b>100</b> for processing as part of the pipeline. The branch age may be managed using wraparound structures to optimize the number of bits needed to keep track of the branch age. EC AGE <b>320</b> column may correspond to the exact convergence point age. The branch age (e.g., stored in BR AGE <b>310</b> column) and the exact convergence age (e.g., stored in EC AGE <b>320</b> column) may be used to maintain the live entries of the STATE TABLE <b>300</b> in case of pipeline flushes. The branch age may also be used during lookup to verify that the entry corresponds to the mispredicted branch. When a branch comes in, immunity table logic <b>200</b> checks the branch's age and the exact convergence program counter (ECPC), which represents the alternate target for the branch instruction. If the branch is predicted as not taken, then immunity table logic <b>200</b> sets up a tracker (e.g., as part of TRACKERS <b>250</b>) to track the exact convergence point for the associated qualified branch and update the corresponding state table entry when the exact convergence is found. Only the oldest resolved qualified branches may release their entries to enable nested exact convergence recovery. TRACKERS <b>250</b> may compare the program counters being received via the FETCH PC STREAM with the exact convergence program counter (ECPC). If there is a match between the exact convergence program counter (ECPC) and a program counter received via the FETCH PC STREAM, immunity table logic <b>200</b> may update (UPDATE) the corresponding STATE TABLE <b>210</b> entry to indicate that the branch is now a qualified branch. When a qualified branch mispredicts, the immunity table index and its age (e.g., BR AGE <b>310</b>) are sent to the commit/flush logic <b>124</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. Commit/flush logic <b>124</b> may use the index and the branch age to consult STATE TABLE <b>210</b> for guidance. Immunity table logic <b>200</b> may then access the corresponding entry and match the branch age to determine if the entry belongs to the mispredicted branch. If the entry does belong to the mispredicted branch, then immunity table logic <b>200</b> determines whether the branch is optimized. And if the branch is optimized, immunity table logic <b>200</b> determines the level of optimization to use (e.g., the Full-Pipeline Selective Recovery or the Frontend Selective Recovery). If immunity table logic <b>200</b> indicates that the mispredicted branch was not found in the STATE TABLE <b>210</b> or that it was not optimized, then commit/flush logic <b>124</b> may raise a full-pipeline flush recovery.</p><p id="p-0034" num="0032">One implementation of trackers <b>250</b> may include the arrangement of comparators and multiplexers shown in <figref idref="DRAWINGS">FIG. <b>2</b></figref> to detect the matches between the exact convergence program counters (ECPCs) and the program counters (labeled as FETCH PC) being received via the FETCH PC STREAM. Comparator <b>252</b> may compare ECPC-<b>0</b> with the program counters, comparator <b>254</b> may compare ECPC-<b>1</b> with the program counters, comparator <b>256</b> may compare ECPC-<b>2</b> with the program counters, and comparator <b>258</b> may compare ECPC-<b>3</b> with the program counters. Each of the comparators may be coupled to multiplexers (e.g., multiplexers <b>262</b>, <b>264</b>, <b>266</b>, and <b>268</b>), as shown in <figref idref="DRAWINGS">FIG. <b>2</b></figref>. Depending on the comparison's result, each of the multiplexers may provide outputs <b>1</b>, <b>2</b>, <b>3</b>, and <b>4</b>. Table 2 below shows example outputs <b>1</b>, <b>2</b>, <b>3</b>, and <b>4</b> depending on whether there is a match or not. Thus, assuming the comparison performed by comparator <b>252</b> results in a match, then multiplexer <b>262</b> may output signal <b>1</b> that results in the state table <b>210</b> entries updated as: Optimize Entry #<b>0</b>, Update EC AGE. Output signals <b>2</b> and <b>3</b> indicate no match, and thus no entries of state table <b>210</b> may be updated. On the other hand, assuming the comparison performed by comparator <b>258</b> results in another match, then multiplexer <b>268</b> may output signal <b>4</b> that results in the state table <b>210</b> entries updated as: Optimize Entry #<b>0</b>, Update EC AGE, Release Entry. Thus, as part of this match, not only the state table entries may be updated but the entry may be released for future use.</p><p id="p-0035" num="0000"><tables id="TABLE-US-00002" num="00002"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="42pt" align="center"/><colspec colname="2" colwidth="175pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 2</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>Output</entry><entry>Description</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="42pt" align="char" char="."/><colspec colname="2" colwidth="175pt" align="left"/><tbody valign="top"><row><entry>1</entry><entry>Match! Optimize Entry #0, Update EC AGE</entry></row><row><entry>2</entry><entry>No Match!</entry></row><row><entry>3</entry><entry>No Match!</entry></row><row><entry>4</entry><entry>Match! Optimize Entry #0, Update EC AGE, Release Entry</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0036" num="0033">With continued reference to <figref idref="DRAWINGS">FIG. <b>2</b></figref>, once the exact convergence point is found, TRACKERS <b>250</b> may update OPT <b>350</b> column to indicate the optimized nature of the branch. Entries stored as part of VAL <b>340</b> column may indicate that the table entry is occupied by a qualified branch, and when the exact convergence point is found by TRACKERS <b>250</b> in the FETCH PC STREAM, TRACKERS <b>250</b> may update the corresponding entry in VAL <b>340</b> column. When the qualified branch is optimized, the appropriate entry in OPT <b>350</b> column may be set, and the exact convergence age may be captured in EC AGE <b>320</b> column. INFO <b>340</b> column may be used to store information, such as the exact convergence path length, and other branch characteristics, including the branch criticality and the prediction confidence.</p><p id="p-0037" num="0034">In addition, if a branch mispredicts, then the immunity table index and its age (e.g., BR AGE <b>310</b>) are sent to the commit/flush logic <b>124</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>. Commit/flush logic <b>124</b> may issue a FLUSH QUERY to look up STATE TABLE <b>210</b> (STATE TABLE <b>300</b> shows the details of an example STATE TABLE <b>210</b>). Using the FLUSH QUERY, commit/flush logic <b>124</b> may use the index and the branch age to consult STATE TABLE <b>210</b> for guidance. Immunity table logic <b>200</b> may then access the corresponding entry and match the branch age to determine if the entry belongs to the mispredicted branch. If the entry does belong to the mispredicted branch, then immunity table logic <b>200</b> determines whether the branch is optimized. And if the branch is optimized, immunity table logic <b>200</b> may determine the level of optimization to use (e.g., the Full-pipeline Selective Recovery or the Frontend Selective Recovery). In addition, in response to the FLUSH QUERY, immunity table logic <b>200</b> may provide IMMUNITY INFORMATION stored as part of STATE TABLE <b>210</b>, including the information stored as part of INFO <b>340</b> column. The type of recovery that is performed may be based on the UPGRADE signal provided to STATE TABLE <b>210</b>. The UPGRADE signal may act as a proxy for a pipeline location of the exact convergence instruction. If immunity table logic <b>200</b> indicates that the mispredicted branch was not found in the STATE TABLE <b>210</b> or that it was ot optimized, then commit/flush logic <b>124</b> may raise a full-pipeline flush recovery.</p><p id="p-0038" num="0035">On a pipeline flush, a pipeline flush request is raised to the commit/flush logic <b>124</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, which may prioritize flushes from multiple sources to conduct appropriate pipeline recovery. In addition, on a pipeline flush, all entries in STATE TABLE <b>210</b> with qualified branches younger (based on EC AGE <b>320</b>) than the flush may be freed. If there are older qualified branches with the exact convergence age (e.g., stored as part of EC AGE <b>320</b> column) younger than the flush, their corresponding optimized entries (OPT <b>350</b> column) may also be cleared, and the freed entries may be set up to track the instruction fetch stream to be optimized again. In addition, new trackers may be set up. Like an unqualified branch, a qualified branch will raise a pipeline flush request upon its misprediction resolution. In addition, the qualified branch will also send a valid assigned TABLE INDEX upon its misprediction resolution. Although <figref idref="DRAWINGS">FIG. <b>2</b></figref> shows a certain number of components of immunity table logic <b>200</b> arranged in a certain manner, there could be more or fewer number of components arranged differently. As an example, although <figref idref="DRAWINGS">FIG. <b>2</b></figref> shows separate STATE TABLE <b>210</b> and TRACKERS <b>250</b>, they could be combined to realize similar functionality as described earlier. As another example, although <figref idref="DRAWINGS">FIG. <b>2</b></figref> shows a certain number and a certain arrangement of comparators and multiplexers as part of TRACKERS <b>250</b>, additional or fewer comparators and multiplexers, arranged differently, may also be used. In addition, although <figref idref="DRAWINGS">FIG. <b>3</b></figref> shows STATE TABLE <b>300</b> as including certain columns, STATE TABLE <b>300</b> may include additional or fewer columns.</p><p id="p-0039" num="0036"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a block diagram of immunity table logic <b>400</b> associated with processor <b>100</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref> in accordance with one example. Immunity table logic <b>400</b> has similar components as described earlier with respect to immunity table logic <b>200</b>. Immunity table logic <b>400</b>, however, is modified to allow for the generation of the upgrade (UPGRADE) signal. The type of recovery that is performed may be based on the upgrade (UPGRADE) signal provided to STATE TABLE <b>410</b>. The upgrade (UPGRADE) signal may act as a proxy for a pipeline location of the exact convergence instruction. As part of immunity table logic <b>400</b>, two separate sets of trackers are set up for the frontend and the backend instructions. A tracker associated with the frontend exact convergence trackers (FE EC TRACKERS <b>430</b>) may detect the exact convergence of a branch in a similar manner as explained earlier with respect to TRACKERS <b>250</b> of <figref idref="DRAWINGS">FIG. <b>2</b></figref>. Apart from setting a value of an entry in OPT <b>350</b> column, the tracker associated with FE EC TRACKERS <b>430</b> may also transmit a signal to one of the trackers associated with the backend exact convergence trackers (BE EC TRACKERS <b>450</b>) to start detecting when the exact convergence instruction enters the backend pipeline of the processor (e.g., backend <b>150</b>). As the exact convergence instruction enters the backend, the corresponding branch entry in STATE TABLE <b>410</b> is upgraded, via the UPGRADE signal output by the tracker associated with BE EC TRACKERS <b>450</b>, to indicate that the optimized mispredicted branch now qualifies for the Full-Pipeline Selective Recovery, and not just the Frontend Selective Recovery. BE EC TRACKERS <b>450</b> may compare the program counters being received via the ALLOC PC STREAM with the exact convergence program counter (ECPC). If there is a match between the exact convergence program counter (ECPC) and a program counter received via the ALLOC PC STREAM, immunity table logic <b>400</b> may update (UPDATE) the corresponding STATE TABLE <b>410</b> entry. In addition, immunity table logic <b>400</b> may send a valid assigned table index (TABLE INDEX) to commit/flush logic <b>124</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref> in a similar manner as described earlier with respect to immunity table logic <b>200</b>.</p><p id="p-0040" num="0037">One implementation of FE EC TRACKERS <b>430</b> may include a similar arrangement of comparators and multiplexers as shown in <figref idref="DRAWINGS">FIG. <b>2</b></figref> to detect the matches between the exact convergence program counters (ECPCs) and the program counters (labeled as FETCH PC) being received via the FETCH PC STREAM. Comparator <b>432</b> may compare ECPC-<b>0</b> with the program counters, comparator <b>434</b> may compare ECPC-<b>1</b> with the program counters, comparator <b>436</b> may compare ECPC-<b>2</b> with the program counters, and comparator <b>438</b> may compare ECPC-<b>3</b> with the program counters. Each of the comparators may be coupled to multiplexers (e.g., multiplexers <b>442</b>, <b>444</b>, <b>446</b>, and <b>448</b>). Depending on the comparison's result, each of the multiplexers may provide outputs <b>1</b>, <b>2</b>, <b>3</b>, and <b>4</b>. Table 3 below shows example outputs <b>1</b>, <b>2</b>, <b>3</b>, and <b>4</b> depending on whether there is a match or not. Thus, assuming the comparison performed by comparator <b>432</b> results in a match, then multiplexer <b>442</b> may output signal <b>1</b> that results in the state table <b>410</b> entries updated as: Optimize Entry #<b>0</b>, Update EC AGE. Output signals <b>2</b> and <b>3</b> indicate no match, and thus no entries of state table <b>410</b> may be updated. On the other hand, assuming the comparison performed by comparator <b>438</b> results in another match, then multiplexer <b>448</b> may output signal <b>4</b> that results in the state table <b>410</b> entries updated as: Optimize Entry #<b>0</b>, Update EC AGE, Release Entry. Thus, as part of this match, not only the state table entries may be updated but the entry may be released for future use.</p><p id="p-0041" num="0000"><tables id="TABLE-US-00003" num="00003"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="42pt" align="center"/><colspec colname="2" colwidth="175pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 3</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>Output</entry><entry>Description</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="42pt" align="char" char="."/><colspec colname="2" colwidth="175pt" align="left"/><tbody valign="top"><row><entry>1</entry><entry>Match! Optimize Entry #0, Update EC AGE</entry></row><row><entry>2</entry><entry>No Match!</entry></row><row><entry>3</entry><entry>No Match!</entry></row><row><entry>4</entry><entry>Match! Optimize Entry #0, Update EC AGE, Release Entry</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0042" num="0038">Still referring to <figref idref="DRAWINGS">FIG. <b>4</b></figref>, one implementation of BE EC TRACKERS <b>450</b> may include an arrangement of comparators to detect the matches between the exact convergence program counters (ECPCs) and the program counters (labeled as ALLOC PC) being received via the ALLOC PC STREAM. Comparator <b>452</b> may compare ECPC-<b>0</b> with the program counters, comparator <b>454</b> may compare ECPC-<b>1</b> with the program counters, comparator <b>456</b> may compare ECPC-<b>2</b> with the program counters, and comparator <b>458</b> may compare ECPC-<b>3</b> with the program counters. If there is a match, then the corresponding output signal (<b>1</b>, <b>2</b>, <b>3</b>, or <b>4</b>) may be the upgrade (UPGRADE) signal to state table <b>410</b>.</p><p id="p-0043" num="0039">With continued reference to <figref idref="DRAWINGS">FIG. <b>4</b></figref>, commit/flush logic <b>124</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref> may receive the pipeline flush request. In this example, based on the IMMUNITY INFORMATION received from STATE TABLE <b>410</b>, including the upgrade (UPGRADE) information, commit/flush logic <b>124</b> may initiate the Full-Pipeline Selective Recovery. In this example, if the exact convergence instruction is not detected by even the tracker associated with BE EC TRACKERS <b>450</b>, then the Conventional Flush Recovery may be performed. Although <figref idref="DRAWINGS">FIG. <b>4</b></figref> shows a certain number of components of immunity table logic <b>400</b> arranged in a certain manner, there could be more or fewer number of components arranged differently. As an example, although <figref idref="DRAWINGS">FIG. <b>4</b></figref> shows separate STATE TABLE <b>410</b>, FE EC TRACKERS <b>430</b>, and BE EC TRACKERS <b>450</b>, they could be combined to realize similar functionality as described earlier. As another example, although <figref idref="DRAWINGS">FIG. <b>4</b></figref> shows a certain number and a certain arrangement of comparators and multiplexers as part of FE EC TRACKERS <b>430</b> and BE EC TRACKERS <b>450</b>, additional or fewer comparators and multiplexers, arranged differently, may also be used.</p><p id="p-0044" num="0040"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a block diagram of immunity table logic <b>500</b> associated with processor <b>100</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref> in accordance with another example. Immunity table logic <b>500</b> has similar components as described earlier with respect to immunity table logic <b>200</b>. Immunity table logic <b>500</b>, however, is modified to allow for the generation of the upgrade (UPGRADE) signal. The type of recovery that is performed may be based on the upgrade (UPGRADE) signal provided to STATE TABLE <b>510</b>. The upgrade (UPGRADE) signal may act as a proxy for a pipeline location of the exact convergence instruction. In this example, instead of using double the number of trackers as shown as part of immunity table logic <b>400</b>, time tracking may be used to determine which one of the entries in STATE TABLE <b>510</b> should be upgraded such that they are now qualified for the Full-Pipeline Selective Recovery instead of just the Frontend Selective Recovery. A tracker associated with the frontend exact convergence trackers (FE EC TRACKERS <b>530</b>) may detect the exact convergence of a branch in a similar manner as explained earlier with respect to TRACKERS <b>250</b> of FIG, <b>2</b>. If an exact convergence is detected in the frontend of the pipeline, then as described earlier, the tracker associated with FE EC TRACKERS <b>530</b> may update (UPDATE) STATE TABLE <b>510</b>, including the update to an entry in OPT <b>350</b> column.</p><p id="p-0045" num="0041">One implementation of FE EC TRACKERS <b>530</b> may include a similar arrangement of comparators and multiplexers as shown in <figref idref="DRAWINGS">FIG. <b>2</b></figref> to detect the matches between the exact convergence program counters (ECPCs) and the program counters (labeled as FETCH PC) being received via the FETCH PC STREAM. Comparator <b>532</b> may compare ECPC-<b>0</b> with the program counters, comparator <b>534</b> may compare ECPC-<b>1</b> with the program counters, comparator <b>536</b> may compare ECPC-<b>2</b> with the program counters, and comparator <b>538</b> may compare ECPC-<b>3</b> with the program counters. Each of the comparators may be coupled to multiplexers (e.g., multiplexers <b>542</b>, <b>544</b>, <b>546</b>, and <b>548</b>). Depending on the comparison's result, each of the multiplexers may provide outputs <b>1</b>, <b>2</b>, <b>3</b>, and <b>4</b>. Table 4 below shows example outputs <b>1</b>, <b>2</b>, <b>3</b>, and <b>4</b> depending on whether there is a match or not. Thus, assuming the comparison performed by comparator <b>532</b> results in a match, then multiplexer <b>542</b> may output signal <b>1</b> that results in the state table <b>510</b> entries updated as: Optimize Entry #<b>0</b>, Update EC AGE. Output signals <b>2</b> and <b>3</b> indicate no match, and thus no entries of state table <b>510</b> may be updated. On the other hand, assuming the comparison performed by comparator <b>538</b> results in another match, then multiplexer <b>548</b> may output signal <b>4</b> that results in the state table <b>510</b> entries updated as: Optimize Entry #<b>0</b>, Update EC AGE, Release Entry. Thus, as part of this match, not only the state table entries may be updated but the entry may be released for future use.</p><p id="p-0046" num="0000"><tables id="TABLE-US-00004" num="00004"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="42pt" align="center"/><colspec colname="2" colwidth="175pt" align="left"/><thead><row><entry namest="1" nameend="2" rowsep="1">TABLE 4</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>Output</entry><entry>Description</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="42pt" align="char" char="."/><colspec colname="2" colwidth="175pt" align="left"/><tbody valign="top"><row><entry>1</entry><entry>Match! Optimize Entry #0, Update EC AGE</entry></row><row><entry>2</entry><entry>No Match!</entry></row><row><entry>3</entry><entry>No Match!</entry></row><row><entry>4</entry><entry>Match! Optimize Entry #0, Update EC AGE, Release Entry</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0047" num="0042">DELAY LOGIC <b>550</b> may be used to delay the assertion of the upgrade (UPGRADE) signal to STATE TABLE <b>510</b> such that the exact convergence recovery is upgraded to the Full-Pipeline Selective Recovery only if the delay, which may be measured in clock cycles, has met, or passed a certain threshold. The threshold may represent in clock cycles a delay that corresponds to a scenario where the exact convergence no longer will occur in the frontend of the pipeline. In this manner, the exact convergence location (frontend vs. backend) may be estimated. DELAY LOGIC <b>550</b> may be implemented using flipflops to measure the delay in dock cycles.</p><p id="p-0048" num="0043">As part of this process, once the exact convergence location is estimated to be in the backend of the pipeline, the corresponding branch entry in STATE TABLE <b>510</b> is also upgraded, via the UPGRADE signal output by DELAY LOGIC <b>550</b>, to indicate that the optimized mispredicted branch now qualifies for the Full-Pipeline Selective Recovery, and not just the Frontend Selective Recovery, In one example, frontend stall (FE STALL) information may also be used by DELAY LOGIC <b>550</b> to upgrade an optimized branch from the Frontend Selective Recovery to the Full-Pipeline Selective Recovery. As part of this example, only the cycles where none of the frontend pipeline stages are stalled (e.g., as indicated by the FE STALL information) may be measured by DELAY LOGIC <b>550</b>. Other types of delay (e.g., any delay based on some other measurements) may also be used to delay the assertion of the upgrade (UPGRADE) signal to STATE TABLE <b>510</b> such that the exact convergence recovery is upgraded to the Full-Pipeline Selective Recovery.</p><p id="p-0049" num="0044">With continued reference to <figref idref="DRAWINGS">FIG. <b>5</b></figref>, commit/flush logic <b>124</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref> may receive the pipeline flush request. In this example, based on the IMMUNITY INFORMATION received from STATE TABLE <b>510</b>, including the UPGRADE information, commit/flush logic <b>124</b> may initiate the Full-Pipeline Selective Recovery. In this example, if the exact convergence instruction is not detected even by DELAY LOGIC <b>550</b>, then the Conventional Flush Recovery may be performed. Although <figref idref="DRAWINGS">FIG. <b>5</b></figref> shows a certain number of components of immunity table logic <b>500</b> arranged in a certain manner, there could be more or fewer number of components arranged differently. As an example, although <figref idref="DRAWINGS">FIG. <b>5</b></figref> shows a certain number and a certain arrangement of comparators and multiplexers as part of FE EC TRACKERS <b>530</b>, additional or fewer comparators and multiplexers, arranged differently, may also be used.</p><p id="p-0050" num="0045"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a flow chart <b>600</b> of a method for operating a processor including a pipeline comprising a first plurality of stages corresponding to a frontend of the pipeline and a second plurality of stages corresponding to a backend of the pipeline in accordance with one example. As an example, processor <b>100</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, including frontend <b>110</b> and backend <b>150</b> may be operated using the steps associated with this method. Frontend <b>110</b> may include at least decoder <b>114</b> and micro-ops morphing logic <b>116</b>. Backend <b>150</b> may include at least instruction scheduler <b>154</b> and register file <b>156</b>, Step <b>610</b> may include tracking locations of any exact convergence points associated with at least a subset of branches corresponding to instructions being processed using the processor. Any of the trackers described earlier with respect to <figref idref="DRAWINGS">FIGS. <b>2</b>-<b>5</b></figref> may be used to track locations of any exact convergence points.</p><p id="p-0051" num="0046">Step <b>620</b> may include maintaining a state table comprising information associated with a subset of branches corresponding to instructions being processed using the processor. Any of the state tables described earlier with respect to <figref idref="DRAWINGS">FIGS. <b>2</b>-<b>5</b></figref> may be used as part of this step. As an example, this step may include maintaining information in state table <b>300</b> described with respect to <figref idref="DRAWINGS">FIG. <b>3</b></figref>. In addition, immunity table logic <b>124</b>, which is also referred to as the stage logic, may be used to perform this step.</p><p id="p-0052" num="0047">Step <b>630</b> may include, based on the tracking and the information in the state table, identifying a first recovery method for recovering from a misprediction associated with a branch from at least the subset of branches if a location of an exact convergence point associated with the branch is determined to be in the frontend of the pipeline, else identifying a second recovery method, different from the first recovery method, for recovering from the misprediction associated with the branch. Any of the ways described earlier for identifying the first recovery method (e.g., the Frontend Selective Recovery) or the second recovery method (e.g., the Full-Pipeline Selective Recovery) may be used as part of this step. As an example, any of the various implementations of immunity table logic <b>122</b> described earlier in coordination with commit/flush logic <b>124</b> may be used to perform this step.</p><p id="p-0053" num="0048"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a flow chart <b>700</b> of another method for operating a processor including a pipeline comprising a first plurality of stages corresponding to a frontend of the pipeline and a second plurality of stages corresponding to a backend of the pipeline. As an example, processor <b>100</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>, including frontend <b>110</b> and backend <b>150</b> may be operated using the steps associated with this method. Frontend <b>110</b> may include at least decoder <b>114</b> and micro-ops morphing logic <b>116</b>. Backend <b>150</b> may include at least instruction scheduler <b>154</b> and register file <b>156</b>. Step <b>710</b> may include tracking locations of any exact convergence points associated with at least a subset of branches corresponding to instructions being processed using the processor. Any of the trackers described earlier with respect to <figref idref="DRAWINGS">FIGS. <b>2</b>-<b>5</b></figref> may be used to track locations of any exact convergence points.</p><p id="p-0054" num="0049">Step <b>720</b> may include identifying a first recovery method for recovering from a misprediction associated with a branch from at least the subset of branches if a location of an exact convergence point associated with the branch is determined to be in the frontend of the pipeline, else identifying a second recovery method, different from the first recovery method, for recovering from the misprediction associated with the branch, The second recovery method may correspond to the Full-Pipeline Selective Recovery described earlier. Any of the ways described earlier for identifying the first recovery method (e.g., the Frontend Selective Recovery) or the second recovery method (e.g., the Full-Pipeline Selective Recovery) may be used as part of this step. As an example, any of the various implementations of immunity table logic <b>122</b> described earlier in coordination with commit/flush logic <b>124</b> may be used to perform this step.</p><p id="p-0055" num="0050">In conclusion, in one example, the present disclosure relates to a processor including a pipeline comprising a first plurality of stages corresponding to a frontend of the pipeline and a second plurality of stages corresponding to a backend of the pipeline. The processor may further include a state table for maintaining information related to at least a subset of branches corresponding to instructions being processed by the processor. The processor may further include state logic configured to access the state table. The state logic may further be configured to track locations of any exact convergence points associated with at least a subset of branches corresponding to the instructions being processed by the processor. The state logic may further be configured to identify a first recovery method for recovering from a misprediction associated with a branch from at least the subset of branches if a location of an exact convergence point associated with the branch from at least the subset of branches is determined to be in the frontend of the pipeline, else identify a second recovery method, different from the first recovery method, for recovering from the misprediction associated with the branch.</p><p id="p-0056" num="0051">The state logic may include at least one frontend exact convergence tracker and at least one backend exact convergence tracker. The state logic may include at least one frontend exact convergence tracker and at least one frontend delay logic.</p><p id="p-0057" num="0052">The first recovery method may include in response to a mispredicted branch, flushing only those instructions that are in the backend of the pipeline and are younger than the mispredicted branch. The first recovery method may also include in response to a mispredicted branch, selectively flushing only those instructions that are in the frontend of the pipeline and are older than an exact convergence point associated with the mispredicted branch.</p><p id="p-0058" num="0053">The second recovery method may include in response to a mispredicted branch, at least one of: (1) replaying all instructions included in an incorrect control dependent path as predicate-fail instructions and replaying all control independent data dependent instructions, or (2) executing a selected recovery program. The state logic may further be configured to identify a third recovery method, different from the first recovery method and the second recovery method, and the third recovery method may comprise in response to a mispredicted branch, flushing all instructions younger than the mispredicted branch from both the frontend of the pipeline and the backend of the pipeline.</p><p id="p-0059" num="0054">In another example, the present disclosure relates to a method for operating a processor including a pipeline comprising a first plurality of stages corresponding to a frontend of the pipeline and a second plurality of stages corresponding to a backend of the pipeline. The method may include tracking locations of any exact convergence points associated with at least a subset of branches corresponding to instructions being processed using the processor. The method may further include identifying a first recovery method for recovering from a misprediction associated with a branch from at least the subset of branches if a location of an exact convergence point associated with the branch is determined to be in the frontend of the pipeline, else identifying a second recovery method, different from the first recovery method, for recovering from the misprediction associated with the branch.</p><p id="p-0060" num="0055">The tracking locations of any convergence points associated with at least the subset of branches corresponding to the instructions being processed using the pipeline may include using: (1) a state table for maintaining information related to at least the subset of branches corresponding to the instructions being processed by the processor, (2) at least one frontend exact convergence tracker, and (3) at least one backend exact convergence tracker. The tracking locations of any convergence points associated with at least the subset of branches corresponding to the instructions being processed using the pipeline may further comprise using: (1) a state table for maintaining information related to at least the subset of branches corresponding to the instructions being processed by the processor, (2) at least one frontend exact convergence tracker, and (3) at least one frontend delay logic.</p><p id="p-0061" num="0056">The first recovery method may include in response to a mispredicted branch, flushing only those instructions that are in the backend of the pipeline and are younger than the mispredicted branch. The first recovery method may also include in response to a mispredicted branch, selectively flushing only those instructions that are in the frontend of the pipeline and are older than an exact convergence point associated with the mispredicted branch.</p><p id="p-0062" num="0057">The second recovery method may include in response to a mispredicted branch, at least one of: (1) replaying all instructions included in an incorrect control dependent path as predicate-fail instructions and replaying all control independent data dependent instructions, or (2) executing a selected recovery program. The method may further include identifying a third recovery method, different from the first recovery method and the second recovery method, and the third recovery method may comprise in response to a mispredicted branch, flushing all instructions younger than the mispredicted branch from both the frontend of the pipeline and the backend of the pipeline.</p><p id="p-0063" num="0058">In yet another example, the present disclosure relates to a method for operating a processor including a pipeline comprising a first plurality of stages corresponding to a frontend of the pipeline and a second plurality of stages corresponding to a backend of the pipeline. The method may include tracking locations of any exact convergence points associated with at least a subset of branches corresponding to instructions being processed using the processor. The method may further include maintaining a state table comprising information associated with at least the subset of branches corresponding to the instructions being processed using the processor. The method may further include based on the tracking and the information in the state table, identifying a first recovery method for recovering from a misprediction associated with a branch from at least the subset of branches if a location of an exact convergence point associated with the branch is determined to be in the frontend of the pipeline, else identifying a second recovery method, different from the first recovery method, for recovering from the misprediction associated with the branch.</p><p id="p-0064" num="0059">The tracking locations of any convergence points associated with at least the subset of branches corresponding to the instructions being processed using the pipeline may comprise using: (1) at least one frontend exact convergence tracker configured to detect any exact convergence points within the frontend of the pipeline and (2) at least one backend exact convergence tracker configured to detect any exact convergence points within the backend of the pipeline. The tracking locations of any convergence points associated with at least the subset of branches corresponding to the instructions being processed using the pipeline may comprise using: (1) at least one frontend exact convergence tracker configured to detect any exact convergence points within the frontend of the pipeline and (2) at least one frontend delay logic configured to delay an assertion of a signal identifying the second recovery method for recovering from a misprediction associated with a branch.</p><p id="p-0065" num="0060">The first recovery method may include in response to a mispredicted branch, flushing only those instructions that are in the backend of the pipeline and are younger than the mispredicted branch. The second recovery method may include in response to a mispredicted branch, at least one of: (1) replaying all instructions included in an incorrect control dependent path as predicate-fail instructions and replaying all control independent data dependent instructions, or (2) executing a selected recovery program. The method may further include identifying a third recovery method, different from the first recovery method and the second recovery method, and the third recovery method may comprise in response to a mispredicted branch, flushing all instructions younger than the mispredicted branch from both the frontend of the pipeline and the backend of the pipeline.</p><p id="p-0066" num="0061">It is to be understood that the methods, modules, and components depicted herein are merely exemplary. Alternatively, or in addition, the functionality described herein can be performed, at least in part, by one or more hardware logic components. For example, and without limitation, illustrative types of hardware logic components that can be used include Field-Programmable Gate Arrays (FPGAs), Application-Specific Integrated Circuits (ASICs), Application-Specific Standard Products (ASSPs), System-on-a-Chip systems (SOCs) Complex Programmable Logic Devices (CPLDs), etc. In an abstract, but still definite sense, any arrangement of components to achieve the same functionality is effectively &#x201c;associated&#x201d; such that the desired functionality is achieved. Hence, any two components herein combined to achieve a particular functionality can be seen as &#x201c;associated with&#x201d; each other such that the desired functionality is achieved, irrespective of architectures or inter-medial components. Likewise, any two components so associated can also be viewed as being &#x201c;operably connected,&#x201d; or &#x201c;coupled,&#x201d; to each other to achieve the desired functionality. Merely because a component, which may be an apparatus, a structure, a system, or any other implementation of a functionality, is described herein as being coupled to another component does not mean that the components are necessarily separate components. As an example, a component A described as being coupled to another component B may be a sub-component of the component B, or the component B may be a sub-component of the component A.</p><p id="p-0067" num="0062">The functionality associated with some examples described in this disclosure can also include instructions stored in a non-transitory media. The term &#x201c;non-transitory media&#x201d; as used herein refers to any media storing data and/or instructions that cause a machine to operate in a specific manner. Exemplary non-transitory media include non-volatile media and/or volatile media. Non-volatile media include, for example, a hard disk, a solid state drive, a magnetic disk or tape, an optical disk or tape, a flash memory, an EPROM NVRAM, PRAM, or other such media, or networked versions of such media. Volatile media include, for example, dynamic memory such as DRAM, SRAM, a cache, or other such media. Non-transitory media is distinct from, but can be used in conjunction with transmission media. Transmission media is used for transferring data and/or instruction to or from a machine. Exemplary transmission media, include coaxial cables, fiber-optic cables, copper wires, and wireless media, such as radio waves.</p><p id="p-0068" num="0063">Furthermore, those skilled in the art will recognize that boundaries between the functionality of the above described operations are merely illustrative. The functionality of multiple operations may be combined into a single operation, and/or the functionality of a single operation may be distributed in additional operations. Moreover, alternative embodiments may include multiple instances of a particular operation, and the order of operations may be altered in various other embodiments.</p><p id="p-0069" num="0064">Although the disclosure provides specific examples, various modifications and changes can be made without departing from the scope of the disclosure as set forth in the claims below. Accordingly, the specification and figures are to be regarded in an illustrative rather than a restrictive sense, and all such modifications are intended to be included within the scope of the present disclosure. Any benefits, advantages, or solutions to problems that are described herein with regard to a specific example are not intended to be construed as a critical, required, or essential feature or element of any or all the claims.</p><p id="p-0070" num="0065">Furthermore, the terms &#x201c;a&#x201d; or &#x201c;an,&#x201d; as used herein, are defined as one or more than one. Also, the use of introductory phrases such as &#x201c;at least one&#x201d; and &#x201c;one or more&#x201d; in the claims should not be construed to imply that the introduction of another claim element by the indefinite articles &#x201c;a&#x201d; or &#x201c;an&#x201d; limits any particular claim containing such introduced claim element to inventions containing only one such element, even when the same claim includes the introductory phrases &#x201c;one or more&#x201d; or &#x201c;at least one&#x201d; and indefinite articles such as &#x201c;a&#x201d; or &#x201c;an.&#x201d; The same holds true for the use of definite articles.</p><p id="p-0071" num="0066">Unless stated otherwise, terms such as &#x201c;first&#x201d; and &#x201c;second&#x201d; are used to arbitrarily distinguish between the elements such terms describe. Thus, these terms are not necessarily intended to indicate temporal or other prioritization of such elements.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed:</us-claim-statement><claims id="claims"><claim id="CLM-01-20" num="01-20"><claim-text><b>1</b>.-<b>20</b>. (canceled)</claim-text></claim><claim id="CLM-00021" num="00021"><claim-text><b>21</b>. A processor comprising:<claim-text>a pipeline comprising a first plurality of stages corresponding to a frontend of the pipeline and a second plurality of stages corresponding to a backend of the pipeline; and</claim-text><claim-text>digital logic to access a state table for maintaining information related to at least a subset of branches corresponding to instructions being processed by the processor, wherein the digital logic is configured to:<claim-text>track locations of any exact convergence points associated with the at least the subset of branches corresponding to the instructions being processed by the processor, and</claim-text><claim-text>initiate a first recovery method for recovering from a misprediction associated with a branch from the at least the subset of branches if a location of an exact convergence point associated with the branch is determined to be in the frontend of the pipeline, or else initiate a second recovery method, different from the first recovery method, for recovering from the misprediction associated with the branch, wherein the location of the exact convergence point associated with the branch is determined based on an entry for the branch in the state table.</claim-text></claim-text></claim-text></claim><claim id="CLM-00022" num="00022"><claim-text><b>22</b>. The processor of <claim-ref idref="CLM-00021">claim 21</claim-ref>, wherein the digital logic further comprises branch qualifier logic to determine whether a branch is eligible for exact convergence tracking.</claim-text></claim><claim id="CLM-00023" num="00023"><claim-text><b>23</b>. The processor of <claim-ref idref="CLM-00021">claim 21</claim-ref>, wherein the digital logic comprises a plurality of frontend trackers and a plurality of backend trackers, wherein each of the plurality of frontend trackers comprises logic to compare any program counters received as part of a stream of fetched instruction addresses with an exact convergence program counter for the branch, and wherein each of the plurality of backend trackers comprises logic to compare any program counters received as part of an allocated stream of instruction addresses with the exact convergence program counter for the branch.</claim-text></claim><claim id="CLM-00024" num="00024"><claim-text><b>24</b>. The processor of <claim-ref idref="CLM-00021">claim 21</claim-ref>, wherein the digital logic further comprises delay logic configured to selectively delay a provision of a signal resulting in an update of the entry for the branch in the state table.</claim-text></claim><claim id="CLM-00025" num="00025"><claim-text><b>25</b>. The processor of <claim-ref idref="CLM-00021">claim 21</claim-ref>, wherein the first recovery method comprises in response to a mispredicted branch, flushing only those instructions that are in the backend of the pipeline and are younger than the mispredicted branch.</claim-text></claim><claim id="CLM-00026" num="00026"><claim-text><b>26</b>. The processor of <claim-ref idref="CLM-00021">claim 21</claim-ref>, wherein the first recovery method comprises in response to a mispredicted branch, selectively flushing only those instructions that are in the frontend of the pipeline and are older than an exact convergence point associated with the mispredicted branch.</claim-text></claim><claim id="CLM-00027" num="00027"><claim-text><b>27</b>. The processor of <claim-ref idref="CLM-00021">claim 21</claim-ref>, wherein the second recovery method comprises in response to a mispredicted branch, at least one of: (1) replaying all instructions included in an incorrect control dependent path as predicate-fail instructions and replaying all control independent data dependent instructions, or (2) executing a selected recovery program.</claim-text></claim><claim id="CLM-00028" num="00028"><claim-text><b>28</b>. The processor of <claim-ref idref="CLM-00021">claim 21</claim-ref>, wherein the digital logic is further configured to initiate a third recovery method, different from the first recovery method and the second recovery method, and wherein the third recovery method comprises in response to a mispredicted branch, flushing all instructions younger than the mispredicted branch from both the frontend of the pipeline and the backend of the pipeline.</claim-text></claim><claim id="CLM-00029" num="00029"><claim-text><b>29</b>. A method for operating a processor including a pipeline comprising a first plurality of stages corresponding to a frontend of the pipeline and a second plurality of stages corresponding to a backend of the pipeline, the method comprising:<claim-text>tracking locations of any exact convergence points associated with at least a subset of branches corresponding to instructions being processed using the processor;</claim-text><claim-text>maintaining a state table comprising information associated with the at least the subset of branches corresponding to the instructions being processed using the processor; and</claim-text><claim-text>initiating a first recovery method for recovering from a misprediction associated with a branch from the at least the subset of branches if a location of an exact convergence point associated with the branch is determined to be in the frontend of the pipeline, or else initiating a second recovery method, different from the first recovery method, for recovering from the misprediction associated with the branch, wherein the location of the exact convergence point associated with the branch is determined based on an entry for the branch in the state table.</claim-text></claim-text></claim><claim id="CLM-00030" num="00030"><claim-text><b>30</b>. The method of <claim-ref idref="CLM-00029">claim 29</claim-ref>, further comprising prior to tracking locations of any exact convergence points associated with any of the at least the subset of branches, determining whether any of the at least the subset of branches is eligible for exact convergence tracking.</claim-text></claim><claim id="CLM-00031" num="00031"><claim-text><b>31</b>. The method of <claim-ref idref="CLM-00029">claim 29</claim-ref>, wherein the processor comprises a plurality of frontend trackers and a plurality of backend trackers, wherein each of the plurality of frontend trackers comprises logic to compare any program counters received as part of a stream of fetched instruction addresses with an exact convergence program counter for the branch, and wherein each of the plurality of backend trackers comprises logic to compare any program counters received as part of an allocated stream of instruction addresses with the exact convergence program counter for the branch.</claim-text></claim><claim id="CLM-00032" num="00032"><claim-text><b>32</b>. The method of <claim-ref idref="CLM-00029">claim 29</claim-ref>, wherein the first recovery method comprises in response to a mispredicted branch, flushing only those instructions that are in the backend of the pipeline and are younger than the mispredicted branch.</claim-text></claim><claim id="CLM-00033" num="00033"><claim-text><b>33</b>. The method of <claim-ref idref="CLM-00029">claim 29</claim-ref>, wherein the first recovery method comprises in response to a mispredicted branch, selectively flushing only those instructions that are in the frontend of the pipeline and are older than an exact convergence point associated with the mispredicted branch.</claim-text></claim><claim id="CLM-00034" num="00034"><claim-text><b>34</b>. The method of <claim-ref idref="CLM-00029">claim 29</claim-ref>, wherein the second recovery method comprises in response to a mispredicted branch, at least one of: (1) replaying all instructions included in an incorrect control dependent path as predicate-fail instructions and replaying all control independent data dependent instructions, or (2) executing a selected recovery program.</claim-text></claim><claim id="CLM-00035" num="00035"><claim-text><b>35</b>. The method of <claim-ref idref="CLM-00029">claim 29</claim-ref>, further comprising initiating a third recovery method, different from both the first recovery method and the second recovery method, and wherein the third recovery method comprises in response to a mispredicted branch, flushing all instructions younger than the mispredicted branch from both the frontend of the pipeline and the backend of the pipeline.</claim-text></claim><claim id="CLM-00036" num="00036"><claim-text><b>36</b>. A method for operating a processor including a pipeline comprising a first plurality of stages corresponding to a frontend of the pipeline and a second plurality of stages corresponding to a backend of the pipeline, the method comprising:<claim-text>using a plurality of frontend trackers and a plurality of backend trackers, tracking locations of any exact convergence points associated with at least a subset of branches corresponding to instructions being processed using the processor;</claim-text><claim-text>maintaining a state table comprising information associated with the at least the subset of branches corresponding to the instructions being processed using the processor; and</claim-text><claim-text>initiating a first recovery method for recovering from a misprediction associated with a branch from the at least the subset of branches if a location of an exact convergence point associated with the branch is determined to be in the frontend of the pipeline, or else initiating a second recovery method, different from the first recovery method, for recovering from the misprediction associated with the branch, wherein at least one of the plurality of backend trackers associated with the branch is configured to provide a signal resulting in an update of an entry for the branch in the state table indicative of the location of the exact convergence point associated with the branch.</claim-text></claim-text></claim><claim id="CLM-00037" num="00037"><claim-text><b>37</b>. The method of <claim-ref idref="CLM-00036">claim 36</claim-ref>, further comprising prior to tracking locations of any exact convergence points associated with any of the at least the subset of branches, determining whether any of the at least the subset of branches is eligible for exact convergence tracking.</claim-text></claim><claim id="CLM-00038" num="00038"><claim-text><b>38</b>. The method of <claim-ref idref="CLM-00036">claim 36</claim-ref>, wherein each of the plurality of frontend trackers comprises logic to compare any program counters received as part of a stream of fetched instruction addresses with an exact convergence program counter for the branch, and wherein each of the plurality of backend trackers comprises logic to compare any program counters received as part of an allocated stream of instruction addresses with the exact convergence program counter for the branch.</claim-text></claim><claim id="CLM-00039" num="00039"><claim-text><b>39</b>. The method of <claim-ref idref="CLM-00036">claim 36</claim-ref>, wherein the first recovery method comprises in response to a mispredicted branch, flushing only those instructions that are in the backend of the pipeline and are younger than the mispredicted branch.</claim-text></claim><claim id="CLM-00040" num="00040"><claim-text><b>40</b>. The method of <claim-ref idref="CLM-00036">claim 36</claim-ref>, wherein the first recovery method comprises in response to a mispredicted branch, selectively flushing only those instructions that are in the frontend of the pipeline and are older than an exact convergence point associated with the mispredicted branch, and wherein the second recovery method comprises in response to the mispredicted branch, at least one of: (1) replaying all instructions included in an incorrect control dependent path as predicate-fail instructions and replaying all control independent data dependent instructions, or (2) executing a selected recovery program.</claim-text></claim></claims></us-patent-application>