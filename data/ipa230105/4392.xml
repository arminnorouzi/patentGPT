<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004393A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004393</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17359552</doc-number><date>20210626</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>30</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>38</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>30149</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>384</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>3836</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">APPARATUS AND METHOD FOR VECTOR PACKED SIGNED/UNSIGNED SHIFT, ROUND, AND SATURATE</invention-title><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Intel Corporation</orgname><address><city>Santa Clara</city><state>CA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>MADDURI</last-name><first-name>Venkateswara Rao</first-name><address><city>Austin</city><state>TX</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>VALENTINE</last-name><first-name>Robert</first-name><address><city>Kiryat</city><country>IL</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>CHARNEY</last-name><first-name>Mark</first-name><address><city>Lexington</city><state>MA</state><country>US</country></address></addressbook></inventor><inventor sequence="03" designation="us-only"><addressbook><last-name>ANDERSON</last-name><first-name>Cristina</first-name><address><city>Hillsboro</city><state>OR</state><country>US</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">Apparatus and method for signed and unsigned shift, round and saturate using different data element values. For example, one embodiment of an apparatus comprises a decoder to decode an instruction having fields for a first packed data source operand to provide a first source data element and a second source data element, a second packed data source operand or immediate to provide a first shift value and a second shift value corresponding to the first source data element and second source data element, respectively, and a packed data destination operand to indicate a first result value and a second result value corresponding to the first source data element and second source data element, and execution circuitry to execute the decoded instruction to: shift the first source data element by an amount based on the first shift value to generate a first shifted data element; shift the second source data element by an amount based on the second shift value to generate a second shifted data element; update a saturation indicator responsive to detecting a saturation condition resulting from the shift of the first and/or second source data elements; round and/or saturate the first and second shifted data elements in accordance with a specified rounding mode and the saturation indicator, respectively, to generate the first and second result data elements; and store the first result value and the second result value in a first data element location and a second data element location in a destination register.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="80.09mm" wi="158.75mm" file="US20230004393A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="192.70mm" wi="135.64mm" orientation="landscape" file="US20230004393A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="163.07mm" wi="87.88mm" orientation="landscape" file="US20230004393A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="199.47mm" wi="51.73mm" orientation="landscape" file="US20230004393A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="170.52mm" wi="142.24mm" orientation="landscape" file="US20230004393A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="93.47mm" wi="130.22mm" orientation="landscape" file="US20230004393A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="178.82mm" wi="136.31mm" orientation="landscape" file="US20230004393A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="195.07mm" wi="32.26mm" orientation="landscape" file="US20230004393A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="177.55mm" wi="112.35mm" orientation="landscape" file="US20230004393A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="225.13mm" wi="139.02mm" orientation="landscape" file="US20230004393A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="206.50mm" wi="120.65mm" orientation="landscape" file="US20230004393A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="193.80mm" wi="58.76mm" orientation="landscape" file="US20230004393A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="162.22mm" wi="116.42mm" orientation="landscape" file="US20230004393A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="140.72mm" wi="122.43mm" orientation="landscape" file="US20230004393A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00014" num="00014"><img id="EMI-D00014" he="119.55mm" wi="153.75mm" orientation="landscape" file="US20230004393A1-20230105-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00015" num="00015"><img id="EMI-D00015" he="224.71mm" wi="123.87mm" orientation="landscape" file="US20230004393A1-20230105-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00016" num="00016"><img id="EMI-D00016" he="219.96mm" wi="105.92mm" orientation="landscape" file="US20230004393A1-20230105-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00017" num="00017"><img id="EMI-D00017" he="238.00mm" wi="129.88mm" orientation="landscape" file="US20230004393A1-20230105-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00018" num="00018"><img id="EMI-D00018" he="235.03mm" wi="150.96mm" orientation="landscape" file="US20230004393A1-20230105-D00018.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00019" num="00019"><img id="EMI-D00019" he="155.28mm" wi="129.12mm" orientation="landscape" file="US20230004393A1-20230105-D00019.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00020" num="00020"><img id="EMI-D00020" he="220.73mm" wi="165.69mm" orientation="landscape" file="US20230004393A1-20230105-D00020.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00021" num="00021"><img id="EMI-D00021" he="219.79mm" wi="176.11mm" orientation="landscape" file="US20230004393A1-20230105-D00021.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00022" num="00022"><img id="EMI-D00022" he="218.27mm" wi="174.16mm" orientation="landscape" file="US20230004393A1-20230105-D00022.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00023" num="00023"><img id="EMI-D00023" he="241.30mm" wi="117.09mm" orientation="landscape" file="US20230004393A1-20230105-D00023.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00024" num="00024"><img id="EMI-D00024" he="205.91mm" wi="146.98mm" orientation="landscape" file="US20230004393A1-20230105-D00024.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00025" num="00025"><img id="EMI-D00025" he="193.46mm" wi="146.98mm" orientation="landscape" file="US20230004393A1-20230105-D00025.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00026" num="00026"><img id="EMI-D00026" he="220.13mm" wi="146.98mm" orientation="landscape" file="US20230004393A1-20230105-D00026.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00027" num="00027"><img id="EMI-D00027" he="193.46mm" wi="146.98mm" orientation="landscape" file="US20230004393A1-20230105-D00027.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00028" num="00028"><img id="EMI-D00028" he="238.25mm" wi="117.09mm" orientation="landscape" file="US20230004393A1-20230105-D00028.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00029" num="00029"><img id="EMI-D00029" he="205.91mm" wi="146.98mm" orientation="landscape" file="US20230004393A1-20230105-D00029.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00030" num="00030"><img id="EMI-D00030" he="193.46mm" wi="146.98mm" orientation="landscape" file="US20230004393A1-20230105-D00030.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00031" num="00031"><img id="EMI-D00031" he="231.39mm" wi="147.24mm" orientation="landscape" file="US20230004393A1-20230105-D00031.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00032" num="00032"><img id="EMI-D00032" he="193.46mm" wi="146.98mm" orientation="landscape" file="US20230004393A1-20230105-D00032.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00033" num="00033"><img id="EMI-D00033" he="234.02mm" wi="122.60mm" orientation="landscape" file="US20230004393A1-20230105-D00033.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00034" num="00034"><img id="EMI-D00034" he="205.91mm" wi="146.98mm" orientation="landscape" file="US20230004393A1-20230105-D00034.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00035" num="00035"><img id="EMI-D00035" he="203.45mm" wi="146.98mm" orientation="landscape" file="US20230004393A1-20230105-D00035.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00036" num="00036"><img id="EMI-D00036" he="228.18mm" wi="146.98mm" orientation="landscape" file="US20230004393A1-20230105-D00036.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00037" num="00037"><img id="EMI-D00037" he="193.46mm" wi="146.98mm" orientation="landscape" file="US20230004393A1-20230105-D00037.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">BACKGROUND</heading><heading id="h-0002" level="1">Field of the Invention</heading><p id="p-0002" num="0001">The embodiments of the invention relate generally to the field of computer processors. More particularly, the embodiments relate to an apparatus and method for vector packed signed/unsigned shift, round, and saturate.</p><heading id="h-0003" level="1">Description of the Related Art</heading><p id="p-0003" num="0002">An instruction set, or instruction set architecture (ISA), is the part of the computer architecture related to programming, including the native data types, instructions, register architecture, addressing modes, memory architecture, interrupt and exception handling, and external input and output (I/O). It should be noted that the term &#x201c;instruction&#x201d; generally refers herein to macro-instructions&#x2014;that is instructions that are provided to the processor for execution&#x2014;as opposed to micro-instructions or micro-ops&#x2014;that is the result of a processor's decoder decoding macro-instructions. The micro-instructions or micro-ops can be configured to instruct an execution unit on the processor to perform operations to implement the logic associated with the macro-instruction.</p><p id="p-0004" num="0003">The ISA is distinguished from the microarchitecture, which is the set of processor design techniques used to implement the instruction set. Processors with different microarchitectures can share a common instruction set. For example, Intel&#xae; Pentium 4 processors, Intel&#xae; Core&#x2122; processors, and processors from Advanced Micro Devices, Inc. of Sunnyvale Calif. implement nearly identical versions of the x86 instruction set (with some extensions that have been added with newer versions), but have different internal designs. For example, the same register architecture of the ISA may be implemented in different ways in different microarchitectures using well-known techniques, including dedicated physical registers, one or more dynamically allocated physical registers using a register renaming mechanism (e.g., the use of a Register Alias Table (RAT), a Reorder Buffer (ROB) and a retirement register file). Unless otherwise specified, the phrases register architecture, register file, and register are used herein to refer to that which is visible to the software/programmer and the manner in which instructions specify registers. Where a distinction is required, the adjective &#x201c;logical,&#x201d; &#x201c;architectural,&#x201d; or &#x201c;software visible&#x201d; will be used to indicate registers/files in the register architecture, while different adjectives will be used to designate registers in a given microarchitecture (e.g., physical register, reorder buffer, retirement register, register pool).</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0005" num="0004">A better understanding of the present invention can be obtained from the following detailed description in conjunction with the following drawings, in which:</p><p id="p-0006" num="0005"><figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates an example computer system architecture;</p><p id="p-0007" num="0006"><figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates a processor comprising a plurality of cores;</p><p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. <b>3</b>A</figref> illustrates a plurality of stages of a processing pipeline;</p><p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. <b>3</b>B</figref> illustrates details of one embodiment of a core;</p><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. <b>4</b></figref> illustrates execution circuitry in accordance with one embodiment;</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. <b>5</b></figref> illustrates one embodiment of a register architecture;</p><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>6</b></figref> illustrates one example of an instruction format;</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. <b>7</b></figref> illustrates addressing techniques in accordance with one embodiment;</p><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. <b>8</b></figref> illustrates one embodiment of an instruction prefix;</p><p id="p-0015" num="0014"><figref idref="DRAWINGS">FIGS. <b>9</b>A-D</figref> illustrate embodiments of how the R, X, and B fields of the prefix are used;</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIGS. <b>10</b>A-B</figref> illustrate examples of a second instruction prefix;</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>11</b></figref> illustrates payload bytes of one embodiment of an instruction prefix;</p><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>12</b></figref> illustrates techniques for executing different instruction set architectures;</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIGS. <b>13</b>A-B</figref> illustrate embodiments of configured tiles and associated registers/storage;</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>14</b></figref> illustrates an embodiment of a system utilizing a matrix operations accelerator;</p><p id="p-0021" num="0020"><figref idref="DRAWINGS">FIGS. <b>15</b> and <b>16</b></figref> show different embodiments of how memory is shared using a matrix operations accelerator;</p><p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. <b>17</b></figref> illustrates an example pipeline for executing a matrix multiplication operation;</p><p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. <b>18</b></figref> illustrates execution circuitry including a processing array;</p><p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. <b>19</b></figref> illustrates an example of a matrix containing complex values;</p><p id="p-0025" num="0024"><figref idref="DRAWINGS">FIGS. <b>20</b>A-C</figref> illustrate different implementations of matrix processing circuitry;</p><p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. <b>21</b></figref> illustrates an architecture for executing complex matrix multiplication instructions;</p><p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. <b>22</b></figref> illustrate methods for performing a complex matrix multiplication;</p><p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. <b>23</b></figref> illustrates an architecture for executing complex matrix transpose and multiplication instructions;</p><p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. <b>24</b></figref> illustrate methods for performing a complex matrix transpose and multiplication;</p><p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. <b>25</b></figref> illustrates an architecture for executing a complex matrix conjugation instruction;</p><p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. <b>26</b></figref> illustrates a method for performing a complex matrix conjugation operation;</p><p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. <b>27</b></figref> illustrates an architecture for executing complex matrix conjugation and multiplication instructions; and</p><p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. <b>28</b></figref> illustrates a method for performing a complex matrix conjugation and multiplication.</p><p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. <b>29</b></figref> illustrates operation of one embodiment of a left-shift signed doubleword SRS instruction;</p><p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. <b>30</b></figref> illustrates operation of one embodiment of a right-shift signed doubleword SRS instruction;</p><p id="p-0036" num="0035"><figref idref="DRAWINGS">FIG. <b>31</b></figref> illustrates one embodiment for shifting based on count values following by rounding/saturation;</p><p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. <b>32</b></figref> illustrates operation of one embodiment of a left-shift unsigned doubleword SRS instruction;</p><p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. <b>33</b></figref> illustrates operation of one embodiment of a right-shift unsigned doubleword SRS instruction;</p><p id="p-0039" num="0038"><figref idref="DRAWINGS">FIG. <b>34</b></figref> illustrates operation of one embodiment of a left-shift signed doubleword SRS instruction;</p><p id="p-0040" num="0039"><figref idref="DRAWINGS">FIG. <b>35</b></figref> illustrates operation of one embodiment of a right-shift signed doubleword SRS instruction.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0005" level="1">DETAILED DESCRIPTION</heading><heading id="h-0006" level="2">Exemplary Computer Architectures</heading><p id="p-0041" num="0040">Detailed below are describes of exemplary computer architectures. Other system designs and configurations known in the arts for laptops, desktops, handheld PCs, personal digital assistants, engineering workstations, servers, network devices, network hubs, switches, embedded processors, digital signal processors (DSPs), graphics devices, video game devices, set-top boxes, micro controllers, cell phones, portable media players, hand held devices, and various other electronic devices, are also suitable. In general, a huge variety of systems or electronic devices capable of incorporating a processor and/or other execution logic as disclosed herein are generally suitable.</p><p id="p-0042" num="0041"><figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates embodiments of an exemplary system. Multiprocessor system <b>100</b> is a point-to-point interconnect system and includes a plurality of processors including a first processor <b>170</b> and a second processor <b>180</b> coupled via a point-to-point interconnect <b>150</b>. In some embodiments, the first processor <b>170</b> and the second processor <b>180</b> are homogeneous. In some embodiments, first processor <b>170</b> and the second processor <b>180</b> are heterogenous.</p><p id="p-0043" num="0042">Processors <b>170</b> and <b>180</b> are shown including integrated memory controller (IMC) units circuitry <b>172</b> and <b>182</b>, respectively. Processor <b>170</b> also includes as part of its interconnect controller units point-to-point (P-P) interfaces <b>176</b> and <b>178</b>; similarly, second processor <b>180</b> includes P-P interfaces <b>186</b> and <b>188</b>. Processors <b>170</b>, <b>180</b> may exchange information via the point-to-point (P-P) interconnect <b>150</b> using P-P interface circuits <b>178</b>, <b>188</b>. IMCs <b>172</b> and <b>182</b> couple the processors <b>170</b>, <b>180</b> to respective memories, namely a memory <b>132</b> and a memory <b>134</b>, which may be portions of main memory locally attached to the respective processors.</p><p id="p-0044" num="0043">Processors <b>170</b>, <b>180</b> may each exchange information with a chipset <b>190</b> via individual P-P interconnects <b>152</b>, <b>154</b> using point to point interface circuits <b>176</b>, <b>194</b>, <b>186</b>, <b>198</b>. Chipset <b>190</b> may optionally exchange information with a coprocessor <b>138</b> via a high-performance interface <b>192</b>. In some embodiments, the coprocessor <b>138</b> is a special-purpose processor, such as, for example, a high-throughput MIC processor, a network or communication processor, compression engine, graphics processor, GPGPU, embedded processor, or the like.</p><p id="p-0045" num="0044">A shared cache (not shown) may be included in either processor <b>170</b>, <b>180</b> or outside of both processors, yet connected with the processors via P-P interconnect, such that either or both processors' local cache information may be stored in the shared cache if a processor is placed into a low power mode.</p><p id="p-0046" num="0045">Chipset <b>190</b> may be coupled to a first interconnect <b>116</b> via an interface <b>196</b>. In some embodiments, first interconnect <b>116</b> may be a Peripheral Component Interconnect (PCI) interconnect, or an interconnect such as a PCI Express interconnect or another I/O interconnect. In some embodiments, one of the interconnects couples to a power control unit (PCU) <b>117</b>, which may include circuitry, software, and/or firmware to perform power management operations with regard to the processors <b>170</b>, <b>180</b> and/or co-processor <b>138</b>. PCU <b>117</b> provides control information to a voltage regulator to cause the voltage regulator to generate the appropriate regulated voltage. PCU <b>117</b> also provides control information to control the operating voltage generated. In various embodiments, PCU <b>117</b> may include a variety of power management logic units (circuitry) to perform hardware-based power management. Such power management may be wholly processor controlled (e.g., by various processor hardware, and which may be triggered by workload and/or power, thermal or other processor constraints) and/or the power management may be performed responsive to external sources (such as a platform or power management source or system software).</p><p id="p-0047" num="0046">PCU <b>117</b> is illustrated as being present as logic separate from the processor <b>170</b> and/or processor <b>180</b>. In other cases, PCU <b>117</b> may execute on a given one or more of cores (not shown) of processor <b>170</b> or <b>180</b>. In some cases, PCU <b>117</b> may be implemented as a microcontroller (dedicated or general-purpose) or other control logic configured to execute its own dedicated power management code, sometimes referred to as P-code. In yet other embodiments, power management operations to be performed by PCU <b>117</b> may be implemented externally to a processor, such as by way of a separate power management integrated circuit (PMIC) or another component external to the processor. In yet other embodiments, power management operations to be performed by PCU <b>117</b> may be implemented within BIOS or other system software.</p><p id="p-0048" num="0047">Various I/O devices <b>114</b> may be coupled to first interconnect <b>116</b>, along with an interconnect (bus) bridge <b>118</b> which couples first interconnect <b>116</b> to a second interconnect <b>120</b>. In some embodiments, one or more additional processor(s) <b>115</b>, such as coprocessors, high-throughput MIC processors, GPGPU's, accelerators (such as, e.g., graphics accelerators or digital signal processing (DSP) units), field programmable gate arrays (FPGAs), or any other processor, are coupled to first interconnect <b>116</b>. In some embodiments, second interconnect <b>120</b> may be a low pin count (LPC) interconnect. Various devices may be coupled to second interconnect <b>120</b> including, for example, a keyboard and/or mouse <b>122</b>, communication devices <b>127</b> and a storage unit circuitry <b>128</b>. Storage unit circuitry <b>128</b> may be a disk drive or other mass storage device which may include instructions/code and data <b>130</b>, in some embodiments. Further, an audio I/O <b>124</b> may be coupled to second interconnect <b>120</b>. Note that other architectures than the point-to-point architecture described above are possible. For example, instead of the point-to-point architecture, a system such as multiprocessor system <b>100</b> may implement a multi-drop interconnect or other such architecture.</p><heading id="h-0007" level="2">Exemplary Core Architectures, Processors, and Computer Architectures</heading><p id="p-0049" num="0048">Processor cores may be implemented in different ways, for different purposes, and in different processors. For instance, implementations of such cores may include: 1) a general purpose in-order core intended for general-purpose computing; 2) a high performance general purpose out-of-order core intended for general-purpose computing; 3) a special purpose core intended primarily for graphics and/or scientific (throughput) computing. Implementations of different processors may include: 1) a CPU including one or more general purpose in-order cores intended for general-purpose computing and/or one or more general purpose out-of-order cores intended for general-purpose computing; and 2) a coprocessor including one or more special purpose cores intended primarily for graphics and/or scientific (throughput). Such different processors lead to different computer system architectures, which may include: 1) the coprocessor on a separate chip from the CPU; 2) the coprocessor on a separate die in the same package as a CPU; 3) the coprocessor on the same die as a CPU (in which case, such a coprocessor is sometimes referred to as special purpose logic, such as integrated graphics and/or scientific (throughput) logic, or as special purpose cores); and 4) a system on a chip that may include on the same die as the described CPU (sometimes referred to as the application core(s) or application processor(s)), the above described coprocessor, and additional functionality. Exemplary core architectures are described next, followed by descriptions of exemplary processors and computer architectures.</p><p id="p-0050" num="0049"><figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates a block diagram of embodiments of a processor <b>200</b> that may have more than one core, may have an integrated memory controller, and may have integrated graphics. The solid lined boxes illustrate a processor <b>200</b> with a single core <b>202</b>A, a system agent <b>210</b>, a set of one or more interconnect controller units circuitry <b>216</b>, while the optional addition of the dashed lined boxes illustrates an alternative processor <b>200</b> with multiple cores <b>202</b>(A)-(N), a set of one or more integrated memory controller unit(s) circuitry <b>214</b> in the system agent unit circuitry <b>210</b>, and special purpose logic <b>208</b>, as well as a set of one or more interconnect controller units circuitry <b>216</b>. Note that the processor <b>200</b> may be one of the processors <b>170</b> or <b>180</b>, or co-processor <b>138</b> or <b>115</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref>.</p><p id="p-0051" num="0050">Thus, different implementations of the processor <b>200</b> may include: 1) a CPU with the special purpose logic <b>208</b> being integrated graphics and/or scientific (throughput) logic (which may include one or more cores, not shown), and the cores <b>202</b>(A)-(N) being one or more general purpose cores (e.g., general purpose in-order cores, general purpose out-of-order cores, or a combination of the two); 2) a coprocessor with the cores <b>202</b>(A)-(N) being a large number of special purpose cores intended primarily for graphics and/or scientific (throughput); and 3) a coprocessor with the cores <b>202</b>(A)-(N) being a large number of general purpose in-order cores. Thus, the processor <b>200</b> may be a general-purpose processor, coprocessor or special-purpose processor, such as, for example, a network or communication processor, compression engine, graphics processor, GPGPU (general purpose graphics processing unit circuitry), a high-throughput many integrated core (MIC) coprocessor (including 30 or more cores), embedded processor, or the like. The processor may be implemented on one or more chips. The processor <b>200</b> may be a part of and/or may be implemented on one or more substrates using any of a number of process technologies, such as, for example, BiCMOS, CMOS, or NMOS.</p><p id="p-0052" num="0051">A memory hierarchy includes one or more levels of cache unit(s) circuitry <b>204</b>(A)-(N) within the cores <b>202</b>(A)-(N), a set of one or more shared cache units circuitry <b>206</b>, and external memory (not shown) coupled to the set of integrated memory controller units circuitry <b>214</b>. The set of one or more shared cache units circuitry <b>206</b> may include one or more mid level caches, such as level 2 (L2), level 3 (L3), level 4 (L4), or other levels of cache, such as a last level cache (LLC), and/or combinations thereof. While in some embodiments ring-based interconnect network circuitry <b>212</b> interconnects the special purpose logic <b>208</b> (e.g., integrated graphics logic), the set of shared cache units circuitry <b>206</b>, and the system agent unit circuitry <b>210</b>, alternative embodiments use any number of well-known techniques for interconnecting such units. In some embodiments, coherency is maintained between one or more of the shared cache units circuitry <b>206</b> and cores <b>202</b>(A)-(N).</p><p id="p-0053" num="0052">In some embodiments, one or more of the cores <b>202</b>(A)-(N) are capable of multi-threading. The system agent unit circuitry <b>210</b> includes those components coordinating and operating cores <b>202</b>(A)-(N). The system agent unit circuitry <b>210</b> may include, for example, power control unit (PCU) circuitry and/or display unit circuitry (not shown). The PCU may be or may include logic and components needed for regulating the power state of the cores <b>202</b>(A)-(N) and/or the special purpose logic <b>208</b> (e.g., integrated graphics logic). The display unit circuitry is for driving one or more externally connected displays.</p><p id="p-0054" num="0053">The cores <b>202</b>(A)-(N) may be homogenous or heterogeneous in terms of architecture instruction set; that is, two or more of the cores <b>202</b>(A)-(N) may be capable of executing the same instruction set, while other cores may be capable of executing only a subset of that instruction set or a different instruction set.</p><heading id="h-0008" level="2">Exemplary Core Architectures</heading><heading id="h-0009" level="2">In-Order and Out-of-Order Core Block Diagram</heading><p id="p-0055" num="0054"><figref idref="DRAWINGS">FIG. <b>3</b>(A)</figref> is a block diagram illustrating both an exemplary in-order pipeline and an exemplary register renaming, out-of-order issue/execution pipeline according to embodiments of the invention. <figref idref="DRAWINGS">FIG. <b>3</b>(B)</figref> is a block diagram illustrating both an exemplary embodiment of an in-order architecture core and an exemplary register renaming, out-of-order issue/execution architecture core to be included in a processor according to embodiments of the invention. The solid lined boxes in <figref idref="DRAWINGS">FIGS. <b>3</b>(A)</figref>-(B) illustrate the in-order pipeline and in-order core, while the optional addition of the dashed lined boxes illustrates the register renaming, out-of-order issue/execution pipeline and core. Given that the in-order aspect is a subset of the out-of-order aspect, the out-of-order aspect will be described.</p><p id="p-0056" num="0055">In <figref idref="DRAWINGS">FIG. <b>3</b>(A)</figref>, a processor pipeline <b>300</b> includes a fetch stage <b>302</b>, an optional length decode stage <b>304</b>, a decode stage <b>306</b>, an optional allocation stage <b>308</b>, an optional renaming stage <b>310</b>, a scheduling (also known as a dispatch or issue) stage <b>312</b>, an optional register read/memory read stage <b>314</b>, an execute stage <b>316</b>, a write back/memory write stage <b>318</b>, an optional exception handling stage <b>322</b>, and an optional commit stage <b>324</b>. One or more operations can be performed in each of these processor pipeline stages. For example, during the fetch stage <b>302</b>, one or more instructions are fetched from instruction memory, during the decode stage <b>306</b>, the one or more fetched instructions may be decoded, addresses (e.g., load store unit (LSU) addresses) using forwarded register ports may be generated, and branch forwarding (e.g., immediate offset or an link register (LR)) may be performed. In one embodiment, the decode stage <b>306</b> and the register read/memory read stage <b>314</b> may be combined into one pipeline stage. In one embodiment, during the execute stage <b>316</b>, the decoded instructions may be executed, LSU address/data pipelining to an Advanced Microcontroller Bus (AHB) interface may be performed, multiply and add operations may be performed, arithmetic operations with branch results may be performed, etc.</p><p id="p-0057" num="0056">By way of example, the exemplary register renaming, out-of-order issue/execution core architecture may implement the pipeline <b>300</b> as follows: 1) the instruction fetch <b>338</b> performs the fetch and length decoding stages <b>302</b> and <b>304</b>; 2) the decode unit circuitry <b>340</b> performs the decode stage <b>306</b>; 3) the rename/allocator unit circuitry <b>352</b> performs the allocation stage <b>308</b> and renaming stage <b>310</b>; 4) the scheduler unit(s) circuitry <b>356</b> performs the schedule stage <b>312</b>; 5) the physical register file(s) unit(s) circuitry <b>358</b> and the memory unit circuitry <b>370</b> perform the register read/memory read stage <b>314</b>; the execution cluster <b>360</b> perform the execute stage <b>316</b>; 6) the memory unit circuitry <b>370</b> and the physical register file(s) unit(s) circuitry <b>358</b> perform the write back/memory write stage <b>318</b>; 7) various units (unit circuitry) may be involved in the exception handling stage <b>322</b>; and 8) the retirement unit circuitry <b>354</b> and the physical register file(s) unit(s) circuitry <b>358</b> perform the commit stage <b>324</b>.</p><p id="p-0058" num="0057"><figref idref="DRAWINGS">FIG. <b>3</b>(B)</figref> shows processor core <b>390</b> including front-end unit circuitry <b>330</b> coupled to an execution engine unit circuitry <b>350</b>, and both are coupled to a memory unit circuitry <b>370</b>. The core <b>390</b> may be a reduced instruction set computing (RISC) core, a complex instruction set computing (CISC) core, a very long instruction word (VLIW) core, or a hybrid or alternative core type. As yet another option, the core <b>390</b> may be a special-purpose core, such as, for example, a network or communication core, compression engine, coprocessor core, general purpose computing graphics processing unit (GPGPU) core, graphics core, or the like.</p><p id="p-0059" num="0058">The front end unit circuitry <b>330</b> may include branch prediction unit circuitry <b>332</b> coupled to an instruction cache unit circuitry <b>334</b>, which is coupled to an instruction translation lookaside buffer (TLB) <b>336</b>, which is coupled to instruction fetch unit circuitry <b>338</b>, which is coupled to decode unit circuitry <b>340</b>. In one embodiment, the instruction cache unit circuitry <b>334</b> is included in the memory unit circuitry <b>370</b> rather than the front-end unit circuitry <b>330</b>. The decode unit circuitry <b>340</b> (or decoder) may decode instructions, and generate as an output one or more micro-operations, micro-code entry points, microinstructions, other instructions, or other control signals, which are decoded from, or which otherwise reflect, or are derived from, the original instructions. The decode unit circuitry <b>340</b> may further include an address generation unit circuitry (AGU, not shown). In one embodiment, the AGU generates an LSU address using forwarded register ports, and may further perform branch forwarding (e.g., immediate offset branch forwarding, LR register branch forwarding, etc.). The decode unit circuitry <b>340</b> may be implemented using various different mechanisms. Examples of suitable mechanisms include, but are not limited to, look-up tables, hardware implementations, programmable logic arrays (PLAs), microcode read only memories (ROMs), etc. In one embodiment, the core <b>390</b> includes a microcode ROM (not shown) or other medium that stores microcode for certain macroinstructions (e.g., in decode unit circuitry <b>340</b> or otherwise within the front end unit circuitry <b>330</b>). In one embodiment, the decode unit circuitry <b>340</b> includes a micro-operation (micro-op) or operation cache (not shown) to hold/cache decoded operations, micro-tags, or micro-operations generated during the decode or other stages of the processor pipeline <b>300</b>. The decode unit circuitry <b>340</b> may be coupled to rename/allocator unit circuitry <b>352</b> in the execution engine unit circuitry <b>350</b>.</p><p id="p-0060" num="0059">The execution engine circuitry <b>350</b> includes the rename/allocator unit circuitry <b>352</b> coupled to a retirement unit circuitry <b>354</b> and a set of one or more scheduler(s) circuitry <b>356</b>. The scheduler(s) circuitry <b>356</b> represents any number of different schedulers, including reservations stations, central instruction window, etc. In some embodiments, the scheduler(s) circuitry <b>356</b> can include arithmetic logic unit (ALU) scheduler/scheduling circuitry, ALU queues, arithmetic generation unit (AGU) scheduler/scheduling circuitry, AGU queues, etc. The scheduler(s) circuitry <b>356</b> is coupled to the physical register file(s) circuitry <b>358</b>. Each of the physical register file(s) circuitry <b>358</b> represents one or more physical register files, different ones of which store one or more different data types, such as scalar integer, scalar floating-point, packed integer, packed floating-point, vector integer, vector floating-point, status (e.g., an instruction pointer that is the address of the next instruction to be executed), etc. In one embodiment, the physical register file(s) unit circuitry <b>358</b> includes vector registers unit circuitry, writemask registers unit circuitry, and scalar register unit circuitry. These register units may provide architectural vector registers, vector mask registers, general-purpose registers, etc. The physical register file(s) unit(s) circuitry <b>358</b> is overlapped by the retirement unit circuitry <b>354</b> (also known as a retire queue or a retirement queue) to illustrate various ways in which register renaming and out-of-order execution may be implemented (e.g., using a reorder buffer(s) (ROB(s)) and a retirement register file(s); using a future file(s), a history buffer(s), and a retirement register file(s); using a register maps and a pool of registers; etc.). The retirement unit circuitry <b>354</b> and the physical register file(s) circuitry <b>358</b> are coupled to the execution cluster(s) <b>360</b>. The execution cluster(s) <b>360</b> includes a set of one or more execution units circuitry <b>362</b> and a set of one or more memory access circuitry <b>364</b>. The execution units circuitry <b>362</b> may perform various arithmetic, logic, floating-point or other types of operations (e.g., shifts, addition, subtraction, multiplication) and on various types of data (e.g., scalar floating-point, packed integer, packed floating-point, vector integer, vector floating-point). While some embodiments may include a number of execution units or execution unit circuitry dedicated to specific functions or sets of functions, other embodiments may include only one execution unit circuitry or multiple execution units/execution unit circuitry that all perform all functions. The scheduler(s) circuitry <b>356</b>, physical register file(s) unit(s) circuitry <b>358</b>, and execution cluster(s) <b>360</b> are shown as being possibly plural because certain embodiments create separate pipelines for certain types of data/operations (e.g., a scalar integer pipeline, a scalar floating-point/packed integer/packed floating-point/vector integer/vector floating-point pipeline, and/or a memory access pipeline that each have their own scheduler circuitry, physical register file(s) unit circuitry, and/or execution cluster&#x2014;and in the case of a separate memory access pipeline, certain embodiments are implemented in which only the execution cluster of this pipeline has the memory access unit(s) circuitry <b>364</b>). It should also be understood that where separate pipelines are used, one or more of these pipelines may be out-of-order issue/execution and the rest in-order.</p><p id="p-0061" num="0060">In some embodiments, the execution engine unit circuitry <b>350</b> may perform load store unit (LSU) address/data pipelining to an Advanced Microcontroller Bus (AHB) interface (not shown), and address phase and writeback, data phase load, store, and branches.</p><p id="p-0062" num="0061">The set of memory access circuitry <b>364</b> is coupled to the memory unit circuitry <b>370</b>, which includes data TLB unit circuitry <b>372</b> coupled to a data cache circuitry <b>374</b> coupled to a level 2 (L2) cache circuitry <b>376</b>. In one exemplary embodiment, the memory access units circuitry <b>364</b> may include a load unit circuitry, a store address unit circuit, and a store data unit circuitry, each of which is coupled to the data TLB circuitry <b>372</b> in the memory unit circuitry <b>370</b>. The instruction cache circuitry <b>334</b> is further coupled to a level 2 (L2) cache unit circuitry <b>376</b> in the memory unit circuitry <b>370</b>. In one embodiment, the instruction cache <b>334</b> and the data cache <b>374</b> are combined into a single instruction and data cache (not shown) in L2 cache unit circuitry <b>376</b>, a level 3 (L3) cache unit circuitry (not shown), and/or main memory. The L2 cache unit circuitry <b>376</b> is coupled to one or more other levels of cache and eventually to a main memory.</p><p id="p-0063" num="0062">The core <b>390</b> may support one or more instructions sets (e.g., the x86 instruction set (with some extensions that have been added with newer versions); the MIPS instruction set; the ARM instruction set (with optional additional extensions such as NEON)), including the instruction(s) described herein. In one embodiment, the core <b>390</b> includes logic to support a packed data instruction set extension (e.g., AVX1, AVX2), thereby allowing the operations used by many multimedia applications to be performed using packed data.</p><heading id="h-0010" level="2">Exemplary Execution Unit(s) Circuitry</heading><p id="p-0064" num="0063"><figref idref="DRAWINGS">FIG. <b>4</b></figref> illustrates embodiments of execution unit(s) circuitry, such as execution unit(s) circuitry <b>362</b> of <figref idref="DRAWINGS">FIG. <b>3</b>(B)</figref>. As illustrated, execution unit(s) circuitry <b>362</b> may include one or more ALU circuits <b>401</b>, vector/SIMD unit circuits <b>403</b>, load/store unit circuits <b>405</b>, and/or branch/jump unit circuits <b>407</b>. ALU circuits <b>401</b> perform integer arithmetic and/or Boolean operations. Vector/SIMD unit circuits <b>403</b> perform vector/SIMD operations on packed data (such as SIMD/vector registers). Load/store unit circuits <b>405</b> execute load and store instructions to load data from memory into registers or store from registers to memory. Load/store unit circuits <b>405</b> may also generate addresses. Branch/jump unit circuits <b>407</b> cause a branch or jump to a memory address depending on the instruction. Floating-point unit (FPU) circuits <b>409</b> perform floating-point arithmetic. The width of the execution unit(s) circuitry <b>362</b> varies depending upon the embodiment and can range from 16-bit to 1,024-bit. In some embodiments, two or more smaller execution units are logically combined to form a larger execution unit (e.g., two 128-bit execution units are logically combined to form a 256-bit execution unit).</p><heading id="h-0011" level="2">Exemplary Register Architecture</heading><p id="p-0065" num="0064"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a block diagram of a register architecture <b>500</b> according to some embodiments. As illustrated, there are vector/SIMD registers <b>510</b> that vary from 128-bit to 1,024 bits width. In some embodiments, the vector/SIMD registers <b>510</b> are physically 512-bits and, depending upon the mapping, only some of the lower bits are used. For example, in some embodiments, the vector/SIMD registers <b>510</b> are ZMM registers which are 512 bits: the lower 256 bits are used for YMM registers and the lower 128 bits are used for XMM registers. As such, there is an overlay of registers. In some embodiments, a vector length field selects between a maximum length and one or more other shorter lengths, where each such shorter length is half the length of the preceding length. Scalar operations are operations performed on the lowest order data element position in a ZMM/YMM/XMM register; the higher order data element positions are either left the same as they were prior to the instruction or zeroed depending on the embodiment.</p><p id="p-0066" num="0065">In some embodiments, the register architecture <b>500</b> includes writemask/predicate registers <b>515</b>. For example, in some embodiments, there are 8 writemask/predicate registers (sometimes called k0 through k7) that are each 16-bit, 32-bit, 64-bit, or 128-bit in size. Writemask/predicate registers <b>515</b> may allow for merging (e.g., allowing any set of elements in the destination to be protected from updates during the execution of any operation) and/or zeroing (e.g., zeroing vector masks allow any set of elements in the destination to be zeroed during the execution of any operation). In some embodiments, each data element position in a given writemask/predicate register <b>515</b> corresponds to a data element position of the destination. In other embodiments, the writemask/predicate registers <b>515</b> are scalable and consists of a set number of enable bits for a given vector element (e.g., 8 enable bits per 64-bit vector element).</p><p id="p-0067" num="0066">The register architecture <b>500</b> includes a plurality of general-purpose registers <b>525</b>. These registers may be 16-bit, 32-bit, 64-bit, etc. and can be used for scalar operations. In some embodiments, these registers are referenced by the names RAX, RBX, RCX, RDX, RBP, RSI, RDI, RSP, and R8 through R15.</p><p id="p-0068" num="0067">In some embodiments, the register architecture <b>500</b> includes scalar floating-point register <b>545</b> which is used for scalar floating-point operations on 32/64/80-bit floating-point data using the x87 instruction set extension or as MMX registers to perform operations on 64-bit packed integer data, as well as to hold operands for some operations performed between the MMX and XMM registers.</p><p id="p-0069" num="0068">One or more flag registers <b>540</b> (e.g., EFLAGS, RFLAGS, etc.) store status and control information for arithmetic, compare, and system operations. For example, the one or more flag registers <b>540</b> may store condition code information such as carry, parity, auxiliary carry, zero, sign, and overflow. In some embodiments, the one or more flag registers <b>540</b> are called program status and control registers.</p><p id="p-0070" num="0069">Segment registers <b>520</b> contain segment points for use in accessing memory. In some embodiments, these registers are referenced by the names CS, DS, SS, ES, FS, and GS.</p><p id="p-0071" num="0070">Machine specific registers (MSRs) <b>535</b> control and report on processor performance. Most MSRs <b>535</b> handle system-related functions and are not accessible to an application program. Machine check registers <b>560</b> consist of control, status, and error reporting MSRs that are used to detect and report on hardware errors.</p><p id="p-0072" num="0071">One or more instruction pointer register(s) <b>530</b> store an instruction pointer value. Control register(s) <b>555</b> (e.g., CR0-CR4) determine the operating mode of a processor (e.g., processor <b>170</b>, <b>180</b>, <b>138</b>, <b>115</b>, and/or <b>200</b>) and the characteristics of a currently executing task. Debug registers <b>550</b> control and allow for the monitoring of a processor or core's debugging operations.</p><p id="p-0073" num="0072">Memory management registers <b>565</b> specify the locations of data structures used in protected mode memory management. These registers may include a GDTR, IDRT, task register, and a LDTR register.</p><p id="p-0074" num="0073">Alternative embodiments of the invention may use wider or narrower registers. Additionally, alternative embodiments of the invention may use more, less, or different register files and registers.</p><heading id="h-0012" level="2">Instruction Sets</heading><p id="p-0075" num="0074">An instruction set architecture (ISA) may include one or more instruction formats. A given instruction format may define various fields (e.g., number of bits, location of bits) to specify, among other things, the operation to be performed (e.g., opcode) and the operand(s) on which that operation is to be performed and/or other data field(s) (e.g., mask). Some instruction formats are further broken down though the definition of instruction templates (or sub-formats). For example, the instruction templates of a given instruction format may be defined to have different subsets of the instruction format's fields (the included fields are typically in the same order, but at least some have different bit positions because there are less fields included) and/or defined to have a given field interpreted differently. Thus, each instruction of an ISA is expressed using a given instruction format (and, if defined, in a given one of the instruction templates of that instruction format) and includes fields for specifying the operation and the operands. For example, an exemplary ADD instruction has a specific opcode and an instruction format that includes an opcode field to specify that opcode and operand fields to select operands (source1/destination and source2); and an occurrence of this ADD instruction in an instruction stream will have specific contents in the operand fields that select specific operands.</p><heading id="h-0013" level="2">Exemplary Instruction Formats</heading><p id="p-0076" num="0075">Embodiments of the instruction(s) described herein may be embodied in different formats. Additionally, exemplary systems, architectures, and pipelines are detailed below. Embodiments of the instruction(s) may be executed on such systems, architectures, and pipelines, but are not limited to those detailed.</p><p id="p-0077" num="0076"><figref idref="DRAWINGS">FIG. <b>6</b></figref> illustrates embodiments of an instruction format. As illustrated, an instruction may include multiple components including, but not limited to, one or more fields for: one or more prefixes <b>601</b>, an opcode <b>603</b>, addressing information <b>605</b> (e.g., register identifiers, memory addressing information, etc.), a displacement value <b>607</b>, and/or an immediate <b>609</b>. Note that some instructions utilize some or all of the fields of the format whereas others may only use the field for the opcode <b>603</b>. In some embodiments, the order illustrated is the order in which these fields are to be encoded, however, it should be appreciated that in other embodiments these fields may be encoded in a different order, combined, etc.</p><p id="p-0078" num="0077">The prefix(es) field(s) <b>601</b>, when used, modifies an instruction. In some embodiments, one or more prefixes are used to repeat string instructions (e.g., 0xF0, 0xF2, 0xF3, etc.), to provide section overrides (e.g., 0x2E, 0x36, 0x3E, 0x26, 0x64, 0x65, 0x2E, 0x3E, etc.), to perform bus lock operations, and/or to change operand (e.g., 0x66) and address sizes (e.g., 0x67). Certain instructions require a mandatory prefix (e.g., 0x66, 0xF2, 0xF3, etc.). Certain of these prefixes may be considered &#x201c;legacy&#x201d; prefixes. Other prefixes, one or more examples of which are detailed herein, indicate, and/or provide further capability, such as specifying particular registers, etc. The other prefixes typically follow the &#x201c;legacy&#x201d; prefixes.</p><p id="p-0079" num="0078">The opcode field <b>603</b> is used to at least partially define the operation to be performed upon a decoding of the instruction. In some embodiments, a primary opcode encoded in the opcode field <b>603</b> is 1, 2, or 3 bytes in length. In other embodiments, a primary opcode can be a different length. An additional 3-bit opcode field is sometimes encoded in another field.</p><p id="p-0080" num="0079">The addressing field <b>605</b> is used to address one or more operands of the instruction, such as a location in memory or one or more registers. <figref idref="DRAWINGS">FIG. <b>7</b></figref> illustrates embodiments of the addressing field <b>605</b>. In this illustration, an optional ModR/M byte <b>702</b> and an optional Scale, Index, Base (SIB) byte <b>704</b> are shown. The ModR/M byte <b>702</b> and the SIB byte <b>704</b> are used to encode up to two operands of an instruction, each of which is a direct register or effective memory address. Note that each of these fields are optional in that not all instructions include one or more of these fields. The MOD R/M byte <b>702</b> includes a MOD field <b>742</b>, a register field <b>744</b>, and R/M field <b>746</b>.</p><p id="p-0081" num="0080">The content of the MOD field <b>742</b> distinguishes between memory access and non-memory access modes. In some embodiments, when the MOD field <b>742</b> has a value of b11, a register-direct addressing mode is utilized, and otherwise register-indirect addressing is used.</p><p id="p-0082" num="0081">The register field <b>744</b> may encode either the destination register operand or a source register operand, or may encode an opcode extension and not be used to encode any instruction operand. The content of register index field <b>744</b>, directly or through address generation, specifies the locations of a source or destination operand (either in a register or in memory). In some embodiments, the register field <b>744</b> is supplemented with an additional bit from a prefix (e.g., prefix <b>601</b>) to allow for greater addressing.</p><p id="p-0083" num="0082">The R/M field <b>746</b> may be used to encode an instruction operand that references a memory address, or may be used to encode either the destination register operand or a source register operand. Note the R/M field <b>746</b> may be combined with the MOD field <b>742</b> to dictate an addressing mode in some embodiments.</p><p id="p-0084" num="0083">The SIB byte <b>704</b> includes a scale field <b>752</b>, an index field <b>754</b>, and a base field <b>756</b> to be used in the generation of an address. The scale field <b>752</b> indicates scaling factor. The index field <b>754</b> specifies an index register to use. In some embodiments, the index field <b>754</b> is supplemented with an additional bit from a prefix (e.g., prefix <b>601</b>) to allow for greater addressing. The base field <b>756</b> specifies a base register to use. In some embodiments, the base field <b>756</b> is supplemented with an additional bit from a prefix (e.g., prefix <b>601</b>) to allow for greater addressing. In practice, the content of the scale field <b>752</b> allows for the scaling of the content of the index field <b>754</b> for memory address generation (e.g., for address generation that uses 2<sup>scale</sup>*index+base).</p><p id="p-0085" num="0084">Some addressing forms utilize a displacement value to generate a memory address. For example, a memory address may be generated according to 2<sup>scale</sup>*index+base+displacement, index*scale+displacement, r/m+displacement, instruction pointer (RIP/EIP)+displacement, register+displacement, etc. The displacement may be a 1-byte, 2-byte, 4-byte, etc. value. In some embodiments, a displacement field <b>607</b> provides this value. Additionally, in some embodiments, a displacement factor usage is encoded in the MOD field of the addressing field <b>605</b> that indicates a compressed displacement scheme for which a displacement value is calculated by multiplying disp8 in conjunction with a scaling factor N that is determined based on the vector length, the value of a b bit, and the input element size of the instruction. The displacement value is stored in the displacement field <b>607</b>.</p><p id="p-0086" num="0085">In some embodiments, an immediate field <b>609</b> specifies an immediate for the instruction. An immediate may be encoded as a 1-byte value, a 2-byte value, a 4-byte value, etc.</p><p id="p-0087" num="0086"><figref idref="DRAWINGS">FIG. <b>8</b></figref> illustrates embodiments of a first prefix <b>601</b>(A). In some embodiments, the first prefix <b>601</b>(A) is an embodiment of a REX prefix. Instructions that use this prefix may specify general purpose registers, 64-bit packed data registers (e.g., single instruction, multiple data (SIMD) registers or vector registers), and/or control registers and debug registers (e.g., CR8-CR15 and DR8-DR15).</p><p id="p-0088" num="0087">Instructions using the first prefix <b>601</b>(A) may specify up to three registers using 3-bit fields depending on the format: 1) using the reg field <b>744</b> and the R/M field <b>746</b> of the Mod R/M byte <b>702</b>; 2) using the Mod R/M byte <b>702</b> with the SIB byte <b>704</b> including using the reg field <b>744</b> and the base field <b>756</b> and index field <b>754</b>; or 3) using the register field of an opcode.</p><p id="p-0089" num="0088">In the first prefix <b>601</b>(A), bit positions 7:4 are set as 0100. Bit position 3 (W) can be used to determine the operand size, but may not solely determine operand width. As such, when W=0, the operand size is determined by a code segment descriptor (CS.D) and when W=1, the operand size is 64-bit.</p><p id="p-0090" num="0089">Note that the addition of another bit allows for 16 (2<sup>4</sup>) registers to be addressed, whereas the MOD R/M reg field <b>744</b> and MOD R/M R/M field <b>746</b> alone can each only address 8 registers.</p><p id="p-0091" num="0090">In the first prefix <b>601</b>(A), bit position 2 (R) may an extension of the MOD R/M reg field <b>744</b> and may be used to modify the ModR/M reg field <b>744</b> when that field encodes a general purpose register, a 64-bit packed data register (e.g., a SSE register), or a control or debug register. R is ignored when Mod R/M byte <b>702</b> specifies other registers or defines an extended opcode.</p><p id="p-0092" num="0091">Bit position 1 (X) X bit may modify the SIB byte index field <b>754</b>.</p><p id="p-0093" num="0092">Bit position B (B) B may modify the base in the Mod R/M R/M field <b>746</b> or the SIB byte base field <b>756</b>; or it may modify the opcode register field used for accessing general purpose registers (e.g., general purpose registers <b>525</b>).</p><p id="p-0094" num="0093"><figref idref="DRAWINGS">FIGS. <b>9</b>(A)</figref>-(D) illustrate embodiments of how the R, X, and B fields of the first prefix <b>601</b>(A) are used. <figref idref="DRAWINGS">FIG. <b>9</b>(A)</figref> illustrates R and B from the first prefix <b>601</b>(A) being used to extend the reg field <b>744</b> and R/M field <b>746</b> of the MOD R/M byte <b>702</b> when the SIB byte <b>7</b> <b>04</b> is not used for memory addressing. <figref idref="DRAWINGS">FIG. <b>9</b>(B)</figref> illustrates R and B from the first prefix <b>601</b>(A) being used to extend the reg field <b>744</b> and R/M field <b>746</b> of the MOD R/M byte <b>702</b> when the SIB byte <b>7</b> <b>04</b> is not used (register-register addressing). <figref idref="DRAWINGS">FIG. <b>9</b>(C)</figref> illustrates R, X, and B from the first prefix <b>601</b>(A) being used to extend the reg field <b>744</b> of the MOD R/M byte <b>702</b> and the index field <b>754</b> and base field <b>756</b> when the SIB byte <b>7</b> <b>04</b> being used for memory addressing. <figref idref="DRAWINGS">FIG. <b>9</b>(D)</figref> illustrates B from the first prefix <b>601</b>(A) being used to extend the reg field <b>744</b> of the MOD R/M byte <b>702</b> when a register is encoded in the opcode <b>603</b>.</p><p id="p-0095" num="0094"><figref idref="DRAWINGS">FIGS. <b>10</b>(A)</figref>-(B) illustrate embodiments of a second prefix <b>601</b>(B). In some embodiments, the second prefix <b>601</b>(B) is an embodiment of a VEX prefix. The second prefix <b>601</b>(B) encoding allows instructions to have more than two operands, and allows SIMD vector registers (e.g., vector/SIMD registers <b>510</b>) to be longer than 64-bits (e.g., 128-bit and 256-bit). The use of the second prefix <b>601</b>(B) provides for three-operand (or more) syntax. For example, previous two-operand instructions performed operations such as A=A+B, which overwrites a source operand. The use of the second prefix <b>601</b>(B) enables operands to perform nondestructive operations such asA=B+C.</p><p id="p-0096" num="0095">In some embodiments, the second prefix <b>601</b>(B) comes in two forms&#x2014;a two-byte form and a three-byte form. The two-byte second prefix <b>601</b>(B) is used mainly for 128-bit, scalar, and some 256-bit instructions; while the three-byte second prefix <b>601</b>(B) provides a compact replacement of the first prefix <b>601</b>(A) and 3-byte opcode instructions.</p><p id="p-0097" num="0096"><figref idref="DRAWINGS">FIG. <b>10</b>(A)</figref> illustrates embodiments of a two-byte form of the second prefix <b>601</b>(B). In one example, a format field <b>1001</b> (byte 0 <b>1003</b>) contains the value C5H. In one example, byte 1 <b>1005</b> includes a &#x201c;R&#x201d; value in bit[<b>7</b>]. This value is the complement of the same value of the first prefix <b>601</b>(A). Bit[2] is used to dictate the length (L) of the vector (where a value of 0 is a scalar or 128-bit vector and a value of 1 is a 256-bit vector). Bits[1:0] provide opcode extensionality equivalent to some legacy prefixes (e.g., 00=no prefix, 01=66H, 10=F3H, and 11=F2H). Bits[6:3] shown as vvvv may be used to: 1) encode the first source register operand, specified in inverted (is complement) form and valid for instructions with 2 or more source operands; 2) encode the destination register operand, specified in is complement form for certain vector shifts; or 3) not encode any operand, the field is reserved and should contain a certain value, such as 1111b.</p><p id="p-0098" num="0097">Instructions that use this prefix may use the Mod R/M R/M field <b>746</b> to encode the instruction operand that references a memory address or encode either the destination register operand or a source register operand.</p><p id="p-0099" num="0098">Instructions that use this prefix may use the Mod R/M reg field <b>744</b> to encode either the destination register operand or a source register operand, be treated as an opcode extension and not used to encode any instruction operand.</p><p id="p-0100" num="0099">For instruction syntax that support four operands, vvvv, the Mod R/M R/M field <b>746</b> and the Mod R/M reg field <b>744</b> encode three of the four operands. Bits[7:4] of the immediate <b>609</b> are then used to encode the third source register operand.</p><p id="p-0101" num="0100"><figref idref="DRAWINGS">FIG. <b>10</b>(B)</figref> illustrates embodiments of a three-byte form of the second prefix <b>601</b>(B). In one example, a format field <b>1011</b> (byte 0 <b>1013</b>) contains the value C4H. Byte 1 <b>1015</b> includes in bits[7:5] &#x201c;R,&#x201d; &#x201c;X,&#x201d; and &#x201c;B&#x201d; which are the complements of the same values of the first prefix <b>601</b>(A). Bits[4:0] of byte 1 <b>1015</b> (shown as mmmmm) include content to encode, as need, one or more implied leading opcode bytes. For example, 00001 implies a OFH leading opcode, 00010 implies a 0F38H leading opcode, 00011 implies a leading 0F3AH opcode, etc.</p><p id="p-0102" num="0101">Bit[7] of byte 2 <b>1017</b> is used similar to W of the first prefix <b>601</b>(A) including helping to determine promotable operand sizes. Bit[2] is used to dictate the length (L) of the vector (where a value of 0 is a scalar or 128-bit vector and a value of 1 is a 256-bit vector). Bits[1:0] provide opcode extensionality equivalent to some legacy prefixes (e.g., 00=no prefix, 01=66H, 10=F3H, and 11=F2H). Bits[6:3], shown as vvvv, may be used to: 1) encode the first source register operand, specified in inverted (is complement) form and valid for instructions with 2 or more source operands; 2) encode the destination register operand, specified in is complement form for certain vector shifts; or 3) not encode any operand, the field is reserved and should contain a certain value, such as 1111b.</p><p id="p-0103" num="0102">Instructions that use this prefix may use the Mod R/M R/M field <b>746</b> to encode the instruction operand that references a memory address or encode either the destination register operand or a source register operand.</p><p id="p-0104" num="0103">Instructions that use this prefix may use the Mod R/M reg field <b>744</b> to encode either the destination register operand or a source register operand, be treated as an opcode extension and not used to encode any instruction operand.</p><p id="p-0105" num="0104">For instruction syntax that support four operands, vvvv, the Mod R/M R/M field <b>746</b>, and the Mod R/M reg field <b>744</b> encode three of the four operands. Bits[7:4] of the immediate <b>609</b> are then used to encode the third source register operand.</p><p id="p-0106" num="0105"><figref idref="DRAWINGS">FIG. <b>11</b></figref> illustrates embodiments of a third prefix <b>601</b>(C). In some embodiments, the first prefix <b>601</b>(A) is an embodiment of an EVEX prefix. The third prefix <b>601</b>(C) is a four-byte prefix.</p><p id="p-0107" num="0106">The third prefix <b>601</b>(C) can encode 32 vector registers (e.g., 128-bit, 256-bit, and 512-bit registers) in 64-bit mode. In some embodiments, instructions that utilize a writemask/opmask (see discussion of registers in a previous figure, such as <figref idref="DRAWINGS">FIG. <b>5</b></figref>) or predication utilize this prefix. Opmask register allow for conditional processing or selection control. Opmask instructions, whose source/destination operands are opmask registers and treat the content of an opmask register as a single value, are encoded using the second prefix <b>601</b>(B).</p><p id="p-0108" num="0107">The third prefix <b>601</b>(C) may encode functionality that is specific to instruction classes (e.g., a packed instruction with &#x201c;load+op&#x201d; semantic can support embedded broadcast functionality, a floating-point instruction with rounding semantic can support static rounding functionality, a floating-point instruction with non-rounding arithmetic semantic can support &#x201c;suppress all exceptions&#x201d; functionality, etc.).</p><p id="p-0109" num="0108">The first byte of the third prefix <b>601</b>(C) is a format field <b>1111</b> that has a value, in one example, of 62H. Subsequent bytes are referred to as payload bytes <b>1115</b>-<b>1119</b> and collectively form a 24-bit value of P[23:0] providing specific capability in the form of one or more fields (detailed herein).</p><p id="p-0110" num="0109">In some embodiments, P[1:0] of payload byte <b>1119</b> are identical to the low two mmmmm bits. P[3:2] are reserved in some embodiments. Bit P[4] (R&#x2032;) allows access to the high 16 vector register set when combined with P[7] and the ModR/M reg field <b>744</b>. P[6] can also provide access to a high 16 vector register when SIB-type addressing is not needed. P[7:5] consist of an R, X, and B which are operand specifier modifier bits for vector register, general purpose register, memory addressing and allow access to the next set of 8 registers beyond the low 8 registers when combined with the ModR/M register field <b>744</b> and ModR/M R/M field <b>746</b>. P[9:8] provide opcode extensionality equivalent to some legacy prefixes (e.g., 00=no prefix, 01=66H, 10=F3H, and 11=F2H). P[10] in some embodiments is a fixed value of 1. P[14:11], shown as vvvv, may be used to: 1) encode the first source register operand, specified in inverted (is complement) form and valid for instructions with 2 or more source operands; 2) encode the destination register operand, specified in is complement form for certain vector shifts; or 3) not encode any operand, the field is reserved and should contain a certain value, such as 1111b.</p><p id="p-0111" num="0110">P[15] is similar to W of the first prefix <b>601</b>(A) and second prefix <b>611</b>(B) and may serve as an opcode extension bit or operand size promotion.</p><p id="p-0112" num="0111">P[18:16] specify the index of a register in the opmask (writemask) registers (e.g., writemask/predicate registers <b>515</b>). In one embodiment of the invention, the specific value aaa=000 has a special behavior implying no opmask is used for the particular instruction (this may be implemented in a variety of ways including the use of a opmask hardwired to all ones or hardware that bypasses the masking hardware). When merging, vector masks allow any set of elements in the destination to be protected from updates during the execution of any operation (specified by the base operation and the augmentation operation); in other one embodiment, preserving the old value of each element of the destination where the corresponding mask bit has a 0. In contrast, when zeroing vector masks allow any set of elements in the destination to be zeroed during the execution of any operation (specified by the base operation and the augmentation operation); in one embodiment, an element of the destination is set to 0 when the corresponding mask bit has a 0 value. A subset of this functionality is the ability to control the vector length of the operation being performed (that is, the span of elements being modified, from the first to the last one); however, it is not necessary that the elements that are modified be consecutive. Thus, the opmask field allows for partial vector operations, including loads, stores, arithmetic, logical, etc. While embodiments of the invention are described in which the opmask field's content selects one of a number of opmask registers that contains the opmask to be used (and thus the opmask field's content indirectly identifies that masking to be performed), alternative embodiments instead or additional allow the mask write field's content to directly specify the masking to be performed.</p><p id="p-0113" num="0112">P[19] can be combined with P[14:11] to encode a second source vector register in a non-destructive source syntax which can access an upper 16 vector registers using P[19]. P[20] encodes multiple functionalities, which differs across different classes of instructions and can affect the meaning of the vector length/rounding control specifier field (P[22:21]). P[23] indicates support for merging-writemasking (e.g., when set to 0) or support for zeroing and merging-writemasking (e.g., when set to 1).</p><p id="p-0114" num="0113">Exemplary embodiments of encoding of registers in instructions using the third prefix <b>601</b>(C) are detailed in the following tables.</p><p id="p-0115" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 1</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>32-Register Support in 64-bit Mode</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="center"/><colspec colname="2" colwidth="14pt" align="center"/><colspec colname="3" colwidth="21pt" align="center"/><colspec colname="4" colwidth="35pt" align="center"/><colspec colname="5" colwidth="49pt" align="center"/><colspec colname="6" colwidth="70pt" align="center"/><tbody valign="top"><row><entry/><entry>4</entry><entry>3</entry><entry>[2:0]</entry><entry>REG. TYPE</entry><entry>COMMON USAGES</entry></row><row><entry namest="1" nameend="6" align="center" rowsep="1"/></row><row><entry>REG</entry><entry>R&#x2032;</entry><entry>R</entry><entry>ModR/M</entry><entry>GPR,</entry><entry>Destination or Source</entry></row><row><entry/><entry/><entry/><entry>reg</entry><entry>Vector</entry><entry/></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="5"><colspec colname="1" colwidth="28pt" align="center"/><colspec colname="2" colwidth="14pt" align="center"/><colspec colname="3" colwidth="56pt" align="center"/><colspec colname="4" colwidth="49pt" align="center"/><colspec colname="5" colwidth="70pt" align="center"/><tbody valign="top"><row><entry>VVVV</entry><entry>V&#x2032;</entry><entry>vvvv</entry><entry>GPR,</entry><entry>2nd Source or</entry></row><row><entry/><entry/><entry/><entry>Vector</entry><entry>Destination</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="6"><colspec colname="1" colwidth="28pt" align="center"/><colspec colname="2" colwidth="14pt" align="center"/><colspec colname="3" colwidth="21pt" align="center"/><colspec colname="4" colwidth="35pt" align="center"/><colspec colname="5" colwidth="49pt" align="center"/><colspec colname="6" colwidth="70pt" align="center"/><tbody valign="top"><row><entry>RM</entry><entry>X</entry><entry>B</entry><entry>ModR/M</entry><entry>GPR,</entry><entry>1st Source or</entry></row><row><entry/><entry/><entry/><entry>R/M</entry><entry>Vector</entry><entry>Destination</entry></row><row><entry>BASE</entry><entry>0</entry><entry>B</entry><entry>ModR/M</entry><entry>GPR</entry><entry>Memory addressing</entry></row><row><entry/><entry/><entry/><entry>R/M</entry><entry/><entry/></row><row><entry>INDEX</entry><entry>0</entry><entry>X</entry><entry>SIB.index</entry><entry>GPR</entry><entry>Memory addressing</entry></row><row><entry>VIDX</entry><entry>V&#x2032;</entry><entry>X</entry><entry>SIB.index</entry><entry>Vector</entry><entry>VSIB memory</entry></row><row><entry/><entry/><entry/><entry/><entry/><entry>addressing</entry></row><row><entry namest="1" nameend="6" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0116" num="0000"><tables id="TABLE-US-00002" num="00002"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 2</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Encoding Register Specifiers in 32-bit Mode</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="35pt" align="center"/><colspec colname="2" colwidth="49pt" align="center"/><colspec colname="3" colwidth="56pt" align="center"/><colspec colname="4" colwidth="77pt" align="center"/><tbody valign="top"><row><entry/><entry>[2:0]</entry><entry>REG. TYPE</entry><entry>COMMON USAGES</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row><row><entry>REG</entry><entry>ModR/M reg</entry><entry>GPR, Vector</entry><entry>Destination or Source</entry></row><row><entry>VVVV</entry><entry>vvvv</entry><entry>GPR, Vector</entry><entry>2<sup>nd </sup>Source or Destination</entry></row><row><entry>RM</entry><entry>ModR/M R/M</entry><entry>GPR, Vector</entry><entry>1<sup>st </sup>Source or Destination</entry></row><row><entry>BASE</entry><entry>ModR/M R/M</entry><entry>GPR</entry><entry>Memory addressing</entry></row><row><entry>INDEX</entry><entry>SIB.index</entry><entry>GPR</entry><entry>Memory addressing</entry></row><row><entry>VIDX</entry><entry>SIB.index</entry><entry>Vector</entry><entry>VSIB memory addressing</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0117" num="0000"><tables id="TABLE-US-00003" num="00003"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 3</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Opmask Register Specifier Encoding</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="4"><colspec colname="1" colwidth="28pt" align="center"/><colspec colname="2" colwidth="63pt" align="center"/><colspec colname="3" colwidth="42pt" align="center"/><colspec colname="4" colwidth="84pt" align="center"/><tbody valign="top"><row><entry/><entry>[2:0]</entry><entry>REG. TYPE</entry><entry>COMMON USAGES</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row><row><entry>REG</entry><entry>ModR/M Reg</entry><entry>k0-k7</entry><entry>Source</entry></row><row><entry>VVVV</entry><entry>vvvv</entry><entry>k0-k7</entry><entry>2<sup>nd </sup>Source</entry></row><row><entry>RM</entry><entry>ModR/M R/M</entry><entry>k0-7</entry><entry>1<sup>st </sup>Source</entry></row><row><entry>{k1}</entry><entry>aaa</entry><entry>k0<sup>1</sup>-k7</entry><entry>Opmask</entry></row><row><entry namest="1" nameend="4" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0118" num="0114">Program code may be applied to input instructions to perform the functions described herein and generate output information. The output information may be applied to one or more output devices, in known fashion. For purposes of this application, a processing system includes any system that has a processor, such as, for example, a digital signal processor (DSP), a microcontroller, an application specific integrated circuit (ASIC), or a microprocessor.</p><p id="p-0119" num="0115">The program code may be implemented in a high-level procedural or object-oriented programming language to communicate with a processing system. The program code may also be implemented in assembly or machine language, if desired. In fact, the mechanisms described herein are not limited in scope to any particular programming language. In any case, the language may be a compiled or interpreted language.</p><p id="p-0120" num="0116">Embodiments of the mechanisms disclosed herein may be implemented in hardware, software, firmware, or a combination of such implementation approaches. Embodiments of the invention may be implemented as computer programs or program code executing on programmable systems comprising at least one processor, a storage system (including volatile and non-volatile memory and/or storage elements), at least one input device, and at least one output device.</p><p id="p-0121" num="0117">One or more aspects of at least one embodiment may be implemented by representative instructions stored on a machine-readable medium which represents various logic within the processor, which when read by a machine causes the machine to fabricate logic to perform the techniques described herein. Such representations, known as &#x201c;IP cores&#x201d; may be stored on a tangible, machine readable medium and supplied to various customers or manufacturing facilities to load into the fabrication machines that actually make the logic or processor.</p><p id="p-0122" num="0118">Such machine-readable storage media may include, without limitation, non-transitory, tangible arrangements of articles manufactured or formed by a machine or device, including storage media such as hard disks, any other type of disk including floppy disks, optical disks, compact disk read-only memories (CD-ROMs), compact disk rewritable's (CD-RWs), and magneto-optical disks, semiconductor devices such as read-only memories (ROMs), random access memories (RAMs) such as dynamic random access memories (DRAMs), static random access memories (SRAMs), erasable programmable read-only memories (EPROMs), flash memories, electrically erasable programmable read-only memories (EEPROMs), phase change memory (PCM), magnetic or optical cards, or any other type of media suitable for storing electronic instructions.</p><p id="p-0123" num="0119">Accordingly, embodiments of the invention also include non-transitory, tangible machine-readable media containing instructions or containing design data, such as Hardware Description Language (HDL), which defines structures, circuits, apparatuses, processors and/or system features described herein. Such embodiments may also be referred to as program products.</p><heading id="h-0014" level="2">Emulation (Including Binary Translation, Code Morphing, Etc.)</heading><p id="p-0124" num="0120">In some cases, an instruction converter may be used to convert an instruction from a source instruction set to a target instruction set. For example, the instruction converter may translate (e.g., using static binary translation, dynamic binary translation including dynamic compilation), morph, emulate, or otherwise convert an instruction to one or more other instructions to be processed by the core. The instruction converter may be implemented in software, hardware, firmware, or a combination thereof. The instruction converter may be on processor, off processor, or part on and part off processor.</p><p id="p-0125" num="0121"><figref idref="DRAWINGS">FIG. <b>12</b></figref> illustrates a block diagram contrasting the use of a software instruction converter to convert binary instructions in a source instruction set to binary instructions in a target instruction set according to embodiments of the invention. In the illustrated embodiment, the instruction converter is a software instruction converter, although alternatively the instruction converter may be implemented in software, firmware, hardware, or various combinations thereof. <figref idref="DRAWINGS">FIG. <b>12</b></figref> shows a program in a high level language <b>1202</b> may be compiled using a first ISA compiler <b>1204</b> to generate first ISA binary code <b>1206</b> that may be natively executed by a processor with at least one first instruction set core <b>1216</b>. The processor with at least one first ISA instruction set core <b>1216</b> represents any processor that can perform substantially the same functions as an Intel&#xae; processor with at least one first ISA instruction set core by compatibly executing or otherwise processing (1) a substantial portion of the instruction set of the first ISA instruction set core or (2) object code versions of applications or other software targeted to run on an Intel processor with at least one first ISA instruction set core, in order to achieve substantially the same result as a processor with at least one first ISA instruction set core. The first ISA compiler <b>1204</b> represents a compiler that is operable to generate first ISA binary code <b>1206</b> (e.g., object code) that can, with or without additional linkage processing, be executed on the processor with at least one first ISA instruction set core <b>1216</b>.</p><p id="p-0126" num="0122">Similarly, <figref idref="DRAWINGS">FIG. <b>12</b></figref> shows the program in the high level language <b>1202</b> may be compiled using an alternative instruction set compiler <b>1208</b> to generate alternative instruction set binary code <b>1210</b> that may be natively executed by a processor without a first ISA instruction set core <b>1214</b>. The instruction converter <b>1212</b> is used to convert the first ISA binary code <b>1206</b> into code that may be natively executed by the processor without a first ISA instruction set core <b>1214</b>. This converted code is not likely to be the same as the alternative instruction set binary code <b>1210</b> because an instruction converter capable of this is difficult to make; however, the converted code will accomplish the general operation and be made up of instructions from the alternative instruction set. Thus, the instruction converter <b>1212</b> represents software, firmware, hardware, or a combination thereof that, through emulation, simulation or any other process, allows a processor or other electronic device that does not have a first ISA instruction set processor or core to execute the first ISA binary code <b>1206</b>.</p><heading id="h-0015" level="2">Exemplary Tile/Matrix Operations and Hardware</heading><p id="p-0127" num="0123"><figref idref="DRAWINGS">FIG. <b>13</b>A</figref> illustrates an embodiment of configured tiles. As shown, there are four tiles <b>1304</b>, <b>1306</b>, <b>1308</b>, and <b>1310</b> that are loaded from application memory <b>1302</b>. In this example, tiles T0 <b>1304</b> and T1 <b>1306</b> have K rows and N columns with 4 element bytes (e.g., single precision data). Tiles T2 <b>1308</b> and T3 <b>1310</b> have M rows and N/2 columns with 8 element bytes (e.g., double precision data). As the double precision operands are twice the width of single precision, this configuration is consistent with a palette, used to provide tile options, supplying at least 4 names with total storage of 16*N*M bytes. Depending upon the instruction encoding scheme used, the number of tiles available varies.</p><p id="p-0128" num="0124">In some embodiments, tile parameters are definable. For example, a &#x201c;palette&#x201d; is used to provide tile options. Exemplary options include, but are not limited to: the number of tile names, the number of bytes in a row of storage, the number of rows and columns in a tile, etc. For example, a maximum &#x201c;height&#x201d; (number of rows) of a tile may be defined as: Tile Max Rows=Architected Storage/(The Number of Palette Names*The Number of Bytes per row)</p><p id="p-0129" num="0125">As such, an application can be written such that a fixed usage of names will be able to take advantage of different storage sizes across implementations.</p><p id="p-0130" num="0126">Configuration of tiles is done using a tile configuration instruction (&#x201c;TILECONFIG&#x201d;), where a particular tile usage is defined in a selected palette. This declaration includes the number of tile names to be used, the requested number of rows and columns per name (tile), and, in some embodiments, the requested datatype of each tile. In some embodiments, consistency checks are performed during the execution of a TILECONFIG instruction to determine that it matches the restrictions of the palette entry.</p><p id="p-0131" num="0127"><figref idref="DRAWINGS">FIG. <b>13</b>B</figref> illustrates several examples of matrix storage. In (A), a tile is stored in memory. As shown, each &#x201c;row&#x201d; consists of four packed data elements. To get to the next &#x201c;row,&#x201d; a stride value is used. Note that rows may be consecutively stored in memory. Strided memory accesses allows for access of one row to then next when the tile storage does not map the underlying memory array row width.</p><p id="p-0132" num="0128">Tile loads from memory and stores to memory are typically strided accesses from the application memory to packed rows of data. Exemplary TILELOAD and TILESTORE instructions, or other instruction references to application memory as a TILE operand in load-op instructions, are, in some embodiments, restartable to handle (up to) 2*rows of page faults, unmasked floating point exceptions, and/or interrupts per instruction.</p><p id="p-0133" num="0129">In (B), a matrix is stored in a tile comprised of a plurality of registers such as packed data registers (single instruction, multiple data (SIMD) or vector registers). In this example, the tile is overlaid on three physical registers. Typically, consecutive registers are used, however, this need not be the case.</p><p id="p-0134" num="0130">In (C), a matrix is stored in a tile in non-register storage accessible to a fused multiple accumulate (FMA) circuit used in tile operations. This storage may be inside of a FMA, or adjacent to it. Additionally, in some embodiments, discussed below, the storage may be for a data element and not an entire row or tile.</p><p id="p-0135" num="0131">The supported parameters for the TMMA architecture are reported via CPUID. In some embodiments, the list of information includes a maximum height and a maximum SIMD dimension. Configuring the TMMA architecture requires specifying the dimensions for each tile, the element size for each tile and the palette identifier. This configuration is done by executing the TILECONFIG instruction.</p><p id="p-0136" num="0132">Successful execution of a TILECONFIG instruction enables subsequent TILE operators. A TILERELEASEALL instruction clears the tile configuration and disables the TILE operations (until the next TILECONFIG instructions executes). In some embodiments, XSAVE, XSTORE, etc. are used in context switching using tiles. In some embodiments, 2 XCRO bits are used in XSAVE, one for TILECONFIF metadata and one bit corresponding to actual tile payload data.</p><p id="p-0137" num="0133">TILECONFIG not only configures the tile usage, but also sets a state variable indicating that the program is in a region of code with tiles configured. An implementation may enumerate restrictions on other instructions that can be used with a tile region such as no usage of an existing register set, etc.</p><p id="p-0138" num="0134">Exiting a tile region is typically done with the TILERELEASEALL instruction. It takes no parameters and swiftly invalidates all tiles (indicating that the data no longer needs any saving or restoring) and clears the internal state corresponding to being in a tile region.</p><p id="p-0139" num="0135">In some embodiments, tile operations will zero any rows and any columns beyond the dimensions specified by the tile configuration. For example, tile operations will zero the data beyond the configured number of columns (factoring in the size of the elements) as each row is written. For example, with 64-byte rows and a tile configured with 10 rows and 12 columns, an operation writing FP32 elements would write each of the first 10 rows with 12*4 bytes with output/result data and zero the remaining 4*4 bytes in each row. Tile operations also fully zero any rows after the first 10 configured rows. When using 1K tile with 64-byte rows, there would be 16 rows, so in this example, the last 6 rows would also be zeroed.</p><p id="p-0140" num="0136">In some embodiments, a context restore (e.g., XRSTOR), when loading data, enforces that the data beyond the configured rows for a tile will be maintained as zero. If there is no valid configuration, all rows are zeroed. XRSTOR of tile data can load garbage in the columns beyond those configured. It should not be possible for XRSTOR to clear beyond the number of columns configured because there is not an element width associated with the tile configuration.</p><p id="p-0141" num="0137">Context save (e.g., XSAVE) exposes the entire TILE storage area when writing it to memory. If XRSTOR loaded garbage data in to the rightmost part of a tile, that data will be saved by XSAVE. XSAVE will write zeros for rows beyond the number specified for each tile.</p><p id="p-0142" num="0138">In some embodiments, tile instructions are restartable. The operations that access memory allow restart after page faults. The computational instructions that deal with floating point operations also allow for unmasked floating-point exceptions, with the masking of the exceptions controlled by a control and/or status register.</p><p id="p-0143" num="0139">To support restarting instructions after these events, the instructions store information in the start registers detailed below.</p><p id="p-0144" num="0140"><figref idref="DRAWINGS">FIG. <b>14</b></figref> illustrates an embodiment of a system utilizing a matrix (tile) operations accelerator. In this illustration, a host processor/processing system <b>1401</b> communicates commands <b>1411</b> (e.g., matrix manipulation operations such as arithmetic or matrix manipulation operations, or load and store operations) to a matrix operations accelerator <b>1407</b>. However, this is shown this way for discussion purposes only. As detailed later, this accelerator <b>1407</b> may be a part of a processing core. Typically, commands <b>1411</b> that are tile manipulation operator instructions will refer to tiles as register-register (&#x201c;reg-reg&#x201d;) or register-memory (&#x201c;reg-mem&#x201d;) format. Other commands such as TILESTORE, TILELOAD, TILECONFIG, etc., do not perform data operations on a tile. Commands may be decoded instructions (e.g., micro-ops) or macro-instructions for the accelerator <b>1407</b> to handle.</p><p id="p-0145" num="0141">In this example, a coherent memory interface <b>1403</b> is coupled to the host processor/processing system <b>1401</b> and matrix operations accelerator <b>1407</b> such that they can share memory.</p><p id="p-0146" num="0142"><figref idref="DRAWINGS">FIGS. <b>15</b> and <b>16</b></figref> show different embodiments of how memory is shared using a matrix operations accelerator. As shown in <figref idref="DRAWINGS">FIG. <b>15</b></figref>, the host processor <b>1501</b> and matrix operations accelerator circuitry <b>1505</b> share the same memory <b>1503</b>. <figref idref="DRAWINGS">FIG. <b>16</b></figref> illustrates an embodiment where the host processor <b>1601</b> and matrix operations accelerator <b>1605</b> do not share memory, but can access each other's memory. For example, processor <b>1601</b> can access tile memory <b>1607</b> and utilize its host memory <b>1603</b> as normal. Similarly, the matrix operations accelerator <b>1605</b> can access host memory <b>1603</b>, but more typically uses its own memory <b>1607</b>. Note these memories may be of different types.</p><p id="p-0147" num="0143">The matrix operations accelerator <b>1407</b> includes a plurality of FMAs <b>1409</b> coupled to data buffers <b>1405</b> (in some implementations, one or more of these buffers <b>1405</b> are stored in the FMAs of the grid as shown). The data buffers <b>1405</b> buffer tiles loaded from memory and/or tiles to be stored to memory (e.g., using a tileload or tilestore instruction). Data buffers may be, for example, a plurality of registers. Typically, these FMAs are arranged as a grid of chained FMAs <b>1409</b> which are able to read and write tiles. In this example, the matrix operations accelerator <b>1407</b> is to perform a matrix multiply operation using tiles T0, T1, and T2. At least one of tiles is housed in the FMA grid <b>1409</b>. In some embodiments, all tiles in an operation are stored in the FMA grid <b>1409</b>. In other embodiments, only a subset are stored in the FMA grid <b>1409</b>. As shown, T1 is housed and T0 and T2 are not. Note that A, B, and C refer to the matrices of these tiles which may or may not take up the entire space of the tile.</p><p id="p-0148" num="0144"><figref idref="DRAWINGS">FIG. <b>17</b></figref> is a block diagram illustrating processing components for executing variable-format, matrix multiplication instruction(s) <b>1703</b>, according to some embodiments. As illustrated, storage <b>1701</b> stores instruction(s) <b>1703</b> to be executed. As described further below, in some embodiments, computing system <b>1700</b> is a single instruction, multiple data (SIMD) processor to concurrently process multiple data elements based on a single instruction.</p><p id="p-0149" num="0145">In operation, the instruction <b>1703</b> is to be fetched from storage <b>1701</b> by fetch circuitry <b>1705</b>. The fetched instruction <b>1707</b> is to be decoded by decode circuitry <b>1709</b>. The instruction format, which is further illustrated and described herein, has fields (not shown here) to specify an opcode, and destination, multiplier, multiplicand, and summand complex vectors. Decode circuitry <b>1709</b> decodes the fetched instruction <b>1707</b> into one or more operations. In some embodiments, this decoding includes generating a plurality of micro-operations to be performed by execution circuitry (such as execution circuitry <b>1719</b>) in conjunction with routing circuitry <b>1718</b>. The decode circuitry <b>1709</b> also decodes instruction suffixes and prefixes (if used). Execution circuitry <b>1719</b>, operating in conjunction with routing circuitry <b>1717</b> executes the decoded instruction.</p><p id="p-0150" num="0146">In some embodiments, register renaming, register allocation, and/or scheduling circuit <b>1713</b> provides functionality for one or more of: 1) renaming logical operand values to physical operand values (e.g., a register alias table in some embodiments), 2) allocating status bits and flags to the decoded instruction, and 3) scheduling the decoded VFVSMM instruction <b>1711</b> for execution on execution circuitry <b>1719</b> out of an instruction pool (e.g., using a reservation station in some embodiments).</p><p id="p-0151" num="0147">Registers (register file) and/or memory <b>1715</b> store data as operands of decoded VFVSMM instruction <b>1711</b> to be operated on by execution circuitry <b>1719</b>. Exemplary register types include writemask registers, packed data registers, general purpose registers, and floating point registers, as further described herein. In some embodiments, write back circuit <b>1720</b> commits the result of the execution of the decoded instruction <b>1711</b>.</p><p id="p-0152" num="0148"><figref idref="DRAWINGS">FIG. <b>18</b></figref> is a block diagram of a processing array <b>1810</b> to execute a matrix multiply instruction (or sequence of instructions) to perform parallel multiply accumulate operations to multiply a first matrix <b>1802</b> (Matrix A with M&#xd7;K elements) by a second matrix <b>1804</b> (Matrix B with K&#xd7;N elements) to generate an output matrix (Matrix C). In one embodiment, the matrix multiplication instruction is a variable-sparsity matrix multiplication (VFVSMM) instruction, which performs dense-dense, sparse-dense, and sparse-sparse matrix multiplications. However, the underlying principles of the invention are not limited to any specific matrix types.</p><p id="p-0153" num="0149">In one embodiment, the processing array <b>1810</b> includes (M&#xd7;N) processing units <b>1814</b> each of which multiplies one or more data elements from the first matrix <b>1802</b> and one or more data elements from the second matrix <b>1804</b>, and accumulates the resulting products (e.g., adding the products and an accumulated value). In some embodiments, each of the processing units in the processing array <b>1810</b> is a multiply-accumulate circuit, one example of which is shown as MAC <b>1814</b>. While the illustrated MAC <b>1814</b> shows a single multiplier, each MAC <b>1814</b> may include a plurality of parallel multipliers to perform parallel multiplications. In one embodiment, the number of parallel multiplications is based on the size of the input operands. For example, each MAC unit <b>1814</b> may be capable of performing one 16-bit integer multiplication, two 8-bit integer multiplications, or four 4-bit integer multiplications, all of which may be accumulated to a 32-bit integer value. Similarly, each MAC unit <b>1814</b> may be capable of multiplying one 32-bit floating point, two 16-bit floating point values (e.g., FP16 or Bfloat16), and accumulating the result into 32-bit or 64-bit floating point value.</p><p id="p-0154" num="0150">In some embodiments, for example when processing 8-bit integer data, execution circuitry throughput is quadrupled by configuring each processing unit to perform a 2&#xd7;2 matrix multiplication.</p><p id="p-0155" num="0151">As described herein, a processing unit is sometimes referred to as a processing element, a processing circuit, or a processing node. Regardless of the wording, the processing unit is intended to comprise circuitry to perform data path computations and provide control logic.</p><p id="p-0156" num="0152">In some implementations, the tile/matrix sources contain complex numbers in the format of 16-bit floating point (FP16) pairs of real and imaginary parts: each element in the source tile is 32-bit wide complex number where the lower 16 bits represent the real part in FP16 format and the higher 16 bits represent the imaginary part in FP16 format. <figref idref="DRAWINGS">FIG. <b>19</b></figref> illustrates an example matrix&#x2014;Matrix A&#x2014;with m rows and k columns of complex data elements, where each data element includes a FP16 real component <b>1901</b> and a FP16 imaginary component <b>1902</b>. Alternatively, two separate matrices may be used for the real and imaginary components.</p><p id="p-0157" num="0153">In one embodiment, the result matrix C may include 32-bit real values (Matrix CR) or 32-bit imaginary values (Matrix CI), depending on the instruction being executed. In other embodiments, the real and imaginary values may be combined into a single result matrix (Matrix C).</p><p id="p-0158" num="0154">While certain specific data element sizes are described herein, it should be noted that the underlying principles of the invention may be implemented using various other data types for the sources and results described herein including, but not limited to, 4-bit integer, 8-bit integer, 16-bit integer, 32-bit integer, Bfloat16, TensorFloat (TF)-32, 32-bit floating-point, and 64-bit floating point (FP), to name a few.</p><heading id="h-0016" level="1">Vector Packed Signed/Unsigned Shift, Round, Saturate</heading><p id="p-0159" num="0155">In sensing applications such as convolution neural networks (CNNs) which use 32-bit, 16-bit, 8-bit, 4-bit integer data types, post processing of the data may be required following accumulation. In one embodiment, the packed signed, unsigned shift instructions described below are used to quantize the accumulator data.</p><p id="p-0160" num="0156"><figref idref="DRAWINGS">FIGS. <b>20</b>A-C</figref> illustrate different architectures in which the embodiments described herein may be implemented. In <figref idref="DRAWINGS">FIG. <b>20</b>A</figref>, matrix decode circuitry <b>2090</b> within each core <b>2001</b><i>a </i>decodes the instructions described herein and matrix execution circuitry <b>2091</b> executes the instructions. In this embodiment, the matrix processing circuitry <b>2090</b>-<b>2091</b> is integral to the pipeline of each core <b>2001</b><i>a</i>. Alternatively, in <figref idref="DRAWINGS">FIG. <b>20</b>B</figref>, a matrix processing accelerator <b>2095</b> is on the same chip and shared by a plurality of cores <b>2001</b><i>a</i>-<i>d</i>. In <figref idref="DRAWINGS">FIG. <b>20</b>C</figref>, the matrix processing accelerator <b>2096</b> is on a different chip (but potentially in the same package) as the cores <b>2001</b><i>a</i>-<i>b</i>. In each implementation, the underlying principles of the invention operate as described herein.</p><p id="p-0161" num="0157">While the signed/unsigned shift/round/saturate instructions described herein may be executed within the context of matrix operations (e.g., to perform post-processing of values resulting from matrix multiplications), these instructions may be processed directly by the decoder <b>2009</b> and execution unit <b>2008</b> (without the need for dedicated matrix circuitry).</p><p id="p-0162" num="0158">Turning first to <figref idref="DRAWINGS">FIG. <b>20</b>A</figref>, the illustrated architectures include a core region <b>2001</b> and a shared, or &#x201c;uncore&#x201d; region <b>2010</b>. The shared region <b>2010</b> includes data structures and circuitry shared by all or a subset of the cores <b>2001</b><i>a</i>-<i>b</i>. In the illustrated embodiment, the plurality of cores <b>2001</b><i>a</i>-<i>b </i>are simultaneous multithreaded cores capable of concurrently executing multiple instruction streams or threads. Although only two cores <b>2001</b><i>a</i>-<i>b </i>are illustrated in <figref idref="DRAWINGS">FIG. <b>20</b>A</figref> for simplicity, it will be appreciated that the core region <b>2001</b> may include any number of cores, each of which may include the same architecture as shown for core <b>2001</b><i>a</i>. Another embodiment includes heterogeneous cores which may have different instruction set architectures and/or different power and performance characteristics (e.g., low power cores combined with high power/performance cores).</p><p id="p-0163" num="0159">The various components illustrated in <figref idref="DRAWINGS">FIG. <b>20</b>A</figref> may be implemented in the same manner as corresponding components described above. For example, the core <b>2001</b><i>a </i>may execute the signed/unsigned shift/round/saturate instructions using one of the instruction formats and register architectures described herein. In addition, the cores <b>2001</b><i>a </i>may include the components of core <b>490</b> shown in <figref idref="DRAWINGS">FIG. <b>3</b>B</figref>, and may include any of the other processor/core components described herein (e.g., <figref idref="DRAWINGS">FIGS. <b>2</b>, <b>4</b></figref>, etc).</p><p id="p-0164" num="0160">Each of the cores <b>2001</b><i>a</i>-<i>b </i>includes instruction pipeline components for performing simultaneous execution of instruction streams including instruction fetch circuitry <b>2018</b> which fetches instructions from system memory <b>2060</b> or the L1 instruction cache <b>2010</b> and decoder <b>2009</b> to decode the instructions. Execution circuitry <b>2008</b> executes the decoded instructions to perform the underlying operations, as specified by the instruction operands, opcodes, and any immediate values.</p><p id="p-0165" num="0161">In the illustrated embodiment, the decoder <b>2009</b> includes matrix decode circuitry <b>2090</b> to decode certain instructions into uops for execution by the matrix execution circuitry <b>2091</b> (integrated within the execution circuitry <b>2008</b> in this embodiment). Although illustrated as separate blocks in <figref idref="DRAWINGS">FIG. <b>20</b>A</figref>, the matrix decode circuitry <b>2090</b> and matrix execution circuitry <b>2091</b> may be distributed as functional circuits spread throughout the decoder <b>2009</b> and execution circuitry <b>2008</b> (e.g., multipliers, multiplexers, etc).</p><p id="p-0166" num="0162">In the embodiment illustrated in <figref idref="DRAWINGS">FIG. <b>20</b>B</figref> the matrix processing accelerator <b>2095</b> is tightly coupled to the processor cores <b>2001</b><i>a</i>-<i>b </i>over a cache coherent interconnect <b>2006</b>. The matrix processing accelerator <b>2095</b> of this embodiment is configured as a peer of the cores, participating in the same set of cache coherent memory transactions as the cores. As illustrated, the matrix processing accelerator <b>2095</b> may include its own set of registers <b>2018</b><i>a </i>(e.g., tile registers, vector registers, mask registers, etc) to perform the operations described herein. In this embodiment, the decoder <b>2009</b> decodes the instructions which are to be executed by the matrix processing accelerator <b>2095</b> and the resulting microoperations are passed for execution to the matrix processing accelerator <b>2095</b> over the interconnect <b>2006</b>. In another embodiment, the matrix processing accelerator <b>2095</b> includes its own fetch and decode circuitry to fetch and decode instructions, respectively, from a particular region of system memory <b>2060</b>. In either implementation, after executing the instructions, the matrix accelerator <b>2091</b> may store the results to the region in system memory <b>2060</b> (which may be accessed by the cores <b>2001</b><i>a</i>-<i>b</i>).</p><p id="p-0167" num="0163"><figref idref="DRAWINGS">FIG. <b>20</b>C</figref> illustrates another embodiment in which the matrix processing accelerator <b>2096</b> is on a different chip from the cores <b>2001</b><i>a</i>-<i>b </i>but coupled to the cores over a cache coherent interface <b>2096</b>. In one embodiment, the cache coherent interface <b>2096</b> uses packet-based transactions to ensure that data accessed/cached by the matrix processing accelerator <b>2096</b> is kept coherent with the cache hierarchy of the cores <b>2001</b><i>a</i>-<i>c. </i></p><p id="p-0168" num="0164">Also illustrated in <figref idref="DRAWINGS">FIGS. <b>20</b>A-C</figref> are general purpose registers (GPRs) <b>2018</b><i>d</i>, a set of vector/tile registers <b>2018</b><i>b</i>, a set of mask registers <b>2018</b><i>a </i>(which may include tile mask registers as described below), and a set of control registers <b>2018</b><i>c</i>. In one embodiment, multiple vector data elements are packed into each vector register which may have a 512-bit width for storing two 256-bit values, four 128-bit values, eight 64-bit values, sixteen 32-bit values, etc. Groups of vector registers may be combined to form the tile registers described herein. Alternatively, a separate set of 2-D tile/tensor registers may be used. However, the underlying principles of the invention are not limited to any particular size/type of vector/tile data. In one embodiment, the mask registers <b>2018</b><i>a </i>include eight 64-bit operand mask registers used for performing bit masking operations on the values stored in the vector registers <b>2006</b> (e.g., implemented as mask registers k0-k7 described above). However, the underlying principles of the invention are not limited to any particular mask register size/type.</p><p id="p-0169" num="0165">The control registers <b>2018</b><i>c </i>store various types of control bits or &#x201c;flags&#x201d; which are used by executing instructions to determine the current state of the processor core <b>2001</b><i>a</i>. By way of example, and not limitation, in an x86 architecture, the control registers include the EFLAGS register.</p><p id="p-0170" num="0166">An interconnect <b>2006</b> such as an in-die interconnect (IDI) or memory fabric implementing an IDI/coherence protocol communicatively couples the cores <b>2001</b><i>a</i>-<i>b </i>(and potentially the matrix accelerator <b>2095</b>) to one another and to various components. For example, the interconnect <b>2006</b> couples core <b>2001</b><i>a </i>via interface <b>2007</b> to a level 3 (L3) cache <b>2020</b> and an integrated memory controller <b>2030</b>. In addition, in some embodiments, the interconnect <b>2006</b> may be used to couple the cores <b>2001</b><i>a</i>-<i>b </i>to the matrix processing accelerator <b>2095</b>.</p><p id="p-0171" num="0167">The integrated memory controller <b>2030</b> provides access to a system memory <b>2060</b>. One or more input/output (I/O) circuits (not shown) such as PCI express circuitry may also be included in the shared region <b>2010</b>.</p><p id="p-0172" num="0168">An instruction pointer register <b>2012</b> stores an instruction pointer address identifying the next instruction to be fetched, decoded, and executed. Instructions may be fetched or prefetched from system memory <b>2060</b> and/or one or more shared cache levels such as an L2 cache <b>2013</b>, the shared L3 cache <b>2020</b>, or the L1 instruction cache <b>2010</b>. In addition, an L1 data cache <b>2002</b> stores data loaded from system memory <b>2060</b> and/or retrieved from one of the other cache levels <b>2013</b>, <b>2020</b> which cache both instructions and data. An instruction TLB (ITLB) <b>2011</b> stores virtual address to physical address translations for the instructions fetched by the fetch circuitry <b>2018</b> and a data TLB (DTLB) <b>2003</b> stores virtual-to-physical address translations for the data processed by the decode circuitry <b>2009</b> and execution circuitry <b>2008</b>.</p><p id="p-0173" num="0169">A branch prediction unit <b>2021</b> speculatively predicts instruction branch addresses and branch target buffers (BTBs) <b>2022</b> for storing branch addresses and target addresses. In one embodiment, a branch history table (not shown) or other data structure is maintained and updated for each branch prediction/misprediction and is used by the branch prediction unit <b>2002</b> to make subsequent branch predictions.</p><p id="p-0174" num="0170">Note that <figref idref="DRAWINGS">FIGS. <b>20</b>A-C</figref> are not intended to provide an exhaustive view of all circuitry and interconnects employed within an example processor. Rather, various components which are not pertinent to the embodiments of the invention are not shown. Conversely, some components are shown merely for the purpose of providing an example architecture in which embodiments of the invention may be implemented, but are not necessarily required for complying with the underlying principles of the invention.</p><heading id="h-0017" level="1">Signed, Unsigned Shift, Round, Saturate Instructions</heading><p id="p-0175" num="0171">For many of the sensing algorithms that perform dot products of 32/16/8/4-bit signed and unsigned integer data types (e.g., using matrix multiplication as described above), the following shift, round, and saturate instructions may be used to improve the performance and enable new sensor use cases. These embodiments also help to reduce the code memory footprint and provide significant performance gains for various sensing algorithms.</p><p id="p-0176" num="0172">These embodiments include signed and unsigned word and doubleword shift/round/saturate (SRS) instructions. Additional variants of the doubleword SRS instructions are provided which are designed for certain doubleword accumulators.</p><p id="p-0177" num="0173">One embodiment includes the following unsigned word SRS instructions:<ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0174">DVPSRRSUQW xmm1, xmm2/m128, imm8</li>        <li id="ul0002-0002" num="0175">DVPSRVRSUQW xmm1, xmm2, xmm3/m128</li>        <li id="ul0002-0003" num="0176">DVPSLRSUQW xmm1, xmm2/m128, imm8</li>        <li id="ul0002-0004" num="0177">DVPSLVRSUQW xmm1, xmm2, xmm3/m128</li>    </ul>    </li></ul></p><p id="p-0178" num="0178">All of the instructions listed above identify a 128-bit destination register (e.g., xmm1). The DVPSRRSUQW instruction also specifies a 128-bit source register or 128-bit memory location (xmm2/m128) and an 8-bit immediate (imm8). The DVPSRVRSUQW instruction specifies a first 128-bit source register (xmm2) and a second 128-bit source register (xmm3) or memory location (m128). Both of these instructions perform right shift operations as described below.</p><p id="p-0179" num="0179">The DVPSLRSUQW instruction specifies a 128-bit source register or 128-bit memory location (xmm2/m128) and an 8-bit immediate (imm8) and the DVPSLVRSUQW instruction specifies a first 128-bit source register (xmm2) and a second 128-bit source register or memory location (xmm3/m128). Both of these instructions perform left shift operations as described below.</p><p id="p-0180" num="0180">Example pseudocode is provided below showing details in accordance with one embodiment:</p><p id="p-0181" num="0000"><tables id="TABLE-US-00004" num="00004"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>TEMP&#x2003;&#x2003;&#x2003;&#x2190; SRC2[127:0];</entry></row><row><entry>COUNT0[5:0] &#x2190; (imm8[5:0] OR SRC3[5:0]);</entry></row><row><entry>COUNT1[5:0] &#x2190; (imm8[5:0] OR SRC3[69:64]);</entry></row><row><entry>SAT_POS0&#x2003;&#x2003;&#x2190; 0;</entry></row><row><entry>SAT_POS1&#x2003;&#x2003;&#x2190; 0;</entry></row><row><entry>IF (COUNT0 &#x3e; 63)</entry></row><row><entry>&#x2003;COUNT0[63:0]&#x2003;&#x2190; 64;</entry></row><row><entry>FI;</entry></row><row><entry>IF (COUNT1 &#x3e; 63)</entry></row><row><entry>&#x2003;COUNT1[63:0]&#x2003;&#x2190; 64;</entry></row><row><entry>FI;</entry></row><row><entry>DO WHILE (COUNT0 != 0)</entry></row><row><entry>&#x2003;&#x2003;IF (Instruction is DVPSLRSUQW or DVPSLVRSUQW) THEN</entry></row><row><entry>&#x2003;&#x2003;&#x2003;SAT_POS0 &#x2190; (TEMP[63] | | SAT_POS0); (* Accum. Shifted 1's *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;TEMP[63:0] &#x2190; {TEMP[62:0], 1'b0} ;&#x2003;&#x2003;(* Left Shift *)</entry></row><row><entry>&#x2003;&#x2003;ELSE (* Instruction is DVPSRRSUQW or DVPSRVRSUQW *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;TEMP[63:0] &#x2190; {1'b0,TEMP[63:1]} ;&#x2003;&#x2003;(* Logical Shift Right *)</entry></row><row><entry>COUNTO &#x2190; (COUNT0 &#x2212; 1);</entry></row><row><entry>ENDWHILE;</entry></row><row><entry>DO WHILE (COUNT1 != 0)</entry></row><row><entry>&#x2003;&#x2003;IF (Instruction is DVPSLRSUQW or DVPSLVRSUQW) THEN</entry></row><row><entry>&#x2003;&#x2003;&#x2003;SAT_POS1 &#x2190; (TEMP[127] | | SAT_POS1); (* Accum. Shifted 1's</entry></row><row><entry>&#x2003;&#x2003;&#x2003;*)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;TEMP[127:64] &#x2190; {TEMP[126:64], 1b0}; (* Left Shift *)</entry></row><row><entry>&#x2003;&#x2003;ELSE (* Instruction is DVPSRRSUQW or DVPSRVRSUQW *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;TEMP[127:64] &#x2190; {1'b0,TEMP[127:65]}; (* Logical Shift Right *)</entry></row><row><entry>COUNT1 &#x2190; (COUNT1 &#x2212; 1);</entry></row><row><entry>ENDWHILE;</entry></row><row><entry>IF (Instruction is DVPSLRSUQW or DVPSLVRSUQW) THEN</entry></row><row><entry>&#x2003;&#x2003;RoundBit0 &#x2190; CalcUnSignedWordRoundBit(TEMP[63:0],</entry></row><row><entry>&#x2003;&#x2003;MXCSR.IRM[1:0], RoundBit0);</entry></row><row><entry>&#x2003;&#x2003;RoundBit1 &#x2190; CalcUnSignedWordRoundBit(TEMP[127:64],</entry></row><row><entry>&#x2003;&#x2003;MXCSR.IRM[1:0], RoundBit1);</entry></row><row><entry>ELSE (* Instruction is DVPSRRSUQW or DVPSRVRSUQW *)</entry></row><row><entry>&#x2003;&#x2003;RoundBit0 &#x2190; CalcUnSignedWordRoundBit(SRC2[63:0],</entry></row><row><entry>&#x2003;&#x2003;MXCSR.IRM[1:0], RoundBit0);</entry></row><row><entry>&#x2003;&#x2003;RoundBit1 &#x2190; CalcUnSignedWordRoundBit(SRC2[127:64],</entry></row><row><entry>&#x2003;&#x2003;MXCSR.IRM[1:0], RoundBit1);</entry></row><row><entry>IF (Instruction is DVPSLRSUQW or DVPSLVRSUQW) THEN</entry></row><row><entry>&#x2003;&#x2003;DEST[15:0]&#x2003;&#x2190; AddBitSaturateToUnSignedWord(TEMP[63:48],</entry></row><row><entry>&#x2003;&#x2003;RoundBit0, SAT_POS0, DEST[15:0]);</entry></row><row><entry>&#x2003;&#x2003;DEST[79:64]&#x2003;&#x2190; AddBitSaturateToUnSignedWord(TEMP[127: 112],</entry></row><row><entry>&#x2003;&#x2003;RoundBit1, SAT_POS1, DEST[79:64]);</entry></row><row><entry>&#x2003;&#x2003;DEST[63:16]&#x2003;&#x2190; 0;</entry></row><row><entry>&#x2003;&#x2003;DEST[127:80] &#x2190; 0;</entry></row><row><entry>ELSE (* Instruction is DVPSRRSUQW or DVPSRVRSUQW *)</entry></row><row><entry>&#x2003;&#x2003;DEST[15:0]&#x2003;&#x2190; AddBitSaturateToUnSignedWord(TEMP[63:48],</entry></row><row><entry>&#x2003;&#x2003;RoundBit0, 0, DEST[15:0]);</entry></row><row><entry>&#x2003;&#x2003;DEST[79:64]&#x2003;&#x2190; AddBitSaturateToUnSignedWord(TEMP[127:112],</entry></row><row><entry>&#x2003;&#x2003;RoundBit1, 0, DEST[79:64]);</entry></row><row><entry>&#x2003;&#x2003;DEST[63:16]&#x2003;&#x2190; 0;</entry></row><row><entry>&#x2003;&#x2003;DEST[127:80] &#x2190; 0;</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0182" num="0181">In accordance with the above code sequence, the two values in the upper and lower 64-bit locations of the first 128-bit source register (SRC<b>2</b>) are shifted based on the count values, COUNT0 and COUNT1. The upper and lower values may be 64-bit values or may be values encoded with fewer than 64 bits (e.g., 32 bits, 16 bits, etc) but packed into 64-bit locations. The two result values are 16-bit words.</p><p id="p-0183" num="0182">In accordance with the above code sequence, the 5-bit count values, COUNT0 and COUNT1, indicate the number of bits to shift right or shift left, where COUNT0 corresponds to the lower value in the first 128-bit source register or memory location and COUNT1 corresponds to the upper value in the first 128-bit source register or memory location. The upper and lower values may be 64-bit values or may be values encoded with fewer than 64 bits (e.g., 32 bits, 16 bits, etc) but packed into 64-bit locations. Depending on the instruction, the count values are provided by an immediate (imm8) or a second source register or memory location (SRC<b>3</b>). The shifted values are then rounded and saturated to generate two 16-bit results, which are stored in bits 15:0 and 79:64 of the destination register.</p><p id="p-0184" num="0183"><figref idref="DRAWINGS">FIG. <b>21</b></figref> illustrates one particular implementation in which the lower value is stored in bits 63:0 of the 128-bit source register or memory location <b>2105</b> and the upper value is stored in bits 127:64 of the 128-bit source register or memory location <b>2105</b>. Shift units, <b>2112</b> and <b>2111</b>, of the execution circuitry <b>2100</b> shift the lower and upper values, respectively, based on the corresponding count values, COUNT0 and COUNT1 (which, as mentioned, are provided via an immediate or second source register/memory location). The shift direction (i.e., right or left) is determined by the specific instruction being executed.</p><p id="p-0185" num="0184">As mentioned, DVPSRRSUQW and DVPSRVRSUQW perform right-shift operations. In the present embodiment, logical right-shift operations are performed in which zeroes are shifted in from the left as the original bit values are shifted out to the right. In other embodiment described below (e.g., instructions operating on signed values), arithmetic shift right operations are performed in which the value of the most significant bit is shifted in from the left as original bit values are shifted out to the right.</p><p id="p-0186" num="0185">The resulting shifted values are provided to rounding/saturation units <b>2122</b> and <b>2121</b> which perform the rounding/saturation operations described herein to generate the two 16-bit results <b>2150</b>-<b>2151</b> in the 128-bit destination register <b>2160</b>. In particular, the first result <b>2150</b>, associated with the lower source values, is stored in bits 16:0 and the second result <b>2151</b>, associated with the upper source value, is stored in bits 79:64.</p><p id="p-0187" num="0186">In one embodiment, a control/status register <b>2112</b> such as an MXCSR register, includes a set of rounding control bits which indicate a rounding mode to be used by the rounding/saturation units <b>2122</b> and <b>2121</b>. In one particular implementation, the rounding control bits <b>2112</b>A comprise two bits in an Integer Rounding Mode Control (IRM) field of the MXCSR register <b>2112</b>. For example, in some embodiments, a value of two zeros (&#x2018;00&#x2019;) may indicate that &#x201c;even rounding&#x201d; (or &#x201c;convergent&#x201d; rounding) is to be performed, which indicates that the value is to be rounded to the nearest even value. Similarly, bit values one followed by a zero (&#x2018;10&#x2019;) may indicate that &#x201c;rounding up&#x201d; is to be performed, which could be performed (as for 2's complement values) by adding &#xbd; of the least significant bit to the result and then truncating that resultant value. Additionally, a bit value of two ones (&#x2018;<b>11</b>&#x2019;) may indicate that the rounding is to be a truncation (an eliminating or &#x201c;dropping&#x201d;) of extra bits. It should be noted, however, that the underlying principles of the invention are not limited to any particular rounding mode.</p><p id="p-0188" num="0187">Additionally, in some embodiments, the rounding/saturation units <b>2122</b> and <b>2121</b> can determine whether saturation is to be performed based upon detecting overflow or underflow. For example, when a saturation condition is detected, each of the final 16-bit results <b>2150</b> and <b>2151</b> can be saturated to a most positive or most negative value. In the code sequence listed above, the SAT_POS0 and SAT_POS1 values are set to 1 when the left shift operation performed by DVPSLRSUQW and DVPSLVRSUQW shifts out a binary 1. In one embodiment, this causes corresponding saturation bit(s) <b>2112</b>B in the control register <b>2112</b> to be set to 1. Thus, a saturation can be determined based on SAT_POS0 and/or SAT_POS1 being set to 1 during left shift operations and reflected in the corresponding saturation bit(s) <b>2112</b>B for use by subsequent operations. In one embodiment, the SAT_POS0/SAT_POS1 values and/or the corresponding saturation bit(s) <b>2112</b>B are maintained at 0 for the DVPSRRSUQW or DVPSRVRSUQW instructions because the most significant is are maintained during right shift operations.</p><p id="p-0189" num="0188">As mentioned, a saturation field <b>2112</b>B of the control/status register(s) <b>2112</b> can be set to indicate saturation. For example, the MXCSR.SAT bit (e.g, MXCSR[20]) can be set to indicate that the saturation has occurred. Thus, in some embodiments, a value in a saturation field <b>2112</b>B of the control/status register(s) <b>2112</b> can be updated when the execution circuitry <b>2100</b> detects that saturation has occurred responsive to the prior executed operations on the data values. In some embodiments the saturation field <b>2112</b>B can be a single bit location that can ordinarily be a zero but set to a value of one when saturation is detected.</p><p id="p-0190" num="0189">Following rounding/saturation, the 16-bit result values <b>2150</b> and <b>2151</b> are stored in bits 16:0 and 79:64 of the destination register <b>2160</b>. In the illustrated embodiment, zeroes are stored in bit ranges 63:16 and 127:80.</p><p id="p-0191" num="0190">A method for performing a left shift SRS instruction is illustrated in <figref idref="DRAWINGS">FIG. <b>22</b></figref>. The method may be performed on the processor or system architectures described herein, but is not limited to any particular processor or system architecture.</p><p id="p-0192" num="0191">At <b>2201</b> a left-shift SRS instruction is fetched, the instruction including a first source operand to identify first and second source values, a second source or immediate to identify first and second left shift values, and a destination operand to identify first and second result values corresponding to the first and second source values, respectively.</p><p id="p-0193" num="0192">At <b>2202</b>, the left-shift SRS instruction is decoded. In a microcoded implementation, for example, decoding of the left-shift SRS instruction generates sequences of microoperations which are then executed by the execution circuitry.</p><p id="p-0194" num="0193">At <b>2203</b>, the left-shift SRS instruction is executed to left-shift the first and second source values based on the first and second left shift values of the second source operand or immediate to generate first and second shifted values. A saturation indication is stored if a saturation condition is detected resulting from the left shift of the first and second source values (e.g., from shifting out a most-significant 1). The first and second shifted values may then be rounded and/or saturated in accordance with a rounding mode and/or the saturation indication, respectively, to generate the first and second result values in the destination register <b>2160</b>. The first and second result values are then stored in corresponding first and second locations of a destination register.</p><p id="p-0195" num="0194">A method for performing a right-shift SRS instruction is illustrated in <figref idref="DRAWINGS">FIG. <b>23</b></figref>. The method may be performed on the processor and system architectures described herein, but is not limited to any particular processor or system architecture.</p><p id="p-0196" num="0195">At <b>2301</b> a right-shift SRS instruction is fetched, the instruction including a first source operand to identify first and second source values, a second source or immediate to identify first and second right shift values, and a destination operand to identify first and second result values corresponding to the first and second source values, respectively.</p><p id="p-0197" num="0196">At <b>2302</b>, the right-shift SRS instruction is decoded. In a microcoded implementation, for example, decoding of the right-shift/round/saturate instruction generates sequences of microoperations which are then executed by the execution circuitry.</p><p id="p-0198" num="0197">At <b>2303</b>, the right-shift SRS instruction is executed to right-shift the first and second source values based on the first and second right-shift values of the second source operand or immediate to generate first and second shifted values. The first and second shifted values may then be rounded and/or saturated in accordance with a rounding mode and/or a saturation indication, respectively, to generate the first and second result values. The first and second result values are then stored in corresponding first and second locations of a destination register.</p><p id="p-0199" num="0198">One embodiment further includes the following signed word SRS instructions:<ul id="ul0003" list-style="none">    <li id="ul0003-0001" num="0000">    <ul id="ul0004" list-style="none">        <li id="ul0004-0001" num="0199">DVPSRARSQW xmm1, xmm2/m128, imm8</li>        <li id="ul0004-0002" num="0200">DVPSRAVRSQW xmm1, xmm2, xmm3/m128</li>        <li id="ul0004-0003" num="0201">DVPSLRSQW xmm1, xmm2/m128, imm8</li>        <li id="ul0004-0004" num="0202">DVPSLVRSQW xmm1, xmm2, xmm3/m128</li>    </ul>    </li></ul></p><p id="p-0200" num="0203">All of the instructions specified above identify a 128-bit destination register (xmm1 in the example). The DVPSRARSQW instruction also specifies a 128-bit source register or 128-bit memory location (xmm2/m128) and an 8-bit immediate (imm8). The DVPSRAVRSQW instruction specifies a first 128-bit source register (xmm2) and a second 128-bit source register or memory location (xmm3/m128). Both of these instructions perform right shift operations as described below</p><p id="p-0201" num="0204">The DVPSLRSQW instruction specifies a 128-bit source register or 128-bit memory location (xmm2/m128) and an 8-bit immediate (imm8) and the DVPSLVRSQW instruction specifies a first 128-bit source register (xmm2) and a second 128-bit source register or memory location (xmm3/m128). Both of these instructions perform left shift operations as described below.</p><p id="p-0202" num="0205">Example pseudocode is provided below showing details in accordance with one embodiment:</p><p id="p-0203" num="0000"><tables id="TABLE-US-00005" num="00005"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>TEMP[127:0] &#x2190; SRC2[127:0];</entry></row><row><entry>COUNT0[5:0] &#x2190; (imm8[5:0] OR SRC3[5:0]);</entry></row><row><entry>COUNT1[5:0] &#x2190; (imm8[5:0] OR SRC3[69:64]);</entry></row><row><entry>SIGN_BIT0 &#x2190; SRC2[63];</entry></row><row><entry>SIGN_BIT1 &#x2190; SRC2[127];</entry></row><row><entry>SAT_POS0 &#x2190; 0;</entry></row><row><entry>SAT_POS1 &#x2190; 0;</entry></row><row><entry>SAT_NEG0 &#x2190; 0;</entry></row><row><entry>SAT_NEG1 &#x2190; 0;</entry></row><row><entry>IF (COUNT0 &#x3e; 63)</entry></row><row><entry>&#x2003;COUNT0[63:0] &#x2190; 64;</entry></row><row><entry>FI;</entry></row><row><entry>IF (COUNT1 &#x3e; 63)</entry></row><row><entry>&#x2003;COUNT1[63:0] &#x2190; 64;</entry></row><row><entry>FI;</entry></row><row><entry>DO WHILE (COUNT0 != 0)</entry></row><row><entry>&#x2003;IF (Instruction is DVPSLRSQW or DVPSLVRSQW) THEN</entry></row><row><entry>&#x2003;&#x2003;SAT_POS0 &#x2190; ((~SIGN_BIT0 &#x26;TEMP[62]) ? 1 : 0) | | SAT_POS0 ;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;(* Check Sign Bit for Positive Saturation *)</entry></row><row><entry>&#x2003;&#x2003;SAT_NEG0 &#x2190; ((SIGN_BIT0 &#x26; ~TEMP[62]) ? 1 : 0) | | SAT_NEG0 ;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;(* Check Sign Bit for Negative Saturation *)</entry></row><row><entry>&#x2003;&#x2003;TEMP[63:0] &#x2190; {TEMP[62:0], 1&#x2032;b0}; (* Left Shift *)</entry></row><row><entry>&#x2003;ELSE (* Instruction is DVPSRARSQW or DVPSRAVRSQW *)</entry></row><row><entry>&#x2003;&#x2003;TEMP[63:0] &#x2190;{TEMP[63], TEMP[63:1]} ; (* Arith Right Shift *)</entry></row><row><entry>COUNT0 &#x2190; (COUNT0 &#x2212; 1);</entry></row><row><entry>ENDWHILE;</entry></row><row><entry>DO WHILE (COUNT1 != 0)</entry></row><row><entry>&#x2003;IF (Instruction is DVPSLRSQW or DVPSLVRSQW) THEN</entry></row><row><entry>&#x2003;&#x2003;SAT_POS1 &#x2190; ((~SIGN_BIT1 &#x26;TEMP[126]) ? 1 : 0) | | SAT_POS1 ;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;(* Check Sign Bit for Positive Saturation *)</entry></row><row><entry>&#x2003;&#x2003;SAT_NEG1 &#x2190; ((SIGN_BIT1 &#x26; ~TEMP[126]) ? 1 : 0) | | SAT_NEG1 ;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;(* Check Sign Bit for Negative Saturation *)</entry></row><row><entry>&#x2003;&#x2003;TEMP[127:64] &#x2190; {TEMP[126:64], 1&#x2032;b0}; (* Left Shift *)</entry></row><row><entry>&#x2003;ELSE (* Instruction is DVPSRARSQW or DVPSRAVRSQW *)</entry></row><row><entry>&#x2003;&#x2003;TEMP[127:64] &#x2190; {TEMP[127], TEMP[127:65]} ;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;(* Arithmetic Right Shift *)</entry></row><row><entry>COUNT1 &#x2190; (COUNT1 &#x2212; 1);</entry></row><row><entry>ENDWHILE;</entry></row><row><entry>IF (Instruction is DVPSLRSQW or DVPSLVRSQW) THEN</entry></row><row><entry>&#x2003;&#x2003;RoundBit0 &#x2190; CalcSignedWordRoundBit(TEMP[63:0],</entry></row><row><entry>&#x2003;&#x2003;MXCSR.IRM[1:0], RoundBit0);</entry></row><row><entry>&#x2003;&#x2003;RoundBit1 &#x2190; CalcSignedWordRoundBit(TEMP[127:64],</entry></row><row><entry>&#x2003;&#x2003;MXCSR.IRM[1:0], RoundBit1);</entry></row><row><entry>ELSE (* Instruction is DVPSRLRSQW or DVPSRLVRSQW *)</entry></row><row><entry>&#x2003;&#x2003;RoundBit0 &#x2190; CalcSignedWordRoundBit(SRC2[63:0],</entry></row><row><entry>&#x2003;&#x2003;MXCSR.IRM[1:0], RoundBit0);</entry></row><row><entry>&#x2003;&#x2003;RoundBit1 &#x2190; CalcSignedWordRoundBit(SRC2[127:64],</entry></row><row><entry>&#x2003;&#x2003;MXCSR.IRM[1:0], RoundBit1);</entry></row><row><entry>IF (Instruction is DVPSLRSQW or DVPSLVRSQW ) THEN</entry></row><row><entry>&#x2003;DEST[15:0] &#x2190; AddBitSaturateToSignedWord(TEMP[63:48], RoundBit0,</entry></row><row><entry>&#x2003;SAT_POS, SAT_NEG, DEST[15:0]);</entry></row><row><entry>&#x2003;DEST[63:16] &#x2190; 0;</entry></row><row><entry>&#x2003;DEST[79:64] &#x2190; AddBitSaturateToSignedWord (TEMP[127:112],</entry></row><row><entry>&#x2003;RoundBit1, SAT_POS1, SAT_NEG1, DEST[79:64]);</entry></row><row><entry>&#x2003;DEST[127:80] &#x2190; 0;</entry></row><row><entry>ELSE (* Instruction is DVPSRARSQW or DVPSRAVRSQW *)</entry></row><row><entry>&#x2003;DEST[15:0] &#x2190; AddBitSaturatePosToSignedWord(TEMP[63:48],</entry></row><row><entry>&#x2003;RoundBit0,1&#x2032;b0, DEST[15:0]);</entry></row><row><entry>&#x2003;DEST[63:16] &#x2190; 0;</entry></row><row><entry>&#x2003;DEST[79:64] &#x2190; AddBitSaturatePosToSignedWord (TEMP[127:112],</entry></row><row><entry>&#x2003;RoundBit1, 1&#x2032;b0, DEST[79:64]);</entry></row><row><entry>&#x2003;DEST[127:80] &#x2190; 0;</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0204" num="0206">Thus, the signed word SRS instructions use positive saturation flags (SAT_POS0 and SAT_POS1) to indicate positive saturation and negative saturation flags (SAT_NEG0 and SAT_NEG1) to indicate positive or negative saturation, respectively. The rounding/saturation units <b>2121</b>-<b>2122</b> can then evaluate the positive and negative saturation flags to determine whether the result values are to be saturated negatively or positively. The signed SRS instructions must also process the sign values (SIGN_BIT0 and SIGN_BIT1) for each of the source values.</p><p id="p-0205" num="0207">For the right-shift instructions DVPSRARSQW and DVPSRAVRSQW, arithmetic shift right operations are performed to preserve the sign of the underlying value. In the arithmetic shift right operations, the value of the most significant bit is shifted in from the left as the least significant bit values are shifted out to the right.</p><p id="p-0206" num="0208">A method for performing a left-shift signed word SRS instruction is illustrated in <figref idref="DRAWINGS">FIG. <b>24</b></figref>. The method may be performed on the processor or system architectures described herein, but is not limited to any particular processor or system architecture.</p><p id="p-0207" num="0209">At <b>2401</b> a left-shift signed word SRS instruction is fetched, the instruction including a first source operand to identify first and second source values, a second source or immediate to identify first and second left shift values, and a destination operand to identify first and second result values corresponding to the first and second source values, respectively.</p><p id="p-0208" num="0210">At <b>2402</b>, the left-shift signed word SRS instruction is decoded. In a microcoded implementation, for example, decoding of the left-shift SRS instruction generates sequences of microoperations which are then executed by the execution circuitry.</p><p id="p-0209" num="0211">At <b>2403</b>, the left-shift signed word SRS instruction is executed to left-shift the first and second signed source values based on the first and second left shift values of the second source operand or immediate to generate first and second signed, shifted values. A positive or negative saturation indication is stored if a positive/negative saturation condition is detected resulting from the left shift of the first and second source values. The first and second signed shifted values may then be rounded and/or saturated in accordance with a rounding mode and/or the positive/negative saturation indication, respectively, to generate the first and second result values in the destination register <b>2160</b>. The first and second result values are then stored in corresponding first and second locations of a destination register.</p><p id="p-0210" num="0212">A method for performing a right-shift signed word SRS instruction is illustrated in <figref idref="DRAWINGS">FIG. <b>25</b></figref>. The method may be performed on the processor and system architectures described herein, but is not limited to any particular processor or system architecture.</p><p id="p-0211" num="0213">At <b>2501</b> a right-shift signed word SRS instruction is fetched, the instruction including a first source operand to identify first and second source values, a second source or immediate to identify first and second right shift values, and a destination operand to identify first and second result values corresponding to the first and second source values, respectively.</p><p id="p-0212" num="0214">At <b>2502</b>, the right-shift signed word SRS instruction is decoded. In a microcoded implementation, for example, decoding of the right-shift SRS instruction generates sequences of microoperations which are then executed by the execution circuitry.</p><p id="p-0213" num="0215">At <b>2503</b>, the right-shift SRS instruction is executed to right-shift the first and second source values based on the first and second right-shift values of the second source operand or immediate to generate first and second shifted values. The first and second shifted values may then be rounded and/or saturated in accordance with a rounding mode and/or a positive/negative saturation indication, respectively, to generate the first and second result values. The first and second result values are then stored in corresponding first and second locations of a destination register.</p><p id="p-0214" num="0216">In addition to signed/unsigned word SRS instructions, one embodiment of the processor also supports the following signed/unsigned doubleword SRS instructions:</p><heading id="h-0018" level="2">Unsigned DWORD SRS Instructions:</heading><p id="p-0215" num="0000"><ul id="ul0005" list-style="none">    <li id="ul0005-0001" num="0000">    <ul id="ul0006" list-style="none">        <li id="ul0006-0001" num="0217">DVPSRRSUQD xmm1, xmm2/m128, imm8</li>        <li id="ul0006-0002" num="0218">DVPSRVRSUQD xmm1, xmm2, xmm3/m128</li>        <li id="ul0006-0003" num="0219">DVPSLRSUQD xmm1, xmm2/m128, imm8</li>        <li id="ul0006-0004" num="0220">DVPSLVRSUQD xmm1, xmm2, xmm3/m128</li>    </ul>    </li></ul></p><heading id="h-0019" level="2">Signed DWORD SRS Instructions:</heading><p id="p-0216" num="0000"><ul id="ul0007" list-style="none">    <li id="ul0007-0001" num="0000">    <ul id="ul0008" list-style="none">        <li id="ul0008-0001" num="0221">DVPSRARSQD xmm1, xmm2/m128, imm8</li>        <li id="ul0008-0002" num="0222">DVPSRAVRSQD xmm1, xmm2, xmm3/m128</li>        <li id="ul0008-0003" num="0223">DVPSLRSQD xmm1, xmm2/m128, imm8</li>        <li id="ul0008-0004" num="0224">DVPSLVRSQD xmm1, xmm2, xmm3/m128</li>    </ul>    </li></ul></p><p id="p-0217" num="0225">All of the instructions listed above identify a 128-bit destination register (e.g., xmm1). The DVPSRRSUQW and DVPSRRSUQD instructions also specify a 128-bit source register or 128-bit memory location (xmm2/m128) and an 8-bit immediate (imm8). The DVPSRVRSUQW and DVPSRVRSUQD instructions specify a first 128-bit source register (xmm2) and a second 128-bit source register (xmm3) or memory location (m128). Each of these instructions perform right-shift operations as described below.</p><p id="p-0218" num="0226">The DVPSLRSUQW and DVPSLRSUQD instructions specify a 128-bit source register or 128-bit memory location (xmm2/m128) and an 8-bit immediate (imm8) and the DVPSLVRSUQW and DVPSLVRSUQD instructions specify a first 128-bit source register (xmm2) and a second 128-bit source register or memory location (xmm3/m128). Each of these instructions perform left-shift operations as described below.</p><p id="p-0219" num="0227">The following pseudocode sequence defines the operation for one embodiment of the unsigned doubleword SRS instructions:</p><p id="p-0220" num="0000"><tables id="TABLE-US-00006" num="00006"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>TEMP &#x2190; SRC2[127:0];</entry></row><row><entry>COUNT0[5:0] &#x2190; (imm8[5:0] OR SRC3[5:0]);</entry></row><row><entry>COUNT1[5:0] &#x2190; (imm8[5:0] OR SRC3[69:64]);</entry></row><row><entry>SAT_POS0 &#x2190; 0;</entry></row><row><entry>SAT_POS1 &#x2190; 0;</entry></row><row><entry>IF (COUNT0 &#x3e; 63)</entry></row><row><entry>&#x2003;COUNT0[63:0] &#x2190; 64;</entry></row><row><entry>FI;</entry></row><row><entry>IF (COUNT1 &#x3e; 63)</entry></row><row><entry>&#x2003;COUNT1[63:0] &#x2190; 64;</entry></row><row><entry>FI;</entry></row><row><entry>DO WHILE (COUNT0 != 0)</entry></row><row><entry>&#x2003;&#x2003;IF (Instruction DVPSLRSUQD or DVPSLVRSUQD) THEN</entry></row><row><entry>&#x2003;&#x2003;&#x2003;SAT_POS0 &#x2190; (TEMP[63] | | SAT_POS0) ;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;(* Check Sign Bit for Positive Saturation *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;TEMP [63:0] &#x2190; ({TEMP[62:0], 1&#x2032;b0}) ; (* Left Shift *)</entry></row><row><entry>&#x2003;&#x2003;ELSE (* Instruction DVPSRRSUQD or DVPSRVRSUQD *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;TEMP [63:0] &#x2190; {1&#x2032;b0, TEMP[63:1]} ; (* Logical Right Shift *)</entry></row><row><entry>&#x2003;&#x2003;COUNT0 &#x2190; (COUNT0 &#x2212; 1);</entry></row><row><entry>ENDWHILE;</entry></row><row><entry>DO WHILE (COUNT1 != 0)</entry></row><row><entry>&#x2003;&#x2003;IF (Instruction DVPSLRSUQD or DVPSLVRSUQD) THEN</entry></row><row><entry>&#x2003;&#x2003;&#x2003;SAT_POS1 &#x2190; (TEMP[127] | | SAT_POS1) ;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;(* Check Sign Bit for Positive Saturation *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;TEMP [127:64] &#x2190; {TEMP[126:64], 1&#x2032;b0} ; (* Left Shift *)</entry></row><row><entry>&#x2003;&#x2003;ELSE (* Instruction DVPSRRSUQD or DVPSRVRSUQD *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;TEMP [127:64] &#x2190; {1&#x2032;b0, TEMP[127:65]} ; (* Logical Right Shift *)</entry></row><row><entry>&#x2003;&#x2003;COUNT1 &#x2190; (COUNT1 &#x2212; 1);</entry></row><row><entry>ENDWHILE;</entry></row><row><entry>IF (Instruction is DVPSLRSUQD or DVPSLVRSUQD) THEN</entry></row><row><entry>&#x2003;&#x2003;RoundBit0 &#x2190; CalcUnSignedDwordRoundBit(TEMP[63:0],</entry></row><row><entry>&#x2003;&#x2003;MXCSR.IRM[1:0], RoundBit0);</entry></row><row><entry>&#x2003;&#x2003;RoundBit1 &#x2190; CalcUnSignedDwordRoundBit(TEMP[127:64],</entry></row><row><entry>&#x2003;&#x2003;MXCSR.IRM[1:0], RoundBit1);</entry></row><row><entry>ELSE (* Instruction is DVPSRRSUQD or DVPSRVRSUQD *)</entry></row><row><entry>&#x2003;&#x2003;RoundBit0 &#x2190; CalcUnSignedDwordRoundBit(SRC2[63:0],</entry></row><row><entry>&#x2003;&#x2003;MXCSR.IRM[1:0], RoundBit0);</entry></row><row><entry>&#x2003;&#x2003;RoundBit1 &#x2190; CalcUnSignedDwordRoundBit(SRC2[127:64],</entry></row><row><entry>MXCSR.IRM[1:0], RoundBit1);</entry></row><row><entry>IF Instruction DVPSLRSUQD or DVPSLVRSUQD THEN</entry></row><row><entry>&#x2003;&#x2003;DEST[31:0] &#x2190; AddBitSaturateToUnSignedDword(TEMP[63:32],</entry></row><row><entry>&#x2003;&#x2003;RoundBit0, SAT_POS0, DEST[31:0]);</entry></row><row><entry>&#x2003;&#x2003;DEST[63:32] &#x2190; 0;</entry></row><row><entry>&#x2003;&#x2003;DEST[95:64] &#x2190; AddBitSaturateToUnSignedDword(TEMP[127:96],</entry></row><row><entry>&#x2003;&#x2003;RoundBit1, SAT_POS1, DEST[95:64]);</entry></row><row><entry>&#x2003;&#x2003;DEST[127:96] &#x2190; 0;</entry></row><row><entry>ELSE (* Instruction DVPSRRSUQD or DVPSRVRSUQD *)</entry></row><row><entry>&#x2003;&#x2003;DEST[31:0] &#x2190; AddBitSaturateToUnSignedDword(TEMP[63:32],</entry></row><row><entry>&#x2003;&#x2003;RoundBit0, 1&#x2032;b0, DEST[31:0]);</entry></row><row><entry>&#x2003;&#x2003;DEST[63:32] &#x2190; 0;</entry></row><row><entry>&#x2003;&#x2003;DEST[95:64] &#x2190; AddBitSaturateToUnSignedDword(TEMP[127:96],</entry></row><row><entry>&#x2003;&#x2003;RoundBit1, 1&#x2032;b0, DEST[95:64]);</entry></row><row><entry>&#x2003;&#x2003;DEST[127:96] &#x2190; 0;</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0221" num="0228">In accordance with the above code sequence, the two values in the upper and lower 64-bit locations of the first 128-bit source register (SRC<b>2</b>) are shifted based on the count values, COUNT0 and COUNT1. The upper and lower values may be 64-bit values or may be values encoded with fewer than 64 bits (e.g., 32 bits, 16 bits, etc) but packed into 64-bit locations. The two result values are 32-bit doublewords.</p><p id="p-0222" num="0229">In accordance with the above code sequence, the 5-bit count values, COUNT0 and COUNT1, indicate the number of bits to shift right or shift left, where COUNT0 corresponds to the lower value in the first 128-bit source register or memory location and COUNT1 corresponds to the upper value in the first 128-bit source register or memory location. Depending on the instruction, the count values are provided by an immediate (imm8) or a second source register or memory location (SRC<b>3</b>). The shifted values are then rounded and saturated to generate two 16-bit results, which are stored in bits 15:0 and 79:64 of the destination register.</p><p id="p-0223" num="0230"><figref idref="DRAWINGS">FIG. <b>26</b></figref> illustrates one particular implementation in which the lower value is stored in bits 63:0 of the 128-bit source register or memory location <b>2605</b> and the upper value is stored in bits 127:64 of the 128-bit source register or memory location <b>2605</b>. Shift units, <b>2612</b> and <b>2611</b>, of the execution circuitry <b>2600</b> shift the lower and upper values, respectively, based on the corresponding count values, COUNT0 and COUNT1 (which, as mentioned, are provided via an immediate or second source register/memory location).</p><p id="p-0224" num="0231">The shift direction (i.e., right or left) is determined by the specific instruction being executed. As mentioned, DVPSRRSUQD and DVPSRVRSUQD perform right-shift operations while DVPSLRSUQD and DVPSLVRSUQD perform left-shift operations. Because the values are unsigned, the right-shift instructions DVPSRRSUQD and DVPSRVRSUQD use a logical right-shift operation.</p><p id="p-0225" num="0232">The resulting shifted values are provided to rounding/saturation units <b>2622</b> and <b>2621</b> which perform the rounding/saturation operations described herein to generate the two 32-bit results <b>2650</b>-<b>2651</b> in the 128-bit destination register <b>2660</b>. In particular, the first result <b>2650</b>, associated with the lower source values, is stored in bits 31:0 and the second result <b>2651</b>, associated with the upper source value, is stored in bits 95:64.</p><p id="p-0226" num="0233">In one embodiment, a control/status register <b>2612</b> such as an MXCSR register, includes a set of rounding control bits which indicate a rounding mode to be used by the rounding/saturation units <b>2622</b> and <b>2621</b>. In one particular implementation, the rounding control bits <b>2612</b>A comprise two bits in an Integer Rounding Mode Control (IRM) field of the MXCSR register <b>2612</b>. For example, in some embodiments, a value of two zeros (&#x2018;00&#x2019;) may indicate that &#x201c;even rounding&#x201d; (or &#x201c;convergent&#x201d; rounding) is to be performed, which indicates that the value is to be rounded to the nearest even value. Similarly, bit values one followed by a zero (&#x2018;<b>10</b>&#x2019;) may indicate that &#x201c;rounding up&#x201d; is to be performed, which could be performed (as for 2's complement values) by adding &#xbd; of the least significant bit to the result and then truncating that resultant value. Additionally, a bit value of two ones (&#x2018;11&#x2019;) may indicate that the rounding is to be a truncation (an eliminating or &#x201c;dropping&#x201d;) of extra bits. It should be noted, however, that the underlying principles of the invention are not limited to any particular rounding mode.</p><p id="p-0227" num="0234">Additionally, in some embodiments, the rounding/saturation units <b>2622</b> and <b>2621</b> can determine whether saturation is to be performed based upon detecting overflow or underflow. For example, when a saturation condition is detected, each of the final 32-bit results <b>2650</b> and <b>2651</b> can be saturated to a most positive or most negative value. In the code sequence listed above, the SAT_POS0 and SAT_POS1 values are set to 1 when the left shift operation performed by DVPSLRSUQD or DVPSLVRSUQD shifts out a binary 1. In one embodiment, this causes corresponding saturation bit(s) <b>2612</b>B in the control register <b>2612</b> to be set to 1. Thus, a saturation can be determined based on SAT_POS0 and/or SAT_POS1 being set to 1 during left shift operations and reflected in the corresponding saturation bit(s) <b>2612</b>B for use by subsequent operations.</p><p id="p-0228" num="0235">In one embodiment, the SAT_POS0/SAT_POS1 values and/or the corresponding saturation bit(s) <b>2612</b>B are maintained at 0 for the DVPSRRSUQD and DVPSRVRSUQD instructions because the most significant is are maintained during right shift operations.</p><p id="p-0229" num="0236">As mentioned, a saturation field <b>2612</b>B of the control/status register(s) <b>2612</b> can be set to indicate saturation. For example, the MXCSR.SAT bit (e.g, MXCSR[20]) can be set to indicate that the saturation has occurred. Thus, in some embodiments, a value in a saturation field <b>2612</b>B of the control/status register(s) <b>2612</b> can be updated when the execution circuitry <b>2600</b> detects that saturation has occurred responsive to the prior executed operations on the data values. In some embodiments the saturation field <b>2612</b>B can be a single bit location that can ordinarily be a zero but set to a value of one when saturation is detected.</p><p id="p-0230" num="0237">Following rounding/saturation, the 16-bit result values <b>2650</b> and <b>2651</b> are stored in bits 31:0 and 95:64 of the destination register <b>2660</b>. In the illustrated embodiment, zeroes are stored in bit ranges 63:32 and 127:96.</p><p id="p-0231" num="0238">A method for performing a left shift doubleword SRS instruction is illustrated in <figref idref="DRAWINGS">FIG. <b>27</b></figref>. The method may be performed on the processor or system architectures described herein, but is not limited to any particular processor or system architecture.</p><p id="p-0232" num="0239">At <b>2701</b> a left-shift doubleword SRS instruction is fetched, the instruction including a first source operand to identify first and second source values, a second source or immediate to identify first and second left shift values, and a destination operand to identify first and second result values corresponding to the first and second source values, respectively.</p><p id="p-0233" num="0240">At <b>2702</b>, the left-shift unsigned doubleword SRS instruction is decoded. In a microcoded implementation, for example, decoding of the left-shift SRS instruction generates sequences of microoperations which are then executed by the execution circuitry.</p><p id="p-0234" num="0241">At <b>2703</b>, the left-shift unsigned doubleword SRS instruction is executed to left-shift the first and second source values based on the first and second left shift values of the second source operand or immediate to generate first and second shifted values. A saturation indication is stored if a saturation condition is detected resulting from the left shift of the first and second source values (e.g., from shifting out a most-significant 1). The first and second shifted values may then be rounded and/or saturated in accordance with a rounding mode and/or the saturation indication, respectively, to generate the first and second unsigned doubleword (32-bit) result values in the destination register <b>2660</b>. The first and second unsigned doubleword result values are then stored in corresponding first and second locations of a destination register.</p><p id="p-0235" num="0242">A method for performing a right-shift unsigned doubleword SRS instruction is illustrated in <figref idref="DRAWINGS">FIG. <b>28</b></figref>. The method may be performed on the processor and system architectures described herein, but is not limited to any particular processor or system architecture.</p><p id="p-0236" num="0243">At <b>2801</b> a right-shift unsigned doubleword SRS instruction is fetched, the instruction including a first source operand to identify first and second source values, a second source or immediate to identify first and second right shift values, and a destination operand to identify first and second result values corresponding to the first and second source values, respectively.</p><p id="p-0237" num="0244">At <b>2802</b>, the right-shift unsigned doubleword SRS instruction is decoded. In a microcoded implementation, for example, decoding of the right-shift/round/saturate instruction generates sequences of microoperations which are then executed by the execution circuitry.</p><p id="p-0238" num="0245">At <b>2803</b>, the right-shift unsigned doubleword SRS instruction is executed to right-shift the first and second source values based on the first and second right-shift values of the second source operand or immediate to generate first and second shifted values. The first and second shifted values may then be rounded and/or saturated in accordance with a rounding mode and/or a saturation indication, respectively, to generate the first and second doubleword (32-bit) result values. The first and second doubleword result values are then stored in corresponding first and second locations of a destination register.</p><p id="p-0239" num="0246">The following pseudocode sequence defines the operation for one embodiment of the signed doubleword SRS instructions:</p><p id="p-0240" num="0000"><tables id="TABLE-US-00007" num="00007"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>TEMP &#x2190; SRC2[127:0];</entry></row><row><entry>COUNT0[5:0] &#x2190; (imm8[5:0] OR SRC3[5:0]);</entry></row><row><entry>COUNT1[5:0] &#x2190; (imm8[5:0] OR SRC3[69:64]);</entry></row><row><entry>SIGN_BIT0 &#x2190; SRC2[63];</entry></row><row><entry>SIGN_BIT1 &#x2190; SRC2[127];</entry></row><row><entry>SAT_POS0 &#x2190; 0;</entry></row><row><entry>SAT_POS1 &#x2190; 0;</entry></row><row><entry>SAT_NEG0 &#x2190; 0;</entry></row><row><entry>SAT_NEG1 &#x2190; 0;</entry></row><row><entry>IF (COUNT0 &#x3e; 63)</entry></row><row><entry>&#x2003;COUNT0[63:0] &#x2190; 64;</entry></row><row><entry>FI;</entry></row><row><entry>IF (COUNT1 &#x3e; 63)</entry></row><row><entry>&#x2003;COUNT1[63:0] &#x2190; 64;</entry></row><row><entry>FI;</entry></row><row><entry>DO WHILE (COUNT0 != 0)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;IF (Instruction is DVPSLRSQD or DVPSLVRSQD) THEN</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;SAT_POS0 &#x2190; ((~SIGN_BIT0 &#x26;TEMP[62]) ? 1 : 0) | | SAT_POS0;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;(* Check Sign Bit for Positive Saturation *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;SAT_NEG0 &#x2190; ((SIGN_BIT0 &#x26; ~TEMP[62]) ? 1 : 0) | | SAT_NEG0 ;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;(* Check Sign Bit for Negative Saturation *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;TEMP [63:0] &#x2190; {TEMP[62:0], 1&#x2032;b0}) ;(* Left Shift *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ELSE (* Instruction is DVPSRARSQD or DVPSRAVRSQD *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;TEMP [63:0] &#x2190; {TEMP[63], TEMP[63:1]}; (* Arith Right Shift *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;COUNT0 &#x2190; (COUNT0 &#x2212; 1);</entry></row><row><entry>ENDWHILE;</entry></row><row><entry>DO WHILE (COUNT1 != 0)</entry></row><row><entry>&#x2003;&#x2003;IF (Instruction is DVPSLRSQD or DVPSLVRSQD) THEN</entry></row><row><entry>&#x2003;&#x2003;&#x2003;SAT_POS1 &#x2190; ((~SIGN_BIT1 &#x26;TEMP[126]) ? 1 : 0) | | SAT_POS1;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;(* Check Sign Bit for Positive Saturation *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;SAT_NEG1 &#x2190; ((SIGN_BIT1 &#x26; ~TEMP[126]) ? 1 : 0) | | SAT_NEG1;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;(* Check Sign Bit for Negative Saturation *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;TEMP [127:64] &#x2190; {TEMP[126:64], 1&#x2032;b0}) ; (* Left Shift *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;ELSE (* Instruction is DVPSRARSQD or DVPSRAVRSQD *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;TEMP [127:64] &#x2190; {TEMP[127], TEMP[127:65]} ; (* Arith Rt Shift *)</entry></row><row><entry>&#x2003;&#x2003;COUNT1 &#x2190; (COUNT1 &#x2212; 1);</entry></row><row><entry>ENDWHILE;</entry></row><row><entry>IF (Instruction is DVPSLRSQD or DVPSLVRSQD) THEN</entry></row><row><entry>&#x2003;&#x2003;&#x2003;RoundBit0 &#x2190; CalcSignedDwordRoundBit(TEMP[63:0],</entry></row><row><entry>&#x2003;&#x2003;&#x2003;MXCSR.IRM[1:0], RoundBit0);</entry></row><row><entry>&#x2003;&#x2003;&#x2003;RoundBit1 &#x2190; CalcUnSignedDwordRoundBit(TEMP[127:64],</entry></row><row><entry>&#x2003;&#x2003;&#x2003;MXCSR.IRM[1:0], RoundBit1);</entry></row><row><entry>ELSE (* Instruction is DVPSRLRSQD or DVPSRLVRSQD *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;RoundBit0 &#x2190; CalcSignedDwordRoundBit(SRC2[63:0],</entry></row><row><entry>&#x2003;&#x2003;&#x2003;MXCSR.IRM[1:0], RoundBit0);</entry></row><row><entry>&#x2003;&#x2003;&#x2003;RoundBit1 &#x2190; CalcSignedDwordRoundBit(SRC2[127:64],</entry></row><row><entry>&#x2003;&#x2003;&#x2003;MXCSR.IRM[1:0], RoundBit1);</entry></row><row><entry>IF (Instruction is DVPSLRSQD or DVPSLVRSQD) THEN</entry></row><row><entry>&#x2003;&#x2003;DEST[31:0] &#x2190; AddBitSaturateToSignedDword(TEMP[63:32], RoundBit0,</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;SAT_POS0, SAT_NEG0, DEST[31:0]);</entry></row><row><entry>&#x2003;&#x2003;DEST[63:32] &#x2190; 0;</entry></row><row><entry>&#x2003;&#x2003;DEST[95:64] &#x2190; AddBitSaturateToSignedDword(TEMP[127:96],</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;RoundBit1, SAT_POS1, SAT_NEG1, DEST[95:64]);</entry></row><row><entry>&#x2003;&#x2003;DEST[127:96] &#x2190; 0;</entry></row><row><entry>ELSE (* Instruction is DVPSRARSQD or DVPSRAVRSQD *)</entry></row><row><entry>&#x2003;&#x2003;DEST[31:0] &#x2190; AddBitSaturatePosToSignedDword(TEMP[63:32],</entry></row><row><entry>&#x2003;&#x2003;RoundBit0,1&#x2032;b0, DEST[31:0]);</entry></row><row><entry>&#x2003;&#x2003;DEST[63:32] &#x2190; 0;</entry></row><row><entry>&#x2003;&#x2003;DEST[95:64] &#x2190; AddBitSaturatePosToSignedDword(TEMP[127:96],</entry></row><row><entry>&#x2003;&#x2003;RoundBit1,1&#x2032;b0, DEST[95:64]);</entry></row><row><entry>&#x2003;&#x2003;DEST[127:96] &#x2190; 0;</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0241" num="0247">Thus, the signed doubleword SRS instructions use positive saturation flags (SAT_POS0 and SAT_POS1) to indicate positive saturation and negative saturation flags (SAT_NEG0 and SAT_NEG1) to indicate positive or negative saturation, respectively. The rounding/saturation units <b>2621</b>-<b>2622</b> can then evaluate the positive and negative saturation flags to determine whether the result values are to be saturated negatively or positively. The signed SRS instructions must also process the sign values (SIGN_BIT0 and SIGN_BIT1) for each of the source values.</p><p id="p-0242" num="0248">In this embodiment, an arithmetic shift right is performed for DVPSRARSQD or DVPSRAVRSQD to preserve the sign value. In the arithmetic shift right operations, the value of the most significant bit is shifted in from the left as the least significant bit values are shifted out to the right.</p><p id="p-0243" num="0249">A method for performing a left shift signed doubleword SRS instruction is illustrated in <figref idref="DRAWINGS">FIG. <b>29</b></figref>. The method may be performed on the processor or system architectures described herein, but is not limited to any particular processor or system architecture.</p><p id="p-0244" num="0250">At <b>2901</b> a left-shift signed doubleword SRS instruction is fetched, the instruction including a first source operand to identify first and second source values, a second source or immediate to identify first and second left shift values, and a destination operand to identify first and second signed doubleword result values corresponding to the first and second source values, respectively.</p><p id="p-0245" num="0251">At <b>2902</b>, the left-shift signed doubleword SRS instruction is decoded. In a microcoded implementation, for example, decoding of the left-shift SRS instruction generates sequences of microoperations which are then executed by the execution circuitry.</p><p id="p-0246" num="0252">At <b>2903</b>, the left-shift signed doubleword SRS instruction is executed to left-shift the first and second signed source values based on the first and second left shift values of the second source operand or immediate to generate first and second signed, shifted values. A positive or negative saturation indication is stored if a positive/negative saturation condition is detected resulting from the left shift of the first and second source values. The first and second signed shifted values may then be rounded and/or saturated in accordance with a rounding mode and/or the positive/negative saturation indication, respectively, to generate the first and second result values in the destination register <b>2660</b>. The first and second signed doubleword result values are then stored in corresponding first and second locations of a destination register.</p><p id="p-0247" num="0253">A method for performing a right-shift signed doubleword SRS instruction is illustrated in <figref idref="DRAWINGS">FIG. <b>30</b></figref>. The method may be performed on the processor and system architectures described herein, but is not limited to any particular processor or system architecture.</p><p id="p-0248" num="0254">At <b>3001</b> a right-shift signed doubleword SRS instruction is fetched, the instruction including a first source operand to identify first and second source values, a second source or immediate to identify first and second right shift values, and a destination operand to identify first and second signed doubleword (32-bit) result values corresponding to the first and second source values, respectively.</p><p id="p-0249" num="0255">At <b>3002</b>, the right-shift signed doubleword SRS instruction is decoded. In a microcoded implementation, for example, decoding of the right-shift SRS instruction generates sequences of microoperations which are then executed by the execution circuitry.</p><p id="p-0250" num="0256">At <b>3003</b>, the right-shift signed doubleword SRS instruction is executed to right-shift the first and second source values based on the first and second right-shift values of the second source operand or immediate to generate first and second shifted values. The first and second shifted values may then be rounded and/or saturated in accordance with a rounding mode and/or a positive/negative saturation indication, respectively, to generate the first and second signed doubleword result values. The first and second signed doubleword result values are then stored in corresponding first and second locations of a destination register.</p><p id="p-0251" num="0257">The following pseudocode sequence defines the operation for additional embodiments of unsigned and signed doubleword SRS instructions which specify four doubleword source and destination values. These embodiments may be particularly useful for implementations with doubleword accumulators.</p><heading id="h-0020" level="2">Unsigned Dword SRS Instructions:</heading><p id="p-0252" num="0000"><ul id="ul0009" list-style="none">    <li id="ul0009-0001" num="0000">    <ul id="ul0010" list-style="none">        <li id="ul0010-0001" num="0258">DVPSRRUD xmm1, xmm2/m128, imm8</li>        <li id="ul0010-0002" num="0259">DVPSRVRUD xmm1, xmm2, xmm3/m128</li>        <li id="ul0010-0003" num="0260">DVPSLSUD xmm1, xmm2/m128, imm8</li>        <li id="ul0010-0004" num="0261">DVPSLVSUD xmm1, xmm2, xmm3/m128</li>    </ul>    </li></ul></p><heading id="h-0021" level="2">Signed Dword SRS Instructions:</heading><p id="p-0253" num="0000"><ul id="ul0011" list-style="none">    <li id="ul0011-0001" num="0000">    <ul id="ul0012" list-style="none">        <li id="ul0012-0001" num="0262">DVPSRARD xmm1, xmm2/m128, imm8</li>        <li id="ul0012-0002" num="0263">DVPSRAVRD xmm1, xmm2, xmm3/m128</li>        <li id="ul0012-0003" num="0264">DVPSLSD xmm1, xmm2/m128, imm8</li>        <li id="ul0012-0004" num="0265">DVPSLVSD xmm1, xmm2, xmm3/m128</li>    </ul>    </li></ul></p><p id="p-0254" num="0266">All of the instructions listed above identify a 128-bit destination register (e.g., xmm1). The DVPSRRUD and DVPSRARD instructions also specify a 128-bit source register or 128-bit memory location (xmm2/m128) and an 8-bit immediate (imm8). The DVPSRVRUD and DVPSRAVRD instructions specify a first 128-bit source register (xmm2) and a second 128-bit source register (xmm3) or memory location (m128). Each of these instructions perform right-shift operations as described below.</p><p id="p-0255" num="0267">The DVPSLSUD and DVPSLSD instructions specify a 128-bit source register or 128-bit memory location (xmm2/m128) and an 8-bit immediate (imm8) and the DVPSLVSUD and DVPSLVSD instructions specify a first 128-bit source register (xmm2) and a second 128-bit source register or memory location (xmm3/m128). Each of these instructions perform left-shift operations as described below.</p><p id="p-0256" num="0268">The following pseudocode sequence defines the operation for one embodiment of the unsigned doubleword SRS instructions:</p><p id="p-0257" num="0000"><tables id="TABLE-US-00008" num="00008"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>TEMP[127:0] &#x2190; SRC2[127:0];</entry></row><row><entry>COUNT0[4:0] &#x2190; (imm8[4:0] OR SRC3[4:0]);</entry></row><row><entry>COUNT1[4:0] &#x2190; (imm8[4:0] OR SRC3[36:32]);</entry></row><row><entry>COUNT2[4:0] &#x2190; (imm8[4:0] OR SRC3[68:64]);</entry></row><row><entry>COUNT3[4:0] &#x2190; (imm8[4:0] OR SRC3[100:96]);</entry></row><row><entry>SAT_POS0 &#x2190; 0;</entry></row><row><entry>SAT_POS1 &#x2190; 0;</entry></row><row><entry>SAT_POS2 &#x2190; 0;</entry></row><row><entry>SAT_POS3 &#x2190; 0;</entry></row><row><entry>SIGN_BIT0 &#x2190; SRC2[31];</entry></row><row><entry>SIGN_BIT1 &#x2190; SRC2[63];</entry></row><row><entry>SIGN_BIT2 &#x2190; SRC2[95];</entry></row><row><entry>SIGN_BIT3 &#x2190; SRC2[127];</entry></row><row><entry>TEMP0[31:0] &#x2190; 0;</entry></row><row><entry>TEMP1[31:0] &#x2190; 0;</entry></row><row><entry>TEMP2[31:0] &#x2190; 0;</entry></row><row><entry>TEMP3[31:0] &#x2190; 0;</entry></row><row><entry>IF (COUNT0 &#x3e; 31)</entry></row><row><entry>&#x2003;COUNT0[31:0] &#x2190; 32;</entry></row><row><entry>FI;</entry></row><row><entry>IF (COUNT1 &#x3e; 31)</entry></row><row><entry>&#x2003;COUNT1[31:0] &#x2190; 32;</entry></row><row><entry>FI;</entry></row><row><entry>IF (COUNT2 &#x3e; 31)</entry></row><row><entry>&#x2003;COUNT2[31:0] &#x2190; 32;</entry></row><row><entry>FI;</entry></row><row><entry>IF (COUNT3 &#x3e; 31)</entry></row><row><entry>&#x2003;COUNT3[31:0] &#x2190; 32;</entry></row><row><entry>FI;</entry></row><row><entry>DO WHILE (COUNT0 != 0)</entry></row><row><entry>&#x2003;&#x2003;IF (Instruction is DVPSLSUD or DVPSLVSUD) THEN</entry></row><row><entry>&#x2003;&#x2003;&#x2003;SAT_POS0 &#x2190; (TEMP[31] | | SAT_POS0); (* Accum Shifted 1&#x2032;s *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;TEMP[31:0] &#x2190; {TEMP[30:0], 1&#x2032;b0} ; (* Left Shift *)</entry></row><row><entry>&#x2003;&#x2003;ELSE (* Instruction is DVPSRRUD or DVPSRVRUD *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;SAT_POS0 &#x2190; 0;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;TEMP0[31:0] &#x2190; {TEMP[0], TEMP0[31:1]};</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;(* Shifted out bits to be used for Rounding *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;TEMP[31:0] &#x2190; {1&#x2032;b0,TEMP[31:1]} ; (* Logical Shift Right *)</entry></row><row><entry>&#x2003;&#x2003;COUNT0 &#x2190; (COUNT0 &#x2212; 1);</entry></row><row><entry>ENDWHILE;</entry></row><row><entry>DO WHILE (COUNT1 != 0)</entry></row><row><entry>&#x2003;&#x2003;IF (Instruction is DVPSLSUD or DVPSLVSUD) THEN</entry></row><row><entry>&#x2003;&#x2003;&#x2003;SAT_POS1 &#x2190; (TEMP[63] | | SAT_POS1); (* Accum Shifted 1&#x2032;s *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;TEMP[63:32] &#x2190; {TEMP[62:32], 1&#x2032;b0} ; (* Left Shift *)</entry></row><row><entry>&#x2003;&#x2003;ELSE (* Instruction is DVPSRRUD or DVPSRVRUD *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;SAT_POS0 &#x2190; 0;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;TEMP1[31:0] &#x2190; {TEMP[32], TEMP1[31:1]};</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;(* Shifted out bits to be used for Rounding *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;TEMP[63:32] &#x2190; {1&#x2032;b0,TEMP[63:33]} ; (* Logical Shift Right *)</entry></row><row><entry>&#x2003;&#x2003;COUNT1 &#x2190; (COUNT1 &#x2212; 1);</entry></row><row><entry>ENDWHILE;</entry></row><row><entry>DO WHILE (COUNT2 != 0)</entry></row><row><entry>&#x2003;&#x2003;IF (Instruction is DVPSLSUD or DVPSLVSUD) THEN</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;SAT_POS2 &#x2190; (TEMP[95] | | SAT_POS2); (* Accum Shifted 1&#x2032;s*)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;TEMP[95:64] &#x2190; {TEMP[94:64], 1&#x2032;b0} ; (* Left Shift *)</entry></row><row><entry>&#x2003;&#x2003;ELSE (* Instruction is DVPSRRUD or DVPSRVRUD *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;SAT_POS2 &#x2190; 0;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;TEMP2[31:0] &#x2190; {TEMP[64], TEMP2[31:1]};</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;(* Shifted out bits to be used for Rounding *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;TEMP[95:64] &#x2190; {1&#x2032;b0,TEMP[95:65]} ; (* Logical Shift Right * )</entry></row><row><entry>&#x2003;&#x2003;COUNT2 &#x2190; (COUNT2 &#x2212; 1);</entry></row><row><entry>ENDWHILE;</entry></row><row><entry>DO WHILE (COUNT3 != 0)</entry></row><row><entry>&#x2003;&#x2003;IF (Instruction is DVPSLSUD or DVPSLVSUD) THEN</entry></row><row><entry>&#x2003;&#x2003;&#x2003;SAT_POS3 &#x2190; (TEMP[127] | | SAT_POS3); (* Accum Shifted 1&#x2032;s *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;TEMP[127:96] &#x2190; {TEMP[126:96], 1&#x2032;b0} ; (* Left Shift *)</entry></row><row><entry>&#x2003;&#x2003;ELSE (* Instruction is DVPSRRUD or DVPSRVRUD *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;SAT_POS3 &#x2190; 0;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;TEMP3[31:0] &#x2190; {TEMP[96], TEMP3[31:1]};</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;(* Shifted out bits to be used for Rounding *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;TEMP[127:96] &#x2190; {1&#x2032;b0,TEMP[127:97]} ; (* Logical Shift Right *)</entry></row><row><entry>&#x2003;&#x2003;COUNT3 &#x2190; (COUNT3 &#x2212; 1);</entry></row><row><entry>ENDWHILE;</entry></row><row><entry>IF (Instruction is DVPSLSUD or DVPSLVSUD) THEN</entry></row><row><entry>&#x2003;&#x2003;RoundBit0 &#x2190; 0;</entry></row><row><entry>&#x2003;&#x2003;RoundBit1 &#x2190; 0;</entry></row><row><entry>&#x2003;&#x2003;RoundBit2 &#x2190; 0;</entry></row><row><entry>&#x2003;&#x2003;RoundBit3 &#x2190; 0;</entry></row><row><entry>ELSE (* Instruction is DVPSRRUD or DVPSRVRUD *)</entry></row><row><entry>&#x2003;&#x2003;RoundBit0 &#x2190; CalcShiftUnSignedDwordRoundBit({TEMP[0],</entry></row><row><entry>&#x2003;&#x2003;TEMP0[31:0]}, MXCSR.IRM[l:0], RoundBit0);</entry></row><row><entry>&#x2003;&#x2003;RoundBit1 &#x2190;</entry></row><row><entry>&#x2003;&#x2003;CalcShiftUnSignedDwordRoundBit({TEMP[32],TEMPl[31:0]},</entry></row><row><entry>&#x2003;&#x2003;MXCSR.IRM[1:0], RoundBit1);</entry></row><row><entry>&#x2003;&#x2003;RoundBit2 &#x2190;</entry></row><row><entry>&#x2003;&#x2003;CalcShiftUnSignedDwordRoundBit({TEMP[64],TEMP2[31:0]},</entry></row><row><entry>&#x2003;&#x2003;MXCSR.IRM[1:0], RoundBit2);</entry></row><row><entry>&#x2003;&#x2003;RoundBit3 &#x2190;</entry></row><row><entry>&#x2003;&#x2003;CalcShiftUnSignedDwordRoundBit({TEMP[96],TEMP3[31:0]},</entry></row><row><entry>&#x2003;&#x2003;MXCSR.IRM[1:0], RoundBit3);</entry></row><row><entry>IF (Instruction is DVPSLSUD or DVPSLVSUD) THEN</entry></row><row><entry>&#x2003;DEST[31:0] &#x2190; SaturateToUnSignedDword(SAT_POS0, TEMP[31:0],</entry></row><row><entry>&#x2003;DEST[31:0]);</entry></row><row><entry>&#x2003;DEST[63:32] &#x2190; SaturateToUnSignedDword(SAT_POS1, TEMP[63:32],</entry></row><row><entry>&#x2003;DEST[63:32]);</entry></row><row><entry>&#x2003;DEST[95:64] &#x2190; SaturateToUnSignedDword(SAT_POS2, TEMP[95:64],</entry></row><row><entry>&#x2003;DEST[95:64]);</entry></row><row><entry>&#x2003;DEST[127:96] &#x2190; SaturateToUnSignedDword(SAT_POS3, TEMP[127:96],</entry></row><row><entry>&#x2003;DEST[127:96]);</entry></row><row><entry>ELSE (* Instruction is DVPSRRUD or DVPSRVRUD *)</entry></row><row><entry>&#x2003;DEST[31:0] &#x2190; (TEMP[31:0] + {31'b0,RoundBit0});</entry></row><row><entry>&#x2003;&#x2003;(* Add Rounding bit with wrapping *)</entry></row><row><entry>&#x2003;DEST[63:32] &#x2190; (TEMP[63:32] + {31&#x2032;b0,RoundBit1});</entry></row><row><entry>&#x2003;&#x2003;(* Add Rounding bit with wrapping *)</entry></row><row><entry>&#x2003;DEST[95:64] &#x2190; (TEMP[95:64] + {31&#x2032;b0,RoundBit2});</entry></row><row><entry>&#x2003;&#x2003;(* Add Rounding bit with wrapping *)</entry></row><row><entry>&#x2003;DEST[127:96] &#x2190; (TEMP[127:96] + {31&#x2032;b0,RoundBit3});</entry></row><row><entry>&#x2003;&#x2003;(* Add Rounding bit with wrapping *)</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0258" num="0269">In accordance with the above code sequence, the four unsigned 32-bit values stored in the first 128-bit source register (SRC<b>2</b>) are shifted based on the four corresponding count values, COUNT0, COUNT1, COUNT 2, and COUNT 3. The four result values are unsigned 32-bit doublewords.</p><p id="p-0259" num="0270">In accordance with the above code sequence, the 5-bit count values, COUNT0, COUNT1, COUNT 2, and COUNT 3, indicate the number of bits to shift right or shift left. Depending on the instruction, the count values are provided by an immediate (imm8) or a second source register or memory location (SRC<b>3</b>). The shifted values are then rounded and saturated to generate four 32-bit results, which are stored in bits 31:0, 63:32, 95:64, and 127:96 of the destination register.</p><p id="p-0260" num="0271"><figref idref="DRAWINGS">FIG. <b>31</b></figref> illustrates one particular implementation in which unsigned 32-bit data elements A-D are stored in a 128-bit source register or memory location <b>3105</b>. Shift units, <b>3112</b> and <b>3111</b>, of the execution circuitry <b>3100</b> shift the lower and upper values, respectively, based on the corresponding count values, COUNT0 and COUNT1 (which, as mentioned, are provided via an immediate or second source register/memory location).</p><p id="p-0261" num="0272">The shift direction (i.e., right or left) is determined by the specific instruction being executed. As mentioned, DVPSLSUD and DVPSLVSUD perform left-shift operations while DVPSRRUD and DVPSRVRUD perform right-shift operations. Because the values are unsigned, logical right-shift operations are performed.</p><p id="p-0262" num="0273">The resulting shifted values are provided to rounding/saturation units <b>3122</b> and <b>3121</b> which perform the rounding/saturation operations described herein to generate the four 32-bit results <b>3151</b>-<b>3154</b> in the 128-bit destination register <b>3160</b>.</p><p id="p-0263" num="0274">As in prior embodiments, a control/status register <b>3112</b> such as an MXCSR register, includes a set of rounding control bits which indicate a rounding mode to be used by the rounding/saturation units <b>3122</b> and <b>3121</b>. In one particular implementation, the rounding control bits <b>3112</b>A comprise two bits in an IRM control field of the MXCSR register <b>3112</b>.</p><p id="p-0264" num="0275">Additionally, in some embodiments, the rounding/saturation units <b>3122</b> and <b>3121</b> can determine whether saturation is to be performed based upon detecting overflow or underflow. For example, when a saturation condition is detected, each of the final 32-bit results <b>3151</b>-<b>3154</b> can be saturated to a most positive or most negative value. In the code sequence listed above, the SAT_POS0, SAT_POS1, SAT_POS2, and SAT_POS3 values are set to 1 when the left shift operation performed by DVPSLSUD and DVPSLVSUD shifts out a binary 1. In one embodiment, this causes corresponding saturation bit(s) <b>3112</b>B in the control register <b>3112</b> to be set to 1. Thus, a saturation can be determined based on the value of SAT_POS0-SAT_POS3 during left shift operations and reflected in the corresponding saturation bit(s) <b>3112</b>B for use by subsequent operations. In one embodiment, the SAT_POS0-SAT_POS3 values and/or the corresponding saturation bit(s) <b>3112</b>B are maintained at 0 for the DVPSRRUD or DVPSRVRUD instructions because the most significant is are maintained during right shift operations.</p><p id="p-0265" num="0276">As mentioned, a saturation field <b>3112</b>B of the control/status register(s) <b>3112</b> can be set to indicate saturation. For example, the MXCSR.SAT bit (e.g, MXCSR[20]) can be set to indicate that the saturation has occurred. Thus, in some embodiments, a value in a saturation field <b>3112</b>B of the control/status register(s) <b>3112</b> can be updated when the execution circuitry <b>3100</b> detects that saturation has occurred responsive to the prior executed operations on the data values. In some embodiments the saturation field <b>3112</b>B can be a single bit location that can ordinarily be a zero but set to a value of one when saturation is detected.</p><p id="p-0266" num="0277">Following rounding/saturation, the 32-bit result values <b>3151</b>-<b>3154</b> are stored in bits 31:0, 63:32, 95:64, and 127:96 of the 128-bit destination register <b>3160</b>.</p><p id="p-0267" num="0278">A method for performing a left-shift unsigned doubleword SRS instruction is illustrated in <figref idref="DRAWINGS">FIG. <b>32</b></figref>. The method may be performed on the processor or system architectures described herein, but is not limited to any particular processor or system architecture.</p><p id="p-0268" num="0279">At <b>3201</b> a left-shift unsigned doubleword SRS instruction is fetched, the instruction including a first source operand to identify first through fourth source values, a second source or immediate to identify first through fourth left shift values, and a destination operand to identify first through fourth result values corresponding to the first through fourth source values, respectively.</p><p id="p-0269" num="0280">At <b>3202</b>, the left-shift unsigned doubleword SRS instruction is decoded. In a microcoded implementation, for example, decoding of the left-shift unsigned doubleword SRS instruction generates sequences of microoperations which are then executed by the execution circuitry.</p><p id="p-0270" num="0281">At <b>3203</b>, the left-shift unsigned doubleword SRS instruction is executed to left-shift the first through fourth source values based on the first through fourth left shift values of the second source operand or immediate to generate first through fourth shifted values. A saturation indication is stored if a saturation condition is detected resulting from the left shift of the first through fourth source values (e.g., from shifting out a most-significant 1). The first through fourth shifted values may then be rounded and/or saturated in accordance with a rounding mode and/or the saturation indication, respectively, to generate the first through fourth result values in the destination register <b>2160</b>. The first through fourth result values are then stored in corresponding first through fourth locations of a destination register.</p><p id="p-0271" num="0282">A method for performing a right-shift unsigned doubleword SRS instruction is illustrated in <figref idref="DRAWINGS">FIG. <b>33</b></figref>. The method may be performed on the processor and system architectures described herein, but is not limited to any particular processor or system architecture.</p><p id="p-0272" num="0283">At <b>3301</b> a right-shift unsigned doubleword SRS instruction is fetched, the instruction including a first source operand to identify first through fourth source values, a second source or immediate to identify first through fourth right shift values, and a destination operand to identify first through fourth result values corresponding to the first through fourth source values, respectively.</p><p id="p-0273" num="0284">At <b>3302</b>, the right-shift unsigned doubleword SRS instruction is decoded. In a microcoded implementation, for example, decoding of the right-shift/round/saturate instruction generates sequences of microoperations which are then executed by the execution circuitry.</p><p id="p-0274" num="0285">At <b>3303</b>, the right-shift unsigned doubleword SRS instruction is executed to right-shift the first through fourth source values based on the first through fourth right-shift values of the second source operand or immediate to generate first through fourth shifted values. The first through fourth shifted values may then be rounded and/or saturated in accordance with a rounding mode and/or a saturation indication, respectively, to generate the first through fourth result values. The first through fourth result values are then stored in corresponding first through fourth locations of a destination register.</p><p id="p-0275" num="0286">The following pseudocode sequence defines the operation for one embodiment of the signed doubleword SRS instructions DVPSRARD, DVPSRAVRD, DVPSLSD, and DVPSLVSD:</p><p id="p-0276" num="0000"><tables id="TABLE-US-00009" num="00009"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="273pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>TEMP[127:0] &#x2190; SRC2[127:0];</entry></row><row><entry>COUNT0[4:0] &#x2190; (imm8[4:0] OR SRC3[4:0]);</entry></row><row><entry>COUNT1[4:0] &#x2190; (imm8[5:0] OR SRC3[36:32]);</entry></row><row><entry>COUNT2[4:0] &#x2190; (imm8[5:0] OR SRC3[68:64]);</entry></row><row><entry>COUNT3[4:0] &#x2190; (imm8[5:0] OR SRC3[100:96]);</entry></row><row><entry>IF (COUNT0 &#x3e; 31)</entry></row><row><entry>&#x2003;COUNT0[31:0] &#x2190; 32;</entry></row><row><entry>FI;</entry></row><row><entry>IF (COUNT1 &#x3e; 31)</entry></row><row><entry>&#x2003;COUNT1[31:0] &#x2190; 32;</entry></row><row><entry>FI;</entry></row><row><entry>IF (COUNT2 &#x3e; 31)</entry></row><row><entry>&#x2003;COUNT2[31:0] &#x2190; 32;</entry></row><row><entry>FI;</entry></row><row><entry>IF (COUNT3 &#x3e; 31)</entry></row><row><entry>&#x2003;COUNT3[31:0] &#x2190; 32;</entry></row><row><entry>FI;</entry></row><row><entry>SIGN_BIT0 &#x2190; SRC2[31];</entry></row><row><entry>SIGN_BIT1 &#x2190; SRC2[63];</entry></row><row><entry>SIGN_BIT2 &#x2190; SRC2[95];</entry></row><row><entry>SIGN_BIT3 &#x2190; SRC2[127];</entry></row><row><entry>SAT_POS0 &#x2190; 0;</entry></row><row><entry>SAT_POS1 &#x2190; 0;</entry></row><row><entry>SAT_POS2 &#x2190; 0;</entry></row><row><entry>SAT_POS3 &#x2190; 0;</entry></row><row><entry>SAT_NEG0 &#x2190; 0;</entry></row><row><entry>SAT_NEG1 &#x2190; 0;</entry></row><row><entry>SAT_NEG2 &#x2190; 0;</entry></row><row><entry>SAT_NEG3 &#x2190; 0;</entry></row><row><entry>TEMP0[31:0] &#x2190; 0;</entry></row><row><entry>TEMP1[31:0] &#x2190; 0;</entry></row><row><entry>TEMP2[31:0] &#x2190; 0;</entry></row><row><entry>TEMP3[31:0] &#x2190; 0;</entry></row><row><entry>TEMP4[31:0] &#x2190; 0;</entry></row><row><entry>TEMP5[31:0] &#x2190; 0;</entry></row><row><entry>TEMP6[31:0] &#x2190; 0;</entry></row><row><entry>TEMP7[31:0] &#x2190; 0;</entry></row><row><entry>(* First Dword Accumulator *)</entry></row><row><entry>DO WHILE (COUNT0 != 0)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;IF (Instruction is DVPSLSD OR DVPSLVSD) THEN</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;SAT_POS0 &#x2190; ((~SIGN_BIT0 &#x26;TEMP[30]) ? 1 : 0) | | SAT_POS0 ;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;(* Check Sign Bit for Positive Saturation *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;SAT_NEG0 &#x2190; ((SIGN_BIT0 &#x26; ~TEMP[30]) ? 1 : 0) | | SAT_NEG0 ;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;(* Check Sign Bit for Negative Saturation *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;TEMP [31:0] &#x2190; {TEMP[30:0], 1&#x2032;b0}) ;(* Left Shift *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;ELSE (* Instruction is DVPSRARD OR DVPSRAVRD *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;SAT_POS0 &#x2190; 0;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;SAT_NEG0 &#x2190; 0;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;TEMP0[31:0] &#x2190; {TEMP[0], TEMP0[31:1]}; (* Shifted bits *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;TEMP[31:0] &#x2190; {TEMP[31], TEMP[31:1]}; (* Arith Rt Shift *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;COUNT0 &#x2190; (COUNT0 &#x2212; 1);</entry></row><row><entry>ENDWHILE;</entry></row><row><entry>(* Second Dword Accumulator *)</entry></row><row><entry>DO WHILE (COUNT1 != 0)</entry></row><row><entry>&#x2003;IF (Instruction is DVPSLSD OR DVPSLVSD) THEN</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;SAT_POS1 &#x2190; ((~SIGN_BIT1 &#x26;TEMP[62]) ? 1 : 0) | | SAT_POS1 ;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;(* Check Sign Bit for Positive Saturation *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;SAT_NEG1 &#x2190; ((SIGN_BIT1 &#x26; ~TEMP[62]) ? 1 : 0) | | SAT_NEG1 ;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;(* Check Sign Bit for Negative Saturation *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;TEMP [63:32] &#x2190; {TEMP[62:32], 1&#x2032;b0}) ;(* Left Shift *)</entry></row><row><entry>&#x2003;&#x2003;ELSE (* Instruction is DVPSRARD OR DVPSRAVRD *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;SAT_POS1 &#x2190; 0;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;SAT_NEG1 &#x2190; 0;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;TEMP1[31:0] &#x2190; {TEMP[32], TEMPl[31:1]}; (* Shifted bits *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;TEMP[63:32] &#x2190; {TEMP[63], TEMP[63:33]}; (* Arith Right Shift *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;COUNT1 &#x2190; (COUNT1 &#x2212; 1);</entry></row><row><entry>ENDWHILE;</entry></row><row><entry>(* Third Dword Accumulator *)</entry></row><row><entry>DO WHILE (COUNT2 != 0)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;IF (Instruction is DVPSLSD OR DVPSLVSD) THEN</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;SAT_POS2 &#x2190; ((~SIGN_BIT2 &#x26;TEMP[94]) ? 1 : 0) | | SAT_POS2 ;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;(* Check Sign Bit for Positive Saturation *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;SAT_NEG2 &#x2190; ((SIGN_BIT2 &#x26; ~TEMP[94]) ? 1 : 0) | | SAT_NEG2 ;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;(* Check Sign Bit for Negative Saturation *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;TEMP[95:64] &#x2190; {TEMP[94:64], 1&#x2032;b0}) ;(* Left Shift *)</entry></row><row><entry>&#x2003;ELSE (* Instruction is DVPSRARD OR DVPSRAVRD *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;SAT_POS2 &#x2190; 0;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;SAT_NEG2 &#x2190; 0;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;TEMP2[31:0] &#x2190; {TEMP[64], TEMP2[31:1]}; (* Shifted bits *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;TEMP[95:64] &#x2190; {TEMP[95], TEMP[95:65]}; (* Arith Rt Shft *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;COUNT2 &#x2190; (COUNT2 &#x2212; 1);</entry></row><row><entry>ENDWHILE;</entry></row><row><entry>(* Fourth Dword Accumulator *)</entry></row><row><entry>DO WHILE (COUNT3 != 0)</entry></row><row><entry>&#x2003;IF (Instruction is DVPSLSD OR DVPSLVSD) THEN</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;SAT_POS3 &#x2190; ((~SIGN_BIT3 &#x26;TEMP[126]) ? 1 : 0) | |</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;SAT_POS3 ; (* Check Sign Bit for Positive Saturation *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;SAT_NEG3 &#x2190; ((SIGN_BIT3 &#x26; ~TEMP[126]) ? 1 : 0) | |</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;SAT_NEG3 ; (* Check Sign Bit for Negative Saturation *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;TEMP [127:96] &#x2190; {TEMP[126:64], 1&#x2032;b0}) ; (* Left Shift *)</entry></row><row><entry>&#x2003;ELSE (* Instruction is DVPSRARD OR DVPSRAVRD *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;SAT_POS3 &#x2190; 0;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;SAT_NEG3 &#x2190; 0;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;TEMP3[31:0] &#x2190; {TEMP[96], TEMP3[31:1]}; (* Shifted bits *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;TEMP[127:96] &#x2190; {TEMP[127], TEMP[127:97]} ;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;(* Arithmetic Right Shift *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;COUNT3 &#x2190; (COUNT3 &#x2212; 1);</entry></row><row><entry>ENDWHILE;</entry></row><row><entry>IF (Instruction is DVPSLSD OR DVPSLVSD) THEN</entry></row><row><entry>&#x2003;&#x2003;&#x2003;RoundBit0 &#x2190; 0;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;RoundBit1 &#x2190; 0;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;RoundBit2 &#x2190; 0;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;RoundBit3 &#x2190; 0;</entry></row><row><entry>ELSE (* Instruction is DVPSRARD OR DVPSRAVRD *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;RoundBit0 &#x2190; CalcShiftSignedDwordRoundBit({TEMP[0],TEMP0[31:0]},</entry></row><row><entry>&#x2003;&#x2003;&#x2003;SIGN_BIT0, MXCSR.IRM[l:0], RoundBit0);</entry></row><row><entry>&#x2003;&#x2003;&#x2003;RoundBit1 &#x2190;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;CalcShiftSignedDwordRoundBit({TEMP[32],TEMPl[31:0]}, SIGN_BIT1,</entry></row><row><entry>&#x2003;&#x2003;&#x2003;MXCSR.IRM[1:0], RoundBit1);</entry></row><row><entry>&#x2003;&#x2003;&#x2003;RoundBit2 &#x2190;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;CalcShiftSignedDwordRoundBit({TEMP[64],TEMP2[31:0]}, SIGN_BIT2,</entry></row><row><entry>&#x2003;&#x2003;&#x2003;MXCSR.IRM[1:0], RoundBit2);</entry></row><row><entry>&#x2003;&#x2003;&#x2003;RoundBit3 &#x2190;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;CalcShiftSignedDwordRoundBit({TEMP[96],TEMP3[31:0]}, SIGN_BIT3,</entry></row><row><entry>&#x2003;&#x2003;&#x2003;MXCSR.IRM[1:0], RoundBit3);</entry></row><row><entry>IF (Instruction is DVPSLSD OR DVPSLVSD) THEN</entry></row><row><entry>&#x2003;&#x2003;&#x2003;DEST[31:0] &#x2190; AddBitSaturateToSignedDword(TEMP[31:0], 0,</entry></row><row><entry>&#x2003;&#x2003;&#x2003;SAT_POS0, SAT_NEG0, DEST[31:0]);</entry></row><row><entry>&#x2003;&#x2003;&#x2003;DEST[63:32] &#x2190; AddBitSaturateToSignedDword(TEMP[63:32], 0,</entry></row><row><entry>&#x2003;&#x2003;&#x2003;SAT_POS1, SAT_NEG1, DEST[63:32]);</entry></row><row><entry>&#x2003;&#x2003;&#x2003;DEST[95:64] &#x2190; AddBitSaturateToSignedDword(TEMP[95:64], 0,</entry></row><row><entry>&#x2003;&#x2003;&#x2003;SAT_POS2, SAT_NEG2, DEST[95:64]);</entry></row><row><entry>&#x2003;&#x2003;&#x2003;DEST[127:96] &#x2190; AddBitSaturateToSignedDWord(TEMP[127:96], 0,</entry></row><row><entry>&#x2003;&#x2003;&#x2003;SAT_POS3, SAT_NEG3, DEST[127:96]);</entry></row><row><entry>ELSE (* Instruction is DVPSRARD OR DVPSRAVRD *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;DEST[31:0] &#x2190; (TEMP[31:0] + {31&#x2032;b0,RoundBit0});</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;(* Add Rounding bit with wrapping *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;DEST[63:32] &#x2190; (TEMP[63:32] + {31&#x2032;b0,RoundBit1});</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;(* Add Rounding bit with wrapping *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;DEST[95:64] &#x2190; (TEMP[95:64] + {31&#x2032;b0,RoundBit2});</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;(* Add Rounding bit with wrapping *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;DEST[127:96] &#x2190; (TEMP[127:96] + {31&#x2032;b0,RoundBit3});</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;(* Add Rounding bit with wrapping *)</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0277" num="0287">Thus, as in prior embodiments, the signed doubleword SRS instructions use positive saturation flags (SAT_POS0, SAT_POS1, SAT_POS2, and SAT_POS3) to indicate positive saturation and negative saturation flags (SAT_NEG0, SAT_NEG1, SAT_NEG2, and SAT_NEG3) to indicate positive or negative saturation, respectively. The rounding/saturation units <b>3121</b>-<b>3124</b> can then evaluate the positive and negative saturation flags to determine whether the result values are to be saturated negatively or positively. The signed SRS instructions must also process the sign values (SIGN_BIT0, SIGN_BIT1, SIGN_BIT2, and SIGN_BIT3) for each of the signed doubleword source values.</p><p id="p-0278" num="0288">DVPSLSD and DVPSLVSD perform left-shift operations and DVPSRARD and DVPSRAVRD perform right-shift operations. Because the values are signed, DVPSRARD and DVPSRAVRD perform arithmetic shift-right operations in which the sign bit is shifted in from the left as the least significant bit values are shifted out to the right.</p><p id="p-0279" num="0289">A method for performing a left-shift signed doubleword SRS instruction is illustrated in <figref idref="DRAWINGS">FIG. <b>34</b></figref>. The method may be performed on the processor or system architectures described herein, but is not limited to any particular processor or system architecture.</p><p id="p-0280" num="0290">At <b>3401</b> a left-shift signed doubleword SRS instruction is fetched, the instruction including a first source operand to identify first through fourth source values, a second source or immediate to identify first through fourth left shift values, and a destination operand to identify first through fourth result values corresponding to the first through fourth source values, respectively.</p><p id="p-0281" num="0291">At <b>3402</b>, the left-shift signed doubleword SRS instruction is decoded. In a microcoded implementation, for example, decoding of the left-shift SRS instruction generates sequences of microoperations which are then executed by the execution circuitry.</p><p id="p-0282" num="0292">At <b>3403</b>, the left-shift signed doubleword SRS instruction is executed to left-shift the first through fourth signed source values based on the first through fourth left shift values of the second source operand or immediate to generate first through fourth signed, shifted values. A positive or negative saturation indication is stored if a positive/negative saturation condition is detected resulting from the left shift of the first through fourth source values. The first through fourth signed shifted values may then be rounded and/or saturated in accordance with a rounding mode and/or the positive/negative saturation indication, respectively, to generate the first through fourth result values in the destination register <b>2160</b>. The first through fourth result values are then stored in corresponding first through fourth locations of a destination register.</p><p id="p-0283" num="0293">A method for performing a right-shift signed doubleword SRS instruction is illustrated in <figref idref="DRAWINGS">FIG. <b>35</b></figref>. The method may be performed on the processor and system architectures described herein, but is not limited to any particular processor or system architecture.</p><p id="p-0284" num="0294">At <b>3501</b> a right-shift signed doubleword SRS instruction is fetched, the instruction including a first source operand to identify first through fourth source values, a second source or immediate to identify first through fourth right shift values, and a destination operand to identify first through fourth result values corresponding to the first through fourth source values, respectively.</p><p id="p-0285" num="0295">At <b>3502</b>, the right-shift signed doubleword SRS instruction is decoded. In a microcoded implementation, for example, decoding of the right-shift SRS instruction generates sequences of microoperations which are then executed by the execution circuitry.</p><p id="p-0286" num="0296">At <b>3503</b>, the right-shift SRS instruction is executed to right-shift the first through fourth source values based on the first through fourth right-shift values of the second source operand or immediate to generate first through fourth shifted values. The first through fourth shifted values may then be rounded and/or saturated in accordance with a rounding mode and/or a positive/negative saturation indication, respectively, to generate the first through fourth result values. The first through fourth result values are then stored in corresponding first through fourth locations of a destination register.</p><p id="p-0287" num="0297">One embodiment includes another pair of signed right-shift doubleword SRS instructions which operate using logical right-shift operations (instead of arithmetic right shift operations as in the prior signed embodiments). In order to do so, these instructions maintain the sign bits and all shifted out bits in temporary storage to be used for the rounding operations. The signed right-shift doubleword SRS instructions of this embodiment are defined as follows:<ul id="ul0013" list-style="none">    <li id="ul0013-0001" num="0000">    <ul id="ul0014" list-style="none">        <li id="ul0014-0001" num="0298">DVPSRLRD xmm1, xmm2/m128, imm8</li>        <li id="ul0014-0002" num="0299">DVPSRLVRD xmm1, xmm2, xmm3/m128</li>    </ul>    </li></ul></p><p id="p-0288" num="0300">The following pseudocode sequence defines the operation of the above instructions in accordance with one embodiment:</p><p id="p-0289" num="0000"><tables id="TABLE-US-00010" num="00010"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>TEMP[127:0] &#x2190; SRC2[127:0];</entry></row><row><entry>COUNT0[4:0] &#x2190; (imm8[4:0] OR SRC3[4:0]);</entry></row><row><entry>COUNT1[4:0] &#x2190; (imm8[4:0] OR SRC3[36:32]);</entry></row><row><entry>COUNT2[4:0] &#x2190; (imm8[4:0] OR SRC3[68:64]);</entry></row><row><entry>COUNT3[4:0] &#x2190; (imm8[4:0] OR SRC3[100:96]);</entry></row><row><entry>SIGN_BIT0 &#x2190; SRC2[31];</entry></row><row><entry>SIGN_BIT1 &#x2190; SRC2[63];</entry></row><row><entry>SIGN_BIT2 &#x2190; SRC2[95];</entry></row><row><entry>SIGN_BIT3 &#x2190; SRC2[127];</entry></row><row><entry>TEMP0[31:0] &#x2190; 0;</entry></row><row><entry>TEMP1[31:0] &#x2190; 0;</entry></row><row><entry>TEMP2[31:0] &#x2190; 0;</entry></row><row><entry>TEMP3[31:0] &#x2190; 0;</entry></row><row><entry>DO WHILE (COUNT0 != 0)</entry></row><row><entry>&#x2003;&#x2003;IF (* Instruction is DVPSRLRD or DVPSRLVRD *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;TEMP0[31:0] &#x2190; {TEMP[0], TEMP0[31:1]};</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;(* Shifted out bits to be used for Rounding *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;TEMP[31:0] &#x2190; {1&#x2032;b0,TEMP[31:1]} ; (* Logical Shift Right *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;COUNT0 &#x2190; (COUNT0 &#x2212; 1);</entry></row><row><entry>ENDWHILE;</entry></row><row><entry>DO WHILE (COUNT1 != 0)</entry></row><row><entry>&#x2003;&#x2003;IF (* Instruction is DVPSRLRD or DVPSRLVRD *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;TEMP1[31:0] &#x2190; {TEMP[32], TEMP1[31:1]};</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;(* Shifted out bits to be used for Rounding *)</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;TEMP[63:32] &#x2190; {1&#x2032;b0,TEMP[63:33]} ; (* Logical Shift Right *)</entry></row><row><entry>&#x2003;&#x2003;COUNT1 &#x2190; (COUNT1 &#x2212; 1);</entry></row><row><entry>ENDWHILE;</entry></row><row><entry>DO WHILE (COUNT2 != 0)</entry></row><row><entry>&#x2003;&#x2003;IF (* Instruction is DVPSRLRD or DVPSRLVRD *)</entry></row><row><entry>&#x2003;&#x2003;TEMP2[31:0] &#x2190; {TEMP[64], TEMP2[31:1]};</entry></row><row><entry>&#x2003;&#x2003;(* Shifted out bits to be used for Rounding *)</entry></row><row><entry>&#x2003;&#x2003;TEMP[95:64] &#x2190; {1&#x2032;b0,TEMP[95:65]} ; (* Logical Shift Right *)</entry></row><row><entry>&#x2003;&#x2003;COUNT2 &#x2190; (COUNT2 &#x2212; 1);</entry></row><row><entry>ENDWHILE;</entry></row><row><entry>DO WHILE (COUNT3 != 0)</entry></row><row><entry>&#x2003;&#x2003;IF (* Instruction is DVPSRLRD or DVPSRLVRD *)</entry></row><row><entry>&#x2003;&#x2003;TEMP3[31:0] &#x2190; {TEMP[96], TEMP3[31:1]};</entry></row><row><entry>&#x2003;&#x2003;(* Shifted out bits to be used for Rounding *)</entry></row><row><entry>&#x2003;&#x2003;TEMP[127:96] &#x2190; {1&#x2032;b0,TEMP[127:97]} ; (* Logical Shift Right *)</entry></row><row><entry>&#x2003;&#x2003;COUNT3 &#x2190; (COUNT3 &#x2212; 1);</entry></row><row><entry>ENDWHILE;</entry></row><row><entry>IF (* Instruction is DVPSRLRD or DVPSRLVRD *)</entry></row><row><entry>&#x2003;&#x2003;RoundBit0 &#x2190; CalcShiftSignedDwordRoundBit((TEMP[0],</entry></row><row><entry>&#x2003;&#x2003;TEMP0[31:0]}, SIGN_BIT0, MXCSR.IRM[1:0], RoundBit0);</entry></row><row><entry>&#x2003;&#x2003;RoundBit1 &#x2190;</entry></row><row><entry>&#x2003;&#x2003;CalcShiftSignedDwordRoundBit({TEMP[32],TEMPl[31:0]}, SIGN_BIT1,</entry></row><row><entry>&#x2003;&#x2003;MXCSR.IRM[1:0], RoundBit1);</entry></row><row><entry>&#x2003;&#x2003;RoundBit2 &#x2190;</entry></row><row><entry>&#x2003;&#x2003;CalcShiftSignedDwordRoundBit({TEMP[64],TEMP2[31:0]}, SIGN_BIT2,</entry></row><row><entry>&#x2003;&#x2003;MXCSR.IRM[1:0], RoundBit2);</entry></row><row><entry>&#x2003;&#x2003;RoundBit3 &#x2190;</entry></row><row><entry>&#x2003;&#x2003;CalcShiftSignedDwordRoundBit({TEMP[96],TEMP3[31:0]}, SIGN_BIT3,</entry></row><row><entry>&#x2003;&#x2003;MXCSR.IRM[1:0], RoundBit3);</entry></row><row><entry>IF (* Instruction is DVPSRLRD or DVPSRLVRD *)</entry></row><row><entry>&#x2003;DEST[31:0] &#x2190; (TEMP[31:0] + {31&#x2032;b0,RoundBit0});</entry></row><row><entry>&#x2003;&#x2003;(* Add Rounding bit with wrapping *)</entry></row><row><entry>&#x2003;DEST[63:32] &#x2190; (TEMP[63:32] + {31&#x2032;b0,RoundBit1});</entry></row><row><entry>&#x2003;&#x2003;(* Add Rounding bit with wrapping *)</entry></row><row><entry>&#x2003;DEST[95:64] &#x2190; (TEMP[95:64] + {31&#x2032;b0, RoundBit2});</entry></row><row><entry>&#x2003;&#x2003;(* Add Rounding bit with wrapping *)</entry></row><row><entry>&#x2003;DEST[127:96] &#x2190; (TEMP[127:96] + {31&#x2032;b0,RoundBit3});</entry></row><row><entry>&#x2003;&#x2003;(* Add Rounding bit with wrapping *)</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0290" num="0301">References to &#x201c;one embodiment,&#x201d; &#x201c;an embodiment,&#x201d; &#x201c;an example embodiment,&#x201d; etc., indicate that the embodiment described may include a particular feature, structure, or characteristic, but every embodiment may not necessarily include the particular feature, structure, or characteristic. Moreover, such phrases are not necessarily referring to the same embodiment. Further, when a particular feature, structure, or characteristic is described in connection with an embodiment, it is submitted that it is within the knowledge of one skilled in the art to affect such feature, structure, or characteristic in connection with other embodiments whether or not explicitly described.</p><heading id="h-0022" level="1">EXAMPLES</heading><p id="p-0291" num="0302">The following are example implementations of different embodiments of the invention.</p><p id="p-0292" num="0303">Example 1. An apparatus comprising: a decoder to decode an instruction having fields for a first packed data source operand to provide a first source data element and a second source data element, a second packed data source operand or immediate to provide a first shift value and a second shift value corresponding to the first source data element and second source data element, respectively, and a packed data destination operand to indicate a first result value and a second result value corresponding to the first source data element and second source data element, and execution circuitry to execute the decoded instruction to: shift the first source data element by an amount based on the first shift value to generate a first shifted data element; shift the second source data element by an amount based on the second shift value to generate a second shifted data element; update a saturation indicator responsive to detecting a saturation condition resulting from the shift of the first and/or second source data elements; round and/or saturate the first and second shifted data elements in accordance with a specified rounding mode and the saturation indicator, respectively, to generate the first and second result data elements; and store the first result value and the second result value in a first data element location and a second data element location in a destination register.</p><p id="p-0293" num="0304">Example 2. The apparatus of example 1 wherein the first packed data source operand is to further provide a third source data element and a fourth source data element, the second packed data source operand or immediate is to further provide a third shift value and a fourth shift value corresponding to the third source data element and fourth source data element, and the packed data destination operand is to indicate a third result value and a fourth result value corresponding to the third source data element and the fourth source data element, and the execution circuitry to execute the decoded instruction to: shift the third source data element by an amount based on the third shift value to generate a third shifted data element; shift the fourth source data element by an amount based on the fourth shift value to generate a fourth shifted data element; update a saturation indicator responsive to detecting a saturation condition resulting from the shift of the third and/or fourth source data elements; round and/or saturate the third and fourth shifted data elements in accordance with a specified rounding mode and the saturation indicator, respectively, to generate the third and fourth result data elements; and store the third result value and the fourth result value in a third data element location and a fourth data element location in a destination register.</p><p id="p-0294" num="0305">Example 3. The apparatus of example 1 wherein the execution circuitry is to right-shift the first and second source data elements by the amount based on the first and second shift values, respectively.</p><p id="p-0295" num="0306">Example 4. The apparatus of example 3 wherein the first and second source data elements and the first and second result values comprise signed word or signed doubleword values.</p><p id="p-0296" num="0307">Example 5. The apparatus of example 4 wherein the right-shift comprises an arithmetic right shift in which a sign value of the first and second source data elements is preserved.</p><p id="p-0297" num="0308">Example 6. The apparatus of example 1 wherein the execution circuitry is to left-shift the first and second source data elements by the amount based on the first and second shift values, respectively.</p><p id="p-0298" num="0309">Example 7. The apparatus of example 5 wherein the execution circuitry is to set a positive saturation flag upon detecting a saturation condition associated with the left-shift, the positive saturation flag to be used during the round and/or saturate operations to generate positively saturated values for the first result value or the second result value.</p><p id="p-0299" num="0310">Example 8. The apparatus of example 4 wherein the execution circuitry is to set a positive saturation flag upon detecting a first saturation condition associated with the left-shift and a negative saturation flag associated with a second saturation condition associated with the left-shift, one of the positive and negative saturation flags to be used during the round and/or saturate operations to generate positively or negatively saturated values for the first result value or the second result value.</p><p id="p-0300" num="0311">Example 9. A method comprising: decoding an instruction having fields for a first packed data source operand to provide a first source data element and a second source data element, a second packed data source operand or immediate to provide a first shift value and a second shift value corresponding to the first source data element and second source data element, respectively, and a packed data destination operand to indicate a first result value and a second result value corresponding to the first source data element and second source data element, and executing the decoded instruction to perform the operations of: shifting the first source data element by an amount based on the first shift value to generate a first shifted data element; shifting the second source data element by an amount based on the second shift value to generate a second shifted data element; updating a saturation indicator responsive to detecting a saturation condition resulting from the shift of the first and/or second source data elements; rounding and/or saturating the first and second shifted data elements in accordance with a specified rounding mode and the saturation indicator, respectively, to generate the first and second result data elements; and store the first result value and the second result value in a first data element location and a second data element location in a destination register.</p><p id="p-0301" num="0312">Example 10. The method of example 9 wherein the first packed data source operand is to further provide a third source data element and a fourth source data element, the second packed data source operand or immediate is to further provide a third shift value and a fourth shift value corresponding to the third source data element and fourth source data element, and the packed data destination operand is to indicate a third result value and a fourth result value corresponding to the third source data element and the fourth source data element, the method further comprising: shifting the third source data element by an amount based on the third shift value to generate a third shifted data element; shifting the fourth source data element by an amount based on the fourth shift value to generate a fourth shifted data element; updating a saturation indicator responsive to detecting a saturation condition resulting from the shifting of the third and/or fourth source data elements; rounding and/or saturating the third and fourth shifted data elements in accordance with a specified rounding mode and the saturation indicator, respectively, to generate the third and fourth result data elements; and storing the third result value and the fourth result value in a third data element location and a fourth data element location in a destination register.</p><p id="p-0302" num="0313">Example 11. The method of example 9 wherein shifting comprises right-shifting the first and second source data elements by the amount based on the first and second shift values, respectively.</p><p id="p-0303" num="0314">Example 12. The method of example 9 wherein the first and second source data elements and the first and second result values comprise signed word or signed doubleword values.</p><p id="p-0304" num="0315">Example 13. The method of example 12 wherein the right-shifting comprises an arithmetic right shift in which a sign value of the first and second source data elements is preserved.</p><p id="p-0305" num="0316">Example 14. The method of example 9 wherein shifting comprises left-shifting the first and second source data elements by the amount based on the first and second shift values, respectively.</p><p id="p-0306" num="0317">Example 15. The method of example 13 further comprising: setting a positive saturation flag upon detecting a saturation condition associated with the left-shift, the positive saturation flag to be used during the round and/or saturate operations to generate positively saturated values for the first result value or the second result value.</p><p id="p-0307" num="0318">Example 16. The method of example 12 further comprising: setting a positive saturation flag upon detecting a first saturation condition associated with the left-shift and a negative saturation flag associated with a second saturation condition associated with the left-shift, one of the positive and negative saturation flags to be used during the round and/or saturate operations to generate positively or negatively saturated values for the first result value or the second result value.</p><p id="p-0308" num="0319">Example 17. A machine-readable medium having program code stored thereon which, when executed by a machine, causes the machine to perform the operations of: decoding an instruction having fields for a first packed data source operand to provide a first source data element and a second source data element, a second packed data source operand or immediate to provide a first shift value and a second shift value corresponding to the first source data element and second source data element, respectively, and a packed data destination operand to indicate a first result value and a second result value corresponding to the first source data element and second source data element, and executing the decoded instruction to perform the operations of: shifting the first source data element by an amount based on the first shift value to generate a first shifted data element; shifting the second source data element by an amount based on the second shift value to generate a second shifted data element; updating a saturation indicator responsive to detecting a saturation condition resulting from the shift of the first and/or second source data elements; rounding and/or saturating the first and second shifted data elements in accordance with a specified rounding mode and the saturation indicator, respectively, to generate the first and second result data elements; and store the first result value and the second result value in a first data element location and a second data element location in a destination register.</p><p id="p-0309" num="0320">Example 18. The machine-readable medium of example 17 wherein the first packed data source operand is to further provide a third source data element and a fourth source data element, the second packed data source operand or immediate is to further provide a third shift value and a fourth shift value corresponding to the third source data element and fourth source data element, and the packed data destination operand is to indicate a third result value and a fourth result value corresponding to the third source data element and the fourth source data element, the machine-readable medium further comprising program code to cause the machine to perform the operations of: shifting the third source data element by an amount based on the third shift value to generate a third shifted data element; shifting the fourth source data element by an amount based on the fourth shift value to generate a fourth shifted data element; updating a saturation indicator responsive to detecting a saturation condition resulting from the shifting of the third and/or fourth source data elements; rounding and/or saturating the third and fourth shifted data elements in accordance with a specified rounding mode and the saturation indicator, respectively, to generate the third and fourth result data elements; and storing the third result value and the fourth result value in a third data element location and a fourth data element location in a destination register.</p><p id="p-0310" num="0321">Example 19. The machine-readable medium of example 17 wherein shifting comprises right-shifting the first and second source data elements by the amount based on the first and second shift values, respectively.</p><p id="p-0311" num="0322">Example 20. The machine-readable medium of example 17 wherein the first and second source data elements and the first and second result values comprise signed word or signed doubleword values.</p><p id="p-0312" num="0323">Example 21. The machine-readable medium of example 20 wherein the right-shifting comprises an arithmetic right shift in which a sign value of the first and second source data elements is preserved.</p><p id="p-0313" num="0324">Example 22. The machine-readable medium of example 17 wherein shifting comprises left-shifting the first and second source data elements by the amount based on the first and second shift values, respectively.</p><p id="p-0314" num="0325">Example 23. The machine-readable medium of example 21 program code to cause the machine to perform the operations of: setting a positive saturation flag upon detecting a saturation condition associated with the left-shift, the positive saturation flag to be used during the round and/or saturate operations to generate positively saturated values for the first result value or the second result value.</p><p id="p-0315" num="0326">Example 24. The machine-readable medium of example 20 further comprising program code to cause the machine to perform the operations of: setting a positive saturation flag upon detecting a first saturation condition associated with the left-shift and a negative saturation flag associated with a second saturation condition associated with the left-shift, one of the positive and negative saturation flags to be used during the round and/or saturate operations to generate positively or negatively saturated values for the first result value or the second result value.</p><p id="p-0316" num="0327">Moreover, in the various embodiments described above, unless specifically noted otherwise, disjunctive language such as the phrase &#x201c;at least one of A, B, or C&#x201d; is intended to be understood to mean either A, B, or C, or any combination thereof (e.g., A, B, and/or C). As such, disjunctive language is not intended to, nor should it be understood to, imply that a given embodiment requires at least one of A, at least one of B, or at least one of C to each be present.</p><p id="p-0317" num="0328">The specification and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense. It will, however, be evident that various modifications and changes may be made thereunto without departing from the broader spirit and scope of the disclosure as set forth in the claims.</p><p id="p-0318" num="0329">Throughout this detailed description, for the purposes of explanation, numerous specific details were set forth in order to provide a thorough understanding of the present invention. It will be apparent, however, to one skilled in the art that the invention may be practiced without some of these specific details. In certain instances, well known structures and functions were not described in elaborate detail in order to avoid obscuring the subject matter of the present invention. Accordingly, the scope and spirit of the invention should be judged in terms of the claims which follow.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>We claim:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. An apparatus comprising:<claim-text>a decoder to decode an instruction having fields for a first packed data source operand to provide a first source data element and a second source data element, a second packed data source operand or immediate to provide a first shift value and a second shift value corresponding to the first source data element and second source data element, respectively, and a packed data destination operand to indicate a first result value and a second result value corresponding to the first source data element and second source data element, and</claim-text><claim-text>execution circuitry to execute the decoded instruction to:<claim-text>shift the first source data element by an amount based on the first shift value to generate a first shifted data element;</claim-text><claim-text>shift the second source data element by an amount based on the second shift value to generate a second shifted data element;</claim-text><claim-text>update a saturation indicator responsive to detecting a saturation condition resulting from the shift of the first and/or second source data elements;</claim-text><claim-text>round and/or saturate the first and second shifted data elements in accordance with a specified rounding mode and the saturation indicator, respectively, to generate the first and second result data elements; and</claim-text><claim-text>store the first result value and the second result value in a first data element location and a second data element location in a destination register.</claim-text></claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The apparatus of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the first packed data source operand is to further provide a third source data element and a fourth source data element, the second packed data source operand or immediate is to further provide a third shift value and a fourth shift value corresponding to the third source data element and fourth source data element, and the packed data destination operand is to indicate a third result value and a fourth result value corresponding to the third source data element and the fourth source data element, and<claim-text>the execution circuitry to execute the decoded instruction to:<claim-text>shift the third source data element by an amount based on the third shift value to generate a third shifted data element;</claim-text><claim-text>shift the fourth source data element by an amount based on the fourth shift value to generate a fourth shifted data element;</claim-text><claim-text>update a saturation indicator responsive to detecting a saturation condition resulting from the shift of the third and/or fourth source data elements;</claim-text><claim-text>round and/or saturate the third and fourth shifted data elements in accordance with a specified rounding mode and the saturation indicator, respectively, to generate the third and fourth result data elements; and</claim-text><claim-text>store the third result value and the fourth result value in a third data element location and a fourth data element location in a destination register.</claim-text></claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The apparatus of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the execution circuitry is to right-shift the first and second source data elements by the amount based on the first and second shift values, respectively.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The apparatus of <claim-ref idref="CLM-00003">claim 3</claim-ref> wherein the first and second source data elements and the first and second result values comprise signed word or signed doubleword values.</claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The apparatus of <claim-ref idref="CLM-00004">claim 4</claim-ref> wherein the right-shift comprises an arithmetic right shift in which a sign value of the first and second source data elements is preserved.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The apparatus of <claim-ref idref="CLM-00001">claim 1</claim-ref> wherein the execution circuitry is to left-shift the first and second source data elements by the amount based on the first and second shift values, respectively.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The apparatus of <claim-ref idref="CLM-00005">claim 5</claim-ref> wherein the execution circuitry is to set a positive saturation flag upon detecting a saturation condition associated with the left-shift, the positive saturation flag to be used during the round and/or saturate operations to generate positively saturated values for the first result value or the second result value.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The apparatus of <claim-ref idref="CLM-00004">claim 4</claim-ref> wherein the execution circuitry is to set a positive saturation flag upon detecting a first saturation condition associated with the left-shift and a negative saturation flag associated with a second saturation condition associated with the left-shift, one of the positive and negative saturation flags to be used during the round and/or saturate operations to generate positively or negatively saturated values for the first result value or the second result value.</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. A method comprising:<claim-text>decoding an instruction having fields for a first packed data source operand to provide a first source data element and a second source data element, a second packed data source operand or immediate to provide a first shift value and a second shift value corresponding to the first source data element and second source data element, respectively, and a packed data destination operand to indicate a first result value and a second result value corresponding to the first source data element and second source data element, and</claim-text><claim-text>executing the decoded instruction to perform the operations of:<claim-text>shifting the first source data element by an amount based on the first shift value to generate a first shifted data element;</claim-text><claim-text>shifting the second source data element by an amount based on the second shift value to generate a second shifted data element;</claim-text><claim-text>updating a saturation indicator responsive to detecting a saturation condition resulting from the shift of the first and/or second source data elements;</claim-text><claim-text>rounding and/or saturating the first and second shifted data elements in accordance with a specified rounding mode and the saturation indicator, respectively, to generate the first and second result data elements; and</claim-text><claim-text>store the first result value and the second result value in a first data element location and a second data element location in a destination register.</claim-text></claim-text></claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref> wherein the first packed data source operand is to further provide a third source data element and a fourth source data element, the second packed data source operand or immediate is to further provide a third shift value and a fourth shift value corresponding to the third source data element and fourth source data element, and the packed data destination operand is to indicate a third result value and a fourth result value corresponding to the third source data element and the fourth source data element, the method further comprising:<claim-text>shifting the third source data element by an amount based on the third shift value to generate a third shifted data element;</claim-text><claim-text>shifting the fourth source data element by an amount based on the fourth shift value to generate a fourth shifted data element;</claim-text><claim-text>updating a saturation indicator responsive to detecting a saturation condition resulting from the shifting of the third and/or fourth source data elements;</claim-text><claim-text>rounding and/or saturating the third and fourth shifted data elements in accordance with a specified rounding mode and the saturation indicator, respectively, to generate the third and fourth result data elements; and</claim-text><claim-text>storing the third result value and the fourth result value in a third data element location and a fourth data element location in a destination register.</claim-text></claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref> wherein shifting comprises right-shifting the first and second source data elements by the amount based on the first and second shift values, respectively.</claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref> wherein the first and second source data elements and the first and second result values comprise signed word or signed doubleword values.</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The method of <claim-ref idref="CLM-00012">claim 12</claim-ref> wherein the right-shifting comprises an arithmetic right shift in which a sign value of the first and second source data elements is preserved.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref> wherein shifting comprises left-shifting the first and second source data elements by the amount based on the first and second shift values, respectively.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The method of <claim-ref idref="CLM-00013">claim 13</claim-ref> further comprising:<claim-text>setting a positive saturation flag upon detecting a saturation condition associated with the left-shift, the positive saturation flag to be used during the round and/or saturate operations to generate positively saturated values for the first result value or the second result value.</claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The method of <claim-ref idref="CLM-00012">claim 12</claim-ref> further comprising:<claim-text>setting a positive saturation flag upon detecting a first saturation condition associated with the left-shift and a negative saturation flag associated with a second saturation condition associated with the left-shift, one of the positive and negative saturation flags to be used during the round and/or saturate operations to generate positively or negatively saturated values for the first result value or the second result value.</claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. A machine-readable medium having program code stored thereon which, when executed by a machine, causes the machine to perform the operations of:<claim-text>decoding an instruction having fields for a first packed data source operand to provide a first source data element and a second source data element, a second packed data source operand or immediate to provide a first shift value and a second shift value corresponding to the first source data element and second source data element, respectively, and a packed data destination operand to indicate a first result value and a second result value corresponding to the first source data element and second source data element, and</claim-text><claim-text>executing the decoded instruction to perform the operations of:<claim-text>shifting the first source data element by an amount based on the first shift value to generate a first shifted data element;</claim-text><claim-text>shifting the second source data element by an amount based on the second shift value to generate a second shifted data element;</claim-text><claim-text>updating a saturation indicator responsive to detecting a saturation condition resulting from the shift of the first and/or second source data elements;</claim-text><claim-text>rounding and/or saturating the first and second shifted data elements in accordance with a specified rounding mode and the saturation indicator, respectively, to generate the first and second result data elements; and</claim-text><claim-text>store the first result value and the second result value in a first data element location and a second data element location in a destination register.</claim-text></claim-text></claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The machine-readable medium of <claim-ref idref="CLM-00017">claim 17</claim-ref> wherein the first packed data source operand is to further provide a third source data element and a fourth source data element, the second packed data source operand or immediate is to further provide a third shift value and a fourth shift value corresponding to the third source data element and fourth source data element, and the packed data destination operand is to indicate a third result value and a fourth result value corresponding to the third source data element and the fourth source data element, the machine-readable medium further comprising program code to cause the machine to perform the operations of:<claim-text>shifting the third source data element by an amount based on the third shift value to generate a third shifted data element;</claim-text><claim-text>shifting the fourth source data element by an amount based on the fourth shift value to generate a fourth shifted data element;</claim-text><claim-text>updating a saturation indicator responsive to detecting a saturation condition resulting from the shifting of the third and/or fourth source data elements;</claim-text><claim-text>rounding and/or saturating the third and fourth shifted data elements in accordance with a specified rounding mode and the saturation indicator, respectively, to generate the third and fourth result data elements; and</claim-text><claim-text>storing the third result value and the fourth result value in a third data element location and a fourth data element location in a destination register.</claim-text></claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The machine-readable medium of <claim-ref idref="CLM-00017">claim 17</claim-ref> wherein shifting comprises right-shifting the first and second source data elements by the amount based on the first and second shift values, respectively.</claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The machine-readable medium of <claim-ref idref="CLM-00017">claim 17</claim-ref> wherein the first and second source data elements and the first and second result values comprise signed word or signed doubleword values.</claim-text></claim><claim id="CLM-00021" num="00021"><claim-text><b>21</b>. The machine-readable medium of <claim-ref idref="CLM-00020">claim 20</claim-ref> wherein the right-shifting comprises an arithmetic right shift in which a sign value of the first and second source data elements is preserved.</claim-text></claim><claim id="CLM-00022" num="00022"><claim-text><b>22</b>. The machine-readable medium of <claim-ref idref="CLM-00017">claim 17</claim-ref> wherein shifting comprises left-shifting the first and second source data elements by the amount based on the first and second shift values, respectively.</claim-text></claim><claim id="CLM-00023" num="00023"><claim-text><b>23</b>. The machine-readable medium of <claim-ref idref="CLM-00021">claim 21</claim-ref> program code to cause the machine to perform the operations of:<claim-text>setting a positive saturation flag upon detecting a saturation condition associated with the left-shift, the positive saturation flag to be used during the round and/or saturate operations to generate positively saturated values for the first result value or the second result value.</claim-text></claim-text></claim><claim id="CLM-00024" num="00024"><claim-text><b>24</b>. The machine-readable medium of <claim-ref idref="CLM-00020">claim 20</claim-ref> further comprising program code to cause the machine to perform the operations of:<claim-text>setting a positive saturation flag upon detecting a first saturation condition associated with the left-shift and a negative saturation flag associated with a second saturation condition associated with the left-shift, one of the positive and negative saturation flags to be used during the round and/or saturate operations to generate positively or negatively saturated values for the first result value or the second result value.</claim-text></claim-text></claim></claims></us-patent-application>