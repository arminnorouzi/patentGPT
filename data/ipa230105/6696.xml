<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230006697A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230006697</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17856661</doc-number><date>20220701</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>03</class><subclass>M</subclass><main-group>13</main-group><subgroup>15</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>03</class><subclass>M</subclass><main-group>13</main-group><subgroup>19</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>03</class><subclass>M</subclass><main-group>13</main-group><subgroup>1575</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>03</class><subclass>M</subclass><main-group>13</main-group><subgroup>1525</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>03</class><subclass>M</subclass><main-group>13</main-group><subgroup>19</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">METHOD FOR ENCODED DIAGNOSTICS IN A FUNCTIONAL SAFETY SYSTEM</invention-title><us-related-documents><us-provisional-application><document-id><country>US</country><doc-number>63217674</doc-number><date>20210701</date></document-id></us-provisional-application><us-provisional-application><document-id><country>US</country><doc-number>63217682</doc-number><date>20210701</date></document-id></us-provisional-application><us-provisional-application><document-id><country>US</country><doc-number>63217684</doc-number><date>20210701</date></document-id></us-provisional-application></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Fort Robotics, Inc.</orgname><address><city>Philadelphia</city><state>PA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Katrak</last-name><first-name>Kerfegar Khurshed</first-name><address><city>Philadelphia</city><state>PA</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Bivans</last-name><first-name>Nathan</first-name><address><city>Philadelphia</city><state>PA</state><country>US</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A method includes, storing a set of valid codewords including: a first valid functional codeword representing a functional state of a controller subsystem; a first valid fault codeword representing a fault state of the controller subsystem and characterized by a minimum hamming distance from the first valid functional codeword; a second valid functional codeword representing a functional state of a controller; and a second valid fault codeword representing a fault state of the controller; in response to detecting functional operation of the controller subsystem, storing the first valid functional codeword in a first memory; in response to detecting a match between contents of the first memory and the first valid functional codeword, outputting the second valid functional codeword; in response to detecting a mismatch between contents of the first memory and every codeword in the first set of valid codewords, outputting the second valid fault codeword.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="197.02mm" wi="156.63mm" file="US20230006697A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="219.46mm" wi="158.67mm" file="US20230006697A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="219.63mm" wi="158.41mm" file="US20230006697A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="215.48mm" wi="154.94mm" file="US20230006697A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="213.11mm" wi="173.06mm" file="US20230006697A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="194.99mm" wi="178.31mm" file="US20230006697A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="156.72mm" wi="176.45mm" file="US20230006697A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="232.07mm" wi="171.37mm" file="US20230006697A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading><p id="p-0002" num="0001">This Application claims the benefit of U.S. Provisional Application Nos. 63/217,674 filed on 1 Jul. 2021, 63/217,682 filed on 1 Jul. 2021, and 63/217,684 filed on 1 Jul. 2021, each of which is incorporated in its entirety by this reference.</p><p id="p-0003" num="0002">This Application is related to U.S. patent application Ser. No. 17/192,657, filed on 4 Mar. 2021, and Ser. No. 17/332,635, filed on 27 May 2021, which are incorporated in its entirety by this reference.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">TECHNICAL FIELD</heading><p id="p-0004" num="0003">This invention relates generally to the field of functional safety and more specifically to a new and useful method for encoded diagnostics in a functional safety system in the field of functional safety.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE FIGURES</heading><p id="p-0005" num="0004"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a flowchart representation of a method;</p><p id="p-0006" num="0005"><figref idref="DRAWINGS">FIGS. <b>2</b>A and <b>2</b>B</figref> are schematic representations of one variation of the method;</p><p id="p-0007" num="0006"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a schematic representation of one variation of the method;</p><p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is an illustrative table in accordance with one variation of the method;</p><p id="p-0009" num="0008"><figref idref="DRAWINGS">FIGS. <b>5</b>A, <b>5</b>B, <b>5</b>C, and <b>5</b>D</figref> are illustrative tables in accordance with one variation of the method; and</p><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is an illustrative table in accordance with one variation of the method.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0004" level="1">DESCRIPTION OF THE EMBODIMENTS</heading><p id="p-0011" num="0010">The following description of embodiments of the invention is not intended to limit the invention to these embodiments but rather to enable a person skilled in the art to make and use this invention. Variations, configurations, implementations, example implementations, and examples described herein are optional and are not exclusive to the variations, configurations, implementations, example implementations, and examples they describe. The invention described herein can include any and all permutations of these variations, configurations, implementations, example implementations, and examples.</p><heading id="h-0005" level="1">1. Methods</heading><p id="p-0012" num="0011">As shown in <figref idref="DRAWINGS">FIGS. <b>1</b>, <b>2</b>A, and <b>2</b>B</figref>, a method S<b>100</b> includes: at a first controller in a safety module coupled to a system, storing a first set of valid codewords in Block S<b>110</b> including: a first valid functional codeword representing a functional state of a first subsystem of a first set of subsystems within the first controller; a first valid fault codeword representing a fault state of the first subsystem and characterized by a first minimum hamming distance from the first valid functional codeword; a second valid functional codeword representing a functional state of the first controller; a second valid fault codeword representing a fault state of the first controller and characterized by a second minimum hamming distance from the second valid functional codeword; a third valid functional codeword representing a functional state of a first input coupled to the system; a third valid fault codeword representing a fault state of the first input and characterized by a third minimum hamming distance from the third valid functional codeword; a fourth valid functional codeword representing a functional state of the system; and a fourth valid fault codeword representing a fault state of the system and characterized by a fourth minimum hamming distance from the fourth valid functional codeword.</p><p id="p-0013" num="0012">The method further includes during a first time period, at the first controller: in response to detecting functional operation of the first subsystem, storing the first valid functional codeword in a first memory in Block S<b>120</b>, and in response to detecting functional operation of the first input, storing the third valid functional codeword in a second memory in Block S<b>122</b>.</p><p id="p-0014" num="0013">The method further includes, during a second time period following the first time period, at the first controller, in response to detecting a match between contents of the first memory and the first valid functional codeword, and in response to detecting functional operation of the first input, outputting a first safety message including the second valid functional codeword and the fourth valid functional codeword in Block S<b>130</b>.</p><p id="p-0015" num="0014">The method further includes, during a third time period following the second time period, at the first controller: in response to detecting functional operation of the first subsystem, storing the first valid functional codeword in the first memory in Block S<b>120</b>, and in response to detecting functional operation of the first input, storing the third valid functional codeword in the second memory in Block S<b>122</b>.</p><p id="p-0016" num="0015">The method further includes, during a fourth time period following the third time period, at the first controller, in response to detecting a mismatch between contents of the first memory and every codeword in the first set of valid codewords, outputting a second safety message including the second valid fault codeword and the fourth valid fault codeword in Block S<b>130</b>.</p><heading id="h-0006" level="1">1.1 Controller Infrastructure Diagnostics and Safety Module Timeout</heading><p id="p-0017" num="0016">As shown in <figref idref="DRAWINGS">FIGS. <b>1</b>, <b>2</b>A, and <b>2</b>B</figref>, one variation of the method S<b>100</b> includes, at a first controller in a safety module coupled to a system, storing a first set of valid codewords in Block S<b>110</b> including: a first valid functional codeword representing a functional state of a first subsystem of a first set of subsystems within the first controller; a first valid fault codeword representing a fault state of the first subsystem and characterized by a first minimum hamming distance from the first valid functional codeword; a second valid functional codeword representing a functional state of the first controller; a second valid fault codeword representing a fault state of the first controller and characterized by a second minimum hamming distance from the second valid functional codeword; a third valid functional codeword representing a functional state of a first input coupled to the system; a third valid fault codeword representing a fault state of the first input and characterized by a third minimum hamming distance from the third valid functional codeword; a fourth valid functional codeword representing a functional state of a second controller within the safety module; a fourth valid fault codeword representing a fault state of the second controller and characterized by a sixth minimum hamming distance from the fourth valid functional codeword; a fifth valid functional codeword representing a functional timeout state of the second controller; a fifth valid fault codeword representing a fault timeout state of the second controller and characterized by a fifth minimum hamming distance from the fourth valid functional codeword; a sixth valid functional codeword representing a functional state of the system; and a sixth valid fault codeword representing a fault state of the system and characterized by a sixth minimum hamming distance from the sixth valid functional codeword.</p><p id="p-0018" num="0017">This variation of the method S<b>100</b> further includes, during a first time period, at the first controller: in response to detecting functional operation of the first subsystem, storing the first valid functional codeword in a first memory in Block S<b>120</b>; in response to detecting functional operation of the first input, storing the third valid functional codeword in a second memory in Block S<b>122</b>; querying an input register coupled to the second controller in Block S<b>140</b>; detecting, in the input register, a first safety message including the fourth valid functional codeword from the second controller in block S<b>142</b>; and, in response to detecting the first safety message in the input register within a first time quantum, storing the fifth valid functional codeword in a third memory in Block S<b>124</b>.</p><p id="p-0019" num="0018">This variation of the method S<b>100</b> further includes, during a second time period after the first time period, at the first controller, in response to detecting a match between contents of the first memory and the first valid functional codeword, in response to detecting a match between contents of the third memory and the fifth valid functional codeword, and in response to detecting functional operation of the first input, outputting a second safety message including the second valid functional codeword and the sixth valid functional codeword in Block S<b>130</b>.</p><p id="p-0020" num="0019">This variation of the method S<b>100</b> further includes, during a third time period after the second time period, at the first controller: in response to detecting functional operation of the first subsystem, storing the first valid functional codeword in the first memory in Block S<b>120</b>; in response to detecting functional operation of the first input, storing the third valid functional codeword in the second memory in Block S<b>122</b>; querying the input register in Block S<b>140</b>; and, in response to detecting non-receipt of the third safety message in the input register within a second time quantum, storing the fifth valid fault codeword in a third memory in Block S<b>124</b>.</p><p id="p-0021" num="0020">This variation of the method S<b>100</b> further includes, during a fourth time period after the third time period, at the first controller, in response to detecting a match between contents of the first memory and the first valid functional codeword, and in response to detecting a match between contents of the third memory and the fifth valid fault codeword, outputting a fourth safety message including the second valid functional codeword and the sixth valid fault codeword in Block S<b>130</b>.</p><heading id="h-0007" level="1">1.2 Controller Infrastructure Diagnostics</heading><p id="p-0022" num="0021">As shown in <figref idref="DRAWINGS">FIGS. <b>1</b>, <b>2</b>A, and <b>2</b>B</figref>, another variation of the method S<b>100</b> includes, at a first controller in a safety module coupled to a system, storing a first set of valid codewords in Block S<b>10</b> including: a first valid functional codeword representing a functional state of a first subsystem of a first set of subsystems within the first controller; a first valid fault codeword representing a fault state of the first subsystem and characterized by a first minimum hamming distance from the first valid functional codeword; a second valid functional codeword representing a functional state of the first controller; and a second valid fault codeword representing a fault state of the first controller and characterized by a second minimum hamming distance from the second valid functional codeword.</p><p id="p-0023" num="0022">This variation of the method S<b>100</b> further includes, during a first time period, at the first controller, in response to detecting functional operation of the first subsystem, storing the first valid functional codeword in a first memory in Block S<b>120</b>.</p><p id="p-0024" num="0023">This variation of the method S<b>100</b> further includes, during a second time period after the first time period, at the first controller, in response to detecting a match between contents of the first memory and the first valid functional codeword, outputting a first safety message including the second valid functional codeword in Block S<b>130</b>.</p><p id="p-0025" num="0024">This variation of the method S<b>100</b> further includes, during a third time period after the second time period, at the first controller, in response to detecting functional operation of the first subsystem, storing the first valid functional codeword in the first memory in Block S<b>120</b>.</p><p id="p-0026" num="0025">This variation of the method S<b>100</b> further includes, during a fourth time period after the third time period, at the first controller, in response to detecting a mismatch between contents of the first memory and every codeword in the first set of valid codewords, outputting a second safety message including the second valid fault codeword in Block S<b>130</b>.</p><heading id="h-0008" level="1">1.3 Safety Module Timeout</heading><p id="p-0027" num="0026">As shown in <figref idref="DRAWINGS">FIGS. <b>1</b>, <b>2</b>A, and <b>2</b>B</figref>, another variation of the method S<b>100</b> includes, at a first controller in a first safety module coupled to a system, storing a first set of valid codewords in Block S<b>110</b> including: a first valid functional codeword representing a functional timeout state of a second controller within the first safety module; a first valid fault codeword representing a fault timeout state of the second controller and characterized by a first minimum hamming distance from the first valid functional codeword; a second valid functional codeword representing a functional state of the second controller; a second valid fault codeword representing a fault state of the second controller and characterized by a second minimum hamming distance from the second valid functional codeword; a third valid functional codeword representing a functional state of a first input coupled to the system; a third valid fault codeword representing a fault state of the first input and characterized by a third minimum hamming distance from the third valid functional codeword; a fourth valid functional codeword representing a functional state of the system; and a fourth valid fault codeword representing a fault state of the system and characterized by a fourth minimum hamming distance from the fourth valid functional codeword.</p><p id="p-0028" num="0027">This variation of the method S<b>100</b> further includes, during a first time period, at the first controller: querying a first input register coupled to the second controller in Block S<b>140</b>; detecting, in the first input register, a first safety message including the second valid functional codeword from the second controller in Block S<b>142</b>; in response to detecting the first safety message in the first input register within a first time quantum, storing the first valid functional codeword in a first memory in Block S<b>124</b>; and in response to detecting functional operation of the first input, storing the third valid functional codeword in a second memory in Block S<b>122</b>.</p><p id="p-0029" num="0028">This variation of the method S<b>100</b> further includes, during a second time period following the first time period, at the first controller, in response to detecting a match between contents of the first memory and the first valid functional codeword, and in response to detecting functional operation of the first input, outputting a second safety message including the fourth valid functional codeword in Block S<b>130</b>.</p><p id="p-0030" num="0029">This variation of the method S<b>100</b> further includes, during a third time period following the second time period, at the first controller: querying the first input register in Block S<b>140</b>; detecting, in the first input register, a third safety message including the second valid functional codeword from the second controller in Block S<b>142</b>; in response to detecting the third safety message in the first input register within a second time quantum, storing the first valid functional codeword in the first memory in Block S<b>124</b>; and in response to detecting functional operation of the first input, storing the third valid functional codeword in the second memory in Block S<b>122</b>.</p><p id="p-0031" num="0030">This variation of the method S<b>100</b> further includes, during a fourth time period following the third time period, at the first controller, in response to detecting a mismatch between contents of the first memory and every codeword in the first set of valid codewords, outputting a fourth safety message including the fourth valid fault codeword in Block S<b>130</b>.</p><heading id="h-0009" level="1">1.4 Safety Controller Timeout with External Input</heading><p id="p-0032" num="0031">As shown in <figref idref="DRAWINGS">FIGS. <b>1</b>, <b>2</b>A, and <b>2</b>B</figref>, another variation of the method S<b>100</b> includes, at a first controller in a first safety module coupled to a system, storing a first set of valid codewords in Block S<b>110</b> including: a first valid functional codeword representing a functional timeout state of a second controller within a second safety module in the system; a first valid fault codeword representing a fault timeout state of the second controller and characterized by a first minimum hamming distance from the first valid functional codeword; a second valid functional codeword representing a functional state of the second controller; a second valid fault codeword representing a fault state of the second controller and characterized by a second minimum hamming distance from the second valid functional codeword; a third valid functional codeword representing a functional state of a first input coupled to the system; a third valid fault codeword representing a fault state of the first input and characterized by a third minimum hamming distance from the third valid functional codeword; a fourth valid functional codeword representing a functional state of the system; and a fourth valid fault codeword representing a fault state of the system and characterized by a fourth minimum hamming distance from the fourth valid functional codeword.</p><p id="p-0033" num="0032">This variation of the method S<b>100</b> further includes, during a first time period, at the first controller: in response to detecting a first safety message including the second valid functional codeword from the second controller within a first time quantum, storing the first valid functional codeword in a first memory in Block S<b>126</b>; and in response to detecting functional operation of the first input, storing the third valid functional codeword in a second memory in Block S<b>122</b>.</p><p id="p-0034" num="0033">This variation of the method S<b>100</b> further includes, during a second time period following the first time period, at the first controller, in response to detecting the second valid functional codeword in the first safety message, in response to detecting a match between contents of the first memory and the first valid functional codeword, and in response to detecting functional operation of the first input, outputting a second safety message including the fourth valid functional codeword in Block S<b>130</b>.</p><p id="p-0035" num="0034">This variation of the method S<b>100</b> further includes, during a third time period following the second time period, at the first controller: in response to detecting receipt of a third safety message including the second valid functional codeword from the second controller within a second time quantum, storing the first valid functional codeword in the first memory in Block S<b>126</b>; and in response to detecting functional operation of the first input, storing the third valid functional codeword in the second memory in Block S<b>122</b>.</p><p id="p-0036" num="0035">This variation of the method S<b>100</b> further includes, during a fourth time period following the third time period, at the first controller, in response to detecting a mismatch between contents of the first memory and every codeword in the first set of valid codewords, outputting a fourth safety message including the fourth valid fault codeword in Block S<b>130</b>.</p><heading id="h-0010" level="1">1.5 Safety Controller Timeout</heading><p id="p-0037" num="0036">As shown in <figref idref="DRAWINGS">FIGS. <b>1</b>, <b>2</b>A, and <b>2</b>B</figref>, another variation of the method S<b>100</b> includes, at a first controller in a first safety module in a system, storing a set of valid codewords in Block S<b>110</b> including: a first valid functional codeword representing a functional timeout state of a second controller within a second safety module in the system; a first valid fault codeword representing a fault timeout state of the second controller and characterized by a first minimum hamming distance from the first valid functional codeword; a second valid functional codeword representing a functional state of the system; and a second valid fault codeword representing a fault state of the system and characterized by a second minimum hamming distance from the second valid functional codeword.</p><p id="p-0038" num="0037">This variation of the method S<b>100</b> further includes, during a first time period, at the first controller, in response to detecting receipt of a first safety message from the second controller within a first time quantum, storing the first valid functional codeword in a memory in Block S<b>126</b>.</p><p id="p-0039" num="0038">This variation of the method S<b>100</b> further includes, during a second time period following the first time period, at the first controller, in response to detecting a match between contents of the memory and the first valid functional codeword, outputting a second safety message including the second valid functional codeword in Block S<b>130</b>.</p><p id="p-0040" num="0039">This variation of the method S<b>100</b> further includes, during a third time period following the second time period, at the first controller, in response to detecting receipt of a third safety message from the second controller within a second time quantum, storing the first valid functional codeword in the memory in Block S<b>126</b>.</p><p id="p-0041" num="0040">This variation of the method S<b>100</b> further includes, during a fourth time period following the third time period, at the first controller, in response to detecting a mismatch between contents of the memory and every codeword in the set of valid codewords, outputting a fourth safety message including the second valid fault codeword in Block S<b>130</b>.</p><heading id="h-0011" level="1">2. Applications</heading><p id="p-0042" num="0041">Generally, the method S<b>100</b> can be executed by a system to: store a set of valid codewords representing state information (e.g., functional, fault) for various components of a safety module (e.g., core infrastructure subsystems, input(s), data communication) and characterized by minimum hamming distances from other valid codewords; store codewords in memory based on detected states of core infrastructure subsystems, input(s), and/or data communication during a monitoring period; and output a safety message based on: (i) whether codewords stored in memory during the monitoring period match valid codewords, and (ii) the detected states during an evaluation period.</p><p id="p-0043" num="0042">In particular, the method S<b>100</b> can be executed by a safety module to encode state information as unique codewords exhibiting a certain minimum hamming distance from other codewords in the encoding scheme to mitigate instances of bit flips or software overwrites of state information stored in memory. For example, instances of unintentional bit flips or software overwrites may occur over time and through unpredictable modes, such as by bugs, lack of memory, malicious attacks, errant algorithm design, faulty memory, bit line errors, or alpha particle irradiation of memory, etc. The safety module can therefore execute Blocks of the method to detect a mismatch between encoded state information (e.g., codewords) stored in memory and the encoding scheme (e.g., valid codewords), which indicates that the encoded state information has been overwritten, and to selectively execute fault, alerting, and/or fault recovery processes accordingly.</p><p id="p-0044" num="0043">In one example, a safety module executes Blocks of the method S<b>100</b> to: store valid codewords representing functional states of individual subsystems of controllers within the safety module, a functional state of an external input monitored by the safety module, and/or a functional state for data communication and characterized by minimum hamming distances from other valid codewords. The safety module also executes Blocks of the method S<b>100</b> to: detect functional states of the individual subsystems, the external input, and/or the data communication; and store corresponding codewords in memory. The safety module then executes Blocks of the method S<b>100</b> to: detect a match between stored codewords and valid codewords; and output a safety message indicating a functional state in response to detecting this match. Therefore, when implemented in an environment prone to interference, the safety module can output safety messages exhibiting a low error rate and can meet functional safety standards.</p><p id="p-0045" num="0044">Alternatively, in this example, if the safety module detects a mismatch between stored codewords and valid codewords, the safety module can output a safety message indicating a fault state. Therefore, because the safety module validates the state of each subsystem based on alignment of stored codewords and valid codewords that encode functional states of these subsystems, the safety module can: detect a fault based on a difference between stored codewords and valid codewords; transmit a fault message in place of a functional message in response to detecting a fault, thereby triggering the system to enter a safe mode with fault condition when function of the safety module is thus unverifiable.</p><p id="p-0046" num="0045">In another example, a safety module executes Blocks of the method S<b>100</b> to store valid codewords representing states (e.g., functional state, fault state) of individual subsystems within a controller within the safety module, a state(s) of an external input(s) monitored by the safety module, and/or a state(s) for data communication and characterized by minimum hamming distances from other valid codewords. The safety module also executes Blocks of the method S<b>100</b> to: detect states of the individual subsystems, the external input, and/or the data communication; and store codewords corresponding to the detected states in memory. The safety module then executes Blocks of the method S<b>100</b> to: output a safety message including a codeword representing an overall state (e.g., functional state, fault state) of the controller(s), input(s), and/or data communication based on: (i) whether codewords stored in memory during the monitoring period match valid codewords; and (ii) the detected states. Therefore, when the safety module is implemented in a system requiring continuous communication with a large number of nodes (e.g., inputs, machines, etc.), the safety module can: manage message traffic from the subgroup of nodes; and transmit a message indicating an overall state of the subgroup, thereby streamlining communication and maintaining functional safety standards in large networks.</p><p id="p-0047" num="0046">The method S<b>100</b> as described herein is executed by a safety module containing a pair of controllers (e.g., microcontrollers manufactured according to 90-nanometer chip manufacturing technologies) and an application processor to implement 8-bit and 16-bit codewords. However, a safety module containing additional or fewer controllers, connected to an external logic, and/or manufactured via any other fabrication technology can similarly execute Blocks of the method S<b>100</b> to: store a set of valid codewords representing state information (e.g., functional, fault) for various components of a safety module (e.g., core infrastructure subsystems, input(s), data communication) and characterized by minimum hamming distances from other codewords; during a monitoring period, store codewords in memory based on detected states of core infrastructure subsystems, input(s), and/or data communication; and, during an evaluation period, output a safety message based on: (i) whether codewords stored in memory during the monitoring period match valid codewords, and (ii) the detected states.</p><p id="p-0048" num="0047">Furthermore, the method S<b>100</b> as described herein is executed by a safety module containing a pair of controllers and an application processor to implement 8-bit and 16-bit codewords separated by predefined minimum hamming distances (e.g., a minimum hamming distance of &#x201c;8&#x201d; or &#x201c;4&#x201d;). However, a safety module implementing longer or shorter codewords separated by larger or smaller minimum hamming distances from each other can similarly execute Blocks of the method S<b>100</b> to: store a set of valid codewords representing state information (e.g., functional, fault) for various components of a safety module (e.g., core infrastructure subsystems, input(s), data communication) and characterized by minimum hamming distances from other codewords; during a monitoring period, store codewords in memory based on detected states of core infrastructure subsystems, input(s), and/or data communication; and, during an evaluation period, output a safety message based on: (i) whether codewords stored in memory during the monitoring period match valid codewords, and (ii) the detected states.</p><heading id="h-0012" level="1">3. System</heading><p id="p-0049" num="0048">Generally, a safety module includes: a first controller, a second controller, an application processor, and a communication bus. The communication bus supports two-way communication between the first controller and the second controller, two-way communication between the first controller and the application controller, and two-way communication between the second controller and the application controller.</p><p id="p-0050" num="0049">In particular, the first controller executes Blocks of the method S<b>100</b> to: store a first set of valid codewords; store codewords in memory corresponding to detected states; and output safety messages including codewords representing state (e.g., functional state, fault state) based on the detected states in response to detecting a match between the codewords stored in memory and the set of valid codewords. The first controller also executes Blocks of the method S<b>100</b> to: output safety messages including codewords representing fault state in response to detecting a mismatch between the codewords stored in memory and the set of valid codewords.</p><p id="p-0051" num="0050">Similarly, the second controller executes Blocks of the method S<b>100</b> to: store a second set of valid codewords; store codewords in memory corresponding to detected states; and output safety messages including codewords representing state (e.g., functional state, fault state) based on the detected states in response to detecting a match between the codewords stored in memory and the set of valid codewords. The second controller also executes Blocks of the method S<b>100</b> to: output safety messages including codewords representing fault state in response to detecting a mismatch between the codewords stored in memory and the set of valid codewords</p><p id="p-0052" num="0051">Furthermore, the application processor executes Blocks of the method S<b>100</b> to: transmit/receive safety messages to/from the first controller; transmit/receive safety messages to/from the second controller; and transmit/receive safety messages to/from other safety modules.</p><heading id="h-0013" level="1">3.1 First Controller</heading><p id="p-0053" num="0052">In one implementation, the first controller includes: an arithmetic logic unit (hereinafter &#x201c;ALU&#x201d;); volatile memory (e.g., random access memory or &#x201c;RAM&#x201d;); and non-volatile memory (e.g., flash memory). The ALU executes arithmetic and logic operations based on computer instructions executed by the first controller. The RAM temporarily stores data retrieved from storage for performing calculations. The flash memory stores data and instructions that are programmed into the first controller. The first controller can further include an input/output interface, an internal bus, and an internal oscillator. The first controller may include fewer or additional components.</p><p id="p-0054" num="0053">In one variation, the first controller further includes a program flow monitor safety mechanism, a stack underflow safety monitor, and a stack overflow safety monitor.</p><p id="p-0055" num="0054">Generally, the program flow monitor safety mechanism detects errors in ordering or other flows of a software instruction being executed by the first controller. In one implementation, the program flow monitor safety mechanism exhibits fault operation when such errors are detected.</p><p id="p-0056" num="0055">Generally, the stack overflow safety mechanism detects a software program being executed by the first controller attempting to use more space than is available on a call stack. In one implementation, the stack overflow safety mechanism exhibits fault operation when stack overflow is detected.</p><p id="p-0057" num="0056">Generally, the stack underflow safety mechanism detects a software program being executed by the controller attempting to remove an item from an empty stack in memory. In one implementation, the stack underflow safety mechanism exhibits fault operation when stack underflow is detected.</p><p id="p-0058" num="0057">In one implementation, the first controller includes an input configured to connect to a safety sensor (e.g., an emergency stop button, a line break sensor) external to the safety module.</p><p id="p-0059" num="0058">In one implementation, the first controller includes an input coupled to an output of the second controller. For example, the first controller can include an input register coupled to an output of the second controller.</p><heading id="h-0014" level="1">3.1.1 First Controller: Logic</heading><p id="p-0060" num="0059">Generally, the first controller includes logic (e.g., hardware and/or firmware modules, instructions stored in the flash memory) configured to detect states of: a set of subsystems within the first controller; the input configured to connect to a safety sensor; and the input coupled to the second controller. For example, the set of subsystems within the first controller can include the ALU, the RAM, the flash memory, the program flow monitor safety mechanism, the stack overflow safety mechanism, and/or the stack underflow safety mechanism.</p><p id="p-0061" num="0060">In one implementation, the first controller can include logic by which the first controller individually monitors each subsystem in the set of subsystems and detects operation (e.g., functional operation, fault operation) of each subsystem accordingly, as described below. In one example, the first controller can monitor the ALU and detect functional operation of the ALU based on a diagnostic test of the ALU. In another example, the first controller can monitor the stack overflow safety mechanism and detect fault operation of the stack overflow safety mechanism in response to/based on an instance of stack overflow.</p><p id="p-0062" num="0061">In another implementation, the first controller detects functional operation in an absence of errors detected for a given subsystem, and the first controller detects fault operation when one or more errors are detected for the given subsystem. For example, an error may be defined based on nature of the given subsystem, a safety standard associated with the given subsystem, and/or any factor applicable to the given subsystem.</p><p id="p-0063" num="0062">In another implementation, the first controller detects a state of a subsystem corresponding to the detected operation of the subsystem. In one example, the first controller detects a functional state of the ALU in response to detecting functional operation of the ALU. In another example, the first controller detects a fault state of the stack overflow safety mechanism in response to detecting fault operation of the stack overflow safety mechanism.</p><p id="p-0064" num="0063">In another implementation, the first controller further includes logic that enables the first controller to detect a state of an input configured to connect to a safety sensor as described below. For example, the first controller can detect functional operation of the input (e.g., an input circuit coupled to an emergency stop button is operating within correct voltage/current ranges according to a configured mode of operation, etc.), and then the first controller can detect a functional state of the input in response to detecting functional operation of the input. Alternatively, the first controller can detect fault operation of the input (e.g., the input circuit coupled to the emergency stop button is operating outside of the correct voltage/current ranges according to the configured mode of operation, an internal hardware fault, etc.), and then the first controller can detect a fault state of the input in response to detecting fault operation of the input.</p><p id="p-0065" num="0064">In another implementation, the first controller further includes logic that enables the first controller to detect states of the second controller as described below. In one example, the first controller can detect a functional timeout state of the second controller in response to detecting receipt of a safety message from the second controller within a predefined time quantum. Alternatively, the first controller can detect a fault timeout state of the second controller in response to detecting non-receipt of a safety message from the second controller within the predefined time quantum. In another example, the first controller can detect a functional state or a fault state of the second controller based on contents of the safety message from the second controller.</p><p id="p-0066" num="0065">In one variation, the first controller includes: a communication infrastructure safety mechanism and a communicated content safety mechanism to detect communication faults with the second controller and/or the application processor.</p><p id="p-0067" num="0066">Similarly, in another implementation, the first controller further includes logic that enables the first controller to detect states of other controllers within other safety modules as described below.</p><p id="p-0068" num="0067">In another implementation, the first controller further includes logic that enables the first controller to encode the detected states of the second controller as described below. For example, the first controller can store codewords corresponding to the detected states in memory (e.g., flash memory, external memory).</p><p id="p-0069" num="0068">In another implementation, the first controller further includes logic that enables the first controller to detect whether memory contents match valid codewords as described below. For example, the first controller can detect a match between memory contents and a valid codeword, indicating the codeword stored in memory has not been overwritten. Alternatively, the first controller can detect a mismatch between memory contents and every valid codeword, indicating the codeword stored in memory has been overwritten.</p><p id="p-0070" num="0069">In another implementation, the first controller further includes logic that enables the first controller to output safety messages as described below. For example, the first controller can assemble and output safety messages to the second controller and/or the application processor via the communication bus.</p><heading id="h-0015" level="1">3.2 Second Controller</heading><p id="p-0071" num="0070">In one implementation, the second controller: includes analogous (e.g., similar, identical) components arranged in an analogous format as the first controller; and is separate and discrete from the first controller.</p><p id="p-0072" num="0071">In one example, the first controller and the second controller each include a redundant input configured to be connected to the same safety sensor (e.g., two redundant outputs of an emergency stop button, outputs of two redundant line break sensors). The first controller and the second controller independently process each redundant input and produce discrete safety messages.</p><heading id="h-0016" level="1">3.3 Application Processor</heading><p id="p-0073" num="0072">In one implementation, the application processor is configured to: receive safety messages from the first controller and the second controller; concatenate information in the safety messages from the first controller and the second controller into a new safety message; and output the new safety message (e.g., over a network to another safety module).</p><p id="p-0074" num="0073">In another implementation, the application processor is further configured to: receive safety messages (e.g., over the network from another safety module); separate the information within the received safety messages into a first safety message for the first controller, and a second safety message for the second controller; output the first safety message to the first controller; and output the second safety message to the second controller.</p><p id="p-0075" num="0074">In another implementation, communication through the application processor by the first controller and the second controller are implemented in a black channel setup where the application processor concatenates/separates information passed between the underlying controllers without otherwise analyzing or manipulating that data.</p><p id="p-0076" num="0075">In one variation, the application processor is configured to: analyze a first safety message from the first controller and a second safety message from the second controller; and output a new safety message based on a result of the analysis. In one example, the application processor can output a safety message indicating a functional state in response to receiving: a first safety message indicating a functional state from the first controller; and a second safety message indicating a functional state from the second controller. In another example, the application processor can output a safety message indicating a fault state in response to receiving: a first safety message indicating a functional state from the first controller; and a second safety message indicating a fault state from the second controller.</p><heading id="h-0017" level="1">4. Example 1: Emergency Stop Button</heading><p id="p-0077" num="0076">Generally, a safety module transmits safety messages and receives safety messages. One or more safety modules can be implemented within a given machine. A safety message can indicate a (e.g., functional, safe, safe due to fault) of a machine (or module or subcomponent thereof), and a safety message can command a machine to enter a safe state (e.g., stop performing a given task, disengage a fuel supply, shut down, reboot) to prevent unsafe activity until the safe state can be reconciled.</p><p id="p-0078" num="0077">In one example, as shown in <figref idref="DRAWINGS">FIGS. <b>2</b>A and <b>2</b>B</figref>, a system includes: a safety module; and a safety controller.</p><p id="p-0079" num="0078">As described above, in one implementation, the safety module includes: a first controller; a second controller; an application processor; and a communication bus. The first controller includes a first input coupled to an emergency stop button within the system, and the second controller includes a second input coupled to the emergency stop button.</p><p id="p-0080" num="0079">Generally, the first controller and the second controller independently process their respective input coupled to the emergency stop button and output respective safety messages to the application processor. In particular, the first controller can output a first safety message based on a detected state of the first controller (e.g., based on detected states of the set of subsystems within the first controller), a detected state of the first input, a detected state of the second controller, and validity of stored codewords representing the detected states (e.g., detecting matches between stored codewords and valid codewords). For example, the first controller can output the first safety message to the second controller and/or the application processor via the communication bus.</p><p id="p-0081" num="0080">Similarly, the second controller can output a second safety message based on a detected state of the second controller (e.g., based on detected states of the set of subsystems within the second controller), a detected state of the second input, a detected state of the first controller, and validity of stored codewords representing the detected states (e.g., detecting matches between stored codewords and valid codewords). For example, the second controller can output the second safety message to the first controller and/or the application processor via the communication bus.</p><p id="p-0082" num="0081">In one implementation, the application processor within the safety module receives the first safety message and the second safety message, concatenates the first safety message and the second safety message, and outputs the resultant safety message to the application processor within the safety controller. For example, the application processor can transmit the resultant safety message over a transmission medium (e.g., any network, the Internet, WiFi, Bluetooth, LTE).</p><p id="p-0083" num="0082">In one implementation, the application processor within the safety controller receives the safety message from the application processor within the safety module and separates the received safety message into: the first safety message for the first controller within the safety controller; and the second safety message for the second controller within the safety controller. The application processor within the safety controller then: outputs the first safety message to the first controller within the safety controller via the communication bus; and outputs the second safety message to the second controller within the safety controller via the communication bus. Therefore, the first controller within the safety controller can process the first safety message from the first controller within the safety module, and the second controller within the safety controller can process the second safety message from the second controller within the safety module.</p><p id="p-0084" num="0083">In one example, the first controller and the second controller within the safety module generate and output safety messages based on the first input and the second input indicating a fault state (e.g., an input circuit coupled to the emergency stop button is operating outside of the correct voltage/current ranges according to the configured mode of operation, an internal hardware fault, etc.). The safety messages include codewords representing fault states of the respective inputs. The safety messages are passed to the safety controller and processed by the first controller and the second controller within the safety controller. The first controller and the second controller within the safety controller can agree on a fault state of the first input and the second input (e.g., the emergency stop button coupled to the safety module). The first controller and the second controller within the safety controller can then output safety messages commanding a machine to enter a safe state. Further description of implementing two controllers to meet this threshold is further described in U.S. patent application Ser. No. 17/192,657, filed on 4 Mar. 2021, which is incorporated in its entirety by this reference.</p><heading id="h-0018" level="1">5. Example 2: Zone Controller</heading><p id="p-0085" num="0084">In one variation to the above example, as shown in <figref idref="DRAWINGS">FIGS. <b>2</b>A and <b>2</b>B</figref>, the system includes: safety modules; safety controllers; and a zone controller.</p><p id="p-0086" num="0085">Generally, a safety controller is a safety module configured to: receive safety messages from a group of safety modules; and transmit safety messages to the group of safety modules.</p><p id="p-0087" num="0086">In one implementation, the safety controller <b>110</b> is configured to: receive safety messages from the safety module <b>120</b> and the safety module <b>122</b>; and transmit safety messages to the safety module <b>120</b> and the safety module <b>122</b>. For example, the safety controller can, upon occurrence of a condition (e.g., a given machine has entered a safe state; a given command is received that affects multiple machines), command predefined segments of other machines to change safety state (e.g., enter a safe state).</p><p id="p-0088" num="0087">Similarly, the safety controller <b>112</b> approximates the safety controller <b>110</b>. For example, the safety controller <b>112</b> is configured to: receive safety messages from the safety module <b>124</b> and the safety module <b>126</b>; and transmit safety messages to the safety module <b>124</b> and the safety module <b>126</b>.</p><p id="p-0089" num="0088">In one variation of this example, the number of safety modules in a group of safety modules can be greater or fewer. Additionally or alternatively, safety modules can be dynamically assigned to different groups of safety modules.</p><p id="p-0090" num="0089">Generally, a zone controller is a safety module configured to: receive safety messages from a group of safety controllers and/or safety modules; and transmit safety messages to a group of safety controllers and/or safety modules. For example, a zone controller can transmit safety messages across a &#x201c;zone,&#x201d; which may be a logical sub-grouping of machines in a facility.</p><p id="p-0091" num="0090">In one implementation, the zone controller <b>130</b> is configured to: receive safety messages from the safety controller <b>110</b> and the safety controller <b>112</b>; and transmit safety messages to the safety controller <b>110</b> and the safety controller <b>112</b>. Additionally or alternatively, the zone controller <b>130</b> is further configured to: receive safety messages from the safety modules <b>120</b>, <b>122</b>, <b>124</b>, <b>126</b>; and transmit safety messages to the safety modules <b>120</b>, <b>122</b>, <b>124</b>, <b>126</b>.</p><p id="p-0092" num="0091">In one variation to this example, zone groupings may cascade to any number of tiers where zone controllers may interact with yet another controller that may be configured to transmit safety messages to all machines of an entire facility (e.g., an emergency facility-wide shutdown). In this variation, mapping tables or other logical associations can be used, where conditions, types of commands or states, or other triggers may be mapped to downstream machines and controllers that should receive commands when a condition is met.</p><p id="p-0093" num="0092">In yet another variation to this example, each layer in the system can implement a timeout safety system. For example, the communication between a safety module <b>120</b> and a safety controller no is an example layer of communication. Furthermore, the communication a safety controller <b>110</b> and a zone controller <b>130</b> is another layer of communication. In this two-layer example, a safety controller <b>110</b> monitors the timeout states of the safety modules <b>120</b>, <b>122</b>, and the zone controller <b>130</b> monitors the timeout states of the safety controllers <b>110</b>, <b>112</b>. In one variation, there can be additional layers beyond either end of the system shown in <figref idref="DRAWINGS">FIGS. <b>2</b>A and <b>2</b>B</figref>.</p><p id="p-0094" num="0093">In this example, a receiving module (e.g., safety controller, zone controller) stores the timeout states of a plurality of transmitting modules (e.g., safety module, safety controller) and uses the timeout states to determine safety remedy when one or more transmitting modules shows faulty timeout states. For example, if only a single transmitting module in a group shows fault, the receiving module can flag the faulty transmitting module for inspection. In other cases, if more than a threshold number of transmitting modules become faulty, the receiving module can take a more aggressive measure, such as commanding one or more receiving modules into a safe mode or even shutting down a part or the entirety of the system. The timeout states of transmitting modules are stored in a memory associated with the receiving module for further analysis to determine a safety action and remedy that a system may take when one or more modules become faulty.</p><p id="p-0095" num="0094">In yet another variation to this example, the zone controller <b>130</b> receives a safety message including one or more valid fault codewords (e.g., from the safety controller <b>110</b>), decodes the safety message, interprets the one or more valid fault codewords as a system fault, and provides notification for a recovery mode.</p><heading id="h-0019" level="1">6. Safety Messages</heading><p id="p-0096" num="0095">In one example, the application processor transmits a concatenated safety message, as shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref>.</p><p id="p-0097" num="0096">Generally, the application processor concatenates information from the first controller and the second controller. In one implementation, &#x201c;AP Rx M1&#x201d; refers to information the application processor received from the first controller, and &#x201c;AP Rx M2&#x201d; refers to information the application processor received from the second controller. In one variation, the application processor can concatenate information from additional or fewer controllers into the safety message.</p><p id="p-0098" num="0097">In one implementation, the first two bytes of the safety message (e.g., &#x201c;ID0,&#x201d; &#x201c;ID1;&#x201d; &#x201c;ID0&#x2032;,&#x201d; &#x201c;ID1&#x2032;&#x201d;) include bytes that, together, uniquely identify the controller. The third byte of the safety message (e.g., &#x201c;M0,&#x201d; &#x201c;M1&#x201d;) refers to a state of the controller (e.g., functional state, fault state). In one implementation, the first controller generates the third byte (&#x201c;M0&#x201d;) after detecting a state of the first controller, as described below. Similarly, the second controller generates the third byte (&#x201c;M1&#x201d;) after detecting a state of the second controller.</p><p id="p-0099" num="0098">In one implementation, the fourth through sixth bytes (e.g., &#x201c;I1&#x201d;, &#x201c;I2&#x201d;, &#x201c;I3) refer to one or more inputs received by the first controller and the second controller (e.g., emergency stop button, line break sensor). In one variation, any order of bytes may be used.</p><p id="p-0100" num="0099">In one implementation, the application processor concatenates the safety messages from the first controller and the second controller, as well as an error code (e.g., cyclic redundancy check (CRC) code). Further information about appending one or more error codes to safety data of two or more microcontrollers and decode/verify safety messages using the same is also described with reference to U.S. patent application Ser. No. 17/192,657, filed on 4 Mar. 2021, which is incorporated in its entirety by this reference.</p><p id="p-0101" num="0100">In one implementation, the application processor may augment the data of the controllers with other information, and may generate a cumulative error code (e.g., cumulative CRC) for the message in its entirety.</p><p id="p-0102" num="0101">In one implementation, the application processor of the input device transmits the safety message, after it is concatenated, to the receiving device (e.g., safety controller), which decodes the message. On the receiving side, the application processor (e.g., of safety controller) separates the messages from each controller. Where M0 or M1 indicate a fault state, all of inputs I1-I3 are failed. Systems and methods for decoding the message while ensuring functional safety standards are described with reference to U.S. patent application Ser. No. 17/192,657, filed on 4 Mar. 2021, which is incorporated in its entirety by this reference.</p><heading id="h-0020" level="1">7. Storing Valid Codewords</heading><p id="p-0103" num="0102">Block Silo of the method S<b>100</b> recites: storing a first set of valid codewords including: a first valid functional codeword representing a functional state of a first subsystem of a first set of subsystems within the first controller; a first valid fault codeword representing a fault state of the first subsystem and characterized by a first minimum hamming distance from the first valid functional codeword; a second valid functional codeword representing a functional state of the first controller; a second valid fault codeword representing a fault state of the first controller and characterized by a second minimum hamming distance from the second valid functional codeword; a third valid functional codeword representing a functional state of a first input coupled to the system; a third valid fault codeword representing a fault state of the first input and characterized by a third minimum hamming distance from the third valid functional codeword; a fourth valid functional codeword representing a functional state of the system; and a fourth valid fault codeword representing a fault state of the system and characterized by a fourth minimum hamming distance from the fourth valid functional codeword.</p><p id="p-0104" num="0103">Generally, in Block S<b>110</b>, the first controller stores a first set of valid codewords representing states of subsystems within the first controller, an input(s) monitored by the first controller, and data communication involving the first controller. In particular, a valid codeword is a bit pattern uniquely representing a state and characterized by a minimum hamming distance from other valid codewords as described below.</p><p id="p-0105" num="0104">Similarly, in Block S<b>110</b>, the second controller stores a second set of valid codewords representing states of subsystems within the second controller, an input(s) monitored by the second controller, and data communication involving the second controller.</p><p id="p-0106" num="0105">In one implementation, the first controller can store the first set of valid codewords in the flash memory within the first controller. In one variation, the first controller can store the first set of valid codewords in an external memory. In yet another example, the first controller can store different valid codewords in the first set of valid codewords across different memories.</p><p id="p-0107" num="0106">Similarly, in one implementation, the second controller can store the second set of valid codewords in the flash memory within the second controller. In one variation, the second controller can store the second set of valid codewords in an external memory. In yet another example, the second controller can store different valid codewords in the second set of valid codewords across different memories.</p><p id="p-0108" num="0107">In one variation, the first controller stores every valid codeword stored and/or implemented by any other controller in communication with the first controller. Similarly, the second controller stores every valid codeword stored and/or implemented by any other controller in communication with the first controller. Therefore, the first controller can validate codewords included in safety messages received from the other controllers, as described below. In another variation, the first controller and the second controller can store a greater or fewer number of valid codewords.</p><heading id="h-0021" level="1">7.1 Storing Valid Codewords: First Controller Subsystems</heading><p id="p-0109" num="0108">Generally, in Block Sino, the first controller stores, for each subsystem in a set of a subsystems within the first controller: a respective valid functional codeword representing a functional state of the subsystem; and a respective valid fault codeword representing a fault state of the subsystem. In one example, the first controller can store: a valid functional codeword representing a functional state of the ALU; and a valid fault codeword representing a fault state of the ALU. In another example, the first controller can store: a valid functional codeword representing a functional state of the flash memory within the first controller; and a valid fault codeword representing a fault state of the ALU. In yet another example, the first controller can store: a valid functional codeword representing a functional state of the stack overflow safety mechanism; and a valid fault codeword representing a fault state of the stack overflow safety mechanism.</p><p id="p-0110" num="0109">In one implementation, the first controller stores each valid codeword representing a state of its subsystems as a different bit pattern exhibiting a length of 16 bits (e.g., one word, two bytes, four nibbles). Each 16-bit word includes an upper byte and a lower byte. Each byte includes an upper nibble and a lower nibble.</p><p id="p-0111" num="0110">In one example, the first controller can store a valid functional codeword representing a functional state of the ALU within the first controller as &#x201c;13, 14, 14, 13&#x201d; (expressed in binary as &#x201c;1101111011101101&#x201d;). The upper nibble of the upper byte is &#x201c;13&#x201d; (expressed in binary as &#x201c;1101&#x201d;) and the lower nibble of the upper byte is &#x201c;14&#x201d; (expressed in binary as &#x201c;1110&#x201d;). Likewise, the upper nibble of the lower byte is &#x201c;14&#x201d; (expressed in binary as &#x201c;110&#x201d;) and the lower nibble of the lower byte is &#x201c;13&#x201d; (expressed in binary as &#x201c;1101&#x201d;). The upper byte and the lower byte exhibit inverse nibble values to each other (e.g., &#x201c;13, 14&#x201d; versus &#x201c;14, 13&#x201d;).</p><p id="p-0112" num="0111">In another example, the first controller can store a valid fault codeword representing a fault state of the ALU within the first controller as &#x201c;8, 2, 2, 8&#x201d; (expressed in binary as &#x201c;10000000001000&#x201d;). The upper nibble of the upper byte is &#x201c;8&#x201d; (expressed in binary as &#x201c;1000&#x201d;) and the lower nibble of the upper byte is &#x201c;2&#x201d; (expressed in binary as &#x201c;0010&#x201d;). Likewise, the upper nibble of the lower byte is &#x201c;2&#x201d; (expressed in binary as &#x201c;0010&#x201d;) and the lower nibble of the lower byte is &#x201c;8&#x201d; (expressed in binary as &#x201c;1000&#x201d;). The upper byte and the lower byte exhibit inverse nibble values to each other (e.g., &#x201c;8, 2&#x201d; versus &#x201c;2, 8&#x201d;).</p><p id="p-0113" num="0112">In one implementation, the first controller stores valid codewords including only odd values (e.g., every half byte is an odd value). In one variation, the first controller stores valid codewords including only even values (e.g., every half byte is an even value). In another variation, the first controller stores valid codewords characterized by: the upper byte of a valid fault codeword uses only odd values; the lower byte of a valid fault codeword uses only even values; the upper byte of a valid functional codeword uses only even values; and the lower byte of a valid functional codeword uses only odd values. In yet another variation, the first controller stores valid codewords characterized by: the upper byte of a valid fault codeword uses only even values; the lower byte of a valid fault codeword uses only odd values; the upper byte of a valid functional codeword uses only odd values; and the lower byte of a valid functional codeword uses only even values. &#x201c;Odd&#x201d; and &#x201c;even&#x201d; here describe the number of bits instead of an odd or even value of the decimal number.</p><p id="p-0114" num="0113">In one implementation, the first controller stores a valid functional codeword for a given subsystem within the first controller and a valid fault codeword for the given subsystem mutually characterized by a minimum hamming distance of 8 from each other. In the above example, the valid functional codeword representing a functional state of the ALU (e.g., &#x201c;1101111011101101&#x201d;) and the valid fault codeword representing a fault state of the ALU (e.g., &#x201c;10000000001000&#x201d;) are characterized by a hamming distance of 8 from each other. In one variation, the first controller can store a valid functional codeword for a given subsystem and a valid fault codeword for the given subsystem mutually characterized by a hamming distance of greater than 8 from each other.</p><p id="p-0115" num="0114">In one implementation, the first controller stores a valid functional codeword for a given subsystem within the first controller and a valid functional codeword for a different subsystem within the first controller mutually characterized by a minimum hamming distance of 4 from each other.</p><p id="p-0116" num="0115">In one implementation, the first controller stores a valid functional codeword for a given subsystem within the first controller and a valid fault codeword for a different subsystem within the first controller mutually characterized by a minimum hamming distance of 4 from each other.</p><p id="p-0117" num="0116">In one implementation, the first controller stores a valid fault codeword for a given subsystem within the first controller and a valid functional codeword for a different subsystem within the first controller mutually characterized by a minimum hamming distance of 4 from each other.</p><p id="p-0118" num="0117">In one implementation, the first controller stores a valid fault codeword for a given subsystem within the first controller and a valid fault codeword for a different subsystem within the first controller mutually characterized by a minimum hamming distance of 4 from each other.</p><p id="p-0119" num="0118">In one variation of the above example, the first controller can further store: a valid functional codeword representing a functional state of the flash memory within the first controller as &#x201c;14, 13, 13, 14&#x201d; (expressed in binary as &#x201c;1110110111011110&#x201d;); and a valid fault codeword representing a fault state of the flash memory within the first controller as &#x201c;2, 8, 8, 2&#x201d; (expressed in binary as &#x201c;0010100010000010&#x201d;).</p><p id="p-0120" num="0119">In the above example, the valid functional codeword representing a functional state of the ALU (e.g., &#x201c;1101111011101101&#x201d;) and the valid functional codeword representing a functional state of the flash memory (e.g., &#x201c;1110110101011110&#x201d;) are characterized by a minimum hamming distance of 4 from each other (e.g., a hamming distance of 8 in this case).</p><p id="p-0121" num="0120">In the above example, the valid functional codeword representing a functional state of the ALU (e.g., &#x201c;1101111011101101&#x201d;) and the valid fault codeword representing a fault state of the flash memory (e.g., &#x201c;0010100010000010&#x201d;) are characterized by a minimum hamming distance of 4 from each other (e.g., a hamming distance of 8 in this case).</p><p id="p-0122" num="0121">In the above example, the valid fault codeword representing a fault state of the ALU (e.g., &#x201c;10000000001000&#x201d;) and the valid functional codeword representing a functional state of the flash memory (e.g., &#x201c;1110110111011110&#x201d;) are characterized by a minimum hamming distance of 4 from each other (e.g., a hamming distance of 12 in this case).</p><p id="p-0123" num="0122">In the above example, the valid fault codeword representing a fault state of the ALU (e.g., &#x201c;10000000001000&#x201d;) and the valid fault codeword representing a fault state of the flash memory (e.g., &#x201c;0010100010000010&#x201d;) are characterized by a minimum hamming distance of 4 from each other (e.g., a hamming distance of 8 in this case).</p><p id="p-0124" num="0123">Therefore, the first controller can store valid codewords characterized by sufficiently large minimum hamming distances to detect occurrences of bit flips or software overwrites.</p><heading id="h-0022" level="1">7.2 Storing Valid Codewords: Second Controller Subsystems</heading><p id="p-0125" num="0124">Generally, in Block S<b>110</b>, the second controller stores, for each subsystem in a set of a subsystems within the second controller: a respective valid functional codeword representing a functional state of the subsystem; and a respective valid fault codeword representing a fault state of the subsystem.</p><p id="p-0126" num="0125">In one implementation, the second controller stores: a valid functional codeword for a given subsystem within the second controller and a valid fault codeword for the given subsystem within the second controller mutually characterized by a minimum hamming distance of 8 from each other; a valid functional codeword for a given subsystem within the second controller and a valid functional codeword for a different subsystem within the second controller mutually characterized by a minimum hamming distance of 4 from each other; a valid functional codeword for a given subsystem within the second controller and a valid fault codeword for a different subsystem within the second controller mutually characterized by a minimum hamming distance of 4 from each other; a valid fault codeword for a given subsystem within the second controller and a valid functional codeword for a different subsystem within the second controller mutually characterized by a minimum hamming distance of 4 from each other; and a valid fault codeword for a given subsystem within the second controller and a valid fault codeword for a different subsystem within the second controller mutually characterized by a minimum hamming distance of 4 from each other.</p><p id="p-0127" num="0126">In one implementation, the second controller stores a valid functional codeword for a given subsystem within the second controller characterized by a minimum hamming distance of 8 from a valid functional codeword for an analogous subsystem within the first controller.</p><p id="p-0128" num="0127">In a variation of an above example, the second controller can store a valid functional codeword representing a functional state of the ALU within the second controller &#x201c;14, 13, 13, 14&#x201d; (expressed in binary as &#x201c;1110110111011110&#x201d;). The valid functional codeword representing a fault state of the ALU in the second controller (e.g., &#x201c;1110110111011110&#x201d;) and the valid functional codeword representing a functional state of the ALU in the first controller (e.g., &#x201c;1101111011101101&#x201d;) are characterized by a minimum hamming distance of 8 from each other (e.g., a hamming distance of 8 in this case).</p><p id="p-0129" num="0128">Similarly, in one implementation, the second controller stores a valid fault codeword for a given subsystem within the second controller characterized by a minimum hamming distance of 8 from a valid fault codeword for an analogous subsystem within the first controller.</p><heading id="h-0023" level="1">7.2.1 Storing Valid Codewords: Subsystems Example</heading><p id="p-0130" num="0129">In one example, the first controller (shown as &#x201c;MA&#x201d; in <figref idref="DRAWINGS">FIG. <b>3</b></figref>) and the second controller (shown as &#x201c;MB&#x201d; in <figref idref="DRAWINGS">FIG. <b>3</b></figref>) can each store codewords as shown in <figref idref="DRAWINGS">FIG. <b>3</b></figref>.</p><p id="p-0131" num="0130">In one example, the first controller stores the binary value pairs below characterized by a hamming distance equal to or greater than 8 to each other. The pairs include: No Failure Indicators (NFI) (e.g., valid functional codewords) and Failure Indicators (FI) (e.g., valid fault codewords) for Safety Mechanisms [SM] within the first controller: ALU/Core SM NFI to FI; Program Flow Monitor SM NFI to FI; RAM SM NFI to FI; Flash SM NFI to FI; Stack Underflow SM NFI to FI; and Stack Overflow SM NFI to FI.</p><p id="p-0132" num="0131">In another example, the first controller stores NFI (e.g., valid functional codewords) within the first controller characterized by a hamming distance equal to or greater than 4 to each other. The pairs include: ALU/Core SM NFI to Program Flow Monitor SM NFI; ALU/Core SM NFI to RAM SM NFI; ALU/Core SM NFI to Flash SM NFI; ALU/Core SM NFI to Stack Underflow SM NFI; ALU/Core SM NFI to Stack Overflow SM NFI; Program Flow Monitor SM NFI to RAM SM NFI; Program Flow Monitor SM NFI to Flash SM NFI; Program Flow Monitor SM NFI to Stack Underflow SM NFI; Program Flow Monitor SM NFI to Stack Overflow SM NFI; RAM SM NFI to Flash SM NFI; RAM SM NFI to Stack Underflow SM NFI; RAM SM NFI to Stack Overflow SM NFI; Flash SM NFI to Stack Underflow SM NFI; Flash SM NFI to Stack Overflow SM NFI; and Flash SM NFI to Stack Overflow SM NFI.</p><p id="p-0133" num="0132">In yet another example, the first controller stores FI (e.g., valid fault codewords) within the first controller characterized by a hamming distance equal to or greater than 4 to each other. The pairs include ALU/Core SM FI to Program Flow Monitor SM FI; ALU/Core SM FI to RAM SM FI; ALU/Core SM FI to Flash SM FI; ALU/Core SM FI to Stack Underflow SM FI; ALU/Core SM FI to Stack Overflow SM FI; Program Flow Monitor SM FI to RAM SM FI; Program Flow Monitor SM FI to Flash SM FI; Program Flow Monitor SM FI to Stack Underflow SM FI; Program Flow Monitor SM FI to Stack Overflow SM FI; RAM SM FI to Flash SM FI; RAM SM FI to Stack Underflow SM FI; RAM SM FI to Stack Overflow SM FI; Flash SM FI to Stack Underflow SM FI; Flash SM FI to Stack Overflow SM FI; and Flash SM FI to Stack Overflow SM FI.</p><p id="p-0134" num="0133">In yet another example, the first controller stores NFI (e.g., valid functional codewords) and other FI (e.g., valid fault codewords) within the first controller characterized by a hamming distance equal to or greater than 4 to each other. The pairs include ALU/Core SM NFI to Program Flow Monitor SM FI; ALU/Core SM NFI to RAM SM FI; ALU/Core SM NFI to Flash SM FI; ALU/Core SM NFI to Stack Underflow SM FI; ALU/Core SM NFI to Stack Overflow SM FI; Program Flow Monitor SM NFI to RAM SM FI; Program Flow Monitor SM NFI to Flash SM FI; Program Flow Monitor SM NFI to Stack Underflow SM FI; Program Flow Monitor SM NFI to Stack Overflow SM FI; RAM SM NFI to Flash SM FI; RAM SM NFI to Stack Underflow SM FI; RAM SM NFI to Stack Overflow SM FI; Flash SM NFI to Stack Underflow SM FI; Flash SM NFI to Stack Overflow SM FI; and Flash SM NFI to Stack Overflow SM FI.</p><p id="p-0135" num="0134">In yet another example, the first controller stores FI (e.g., valid fault codewords) and other NFI (e.g., valid functional codewords) within the first controller characterized by a hamming distance equal to or greater than 4 to each other. The pairs include ALU/Core SM FI to Program Flow Monitor SM NFI; ALU/Core SM FI to RAM SM NFI; ALU/Core SM FI to Flash SM NFI; ALU/Core SM FI to Stack Underflow SM NFI; ALU/Core SM FI to Stack Overflow SM NFI; Program Flow Monitor SM FI to RAM SM NFI; Program Flow Monitor SM FI to Flash SM NFI; Program Flow Monitor SM FI to Stack Underflow SM NFI; Program Flow Monitor SM FI to Stack Overflow SM NFI; RAM SM FI to Flash SM NFI; RAM SM FI to Stack Underflow SM NFI; RAM SM FI to Stack Overflow SM NFI; Flash SM FI to Stack Underflow SM NFI; Flash SM FI to Stack Overflow SM NFI; and Flash SM FI to Stack Overflow SM NFI.</p><p id="p-0136" num="0135">In yet another example, the second controller stores the binary value pairs below characterized by a hamming distance equal to or greater than 8 to each other. The pairs include No Failure Indicators (NFI) (e.g., valid functional codewords) and Failure Indicators (FI) (e.g., valid fault codewords) for Safety Mechanisms [SM] within the second controller: ALU/Core SM NFI to FI; Program Flow Monitor SM NFI to FI; RAM SM NFI to FI; Flash SM NFI to FI; Stack Underflow SM NFI to FI; and Stack Overflow SM NFI to FI.</p><p id="p-0137" num="0136">In yet another example, the second controller stores NFI (e.g., valid functional codewords) within the second controller characterized by a hamming distance equal to or greater than 4 to each other. The pairs include ALU/Core SM NFI to Program Flow Monitor SM NFI; ALU/Core SM NFI to RAM SM NFI; ALU/Core SM NFI to Flash SM NFI; ALU/Core SM NFI to Stack Underflow SM NFI; ALU/Core SM NFI to Stack Overflow SM NFI; Program Flow Monitor SM NFI to RAM SM NFI; Program Flow Monitor SM NFI to Flash SM NFI; Program Flow Monitor SM NFI to Stack Underflow SM NFI; Program Flow Monitor SM NFI to Stack Overflow SM NFI; RAM SM NFI to Flash SM NFI; RAM SM NFI to Stack Underflow SM NFI; RAM SM NFI to Stack Overflow SM NFI; Flash SM NFI to Stack Underflow SM NFI; Flash SM NFI to Stack Overflow SM NFI; and Flash SM NFI to Stack Overflow SM NFI.</p><p id="p-0138" num="0137">In yet another example, the second controller stores FI (e.g., valid fault codewords) within the second controller characterized by a hamming distance equal to or greater than 4 to each other. The pairs include ALU/Core SM FI to Program Flow Monitor SM FI; ALU/Core SM FI to RAM SM FI; ALU/Core SM FI to Flash SM FI; ALU/Core SM FI to Stack Underflow SM FI; ALU/Core SM FI to Stack Overflow SM FI; Program Flow Monitor SM FI to RAM SM FI; Program Flow Monitor SM FI to Flash SM FI; Program Flow Monitor SM FI to Stack Underflow SM FI; Program Flow Monitor SM FI to Stack Overflow SM FI; RAM SM FI to Flash SM FI; RAM SM NFI to Stack Underflow SM FI; RAM SM FI to Stack Overflow SM FI; Flash SM FI to Stack Underflow SM FI; Flash SM FI to Stack Overflow SM FI; and Flash SM FI to Stack Overflow SM FI.</p><p id="p-0139" num="0138">In yet another example, the second controller stores NFI (e.g., valid functional codewords) and other Failure Indicators FI within the second controller characterized by a hamming distance equal to or greater than 4 to each other. The pairs include ALU/Core SM NFI to Program Flow Monitor SM FI; ALU/Core SM NFI to RAM SM FI; ALU/Core SM NFI to Flash SM FI; ALU/Core SM NFI to Stack Underflow SM FI; ALU/Core SM NFI to Stack Overflow SM FI; Program Flow Monitor SM NFI to RAM SM FI; Program Flow Monitor SM NFI to Flash SM FI; Program Flow Monitor SM NFI to Stack Underflow SM FI; Program Flow Monitor SM NFI to Stack Overflow SM FI; RAM SM NFI to Flash SM FI; RAM SM NFI to Stack Underflow SM FI; RAM SM NFI to Stack Overflow SM FI; Flash SM NFI to Stack Underflow SM FI; Flash SM NFI to Stack Overflow SM FI; and Flash SM NFI to Stack Overflow SM FI.</p><p id="p-0140" num="0139">In yet another example, the second controller stores FI (e.g., valid fault codewords) and other NFI (e.g., valid fault codewords) within the second controller characterized by a hamming distance equal to or greater than 4 to each other. The pairs include ALU/Core SM FI to Program Flow Monitor SM NFI; ALU/Core SM FI to RAM SM NFI; ALU/Core SM FI to Flash SM NFI; ALU/Core SM FI to Stack Underflow SM NFI; ALU/Core SM FI to Stack Overflow SM NFI; Program Flow Monitor SM FI to RAM SM NFI; Program Flow Monitor SM FI to Flash SM NFI; Program Flow Monitor SM FI to Stack Underflow SM NFI; Program Flow Monitor SM FI to Stack Overflow SM NFI; RAM SM FI to Flash SM NFI; RAM SM FI to Stack Underflow SM NFI; RAM SM FI to Stack Overflow SM NFI; Flash SM FI to Stack Underflow SM NFI; Flash SM FI to Stack Overflow SM NFI; and Flash SM FI to Stack Overflow SM NFI.</p><p id="p-0141" num="0140">In yet another example, the second controller stores the binary value pairs below have equal to or greater than 8 to each other. The pairs include Controller <b>1</b> (e.g., the first controller) ALU/Core SM NFI to Controller <b>2</b> (e.g., the second controller) ALU/Core SM NFI; Controller <b>1</b> ALU/Core SM FI to Controller <b>2</b> ALU/Core SM FI; Controller <b>1</b> ALU/Core SM NFI to Controller <b>2</b> ALU/Core SM NFI; Controller <b>1</b> ALU/Core SM FI to Controller <b>2</b> ALU/Core SM NFI; Controller <b>1</b> Program Flow Monitor [PFM] SM NFI to Controller <b>2</b> PFM SM NFI; Controller <b>1</b> PFM SM FI to Controller <b>2</b> PFM SM FI; Controller <b>1</b> PFM SM NFI to Controller <b>2</b> PFM SM NFI; Controller <b>1</b> PFM SM FI to Controller <b>2</b> PFM SM NFI; Controller <b>1</b> RAM SM NFI to Controller <b>2</b> RAM SM NFI; Controller <b>1</b> RAM SM FI to Controller <b>2</b> RAM SM FI; Controller <b>1</b> RAM SM NFI to Controller <b>2</b> RAM SM NFI; Controller <b>1</b> RAM SM FI to Controller <b>2</b> RAM SM NFI; Controller <b>1</b> Flash SM NFI to Controller <b>2</b> Flash SM NFI; Controller <b>1</b> Flash SM FI to Controller <b>2</b> Flash SM FI; Controller <b>1</b> Flash SM NFI to Controller <b>2</b> Flash SM NFI; Controller <b>1</b> Flash SM FI to Controller <b>2</b> Flash SM NFI; Controller <b>1</b> Stack Underflow SM NFI to Controller <b>2</b> Stack Underflow SM NFI; Controller <b>1</b> Stack Underflow SM FI to Controller <b>2</b> Stack Underflow SM FI; Controller <b>1</b> Stack Underflow SM NFI to Controller <b>2</b> Stack Underflow SM NFI; Controller <b>1</b> Stack Underflow SM FI to Controller <b>2</b> Stack Underflow SM NFI; Controller <b>1</b> Stack Underflow SM NFI to Controller <b>2</b> Stack Underflow SM NFI; Controller <b>1</b> Stack Underflow SM FI to Controller <b>2</b> Stack Underflow SM FI; Controller <b>1</b> Stack Underflow SM NFI to Controller <b>2</b> Stack Underflow SM NFI; and Controller <b>1</b> Stack Underflow SM FI to Controller <b>2</b> Stack Underflow SM NFI.</p><p id="p-0142" num="0141">Therefore, the first controller and the second controller implementing valid functional codewords and valid fault codewords exhibit freedom from interference (FFI) from each other.</p><heading id="h-0024" level="1">7.3 Storing Valid Codewords: Overall Controller State</heading><p id="p-0143" num="0142">In one implementation, in Block Silo, the first controller stores: a valid functional codeword representing a functional state of the first controller; and a valid fault codeword representing a fault state of the first controller and characterized by a minimum hamming distance from the valid functional codeword representing a functional state of the first controller. For example, the first controller can store the valid functional codeword and the valid fault codeword characterized by a minimum hamming distance of 4 from each other.</p><p id="p-0144" num="0143">Similarly, in one implementation, in Block Silo, the second controller stores: a valid functional codeword representing a functional state of the second controller; and a valid fault codeword representing a fault state of the second controller and characterized by a minimum hamming distance from the valid functional codeword representing a functional state of the second controller. For example, the second controller can store the valid functional codeword and the valid fault codeword characterized by a minimum hamming distance of 4 from each other.</p><p id="p-0145" num="0144">In one implementation, the valid codewords representing state of a controller each exhibit a length of 8 bits (e.g., one byte).</p><p id="p-0146" num="0145">In one example, the first controller can store: a valid functional codeword representing a functional state of the first controller as &#x201c;11110010;&#x201d; and a valid fault codeword representing a fault state of the first controller as &#x201c;10100100.&#x201d;</p><p id="p-0147" num="0146">In another example, the second controller can store: a valid functional codeword representing a functional state of the second controller as &#x201c;00101111;&#x201d; and a valid fault codeword representing a fault state of the second controller as &#x201c;01001010.&#x201d;</p><p id="p-0148" num="0147">In one implementation, the valid functional codeword for the first controller and the valid functional codeword exhibit inverse nibble values to each other (e.g., &#x201c;1111, 0010&#x201d; versus &#x201c;0010, 1111&#x201d;). Similarly, in one implementation, the valid fault codeword for the first controller and the valid fault codeword exhibit inverse nibble values to each other (e.g., &#x201c;1010, 0100&#x201d; versus &#x201c;0100, 1010&#x201d;).</p><p id="p-0149" num="0148">In one implementation, in Block Silo, the first controller stores: a valid functional codeword representing a functional state of the second controller; and a valid fault codeword representing a fault state of the second controller and characterized by a minimum hamming distance (e.g., 4) from the valid functional codeword representing a functional state of the second controller.</p><p id="p-0150" num="0149">In one implementation, in Block Silo, the second controller stores: a valid functional codeword representing a functional state of the first controller; and a valid fault codeword representing a fault state of the first controller and characterized by a minimum hamming distance (e.g., 4) from the valid functional codeword representing a functional state of the first controller.</p><heading id="h-0025" level="1">7.4 Storing Valid Codewords: External Input</heading><p id="p-0151" num="0150">In one implementation, in Block Silo, the first controller stores: a valid functional codeword representing a functional state of a first input coupled to the system; and a valid fault codeword representing a fault state of the first input and characterized by a minimum hamming distance (e.g., 4) from the valid functional codeword representing a functional state of the first input.</p><p id="p-0152" num="0151">In one implementation, in Block S<b>110</b>, the second controller stores: a valid functional codeword representing a functional state of a second input coupled to the system; and a valid fault codeword representing a fault state of the second input and characterized by a minimum hamming distance (e.g., 4) from the valid functional codeword representing a functional state of the second input.</p><p id="p-0153" num="0152">In one variation, the first controller and the second controller can each store respective valid functional/fault codewords for more than one input. In one example, each valid functional/fault codeword pair can exhibit a minimum hamming distance (e.g., 4) from each other. In another example, each valid codeword can exhibit a minimum hamming distance (e.g., 4) from other valid codewords.</p><p id="p-0154" num="0153">In one implementation, the valid codewords representing state of an input each exhibit a length of 8 bits (e.g., one byte).</p><heading id="h-0026" level="1">7.5 Storing Valid Codewords: Safety Module Timeout</heading><p id="p-0155" num="0154">In one implementation, in Block S<b>110</b>, the first controller stores: a valid functional codeword representing a functional timeout state of the second controller; and a valid fault codeword representing a fault timeout state of the second controller and characterized by a minimum hamming distance (e.g., 8) from the valid functional codeword representing a functional timeout state of the second controller.</p><p id="p-0156" num="0155">In one implementation, the first controller stores these valid codewords as a different bit pattern exhibiting a length of 16 bits (e.g., one word, two bytes, four nibbles). Each 16-bit word includes an upper byte and a lower byte. Each byte includes an upper nibble and a lower nibble.</p><p id="p-0157" num="0156">For example, the first controller can store: a valid functional codeword representing a functional timeout state of the second controller as &#x201c;12, 5, 11, 7&#x201d; (expressed in binary as &#x201c;1100010110110111&#x201d;); and a valid fault codeword representing a fault timeout state of the second controller as &#x201c;7, 11, 5, 12&#x201d; (expressed in binary as &#x201c;0111101101011100&#x201d;).</p><p id="p-0158" num="0157">Similarly, in one implementation, the second controller stores: a valid functional codeword representing a functional timeout state of the first controller; and a valid fault codeword representing a fault timeout state of the first controller and characterized by a minimum hamming distance (e.g., 8) from the valid functional codeword representing a functional timeout state of the first controller.</p><p id="p-0159" num="0158">For example, the second controller can store: a valid functional codeword representing a functional timeout state of the first controller as &#x201c;5, 12, 7, 11&#x201d; (expressed in binary as &#x201c;0101110001111011&#x201d;); and a valid fault codeword representing a fault timeout state of the first controller as &#x201c;11, 7, 12, 5&#x201d; (expressed in binary as &#x201c;1011011111000101&#x201d;).</p><p id="p-0160" num="0159">In one variation: the upper byte of a valid fault codeword exhibits only odd values, and the lower byte of the valid fault codeword exhibits only even values; the upper byte of a valid functional codeword exhibits only even values, and the lower byte of the valid functional codeword exhibits only odd values. In another variation: the upper byte of a valid fault codeword exhibits only even values, and the lower byte of the valid fault codeword exhibits only odd values; the upper byte of a valid functional codeword exhibits only odd values, and the lower byte of the valid functional codeword exhibits only even values. &#x201c;Odd&#x201d; and &#x201c;even&#x201d; here describe the number of bits instead of an odd or even value of the decimal number.</p><p id="p-0161" num="0160">In one implementation, in Block S<b>110</b>, the first controller stores: a valid functional codeword representing a functional state of communicated content from the second controller; and a valid fault codeword representing a fault state of communicated content from the second controller and characterized by a minimum hamming distance (e.g., 8) from the valid functional codeword representing a functional state of communicated content from the second controller.</p><p id="p-0162" num="0161">Similarly, in one implementation, in Block S<b>110</b>, the second controller stores: a valid functional codeword representing a functional state of communicated content from the first controller; and a valid fault codeword representing a fault state of communicated content from the first controller and characterized by a minimum hamming distance (e.g., 8) from the valid functional codeword representing a functional state of communicated content from the first controller.</p><p id="p-0163" num="0162">In one implementation, in Block S<b>110</b>, the first controller stores: a valid functional codeword representing a functional state of communicated content from the application processor; and a valid fault codeword representing a fault state of communicated content from the application processor and characterized by a minimum hamming distance (e.g., 8) from the valid functional codeword representing a functional state of communicated content from the application processor.</p><p id="p-0164" num="0163">Similarly, in one implementation, in Block S<b>110</b>, the second controller stores: a valid functional codeword representing a functional state of communicated content from the application processor; and a valid fault codeword representing a fault state of communicated content from the application processor and characterized by a minimum hamming distance (e.g., 8) from the valid functional codeword representing a functional state of communicated content from the application processor.</p><p id="p-0165" num="0164">In one implementation, the first controller stores these valid codewords, each characterized by a minimum hamming distance (e.g., 4) from other valid codewords.</p><p id="p-0166" num="0165">For example, the first controller (shown as &#x201c;MA&#x201d;) and the second controller (shown as &#x201c;MB&#x201d;) can each store codewords as shown in <figref idref="DRAWINGS">FIGS. <b>5</b>A, <b>5</b>B, <b>5</b>C, <b>5</b>D, and <b>6</b></figref> (application processor shown as &#x201c;AP&#x201d;).</p><p id="p-0167" num="0166">In this example, all four communication SM value NFI (e.g., valid functional codewords)/FI (e.g., valid fault codewords) pairs within the first controller MA are characterized by a hamming distance greater than or equal to 8 from each other. All four NFI within the first controller MA are characterized by a hamming distance greater than or equal to 4 from each other. All four FI within the first controller MA are characterized by a hamming distance greater than or equal to 4 from each other. Any of the four NFI within first controller MA are characterized by a hamming distance greater than or equal to 4 from any of the 4 FI within the first controller MA.</p><p id="p-0168" num="0167">Similarly, all four communication SM value NFI (e.g., valid functional codewords)/FI (e.g., valid fault codewords) pairs within the second controller MB are characterized by a hamming distance greater than or equal to 8 from each other. All four NFI within the second controller MB are characterized by a hamming distance greater than or equal to 4 from each other. All four FI within the second controller MB are characterized by a hamming distance greater than or equal to 4 from each other. Any of the four NFI within second controller MB are characterized by a hamming distance greater than or equal to 4 from any of the 4 FI within the second controller MB.</p><heading id="h-0027" level="1">7.6 Storing Valid Codewords: Safety Controller Timeout</heading><p id="p-0169" num="0168">In one implementation, in Block S<b>110</b>, the first controller stores: a valid functional codeword representing a functional timeout state of a third controller within a second safety module coupled to the system; a valid fault codeword representing a fault timeout state of the third controller and characterized by a minimum hamming distance (e.g., 8) from the valid functional codeword representing a functional timeout state of the third controller; a valid functional codeword representing a functional timeout state of a fourth controller within a third safety module coupled to the system; a valid fault codeword representing a fault timeout state of the fourth controller and characterized by a minimum hamming distance (e.g., 8) from the valid functional codeword representing a functional timeout state of the fourth controller; a ninth valid functional codeword representing a functional timeout state of a set of monitored controllers including the third controller and the fourth controller; and a ninth valid fault codeword representing a fault timeout state of the set of monitored controllers and characterized by a minimum hamming distance (e.g., 8) from the ninth valid functional codeword representing a functional timeout state of the set of monitored controllers.</p><p id="p-0170" num="0169">In one variation, the first controller can store a greater or fewer number of valid functional codewords corresponding to a greater or fewer number of controllers of other safety modules being monitored by the first controller and included in the set of monitored controllers.</p><p id="p-0171" num="0170">In one implementation, the first controller stores these valid codewords as a different bit pattern exhibiting a length of 16 bits (e.g., one word, two bytes, four nibbles). Each 16-bit word includes an upper byte and a lower byte. Each byte includes an upper nibble and a lower nibble. In one variation, the first controller stores the valid functional codeword representing a functional timeout state of the set of monitored controllers and the valid fault codeword representing a fault timeout state of the set of monitored controllers as different bit patterns each exhibiting a length of 8 bits (e.g., one byte).</p><p id="p-0172" num="0171">In one implementation: the upper byte of a valid fault codeword exhibits only odd values, and the lower byte of the valid fault codeword exhibits only even values; the upper byte of a valid functional codeword exhibits only even values, and the lower byte of the valid functional codeword exhibits only odd values. In one variation: the upper byte of a valid fault codeword exhibits only even values, and the lower byte of the valid fault codeword exhibits only odd values; the upper byte of a valid functional codeword exhibits only odd values, and the lower byte of the valid functional codeword exhibits only even values.</p><p id="p-0173" num="0172">In one implementation, the first controller stores valid functional/fault codewords representing a timeout state for a given controller characterized by a minimum hamming distance (e.g., 8) from each other. In one implementation, the first controller stores these valid codewords each characterized by a minimum hamming distance (e.g., 4) from other valid codewords.</p><p id="p-0174" num="0173">In one variation, in Block S<b>110</b>, the second controller can store valid codewords representing timeout states of controllers within other safety modules in an analogous manner as described above in connection with the first controller, such as described in the foregoing example.</p><heading id="h-0028" level="1">7.6.1 Storing Valid Codewords: Safety Controller Timeout Example</heading><p id="p-0175" num="0174">In one example, the first controller (shown as &#x201c;MA&#x201d;) and the second controller (shown as &#x201c;MB&#x201d;) within the safety module can each store codewords as shown in <figref idref="DRAWINGS">FIGS. <b>5</b>A, <b>5</b>B, <b>5</b>C, <b>5</b>D, and <b>6</b></figref>.</p><p id="p-0176" num="0175">In this example, the first controller (MA) and the second controller (MB) in the safety module monitor timeout state for respective MA controllers and MB controllers in devices D<b>1</b>-D<b>12</b>. In particular, the safety module is a safety controller for devices D<b>1</b>-D<b>12</b>, and devices D<b>1</b>-D<b>12</b> are each safety modules.</p><p id="p-0177" num="0176">In one implementation, the first controller monitors timeout state for MA controller in device D<b>1</b>, MA controller in device D<b>2</b>, MA controller in device D<b>3</b>, etc. Similarly, the second controller monitors timeout state for MB controller in device D<b>1</b>, MB controller in device D<b>2</b>, MB controller in device D<b>3</b>, etc.</p><p id="p-0178" num="0177">In one implementation, the first controller stores valid functional/fault codewords, each representing a respective state of MA controllers in devices D<b>1</b>-D<b>12</b>. Similarly, the second controller stores valid functional/fault codewords each representing a respective state of MB controllers in devices D<b>1</b>-D<b>12</b>.</p><p id="p-0179" num="0178">In one implementation, the first controller and the second controller store these valid codewords as a different bit pattern exhibiting a length of 16 bits (e.g., one word, two bytes, four nibbles). Each 16-bit word includes an upper byte and a lower byte. Each byte includes an upper nibble and a lower nibble. In one implementation, each byte (e.g., an upper byte, a lower byte) of each valid codeword includes an odd value nibble and an even value nibble.</p><p id="p-0180" num="0179">For example, the first controller can store: a valid fault codeword representing a fault timeout state of the third controller (e.g., MA of device D<b>1</b>) as &#x201c;14, 3, 7, 5&#x201d; (expressed in binary as &#x201c;1110001101110101&#x201d;); and a valid functional codeword representing a functional timeout state of the third controller as &#x201c;7, 5, 14, 3&#x201d; (expressed in binary as &#x201c;0111010111100011&#x201d;).</p><p id="p-0181" num="0180">In one variation: the upper byte of the valid functional codeword and the lower byte of the valid fault codeword are equivalent to each other; and the upper byte of the valid fault codeword and the lower byte of the valid functional codeword are equivalent to each other. For example, the upper byte of the valid functional codeword representing a functional timeout state of the controller MA of device D<b>1</b> (e.g., &#x201c;7, 5&#x201d;) and the lower byte of the valid fault codeword representing a fault timeout state of the controller MA of device D<b>1</b> (e.g., &#x201c;7, 5&#x201d;) are equivalent to each other. Furthermore, the upper byte of the valid fault codeword (e.g., &#x201c;14, 3&#x201d;) and the lower byte of the valid functional codeword are equivalent to each other (e.g., &#x201c;14, 3&#x201d;).</p><heading id="h-0029" level="1">7.7 Storing Valid Codewords: System State</heading><p id="p-0182" num="0181">In one implementation, in Block S<b>110</b>, the first controller stores: a valid functional codeword representing a functional state of the system; and a valid fault codeword representing a fault state of the system and characterized by a minimum hamming distance (e.g., 4) from the valid functional codeword representing a functional state of the system.</p><p id="p-0183" num="0182">In one implementation, in Block S<b>110</b>, the second controller stores: a valid functional codeword representing a functional state of the system; and a valid fault codeword representing a fault state of the system and characterized by a minimum hamming distance (e.g., 4) from the valid functional codeword representing a functional state of the system.</p><p id="p-0184" num="0183">In one example, each valid functional/fault codeword pair can exhibit a minimum hamming distance (e.g., 4) from each other. In another example, each valid codeword can exhibit a minimum hamming distance (e.g., 4) from other valid codewords.</p><p id="p-0185" num="0184">In one implementation, the valid codewords representing state of the system each exhibit a length of 8 bits (e.g., one byte).</p><heading id="h-0030" level="1">8. First Controller: Subsystem Monitoring</heading><p id="p-0186" num="0185">Block S<b>120</b> of the method S<b>100</b> recites: during a first time period: in response to detecting functional operation of the first subsystem, storing the first valid functional codeword in a first memory.</p><p id="p-0187" num="0186">Generally, in Block S<b>120</b>, during a monitoring period, the first controller: individually monitors each subsystem in a set of subsystems within the first controller; detects operation (e.g., functional operation, fault operation) for each subsystem based on the monitoring; detects a respective state of each subsystem corresponding to the detected operation of the subsystem; encodes the detected states into codewords corresponding to the detected states; and stores valid codewords (e.g., valid functional codeword, valid fault codeword) in memory based on the detected states.</p><p id="p-0188" num="0187">In one implementation, the first controller individually monitors each subsystem in a set of subsystems within the first controller. In one example, the first controller can individually monitor: the ALU, the RAM, the flash memory, the program flow monitor safety mechanism, the stack overflow safety mechanism, and/or the stack underflow safety mechanism. In another example, the first controller individually performs a diagnostic test on each subsystem.</p><p id="p-0189" num="0188">In one implementation, the first controller detects operation (e.g., functional operation, fault operation) for each subsystem based on the monitoring. In one example, the first controller can detect functional operation of the ALU based on performance a diagnostic test resulting without error. In another example, the first controller can detect fault operation of the stack overflow safety mechanism based on an instance of stack overflow being detected.</p><p id="p-0190" num="0189">In one implementation, the first controller detects functional operation of a subsystem in an absence of errors being detected for a given subsystem, and the first controller detects fault operation when one or more errors are detected for the given subsystem. For example, an error may be defined based on nature of the given subsystem, a safety standard associated with the given subsystem, and/or any factor applicable to the given subsystem.</p><p id="p-0191" num="0190">Generally, the first controller detects a respective state of each subsystem corresponding to the detected operation of the subsystem. In one implementation, the first controller: detects a functional state of a subsystem in response to detecting functional operation of the subsystem; and detects a fault state of a subsystem in response to detecting fault operation of the subsystem. In one example, the first controller detects a functional state of the ALU in response to detecting functional operation of the ALU. In another example, the first controller detects a fault state of the stack overflow safety mechanism in response to detecting fault operation of the stack overflow safety mechanism.</p><p id="p-0192" num="0191">Generally, the first controller encodes the detected states into codewords corresponding to the detected states of the subsystems. In one implementation, the first controller selects a valid codeword from the first set of valid codewords that corresponds to the detected state. In one example, the first controller selects a valid functional codeword representing functional operation of the ALU in response to detecting a functional state of the ALU. In another example, the first controller selects a valid fault codeword representing fault operation of the stack overflow safety mechanism in response to detecting a fault state of the stack overflow safety mechanism.</p><p id="p-0193" num="0192">Generally, the first controller stores respective valid codewords (e.g., valid functional codeword, valid fault codeword) for each subsystem in the set of subsystems in memory. In one implementation, the first controller stores a valid functional codeword representing functional operation of a subsystem in memory. In one variation, the first controller stores a valid fault codeword representing fault operation of the subsystem in memory. In one example, the first controller stores a valid functional codeword representing functional operation of the ALU in a first memory. In another example, the first controller stores a valid fault codeword representing fault operation of the stack overflow safety mechanism in a second memory.</p><p id="p-0194" num="0193">In one implementation, the first controller stores the valid codewords in the flash memory within the first controller. In one variation, the first controller stores the valid codewords in an external memory.</p><heading id="h-0031" level="1">9. First Controller: Overall Controller State</heading><p id="p-0195" num="0194">Block S<b>130</b> of the method S<b>100</b> recites: during a second time period after the first time period, at the first controller, in response to detecting a match between contents of the first memory and the first valid functional codeword, and in response to detecting functional operation of the first input, outputting a first safety message including the second valid functional codeword and the fourth valid functional codeword; and during a fourth time period after the third time period, at the first controller, in response to detecting a mismatch between contents of the first memory and every codeword in the first set of valid codewords, outputting a second safety message including the second valid fault codeword and the fourth valid fault codeword.</p><p id="p-0196" num="0195">Generally, in Block S<b>130</b>, during an evaluation period after the monitoring period, the first controller: detects whether codewords stored in memory during the monitoring period match valid codewords; detect an overall state of the first controller based on: (i) whether codewords stored in memory during the monitoring period match valid codewords, and (ii) the detected states; and output a safety message.</p><p id="p-0197" num="0196">In one implementation, the first controller detects a match between contents of a memory and a valid codeword included in the set of valid codewords. In one variation, the first controller detects a mismatch between contents of a memory and every valid codeword in the set of valid codewords.</p><p id="p-0198" num="0197">For example, if the contents of a memory associated with the ALU is &#x201c;8, 1, 2, 8&#x201d; the first controller detects a mismatch between the contents of the memory and every valid codeword in the set of valid codewords because the valid functional codeword for the ALU is &#x201c;13, 14, 14, 13&#x201d; and the valid fault codeword for the ALU is &#x201c;8, 2, 2, 8,&#x201d; and because no valid codeword in the set of valid codewords is &#x201c;8, 1, 2, 8.&#x201d;</p><p id="p-0199" num="0198">In one implementation, the first controller indicates a given subsystem is in a fault state in response to detecting a mismatch between contents of a memory associated with the given subsystem and every valid codeword in the set of valid codewords. For example, the first controller can store a valid fault codeword representing a fault state of the given subsystem in a memory in response to detecting the mismatch.</p><p id="p-0200" num="0199">In one implementation, the first controller detects an overall state of the first controller based on the codewords representing the detected states of the set of subsystems. In one implementation, the first controller detects an overall state of the first controller based on a set of rules. In one example, the first controller can detect a functional state of the first controller in response to detecting every subsystem in the set of subsystems is in a functional state and/or detecting a valid functional codeword in memory for every subsystem in the set of subsystems. In another example, the first controller can detect a fault state of the first controller in response to detecting one subsystem in the set of subsystems is in a fault state and/or detecting a valid fault codeword in memory for one subsystem in the set of subsystems.</p><p id="p-0201" num="0200">In one implementation, the first controller indicates a valid functional codeword representing a functional state of the first controller in response to detecting a functional state of the first controller. In one variation, the first controller indicates a valid fault codeword representing a fault state of the first controller in response to detecting a fault state of the first controller. In one example, the first controller can store a valid functional codeword (e.g., &#x201c;111000&#x201d;) representing a functional state of the first controller in memory. In another example, the first controller can store a valid fault codeword (e.g., &#x201c;10100100&#x201d;) representing a fault state of the first controller in memory.</p><p id="p-0202" num="0201">Generally, the first controller outputs a safety message including a valid codeword representing a state of the first controller. In one implementation, the first controller outputs a safety message including a valid functional codeword representing a functional state of the first controller in response to: detecting a match between contents of the memory and the set of valid codewords, detecting functional operation of the set of subsystems. In one variation, the first controller outputs a safety message including a valid fault codeword representing a fault state of the first controller in response to: detecting a mismatch between contents of the memory and every valid codeword in the set of valid codewords. In another variation, the first controller outputs a safety message including a valid fault codeword representing a fault state of the first controller in response to: detecting a match between contents of the memory and the set of valid codewords, detecting fault operation of at least one subsystem in the set of subsystems.</p><p id="p-0203" num="0202">In one implementation, the first controller outputs a safety message including a valid functional codeword representing a functional state of the first controller in a third byte (e.g., &#x201c;M0&#x201d;) of the safety message. In one variation, the first controller outputs a safety message including a valid fault codeword representing a fault state of the first controller in a third byte (e.g., &#x201c;M0&#x201d;) of the safety message.</p><p id="p-0204" num="0203">The first controller then outputs the safety message to the second controller and/or to the application processor.</p><heading id="h-0032" level="1">10. External Input</heading><p id="p-0205" num="0204">Block S<b>122</b> of the method S<b>100</b> recites: during a first time period: in response to detecting functional operation of the first input, storing the third valid functional codeword in a second memory.</p><p id="p-0206" num="0205">Generally, in Block S<b>122</b>, during a monitoring period, the first controller: monitors an input coupled to the system (e.g., emergency stop button, line break sensor); detects operation (e.g., functional operation, fault operation) of the input based on the monitoring; detects a respective state of the input corresponding to the detected operation of the subsystem; encodes the detected state into a codeword corresponding to the detected state; and stores a valid codeword (e.g., valid functional codeword, valid fault codeword) in memory based on the detected state.</p><p id="p-0207" num="0206">In one implementation, the first controller: reads and converts an analog voltage at an analog input pin into a set of input counts; reads a digital power supply signal from the ADC as a set of reference counts; corrects (e.g., scales) the input counts based on the set of reference counts to calculate a corrected input count; and encodes the corrected input count into a first encoded logic output value (e.g., valid codeword), such as described in U.S. patent application Ser. No. 17/332,635, filed on 27 May 2021, which is incorporated in its entirety by this reference.</p><p id="p-0208" num="0207">In one implementation, the first controller stores a valid functional codeword representing functional operation of the input in memory. In one variation, the first controller stores a valid fault codeword representing fault operation of the input in memory.</p><p id="p-0209" num="0208">In one implementation, the first controller stores the valid codewords in the flash memory within the first controller. In one variation, the first controller stores the valid codewords in an external memory.</p><p id="p-0210" num="0209">In one variation, the first controller performs Block S<b>122</b> for each additional input monitored by the first controller.</p><p id="p-0211" num="0210">In one variation, in Block S<b>130</b>, during an evaluation period after a monitoring period, the first controller outputs a safety message including a valid codeword representing a state of the input in response to detecting operation (e.g., functional operation, fault operation) of the input. For example, the first controller outputs a safety message including a valid functional codeword representing functional operation of the input in response to detecting functional operation of the input. In another example, the first controller outputs a safety message including a valid fault codeword representing fault operation of the input in response to detecting fault operation of the input. In yet another example, the first controller outputs a safety message including a valid functional codeword representing functional operation of the input in a fourth byte (e.g., &#x201c;I1&#x201d;) of the safety message. In yet another example, the first controller outputs a safety message including a valid fault codeword representing fault operation of the input in a fourth byte (e.g., &#x201c;I1&#x201d;) of the safety message.</p><heading id="h-0033" level="1">11. Inter-Controller Communication</heading><p id="p-0212" num="0211">Blocks S<b>124</b>, S<b>140</b>, S<b>142</b> of the method S<b>100</b> recite: during the first time period, at the first controller: querying an input register coupled to the second controller; detecting, in the input register, a fourth safety message including the sixth valid functional codeword from the second controller; during a third time period, querying an input register coupled to the first controller; and, in response to detecting non-receipt of a third safety message from the input register within a first time quantum, storing the ninth valid fault codeword in a fifth memory.</p><p id="p-0213" num="0212">Generally, in Blocks S<b>124</b>, S<b>140</b>, S<b>142</b>, during a monitoring period, the first controller: queries an input register coupled to the second controller; detects whether a safety message is in the input register within a predefined time quantum; detects a timeout state of the second controller; encodes the detected state into a codeword corresponding to the detected state; and stores a valid codeword (e.g., valid functional codeword, valid fault codeword) in memory based on the detected state.</p><p id="p-0214" num="0213">In one implementation, during a monitoring period, the first controller queries an input register coupled to the second controller. For example, the first controller can query an input of the first controller configured to receive safety messages from the second controller.</p><p id="p-0215" num="0214">In one implementation, the first controller detects receipt of a safety message in the input register from the second controller within a predefined time quantum. For example, the first controller can: monitor an elapsed time since a most recent safety message was received from the second controller; and detect receipt of the safety message within the predefined time quantum in response to detecting the elapsed time is within a threshold amount of time.</p><p id="p-0216" num="0215">In one implementation, the predefined time quantum and/or threshold amount of time can be selected based on safety standard, timing requirement, communication protocol, and/or any other factor.</p><p id="p-0217" num="0216">In one variation, the first controller detects non-receipt of a safety message in the input register from the second controller within a predefined time quantum. For example, the first controller can: monitor an elapsed time since a most recent safety message was received from the second controller; and detect non-receipt of the safety message within the predefined time quantum in response to detecting the elapsed time exceeds a threshold amount of time.</p><p id="p-0218" num="0217">In one implementation, the first controller detects a functional timeout state of the second controller in response to detecting receipt of a safety message in the input register coupled to the second controller within the predefined time quantum. In one variation, the first controller detects a fault timeout state of the second controller in response to detecting non-receipt of a safety message in the input register coupled to the second controller within the predefined time quantum.</p><p id="p-0219" num="0218">Generally, the first controller encodes the detected timeout state into a codeword corresponding to the detected timeout state. In one implementation, the first controller selects a valid codeword from the first set of valid codewords that corresponds to the detected state.</p><p id="p-0220" num="0219">Generally, the first controller stores a valid codeword (e.g., valid functional codeword, valid fault codeword) in memory. In one implementation, the first controller stores a valid functional codeword representing a functional timeout state of the second controller in memory. In one variation, the first controller stores a valid fault codeword representing a fault timeout state of the second controller in memory.</p><p id="p-0221" num="0220">In one variation, in response to detecting receipt of a safety message in the input register from the second controller within a predefined time quantum, the first controller detects whether content of the received safety message is valid. In one example, the first controller checks the content and format of the safety message to determine whether the safety message is erroneous. In another example, the first controller detects whether the safety message conforms with the data structure specified in <figref idref="DRAWINGS">FIG. <b>3</b></figref>. In yet another example, the first controller detects a mismatch between a codeword included in the safety message and every valid codeword in the stored set of valid codewords.</p><p id="p-0222" num="0221">In one implementation, the first controller detects a functional state of communicated content from the second controller in response to detecting an absence of errors in content and/or format of the safety message. In one variation, the first controller detects a fault state of communicated content from the second controller in response to detecting one or more errors in content and/or format of the safety message (e.g., a mismatch between a codeword included in the safety message and every valid codeword in the stored set of valid codewords).</p><p id="p-0223" num="0222">In one implementation, the first controller stores valid codewords (e.g., valid functional codeword, valid fault codeword) in memory representing timeout and/or content states of the second controller in memory. For example, the first controller stores a valid functional codeword representing a functional timeout state of the second controller in memory in response to detecting receipt of a safety message in the input register coupled to the second controller within the predefined time quantum. In another example, the first controller stores a valid fault codeword representing a fault timeout state of the second controller in memory in response to detecting non-receipt of a safety message in the input register coupled to the second controller within the predefined time quantum. In yet another example, the first controller stores a valid functional codeword representing a functional communicated content state of the second controller in memory in response to detecting an absence of errors in content and/or format of the safety message. In yet another example, the first controller stores a valid fault codeword representing a fault communicated content state of the second controller in memory in response to detecting one or more errors in content and/or format of the safety message. In yet another example, the first controller forgoes a content check and stores a valid fault codeword representing a fault communicated content state of the second controller in memory in response to detecting non-receipt of a safety message in the input register from the second controller within the predefined time quantum.</p><p id="p-0224" num="0223">In one implementation, the first controller stores the valid codewords in the flash memory within the first controller. In one variation, the first controller stores the valid codewords in an external memory.</p><p id="p-0225" num="0224">Block S<b>130</b> of the method S<b>100</b> recites: during a second time period after the first time period, at the first controller, in response to detecting a match between contents of the first memory and the first valid functional codeword, in response to detecting a match between contents of the third memory and the fifth valid functional codeword, and in response to detecting functional operation of the first input, outputting a second safety message including the second valid functional codeword and the sixth valid functional codeword; during a fourth time period after the third time period, at the first controller, in response to detecting a match between contents of the first memory and the first valid functional codeword, and in response to detecting a match between contents of the third memory and the fifth valid fault codeword, outputting a fourth safety message including the second valid functional codeword and the sixth valid fault codeword.</p><p id="p-0226" num="0225">Generally, in Block S<b>130</b>, during an evaluation period after the monitoring period, the first controller: detects whether codewords stored in memory during the monitoring period match valid codewords; detect an overall state of the first controller based on: (i) whether codewords stored in memory during the monitoring period match valid codewords, and (ii) the detected states; and output a safety message.</p><p id="p-0227" num="0226">In one implementation, the first controller detects a match between contents (e.g., codeword representing a functional timeout state of the second controller) of a memory and a valid codeword included in the set of valid codewords (e.g., valid codeword representing a functional timeout state of the second controller, valid codeword representing a functional communicated content state of the second controller). In one variation, the first controller detects a mismatch between contents (e.g., overwritten codeword representing a functional timeout state of the second controller, overwritten codeword representing a functional communicated content state of the second controller) of a memory and every valid codeword in the set of valid codewords.</p><p id="p-0228" num="0227">In one implementation, the first controller indicates the second controller is in a fault timeout state in response to detecting a mismatch between contents (e.g., overwritten codeword representing a functional timeout state of the second controller, overwritten codeword representing a functional communicated content state of the second controller) of a memory and every valid codeword in the set of valid codewords. For example, the first controller can store a valid fault codeword representing a fault timeout state of the second controller in a memory in response to detecting the mismatch.</p><p id="p-0229" num="0228">In one variation, in Block S<b>130</b>, during an evaluation period after a monitoring period, the first controller outputs a safety message including a valid codeword representing a state of the second controller in response to detecting receipt/non-receipt of a safety message from the second controller within a predefined time quantum. For example, the first controller outputs a safety message including a valid functional codeword representing functional operation of the second controller in response to detecting receipt of a safety message (including the valid functional codeword representing functional operation of the second controller) from the second controller within a predefined time quantum. In another example, the first controller outputs a safety message including a valid functional codeword representing functional operation of the second controller in response to detecting an absence of errors in content and/or format of the safety message from the second controller. In yet another example, the first controller outputs a safety message including a valid fault codeword representing fault operation of the second controller in response to detecting one or more errors in content and/or format of the safety message. In yet another example, the first controller outputs a safety message including a valid fault codeword representing fault operation of the second controller in response to detecting non-receipt of a safety message from the second controller within a predefined time quantum. In yet another example, the first controller outputs a safety message including a valid fault codeword representing fault operation of the second controller in response to detecting a mismatch between contents (e.g., overwritten codeword representing a functional timeout state of the second controller) of a memory associated with the second controller and every valid codeword in the set of valid codewords.</p><p id="p-0230" num="0229">In one variation, the first controller can detect communication faults with the application processor in an analogous manner. In particular, the first controller and application processor can monitor timeout and detect communicated content faults with each other in an analogous manner as described above in connection with the first controller and the second controller.</p><p id="p-0231" num="0230">Generally, the first controller can detect a state of the second controller based on contents of safety messages received from the second controller. For example, the safety message from the second controller can include a state (e.g., valid functional codeword, valid fault codeword) of the second controller, such as in the third byte (e.g., &#x201c;M1&#x201d;) of the safety message. Therefore, the first controller can detect infrastructure issues with the second controller.</p><p id="p-0232" num="0231">Similarly, the first controller can detect a state of the input based on contents of safety messages received from the second controller. For example, the safety message from the second controller can include a state (e.g., valid functional codeword, valid fault codeword) of the input as processed by the second controller, such as in the fourth byte (e.g., &#x201c;I1&#x201d;) of the safety message.</p><p id="p-0233" num="0232">In one implementation, in response to detecting a match between a state of the input as detected by the first controller and a state of the input as indicated in the safety message from the second controller, the first controller can detect the state is true. In one variation, in response to detecting a mismatch between a state of the input as detected by the first controller and a state of the input as indicated in the safety message from the second controller, the first controller can detect a fault state of the input. Therefore, probability of an error in a message is reduced below a threshold maximum error value as required by functional safety standards (e.g., IEC 61784), which is beneficial when communicating in media prone to interference (e.g., wireless communications, high utilization wired communications).</p><heading id="h-0034" level="1">12. Safety Controller</heading><p id="p-0234" num="0233">Block S<b>126</b> of the method S<b>100</b> recites, during the first time period: in response to detecting receipt of a fifth safety message from a third controller (e.g., within a second safety module) within a third time quantum, storing the seventh valid functional codeword in a fourth memory; in response to detecting non-receipt of a sixth safety message from the fourth controller (e.g., within a third safety module) within a fourth time quantum, storing the eighth valid fault codeword in a fifth memory; and wherein outputting, at the first controller during the second period of time, the second safety message includes outputting the second safety message including the second valid functional codeword, the sixth valid functional codeword, and the ninth valid fault codeword in response to detecting a match between contents of the first memory and the first valid functional codeword, in response to detecting a match between contents of the third memory and the fifth valid functional codeword, in response to detecting functional operation of the first input, in response to detecting a match between contents of the fourth memory and the seventh valid functional codeword, and in response to detecting a match between the fifth memory and the eighth valid fault codeword.</p><p id="p-0235" num="0234">Generally, in Block S<b>126</b>, during a monitoring period, the first controller: detects receipt (or non-receipt) of safety messages from each controller in a set of monitored controllers within other safety modules within predefined time quanta; detects a respective timeout state for each controller in the set of monitored controllers; encodes the detected states into a codewords corresponding to the detected state; and stores valid codeword (e.g., valid functional codeword, valid fault codeword) in memory based on the detected states.</p><p id="p-0236" num="0235">In one implementation, during a monitoring period, the first controller detects receipt (or non-receipt) of safety messages from each controller in a set of monitored controllers within other safety modules within predefined time quanta. In one example, the first controller can receive the safety messages from the application processor.</p><p id="p-0237" num="0236">In one implementation, the first controller independently detects receipt of safety messages from each controller in a set of monitored controllers within other safety modules within predefined time quanta. In one example, the first controller can: independently monitor an elapsed time since a most recent safety message was received from a given controller in the set of monitored controllers; and detect receipt of the safety message within the predefined time quantum in response to detecting the elapsed time is within a threshold amount of time.</p><p id="p-0238" num="0237">In one variation, the first controller can: independently monitor an elapsed time since a most recent safety message was received from a given controller in the set of monitored controllers; and detect non-receipt of the safety message within the predefined time quantum in response to detecting the elapsed time exceeds the threshold amount of time.</p><p id="p-0239" num="0238">In some implementations, the first controller receives safety messages from the set of monitored controllers at different times.</p><p id="p-0240" num="0239">In one implementation, the predefined time quantum and/or threshold amount of time can be selected based on safety standard, timing requirement, communication protocol, and/or any other factor. In one variation, the predefined time quantum and/or threshold amount of time can be selected individually for each controller in the set of monitored controllers.</p><p id="p-0241" num="0240">In one implementation, the first controller detects a functional timeout state of a given controller in the set of monitored controllers in response to detecting receipt of a safety message within the predefined time quantum. In one variation, the first controller detects a fault timeout state of the given controller in response to detecting non-receipt of a safety message within the predefined time quantum.</p><p id="p-0242" num="0241">Generally, the first controller encodes the detected timeout state into a codeword corresponding to the detected timeout state. In one implementation, the selects a valid codeword from the first set of valid codewords that corresponds to the detected state.</p><p id="p-0243" num="0242">Generally, the first controller stores a valid codeword (e.g., valid functional codeword, valid fault codeword) in memory. In one implementation, the first controller stores a valid functional codeword representing a functional timeout state of a given controller in the set of monitored controllers in memory. In one variation, the first controller stores a valid fault codeword representing a fault timeout state of the given controller in memory.</p><p id="p-0244" num="0243">In one variation, in response to detecting receipt of a safety message from a given controller in the set of monitored controllers within a predefined time quantum, the first controller detects whether content of the received safety message is valid. In one example, the first controller checks the content and format of the safety message to determine whether the safety message is erroneous. In another example, the first controller detects whether the safety message conforms with the data structure specified in <figref idref="DRAWINGS">FIG. <b>3</b></figref>. In yet another example, the first controller detects a mismatch between a codeword included in the safety message and every valid codeword in the stored set of valid codewords.</p><p id="p-0245" num="0244">In one implementation, the first controller detects a functional state of communicated content from the given controller in response to detecting an absence of errors in content and/or format of the safety message. In one variation, the first controller detects a fault state of communicated content from the given controller in response to detecting one or more errors in content and/or format of the safety message (e.g., a mismatch between a codeword included in the safety message and every valid codeword in the stored set of valid codewords).</p><p id="p-0246" num="0245">In one implementation, the first controller stores valid codewords (e.g., valid functional codeword, valid fault codeword) in memory representing timeout and/or content states of the given controller in memory. For example, the first controller stores a valid functional codeword representing a functional timeout state of the given controller in memory in response to detecting receipt of a safety message within the predefined time quantum. In another example, the first controller stores a valid fault codeword representing a fault timeout state of the given controller in memory in response to detecting non-receipt of a safety message within the predefined time quantum. In yet another example, the first controller stores a valid functional codeword representing a functional communicated content state of the given controller in memory in response to detecting an absence of errors in content and/or format of the safety message. In yet another example, the first controller stores a valid fault codeword representing a fault communicated content state of the given controller in memory in response to detecting one or more errors in content and/or format of the safety message. In yet another example, the first controller forgoes a content check and stores a valid fault codeword representing a fault communicated content state of the given controller in memory in response to detecting non-receipt of a safety message in the input register from the given controller within the predefined time quantum.</p><p id="p-0247" num="0246">In one implementation, the first controller stores the valid codewords in the flash memory within the first controller. In one variation, the first controller stores the valid codewords in an external memory.</p><p id="p-0248" num="0247">Block S<b>126</b>, S<b>130</b> of the method S<b>100</b> recites: during the first time period: in response to detecting receipt of a fifth safety message from a third controller (e.g., within a second safety module) within a third time quantum, storing the seventh valid functional codeword in a fourth memory; in response to detecting non-receipt of a sixth safety message from the fourth controller (e.g., within a third safety module) within a fourth time quantum, storing the eighth valid fault codeword in a fifth memory; and wherein outputting, at the first controller during the second period of time, the second safety message includes outputting the second safety message including the second valid functional codeword, the sixth valid functional codeword, and the ninth valid fault codeword in response to detecting a match between contents of the first memory and the first valid functional codeword, in response to detecting a match between contents of the third memory and the fifth valid functional codeword, in response to detecting functional operation of the first input, in response to detecting a match between contents of the fourth memory and the seventh valid functional codeword, and in response to detecting a match between the fifth memory and the eighth valid fault codeword.</p><p id="p-0249" num="0248">Generally, in Block S<b>130</b>, during an evaluation period after the monitoring period, the first controller: detects whether codewords stored in memory during the monitoring period match valid codewords; detect an overall state of the first controller based on: (i) whether codewords stored in memory during the monitoring period match valid codewords, and (ii) the detected states; and output a safety message.</p><p id="p-0250" num="0249">In one implementation, the first controller detects a match between contents of a memory and a valid codeword included in the set of valid codewords. In one variation, the first controller detects a mismatch between contents of a memory and every valid codeword in the set of valid codewords.</p><p id="p-0251" num="0250">In one implementation, the first controller indicates a given controller in the set of monitored controllers is in a fault timeout state in response to detecting a mismatch between contents of a memory associated with the given controller and every valid codeword in the set of valid codewords. For example, the first controller can store a valid fault codeword representing a fault timeout state of the given controller in a memory in response to detecting the mismatch.</p><p id="p-0252" num="0251">In one implementation, the first controller detects an overall timeout state of the set of monitored controllers based on the codewords representing the detected states of the set of subsystems. In one implementation, the first controller detects an overall timeout state of the set of monitored controllers based on a set of rules. In one example, the first controller can detect a functional timeout state of the set of monitored controllers in response to detecting every controller in the set of monitored controllers in a functional timeout state and/or detecting a valid functional codeword in memory for every controller in the set of monitored controllers. In another example, the first controller can detect a fault state of the set of monitored controllers in response to detecting one controller in the set of monitored controllers in a fault timeout state and/or detecting a valid fault codeword in memory for one controller in the set of monitored controllers. In yet another example, the first controller can detect a fault state of the set of monitored controllers in response to detecting two or more controllers in the set of monitored controllers in a fault timeout state and/or detecting two or more valid fault codewords in memory for two or more controllers in the set of monitored controllers.</p><p id="p-0253" num="0252">In one implementation, the first controller stores a valid functional codeword representing a functional timeout state of the set of monitored controllers in memory in response to detecting a functional timeout state of the set of monitored controllers. In one variation, the first controller stores a valid fault codeword representing a fault timeout state of the set of monitored controllers in memory in response to detecting a fault timeout state of the set of monitored controllers.</p><p id="p-0254" num="0253">In one implementation, the first controller stores the valid codewords in the flash memory within the first controller. In one variation, the first controller stores the valid codewords in an external memory.</p><p id="p-0255" num="0254">In one variation, in Block S<b>130</b>, during an evaluation period after a monitoring period, the first controller outputs a safety message including a valid codeword representing a timeout state of the set of monitored controllers. In one example, the first controller can output a safety message including the valid functional codeword representing a functional timeout state of the set of monitored controllers. In another example, the first controller can output a safety message including the valid fault codeword representing a fault timeout state of the set of monitored controllers.</p><heading id="h-0035" level="1">13. System State</heading><p id="p-0256" num="0255">In one variation, in Block S<b>130</b>, the first controller can further detect a state (e.g., functional, fault) of the system based on one or more dependencies. For example, the first controller can detect a state of the system based on: a state of the first controller; a state of the input(s); a timeout state of the second controller; a state of the second controller; timeout states of controllers in a set of monitored controllers within other safety modules; communicated content states of controllers in the set of monitored controllers; and/or a timeout state of the set of monitored controllers.</p><p id="p-0257" num="0256">In one implementation, the controller detects a state of the system based on a set of rules. In one example, the first controller can detect a functional state of the system in response to detecting functional states for every dependency (e.g., a state of the first controller; a state of the input(s); a timeout state of the second controller; a state of the second controller; timeout states of controllers in a set of monitored controllers within other safety modules; communicated content states of controllers in the set of monitored controllers; and/or a timeout state of the set of monitored controllers). In another example, the first controller can detect a fault state of the system in response to detecting a fault state of any dependency. In yet another example, the first controller can detect a functional state of the system in response to detecting a fault timeout state for one controller in the set of monitored controllers, and in response to detecting functional states for every other dependency.</p><p id="p-0258" num="0257">In one implementation, the first controller stores valid codewords (e.g., valid functional codeword, valid fault codeword) in memory representing a state of the system in memory. In one example, the first controller stores a valid functional codeword representing a functional state of the system in memory in response to detecting a functional state of the system. In another example, the first controller stores a valid fault codeword representing a fault state of the system in memory in response to detecting a fault state of the system.</p><p id="p-0259" num="0258">In one implementation, the first controller stores the valid codewords in the flash memory within the first controller. In one variation, the first controller stores the valid codewords in an external memory.</p><p id="p-0260" num="0259">In one variation, in Block S<b>130</b>, during an evaluation period after a monitoring period, the first controller outputs a safety message including a valid codeword representing a detected state of the system as described above. In one example, the first controller can output a safety message including the valid functional codeword representing a functional state of the system. In another example, the first controller can output a safety message including the valid fault codeword representing a fault state of the system.</p><p id="p-0261" num="0260">Therefore, the first controller can resolve a combination of multiple states into a single state indicator, thus streamlining communication and maintaining functional safety standards in large networks.</p><heading id="h-0036" level="1">14. Second Controller</heading><p id="p-0262" num="0261">In one implementation, the second controller performs Blocks S<b>110</b>, S<b>120</b>, S<b>122</b>, S<b>124</b>, S<b>126</b>, S<b>130</b>, S<b>140</b>, S<b>142</b> of the method S<b>100</b> in an analogous (e.g., similar, identical) manner as described above in connection with the first controller.</p><heading id="h-0037" level="1">15. Application Processor</heading><p id="p-0263" num="0262">Block S<b>150</b> recites receiving the first safety message and the third safety message; in response to detecting the fourth valid functional codeword in the first safety message and the eighth valid functional codeword in the third safety message, outputting a fifth safety message including a ninth valid functional codeword representing a functional state of the system; during a sixth time period after the fourth time period, at the application processor, receiving the second safety message and the fourth safety message; and in response to detecting the fourth valid fault codeword in the second safety message and the eighth valid functional codeword in the fourth safety message, outputting a sixth safety message including a ninth valid fault codeword representing a fault state of the system and characterized by a ninth minimum hamming distance from the ninth valid functional codeword.</p><p id="p-0264" num="0263">Generally, in Block S<b>150</b>, after an evaluation period the application processor: receives safety messages from the first controller and the second controller; concatenates safety messages from the first controller and/or the second controller into a concatenated safety message; and outputs a safety message (e.g., over a network to another safety module).</p><p id="p-0265" num="0264">In one implementation, the application processor: analyzes a first safety message from the first controller and a second safety message from the second controller; and outputs a new safety message based on a result of the analysis.</p><p id="p-0266" num="0265">In one implementation, the application processor outputs a safety message indicating a functional state in response to receiving: a first safety message indicating a functional state from the first controller; and a second safety message indicating a functional state from the second controller. For example, the application processor can output a safety message including valid functional codeword representing a functional state of the system in response to receiving: a first safety message indicating a functional state (e.g., valid functional codeword) from the first controller; and a second safety message indicating a functional state (e.g., valid functional codeword) from the second controller.</p><p id="p-0267" num="0266">In one variation, the application processor can output a safety message indicating a fault state in response to receiving: a first safety message indicating a functional state from the first controller; and a second safety message indicating a fault state from the second controller. For example, the application processor can output a safety message including valid fault codeword representing a fault state of the system in response to receiving: a first safety message indicating a functional state (e.g., valid functional codeword) from the first controller; and a second safety message indicating a fault state (e.g., valid fault codeword) from the second controller.</p><p id="p-0268" num="0267">In another variation, the application processor can output a safety message indicating a fault state in response to detecting non-receipt of a safety message from the first controller and/or the second controller within predefined time quanta. For example, the application processor can output a safety message including valid fault codeword representing a fault state of the system in response to: detecting non-receipt of a first safety message from the first controller within a first time quantum; or detecting non-receipt of a second safety message from the second controller within a second time quantum.</p><p id="p-0269" num="0268">In one implementation, the application processor implements the valid functional codeword representing a functional state of the system and the valid fault codeword representing a fault state of the system characterized by a minimum hamming distance (e.g., 4) from each other.</p><p id="p-0270" num="0269">In one implementation, the application processor: receives safety messages (e.g., over the network from another safety module); separates the information within the received safety messages into: a first safety message for the first controller; and a second safety message for the second controller; outputs the first safety message to the first controller; and outputs the second safety message to the second controller.</p><p id="p-0271" num="0270">The systems and methods described herein can be embodied and/or implemented at least in part as a machine configured to receive a computer-readable medium storing computer-readable instructions. The instructions can be executed by computer-executable components integrated with the application, applet, host, server, network, website, communication service, communication interface, hardware/firmware/software elements of a user computer or mobile device, wristband, smartphone, or any suitable combination thereof. Other systems and methods of the embodiment can be embodied and/or implemented at least in part as a machine configured to receive a computer-readable medium storing computer-readable instructions. The instructions can be executed by computer-executable components integrated by computer-executable components integrated with apparatuses and networks of the type described above. The computer-readable medium can be stored on any suitable computer readable media such as RAMs, ROMs, flash memory, EEPROMs, optical devices (CD or DVD), hard drives, floppy drives, or any suitable device. The computer-executable component can be a processor but any suitable dedicated hardware device can (alternatively or additionally) execute the instructions.</p><p id="p-0272" num="0271">As a person skilled in the art will recognize from the previous detailed description and from the figures and claims, modifications and changes can be made to the embodiments of the invention without departing from the scope of this invention as defined in the following claims.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>I claim:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A method comprising:<claim-text>at a first controller in a safety module coupled to a system, storing a first set of valid codewords comprising:<claim-text>a first valid functional codeword representing a functional state of a first subsystem of a first set of subsystems within the first controller;</claim-text><claim-text>a first valid fault codeword representing a fault state of the first subsystem and characterized by a first minimum hamming distance from the first valid functional codeword;</claim-text><claim-text>a second valid functional codeword representing a functional state of the first controller;</claim-text><claim-text>a second valid fault codeword representing a fault state of the first controller and characterized by a second minimum hamming distance from the second valid functional codeword;</claim-text><claim-text>a third valid functional codeword representing a functional state of a first input coupled to the system;</claim-text><claim-text>a third valid fault codeword representing a fault state of the first input and characterized by a third minimum hamming distance from the third valid functional codeword;</claim-text><claim-text>a fourth valid functional codeword representing a functional state of the system; and</claim-text><claim-text>a fourth valid fault codeword representing a fault state of the system and characterized by a fourth minimum hamming distance from the fourth valid functional codeword;</claim-text></claim-text><claim-text>during a first time period, at the first controller:<claim-text>in response to detecting functional operation of the first subsystem, storing the first valid functional codeword in a first memory; and</claim-text><claim-text>in response to detecting functional operation of the first input, storing the third valid functional codeword in a second memory;</claim-text></claim-text><claim-text>during a second time period following the first time period, at the first controller, in response to detecting a match between contents of the first memory and the first valid functional codeword, and in response to detecting functional operation of the first input, outputting a first safety message comprising the second valid functional codeword and the fourth valid functional codeword;</claim-text><claim-text>during a third time period following the second time period, at the first controller:<claim-text>in response to detecting functional operation of the first subsystem, storing the first valid functional codeword in the first memory; and</claim-text><claim-text>in response to detecting functional operation of the first input, storing the third valid functional codeword in the second memory; and</claim-text></claim-text><claim-text>during a fourth time period following the third time period, at the first controller, in response to detecting a mismatch between contents of the first memory and every codeword in the first set of valid codewords, outputting a second safety message comprising the second valid fault codeword and the fourth valid fault codeword.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>at a second controller in the safety module, storing a second set of valid codewords comprising:<claim-text>a fifth valid functional codeword representing a functional state of a second subsystem of a second set of subsystems within the second controller;</claim-text><claim-text>a fifth valid fault codeword representing a fault state of the second subsystem and characterized by a fifth minimum hamming distance from the fifth valid functional codeword;</claim-text><claim-text>a sixth valid functional codeword representing a functional state of the second controller;</claim-text><claim-text>a sixth valid fault codeword representing a fault state of the second controller and characterized by a sixth minimum hamming distance from the sixth valid functional codeword;</claim-text><claim-text>a seventh valid functional codeword representing a functional state of a second input coupled to the system;</claim-text><claim-text>a seventh valid fault codeword representing a fault state of the second input and characterized by a seventh minimum hamming distance from the seventh valid functional codeword;</claim-text><claim-text>an eighth valid functional codeword representing a functional state of the system; and</claim-text><claim-text>an eighth valid fault codeword representing a fault state of the system and characterized by an eighth minimum hamming distance from the eighth valid functional codeword;</claim-text></claim-text><claim-text>during the first time period, at the second controller:<claim-text>in response to detecting functional operation of the second subsystem, storing the fifth valid functional codeword in a third memory; and</claim-text><claim-text>in response to detecting functional operation of the second input, storing the seventh valid functional codeword in a fourth memory;</claim-text></claim-text><claim-text>during the second time period, at the second controller, in response to detecting a match between contents of the third memory and the fifth valid functional codeword, and in response to detecting functional operation of the second input, outputting a third safety message comprising the sixth valid functional codeword and the eighth valid functional codeword;</claim-text><claim-text>during the third time period, at the second controller:<claim-text>in response to detecting functional operation of the second subsystem, storing the fifth valid functional codeword in the third memory; and</claim-text><claim-text>in response to detecting functional operation of the second input, storing the seventh valid functional codeword in the fourth memory;</claim-text></claim-text><claim-text>during the fourth time period, at the second controller, in response to detecting a match between contents of the third memory and the fifth valid functional codeword, and in response to detecting functional operation of the second input, outputting a fourth safety message comprising the sixth valid functional codeword and the eighth valid functional codeword;</claim-text><claim-text>during a fifth time period following the second time period, at an application processor within the safety module:<claim-text>receiving the first safety message and the third safety message; and</claim-text><claim-text>in response to detecting the fourth valid functional codeword in the first safety message and the eighth valid functional codeword in the third safety message, outputting a fifth safety message comprising a ninth valid functional codeword representing a functional state of the system; and</claim-text></claim-text><claim-text>during a sixth time period following the fourth time period, at the application processor:<claim-text>receiving the second safety message and the fourth safety message; and</claim-text><claim-text>in response to detecting the fourth valid fault codeword in the second safety message and the eighth valid functional codeword in the fourth safety message, outputting a sixth safety message comprising a ninth valid fault codeword representing a fault state of the system and characterized by a ninth minimum hamming distance from the ninth valid functional codeword.</claim-text></claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>:<claim-text>wherein the first valid functional codeword represents a functional state of a first arithmetic logic unit within the first controller;</claim-text><claim-text>wherein the first valid fault codeword represents a fault state of the first arithmetic logic unit within the first controller and is characterized by a minimum hamming distance of 8 from the first valid functional codeword;</claim-text><claim-text>wherein the fifth valid functional codeword represents a functional state of a second arithmetic logic unit within the second controller and is characterized by a minimum hamming distance of 8 from the first valid functional codeword; and</claim-text><claim-text>wherein the fifth valid fault codeword represents a fault state of the second arithmetic logic unit within the second controller and is characterized by a minimum hamming distance of 8 from the first valid fault codeword and a minimum hamming distance of 8 from the fifth valid functional codeword.</claim-text></claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>at a second controller in the safety module, storing a second set of valid codewords comprising:<claim-text>a fifth valid functional codeword representing a functional state of a second subsystem of a second set of subsystems within the second controller;</claim-text><claim-text>a fifth valid fault codeword representing a fault state of the second subsystem and characterized by a fifth minimum hamming distance from the fifth valid functional codeword;</claim-text><claim-text>a sixth valid functional codeword representing a functional state of the second controller;</claim-text><claim-text>a sixth valid fault codeword representing a fault state of the second controller and characterized by a sixth minimum hamming distance from the sixth valid functional codeword;</claim-text><claim-text>a seventh valid functional codeword representing a functional state of a second input coupled to the system;</claim-text><claim-text>a seventh valid fault codeword representing a fault state of the second input and characterized by a seventh minimum hamming distance from the seventh valid functional codeword;</claim-text><claim-text>an eighth valid functional codeword representing a functional state of the system; and</claim-text><claim-text>an eighth valid fault codeword representing a fault state of the system and characterized by an eighth minimum hamming distance from the eighth valid functional codeword;</claim-text></claim-text><claim-text>during the first time period, at the second controller:<claim-text>in response to detecting functional operation of the second subsystem, storing the fifth valid functional codeword in a third memory; and</claim-text><claim-text>in response to detecting functional operation of the second input, storing the seventh valid functional codeword in a fourth memory;</claim-text></claim-text><claim-text>during the second time period, at the second controller, in response to detecting a match between contents of the third memory and the fifth valid functional codeword and in response to detecting functional operation of the second input, outputting a third safety message comprising the sixth valid functional codeword and the eighth valid functional codeword; and</claim-text><claim-text>during the first time period, at the first controller:<claim-text>querying an input register coupled to the second controller; and</claim-text><claim-text>detecting, in the input register, a fourth safety message comprising the sixth valid functional codeword from the second controller;</claim-text></claim-text><claim-text>wherein outputting, at the first controller during the second time period, the first safety message comprising the third valid functional codeword is further in response to detecting the fourth safety message in the input register within a first time quantum.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, further comprising, during a fifth time period following the second time period, at an application processor within the safety module:<claim-text>receiving the first safety message and the third safety message; and</claim-text><claim-text>in response to detecting the fourth valid functional codeword in the first safety message and the eighth valid functional codeword in the third safety message, outputting a fifth safety message comprising a ninth valid functional codeword representing a functional state of the system.</claim-text></claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, further comprising:<claim-text>at the first controller, storing the first set of valid codewords further comprising:<claim-text>a ninth valid functional codeword representing a functional timeout state of the second controller; and</claim-text><claim-text>a ninth valid fault codeword representing a fault timeout state of the second controller and characterized by a ninth minimum hamming distance from the ninth valid functional codeword; and</claim-text></claim-text><claim-text>during the first time period, at the first controller, in response to detecting the fourth safety message in the input register within the first time quantum, storing the ninth valid functional codeword in a fifth memory; and</claim-text><claim-text>wherein outputting, at the first controller during the second time period, the first safety message comprising the second valid functional codeword and the fourth valid functional codeword is further in response to detecting a match between contents of the fifth memory and the ninth valid functional codeword.</claim-text></claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>at a second controller in the safety module, storing a second set of valid codewords comprising:<claim-text>a fifth valid functional codeword representing a functional state of a second subsystem of a second set of subsystems within the second controller;</claim-text><claim-text>a fifth valid fault codeword representing a fault state of the second subsystem and characterized by a fifth minimum hamming distance from the fifth valid functional codeword;</claim-text><claim-text>a sixth valid functional codeword representing a functional state of the second controller;</claim-text><claim-text>a sixth valid fault codeword representing a fault state of the second controller and characterized by a sixth minimum hamming distance from the sixth valid functional codeword;</claim-text><claim-text>a seventh valid functional codeword representing a functional state of a second input coupled to the system;</claim-text><claim-text>a seventh valid fault codeword representing a fault state of the second input and characterized by a seventh minimum hamming distance from the seventh valid functional codeword;</claim-text><claim-text>an eighth valid functional codeword representing a functional state of the system;</claim-text><claim-text>an eighth valid fault codeword representing a fault state of the system and characterized by an eighth minimum hamming distance from the eighth valid functional codeword;</claim-text><claim-text>a ninth valid functional codeword representing a functional timeout state of the first controller; and</claim-text><claim-text>a ninth valid fault codeword representing a fault timeout state of the first controller and characterized by a ninth minimum hamming distance from the ninth valid functional codeword;</claim-text></claim-text><claim-text>during the first time period, at the second controller:<claim-text>in response to detecting functional operation of the second subsystem, storing the fifth valid functional codeword in a third memory;</claim-text><claim-text>in response to detecting functional operation of the second input, storing the seventh valid functional codeword in a fourth memory;</claim-text><claim-text>querying an input register coupled to the first controller; and</claim-text><claim-text>in response to detecting non-receipt of a third safety message in the input register within a first time quantum, storing the ninth valid fault codeword in a fifth memory; and</claim-text></claim-text><claim-text>during the second time period, at the second controller, in response to detecting a match between contents of the fifth memory and the ninth valid fault codeword, outputting a fourth safety message comprising the eighth valid fault codeword.</claim-text></claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>at the first controller, storing the first set of valid codewords further comprising:<claim-text>a fifth valid functional codeword representing a functional state of a second subsystem of the first set of subsystems within the first controller and characterized by a minimum hamming distance of 4 from the first valid functional codeword; and</claim-text><claim-text>a fifth valid fault codeword representing a fault state of the second subsystem and characterized by a minimum hamming distance of 4 from the first valid fault codeword and a minimum hamming distance of 8 from the fifth valid functional codeword;</claim-text></claim-text><claim-text>during the first time period, at the first controller, in response to detecting functional operation of the second subsystem, storing the fifth valid functional codeword in a third memory; and</claim-text><claim-text>wherein outputting, at the first processor during the second time period, the first safety message comprising the second valid functional codeword and the fourth valid functional codeword is further in response to detecting contents of the third memory matches the fifth valid functional codeword.</claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>:<claim-text>wherein the first valid functional codeword and the first valid fault codeword each exhibit a length of two bytes;</claim-text><claim-text>wherein the second valid functional codeword, the second valid fault codeword, the third valid functional codeword, the third valid fault codeword, the fourth valid functional codeword, and the fourth valid fault codeword each exhibit a length of one byte;</claim-text><claim-text>wherein the first minimum hamming distance is 8;</claim-text><claim-text>wherein the second minimum hamming distance is 4;</claim-text><claim-text>wherein the third minimum hamming distance is 4; and</claim-text><claim-text>wherein the fourth minimum hamming distance is 4.</claim-text></claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein storing, at the first controller, the first set of valid codewords comprises:<claim-text>storing a bit pattern of &#x201c;11011101010101&#x201d; as the first valid functional codeword; and</claim-text><claim-text>storing a bit pattern of &#x201c;1000001000101000&#x201d; as the first valid fault codeword.</claim-text></claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. A method comprising:<claim-text>at a first controller in a safety module coupled to a system, storing a first set of valid codewords comprising:<claim-text>a first valid functional codeword representing a functional state of a first subsystem of a first set of subsystems within the first controller;</claim-text><claim-text>a first valid fault codeword representing a fault state of the first subsystem and characterized by a first minimum hamming distance from the first valid functional codeword;</claim-text><claim-text>a second valid functional codeword representing a functional state of the first controller;</claim-text><claim-text>a second valid fault codeword representing a fault state of the first controller and characterized by a second minimum hamming distance from the second valid functional codeword;</claim-text><claim-text>a third valid functional codeword representing a functional state of a first input coupled to the system;</claim-text><claim-text>a third valid fault codeword representing a fault state of the first input and characterized by a third minimum hamming distance from the third valid functional codeword;</claim-text><claim-text>a fourth valid functional codeword representing a functional state of a second controller within the safety module;</claim-text><claim-text>a fourth valid fault codeword representing a fault state of the second controller and characterized by a sixth minimum hamming distance from the fourth valid functional codeword;</claim-text><claim-text>a fifth valid functional codeword representing a functional timeout state of the second controller;</claim-text><claim-text>a fifth valid fault codeword representing a fault timeout state of the second controller and characterized by a fifth minimum hamming distance from the fourth valid functional codeword;</claim-text><claim-text>a sixth valid functional codeword representing a functional state of the system; and</claim-text><claim-text>a sixth valid fault codeword representing a fault state of the system and characterized by a sixth minimum hamming distance from the sixth valid functional codeword;</claim-text></claim-text><claim-text>during a first time period, at the first controller:<claim-text>in response to detecting functional operation of the first subsystem, storing the first valid functional codeword in a first memory;</claim-text><claim-text>in response to detecting functional operation of the first input, storing the third valid functional codeword in a second memory;</claim-text><claim-text>querying an input register coupled to the second controller;</claim-text><claim-text>detecting, in the input register, a first safety message comprising the fourth valid functional codeword from the second controller; and</claim-text><claim-text>in response to detecting the first safety message in the input register within a first time quantum, storing the fifth valid functional codeword in a third memory;</claim-text></claim-text><claim-text>during a second time period following the first time period, at the first controller, in response to detecting a match between contents of the first memory and the first valid functional codeword, in response to detecting a match between contents of the third memory and the fifth valid functional codeword, and in response to detecting functional operation of the first input, outputting a second safety message comprising the second valid functional codeword and the sixth valid functional codeword;</claim-text><claim-text>during a third time period following the second time period, at the first controller:<claim-text>in response to detecting functional operation of the first subsystem, storing the first valid functional codeword in the first memory;</claim-text><claim-text>in response to detecting functional operation of the first input, storing the third valid functional codeword in the second memory;</claim-text><claim-text>querying the input register; and</claim-text><claim-text>in response to detecting non-receipt of the third safety message in the input register within a second time quantum, storing the fifth valid fault codeword in a third memory; and</claim-text></claim-text><claim-text>during a fourth time period following the third time period, at the first controller, in response to detecting a match between contents of the first memory and the first valid functional codeword, and in response to detecting a match between contents of the third memory and the fifth valid fault codeword, outputting a fourth safety message comprising the second valid functional codeword and the sixth valid fault codeword.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, further comprising:<claim-text>during a fifth time period following the second time period and prior to the third time period, at the first controller:<claim-text>in response to detecting functional operation of the first subsystem, storing the first valid functional codeword in the first memory;</claim-text><claim-text>querying the input register coupled to the second controller; and</claim-text><claim-text>in response to detecting a fifth safety message from the second controller in the input register within a third time quantum, storing the fifth valid functional codeword in the third memory; and</claim-text></claim-text><claim-text>during a sixth time period following the fifth time period and prior to the third time period, at the first controller, in response to detecting a match between contents of the first memory and the first valid functional codeword, and in response to detecting a mismatch between contents of the third memory and every codeword in the first set of valid codewords, outputting a sixth safety message comprising the second valid functional codeword and the sixth valid fault codeword.</claim-text></claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, further comprising:<claim-text>at the first controller, storing the first set of valid codewords further comprising:<claim-text>a seventh valid functional codeword representing a functional timeout state of a third controller within a second safety module coupled to the system; and</claim-text><claim-text>a seventh valid fault codeword representing a fault timeout state of the third controller and characterized by a minimum hamming distance of 8 from the seventh valid functional codeword;</claim-text></claim-text><claim-text>during the first time period, at the first controller, in response to detecting receipt of a fifth safety message from the third controller within a third time quantum, storing the seventh valid functional codeword in a fourth memory; and</claim-text><claim-text>during the second time period, at the first controller, outputting the second safety message comprising the second valid functional codeword and the sixth valid functional codeword further in response to detecting a match between contents of the fourth memory and the seventh valid functional codeword.</claim-text></claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, further comprising:<claim-text>at the first controller, storing the first set of valid codewords further comprising:<claim-text>a seventh valid functional codeword representing a functional timeout state of a third controller within a second safety module coupled to the system;</claim-text><claim-text>a seventh valid fault codeword representing a fault timeout state of the third controller and characterized by a minimum hamming distance of 8 from the seventh valid functional codeword;</claim-text><claim-text>an eighth valid functional codeword representing a functional timeout state of a fourth controller within a third safety module coupled to the system and characterized by a minimum hamming distance of 4 from the seventh valid function codeword;</claim-text><claim-text>an eighth valid fault codeword representing a fault timeout state of the fourth controller and characterized by a minimum hamming distance of 4 from the seventh valid fault codeword and a minimum hamming distance of 8 from the eighth valid functional codeword;</claim-text><claim-text>a ninth valid functional codeword representing a functional timeout state of a set of monitored controllers comprising the third controller and the fourth controller; and</claim-text><claim-text>a ninth valid fault codeword representing a fault timeout state of the set of monitored controllers and characterized by a minimum hamming distance of 8 from the ninth valid functional codeword;</claim-text></claim-text><claim-text>during the first time period, at the first controller:<claim-text>in response to detecting receipt of a fifth safety message from the third controller within a third time quantum, storing the seventh valid functional codeword in a fourth memory; and</claim-text><claim-text>in response to detecting non-receipt of a sixth safety message from the fourth controller within a fourth time quantum, storing the eighth valid fault codeword in a fifth memory;</claim-text></claim-text><claim-text>wherein outputting, at the first controller during the second period of time, the second safety message comprises outputting the second safety message comprising the second valid functional codeword, the sixth valid functional codeword, and the ninth valid fault codeword in response to detecting a match between contents of the first memory and the first valid functional codeword, in response to detecting a match between contents of the third memory and the fifth valid functional codeword, in response to detecting functional operation of the first input, in response to detecting a match between contents of the fourth memory and the seventh valid functional codeword, and in response to detecting a match between the fifth memory and the eighth valid fault codeword.</claim-text></claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref>:<claim-text>wherein the first valid functional codeword comprises an upper byte and a lower byte, and</claim-text><claim-text>wherein the upper byte and the lower byte are inverse nibble values to each other.</claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref>:<claim-text>wherein the first valid functional codeword is characterized by a hamming distance of 4 from the second valid functional codeword and a hamming distance of 4 from the second valid fault codeword; and</claim-text><claim-text>wherein the first valid fault codeword is characterized by a hamming distance of 4 from the second valid functional codeword, a hamming distance of 4 from the second valid fault codeword, and a hamming distance of 8 from the first valid functional codeword.</claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein storing, at the first controller, the first set of valid codewords comprises storing the second valid fault codeword characterized by a minimum hamming distance of 4 from the second valid functional codeword.</claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein storing, at the first controller, the first set of valid codewords comprises:<claim-text>storing the first valid functional codeword representing a functional state of an arithmetic logic unit within the first controller;</claim-text><claim-text>storing the first valid fault codeword representing a fault state of the arithmetic logic unit and characterized by a minimum hamming distance of 8 from the first valid functional codeword;</claim-text><claim-text>storing a seventh valid functional codeword representing a functional state a flash memory within the first controller and characterized by a minimum hamming distance of 4 from the first valid functional codeword and a minimum hamming distance of 4 from the first valid fault codeword;</claim-text><claim-text>storing a seventh valid fault codeword representing a fault state the flash memory and characterized by a minimum hamming distance of 4 from the first valid functional codeword, a minimum hamming distance of 4 from the first valid fault codeword, and a minimum hamming distance of 8 from the seventh valid functional codeword;</claim-text><claim-text>storing an eighth valid functional codeword representing a functional state a stack overflow safety mechanism within the first controller and characterized by a minimum hamming distance of 4 from the first valid functional codeword and a minimum hamming distance of 4 from the seventh valid functional codeword; and</claim-text><claim-text>storing an eighth valid fault codeword representing a fault state the stack overflow safety mechanism and characterized by a minimum hamming distance of 4 from the first valid fault codeword, a minimum hamming distance of 4 from the seventh valid fault codeword, and a minimum hamming distance of 8 from the eighth valid functional codeword.</claim-text></claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The method of <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein storing, at the first controller, the first set of valid codewords comprises:<claim-text>storing a bit pattern of &#x201c;1101111011101101&#x201d; as the first valid functional codeword;</claim-text><claim-text>storing a bit pattern of &#x201c;10000000001000&#x201d; as the first valid fault codeword;</claim-text><claim-text>storing a bit pattern of &#x201c;1110110101011110&#x201d; as the seventh valid functional codeword;</claim-text><claim-text>storing a bit pattern of &#x201c;0010100010000010&#x201d; as the seventh valid fault codeword;</claim-text><claim-text>storing a bit pattern of &#x201c;11110010111110&#x201d; as the eighth valid functional codeword; and</claim-text><claim-text>storing a bit pattern of &#x201c;10101011101&#x201d; as the eighth valid fault codeword.</claim-text></claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. A method comprising:<claim-text>at a first controller in a safety module coupled to a system, storing a first set of valid codewords comprising:<claim-text>a first valid functional codeword representing a functional state of a first subsystem of a first set of subsystems within the first controller;</claim-text><claim-text>a first valid fault codeword representing a fault state of the first subsystem and characterized by a first minimum hamming distance from the first valid functional codeword;</claim-text><claim-text>a second valid functional codeword representing a functional state of the first controller; and</claim-text><claim-text>a second valid fault codeword representing a fault state of the first controller and characterized by a second minimum hamming distance from the second valid functional codeword;</claim-text></claim-text><claim-text>during a first time period, at the first controller, in response to detecting functional operation of the first subsystem, storing the first valid functional codeword in a first memory;</claim-text><claim-text>during a second time period following the first time period, at the first controller, in response to detecting a match between contents of the first memory and the first valid functional codeword, outputting a first safety message comprising the second valid functional codeword;</claim-text><claim-text>during a third time period following the second time period, at the first controller, in response to detecting functional operation of the first subsystem, storing the first valid functional codeword in the first memory; and</claim-text><claim-text>during a fourth time period following the third time period, at the first controller, in response to detecting a mismatch between contents of the first memory and every codeword in the first set of valid codewords, outputting a second safety message comprising the second valid fault codeword.</claim-text></claim-text></claim></claims></us-patent-application>