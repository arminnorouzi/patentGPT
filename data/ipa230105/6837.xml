<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230006838A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230006838</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17941972</doc-number><date>20220909</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>L</subclass><main-group>9</main-group><subgroup>32</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>L</subclass><main-group>9</main-group><subgroup>08</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>54</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>L</subclass><main-group>9</main-group><subgroup>30</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>L</subclass><main-group>9</main-group><subgroup>3247</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>L</subclass><main-group>9</main-group><subgroup>085</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>54</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>L</subclass><main-group>9</main-group><subgroup>30</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>L</subclass><main-group>2209</main-group><subgroup>56</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>L</subclass><main-group>2209</main-group><subgroup>46</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20220501</date></cpc-version-indicator><section>H</section><class>04</class><subclass>L</subclass><main-group>9</main-group><subgroup>50</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">TECHNIQUES FOR SECURING APPLICATION PROGRAMMING INTERFACE REQUESTS USING MULTI-PARTY DIGITAL SIGNATURES</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>16404218</doc-number><date>20190506</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11444779</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17941972</doc-number></document-id></child-doc></relation></continuation><us-provisional-application><document-id><country>US</country><doc-number>62713834</doc-number><date>20180802</date></document-id></us-provisional-application></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>PAYPAL, INC.</orgname><address><city>San Jose</city><state>CA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Yadlin</last-name><first-name>Dan</first-name><address><city>Tel-Aviv</city><country>IL</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Riva</last-name><first-name>Ben</first-name><address><city>Givatayim</city><country>IL</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>Navon</last-name><first-name>Alon</first-name><address><city>Tel-Aviv</city><country>IL</country></address></addressbook></inventor><inventor sequence="03" designation="us-only"><addressbook><last-name>Pachmanov</last-name><first-name>Lev</first-name><address><city>Haifa</city><country>IL</country></address></addressbook></inventor><inventor sequence="04" designation="us-only"><addressbook><last-name>Katz</last-name><first-name>Jonathan</first-name><address><city>Silver Spring</city><state>MD</state><country>US</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A system and method for securing application programming interface (API) requests using multi-party digital signatures. The method includes generating, by a first system, at least one first secret share of a plurality of secret shares based on an API secret, wherein the plurality of secret shares includes the at least one first secret share and at least one second secret share, wherein the at least one second secret share is generated by at least one second system; and signing, by the first system, an API request using the at least one first secret share, wherein the API request is further signed by the at least one second system using the at least one second secret share, wherein the API request is signed without revealing any of the at least one first secret share to the at least one second system and without revealing any of the at least one second secret share to the first system.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="76.45mm" wi="158.75mm" file="US20230006838A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="109.73mm" wi="112.35mm" file="US20230006838A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="111.42mm" wi="166.45mm" file="US20230006838A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="155.36mm" wi="149.44mm" file="US20230006838A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="109.73mm" wi="131.57mm" file="US20230006838A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading><p id="p-0002" num="0001">This application is a continuation of U.S. patent application Ser. No. 16/404,218, filed May 6, 2019, which claims the benefit of U.S. Provisional Application No. 62/713,834, filed Aug. 2, 2018, the contents of which are hereby incorporated by reference in their entirety.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">TECHNICAL FIELD</heading><p id="p-0003" num="0002">The present disclosure relates generally to application programming interface requests, and more specifically to securing application programming interface requests.</p><heading id="h-0003" level="1">BACKGROUND</heading><p id="p-0004" num="0003">An application programming interface (API) is a set of definitions, protocols, and tools used for allowing communication among applications. Using APIs simplifies programming by only exposing objects and actions needed by application developers. Calls to APIs are referred to as API requests. These API requests may be used to obtain access to target services and, therefore, can present cyber security threats related to unauthorized access of data.</p><p id="p-0005" num="0004">One existing solution for securing APIs includes using a symmetric key (API secret) to validate a requestor program that sends an API request and by forcing the requestor program to sign API requests. A digital signature is a set of algorithms and encryption protocols utilized to verify the authenticity of a message contents. Each entity's identity is determined by an API token (sometimes referred to as an API key). When the requestor program asks a program of the service provider to receive access to the API, the service provider program issues the API token and the API secret and sends them to the requestor program.</p><p id="p-0006" num="0005">Once the API secret and tokens have been issued, the requestor program can use them as long as they are valid. More specifically, the API secret may be used to sign a request by creating a hash of the content of the API request that can only be validated by the system hosting the requested operation. The API token is exposed in the request. This is usually done through a secure channel.</p><p id="p-0007" num="0006">By identifying the requestor program, use of the API can be tracked and access can be controlled accordingly by the API service provider. For example, actions may be restricted based on the source of the request (e.g., based on a level of access permitted for a particular user using the requesting program), or sources issuing an unusually high number of requests may be blocked. By using a secret to sign the request, the request may be authenticated by the service provider to validate that the requestor program is authentic.</p><p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. <b>1</b></figref> shows an example network diagram <b>100</b> utilized to describe an existing solution for managing API requests. In the example block diagram <b>100</b>, an API service requestor device <b>110</b> communicates with an API service provider device <b>120</b> in order to access services delivered by the API service provider device <b>120</b>. The API service provider device <b>120</b> may further communicate with one or more data stores <b>130</b> including data used for providing such operations or other services.</p><p id="p-0009" num="0008">The API service requestor device <b>110</b> is a device executing a requestor program <b>115</b> that is configured to access API services delivered by the API service provider device <b>120</b>. The API services utilize APIs to facilitate communications. The API services are secured by requiring the API service requestor device <b>110</b> to sign API requests. The API service requestor device <b>110</b> and the API service provider device <b>120</b> may communicate via one or more networks (not shown).</p><p id="p-0010" num="0009">Although using cryptographic techniques present some benefits in securing API access, insecurities related to the tokens and secrets used for such cryptographic techniques may allow malicious entities who have successfully infiltrated the requestor's machine to receive unauthorized access through APIs. In particular, when a system storing the API token and API secret is breached. An adversary gaining access to the token and secret can issue a call, and the server will have no way of differentiating the attacker from the authenticated legitimate user. The potential amount of exposure has increased due to cross-entity API services such as SaaS service providers.</p><p id="p-0011" num="0010">It would therefore be advantageous to provide a solution that would overcome the challenges noted above.</p><heading id="h-0004" level="1">SUMMARY</heading><p id="p-0012" num="0011">A summary of several example embodiments of the disclosure follows. This summary is provided for the convenience of the reader to provide a basic understanding of such embodiments and does not wholly define the breadth of the disclosure. This summary is not an extensive overview of all contemplated embodiments, and is intended to neither identify key or critical elements of all embodiments nor to delineate the scope of any or all aspects. Its sole purpose is to present some concepts of one or more embodiments in a simplified form as a prelude to the more detailed description that is presented later. For convenience, the term &#x201c;some embodiments&#x201d; or &#x201c;certain embodiments&#x201d; may be used herein to refer to a single embodiment or multiple embodiments of the disclosure.</p><p id="p-0013" num="0012">Certain embodiments disclosed herein include a method for securing application programming interface (API) requests using multi-party digital signatures. The method comprises generating, by a first system, at least one first secret share of a plurality of secret shares based on an API secret, wherein the plurality of secret shares includes the at least one first secret share and at least one second secret share, wherein the at least one second secret share is generated by at least one second system; and signing, by the first system, an API request using the at least one first secret share, wherein the API request is further signed by the at least one second system using the at least one second secret share, wherein the API request is signed without revealing any of the at least one first secret share to the at least one second system and without revealing any of the at least one second secret share to the first system.</p><p id="p-0014" num="0013">Certain embodiments disclosed herein also include a non-transitory computer readable medium having stored thereon causing a processing circuitry to execute a process, the process comprising: generating, by a first system, at least one first secret share of a plurality of secret shares based on an API secret, wherein the plurality of secret shares includes the at least one first secret share and at least one second secret share, wherein the at least one second secret share is generated by at least one second system; and signing, by the first system, an API request using the at least one first secret share, wherein the API request is further signed by the at least one second system using the at least one second secret share, wherein the API request is signed without revealing any of the at least one first secret share to the at least one second system and without revealing any of the at least one second secret share to the first system.</p><p id="p-0015" num="0014">Certain embodiments disclosed herein also include a system for securing application programming interface (API) requests, comprising: a processing circuitry; and a memory, the memory containing instructions that, when executed by the processing circuitry, configure the system to: generate at least one first secret share of a plurality of secret shares based on an API secret, wherein the system is a first system, wherein the plurality of secret shares includes the at least one first secret share and at least one second secret share, wherein the at least one second secret share is generated by at least one second system; and sign an API request using the at least one first secret share, wherein the API request is further signed by the at least one second system using the at least one second secret share, wherein the API request is signed without revealing any of the at least one first secret share to the at least one second system and without revealing any of the at least one second secret share to the first system.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0005" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0016" num="0015">The subject matter disclosed herein and other objects, features, and advantages of the disclosed embodiments will be apparent from the following detailed description taken in conjunction with the accompanying drawings.</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a network diagram utilized to describe an existing solution for managing API requests.</p><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a network diagram utilized to describe an example implementation for securing API requests via multi-party computation according to an embodiment.</p><p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a flowchart illustrating a method for securing API requests via multi-party computation according to an embodiment.</p><p id="p-0020" num="0019"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a block diagram of a system for securing API requests via multi-party computation according to an embodiment.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0006" level="1">DETAILED DESCRIPTION</heading><p id="p-0021" num="0020">It is important to note that the embodiments disclosed herein are only examples of the many advantageous uses of the innovative teachings herein. In general, statements made in the specification of the present application do not necessarily limit any of the various claimed embodiments. Moreover, some statements may apply to some inventive features but not to others. In general, unless otherwise indicated, singular elements may be in plural and vice versa with no loss of generality. In the drawings, like numerals refer to like parts through several views.</p><p id="p-0022" num="0021">The security challenges related to application programming interface (API) requests warrant new solutions for securing APIs by the requesting party. Insecurities related to API secrets present challenges for entities seeking to receive services using APIs. Lost or stolen API secrets may allow unauthorized access to the API offered by a service provider without the service provider being able to identify that the requesting party has been breached. This may lead to data leak or to unauthorized financial operations carried out by the attacker depending on the service provided through APIs by the service provider. Although existing solutions provide some techniques for storing secrets securely, such solutions still maintain complete copies of those secrets that, if compromised, can result in unauthorized access. Additionally, APIs are intended to be used by machines who automatically issue requests. Those machines almost always possess full access to the API token and API secret.</p><p id="p-0023" num="0022">The various disclosed embodiments provide techniques for securing API requests by using multi-party digital signatures to sign API requests. In particular, the disclosed embodiments address the above-noted challenges by creating API secrets used for signing API requests in a distributed way through two or more portions (hereinafter referred to as &#x201c;shares&#x201d;) and using the distributed shares by systems of two or more different entities, or parties, to sign an API request. Each system is owned by a different entity. An interactive protocol (e.g., Secure Multiparty Computation or Threshold Digital signature) is run between the systems. Each system generates and stores one or more shares such that the shares collectively enable the signing of an API request as if it was signed by the corresponding API secret but cannot be used for determining the API secret while maintained separately. The API secret never materializes in any of the protocols.</p><p id="p-0024" num="0023">One or more of the systems having the distributed shares determines whether an API request meets a signing policy before the shares are used to sign the API request. A system that validated the API request with respect to the signing policy engages in the signing protocol to sign the API request when the API request has been validated. At least some of the shares are used to sign the API request such that a system lacking the necessary number of shares is unable to sign the API request in accordance with the signing policy. The signing policy is a security policy that aligns the number of users approving the API request to the risk the API request might pose. The protocol only works if a minimum number of shares of the distributed API secret are present.</p><p id="p-0025" num="0024">In an example implementation, an API secret that is generated by an API service provider is to be protected. The API secret is sent to an API service requestor device as part of a service utilizing APIs. The secret is split, in the API service requestor device, into two shares and then one of the shares is securely sent to one or more other parties such that the secret is split between systems of two or more parties. Each system secures its corresponding share. The two or more parties can be, for example, an API service requestor party and multi-party computation (MPC) service provider party (i.e., an entity that owns or operates a MPC system that is configured to secure API requests using MPC as described herein). The MPC system validates an API request by determining whether the signing policy is met. When the API request is validated, the MPC system will engage in a MPC signing protocol using its share with the other parties. The signing policy requires at least a portion of the shares and may be configured by a system of the API service requestor. The share stored in each system may be rotated every hour or day such that shares are only valid for a limited period of time and the likelihood of collecting all shares before the next rotation is significantly reduced. The share rotation is also performed through an interactive multiparty computation protocol.</p><p id="p-0026" num="0025">MPC allows parties to jointly compute a function over their respective inputs while keeping those inputs private. Thus, utilizing MPC for the signing protocol allows for utilizing the shares secretly and independently by each participating party while ensuring that the shares collectively enable signing transactions without revealing the API secret or shares by one party to the others. Throughout this process, no portion of the shares of one party is revealed to the other party.</p><p id="p-0027" num="0026">In another example implementation, the MPC service provider can have 3 shares each stored on a different cloud IaaS provider, while the API service requestor can have 2 shares, one stored on employee devices and one stored on a backend. The number of shares can be higher than two and the number of required shares to sign can be lower than the number of shares.</p><p id="p-0028" num="0027">In an embodiment, multiple sets of shares may be created by engaging a protocol to re-split the original API secret for a total of two or more times being split. Each set of shares includes n shares (where n is an integer value greater than or equal to 2) and requires k out of n of its respective shares to be complete for signing purposes (where k is an integer value that with 1&#x3c;k&#x3c;=n).</p><p id="p-0029" num="0028">Different sets of shares may be distributed differently. For example, each set may be assigned to a different employee or other user such that a user device of each employee stores a different share from that of other employees and a corresponding service provider system stores a different share for each employee. Further, if a share of a first set of shares is lost (e.g., a share assigned to a first employee is deleted or corrupted, etc.), new shares may be created using other existing shares. This allows for recovery of the API secret without actually reconstructing or generating the API secret. In a further embodiment, the shares held by the API service requestor cannot be used to reconstruct the API secret without the shares safeguarded by the MPC system.</p><p id="p-0030" num="0029">The disclosed embodiments may include various protocols utilized to facilitate the functions described herein. In an example implementation, securing the API secrets includes splitting the API secret created by the API service provider into several shares, a digital signature protocol, and a share addition protocol. The share addition protocol allows for creating new shares based on existing shares and may be utilized to add a new user or to rotate shares.</p><p id="p-0031" num="0030">The disclosed embodiments reduce the complexity as compared to utilizing multiple API secrets while being more secure than use of a single API secret. In particular, theft of a single share or the compromising of only one system storing shares will not lead to unauthorized signing or exposure of API secrets. Further, the disclosed embodiments provide a fast and flexible solution that may be delivered as a software only cloud service, thereby allowing for efficient scaling and auditing. The service may be provided with minimal interference with user networks and systems.</p><p id="p-0032" num="0031">In addition to the aforementioned advantages, shares may be rotated among entities to prevent collecting API secrets via the shares. Shares may be rotated periodically, for example every hour or day. The shares may be stored on separate networks, thereby drastically decreasing the likelihood of simultaneously infiltrating the networks to retrieve all shares. Shares may be rotated without needing to change the latent API secret. Additionally, API secrets may be split using arbitrarily complex schemes to increase security.</p><p id="p-0033" num="0032">Additionally, in some embodiments, the signing policy may define additional requirements for signing API requests. The additional requirements may differ, for example, depending on a requested operation (i.e., some operations may require more stringent requirements), a type of the operation, time of day, and the like. Such requirements may require approval by other entities (e.g., managers, upper management, administrators, etc.), particular authentication methods (e.g., password, biometric authentication, multi-factor authentication, device certificate, one-time password, etc.), both, and the like. The additional requirements provide a flexible policy scheme that increases security of API requests and minimizes harm caused by malicious entities. For example, an attacker that gains access to an employee's device may be unable to access operations that expose sensitive data because the attacker cannot gain approval from a manager or administrator. The signing policy may also ensure authenticity of the request using multi-factor authentication, for example by sending an email to the requesting user to validate the request.</p><p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. <b>2</b></figref> shows an example network diagram <b>200</b> utilized to describe various disclosed embodiments. In the example network diagram <b>200</b>, an application programming interface (API) service requestor device <b>210</b> accesses operations of services via an API service provider device <b>230</b>. To this end, the API service requestor device <b>210</b> communicates with a multi-party computation (MPC) system <b>220</b> to distribute shares of an API secret used for signing API requests to the API service provider device <b>230</b>.</p><p id="p-0035" num="0034">In an example implementation, the API service requestor device <b>210</b> may communicate with the MPC system <b>220</b> and the MPC system <b>220</b> may communicate with the API service provider device <b>230</b> over one or more networks that may include, but are not limited to, a wireless, cellular or wired network, a local area network (LAN), a wide area network (WAN), a metro area network (MAN), the Internet, the worldwide web (WWW), similar networks, and any combinations thereof.</p><p id="p-0036" num="0035">The API service requestor device <b>210</b> may be, but is not limited to, a server; a user device such as a personal computer, a laptop, a tablet computer, a smartphone, a wearable computing device; or any other device configured to make and sign API requests in accordance with the embodiments disclosed herein. The API service requestor device <b>210</b> may be deployed in a local network (not shown) such as, for example, a corporate network of a company.</p><p id="p-0037" num="0036">The API service provider device <b>230</b> is a server or other system hosting one or more applications and utilizing one or more APIs to deliver services or functions of the hosted applications. In an example implementation, the API service provider device <b>230</b>, the MPC system <b>220</b>, or both, are deployed in a cloud computing platform. Thus, the API service provider device <b>230</b> may be utilized for providing cloud computing services.</p><p id="p-0038" num="0037">The APIs used by the API service provider device <b>230</b> include definitions required for accessing services provided by applications hosted thereon. Such definitions may include, but are not limited to, routines, data structures, object classes variables, remote calls, and the like. The APIs are used to communicate with external systems (e.g., the API service requestor device <b>210</b>) to receive and respond to requests for operations or other services hosted by the API service provider device <b>230</b>. The API service provider device <b>230</b> may further communicate with one or more data stores <b>240</b> including data used for providing such operations or other services.</p><p id="p-0039" num="0038">The API service requestor device <b>210</b> is configured to create and store a first share of an API secret used for signing API requests to the API service provider device <b>230</b>. The API service requestor device <b>210</b> may include a software development kit (SDK). In some implementations, the API service requestor device <b>210</b> is configured to perform an authentication to verify that a user operating the API service requestor device <b>210</b> is authorized to make particular API requests.</p><p id="p-0040" num="0039">Once the user is authenticated, the API service requestor device <b>210</b> communicates with the MPC system <b>220</b>. To this end, an interactive protocol is run between the API service requestor device <b>210</b> and the MPC system <b>220</b>. During this process, the API secret is not exposed over the networks used for communication. Additionally, an insider having access to a network (not shown) in which the API service requestor device <b>210</b> is deployed can at best access shares stored on systems in that network but not those shares stored on external systems and, specifically, on the MPC system <b>220</b>.</p><p id="p-0041" num="0040">In an embodiment, the MPC system <b>220</b> is configured with a policy engine (PE) <b>222</b> and a share manager (SM) <b>224</b>. The policy engine <b>222</b> is configured to determine whether a signing policy is met at least based on shares stored by the API service requestor device <b>210</b> and by the MPC system <b>220</b>. The policy engine <b>222</b> may further be configured to determine whether the signing policy is met based on one or more additional requirements. The additional requirements may indicate other entities (not shown) that must approve an API request, required authentication protocols (e.g., multi-factor authentication, use of particular devices, biometric authentication, combinations thereof, etc.), both, and the like.</p><p id="p-0042" num="0041">The share manager <b>224</b> is configured to create shares. When the policy engine <b>222</b> determines that an API request is authenticated and should therefore be signed, it notifies the share manager <b>224</b> to participate in the MPC. The MPC may fail if the other parties (e.g., the API service requestor device <b>210</b>) fail to deliver their shares. When sufficient shares are present, the MPC system <b>220</b> signs the API request via the MPC interactive protocol using its respective shares.</p><p id="p-0043" num="0042">In an embodiment, each share that is held by a party is not revealed to the other party or parties, and is not revealed to any external third parties. To this end, each share generated by one system is only exposed to that system and is not sent, shared, or otherwise revealed to another system. In a further embodiment, no portion of any share is exposed to any parties that the entire share is not exposed to (i.e., 0% of the share is exposed aside from being exposed to the system that generated the share), thereby ensuring that shares cannot be reconstructed based on exposed pieces. Since shares are only exposed to a single party, accessing only one party's shares will not allow a malicious entity to enable signing in accordance with the MPC signing protocol.</p><p id="p-0044" num="0043">In an embodiment, further security measures may be provided to prevent malicious exposure of shares. To this end, each system generating a share may be configured such that they cannot send or otherwise provide shares (or portions thereof) to any external system (i.e., a system other than the system that generated the share). In other words, even if a malicious entity attempts to trick or otherwise cause a system to improperly expose its share, the system cannot do so.</p><p id="p-0045" num="0044">The MPC system <b>220</b> may be, but is not limited to, a server or other system configured to perform various disclosed embodiments. Each of the API service requestor device <b>210</b> and the MPC system <b>220</b> may include, but is not limited to, a processing circuitry and a memory, the memory containing instructions that, when executed by the processing circuitry, configures the respective counterpart to perform a portion of the functions described herein. In particular, each portion includes at least generating one or more shares and using the respective shares to sign an API request. An example block diagram illustrating some components of the MPC system <b>220</b> is described further below with respect to <figref idref="DRAWINGS">FIG. <b>4</b></figref>.</p><p id="p-0046" num="0045">It should be noted that <figref idref="DRAWINGS">FIG. <b>2</b></figref> shows a single API service requestor device <b>210</b> and a single MPC system <b>220</b> merely for simplicity and without limiting the disclosed embodiments. Multiple API service requestor devices, MPC systems, or both, may be utilized, each storing one or more shares. Utilizing multiple MPC systems, for example such that each holds a different share that is required in every signature, allows for reducing the risk of one rogue system from unilaterally signing data. To this end, in an embodiment using multiple MPC systems, a consensus algorithm is utilized to agree on the policy in a way that would prevent a single point of failure.</p><p id="p-0047" num="0046">It should also be noted that a single API service provider device <b>230</b> is shown in <figref idref="DRAWINGS">FIG. <b>2</b></figref> merely for simplicity and that multiple API service provider devices may be equally utilized. Communications with applications or portions thereof hosted by the API service provider devices may be provided via an API exchange or other platform that hosts APIs from various operators without departing from the scope of the disclosure.</p><p id="p-0048" num="0047"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is an example flowchart <b>300</b> illustrating a method for securing digital signatures for signing API requests using multi-party digital signatures according to an embodiment. In an example implementation, the method may be performed by the MPC system <b>220</b>.</p><p id="p-0049" num="0048">At S<b>310</b>, a request for cryptographic parameters to be used for API requests is received. The request may be received from, for example, an API service requestor device (e.g., the API service requestor device <b>210</b>, <figref idref="DRAWINGS">FIG. <b>2</b></figref>).</p><p id="p-0050" num="0049">At S<b>320</b>, secret shares are generated based on an API secret created by the API service provider. The secret shares are created such that two or more shares collectively form the API secret delivered by the service provider. To this end, when data is signed using each of the shares, at least k shares out of a total number n of shares is needed to successfully sign the data, where k and n are both integers having a value greater than or equal to 2 and k is less than or equal to n. To this end, the shares are generated by two or more systems, with each system representing a party. As a non-limiting example, each of the MPC system <b>220</b> and the API service provider device <b>230</b> generates a portion of the shares.</p><p id="p-0051" num="0050">It should be noted that each party generates one or more secret shares and that none of the parties knows the full API secret. As a non-limiting example, if a customer device (e.g., the API service requestor device <b>210</b>) and a service provider system (e.g., the MPC system <b>220</b>) will store the shares, at least two shares are created. As another non-limiting example, if four systems will store the shares, at least four shares are created. The system of each party creates one or more of the shares separately and independently from the other systems. As a non-limiting example, when the method of <figref idref="DRAWINGS">FIG. <b>3</b></figref> is performed by the MPC system <b>220</b>, the API service requestor device <b>210</b> separately generates one or more shares.</p><p id="p-0052" num="0051">In another embodiment, S<b>320</b> may include secure distributed generation of the same latent API secret multiple times such that two or more sets of shares are created, with each set of shares including two or more shares. Each set of shares may be used to sign and validate the data such that all shares of one of the sets are needed to sign the data. The scheme supports defining a threshold k in which k shares are needed out of the total number n of shares, where k is less than or equal to n. As a non-limiting example, 5 shares of an API secret are created among an API service requestor and a MPC service provider, with 2 to be generated by the API service requestor and 3 by the service provider. Any 4 of the 5 shares may be needed for access. As another non-limiting example, the API secret may be generated by 3 parties creating shares, for example an API service requestor, a MPC service provider, and a trusted third party.</p><p id="p-0053" num="0052">At S<b>330</b>, a request to sign an API request is received. The request may be received from, for example, a device requesting a service that uses APIs (e.g., the API service requestor device <b>210</b>, <figref idref="DRAWINGS">FIG. <b>1</b></figref>) when the API service requestor device requests an operation to be performed or other service to be delivered. The request at least includes the data to be signed (for example, an API request).</p><p id="p-0054" num="0053">At S<b>340</b>, it is determined whether requirements of a signing policy have been met and, if so, execution continues with S<b>350</b>; otherwise, execution either terminates (not shown) or continues with S<b>330</b> (shown). The signing policy includes rules for validating the authenticity. When the API request is validated, the system of the validating party (for example, the service provider) will use its respective predefined portion of the shares (or a portion of shares of a set of shares if the API secret is split into several sets) in order to sign the API request. The signing policy may further include additional requirements as described herein above. To this end, S<b>340</b> may include communicating with other systems to, for example, prompt other users to provide authentication and approval for the transaction.</p><p id="p-0055" num="0054">At S<b>350</b>, the shares are used to sign the API request. In an embodiment, the API request is signed using a distributed implementation of a digital signature algorithm (for example ECDSA/EdDSA/ED25519/HMAC), such that the full API secret is never reconstructed on any system. As non-limiting examples, such a digital signature algorithm may be ECDSA, Edwards-curve Digital Signature Algorithm (EdDSA), Ed25519, HMAC (for example, HMAC over SHA-512) and the like. The security of the protocol may be proven based on cryptographic assumptions (e.g., a discrete log).</p><p id="p-0056" num="0055">It should be noted that steps S<b>330</b> through S<b>350</b> may be repeated with the same secret generated in S<b>320</b> because the same secret can be used for signing multiple API requests.</p><p id="p-0057" num="0056">It should also be noted that, in an embodiment, shares generated at S<b>320</b> may be rotated in a way that is consistent with the API secret of the digital signature. Such rotation may be performed between any two or more parties that wish to refresh their secret shares. None of the shares are revealed in the process. The parties may proceed to S<b>330</b> as if the shares were generated in S<b>320</b>.</p><p id="p-0058" num="0057"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is an example schematic diagram of the MPC system <b>220</b> according to an embodiment. The MPC system <b>220</b> includes a processing circuitry <b>410</b> coupled to a memory <b>420</b>, a storage <b>430</b>, and a network interface <b>440</b>. The components of the MPC system <b>220</b> may be communicatively connected via a bus <b>450</b>.</p><p id="p-0059" num="0058">The processing circuitry <b>410</b> may be realized as one or more hardware logic components and circuits. For example, and without limitation, illustrative types of hardware logic components that can be used include field programmable gate arrays (FPGAs), application-specific integrated circuits (ASICs), Application-specific standard products (ASSPs), system-on-a-chip systems (SOCs), general-purpose microprocessors, microcontrollers, digital signal processors (DSPs), encrypted verifiable hardware, secure elements, secure verifiable enclaves within microprocessors such as Intel&#xa9; SGX, and the like, or any other hardware logic components that can perform calculations or other manipulations of information.</p><p id="p-0060" num="0059">In an example implementation, the entire MPC protocol may be implemented using software guard extensions (SGX). To this end, instructions for performing the disclosed embodiments may be stored in a private region of memory, where the private region of memory includes data used for signing and providing signed API requests. The data in the private region of memory is inaccessible to processes outside the private region of memory.</p><p id="p-0061" num="0060">The memory <b>420</b> may be volatile (e.g., RAM, etc.), non-volatile (e.g., ROM, flash memory, etc.), or a combination thereof. In one configuration, computer readable instructions to implement one or more embodiments disclosed herein may be stored in the storage <b>430</b>.</p><p id="p-0062" num="0061">In another embodiment, the memory <b>420</b> is configured to store software. Software shall be construed broadly to mean any type of instructions, whether referred to as software, firmware, middleware, microcode, hardware description language, or otherwise. Instructions may include code (e.g., in source code format, binary code format, executable code format, or any other suitable format of code). The instructions, when executed by the processing circuitry <b>410</b>, configure the processing circuitry <b>410</b> to perform at least some of the various processes described herein.</p><p id="p-0063" num="0062">The storage <b>430</b> may be magnetic storage, optical storage, and the like, and may be realized, for example, as flash memory or other memory technology, CD-ROM, Digital Versatile Disks (DVDs), or any other medium which can be used to store the desired information.</p><p id="p-0064" num="0063">The network interface <b>440</b> allows the MPC system <b>220</b> to communicate with, for example, the API service requestor device <b>210</b>, the API service provider device <b>230</b>, and the like, for purposes such as, but not limited to, receiving API request data, sending at least partially signed API requests, and the like.</p><p id="p-0065" num="0064">It should be understood that the embodiments described herein are not limited to the specific architecture illustrated in <figref idref="DRAWINGS">FIG. <b>4</b></figref>, and other architectures may be equally used without departing from the scope of the disclosed embodiments. Additionally, other systems may be similarly configured to create shares based on API secrets and to sign transactions using the created shares.</p><p id="p-0066" num="0065">The various embodiments disclosed herein can be implemented as hardware, firmware, software, or any combination thereof. Moreover, the software is preferably implemented as an application program tangibly embodied on a program storage unit or computer readable medium consisting of parts, or of certain devices and/or a combination of devices. The application program may be uploaded to, and executed by, a machine comprising any suitable architecture. Preferably, the machine is implemented on a computer platform having hardware such as one or more central processing units (&#x201c;CPUs&#x201d;), a memory, and input/output interfaces. The computer platform may also include an operating system and microinstruction code. The various processes and functions described herein may be either part of the microinstruction code or part of the application program, or any combination thereof, which may be executed by a CPU, whether or not such a computer or processor is explicitly shown. In addition, various other peripheral units may be connected to the computer platform such as an additional data storage unit and a printing unit. Furthermore, a non-transitory computer readable medium is any computer readable medium except for a transitory propagating signal.</p><p id="p-0067" num="0066">All examples and conditional language recited herein are intended for pedagogical purposes to aid the reader in understanding the principles of the disclosed embodiment and the concepts contributed by the inventor to furthering the art, and are to be construed as being without limitation to such specifically recited examples and conditions. Moreover, all statements herein reciting principles, aspects, and embodiments of the disclosed embodiments, as well as specific examples thereof, are intended to encompass both structural and functional equivalents thereof. Additionally, it is intended that such equivalents include both currently known equivalents as well as equivalents developed in the future, i.e., any elements developed that perform the same function, regardless of structure.</p><p id="p-0068" num="0067">It should be understood that any reference to an element herein using a designation such as &#x201c;first,&#x201d; &#x201c;second,&#x201d; and so forth does not generally limit the quantity or order of those elements. Rather, these designations are generally used herein as a convenient method of distinguishing between two or more elements or instances of an element. Thus, a reference to first and second elements does not mean that only two elements may be employed there or that the first element must precede the second element in some manner. Also, unless stated otherwise, a set of elements comprises one or more elements.</p><p id="p-0069" num="0068">As used herein, the phrase &#x201c;at least one of&#x201d; followed by a listing of items means that any of the listed items can be utilized individually, or any combination of two or more of the listed items can be utilized. For example, if a system is described as including &#x201c;at least one of A, B, and C,&#x201d; the system can include A alone; B alone; C alone; <b>2</b>A; <b>2</b>B; <b>2</b>C; <b>3</b>A; A and B in combination; B and C in combination; A and C in combination; A, B, and C in combination; <b>2</b>A and C in combination; A, <b>3</b>B, and <b>2</b>C in combination; and the like.</p><?detailed-description description="Detailed Description" end="tail"?></description><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. (canceled)</claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. A method comprising:<claim-text>accessing, by a first system, a digital signing protocol for an application programming interface (API) secret having a plurality of secret shares distributed over a plurality of computing systems;</claim-text><claim-text>determining, by the first system based on the digital signing protocol, an update operation for the plurality of secret shares;</claim-text><claim-text>generating, by the first system, a first secret share of the plurality of secret shares based on the update operation, wherein the plurality of secret shares includes the first secret share and a second secret share generated by a second system;</claim-text><claim-text>determining, by the first system, a signing policy including a first requirement that a minimum number of secret shares of the plurality of secret shares are available to sign an API request;</claim-text><claim-text>determining, by the first system based on the signing policy, whether the second secret share is required to be updated for the minimum number of secret shares available to sign the API request; and</claim-text><claim-text>providing, by the first system, the first secret share for a processing of the API request based on the determining whether the second secret share is updated.</claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, further comprising:<claim-text>updating, by the first system, the first secret share of the plurality of secret shares on a periodic rolling basis based on the signing policy.</claim-text></claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The method of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the updating comprises:<claim-text>determining, by the first system, that the second secret share is required to be updated; and</claim-text><claim-text>requesting, by the first system from the second system, that the second system update the second secret share based on the signing policy.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the signing policy comprises a minimum number of the plurality of secret shares required for different ones of a plurality of signing authorizations.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The method of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the different ones of the plurality of signing authorizations are associated with transaction payment limits for the signing policy.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The method of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein each of the transaction payment limits is associated with an amount of cryptocurrency utilized during transactions requiring the signing policy.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the API secret comprises an encryption key associated with an amount of transferrable cryptocurrency using one or more private keys.</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, further comprising:<claim-text>validating, by the first system, the API request based on the signing policy and the minimum number of secret shares available to sign the API request.</claim-text></claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The method of <claim-ref idref="CLM-00002">claim 2</claim-ref>, further comprising:<claim-text>signing, by the first system, the API request using the first secret share, wherein the API request is further signed by the second system using the second secret share, and wherein the API request is signed without revealing any of the first secret share to the second system.</claim-text></claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. A first system comprising:<claim-text>a non-transitory memory; and</claim-text><claim-text>one or more hardware processors coupled to the non-transitory memory and configured to read instructions from the non-transitory memory to cause the first system to perform operations comprising:<claim-text>accessing a digital signing protocol for an application programming interface (API) secret having a plurality of secret shares distributed over a plurality of computing systems;</claim-text><claim-text>determining, based on the digital signing protocol, an update operation for the plurality of secret shares;</claim-text><claim-text>generating a first secret share of the plurality of secret shares based on the update operation, wherein the plurality of secret shares includes the first secret share and a second secret share generated by a second system;</claim-text><claim-text>determining a signing policy including a first requirement that a minimum number of secret shares of the plurality of secret shares are available to sign an API request;</claim-text><claim-text>determining, based on the signing policy, whether the second secret share is required to be updated for the minimum number of secret shares available to sign the API request; and</claim-text><claim-text>providing the first secret share for a processing of the API request based on the determining whether the second secret share is updated.</claim-text></claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The first system of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the operations further comprise:<claim-text>updating the first secret share of the plurality of secret shares on a periodic rolling basis based on the signing policy.</claim-text></claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The first system of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the updating comprises:<claim-text>determining that the second secret share is required to be updated; and</claim-text><claim-text>requesting, from the second system, that the second system update the second secret share based on the signing policy.</claim-text></claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The first system of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the signing policy comprises a minimum number of the plurality of secret shares required for different ones of a plurality of signing authorizations.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The first system of <claim-ref idref="CLM-00014">claim 14</claim-ref>, wherein the different ones of the plurality of signing authorizations are associated with transaction payment limits for the signing policy.</claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The first system of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein each of the transaction payment limits is associated with an amount of cryptocurrency utilized during transactions requiring the signing policy.</claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The first system of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the API secret comprises an encryption key associated with an amount of transferrable cryptocurrency using one or more private keys.</claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The first system of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the operations further comprise:<claim-text>validating, by the first system, the API request based on the signing policy and the minimum number of secret shares available to sign the API request.</claim-text></claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. A non-transitory machine-readable medium having stored thereon machine-readable instructions executable to cause a machine to perform operations comprising:<claim-text>accessing, by a first system, a digital signing protocol for an application programming interface (API) secret having a plurality of secret shares distributed over a plurality of computing systems;</claim-text><claim-text>determining, by the first system based on the digital signing protocol, an update operation for the plurality of secret shares;</claim-text><claim-text>generating, by the first system, a first secret share of the plurality of secret shares based on the update operation, wherein the plurality of secret shares includes the first secret share and a second secret share generated by a second system;</claim-text><claim-text>determining, by the first system, a signing policy including a first requirement that a minimum number of secret shares of the plurality of secret shares are available to sign an API request;</claim-text><claim-text>determining, by the first system based on the signing policy, whether the second secret share is required to be updated for the minimum number of secret shares available to sign the API request; and</claim-text><claim-text>providing, by the first system, the first secret share for a processing of the API request based on the determining whether the second secret share is updated.</claim-text></claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The non-transitory machine-readable medium of <claim-ref idref="CLM-00019">claim 19</claim-ref>, wherein the operations further comprise:<claim-text>updating, by the first system, the first secret share of the plurality of secret shares on a periodic rolling basis based on the signing policy.</claim-text></claim-text></claim><claim id="CLM-00021" num="00021"><claim-text><b>21</b>. The non-transitory machine-readable medium of <claim-ref idref="CLM-00020">claim 20</claim-ref>, wherein the updating comprises:<claim-text>determining, by the first system, that the second secret share is required to be updated; and</claim-text><claim-text>requesting, by the first system with the second system, that the second system update the second secret share based on the signing policy.</claim-text></claim-text></claim></claims></us-patent-application>