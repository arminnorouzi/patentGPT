<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230006981A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230006981</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17369305</doc-number><date>20210707</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><priority-claims><priority-claim sequence="01" kind="national"><country>GR</country><doc-number>20210100449</doc-number><date>20210701</date></priority-claim></priority-claims><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>L</subclass><main-group>29</main-group><subgroup>06</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>L</subclass><main-group>9</main-group><subgroup>08</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>455</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>H</section><class>04</class><subclass>L</subclass><main-group>9</main-group><subgroup>32</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>L</subclass><main-group>63</main-group><subgroup>0435</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>L</subclass><main-group>9</main-group><subgroup>0819</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>45533</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>L</subclass><main-group>9</main-group><subgroup>0852</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>L</subclass><main-group>9</main-group><subgroup>3265</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>H</section><class>04</class><subclass>L</subclass><main-group>9</main-group><subgroup>0894</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e61">SYSTEMS, METHODS, AND DEVICES FOR ENCRYPTED DATA TRANSFER</invention-title><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>MELLANOX TECHNOLOGIES, LTD.</orgname><address><city>Yokneam</city><country>IL</country></address></addressbook><residence><country>IL</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Syrivelis</last-name><first-name>Dimitrios</first-name><address><city>Volos</city><country>GR</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Levi</last-name><first-name>Dotan David</first-name><address><city>Yokneam</city><country>IL</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>Bakopoulos</last-name><first-name>Paraskevas</first-name><address><city>Ilion</city><country>GR</country></address></addressbook></inventor><inventor sequence="03" designation="us-only"><addressbook><last-name>Patronas</last-name><first-name>Ioannis (Giannis)</first-name><address><city>Athens</city><country>GR</country></address></addressbook></inventor><inventor sequence="04" designation="us-only"><addressbook><last-name>Mentovich</last-name><first-name>Elad</first-name><address><city>Tel Aviv</city><country>IL</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A network interface controller includes processing circuitry configured to pair with a local root of trust of a host device connected to the network interface controller and provide a key to an encryption device of the host device that enables the encryption device to encrypt data of one or more host device applications using the key. The encrypted data are stored in host device memory. The processing circuitry is configured to share the key with a remote endpoint and forward the encrypted data from the host device memory to the remote endpoint.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="108.97mm" wi="158.75mm" file="US20230006981A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="232.66mm" wi="160.44mm" orientation="landscape" file="US20230006981A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="232.66mm" wi="164.76mm" orientation="landscape" file="US20230006981A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="194.31mm" wi="133.52mm" file="US20230006981A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="172.47mm" wi="132.00mm" file="US20230006981A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="207.86mm" wi="127.76mm" orientation="landscape" file="US20230006981A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">FIELD OF THE DISCLOSURE</heading><p id="p-0002" num="0001">The present disclosure is generally directed to systems, devices, and methods for encrypted data transfer.</p><heading id="h-0002" level="1">BACKGROUND</heading><p id="p-0003" num="0002">Modern datacenters employ various devices and methods for high-speed data exchange that are vulnerable to malicious attacks, particularly when the data being exchanged is unencrypted.</p><heading id="h-0003" level="1">BRIEF SUMMARY</heading><p id="p-0004" num="0003">In an illustrative embodiment, a network interface controller includes processing circuitry configured to pair with a local root of trust of a host device connected to the network interface controller and provide a key to an encryption device of the host device that enables the encryption device to encrypt data of one or more host device applications using the key. The encrypted data are stored in host device memory. The processing circuitry is configured to share the key with a remote endpoint and forward the encrypted data from the host device memory to the remote endpoint. Notably, the processing circuitry is not accessible to host device application software and so the key is not revealed to the one or more host device applications that use the encryption device.</p><p id="p-0005" num="0004">In an illustrative embodiment, a method includes generating, by a network device connected to a host device, a key and associated key identifier, establishing, by the network device and over a communication network, a single key domain by sharing the key and the associated key identifier with at least one other network device, and performing a remote direct access memory (RDMA) operation within the single key domain to send data encrypted with the key over the communication network to the at least one other network device.</p><p id="p-0006" num="0005">In an illustrative embodiment, a system includes a first host device, and a first network device coupled to the first host device. The first network device enables remote direct access memory (RDMA) operations for exchanging encrypted data over a communication network with a second host device. The encrypted data are encrypted with a single key.</p><p id="p-0007" num="0006">Additional features and advantages are described herein and will be apparent from the following Description and the figures.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0008" num="0007">The present disclosure is described in conjunction with the appended figures, which are not necessarily drawn to scale:</p><p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates a system according to at least one example embodiment;</p><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates a system according to at least one example embodiment;</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates a flowchart for a method according to at least one example embodiment;</p><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>4</b></figref> illustrates a flowchart for a method according to at least one example embodiment; and</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. <b>5</b></figref> illustrates a portion of the systems in <figref idref="DRAWINGS">FIGS. <b>1</b> and <b>2</b></figref> according to at least one example embodiment.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0005" level="1">DETAILED DESCRIPTION</heading><p id="p-0014" num="0013">The ensuing description provides embodiments only, and is not intended to limit the scope, applicability, or configuration of the claims. Rather, the ensuing description will provide those skilled in the art with an enabling description for implementing the described embodiments. It being understood that various changes may be made in the function and arrangement of elements without departing from the spirit and scope of the appended claims.</p><p id="p-0015" num="0014">It will be appreciated from the following description, and for reasons of computational efficiency, that the components of the system can be arranged at any appropriate location within a distributed network of components without impacting the operation of the system.</p><p id="p-0016" num="0015">Furthermore, it should be appreciated that the various links connecting the elements can be wired, traces, or wireless links, or any appropriate combination thereof, or any other appropriate known or later developed element(s) that is capable of supplying and/or communicating data to and from the connected elements. Transmission media used as links, for example, can be any appropriate carrier for electrical signals, including coaxial cables, copper wire and fiber optics, electrical traces on a PCB, or the like.</p><p id="p-0017" num="0016">As used herein, the phrases &#x201c;at least one,&#x201d; &#x201c;one or more,&#x201d; &#x201c;or,&#x201d; and &#x201c;and/or&#x201d; are open-ended expressions that are both conjunctive and disjunctive in operation. For example, each of the expressions &#x201c;at least one of A, B and C,&#x201d; &#x201c;at least one of A, B, or C,&#x201d; &#x201c;one or more of A, B, and C,&#x201d; &#x201c;one or more of A, B, or C,&#x201d; &#x201c;A, B, and/or C,&#x201d; and &#x201c;A, B, or C&#x201d; means A alone, B alone, C alone, A and B together, A and C together, B and C together, or A, B and C together.</p><p id="p-0018" num="0017">The terms &#x201c;determine,&#x201d; &#x201c;calculate,&#x201d; and &#x201c;compute,&#x201d; and variations thereof, as used herein, are used interchangeably and include any appropriate type of methodology, process, operation, or technique.</p><p id="p-0019" num="0018">Various aspects of the present disclosure will be described herein with reference to drawings that may be schematic illustrations of idealized configurations.</p><p id="p-0020" num="0019">Unless otherwise defined, all terms (including technical and scientific terms) used herein have the same meaning as commonly understood by one of ordinary skill in the art to which this disclosure belongs. It will be further understood that terms, such as those defined in commonly used dictionaries, should be interpreted as having a meaning that is consistent with their meaning in the context of the relevant art and this disclosure.</p><p id="p-0021" num="0020">As used herein, the singular forms &#x201c;a,&#x201d; &#x201c;an,&#x201d; and &#x201c;the&#x201d; are intended to include the plural forms as well, unless the context clearly indicates otherwise. It will be further understood that the terms &#x201c;include,&#x201d; &#x201c;including,&#x201d; &#x201c;includes,&#x201d; &#x201c;comprise,&#x201d; &#x201c;comprises,&#x201d; and/or &#x201c;comprising,&#x201d; when used in this specification, specify the presence of stated features, integers, steps, operations, elements, and/or components, but do not preclude the presence or addition of one or more other features, integers, steps, operations, elements, components, and/or groups thereof. The term &#x201c;and/or&#x201d; includes any and all combinations of one or more of the associated listed items.</p><p id="p-0022" num="0021">Inventive concepts relate to extensions of smart network interface controller (NIC) architectures that enable the exchange of in-memory encrypted buffers over Remote Direct Memory Access (RDMA) between endpoints without decrypting the data during the actual transfer. The approach aims to extend the data-in-use security concept for central processing units (CPUs) where data are not stored in the clear (e.g., unencrypted) in the main system memory but are encrypted by the CPUs during the store operation and are decrypted during the load (or read) operation so the contents of main system memory are always encrypted. Inventive concepts cover at least the following subsystem extensions: a smart NIC implementing the concept of a &#x201c;distributed root of trust,&#x201d; which extends a local root of trust of a device attached to the NIC and allows authenticated machines to share keys through isolated/hardened NIC-based CPU complexes; details for the integration of quantum key distribution (QKD)-based secret key exchange; enabling a smart NIC to interact with the trusted root key management service on a server and negotiate the keys with the local applications, where the key(s) will then be used to exchange encrypted buffers over RDMA with a remote counterpart; and an introduction of host-isolated support to the NIC for the transfer of key-synchronization messages between endpoints that also acts as part of an RDMA tunnel establishment sequence.</p><p id="p-0023" num="0022">The meltdown and spectre bugs that were introduced in 2018 shocked the cloud computing industry. In this type of attack, an adversary exploits a CPU side channel, combining speculative execution features along with cache hits on modern processors, that allowed a legitimate application to dump an entire operating system (OS) kernel in-memory footprint. The initial response to this type of attack was to disable speculative execution on processors, which decreased CPU performance substantially and, at the software-level, the OS kernel was appropriately patched to load itself to an arbitrary location at boot rather than a static one, which makes it very difficult, but not impossible, to interpret a memory dump.</p><p id="p-0024" num="0023">However, these mitigation measures do not address the heart of the problem, which is that data-in-use (i.e., data stored on main system memory and cache on which CPUs work) are stored in main system memory in the clear (unencrypted). Even an encrypted disk block buffer is manipulated unencrypted by the CPU and at that point a substantial vulnerability is exposed. For that reason, CPU vendors have rolled or are soon rolling out CPUs with in-memory encryption capabilities. The basic functionality of encrypted memory support is that the CPU (or the memory controller) encrypts data on the fly as it stores data to memory and decrypts the data when the CPU loads the data back. As a result, the data stored in memory (after the lowest point of coherency) are always encrypted. CPUs employing encrypted memory support have different operating modes that may be classified in two main categories: transparent full memory encryption (where everything in memory is encrypted with the same key&#x2014;referred to as Secure Memory Encryption), and a more elaborate scheme that allows each virtual machine or each container (or more generally, each process) to use custom keys for the memory in use. Since the memory contents are always encrypted, an illegal memory dump via a side channel has the additional challenge of breaking the symmetric key encryption (such AES) to read the data, which is currently intractable to solve. Even though CPU memory encryption engines strive for efficiency, these encryption engines introduce some amount of latency and consume significant power.</p><p id="p-0025" num="0024">In the CPU encrypted memory support, the encryption engine operates on cache line-sized blocks and is engaged in the memory access data path on a per cache line-update transaction basis. Dedicated reserved bits of each transaction's virtual address define whether the transaction payload should undergo an encryption or decryption (depending on whether the operation is a store or load operation). In that context, DMA engines of peripherals (like smart NICs) may be programmed by a driver to read or write application buffers with encryption support on or off. If the encryption support is turned off, the peripheral will read the application buffer encrypted and does not have the key to decipher.</p><p id="p-0026" num="0025">Inventive concepts relate to cases where two or more remote servers have enabled the CPU memory encryption, which creates secure memory enclaves that allow the use of different keys for each application or that allow the use of a single key for multiple applications, and that run applications that perform RDMA transfers between them. Inventive concepts create an isolated, secure, single encryption key domain that integrates the data-in-use security of each server endpoint with data-in-motion introduced by RDMA between servers for two or more applications on different servers that want to exchange data.</p><p id="p-0027" num="0026">The benefits of using a single key domain between applications that leverage secure memory enclaves that also need to exchange data over RDMA include: the NIC will have RDMA payload encrypted for free and does not need to leverage additional encryption support, thus consuming less power while still transferring encrypted data; CPU-based encryption is not in the critical path of the transfer and happens sometime beforehand, which enables the RDMA to use a low latency data path that does not go through the encryption offloading accelerators while still carrying symmetrically encrypted payloads; payload data sent to the NIC remain encrypted, which further resists tampering attempts with the peripheral component interconnect express (PCIe) bus or NIC internals where, otherwise, the transferred data would have been unencrypted; and, even if the NIC, for security reasons (e.g., more frequent key updates, stronger ciphers, encryption of the Layer3 and Layer2 headers), needs to encrypt packets, the described approach is still beneficial as it eliminates the need of encryption/decryption of the buffers at the processor-level, as the buffers are transferred encrypted, which contributes to lower latency and decreased power consumption.</p><p id="p-0028" num="0027">In some cases, there are multiple protection domains inside a single CPU, and the NIC is the only entity entitled to read/write data from all domains to secure the protection domains. This allows inventive concepts to apply to cases where the authority for the encryption is a guest virtual machine (VM), and the NIC serves multiple guest VMs.</p><p id="p-0029" num="0028">In general, inventive concepts relate to assignment of a root of trust to a NIC's programmable system on chip (SoC) and integration of the NIC root of trust with a local server root of trust and CPU firmware to form a distributed root of trust (e.g., some root of trust functions are performed by the local root of trust of the server and some root of trust functions are performed by the root of trust on the NIC). In this context, the NIC becomes an isolated key distributor that securely provides keys to applications running on hosts. The NIC may also provide isolated key distribution to several different clients (e.g., VMs) on the same host while providing a secure domain for data-in-use and data-in-motion with a single encryption key. Inventive concepts further relate to a bring-up sequence of a secure domain for data-in-use and data-in-motion for applications that run on systems with encrypted memory support and that perform RDMA transfers, and the integration of Quantum Key distribution (QKD) with the aforementioned key distribution scheme.</p><p id="p-0030" num="0029">The approach of a single key domain between data-in-use and data-in-motion has not been yet considered because the approach is primarily applicable to RDMA or custom Data Plane Development Kit (DPDK) solutions where the NIC is not required to read any data on the network buffer to proceed with the packet forwarding, as the data comes from the main system memory already encrypted.</p><p id="p-0031" num="0030">Inventive concepts propose a distributed root of trust for secret key management that features appropriately integrated endpoints on each server host. The distributed root of trust support on each server is provided by a NIC at each server that is hardened and isolated from user applications. Subsequently, each NIC root of trust may provide the local server with encryption keys via isolated channels that are used by the hardware-enabled (e.g., CPU/memory controller) encrypted memory support. Host processor firmware handles the integration of the NIC provided root of trust with the local encrypted memory root of trust to form the distributed root of trust. The system may be leveraged by a hypervisor or application loader that runs on each server with hypervisor privileges and handles of the synchronization steps between two or more servers, thereby enabling the same encryption key to be used by all the applications that wish to establish an RDMA channel. Once coordination is completed, the hypervisor/loader on each server forks the application binaries (e.g., virtual machines) to set the same key for the local secure memory enclaves.</p><p id="p-0032" num="0031">Example embodiments cover at least: 1) the distributed root of trust NIC-assisted concept; and 2) the formation of a single secret key domain between one or more applications, that run on different machines and use RDMA to exchange data. An example deployment for a setup with two servers is depicted in <figref idref="DRAWINGS">FIGS. <b>1</b> and <b>2</b></figref>.</p><p id="p-0033" num="0032">Some NICs feature an entire processor complex that, in selected configurations, can be entirely isolated from the attached host device and can be controlled from an infrastructure provider via a dedicated network port. In that context, even if for example a datacenter infrastructure provider provides bare metal server access to a third party, the provider still has thorough control of the network-facing traffic by leveraging the CPU complex on the NIC because the CPU complex is completely isolated from the host device software. Example embodiments build on the concept of an isolated, infrastructure provider-controlled, CPU complex on a NIC to introduce a distributed root of trust service, which allows secret keys to be securely agreed upon and shared between remote machines via each remote machine's local root of trust support.</p><p id="p-0034" num="0033">A local root of trust (e.g., an Advanced RISC Machines (ARM) trusted boot) on computing systems is a hardware-assisted entity that allows running system software to secure the identity of the platform on which the software is running. This prevents adversaries from taking over the control of a system at a very low-level, for example, by preventing boot of a malicious OS kernel or by preventing emulation of the host to trick the software into running on an adversary-controlled execution environment (enclave). With the advent of hardware memory encryption, the root of trust role has been extended to provide secret keys via an out-of-band channel to the encryptor/decryptor hardware that performs the cryptography operations in a controlled manner. In addition, there is a secure interface with the OS and hypervisor to control which keys are used for which secure execution environments (e.g., VMs). A local root of trust is, in most cases, a CPU-based system that is physically isolated from the network and controlled by server firmware (e.g., Basic-Input Output System (BIOS)) to which the root of trust also provides security bootstrap services. Thus, software that runs on a system is forced to interact with the server firmware to access the very specific, well-defined root of trust services.</p><p id="p-0035" num="0034">Inventive concepts relate to an approach for adding the functionality of key exchange to the local root of trust by offloading the network part of the tasks to a trusted root of trust service that runs on the NIC, for example, on the NIC's CPU complex. Each time a NIC is attached to the PCI-bus or other peripheral interconnect infrastructure of a system (e.g., a server), the system administrator may carry out a pairing process between the extended root of trust service running on the NIC's CPU complex and the local root of trust of the system or server. The pairing process may include generating a combined root certificate that uniquely defines the specific server platform instance with the specific instance of the attached NIC. Thereafter, the server interconnect access to the NIC CPU complex is physically confined to be carried out by circuitry that can only be controlled by the server local root of trust and/or the server firmware. The NIC CPU complex runs a process that acts as part of the root of trust firmware and provides a service for secure key exchange with remote counterparts (e.g., other NICs) by, leveraging the network access facilities of the NIC. The NIC-based distributed root of trust endpoint may then form secure connections to other root of trust endpoints within the datacenter or beyond to exchange keys. Key exchange may be performed with any secure tunnel approach like VPN and MACsec. At least one example embodiment performs the key-exchange over a Quantum-key distribution system (QKD). In addition, the NIC-based distributed root of trust assists with the secure notification of key exchange completion (e.g., to the hypervisor) so that a single secret key domain is formed.</p><p id="p-0036" num="0035">A distributed root of trust according to example embodiments may implement the following operations for a key exchange: 1) the administrator has configured a centralized service like DNS or has a hardcoded list of server identifiers available to the root of trust service extension that runs on the NIC to identify one or more remote endpoints that wish to participate in a single key domain, 2) a hypervisor establishes an isolated channel with the local server firmware that is dedicated, secured and cannot be overridden; 3) the local root of trust receives a request from the hypervisor over the isolation channel via a firmware callback to set up a single key domain with the one or more remote endpoints; 4) the local root of trust authenticates and relays the request to the NIC-based root of trust extension via the isolated channel (for example, the NIC root of trust service uses a backend to generate a secret key-key identifier keyID (e.g., a universally unique identifier (UUID)) pair and then securely exchanges the key with the remote endpoint(s). Upon completion of key sharing, the key identifier keyID is returned to the local server firmware (e.g., the local root of trust) and from there to hypervisor for future reference; 5) upon return of the KeyID, the hypervisor knows that the key exchange has been carried out and the secret key can be made available to the encrypted memory engines of remote endpoints upon request; 6) during launch of an application, the keyID is passed as an argument by the hypervisor so the hypervisor's virtual address space can be associated with the secret key to which keyID points (by using the keyID, the secret key that is actually being used for in-memory data encryption is never revealed which is consistent with how encrypted memory operates), and upon the first request for keyID installation, the keyID-key pair is consumed and cannot be used again.</p><p id="p-0037" num="0036">The secure exchange of the keyID may be a hypervisor responsibility. Nevertheless, there is some inherent security in place in case such a communication channel is compromised. Firstly, eavesdropping the keyID cannot be used to decrypt data as the keyID is only a reference to the actual secret key which is not revealed to any applications. In addition, a side channel cannot be established as the system removes the key-keyID pair after the key-keyID pair has been requested exactly once. Therefore, the key can be either consumed by the launch of the actual application or the side channel application, and hence, no eavesdropping can be established.</p><p id="p-0038" num="0037">Regarding the actual key exchange, the system can support existing good practices but, in addition, may be based on Quantum Key Distribution (QKD). In the QKD case, the key-keyID pair approach is compatible with existing QKD devices. Therefore, the KeyID exchange is integrated in the described root of trust flow in the same spirit whereas the key exchange is performed from the QKD quantum channel making the whole key exchange process quantum safe.</p><p id="p-0039" num="0038">As described above and below, the distributed root of trust according to example embodiments enables the secret key exchange between remote machines in a coordinated fashion. Given that RDMA communication is integrated in the virtual address space of applications to bypass the CPU entirely and given that the RDMA buffer contents do not have to be read by the MC for forwarding operations as all the network plumbing happens out-of-band, there is the unique opportunity to move around encrypted memory contents without actually having to decrypt the contents for the network transfer. For this to work, the endpoints that exchange encrypted memory contents over RDMA should be using the same key. The distributed root of trust support according to example embodiments provides this functionality and includes the integration of RDMA initialization sequence with distributed root of trust functionality for performing RDMA between encrypted memory systems.</p><p id="p-0040" num="0039">The RDMA initialization sequence may include the following operations. Firstly, RDMA orchestration software is notified that virtual machines (VMs) or containers or specific processes (in the case of high performance computing (HPC)) will start on specific servers with encrypted memory turned on and will be also performing RDMA. Subsequently, the orchestration software informs the hypervisor on each machine, in addition to the default details required to launch applications, that encrypted memory support will be activated and the machines will participate to a single secret key domain. A specific hypervisor is designated as the key domain master for the purpose of initiating the distributed root of trust key exchange. Upon notification of established single key domain (i.e., the agreed secret key has been exchanged and is locally available on each endpoint), the required application instances may be started on each server. Given that the keys are the same, the encrypted content that originates from the virtual address space of one application endpoint should be readable by any remote counterpart without the need for any decryption during the network transfer. After proper launch as described above, the standard RDMA approach may be used both for channel setup as well as data exchange.</p><p id="p-0041" num="0040">The above initialization approach is not limited to any specific orchestrator or hypervisor or virtualization technology. The steps of leveraging the NIC-assisted distributed root of trust to bring up a single secret key domain for encrypted memory systems may be accomplished by a custom bootstrap process in any suitable application scenario. One hard requirement is that the NIC should not rely on packet information that has been added by applications (e.g., as it can happen with DPDK applications) that use encrypted memory for forwarding operations, as the packet information is not part of the secret key domain and the data are encrypted.</p><p id="p-0042" num="0041">The above-described systems, methods, and devices will now be explained with reference to <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>5</b></figref>.</p><p id="p-0043" num="0042"><figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates a system <b>100</b> according to at least one example embodiment. The system <b>100</b> includes a host device <b>104</b>, a communication network <b>108</b>, and a host device <b>112</b>. In at least one example embodiment, host devices <b>104</b> and <b>112</b> correspond to one or more of a Personal Computer (PC), a laptop, a tablet, a smartphone, a server, a collection of servers, or the like. In some embodiments, the host devices <b>104</b> and <b>112</b> may correspond to any appropriate type of device that communicates with other devices also connected to a common type of communication network <b>108</b>. As another specific but non-limiting example, the host devices <b>104</b> and <b>112</b> may correspond to network switches for servers offering information resources, services and/or applications to user devices, client devices, or other hosts in the system <b>100</b>.</p><p id="p-0044" num="0043">Examples of the communication network <b>108</b> that may be used to connect the host devices <b>104</b> and <b>112</b> include an Internet Protocol (IP) network, an Ethernet network, an InfiniBand (TB) network, a Fibre Channel network, the Internet, a cellular communication network, a wireless communication network, combinations thereof (e.g., Fibre Channel over Ethernet), variants thereof, and/or the like. In one specific, but non-limiting example, the communication network <b>108</b> enables data transmission between the devices <b>104</b> and <b>112</b> using optical signals. In this case, the host devices <b>104</b> and <b>112</b> and the communication network <b>108</b> may include waveguides (e.g., optical fibers) that carry the optical signals. In one specific, but non-limiting example, the communication network <b>108</b> enables data transmission between the host devices <b>104</b> and <b>112</b> using electrical signals. In this case, the host devices <b>104</b> and <b>112</b> and the communication network <b>108</b> may include conductive wires (e.g., copper wires) that carry the electrical signals. In one embodiment, the communication network <b>108</b> enables data transmission with both electrical and optical signals.</p><p id="p-0045" num="0044">The host device <b>104</b> includes an attachable network device (also called a network attached device), such as a network interface controller (NIC) <b>116</b> or other suitable network attached device. The host device <b>104</b> includes a local root of trust <b>120</b>, an encryptor/decryptor <b>124</b>, encrypted memory <b>128</b>, and a collection of central processing units (CPUs) <b>132</b>.</p><p id="p-0046" num="0045">The NIC <b>116</b> may be a &#x201c;smart&#x201d; NIC that includes a CPU complex with at least one CPU <b>118</b>. The CPU <b>118</b> may include processing circuitry and/or memory for carrying out computing tasks, for example, tasks associated with controlling the flow of data over the communication network <b>108</b>. The processing circuitry may comprise software, hardware, or a combination thereof. For example, the processing circuitry may include a memory including executable instructions and a processor (e.g., a microprocessor) that executes the instructions on the memory. The memory may correspond to any suitable type of memory device or collection of memory devices configured to store instructions. Non-limiting examples of suitable memory devices that may be used include Flash memory, Random Access Memory (RAM), Read Only Memory (ROM), variants thereof, combinations thereof, or the like. In some embodiments, the memory and processor may be integrated into a common device (e.g., a microprocessor may include integrated memory). Additionally or alternatively, the processing circuitry may comprise hardware, such as an application specific integrated circuit (ASIC). Other non-limiting examples of the processing circuitry include an Integrated Circuit (IC) chip, a Central Processing Unit (CPU), a General Processing Unit (GPU), a microprocessor, a Field Programmable Gate Array (FPGA), a collection of logic gates or transistors, resistors, capacitors, inductors, diodes, or the like. Some or all of the processing circuitry may be provided on a Printed Circuit Board (PCB) or collection of PCBs. It should be appreciated that any appropriate type of electrical component or collection of electrical components may be suitable for inclusion in the processing circuitry. As discussed in more detail below, the CPU <b>118</b> enables creation of a single-key domain for exchanging encrypted data with host device <b>112</b>. To this end, the CPU <b>118</b> may execute isolated root of trust software (e.g., firmware) to extend the local root of trust <b>120</b> to form a distributed root of trust between the CPU <b>118</b> and the local root of trust <b>120</b>.</p><p id="p-0047" num="0046">The local root of trust <b>120</b> comprises suitable hardware and/or software for enabling secure communication with other elements of the host device <b>104</b> and is trusted by the operating system (OS) of the host device <b>104</b>. The local root of trust <b>120</b> (e.g., an Advanced RISC Machines (ARM) trusted boot) may be a hardware-assisted entity that allows running system software to secure the identity of the platform on which the software is running. This prevents adversaries from taking over the control of a system at a very low-level, for example, by preventing boot of a malicious operating system kernel or by preventing emulation of the host to trick the software into running on an adversary-controlled execution environment (enclave). With the advent of hardware memory encryption, the root of trust role has been extended to provide secret keys via an out-of-band channel to the encryptor/decryptor <b>124</b> hardware that performs the cryptography operations in a controlled manner. In addition, there is a secure interface with the OS and hypervisor <b>140</b> to control which keys are used for which secure execution environments (e.g., VMs). The local root of trust <b>120</b> may include a CPU-based system that is physically isolated from the communication network <b>108</b> and controlled by firmware of the host device <b>104</b> (e.g., Basic-Input Output System (BIOS) firmware) to which the root of trust also provides security bootstrap services. Thus, software that runs on the host device <b>104</b> interacts with the host device <b>104</b> firmware to access specific, well-defined root of trust services.</p><p id="p-0048" num="0047">In at least one embodiment, the local root of trust <b>120</b> enables data encryption functions, detection and reporting of unauthorized changes to the OS or applications, detection of rootkits, memory curtaining, and/or digital rights management. As discussed in more detail below, the local root of trust <b>120</b> pairs with a root of trust of the CPU <b>118</b> (also referred to as an extended root of trust) to provide a distributed root of trust for the host device <b>104</b>.</p><p id="p-0049" num="0048">The encryptor/decryptor <b>124</b> includes suitable hardware and/or software for encrypting data and storing the encrypted data on encrypted memory <b>128</b>. The encryptor/decryptor <b>124</b> may further include suitable hardware and/or software for decrypting the data from encrypted memory <b>128</b>. The encryptor/decryptor <b>124</b> may encrypt data from the CPUs <b>132</b> using a key received from the local root of trust <b>120</b> over an isolated (secure) channel. The encrypted memory <b>128</b> may include volatile and/or non-volatile storage devices. Non-limiting examples of suitable memory devices for the encrypted memory <b>128</b> include flash memory, Random Access Memory (RAM), variants thereof, combinations thereof, or the like. The encrypted memory <b>128</b> may be main system memory of the host device <b>104</b> (as in <figref idref="DRAWINGS">FIG. <b>1</b></figref>), peripheral device dedicated memory (e.g., GPU memory), encrypted storage (e.g., NVMe Over Fabric), and/or storage class memory.</p><p id="p-0050" num="0049">The collection of CPUs <b>132</b> may include the same or similar processing circuitry as the CPU <b>118</b>. In one embodiment, the CPUs <b>132</b> include physical and/or logical processing units that execute operations for a respective virtual machine (VM) in a collection of VMs <b>136</b> created by a hypervisor <b>140</b>. The CPUs <b>132</b> and VMs <b>136</b> may be controlled by the hypervisor <b>140</b>.</p><p id="p-0051" num="0050">The host device <b>112</b> includes an attached network device (also called a network attached device), such as a NIC <b>144</b>, or other suitable network attached device. The host device <b>112</b> further includes a local root of trust <b>148</b>, an encryptor/decryptor <b>152</b>, encrypted memory <b>156</b>, and a collection of central processing units (CPUs) <b>160</b>.</p><p id="p-0052" num="0051">The NIC <b>144</b> may be a &#x201c;smart&#x201d; NIC that includes a (CPU) complex with at least one CPU <b>146</b>. The CPU <b>146</b> may include the same or similar processing circuitry as CPU <b>118</b>. As discussed in more detail below, the CPU <b>146</b> (along with CPU <b>118</b>) enables a single-key domain for exchanging encrypted data with host device <b>104</b>. To this end, the CPU <b>146</b> may execute isolated root of trust software (e.g., firmware) to extend the local root of trust <b>148</b> to form a distributed root of trust between the CPU <b>146</b> and the local root of trust <b>148</b>. As shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the secure key exchange may occur over a designated, secure channel between CPUs <b>118</b> and <b>146</b>. However, it should be appreciated that one or more control signals for key exchange may be exchanged over a backend channel.</p><p id="p-0053" num="0052">Like the local root of trust <b>120</b> of host device <b>104</b>, the local root of trust <b>148</b> comprises suitable hardware and/or software for enabling secure communication with other elements of the host device <b>112</b> and is trusted by the operating system (OS) of the host device <b>112</b>. For example, the local root of trust <b>148</b> (e.g., an Advanced RISC Machines (ARM) trusted boot) may be a hardware-assisted entity that allows running system software to secure the identity of the platform on which the software is running. This prevents adversaries from taking over the control of a system at a very low-level, for example, by preventing boot of a malicious operating system kernel or by preventing emulation of the host to trick the software into running on an adversary-controlled execution environment (enclave). With the advent of hardware memory encryption, the root of trust role has been extended to provide secret keys via an out-of-band channel to the encryptor/decryptor <b>152</b> hardware that performs the cryptography operations in a controlled manner. In addition, there is a secure interface with the OS and hypervisor <b>168</b> to control which keys are used for which secure execution environments (e.g., VMs). The local root of trust <b>148</b> may include a CPU-based system that is physically isolated from the communication network <b>108</b> and controlled by firmware of the host device <b>112</b> (e.g., Basic-Input Output System (BIOS) firmware) to which the root of trust also provides security bootstrap services. Thus, software that runs on the host device <b>112</b> interacts with the host device <b>112</b> firmware to access specific, well-defined root of trust services.</p><p id="p-0054" num="0053">In at least one embodiment, the local root of trust <b>148</b> enables data encryption functions, detection and reporting of unauthorized changes to the OS or applications, detection of rootkits, memory curtaining, and/or digital rights management. As discussed in more detail below, the local root of trust <b>148</b> pairs with a root of trust of the CPU <b>146</b> to provide a distributed root of trust for the host device <b>112</b>.</p><p id="p-0055" num="0054">The encryptor/decryptor <b>152</b> includes suitable hardware and/or software for encrypting data and storing the encrypted data on encrypted memory <b>156</b>. The encryptor/decryptor <b>152</b> may further include suitable hardware and/or software for decrypting the data in encrypted memory <b>156</b>. The encryptor/decryptor <b>152</b> may encrypt data from the CPUs <b>160</b> using a key received from the local root of trust <b>148</b> over an isolated (secure) channel. The encrypted memory <b>156</b> may include volatile and/or non-volatile storage devices. Non-limiting examples of suitable memory devices for the encrypted memory <b>156</b> include flash memory, Random Access Memory (RAM), variants thereof, combinations thereof, or the like. The encrypted memory <b>156</b> may be main system memory of the host device <b>104</b> (as in <figref idref="DRAWINGS">FIG. <b>1</b></figref>), peripheral device dedicated memory (e.g., GPU memory), encrypted storage (e.g., NVMe Over Fabric), and/or storage class memory.</p><p id="p-0056" num="0055">The collection of CPUs <b>160</b> may include the same or similar processing circuitry as the CPU <b>118</b>. In one embodiment, the CPUs <b>132</b> include physical and/or logical processing units that execute operations for a respective virtual machine (VM) in a collection of VMs <b>164</b> created by a hypervisor <b>168</b>. The CPUs <b>160</b> and VMs <b>164</b> may be controlled by the hypervisor <b>168</b>.</p><p id="p-0057" num="0056">Here, it should be appreciated that although various elements of the system <b>100</b> are illustrated as separate entities, some elements may be integrated with one another within the system <b>100</b>. In addition, although not explicitly shown, it should be appreciated that host devices <b>104</b> and <b>112</b> may include other processing devices, storage devices, and/or communication interfaces generally associated with computing tasks, such as sending and receiving data. The system <b>100</b> may also include additional host devices with substantially the same structure as host devices <b>104</b> and <b>112</b>.</p><p id="p-0058" num="0057">As shown in <figref idref="DRAWINGS">FIG. <b>1</b></figref>, the NICs <b>116</b> and <b>144</b> enable secure key exchange between them by, for example, the CPUs <b>118</b> and <b>146</b> executing securely stored key exchange software stored thereon. Some key exchange operations, such as, operations for controlling the key exchange and/or the exchange of the actual key may occur over a secure backend channel between the CPUs <b>118</b> and <b>146</b>.</p><p id="p-0059" num="0058">Here, it should be appreciated that host devices <b>104</b> and <b>112</b> have encrypted memory support. In other words, the data stored in memories <b>128</b> and <b>156</b> (e.g., after the lowest point of coherency) are always encrypted. Encrypted memory support has different operating modes that may be classified in two main categories: transparent full memory encryption (where everything in memories <b>128</b> and <b>156</b> is encrypted with the same key&#x2014;referred to as Secure Memory Encryption); and a scheme that allows each virtual machine or each container (or more generally, each process) to use custom keys for the data in use. Since the memory contents are always encrypted, an illegal memory dump via a side channel has the additional challenge of breaking the symmetric key encryption (such AES) to read the data, which is intractable to solve.</p><p id="p-0060" num="0059">Inventive concepts relate to cases where the host devices <b>104</b> and <b>112</b> have enabled memory encryption support, which creates secure memory enclaves that allow the use of different keys (or the same key) for each application. The host devices <b>104</b> and <b>112</b> may run applications that perform RDMA transfers across the communication network <b>108</b>. In operation, the system <b>100</b> creates an isolated, secure, single encryption key domain that integrates the data-in-use security (i.e., data in memories <b>128</b> and <b>156</b>) of each host device <b>104</b> and <b>112</b> with data-in-motion introduced by RDMA between host devices <b>104</b> and <b>112</b> for two or more applications that want to exchange data. For example, <figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates encrypted data flows between host devices <b>104</b> and <b>112</b> where the encrypted data flows may correspond to encrypted RDMA transfers of data. Notably, the data remains encrypted throughout the RDMA transfer without being decrypted. In o</p><p id="p-0061" num="0060">As discussed in more detail below, the system <b>100</b> enables a single key domain between applications of the host devices <b>104</b> and <b>112</b> that leverage secure memory enclaves that also need to exchange data over RDMA include. Each NIC <b>116</b> and <b>144</b> has an RDMA payload encrypted for free and does not need to provide additional encryption support, thus consuming less power while still transferring encrypted data.</p><p id="p-0062" num="0061">In general, inventive concepts relate to assignment of a root of trust to the NIC CPUs <b>118</b> and <b>146</b> (e.g., with specific hardware and/or software) and integration of each NIC root of trust <b>120</b> and <b>148</b> with respective local roots of trust <b>120</b> and <b>148</b> to form a distributed root of trust that enables the NICs <b>116</b> and <b>144</b> to exchange keys to, for example, carry out encrypted RDMA operations between host devices <b>104</b> and <b>112</b>. In this context, each NIC <b>116</b> and <b>144</b> functions as an isolated key distributor that securely provides keys to applications running on host devices <b>104</b> and <b>112</b>. Each NIC <b>116</b> and <b>144</b> may also provide isolated key distribution to several different clients (e.g., VMs) on the same host while providing a secure domain for data-in-use (e.g., data in memory) and data-in-motion (e.g., data being transferred) with a single encryption key. As discussed in more detail below, inventive concepts further relate to a bring-up sequence of a secure domain for data-in-use and data-in-motion for applications that run on systems with encrypted memory support and that perform RDMA transfers, and the integration of Quantum Key distribution (QKD) with the aforementioned key distribution scheme.</p><p id="p-0063" num="0062">The distributed root of trust for secret key management features appropriately integrated endpoints on each host device <b>104</b> and <b>112</b>. For example, the distributed root of trust support on each host device <b>104</b> and <b>112</b> is provided by the NIC <b>116</b> and <b>144</b> and is hardened and isolated from user applications (e.g., VMs <b>136</b> and <b>164</b>). Subsequently, each distributed root of trust (provides its host device <b>104</b> and <b>112</b> with encryption keys via isolated channels that are used by the hardware-enabled encrypted memory support devices (e.g., encryptor/decryptor devices <b>124</b> and <b>152</b>). Host device firmware handles the integration of each NIC provided root of trust with the respective local root of trust. The system <b>100</b> is leveraged by hypervisors <b>140</b> and <b>168</b> (or by application loaders that run on each host device <b>104</b> and <b>112</b> with hypervisor privileges) that handle the synchronization steps between the host devices <b>104</b> and <b>112</b>, thereby enabling the same memory encryption key to be used by the applications that wish to establish an RDMA channel. Once coordination is completed, the hypervisor or loader on each host device <b>104</b>/<b>112</b> forks the application binaries (e.g., VMs <b>136</b>/<b>164</b>) to set the same key for the local secure memory enclaves <b>128</b> and <b>156</b>.</p><p id="p-0064" num="0063">Here, it should be appreciated that key exchange in <figref idref="DRAWINGS">FIG. <b>1</b></figref> may be performed with a suitable key exchange protocol, such as internet key exchange (IKE), MACsec, IPsec, virtual private network (VPN), and/or a suitable secure tunnel approach.</p><p id="p-0065" num="0064"><figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates a system <b>100</b>A according to at least one example embodiment. The system <b>100</b>A is substantially the same as system <b>100</b> in <figref idref="DRAWINGS">FIG. <b>1</b></figref> except that system <b>100</b>A includes dedicated QKD devices <b>172</b> and <b>176</b> and a dedicated QKD channel (e.g., optical fiber(s)). The QKD devices <b>172</b> and <b>176</b> and QKD channel may include suitable hardware and/or software for accomplishing the same key exchange concept in <figref idref="DRAWINGS">FIG. <b>1</b></figref> by exchanging keys according to suitable QKD methods and protocols. As shown in <figref idref="DRAWINGS">FIG. <b>2</b></figref>, the system <b>100</b>A may further include a QKD control channel between CPU <b>118</b> and CPU <b>146</b> for passing control signals related to QKD key exchange. For example, the QKD control channel may use in-band communication to pass control signals. In addition, the QKD control channel may also carry the key identifier while the QKD channel between QKD devices <b>172</b> and <b>176</b> is an isolated channel used to exchange the actual key associated with the key identifier.</p><p id="p-0066" num="0065">Example embodiments provide at least the following: 1) the distributed root of trust NIC-assisted concept; and 2) the formation of a single secret key domain between one or more applications that run on different virtual machines and use RDMA to exchange data.</p><p id="p-0067" num="0066"><figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates a method <b>300</b> according to at least one example embodiment. The method <b>300</b> may be carried out by one or more elements shown and described with reference to <figref idref="DRAWINGS">FIGS. <b>1</b> and <b>2</b></figref>. The operations of <figref idref="DRAWINGS">FIG. <b>3</b></figref> are described with reference to the host device <b>104</b>, but the operations of <figref idref="DRAWINGS">FIG. <b>3</b></figref> may be equally carried out on host device <b>112</b> or any other host device of the systems <b>100</b> and/or <b>100</b>A. The operations of <figref idref="DRAWINGS">FIG. <b>3</b></figref> may relate to the formation of a distributed root of trust in a host device to create a key that encrypts data stored in encrypted memory <b>128</b>, where that key is shared with a remote endpoint to enable encrypted data transfer operations.</p><p id="p-0068" num="0067">Example embodiments relate to an approach for adding the functionality of key exchange to the local root of trust of a host device by offloading the network part of the tasks to a root of trust service that runs on a NIC, for example, on a NIC's CPU complex. Thus, operation <b>304</b> may include pairing a NIC root of trust (e.g., the root of trust service programmed on CPU <b>118</b>) with a local root of trust <b>120</b> of the host device <b>104</b> connected to the NIC <b>116</b> to form a distributed root of trust that is distributed across the local root of trust <b>120</b> and the extended root of trust services of CPU <b>118</b>. The pairing process may occur each time NIC <b>116</b> is connected to a PCI-bus or other peripheral interconnect system of the host device <b>104</b> or upon the MC <b>116</b> receiving an instruction to pair with the host device <b>104</b>.</p><p id="p-0069" num="0068">The pairing process in operation <b>304</b> may include generating a combined root certificate that uniquely defines the specific host device <b>104</b> platform instance with the specific instance of the attached NIC <b>116</b>. Thereafter, the host device <b>104</b> access to the NIC CPU <b>118</b> is physically confined to be carried out by circuitry that can only be controlled by the local root of trust <b>120</b> and/or firmware of the host device <b>104</b>. As part of the pairing process, the CPU <b>118</b> runs a process that functions as part of the local root of trust firmware to provide a service for secure key exchange with remote counterparts (e.g., other NICs like NIC <b>144</b>) by leveraging the network access functions of the NIC <b>116</b>. Thereafter, the NIC-based distributed root of trust at host device <b>104</b> is ready to form secure connections to other root of trust endpoints (e.g., the distributed root of trust of host device <b>112</b>) within the datacenter or beyond to exchange keys.</p><p id="p-0070" num="0069">Operation <b>308</b> includes providing the key to an encryption device of the host device <b>104</b> to enable the encryption device to encrypt data of one or more host device applications. For example, the CPU <b>118</b> provides the key to the encryptor/decryptor <b>124</b> via an isolated channel that passes through the local root of trust <b>120</b>. Prior to providing the key to the encryptor/decryptor <b>124</b>, the NIC <b>116</b> (or suitable similar network device) may generate the key and an associated key identifier. For example, the CPU <b>118</b> includes a random generator that generates a key (e.g., a unique key) and an associated universally unique identifier (UUID) for the key. As discussed in more detail below, the key identifier may be useful because discovering the key identifier does not reveal the key. The encryptor/decryptor <b>124</b> may use the key to encrypt data of the one or more host device applications. The one or more host device applications may include applications executed by the VMs <b>136</b>.</p><p id="p-0071" num="0070">Operation <b>312</b> includes sharing the key with a remote endpoint. For example, the CPU <b>118</b> shares the key with the CPU <b>146</b> of NIC <b>144</b> within host device <b>112</b> according to a suitable key sharing technique, which may include backend communication. For example, key exchange may be performed with a suitable secure tunnel approach like VPN, IKE, MACsec, and/or the like. At least one example embodiment performs the key-exchange over a Quantum-key distribution system (QKD), as in <figref idref="DRAWINGS">FIG. <b>2</b></figref>. In order to identify the host device <b>112</b> as a remote endpoint, the administrator of the system <b>100</b> and/or <b>100</b>A may have a centralized service (e.g., domain name system (DNS)) or maintain a hardcoded list of host device identifiers that are available to the distributed root of trust formed in operation <b>304</b>.</p><p id="p-0072" num="0071">In at least one example embodiment, operation <b>312</b> includes the hypervisor <b>140</b> establishing an isolated channel with firmware that is dedicated and secure (i.e., the firmware cannot be overridden). The local root of trust <b>120</b> may receive a request from the hypervisor <b>140</b> via a firmware callback to set up a single key domain with one or more endpoints, such as, the host device <b>112</b> (see <figref idref="DRAWINGS">FIG. <b>5</b></figref>). The local root of trust <b>120</b> may then authenticate the request and relay the request to the distributed root of trust within the NIC <b>116</b> via the isolated channel. The root of trust on the NIC may use a backend to generate the key and associated key identifier pair and to securely exchange the key (and in some cases the key identifier) with the one or more remote endpoints.</p><p id="p-0073" num="0072">Operation <b>316</b> includes sending the key identifier associated with the key to the hypervisor <b>140</b> through the local root of trust <b>120</b> for use by the hypervisor <b>140</b> when opening the one or more host device applications. For example, upon completion of key exchange, the distributed root of trust at host device <b>104</b> securely notifies the hypervisor <b>140</b> of key exchange completion, thereby forming a single secret key domain between the host device <b>104</b> and any endpoint that participated in the secure key exchange. In addition, returning the key identifier to the hypervisor <b>140</b> notifies the hypervisor <b>140</b> that the key may be made available to encrypted memory engines of the one or more remote endpoints upon request. In at least one example embodiment, the key identifier is passed as an argument by the hypervisor <b>140</b> during the launch of an application so that a portion of the hypervisor's virtual address space is associated with the key. By using the key identifier instead of the key, the key used for encryption is not revealed. Upon request for installation of a particular key identifier, the particular key identifier and associated key are marked as consumed so as to not be reused. At this stage, the host device <b>104</b> has established a single key domain with one or more endpoints (e.g., host device <b>112</b>) in order to exchange encrypted data via, for example, RDMA.</p><p id="p-0074" num="0073">Operation <b>320</b> includes forwarding the encrypted data of the one or more host device applications from the host device memory (e.g., encrypted memory <b>128</b>) to a remote endpoint. For example, the system <b>100</b> and/or <b>100</b>A may execute an RDMA operation to transfer encrypted data from host device <b>104</b> to host device <b>112</b> without decrypting the data at any point during the transfer. Here, it should be appreciated that forwarding the encrypted data may include the NIC <b>116</b> passing the encrypted data from the collection of CPUs <b>132</b> to the communication network <b>108</b> without performing any additional operations on the data such as data decryption or further data encryption.</p><p id="p-0075" num="0074">An RDMA initialization sequence for operation <b>320</b> may include the following operations. Firstly, RDMA orchestration software (e.g., running on the host device <b>104</b>) is notified (e.g., by the host device <b>104</b>) that VMs (e.g., VMs <b>136</b> and <b>164</b>) or containers or specific processes (in the case of high performance computing (HPC)) will start on specific host devices (e.g., host devices <b>104</b> and <b>112</b>) with encrypted memory turned on and will be also performing RDMA. Subsequently, the RDMA orchestration software informs the hypervisor on each host device about the details used to launch host device applications, that encrypted memory support is activated, and that the host devices will participate to a single secret key domain. A specific hypervisor (e.g., hypervisor <b>140</b>) may designated as the key domain master for the purpose of initiating the distributed root of trust key exchange. Upon notification of established single key domain (i.e., the agreed secret key has been exchanged and is locally available on each endpoint), the host device application instances may be started on each host device <b>104</b> and <b>112</b>. Given that the keys at each endpoint are the same, the encrypted content that originates from the virtual address space of one application endpoint is readable by any remote counterpart without the need for any decryption during the network transfer. After proper launch as described above, a standard RDMA approach may be used both for channel setup as well as data exchange.</p><p id="p-0076" num="0075">The above-described RDMA initialization approach is not limited to any specific orchestrator or hypervisor or virtualization technology. The steps of leveraging the NIC-assisted distributed root of trust to bring up a single secret key domain for encrypted memory systems may be accomplished by a custom bootstrap process in any suitable application scenario. However, the NIC should not rely on packet information that has been added by host device applications (e.g., as it can happen with DPDK applications) that use encrypted memory for forwarding operations, as the packet information is not part of the secret key domain and the data are encrypted.</p><p id="p-0077" num="0076">Here, it should be appreciated that example embodiments provide for using a single key to encrypt data belonging to multiple different host device applications. In this case, the single key domain refers to using a single key to encrypt data for multiple host device applications. However, example embodiments also provide for using a separate key for each host device application that wishes to participate in encrypted data exchange. In this case, the single key domain refers to using a single key to encrypt data for a single host device application.</p><p id="p-0078" num="0077"><figref idref="DRAWINGS">FIG. <b>4</b></figref> illustrates a method <b>400</b> according to at least one example embodiment. The method <b>400</b> may be carried out by one or more elements shown and described with reference to <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>3</b></figref>. The operations of <figref idref="DRAWINGS">FIG. <b>4</b></figref> are described with reference to the host device <b>104</b>, but the operations of <figref idref="DRAWINGS">FIG. <b>4</b></figref> may be equally carried out on host device <b>112</b> or any other host device of the systems <b>100</b> and/or <b>100</b>A. The operations of <figref idref="DRAWINGS">FIG. <b>4</b></figref> may relate to creating a single key domain between endpoints to exchange encrypted data between the endpoints via RDMA operations.</p><p id="p-0079" num="0078">Operation <b>404</b> includes generating, by a network device connected to a host device, a key and associated key identifier. In this case, the network device may correspond to a NIC, such as NIC <b>116</b>, while the host device may correspond to host device <b>104</b>. The key and associated key identifier may be generated in the same manner as that described above.</p><p id="p-0080" num="0079">Operation <b>408</b> includes establishing, by the network device and over a communication network, a single key domain by sharing the key and the associated key identifier with at least one other network device. For example, the NIC <b>116</b> establishes a single key domain over communication network <b>108</b> in accordance with the operations described above and shares the key and associated key identifier with the NIC <b>144</b>.</p><p id="p-0081" num="0080">Operation <b>412</b> includes performing an RDMA operation within the single key domain to send data encrypted with the key over the communication network <b>108</b> to the at least one other network device. For example, as discussed above, host device applications running on host devices <b>104</b> and <b>112</b> exchange encrypted data via RDMA transfers. Thus, performing the RDMA operation may include forwarding, by the network device, the data encrypted with the key from the memory of the host device to the communication network. It should be appreciated that the data encrypted with the key stored in the memory of the host device remains encrypted with the key as the data travels from the memory through the network device and the communication network to the at least one other network device.</p><p id="p-0082" num="0081">Although not explicitly illustrated, the method <b>400</b> may include encrypting the data with the key and storing the encrypted data in memory of the host device (e.g., encrypted memory <b>128</b>). The method <b>400</b> may further include pairing the network device and the host device to enable the network device to generate the key and the associated key identifier.</p><p id="p-0083" num="0082">Notably, throughout methods <b>300</b> and <b>400</b>, the key exchanged between host devices <b>104</b> and <b>112</b> and that is used to encrypt data of applications running on the host devices is not revealed to the applications, and thus, cannot be read or modified by the applications. This feature is enabled because the distributed root of trust that handles key generation and exchange functions is physically isolated from access by the applications.</p><p id="p-0084" num="0083"><figref idref="DRAWINGS">FIG. <b>5</b></figref> illustrates a portion of the systems depicted in <figref idref="DRAWINGS">FIGS. <b>1</b> and <b>2</b></figref>. In particular, <figref idref="DRAWINGS">FIG. <b>5</b></figref> illustrates a virtual address space for the hypervisor <b>140</b> and the local root of trust <b>120</b> receiving requests from the hypervisor <b>140</b> to set up a single key domain via firmware callbacks. The local root of trust <b>120</b> may then authenticate the request and relay the request to the extended root of trust within the NIC <b>116</b> via the isolated channel. The extended root of trust within the NIC <b>116</b> may use a backend to generate the key and associated key identifier pair and to securely exchange the key (and in some cases the key identifier) with one or more remote endpoints (e.g., host device <b>112</b>).</p><p id="p-0085" num="0084">In view of <figref idref="DRAWINGS">FIGS. <b>1</b>-<b>5</b></figref>, it should be appreciated that example embodiments are directed to a NIC (e.g., NIC <b>116</b>) including processing circuitry (e.g., CPU <b>118</b>) configured to pair with a local root of trust (e.g., local root of trust <b>120</b>) of a host device (e.g., host device <b>104</b>) connected to the NIC. The processing circuitry is configured to provide a key to an encryption device (e.g., encryptor/decryptor <b>124</b>) of the host device that enables the encryption device to encrypt data of one or more host device applications using the key. The encrypted data being stored in host device memory (e.g., encrypted memory <b>128</b>). The processing circuitry is configured share the key with a remote endpoint (e.g., NIC <b>144</b> of host device <b>112</b>), and to forward the encrypted data from the host device memory to the remote endpoint.</p><p id="p-0086" num="0085">As discussed above, the processing circuitry is configured to share the key and a key identifier of the key with the remote endpoint, and after sharing the key and the key identifier with the remote endpoint, the processing circuitry is configured to send the key identifier to a hypervisor (e.g., hypervisor <b>140</b>) of the host device through the local root of trust for use by the hypervisor when opening the one or more host device applications. The NIC may include a designated channel that enables the processing circuitry to share the key with the remote endpoint. In at least one embodiment, the designated channel is configured for Quantum Key Distribution (QKD). As noted above, the processing circuitry is configured to pair with the local root of trust over an isolated channel between the NIC and the local root of trust. In at least one embodiment, the processing circuitry is configured to pair with the local root of trust based on a root certificate that associates the host device with the NIC. The processing circuitry is configured to share the key in response to a request from a hypervisor (e.g., hypervisor <b>140</b>) of the host device that passes through the local root of trust (see <figref idref="DRAWINGS">FIG. <b>5</b></figref>). In at least one embodiment, the processing circuitry is configured to pair with the local root of trust of the host device upon connection of the NIC to the host device. The processing circuitry may be configured to provide the key to the encryption device through the local root of trust.</p><p id="p-0087" num="0086">At least one example embodiment is directed to a system (e.g., system <b>100</b> or system <b>100</b>A) that includes a first host device (e.g., host device <b>104</b>) and a first network device (e.g., NIC <b>116</b>) coupled to the first host device. As discussed above, the first network device enables remote direct access memory (RDMA) operations for exchanging encrypted data over a communication network <b>108</b> with a second host device (e.g., host device <b>112</b>). The encrypted data are encrypted with a single key. The first network device may share the single key and an associated key identifier with the second network device. The encrypted data may belong to multiple applications running on the first host device and the second host device, or may belong to only one application running on the first host device and the second host device. Notably, the encrypted data remains encrypted throughout the RDMA operations.</p><p id="p-0088" num="0087">Example embodiments have been shown and described with respect to RDMA operations of encrypted data between endpoints with the assistance of a smart NIC, but it should be appreciated that example embodiments are applicable to any suitable case where data movement between two endpoint devices is required and both source and destination endpoints are able to operate on encrypted data. That is, example embodiments are not limited to RDMA operations and NICs; other data transfer operations may be employed and suitable peripheral devices other than a NIC (e.g., GPUs, a storage array with an integrated NIC like a network attached storage device, and/or the like) may be used to perform the functions of the NIC described herein.</p><p id="p-0089" num="0088">Specific details were given in the description to provide a thorough understanding of the embodiments. However, it will be understood by one of ordinary skill in the art that the embodiments may be practiced without these specific details. In other instances, well-known circuits, processes, algorithms, structures, and techniques may be shown without unnecessary detail in order to avoid obscuring the embodiments.</p><p id="p-0090" num="0089">While illustrative embodiments of the disclosure have been described in detail herein, it is to be understood that the inventive concepts may be otherwise variously embodied and employed, and that the appended claims are intended to be construed to include such variations, except as limited by the prior art.</p><p id="p-0091" num="0090">It should be appreciated that inventive concepts cover any embodiment in combination with any one or more other embodiment, any one or more of the features disclosed herein, any one or more of the features as substantially disclosed herein, any one or more of the features as substantially disclosed herein in combination with any one or more other features as substantially disclosed herein, any one of the aspects/features/embodiments in combination with any one or more other aspects/features/embodiments, use of any one or more of the embodiments or features as disclosed herein. It is to be appreciated that any feature described herein can be claimed in combination with any other feature(s) as described herein, regardless of whether the features come from the same described embodiment.</p><p id="p-0092" num="0091">Example embodiments may be configured as follows:</p><p id="p-0093" num="0000">(1) A network interface controller (NIC), comprising:<ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0092">processing circuitry configured to:        <ul id="ul0003" list-style="none">            <li id="ul0003-0001" num="0093">pair with a local root of trust of a host device connected to the NIC;</li>            <li id="ul0003-0002" num="0094">provide a key to an encryption device of the host device that enables the encryption device to encrypt data of one or more host device applications using the key, the encrypted data being stored in host device memory;</li>            <li id="ul0003-0003" num="0095">share the key with a remote endpoint; and</li>            <li id="ul0003-0004" num="0096">forward the encrypted data from the host device memory to the remote endpoint.<br/>(2) The NIC of (1), wherein the processing circuitry is configured to share the key and a key identifier of the key with the remote endpoint.<br/>(3) The NIC of one or more of (1) to (2), wherein, after sharing the key and the key identifier with the remote endpoint, the processing circuitry is configured to send the key identifier to a hypervisor of the host device through the local root of trust for use by the hypervisor when opening the one or more host device applications.<br/>(4) The NIC of one or more of (1) to (3), further comprising:</li>        </ul>        </li>        <li id="ul0002-0002" num="0097">a designated channel that enables the processing circuitry to share the key with the remote endpoint.<br/>(5) The NIC of one or more of (1) to (4), wherein the designated channel is configured for Quantum Key Distribution (QKD).<br/>(6) The NIC of one or more of (1) to (5), wherein the processing circuitry is configured to pair with the local root of trust over an isolated channel.<br/>(7) The NIC of one or more of (1) to (6), wherein the processing circuitry is configured to pair with the local root of trust based on a root certificate that associates the host device with the NIC.<br/>(8) The NIC of one or more of (1) to (7), wherein the processing circuitry is configured to share the key in response to a request from a hypervisor of the host device that passes through the local root of trust.<br/>(9) The NIC of one or more of (1) to (8), wherein the processing circuitry is configured to pair with the local root of trust of the host device upon connection of the NIC to the host device.<br/>(10) The NIC of one or more of (1) to (9), wherein the processing circuitry is configured to provide the key to the encryption device through the local root of trust without the key being accessible to the one or more host device applications.<br/>(11) A method, comprising:</li>        <li id="ul0002-0003" num="0098">generating, by a network device connected to a host device, a key and associated key identifier;</li>        <li id="ul0002-0004" num="0099">establishing, by the network device and over a communication network, a single key domain by sharing the key and the associated key identifier with at least one other network device; and</li>        <li id="ul0002-0005" num="0100">performing a remote direct access memory (RDMA) operation within the single key domain to send data encrypted with the key over the communication network to the at least one other network device.<br/>(12) The method of one or more of (11) to (11), further comprising:</li>        <li id="ul0002-0006" num="0101">encrypting the data with the key; and</li>        <li id="ul0002-0007" num="0102">storing the data encrypted with the key in a memory of the host device.<br/>(13) The method of one or more of (11) to (12), wherein performing the RDMA operation includes forwarding, by the network device, the data encrypted with the key from the memory of the host device to the communication network.<br/>(14) The method of one or more of (11) to (13), wherein the data encrypted with the key stored in the memory of the host device remains encrypted with the key as the data travels from the memory through the network device and the communication network to the at least one other network device.<br/>(15) The method of one or more of (11) to (14), wherein the key is shared via quantum key distribution (QKD).<br/>(16) The method of one or more of (11) to (15), further comprising:</li>        <li id="ul0002-0008" num="0103">pairing the network device and the host device to enable the network device to generate the key and the associated key identifier.<br/>(17) A system, comprising:</li>        <li id="ul0002-0009" num="0104">a first host device; and</li>        <li id="ul0002-0010" num="0105">a first network device coupled to the first host device, the first network device enabling remote direct access memory (RDMA) operations for exchanging encrypted data over a communication network with a second host device, wherein the encrypted data are encrypted with a single key.<br/>(18) The system of one or more of (1) to (17), wherein the first network device shares the single key and an associated key identifier with the second network device.<br/>(19) The system of one or more of (1) to (18), wherein the encrypted data belong to multiple applications running on the first host device and the second host device.<br/>(20) The system of one or more of (1) to (19), wherein the encrypted data remains encrypted throughout the RDMA operations.</li>    </ul>    </li></ul></p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A network interface controller (NIC), comprising:<claim-text>processing circuitry configured to:<claim-text>pair with a local root of trust of a host device connected to the NIC;</claim-text><claim-text>provide a key to an encryption device of the host device that enables the encryption device to encrypt data of one or more host device applications using the key, the encrypted data being stored in host device memory;</claim-text><claim-text>share the key with a remote endpoint; and</claim-text><claim-text>forward the encrypted data from the host device memory to the remote endpoint.</claim-text></claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The NIC of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the processing circuitry is configured to share the key and a key identifier of the key with the remote endpoint.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The NIC of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein, after sharing the key and the key identifier with the remote endpoint, the processing circuitry is configured to send the key identifier to a hypervisor of the host device through the local root of trust for use by the hypervisor when opening the one or more host device applications.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The NIC of <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising:<claim-text>a designated channel that enables the processing circuitry to share the key with the remote endpoint.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The NIC of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the designated channel is configured for Quantum Key Distribution (QKD).</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The NIC of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the processing circuitry is configured to pair with the local root of trust over an isolated channel.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The NIC of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the processing circuitry is configured to pair with the local root of trust based on a root certificate that associates the host device with the MC.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The NIC of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the processing circuitry is configured to share the key in response to a request from a hypervisor of the host device that passes through the local root of trust.</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The NIC of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the processing circuitry is configured to pair with the local root of trust of the host device upon connection of the NIC to the host device.</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The NIC of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the processing circuitry is configured to provide the key to the encryption device through the local root of trust without the key being accessible to the one or more host device applications.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. A method, comprising:<claim-text>generating, by a network device connected to a host device, a key and associated key identifier;</claim-text><claim-text>establishing, by the network device and over a communication network, a single key domain by sharing the key and the associated key identifier with at least one other network device; and</claim-text><claim-text>performing a remote direct access memory (RDMA) operation within the single key domain to send data encrypted with the key over the communication network to the at least one other network device.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, further comprising:<claim-text>encrypting the data with the key; and</claim-text><claim-text>storing the data encrypted with the key in a memory of the host device.</claim-text></claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The method of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein performing the RDMA operation includes forwarding, by the network device, the data encrypted with the key from the memory of the host device to the communication network.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The method of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the data encrypted with the key stored in the memory of the host device remains encrypted with the key as the data travels from the memory through the network device and the communication network to the at least one other network device.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the key is shared via quantum key distribution (QKD).</claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, further comprising:<claim-text>pairing the network device and the host device to enable the network device to generate the key and the associated key identifier.</claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. A system, comprising:<claim-text>a first host device; and</claim-text><claim-text>a first network device coupled to the first host device, the first network device enabling remote direct access memory (RDMA) operations for exchanging encrypted data over a communication network with a second host device, wherein the encrypted data are encrypted with a single key.</claim-text></claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The system of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the first network device shares the single key and an associated key identifier with the second network device.</claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The system of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the encrypted data belong to multiple applications running on the first host device and the second host device.</claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The system of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the encrypted data remains encrypted throughout the RDMA operations.</claim-text></claim></claims></us-patent-application>