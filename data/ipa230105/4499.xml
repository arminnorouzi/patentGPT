<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004500A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004500</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17941587</doc-number><date>20220909</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0888</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0891</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>54</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>02</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0811</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>128</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0817</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0804</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>30</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>11</class><subclass>C</subclass><main-group>7</main-group><subgroup>10</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>11</class><subclass>C</subclass><main-group>29</main-group><subgroup>42</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>11</class><subclass>C</subclass><main-group>29</main-group><subgroup>44</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>11</main-group><subgroup>10</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0855</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>12</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0806</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0815</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0853</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>13</main-group><subgroup>16</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>121</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0884</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0897</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0895</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0864</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>11</class><subclass>C</subclass><main-group>7</main-group><subgroup>22</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>11</class><subclass>C</subclass><main-group>5</main-group><subgroup>06</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>15</main-group><subgroup>80</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0802</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0888</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0891</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>546</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0215</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0238</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0811</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>128</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>082</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0804</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>3001</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>9</main-group><subgroup>30047</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>11</class><subclass>C</subclass><main-group>7</main-group><subgroup>106</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>11</class><subclass>C</subclass><main-group>7</main-group><subgroup>1087</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>11</class><subclass>C</subclass><main-group>29</main-group><subgroup>42</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>11</class><subclass>C</subclass><main-group>29</main-group><subgroup>44</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>11</main-group><subgroup>1064</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0855</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>12</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0806</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0815</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0853</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>13</main-group><subgroup>1605</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>121</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0292</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0884</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0897</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0895</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0864</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>11</class><subclass>C</subclass><main-group>7</main-group><subgroup>222</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>11</class><subclass>C</subclass><main-group>7</main-group><subgroup>1075</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>11</class><subclass>C</subclass><main-group>7</main-group><subgroup>1078</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>13</main-group><subgroup>1642</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>13</main-group><subgroup>1673</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>13</main-group><subgroup>1689</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>11</class><subclass>C</subclass><main-group>5</main-group><subgroup>066</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>11</class><subclass>C</subclass><main-group>7</main-group><subgroup>10</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>11</class><subclass>C</subclass><main-group>7</main-group><subgroup>1015</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>15</main-group><subgroup>8069</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>12</main-group><subgroup>0802</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>2212</main-group><subgroup>1021</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>2212</main-group><subgroup>608</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130401</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>2212</main-group><subgroup>6032</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>2212</main-group><subgroup>1024</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>2212</main-group><subgroup>62</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>2212</main-group><subgroup>1016</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>2212</main-group><subgroup>1041</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>2212</main-group><subgroup>1044</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>2212</main-group><subgroup>301</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>2212</main-group><subgroup>454</subgroup><symbol-position>L</symbol-position><classification-value>A</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">AGGRESSIVE WRITE FLUSH SCHEME FOR A VICTIM CACHE</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>16882374</doc-number><date>20200522</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11442868</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17941587</doc-number></document-id></child-doc></relation></continuation><us-provisional-application><document-id><country>US</country><doc-number>62852494</doc-number><date>20190524</date></document-id></us-provisional-application></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="obligated-assignee"><addressbook><orgname>TEXAS INSTRUMENTS INCORPORATED</orgname><address><city>Dallas</city><state>TX</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>BHORIA</last-name><first-name>Naveen</first-name><address><city>Plano</city><state>TX</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>ANDERSON</last-name><first-name>Timothy David</first-name><address><city>University Park</city><state>TX</state><country>US</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>HIPPLEHEUSER</last-name><first-name>Pete</first-name><address><city>Murphy</city><state>TX</state><country>US</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A caching system including a first sub-cache and a second sub-cache in parallel with the first sub-cache, wherein the second sub-cache includes: line type bits configured to store an indication that a corresponding cache line of the second sub-cache is configured to store write-miss data, and an eviction controller configured to evict a cache line of the second sub-cache storing write-miss data based on an indication that the cache line has been fully written.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="76.79mm" wi="137.84mm" file="US20230004500A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="243.92mm" wi="159.26mm" orientation="landscape" file="US20230004500A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="255.27mm" wi="170.01mm" orientation="landscape" file="US20230004500A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="234.02mm" wi="159.85mm" file="US20230004500A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="142.66mm" wi="137.75mm" file="US20230004500A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="254.00mm" wi="168.99mm" orientation="landscape" file="US20230004500A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="239.35mm" wi="134.28mm" file="US20230004500A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="247.90mm" wi="169.25mm" orientation="landscape" file="US20230004500A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="172.72mm" wi="115.06mm" file="US20230004500A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="180.26mm" wi="119.04mm" file="US20230004500A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="180.51mm" wi="111.00mm" file="US20230004500A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="212.17mm" wi="130.98mm" file="US20230004500A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="235.80mm" wi="107.02mm" file="US20230004500A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="154.69mm" wi="115.06mm" file="US20230004500A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00014" num="00014"><img id="EMI-D00014" he="144.19mm" wi="75.01mm" file="US20230004500A1-20230105-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATION</heading><p id="p-0002" num="0001">This application is a continuation of U.S. patent application Ser. No. 16/882,378, filed May 22, 2020, which is scheduled to issue as U.S. Pat. No. 11,442,165 on Sep. 13, 2022, and which claims priority to U.S. Provisional Patent Application Ser. No. 62/852,494, filed May 24, 2019, titled &#x201c;Data Caches and Related Systems and Methods,&#x201d; each of which is hereby incorporated herein by reference in its entirety.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">BACKGROUND</heading><p id="p-0003" num="0002">In a multi-core coherent system, multiple processor and system components share the same memory resources, such as on-chip and off-chip memories. Memory caches (e.g., caches) typically are an amount of high-speed memory located operationally near (e.g., close to) a processor. A cache is more operationally nearer to a processor based on latency of the cache, that is, one many processor clock cycles for the cache to fulfill a memory request. Generally, cache memory closest to a processor includes a level 1 (L1) cache that is often directly on a die with the processor. Many processors also include a larger level 2 (L2) cache. This L2 cache is generally slower than the L1 cache but may still be on the die with the processor cores. The L2 cache may be a per processor core cache or shared across multiple cores. Often, a larger, slower L3 cache, either on die, as a separate component, or another portion of a system on a chip (SoC) is also available to the processor cores.</p><p id="p-0004" num="0003">Memory systems such as caches can be susceptible to data corruption, for example, due to electronic or magnetic interference from cosmic rays, solar particles, or malicious memory accesses. As processors are increasingly used in critical and/or other fault-intolerant systems, such as self-driving vehicles and autonomous systems, techniques to protect memory systems from data corruption are increasingly being applied to the memory systems. One such technique is the use of error correcting codes (ECC) to detect and correct memory corruption. Implementing ECC in high speed cache memory is challenging as ECC can introduce additional timing overhead that needs to be accounted for. For example, a high speed cache memory system may have a five stage memory pipeline for determining whether a memory address being accessed is in the cache and retrieving the contents of the cache memory. Each stage may take one clock cycle, which at 1 GHz, is about one nanosecond. Error checking the contents of the cache memory can substantially take up a full clock cycle. What is needed are techniques for increasing cache performance for fault tolerant caches.</p><heading id="h-0003" level="1">SUMMARY</heading><p id="p-0005" num="0004">This disclosure relates to a caching system. More particularly, but not by way of limitation, aspects of the present disclosure relate to a caching system including a first sub-cache and a second sub-cache in parallel with the first sub-cache, wherein the second sub-cache includes a set of cache lines, line type bits configured to store an indication that a corresponding cache line of the set of cache lines is configured to store write-miss data, and an eviction controller configured to flush stored write-miss data based on the line type bits.</p><p id="p-0006" num="0005">Another aspect of the present disclosure relates to a method for caching data including receiving, by a caching system, a write memory request for a memory address, determining, by a first sub-cache of the caching system, that the memory address is not cached in the first sub-cache, determining, by second sub-cache of the caching system, that the memory address is not cached in the second sub-cache, storing data associated with the write memory request in the second sub-cache, storing, in a line type bit of the second sub-cache, an indication that the stored data corresponds to a write-miss, and flushing the stored data based on the indication.</p><p id="p-0007" num="0006">Another aspect of the present disclosure relates to a device including a first sub-cache, and a second sub-cache in parallel with the first sub-cache; wherein the second sub-cache includes a set of cache lines, line type bits configured store an indication that a corresponding cache line of the set of cache lines is configured to store write-miss data, and an eviction controller configured to flush stored write-miss data based on the line type bits.</p><p id="p-0008" num="0007">Another aspect of the present disclosure relate to a caching system including a first sub-cache and a second sub-cache in parallel with the first sub-cache, wherein the second sub-cache includes: a set of cache lines, line type bits configured to store an indication that a corresponding line of the set of cache lines is configured to store write-miss data, and an eviction controller configured to evict a cache line of the second sub-cache storing write-miss data based on an indication that the cache line has been fully written.</p><p id="p-0009" num="0008">Another aspect of the present disclosure relates to a method for caching data, including receiving, by a caching system, a write memory request for a memory address, determining, by a first sub-cache of the caching system, that the memory address is not cached in the first sub-cache, determining, by second sub-cache of the caching system, that the memory address is not cached in the second sub-cache, storing data associated with the write memory request in the second sub-cache, storing, in a line type bit of the second sub-cache, an indication that the stored data corresponds to a write-miss, and evicting a cache line of the second sub-cache storing the write-miss based on an indication that the cache line has been fully written.</p><p id="p-0010" num="0009">Another aspect of the present disclosure relates to a device including a processor, a first sub-cache, and a second sub-cache in parallel with the first sub-cache, wherein the second sub-cache includes: a set of cache lines, line type bits configured to store an indication that a corresponding line of the set of cache lines is configured to store write-miss data, and an eviction controller configured to evict a cache line of the second sub-cache storing write-miss data based on an indication that the cache line has been fully written.</p><p id="p-0011" num="0010">Another aspect of the present disclosure relates to a caching system including a first sub-cache, and a second sub-cache, coupled in parallel with the first cache, for storing cache data evicted from the first sub-cache and write-memory commands that are not cached in the first sub-cache, and wherein the second sub-cache includes: color tag bits configured to store an indication that a corresponding cache line of the second sub-cache storing write miss data is associated with a color tag, and an eviction controller configured to evict cache lines of the second sub-cache storing write-miss data based on the color tag associated with the cache line.</p><p id="p-0012" num="0011">Another aspect of the present disclosure relates to a method for caching data, including receiving, by a caching system, a write memory command for a memory address, determining, by a first sub-cache of the caching system, that the memory address is not cached in the first sub-cache, determining, by second sub-cache of the caching system, that the memory address is not cached in the second sub-cache, wherein the second sub-cache is configured to store, in parallel with the first sub-cache, cache data evicted from the first sub-cache and write-memory commands that are not cached in the first sub-cache, storing data associated with the write memory command in the second sub-cache, storing, in the second sub-cache, a color tag bit associated with the data, and evicting the stored data based on the color tag bit.</p><p id="p-0013" num="0012">Another aspect of the present disclosure relates to a device including a a processor, a first sub-cache, and a second sub-cache, coupled in parallel with the first cache, for storing cache data evicted from the first sub-cache and write-memory commands that are not cached in the first sub-cache, and wherein the second sub-cache includes: color tag bits configured to store an indication that a corresponding cache line of the second sub-cache storing write-miss data is associated with a color tag, and an eviction controller configured to evict the cache line of the second sub-cache storing write-miss data based on the color tag associated with the cache line.</p><p id="p-0014" num="0013">Another aspect of the present disclosure relates to techniques for caching data by a caching system, the caching system including a first sub-cache, and a second sub-cache, coupled in parallel with the first sub-cache, for storing cache data evicted from the first sub-cache and write-memory commands that are not cached in the first sub-cache, the second sub-cache including color tag bits configured to store an indication that a corresponding line of the second sub-cache is associated with a color tag, and an eviction controller configured to evict cache lines of the second sub-cache storing write-memory data based on the color tag associated with the line, and wherein the second sub-cache is further configured to: receive a first write memory command for a memory address, the write memory command associated with a first color tag, store first data associated with the first write memory command in a cache line of the second sub-cache, store the first color tag in the second sub-cache, receive a second write memory command for the cache line, the write memory command associated with a second color tag, merge the second color tag with the first color tag, store the merged color tag, and evict the cache line based on the merged color tag.</p><p id="p-0015" num="0014">Another aspect of the present disclosure relates to a method for caching data, including receiving, by a caching system, a write memory command for a memory address, the write memory command associated with a first color tag, determining, by a first sub-cache of the caching system, that the memory address is not cached in the first sub-cache, determining, by second sub-cache of the caching system, that the memory address is not cached in the second sub-cache, wherein the second sub-cache is configured to store, in parallel with the first sub-cache, cache data evicted from the first sub-cache and write-memory commands that are not cached in the first sub-cache, storing first data associated with the first write memory command in a cache line of the second sub-cache, storing the first color tag in the second sub-cache, receiving a second write memory command for the cache line, the write memory command associated with a second color tag, merging the second color tag with the first color tag, storing the merged color tag, and evicting the cache line based on the merged color tag.</p><p id="p-0016" num="0015">Another aspect of the present disclosure relates to a device including a processor, a first sub-cache, and a second sub-cache, coupled in parallel with the first sub-cache, for storing cache data evicted from the first sub-cache and write-memory commands that are not cached in the first sub-cache, and the second sub-cache including color tag bits configured to store an indication that a corresponding line of the second sub-cache is associated with a color tag, and an eviction controller configured to evict cache lines of the second sub-cache storing write-memory data based on the color tag associated with the line, and wherein the second sub-cache is further configured to receive a first write memory command for a memory address, the write memory command associated with a first color tag, store first data associated with the first write memory command in a cache line of the second sub-cache, store the first color tag in the second sub-cache, receive a second write memory command for the cache line, the write memory command associated with a second color tag, merge the second color tag with the first color tag, store the merged color tag; and evict the cache line based on the merged color tag.</p><p id="p-0017" num="0016">Another aspect of the present disclosure relates to a caching system including a first sub-cache, a second sub-cache coupled in parallel with the first sub-cache, for storing cache data evicted from the first sub-cache and write-memory commands that are not cached in the first sub-cache, the second sub-cache including privilege bits configured to store an indication that a corresponding cache line of the second sub-cache is associated with a level of privilege, and wherein the second sub-cache is further configured to receive a first write memory command for a memory address, the first write memory command associated with a first level of privilege, store, in a cache line of the second sub-cache, first data associated with the first write memory command, store, in the second sub-cache, the level of privilege associated with the cache line, receive a second write memory command for the cache line, the second write memory command associated with a second level of privilege, merge the first level of privilege with the second level of privilege, store the merged privilege level, and output the merged privilege level with the cache line.</p><p id="p-0018" num="0017">Another aspect of the present disclosure relates to a method for caching data, including receiving, by a caching system, a first write memory command for a memory address, the first write memory command associated with a first privilege level, determining, by a first sub-cache of the caching system, that the memory address is not cached in the first sub-cache, determining, by second sub-cache of the caching system, that the memory address is not cached in the second sub-cache, wherein the second sub-cache is configured to store, in parallel with the first sub-cache, cache data evicted from the first sub-cache and write-memory commands that are not cached in the first sub-cache, storing first data associated with the first write memory command in a cache line of the second sub-cache, storing the first privilege level in the second sub-cache, receiving a second write memory command for the cache line, the second write memory command associated with a second level of privilege, merging the first level of privilege with the second level of privilege, storing the merged privilege level, and outputting the merged privilege level with the cache line.</p><p id="p-0019" num="0018">Another aspect of the present disclosure relates to a device including a processor, a first sub-cache, and a second sub-cache, coupled in parallel with the first sub-cache, for storing cache data evicted from the first sub-cache and write-memory commands that are not cached in the first sub-cache, the second sub-cache including privilege bits configured to store an indication that a corresponding cache line of the second sub-cache is associated with a level of privilege, and wherein the second sub-cache is further configured to receive a first write memory command for a memory address, the first write memory command associated with a first level of privilege, store, in a cache line of the second sub-cache, first data associated with the first write memory command, store, in the second sub-cache, the level of privilege associated with the cache line, receive a second write memory command for the cache line, the second write memory command associated with a second level of privilege, merge the first level of privilege with the second level of privilege, store the merged privilege level, and output the merged privilege level with the cache line.</p><p id="p-0020" num="0019">Another aspect of the present disclosure relates to a caching system including a first sub-cache, and a second sub-cache coupled in parallel with the first sub-cache; wherein the second sub-cache includes line type bits configured to store an indication that a corresponding line of the second sub-cache is configured to store write-miss data.</p><p id="p-0021" num="0020">Another aspect of the present disclosure relates to a method for caching data including receiving, by a caching system, a write memory request for a memory address, determining, by a first sub-cache of the caching system, that the memory address is not cached in the first sub-cache, determining, by second sub-cache of the caching system, the second sub-cache coupled in parallel with the first sub-cache, that the memory address is not cached in the second sub-cache, storing data associated with the write memory request in the second sub-cache, and storing, in a line type bit of the second sub-cache, an indication that the stored data corresponds to a write-miss.</p><p id="p-0022" num="0021">Another aspect of the present disclosure relates to a device including a processor, a first sub-cache, and a second sub-cache coupled in parallel with the first sub-cache; wherein the second sub-cache includes line type bits configured to store an indication that a corresponding line of the second sub-cache is configured to store write-miss data.</p><p id="p-0023" num="0022">Another aspect of the present disclosure relates to a caching system including a first sub-cache, a second sub-cache, coupled in parallel with the first sub-cache, for storing cache data evicted from the first sub-cache and write-memory commands that are not cached in the first sub-cache, and a cache controller configured to receive two or more cache commands, determine a conflict exists between the received two or more cache commands, determine a conflict resolution between the received two or more cache commands, and sending the two or more cache commands to the first sub-cache and the second sub-cache.</p><p id="p-0024" num="0023">Another aspect of the present disclosure relates to a method for caching data including receiving two or more cache commands, determining a conflict exists between the two or more cache commands, determining a conflict resolution between the received two or more cache commands, and sending the two or more cache commands to a first sub-cache and a second sub-cache, wherein the second sub-cache is configured to store, in parallel with the first sub-cache, cache data evicted from the first sub-cache and write-memory commands that are not cached in the first sub-cache.</p><p id="p-0025" num="0024">Another aspect of the present disclosure relates to a device including a a processor, a first sub-cache, and a second sub-cache, coupled in parallel with the first sub-cache, for storing cache data evicted from the first sub-cache and write-memory commands that are not cached in the first sub-cache, and a cache controller configured to receive two or more cache commands, determine a conflict exists between the received two or more cache commands, determine a conflict resolution between the received two or more cache commands, and sending the two or more cache commands to the first sub-cache and the second sub-cache.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0026" num="0025">For a detailed description of various examples, reference will now be made to the accompanying drawings in which:</p><p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram of a computer system.</p><p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. <b>2</b></figref> is a block diagram illustrating a simplified cache memory pipeline for processing a read request.</p><p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a block diagram of a cache memory pipeline with a store queue, in accordance with aspects of the present disclosure.</p><p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a block diagram illustrating a cache architecture including a victim cache.</p><p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. <b>5</b></figref> is a block diagram illustrating a cache architecture including a parallel victim cache, in accordance with aspects of the present disclosure.</p><p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a block diagram illustrating a victim cache memory pipeline, in accordance with aspects of the present disclosure.</p><p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a block diagram illustrating a victim cache pipeline including a write-miss buffer, in accordance with aspects of the present disclosure.</p><p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a block diagram of a MESI RAM, in accordance with aspects of the present disclosure.</p><p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is an architectural block diagram of a cache system including a write-miss buffer, in accordance with aspects of the present disclosure.</p><p id="p-0036" num="0035"><figref idref="DRAWINGS">FIGS. <b>10</b>-<b>16</b></figref> are flow diagrams illustrating techniques for caching data, in accordance with aspects of the present disclosure.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0005" level="1">DETAILED DESCRIPTION</heading><p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. <b>1</b></figref> is a block diagram of a computer system <b>100</b>. The computer system <b>100</b> includes a data cache <b>102</b>, such as a level one (L1) data cache. The data cache <b>102</b> stores a subset of the system's data to reduce the time needed to access (e.g., read and/or write) the cached subset. By effectively caching the most commonly used data, the data cache <b>102</b> may markedly improve system performance.</p><p id="p-0038" num="0037">The data cache <b>102</b> may be coupled to one or more processing resources <b>104</b> (e.g., processor cores) and to an extended memory <b>106</b>. The extended memory <b>106</b> includes other levels of a memory hierarchy, such as an L2 cache, storage devices, etc. The data cache <b>102</b> may be incorporated into the same die as the processing resource(s) <b>104</b> (e.g., on-die cache) or may be on a separate die. In either case, the cache <b>102</b> is coupled to each processing resource <b>104</b> by one or more interfaces used to exchange data between the cache <b>102</b> and the processing resource. In this example, the cache <b>102</b> is coupled to each processing resource <b>104</b> by a scalar interface and a vector interface. In examples with more than one interface, in the event that one interface is busy, a command may be serviced using another interface. For example, when a scalar read command is received by the cache over the scalar interface, the associated data may be provided to the processing resource <b>104</b> over the vector interface based on interface utilization, data size, and/or other considerations. Similarly, the cache <b>102</b> may also be coupled to the extended memory <b>106</b> by one or more interfaces. Where more than one interface is present, an interface may be selected based on utilization, data size, and/or other considerations.</p><p id="p-0039" num="0038">Each interface may have any suitable width. The widths of the interfaces may be different from each other, although in many examples, they are integer multiplies of the narrowest interface. In one such example, the scalar interface is 64 bits wide, the vector interface is 512 bits wide, and the extended memory interface is 1024 bits wide.</p><p id="p-0040" num="0039">The interfaces may be bidirectional or unidirectional. Bidirectional interfaces may include two independent unidirectional interfaces so that data can be transmitted and received concurrently. In one such example, the vector interface includes two 512-bit unidirectional busses, one for receiving data and operations from the processing resource <b>104</b>, and one for sending data to the processing resource <b>104</b>.</p><p id="p-0041" num="0040">The data cache <b>102</b> may include a number of pipelines for processing operations received via these interfaces. <figref idref="DRAWINGS">FIG. <b>2</b></figref> is a block diagram illustrating a simplified cache memory pipeline <b>200</b> for processing a read request. As shown in the cache memory pipeline <b>200</b>, a processor <b>202</b> sends a memory request to a cache memory <b>204</b>. While the cache memory <b>204</b> is described in the context of a L1 cache, the concepts discussed herein may be understood as applicable to any type of cache memory. In certain cases, the memory request may be sent via a cache or memory controller, not shown. In this example, the cache memory pipeline includes five stages, E1, E2, E3, E4, and E5. Each cache memory pipeline stage may be allocated a specific number of clock cycles to complete, and in some examples, each stage is allocated one clock cycle such that cached data may be returned to the processor <b>202</b> after the E5 memory pipeline stage in five clock cycles. In the E1 memory pipeline stage, a memory request is received by the cache memory <b>204</b>. The memory request includes a memory address of the data to be retrieved from. In the E2 pipe stage, a tag random access memory (RAM) <b>206</b> is read to determine what memory addresses are currently store in the cache memory. The tag RAM <b>206</b> stores a table that records which entries in the memory <b>208</b> correspond to which memory addresses in an extended memory. The tag RAM may be a bank or portion of memory used to hold the table of memory addresses. In certain cases, the cache may be a N-way associative cache where each cache set can hold N lines of memory addresses. As N increases, the number of addresses which are searched through also increases, which in turn increases the amount of time needed to determine whether a requested memory address is in the tag RAM. In the E3 memory pipeline stage, the received memory address is compared to memory addresses stored read from the tag RAM to determine whether there is a cache hit or miss. A cache hit occurs when data associated with a requested memory address is stored in the cache and a cache miss occurs when data associated with the requested memory address is not stored in the cache. In the E4 memory pipeline stage, a portion of the memory <b>208</b> associated with the requested memory address is read and at the E5 memory pipeline stage, the requested memory address is provided to the processor <b>202</b>. The memory <b>208</b> may be any type of memory suitable for a cache memory, such as dynamic random-access memory (DRAM), static random-access memory (SRAM), registers, etc. It may be understood that the pipeline stages, as described, are for illustrating how a memory pipeline can be configured, and as such, omit certain sub-steps and features. In certain implementations, the stages in which certain activities, such as the memory access, are performed may differ.</p><p id="p-0042" num="0041"><figref idref="DRAWINGS">FIG. <b>3</b></figref> is a block diagram illustrating a cache pipeline <b>300</b> supporting read-modify-write with error-correcting code store queue architecture, in accordance with aspects of the present disclosure. The pipeline <b>300</b> includes a read path (with read path latches <b>302</b>, tag RAM <b>306</b>, memory <b>308</b>, etc.), and write path (write path latches <b>304</b>, store queue <b>314</b>, etc.).</p><p id="p-0043" num="0042">With respect to the read path, the pipeline <b>300</b> includes a tag RAM <b>306</b> and a memory <b>308</b> (e.g., DRAM or other suitable memory). The cache may have any degree of associativity, and in an example, the cache is a direct-mapped cache such that each extended memory address corresponds to exactly one entry in the cache memory <b>308</b>.</p><p id="p-0044" num="0043">In certain cases, the cache pipeline <b>300</b> may include support for ECC and the memory <b>308</b> may be coupled to an error detection and correction circuit <b>310</b>. In an ECC example, the memory <b>308</b> stores data in blocks along with a set of ECC syndrome bits that correspond to the blocks. When a read operation is received, the memory <b>308</b> may provide the stored data block and the corresponding ECC syndrome bits to the error detection and correction circuit <b>310</b>. The error detection and correction circuit <b>310</b> may regenerate the ECC syndrome bits based on the data block as read from the memory <b>208</b> and compare the regenerated ECC syndrome bits with those that were previously stored. Any discrepancy may indicate that the data block has been read incorrectly, and the ECC syndrome bits may be used to correct the error in the data block. The ability to detect and correct errors makes the cache well-suited to mission critical applications.</p><p id="p-0045" num="0044">An arbitration unit <b>312</b> may be coupled to the memory <b>308</b> to arbitrate between conflicting accesses of the memory <b>308</b>. When multiple operations attempt to access the memory <b>308</b> in the same cycle, the arbitration unit <b>312</b> may select which operation(s) are permitted to access the memory <b>308</b> according to a priority scheme. Many different priority schemes may be used. As an example of a priority scheme, the arbitration prioritizes read operations over write operations because write data that is in the pipeline <b>300</b> is available for use by subsequent operations even before it is written to the memory <b>308</b>, for example via a data forwarding multiplexer <b>318</b> of a store queue <b>314</b>, as will be discussed in more detail below. Thus, there is minimal performance impact in allowing the write data to wait in the pipeline <b>300</b>. However, as the pipeline <b>300</b> fills with write data that has not yet been written back, the priority of the write operations may increase until they are prioritized over competing read operations.</p><p id="p-0046" num="0045">The read path may run in parallel with the store queue <b>314</b>. Because a read operation may refer to data in a write operation that may not have completed yet, the pipeline <b>300</b> may include write forwarding functionality that allows the read path to obtain data from the store queue <b>314</b> that has not yet been written back to the memory <b>308</b>. In an example, the pipeline <b>300</b> includes a pending store address table <b>316</b> that records the addresses of the operations at each stage of the store queue <b>314</b>, the data forwarding multiplexer <b>318</b> to select data from one of the stages of the store queue <b>314</b> for forwarding, and a store queue hit multiplexer <b>320</b> that selects between the output of the memory <b>308</b> (by way of the error detection and correction circuit <b>310</b>) and the forwarded store queue <b>314</b> data from the data forwarding multiplexer <b>318</b>.</p><p id="p-0047" num="0046">An example flow of a read operation through the pipeline <b>300</b> will now be described. In a first cycle, indicated by stage E1, the cache retrieves a record from the tag RAM <b>306</b> that is associated with an address of the read operation to determine whether the data is stored in the cache's memory <b>308</b>. In a direct mapped example, the cache does not need to wait for the tag RAM comparison before requesting data from the memory <b>308</b>, and thus, the tag RAM comparison between the address of the read operation and the record of cached addresses does not need to extend into a second (E2) or third (E3) cycle.</p><p id="p-0048" num="0047">In the second cycle, in stage E2, the cache may request the data and ECC syndrome bits from the memory <b>308</b>, if the arbitration unit <b>312</b> permits. In this cycle, the cache may also determine whether newer data is available in the store queue <b>314</b> by comparing the read address to the pending store address table <b>316</b>. If so, the data forwarding multiplexer <b>318</b> is set to forward the appropriate data from the store queue <b>314</b>.</p><p id="p-0049" num="0048">Data and ECC syndrome bits may be provided by the memory <b>308</b> in the third cycle in stage E3. However, this data may or may not correspond to the memory address specified by the read operation because the cache may allocate multiple extended memory addresses to the same entry in the cache's memory <b>308</b>. Accordingly, in the third cycle, the cache determines whether the provided data and ECC from the memory <b>308</b> corresponds to the memory address in the read operation (e.g., a cache hit) based on the comparison of the tag RAM record. In the event of a cache hit, the data and ECC bits are received by the error detection and correction circuit <b>310</b>, which corrects any errors in the data in a fourth cycle in stage E4.</p><p id="p-0050" num="0049">As explained above, newer data that has not yet been written to the memory <b>308</b> may be present in the store queue <b>314</b>, and may be forwarded from the store queue <b>314</b> by the data forwarding multiplexer <b>318</b>. If so, the store queue hit multiplexer <b>320</b> selects the forwarded data over the corrected data from the memory <b>308</b>.</p><p id="p-0051" num="0050">Either the corrected data from the memory <b>308</b> or the forwarded data from the store queue <b>314</b> is provided to the requesting processor in a fifth cycle in stage E5. In this way, the example cache may provide data to the processor with full ECC checking and correction in the event of a cache hit in about 5 cycles.</p><p id="p-0052" num="0051">In the event that the data and ECC bits are not present in the memory <b>308</b> (e.g., a cache miss), the pipeline <b>300</b> may stall until the data can be retrieved from the extended memory, at which point the data may be written to the memory <b>308</b> and the tag RAM <b>306</b> may be updated so that subsequent reads of the data hit in the cache.</p><p id="p-0053" num="0052">The cache may also support a number of operations that read data from the cache and make changes to the data before rewriting it. For example, the cache may support read-modify-write (RMW) operations. A RMW operation reads existing data, modifies at least a portion of the data and overwrites that portion of the data. In ECC embodiments, a RMW operation may be performed when writing less than a full bank width. As the write is not for the full bank width, performing an ECC operation on just the portion of the data being written would result in an incorrect ECC syndrome. Thus, the read functionality of the RWM is used because the portion of the data in the bank that will not be overwritten still contributes to the ECC syndrome bits.</p><p id="p-0054" num="0053">A RMW operation may be split into a write operation and a read operation, and the pipeline <b>300</b> may be structured such that the read operation in the read path stays synchronized with the write operation in the store queue <b>314</b>. The read operation and the write operation remain synchronized until a read-modify-write merge circuit <b>322</b> overwrites at least a portion of the read data with the write data to produce merged data. The merged data is provided to an ECC generation circuit <b>324</b> that generates new ECC syndrome bits for the merged data, and then the merged data and ECC syndrome bits may be provided to the arbitration unit <b>312</b> for storing in the memory <b>308</b>.</p><p id="p-0055" num="0054">An example flow of a RMW operation through the pipeline <b>300</b> will now be described. The read portion of the operation proceeds substantially as explained above in stages E1-E4, where the cache compares an address of the read operation to a record of the tag RAM <b>306</b>, and the cache requests the data and ECC syndrome bits from the memory <b>308</b> and/or the store queue <b>314</b>. Because the RMW operation will modify the data, in examples that track MESI (Modified, Exclusive, Shared, and Invalid) states of entries in the memory <b>308</b>, a cache hit that is not in either the Modified or Exclusive state may be considered a cache miss. When the data is obtained in the proper state and any errors are corrected, it is provided to the read-modify-write merge circuit <b>322</b> in cycle E4 (or later in the event of a cache miss). In this same cycle, the read-modify-write merge circuit <b>322</b> may overwrite at least a portion of the corrected data with the write data to produce merged data. The ECC generation circuit <b>324</b> generates new ECC syndrome bits for the merged data in stage E5 (or later in the event of a cache miss). The merged data and the ECC syndrome bits are provided to the arbitration unit <b>312</b> for writing to the cache memory <b>308</b>.</p><p id="p-0056" num="0055">In some examples, sequential RMW operations are received that refer to the same address. Rather than wait for the merged data from the earlier RMW operations to be written to the memory <b>308</b>, the store queue <b>314</b> may include address comparators <b>326</b> for write forwarding that may feed the merged data back to a prior stage of the store queue <b>314</b> for use by a subsequent RMW operation. This may be referred to as &#x201c;piggy-backing.&#x201d; The data may be fed back before or after the ECC generation circuit <b>324</b>. As the feedback effectively merges the RMW operations, the final RMW operation has a complete set of data and ECC syndrome bits. Accordingly, earlier-in-time RMW operations may be canceled before they are written back to the memory <b>308</b>. This may avoid stalling other operations with writes of obsolete data.</p><p id="p-0057" num="0056">In certain cases, memory <b>308</b> may represent the entirety of the data cache. By way of example only, in such an embodiment, the data cache (which may be an L1 data cache) is associated with a single store queue structure <b>314</b>. As an example, the data cache may include 256 rows, with each row having 1024 bits (1 Kb) per row.</p><p id="p-0058" num="0057">In other examples, the cache may be divided into a plurality of independently addressable banks, and each individual bank may have its own respective store queue structure <b>314</b>. For instance, consider an embodiment in which the above-mentioned data cache has 256 rows with each row having a line width of 1024 bits, but being divided into 16 banks, with 64 bits per row in a given bank. In such an embodiment, there would be 16 store queues, one for each bank of the data cache. Thus, read and write operations may be sent to the banks in parallel, and each bank arbitrates its own processes in response to the read and/or write operations. By allowing each bank of a multi-bank cache to operate independently, operation of the cache is more efficient since an entire cache line is not locked up when a request is received. Rather, only the portion of the cache line allocated to the bank that received such a request would be locked. Of course, the cache size described above is only one example and the disclosure is not limited to any particular cache line width, number of banks, or rows, etc.</p><p id="p-0059" num="0058">The above example is also useful for writing and/or reading vector data. For instance, vector data may be 512 bits wide. For a multi-bank cache, a write request containing vector data that is a hit in the cache may be processed as 8 parallel writes to 8 banks (e.g., 8&#xd7;64 bits=512 bits). Similarly, a read request to such a multi-bank cache could be performed as 8 parallel reads from 8 banks.</p><p id="p-0060" num="0059">Another feature that may be present in a contemplated embodiment of the cache system is supporting inflight forwarding and invalidation. For instance, assume in one example that the cache is a two-way set associative cache. In a two-way set associative implementation, each cache line within the cache could map to two different addresses in a higher level of memory (e.g., L2 cache or main system memory for instance).</p><p id="p-0061" num="0060">Consider a situation in which a given cache line, referred to as &#x201c;Line <b>1</b>&#x201d; in this example, is a cache line in a two-way set associate cache and maps to two different addresses in memory, which are referred to as &#x201c;Address A&#x201d; and &#x201c;Address B.&#x201d; Now, suppose that cache receives a first request is received which is a partial write (e.g., a write to less than a full cache line) and is followed by a read request, like so:</p><p id="p-0062" num="0061">Write (Address A): Data <b>1</b> // write Data<b>1</b> to cache line corresponding to Address A</p><p id="p-0063" num="0062">Read (Address B) // read data contained in cache line corresponding to //Address B</p><p id="p-0064" num="0063">In this example, let us assume that the Write request is a hit, meaning that the cache line corresponding to Address A, which we will assume is Line <b>1</b> in this example, is in the cache. In response, the cache system will begin the process of writing Data <b>1</b> to Line <b>1</b>.</p><p id="p-0065" num="0064">Subsequently, let us assume that the Read request is a miss. In other words, while Line <b>1</b> may be mapped to either Address A or Address B in this two-way set associative cache, in this instance it is presently mapped to Address A. The miss thus occurs because Address B is not found in the tag RAM <b>306</b>. In response to the miss, the cache system will service the miss by going to retrieve the data from a higher level of memory, such as an L2 cache and, when the data, which is referred to as &#x201c;Data <b>2</b>&#x201d; in this example is returned, data currently in Line <b>1</b> will be evicted in order to store Data <b>2</b>. This may occur before the earlier Write has completed. In this case, there is no need to complete the Write operation since the Line <b>1</b> is going to be evicted anyways. Thus, the Write can be invalidated prior to its completion, referred to as &#x201c;inflight.&#x201d;</p><p id="p-0066" num="0065">Atomic operations, such as an atomic compare and swap, are further examples of memory operations that include a read. An atomic compare and swap operation may provide an address, a key value, and a set of new data to be written. The current data at the address is compared to the key, and if they match, the current data at the address is overwritten by the new data. Accordingly, in some examples, the pipeline <b>300</b> includes an atomic compare and swap circuit <b>328</b> to perform the comparison and forward the new data on for writing if the current data matches the key value. The atomic compare and swap circuit <b>328</b> may be coupled in parallel with the read-modify-write merge circuit <b>322</b> and a function multiplexer <b>330</b> may be used to determine which output is provided to the ECC generation circuit <b>324</b>.</p><p id="p-0067" num="0066">An example flow of an atomic compare and swap operation through the pipeline <b>300</b> will now be described. The read portion of the operation proceeds substantially as explained above in stages E1-E4, where the cache compares an address of the read operation to a record of the tag RAM <b>306</b> and the cache requests the data and ECC syndrome bits from the memory <b>308</b> and/or the store queue <b>314</b>. Because the atomic compare and swap operation may modify the data, in examples that track MESI states of entries in the memory <b>308</b>, a cache hit that is not in either the Modified or Exclusive state may be considered a cache miss. When the data is obtained in the proper state, it is provided to the atomic compare and swap circuit <b>328</b> in stage E4 (or later in the event of a cache miss). During these cycles, the new data and the key may be stored in the write path latches <b>304</b>. During stage E4, the atomic compare and swap circuit <b>328</b> may receive the corrected read data, the key, and the new data. If the corrected read data matches the key, the atomic compare and swap circuit <b>328</b> provides the new data to the ECC generation circuit <b>324</b>. The atomic compare and swap circuit <b>328</b> may also change the state of the new data to Modified if the read data matches the key. The ECC generation circuit <b>324</b> generates new ECC syndrome bits for the new data in stage E5 (or later in the event of a cache miss). The new data and the ECC syndrome bits are provided to the arbitration unit <b>312</b> for writing to the cache memory <b>308</b>.</p><p id="p-0068" num="0067">The pipeline <b>300</b> may also perform write forwarding using the address comparators <b>326</b> when sequential atomic compare and swap operations are received, similar to that described in the context of the RMW operations.</p><p id="p-0069" num="0068">Further examples of memory operations that read existing data include histogram operations. Histogram operations may specify a value to add to or subtract from existing data. To support histogram operations, the pipeline <b>300</b> may include an arithmetic unit <b>332</b> coupled in parallel with the read-modify-write merge circuit <b>322</b> and/or the atomic compare and swap circuit <b>328</b>. The arithmetic unit <b>332</b> may support any size operands, and in one such example, the arithmetic unit <b>332</b> supports addition and subtraction of a 16-bit value from a 64-bit bank. Multiplexer <b>330</b> may be used to select between the arithmetic unit <b>332</b>, the read-modify-write merge circuit <b>322</b>, and the atomic compare and swap circuit <b>328</b>.</p><p id="p-0070" num="0069">An example flow of a histogram operation through the pipeline <b>300</b> will now be described. The read portion of the operation proceeds substantially as explained above in stages E1-E4, where the cache compares an address of the read operation to a record of the tag RAM <b>306</b> and the cache requests the data and ECC syndrome bits from the memory <b>308</b> and/or the store queue <b>314</b>. Because the histogram operation will modify the data, in examples that track MESI states of entries in the memory <b>308</b>, a cache hit that is not in either the Modified or Exclusive state may be considered a cache miss. When the data is obtained in the proper state, it is provided to the arithmetic unit <b>332</b> in stage E4 (or later in the event of a cache miss). During these cycles, the value to be added to the corrected data may be stored in the write path latches <b>304</b>. During stage E4, the arithmetic unit <b>332</b> may receive the corrected read data and the value to be added or subtracted from the read data. The arithmetic unit <b>332</b> performs the specified addition or subtraction and provides the new data to the ECC generation circuit <b>324</b>. The ECC generation circuit <b>324</b> generates new ECC syndrome bits for the new data in stage E5 (or later in the event of a cache miss). The new data and the ECC syndrome bits are provided to the arbitration unit <b>312</b> for writing to the cache memory <b>308</b>.</p><p id="p-0071" num="0070">The pipeline <b>300</b> may also perform write forwarding using the address comparators <b>326</b> when sequential histogram operations are received, similar to that described in the context of the RMW operations.</p><p id="p-0072" num="0071">While <figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates a single pipeline <b>300</b> with a single instance of a store queue <b>314</b>, latches <b>302</b> and <b>304</b>, an error detection and correction circuit <b>310</b>, etc. However, as described above, the memory <b>308</b> may be arranged to support more than one independent copy of the pipeline <b>300</b>. Accordingly, the pipeline <b>300</b> may be reproduced multiple times. In one such example, the memory <b>308</b> entries are 1024-bit blocks based on the width of the extended memory interface, and the memory <b>308</b> is arranged into 16 parallel banks where each 1024-bit block includes 64 bits in each of the 16 banks. In this particular example, each of the 16 banks has its own independent pipeline <b>300</b>. A read or write operation from the processor is divided into a number of bank-level operations and each is provided to its respective pipeline <b>300</b> so that they may be processed concurrently. For example, a 512-bit vector read operation may be divided into eight 64-bit read operations that are provided to eight independent pipelines <b>300</b> to be processed in parallel. At the same time, another operation may be received over the scalar interface or a vector interface of another processor and divided into operations that are provided to the remaining pipelines <b>300</b>. Accordingly, the data cache may service multiple independent operations concurrently, with each operation being allocated a subset of the pipelines <b>300</b>.</p><p id="p-0073" num="0072">In certain cases, the cache pipeline <b>300</b> may be coupled to a victim cache. Victim caches may help improve cache miss rates, such as those due to conflict misses. A victim cache, in certain cases, can have an impact on cache performance similar to increasing the N-way associative number (e.g., a degree of cache associativity). This benefit may be more evident in cases where the victim cache is added to a direct-mapped cache, as a direct mapped cache typically has the highest rate of conflict misses. The addition of a victim cache may help improve an overall cache hit rate.</p><p id="p-0074" num="0073"><figref idref="DRAWINGS">FIG. <b>4</b></figref> is a block diagram illustrating a cache architecture <b>400</b> including a victim cache. Here, the cache architecture <b>400</b> includes a main cache <b>404</b> coupled to a victim cache <b>402</b>, where the victim cache <b>402</b> resides after the main cache <b>404</b>. When a line of data is evicted out of the main cache <b>404</b>, rather than moving the line of data to a next level cache (e.g., L2), the line of data is moved to the victim cache <b>402</b> and held there until there is a reason to evict it out, such as due to capacity or other reasons. In such a cache architecture <b>400</b>, in case of a cache miss from the main cache <b>404</b>, the victim cache <b>402</b> can service the miss and return the line to the processor <b>414</b>, reducing the overall latency experienced for a read miss.</p><p id="p-0075" num="0074">As an example, suppose a processor <b>414</b> attempts to access address A in the main cache <b>404</b> and the victim cache <b>402</b>, causing a cache miss. The main cache <b>404</b> may then evict address B from the main cache <b>404</b> and create a victim cache (Address B) line in the victim cache <b>402</b>. The read miss of address A then goes out <b>406</b> to a higher level memory <b>412</b>, such as L2 cache, another cache, and/or other memory, to be serviced. Once address A is accessed, the contents of address A may be returned <b>410</b> and stored in the main cache <b>404</b>.</p><p id="p-0076" num="0075">If a subsequent access attempt for address B is issued, the main cache <b>404</b> is checked to see if address B is cached, resulting in a cache miss. The victim cache <b>402</b> is then checked <b>408</b>, which returns a hit as address B was stored in the victim cache <b>402</b> after being evicted from the main cache <b>404</b>. Address B may then be restored <b>410</b> to the main cache <b>404</b> and returned as a result to the processor <b>414</b>. The read latency in such a system, while faster as compared to having to fetch the address from higher level memory <b>414</b> (e.g., L2 cache, main memory, etc.), is still greater than the latency when there is a cache hit in the main cache <b>404</b>.</p><p id="p-0077" num="0076">To help address the latency experienced in cache architectures which place the victim cache after the main cache, in certain cases, the victim cache may be placed in parallel with the main cache. <figref idref="DRAWINGS">FIG. <b>5</b></figref> is a block diagram illustrating a cache architecture <b>500</b> including a parallel victim cache, in accordance with aspects of the present disclosure. The cache architecture <b>500</b> can be thought of as having multiple sub-caches in parallel. Each of the main cache <b>504</b> and the victim cache <b>502</b> has their own independent associativity and the overall cache system <b>500</b> may have the appearance of a hybrid way cache system. In certain cases, either the main cache <b>504</b> or the victim cache <b>502</b> may be n-way associative, while the other cache may be fully associative. In this example, the main cache <b>504</b> may be a direct mapped (1-way associative) cache and the victim cache <b>502</b> may be fully associative.</p><p id="p-0078" num="0077">In this example, if a processor <b>514</b> issues a read to address A, which misses in the main cache <b>504</b>, the miss request goes out to a higher level cache <b>512</b> for servicing and the victim line, here address B, is moved to the victim cache <b>502</b>. Next, let us assume the processor <b>514</b> wants to read address B. In this example, the address of the read is checked against both the main cache <b>504</b> and the victim cache <b>502</b> in parallel. This results in a read miss in the main cache <b>504</b> but a hit in the victim cache <b>502</b>. The read results for address B may then be directly returned from the victim cache <b>402</b> to the processor <b>514</b>. As both caches are checked in parallel, the read latency remains the same as if the read request was a hit in the main cache <b>504</b>. The overall effect of having a victim cache in parallel to the main cache is that we get the benefit of reducing the cache miss rate while also not impacting the latency in case the subsequent CPU access hits the victim cache.</p><p id="p-0079" num="0078"><figref idref="DRAWINGS">FIG. <b>6</b></figref> is a block diagram illustrating a victim cache memory pipeline <b>600</b>, in accordance with aspects of the present disclosure. As discussed above, the victim cache may be a fully associative cache, meaning that there is not a mapping addresses and cache lines. Rather any address may be stored in any cache line of the victim cache. Thus, for an address received at block <b>602</b> in the E1 stage, the received address is checked, in the E2 stage, against addresses stored in each location in the victim cache tag RAM <b>604</b>. In certain cases, these locations in the victim cache tag RAM <b>604</b> correspond to lines of the victim cache <b>606</b>. For example, if address A is received at block <b>602</b>, address A is compared against addresses in the victim cache tag RAM <b>604</b> to see if there is a match. If, for example, location <b>5</b> of the victim cache tag RAM <b>604</b> corresponds to address A, then the data corresponding to address A is stored in address <b>5</b> of the victim cache <b>606</b>. This data is eventually returned to the processor at block <b>608</b>.</p><p id="p-0080" num="0079">Where the victim cache operates in parallel to the main cache, it may be desirable for the victim cache to support certain features of the main cache, such as ECC and RMW operations. In certain cases, the victim cache may also include a store queue <b>610</b> structure to help provide support for RMW and ECC operations, in a manner similar to the store queue <b>314</b> as discussed in conjunction with <figref idref="DRAWINGS">FIG. <b>3</b></figref>.</p><p id="p-0081" num="0080">In certain cases, caches may include a write-miss buffer. A write-miss can occur when a memory write is issued to a cache against a memory address that is not in the cache. The memory write may be an atomic operation, the processor that issued the memory write may stall until a memory write complete message is returned to the processor. Rather than stalling the processor until a write to a higher level memory is complete, the cache may store the memory write in a write-miss buffer and returns an indication that the memory write is complete. The write-miss buffer this information and then outputs (e.g., drains) the memory write to the target memory address. Once the memory write output to the target memory address is complete, the memory write is removed from the write-miss buffer. To output the memory write, the write-miss buffer may include three pieces of information for each memory write: the memory address for the write, the corresponding data, and the byte enable (byten) mask for the memory write. Generally, the byte enable logic or mask that defines a portion of the memory line to be written to. Typically, write-miss buffers are implemented using dedicated buffer circuitry as a first in first out (FIFO) buffer. However, FIFO write-miss buffers are typically configured to drain to a higher level memory more or less continuously and do not support features such as write merging. In certain cases, a write-miss buffer may be allocated into the cache system using the victim cache.</p><p id="p-0082" num="0081"><figref idref="DRAWINGS">FIG. <b>7</b></figref> is a block diagram illustrating a victim cache pipeline <b>700</b> including a write-miss buffer, in accordance with aspects of the present disclosure. As discussed above, a write-miss buffer may store the memory address for the write, the data to be written, and the byten logic. In this example victim cache pipeline <b>700</b> the memory addresses for a write-miss buffer entry may be stored in a victim cache tag RAM <b>704</b> and the corresponding data may be stored in the victim cache RAM <b>706</b>. A byte enable memory <b>702</b> may also be added to the victim cache to store the byten logic associated with a write-miss buffer line. In certain cases, the MESI RAM <b>732</b> may be modified to include an extra bit indicating a line type <b>708</b> associated with an entry in the victim cache RAM <b>706</b>. The line type <b>708</b> indicates whether a particular line of the victim cache RAM <b>706</b> is a cache line or a write-miss buffer line. In certain cases, the line type <b>708</b> may be added to another memory, such as the victim cache tag RAM <b>704</b>, rather than the MESI RAM <b>718</b>.</p><p id="p-0083" num="0082">Additionally, the victim cache system, for example as discussed in conjunction with <figref idref="DRAWINGS">FIG. <b>6</b></figref>, may be configured as a write-miss buffer by adding control logic in read and write-miss state machines to address allocating of write-miss entries inside the victim cache, as well as logic to support handling various address hazards in cases like a read to the same line as a write-miss entry inside the victim cache (selective write-miss flush), and logic to support resolving same address load/stores in data-paths of the victim cache. A storage queue <b>710</b> structure may also be provided to enable support for RMW and ECC support for write-misses. In certain cases, the storage queue <b>710</b> may be used to enable support for RMW and ECC support for write miss operations as well as cache operations.</p><p id="p-0084" num="0083">As an example of performing write-miss buffer operations in a cache, when a write is received at block <b>712</b>, the address of the write is checked against memory addresses stored in each location in the victim cache tag RAM <b>704</b>. A write-miss occurs when the address of the write is not found in the victim cache tag RAM <b>704</b>. When operating as a write-miss cache, a determination is made where to store the write-miss in the victim cache. In certain cases, this determination may be made based on entries in the victim cache tag RAM <b>704</b>. If there is an empty location in the victim cache tag RAM <b>704</b>, then the address of the write-miss is stored in the victim cache tag RAM <b>704</b> in the empty location. If there is not an empty location, then a line may be evicted based on an eviction scheme for allocating the write-miss buffer space. In other cases, the line may have previously been used as a write miss buffer or a cache line. The line type <b>708</b> corresponding to the location in the victim cache tag RAM <b>704</b> of the write-miss may be updated to indicate that the location is being used as a write-miss buffer. For example, a 0 in the line type <b>708</b> may indicate the corresponding line is a cache entry, while a 1 in the line type <b>708</b> may indicate that the corresponding line is a write-miss buffer entry. In certain cases, the line type <b>708</b> may be store in another memory location, such as the MESI RAM <b>732</b>, or in a dedicated memory space, such as a set of registers. The data of the write-miss is stored in a line of the victim cache RAM <b>706</b> corresponding to the victim cache tag RAM <b>704</b> location used. The byte enable logic may be stored in a corresponding slot of the byte enable memory <b>702</b>. In certain cases, the byte enable memory <b>702</b> may include bits indicating which positions of the byte enable memory <b>702</b> are valid. The line type bit helps enable storing write miss entries in lines of the victim cache RAM <b>706</b> without having to dedicate a portion of the victim cache RAM <b>706</b> as a write buffer.</p><p id="p-0085" num="0084">According to aspects of the present disclosure, the victim cache eviction logic, for example in an eviction controller <b>714</b>, may be updated to handle write-miss entries stored in the victim cache to prioritize evicting write-miss entries in favor of store cache entries. Additionally, control logic for read and write state machines of the victim cache controller <b>734</b> may be configured to determine that an incoming read request might hit a cache line of the victim cache configured to store a write-miss. In such cases, the victim cache controller <b>734</b> may be configured to treat this read hit like a read-miss and evict the stored write miss command to higher level memory and then send the read miss out to the higher level memory. Additionally, cache system are typically configured to stall on a miss while a write-miss buffer typically does not stall a processor as it buffers the write miss. To help address this difference, the victim cache controller <b>734</b> may be configured to allocate write miss entries to the victim cache without stalling the CPU by speculatively reading an incoming write data so that data can be stored directly in to the victim cache without stalling if it is a write miss.</p><p id="p-0086" num="0085">In certain cases, by placing write-misses in a cache system, the write-misses may stay cached until there is a requirement to evict them out to higher level memories. In certain cases, a write-miss stored in the victim cache may stay in the cache system until a defined condition is met, a fence operation is requested, or there are address/hardware conflicts which need a particular write-miss entry to be evicted.</p><p id="p-0087" num="0086">Maintaining the write-miss buffer until an explicit fence operation is requested may be problematic, for example, if a fence operation is not raised at the end of an operation, and any write-misses stored in the victim cache may be stuck inside the victim cache. Additionally, there can be latency concerns from fence operations, as flushing out (e.g., evicting all) write miss buffers stores only in response of a fence operation can result in delays as the cache needs to drain the stored write-misses out to the appropriate memories and then wait for the acknowledgments to return. In certain cases, an auto-flushing or draining of write-miss entries stored in the victim cache may be provided. Auto-flushing may be implemented to help drain write-miss entries from the victim cache while reducing the potential latency that may be incurred in the drain process. In certain cases, an eviction controller <b>714</b> may monitor activity on a processor interface. If the eviction controller <b>714</b> detects idle activity on the processor interface, the eviction controller <b>714</b> may proceed to start draining write-miss entries from the victim cache. For example, if the eviction controller <b>714</b> detects that the processor has not issued any commands for N number of clock cycles, then the eviction controller <b>714</b> may internally start an auto-flush process to start draining the stores cached inside victim cache. In certain cases, N may be predetermined. In other cases, N may be configurable. In certain cases, the auto-flush process may walk (e.g., examine in order) the VTag RAM looking for write-miss entries and flushing entries corresponding to write-miss entries. In other cases, the auto-flush process may include logic to flush entries based in a FIFO, least recently used (LRU), random, or other basis.</p><p id="p-0088" num="0087">In auto-flushing write-miss entries, the eviction controller <b>714</b> may send an eviction trigger request to the victim cache controller <b>734</b> for a selected write buffer cache line. The victim cache controller <b>734</b> checks the store queue to see if there are any entries in the store queue corresponding to a write buffer cache line to be flushed. If there is a corresponding entry in the store queue, then the victim cache controller <b>734</b> may wait for the store queue to complete. Once the store queue is emptied, the victim cache controller <b>734</b> may evict the selected cache lines. The victim cache controller <b>734</b> sets up the creation of store miss packets to be sent to higher level caches or other memories. These store miss packets may include the corresponding memory address stored in the victim cache tag RAM <b>704</b>, byte enable logic in the byte enable memory <b>702</b>, and the data in the victim cache RAM <b>706</b>. The victim cache can then send the store miss packet, for example to a cache controller of a higher level cache or other memory. When flushing write-miss entries, the write miss packet may be sent out to other memories and the corresponding entries in the victim cache RAM <b>706</b>, victim cache tag RAM <b>704</b>, and byte enable memory <b>702</b> may be invalidated. The write miss packet may be placed in a drain buffer <b>716</b> temporarily until the write miss packet is accepted (e.g., acknowledged) by the other memory. Once the write miss buffer cache line is invalidated, the eviction controller <b>714</b> may select a next write miss buffer cache line to evict and proceed to evict the next write miss buffer cache line. If activity is subsequently detected on the processor interface, this auto-flush operation may be cancelled. By doing so, the victim cache is able to utilize idle periods and avoid impacting processor performance when there is activity on the interface by attempting to drain the write-miss buffer entries.</p><p id="p-0089" num="0088">In certain cases, write-misses stored in the victim cache may be evicted based on a state of the write miss line storing a particular write-miss, rather than a FIFO, LRU, random, or other scheme based on the order which a cache line is allocated. Where the cache is configured to merge data in the cache, cache writes to a memory line from a processor do not imply that the processor needs to read from other portions of the memory line. Further, where a processor has written out a large portion of the memory line, such as half the memory line or the whole memory line, the processor is less likely to need to access (such as merging additional data into) that portion of the memory line again, as compared to where the processor has written only a small portion of the memory line. As the processor is less likely to need to access a given write miss cache line after writing out a half or the full write miss cache line, this write miss cache line can be evicted with less potential impact to performance. Thus, once a write miss cache line is fully written to, or half written to, and a write has started on a next entry in the victim cache on another write miss cache line, the full, or half full, cache line may be evicted. This helps address the case where a processor is issuing a stream of cache writes-misses which are collectively larger than the victim cache. Additionally, aggressively evicting full or half full write-miss cache lines helps avoid performance issues that may arise when a large number of write-miss items stored in the victim cache are all flushed at once due to a fence operation at the end of an operation.</p><p id="p-0090" num="0089">To help support removing full or half full write-miss cache lines, the byte enable memory <b>702</b> may include two status bits, a half-full line status bit <b>718</b> and a full line status bit <b>720</b>. Each line of the byte enable memory <b>702</b> corresponds with a cache line in the victim cache ram <b>206</b> and each line of the byte enable memory <b>702</b> may include the half-full line status bit <b>718</b> and the full line status bit <b>720</b>. These status bits may be updated each write cycle where bits are written into a cache line configured as a write miss buffer and the status bits may be calculated based on the bits already stored in the corresponding line of the victim cache RAM <b>706</b>, as well as the bits that are being written to the victim cache RAM <b>706</b> in a write cycle. In certain cases, this updating may be performed for each cache line of the byte enable memory <b>702</b> for each cycle and updating may be omitted when there is not a write cycle. As indicated above, each line of the byte enable memory <b>702</b> can include a bit mask indicating which positions (e.g., bytes) of the byte enable memory <b>702</b> are valid (e.g., written to). Determining which lines are full or half full can be performed using an XOR over corresponding portions of the bit mask. The half-full line status bit <b>718</b> may be set when half of a given cache line has been written to, either the least significant bits, or the most significant bits. Similarly, the full line status bit <b>720</b> may be set when an entire cache line has been written to. The cache lines may then be walked (e.g., examined in order) to determine an address to return that has a full or half full cache line. In certain cases, addresses corresponding to full cache lines are selected first and addresses corresponding with half full cache lines are returned if there are no full cache lines. If multiple cache lines are full (or half full, if there are no full cache lines), then the first cache line that is full (or half full) found when walking the cache lines may be selected. If no cache line is full or half full, a write-miss cache line may be selected based on FIFO, LRU, or other logic may be used to determine which cache line to select where there are multiple lines available.</p><p id="p-0091" num="0090">Evicting write-miss entries may operate similarly to auto-flush except that the store queue is not checked to see if there are any entries corresponding to a full or half full write miss cache line being evicted as this operation is initiated by a read or write miss and is performed after a line has been written to. Once a full or half full write miss cache line has been selected for eviction, the eviction controller <b>714</b> indicates to a victim cache controller <b>734</b> to evict the selected cache lines. The victim cache controller <b>734</b> sets up the creation of store miss packets to be sent to higher level caches or other memories. These store miss packets may include the corresponding memory address stored in the victim cache tag RAM <b>704</b>, byte enable logic in the byte enable memory <b>702</b>, and the data in the victim cache RAM <b>706</b>. The store miss packets are sent, for example to a cache controller of a higher level cache or other memory and the corresponding entries in the victim cache RAM <b>706</b>, victim cache tag RAM <b>704</b>, and byte enable memory <b>702</b> may be invalidated. The store miss packet may be placed in a drain buffer <b>716</b> temporarily until the store miss packet is accepted (e.g., acknowledged) by the other memory.</p><p id="p-0092" num="0091">Once the write-miss cache lines have been invalidated, the address of the cache line may be sent to replacement policy logic <b>722</b> each write cycle. Cache line address which are available may be fed into mux <b>724</b> in a replacement address line <b>726</b>. An address generation line <b>728</b> may include an address assigned to a received write instruction. If hit/miss logic <b>730</b> determines that the address of the received write instruction is a hit, the address is already stored in a line of the victim cache and data from the write instruction is merged to the line. If hit/miss logic <b>730</b> determines that the address of the received write instruction is a miss, an address from the replacement address line <b>728</b> may be used to write the write-miss command to the victim cache/write miss buffer. An eviction process may be triggered if there are no empty cache lines in the victim cache/write miss buffer to allocate the write miss. In an eviction process, a centralized controller may detect that a write miss has been received that needs to be stored into the victim cache. The centralized controller may instruct the victim cache controller <b>734</b> to ensure that there is a cache line available. This cache line may be based on a location provided by either the replacement address <b>726</b>, or the address generation <b>728</b>. If there is already a write miss stored in the identified location, the write miss may be evicted.</p><p id="p-0093" num="0092"><figref idref="DRAWINGS">FIG. <b>8</b></figref> is a block diagram of a MESI RAM <b>800</b>, in accordance with aspects of the present disclosure. The MESI RAM <b>800</b> may be a memory (e.g., SRAM) or set of registers (e.g., register file), used to track the MESI status of a corresponding cache line. As an example, the victim cache, in certain cases, may track MESI states in MESI state bits <b>802</b> in the MESI RAM <b>800</b> for cache entries as a part of writing data. In certain cases, the MESI RAM <b>800</b> includes a line corresponding to each line of the corresponding cache, here, the victim cache. It may be understood that the main cache may include a corresponding MESI RAM. In certain cases, a single MESI RAM may be shared by both a main and victim cache. The MESI RAM <b>800</b> may have a set of bits for tracking the MESI state of each cache line stored in the victim cache. In certain cases, the MESI RAM <b>800</b> may be expanded with additional bits to track other states of cache lines in the victim cache. The MESI RAM <b>800</b> may be expanded to track additional states by including additional columns for the additional states. In this example, the MESI RAM has been expanded to include state bits in a bit field to track a privilege level <b>804</b> for each cache line, a red tag <b>806</b>, a blue tag <b>808</b>, whether a line is valid <b>810</b>, and whether a line is a write miss buffer or victim cache line <b>812</b>. It may be noted that while shown as a part of the MESI RAM, the state bits may be placed within other memories in other embodiments, such as the tag RAM <b>704</b>, or in a separate memory altogether. It may be understood that the MESI RAM may be configured to track additional states not shown here.</p><p id="p-0094" num="0093">In certain cases, it may be useful to flush all write-miss buffer entries of a certain type stored in the victim cache. As discussed below, entries in the write-miss buffer may be associated with a &#x201c;color&#x201d; tag. This color tag may be represented by one or more bits such that when a bit is set for a write-miss buffer entry, the color associated with the write-miss buffer entry may be &#x201c;blue&#x201d; and when the bit is not set, or another bit is set, the write-miss buffer entry may be &#x201c;red.&#x201d; Tagging helps allow certain write-miss buffer entries to be associated with a particular process running on a processor, while other write-miss buffer entries may be associated with another process running on the processor. In certain cases, a processor may want to flush all write-miss buffer entries associated with a particular process (e.g., a selective fence operation), but not the write-miss buffer entries associated with another process.</p><p id="p-0095" num="0094">To perform a selective fence operation, a processor may assert a drain signal. Along with the asserted drain signal, the processor may provide an indication that a particular tag should be prioritized for draining, either the red or blue tag. Referring back to <figref idref="DRAWINGS">FIG. <b>7</b></figref>, the drain signal is passed to the eviction controller <b>714</b>. The eviction controller <b>714</b> may check an availability of a higher level cache or memory to see whether the higher level cache or memory is busy. If the higher level cache or memory is unavailable, the eviction controller <b>714</b> may stall the processor. If the higher level cache or memory is available, then the eviction controller <b>714</b> may send an eviction trigger request indicating the prioritized tag to the victim cache controller <b>734</b>. The victim cache controller <b>734</b> may then check with the store queue to see if there are any outstanding entries in the store queue for any bank of the victim cache RAM <b>706</b>. The victim cache controller <b>734</b> may also indicate to the store queue <b>710</b> to escalate the priority of draining the store queue. If there is data, for example in the store queue, that has not yet been stored to the victim cache, the eviction controller <b>714</b> may wait for the store queue <b>710</b> to complete. Once the store queue <b>710</b> is emptied, the eviction controller <b>714</b> indicates to a victim cache controller to evict the selected cache lines. The victim cache controller <b>734</b> sets up the creation of store miss packets to be sent to higher level caches or other memories. These store miss packets may include the corresponding memory address stored in the victim cache tag RAM <b>704</b>, byte enable logic in the byte enable memory <b>702</b>, and the data in the victim cache RAM <b>706</b>. The victim cache can then send the store miss packet, for example to a cache controller of a higher level cache or other memory. When flushing write-miss entries, the write miss packet may be sent out to other memories and the corresponding entries in the victim cache RAM <b>706</b>, victim cache tag RAM <b>704</b>, and byte enable memory <b>702</b> may be invalidated. The write miss packet may be placed in a drain buffer <b>716</b> temporarily until the write miss packet is accepted (e.g., acknowledged) by the other memory. This flushing continues until the processor ceases to assert the drain signal. If the processor stops asserting the drain signal before all write-miss buffer entries of the indicated color have been drained, draining of the write-miss buffer stops wherever in the draining process the victim cache is in when the drain signal stops being asserted. Once all write miss buffer entries of the indicated color tag have been drained, an idle signal is asserted back to the processor. If the processor continues to assert the drain signal, other write miss buffer entries associated with the other color tag may be drained.</p><p id="p-0096" num="0095">Placing write-misses in a cache system helps provide an opportunity to merge additional write misses to the write miss already in the cache system. As write-misses can stay longer inside the cache, the cache has an opportunity to merge any future write-misses to write-misses already existing in the cache system, thus reducing the write-miss traffic out to higher level memories. Reducing the write-misses being sent to higher level memories can reduce the pressure on those memories and help improve overall performance.</p><p id="p-0097" num="0096">A write merge may occur when a processor issues a second store or write command to a particular address at block <b>712</b>. Where the victim cache is fully associative, the address of the second write may be checked, by the hit/miss logic <b>730</b>, against a set of memory addresses stored in each location in the victim cache tag RAM <b>704</b>. In parallel, a replacement policy <b>722</b> logic determines a location inside of the victim cache where the write transaction could be allocated in case of a write miss. Generally, when a write miss is stored in the victim cache, the write miss is allocated an entire cache line, even if the data in the write miss does not need an entire cache line. Thus, a set of memory addresses may be associated with each write miss stored in the victim cache, including the memory address in the write miss, along with a set of memory addresses either before, after, or both before and after the memory address in the write miss. If the address of the second write is determined to be within a set of memory addresses associated with a write-miss stored in the victim cache, then a cache hit is detected and the hit/miss logic returns the location in the victim cache where the write-miss is currently stored. In the E3 pipestage, the color type and privilege level associated with the second write is merged, for example by the victim cache controller <b>734</b>, with the currently stored color type and privilege level and the MESI RAM <b>732</b> is updated. In certain cases, merging the privilege level may be performed with reference to a privilege merge table <b>736</b>. The data of the second write is also merged into the corresponding line of the victim cache RAM <b>706</b> and the corresponding entry of the byte enable memory <b>702</b> updated based on the byte enable logic associated with the second write, for example by the victim cache controller <b>734</b>. In certain cases, the store queue <b>710</b> may also include write merge functionality. For example, when back to back writes are issued to the same address, the store queue <b>710</b> may internally merge them to help minimize a number of writes to issue to the victim cache RAM <b>706</b>.</p><p id="p-0098" num="0097">In certain cases, write merging may be performed across privilege levels. Merging the privilege level may be performed when performing write merging. For example, a first write-miss stored in the victim cache may be associated with a first privilege level. A second write associated with a second privilege level may be merged with the stored first write-miss. To perform the merge, the privilege levels should be merged as well. In certain cases, the privilege levels may be merged by merging the privilege levels to the lower level of the privilege levels. For example, in an embodiment, a write operation may be associated with a two part privilege level such as root/guest-user/supervisor. A first write-miss may be received with a privilege level of root-user. This first write-miss may be written to the write miss buffer in the victim cache. A second write with privilege level of guest-supervisor may be received, the second write directed to an address within the set of addresses associated with the first write-miss. When merging the privilege levels of the two writes, the lower privilege level may be used, resulting in a merged privilege level of guest-user. In certain cases, merging the privilege levels may operate in the same way when merging is performed for multiple datapaths. In certain cases, privilege level merging may be encoded in the privilege merge table <b>736</b>, indicating how different privilege levels may be merged. In certain cases, the privilege merge table <b>736</b> may be predefined. An example of a predefined privilege merge table <b>736</b> is shown in Table 1. In certain cases, the privilege merge table <b>736</b> may be configurable.</p><p id="p-0099" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="98pt" align="left"/><colspec colname="2" colwidth="56pt" align="left"/><colspec colname="3" colwidth="63pt" align="left"/><thead><row><entry namest="1" nameend="3" rowsep="1">TABLE 1</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row><row><entry/><entry/><entry>New Privilege level</entry></row><row><entry>Privilege of Write Miss to be</entry><entry>Current Privilege</entry><entry>of Write Miss Buffer </entry></row><row><entry>merged into Write Miss Buffer </entry><entry>of Write Miss</entry><entry>line after transaction </entry></row><row><entry>on Write Miss Buffer Hit</entry><entry>Buffer Hit line</entry><entry>merge</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>Guest-User</entry><entry>Guest-User</entry><entry>Guest-User</entry></row><row><entry>Guest-User</entry><entry>Guest-Supervisor</entry><entry>Guest-User</entry></row><row><entry>Guest-User</entry><entry>Root-User</entry><entry>Guest-User</entry></row><row><entry>Guest-User</entry><entry>Root-Supervisor</entry><entry>Guest-User</entry></row><row><entry>Guest-Supervisor</entry><entry>Guest-User</entry><entry>Guest-User</entry></row><row><entry>Guest-Supervisor</entry><entry>Guest-Supervisor</entry><entry>Guest-Supervisor</entry></row><row><entry>Guest-Supervisor</entry><entry>Root-User</entry><entry>Guest-User</entry></row><row><entry>Guest-Supervisor</entry><entry>Root-Supervisor</entry><entry>Guest-Supervisor</entry></row><row><entry>Root-User</entry><entry>Guest-User</entry><entry>Guest-User</entry></row><row><entry>Root-User</entry><entry>Guest-Supervisor</entry><entry>Guest-User</entry></row><row><entry>Root-User</entry><entry>Root-User</entry><entry>Root-User</entry></row><row><entry>Root-User</entry><entry>Root-Supervisor</entry><entry>Root-User</entry></row><row><entry>Root-Supervisor</entry><entry>Guest-User</entry><entry>Guest-User</entry></row><row><entry>Root-Supervisor</entry><entry>Guest-Supervisor</entry><entry>Guest-Supervisor</entry></row><row><entry>Root-Supervisor</entry><entry>Root-User</entry><entry>Root-User</entry></row><row><entry>Root-Supervisor</entry><entry>Root-Supervisor</entry><entry>Root-Supervisor</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0100" num="0098">In certain cases, write merging may be performed for color tags. For example, a first write-miss stored in the victim cache may be associated with a first color tag, such as red. With reference to <figref idref="DRAWINGS">FIG. <b>8</b></figref>, the first write-miss may be associated with an entry in the MESI RAM <b>800</b> with a bit set in the red tag <b>806</b> of a bit field. A second write associated with a second color tag may be merged with the stored first write-miss. To perform the merge, the color tags should be merged as well. In certain cases, the color tags may be merged by combining the color tags of the writes. For example, if both writes are red tagged, then the merged write remains red tagged. Similarly, the merged write would be blue tagged if both writes are blue tagged. If one write is red tagged and the other write is blue tagged, then the merged write is tagged both red and blue. Thus, if the second write to be merged is associated with a blue tag, the merged write may have a bit set in the red tag <b>806</b> of the bit field and a bit set in the blue tag <b>808</b> of the bit field. In certain cases, if a drain operation is then performed, for example for blue tags, the merged write would be drained. Similarly, if a drain operation is performed for red tags, the merged write would also be drained as the merged write is tagged as both red and blue.</p><p id="p-0101" num="0099"><figref idref="DRAWINGS">FIG. <b>9</b></figref> is an architectural block diagram of a cache system <b>900</b> including a write-miss buffer, in accordance with aspects of the present disclosure. As shown, a cache <b>902</b> may receive cache requests from a processor <b>904</b> via a processor interface <b>906</b>. In certain cases, the cache <b>902</b> may be configured to handle either scalar or vector data, or both. The cache <b>902</b> is logically divided into parallel sub-caches including a main cache <b>908</b> and a victim cache <b>910</b>. While a single main cache <b>908</b> and victim cache <b>910</b> are shown, it may be understood that certain embodiments can include multiple main caches <b>908</b> and victim caches <b>910</b> pairs. In certain cases, there may be a different number of main caches <b>908</b> and victim caches <b>910</b>. With respect to the main cache <b>908</b>, a main cache tag RAM access controller <b>912</b> accesses and checks a main cache tag RAM <b>914</b> against memory addresses included in the cache requests to determine whether a memory address is stored in the main cache <b>908</b>. A main cache controller <b>916</b> directs the appropriate allocation, eviction, arbitration, merge, etc. processes and reads/writes into the main cache memory <b>918</b>. A main cache store queue structure <b>920</b>, as described in conjunction with <figref idref="DRAWINGS">FIG. <b>3</b></figref>, provides features such as RMW, ECC, write merging, etc.</p><p id="p-0102" num="0100">The overall architecture of the victim cache <b>910</b> is similar to that of main cache <b>908</b>. For example, for a received memory request, a victim cache tag RAM access controller <b>922</b> accesses and checks a victim cache tag RAM <b>924</b> against memory addresses included in the cache requests to determine whether a memory address is stored in the victim cache <b>910</b>. A victim cache controller <b>926</b> similarly directs the appropriate allocation, eviction, arbitration, merge, etc. processes and reads/writes into the victim cache memory <b>928</b>. A victim cache store queue <b>930</b> provides RMW, ECC, and other features, as discussed in conjunction with <figref idref="DRAWINGS">FIG. <b>3</b></figref>. Victim cache logic <b>932</b> helps coordinate operations as between the victim cache <b>910</b> and the main cache <b>908</b>. It may be understood that while the victim cache logic <b>932</b> is shown separately, the victim cache logic <b>932</b> may be integrated with or a part of other elements, such as the victim cache controller <b>926</b>. In certain cases, the victim cache <b>908</b> includes certain elements which help enable the victim cache <b>908</b> to support write-miss buffer functionality. For example, auto flush logic <b>934</b> may monitor the processor interface <b>906</b> and direct draining the portions of the victim cache memory <b>928</b> allocated for write-miss buffering, for example, to higher level caches and memories via one or more memory interfaces <b>936</b>. As another example, MESI RAM <b>938</b> or the victim cache tag RAM may be configured to include one or more bit fields to store state information regarding write-miss buffer entries stored in the victim cache <b>910</b>.</p><p id="p-0103" num="0101">In certain cases, the victim cache and main cache may include multiple datapaths while configured as parallel caches which appear as a single cache to a processor. Each datapath is configured to handle a particular command in parallel with the other datapaths. For example, a first datapath <b>910</b> may be handling a read command to the main cache while the second datapath <b>942</b> handles a write-miss to the victim cache. In an embodiment with two datapaths for the victim cache there may be four combinations of cache commands for a first datapath <b>940</b> and a second datapath <b>942</b>: read/read, read/write, write/read, and write/write. In addition, each command combination could result in a cache hit/hit, hit/miss, miss/hit, or miss/miss. In addition, the two commands could potentially be addressed to the same memory address with varying privilege levels and color tags. In certain cases, to facilitate controlling the parallel caches, a centralized controller <b>944</b> may help coordinate handling of read and write requests as between the main cache <b>908</b> and the victim cache <b>910</b>. In certain cases, the centralized controller <b>944</b> may be configured to handle coordination as between the main cache <b>908</b> and the victim cache <b>910</b> and handing off tasks for the main cache <b>908</b> and the victim cache <b>910</b> to the main cache controller <b>916</b> and victim cache controller <b>926</b>, respectively. The centralized controller <b>944</b> may also detect and handle potential conflicts as well. For example, where read request received from a processor, the centralized controller <b>944</b> may check with the main cache <b>908</b> and the victim cache <b>910</b> to determine that the addressed memory location of the read request is not stored in either the main cache <b>908</b> nor the victim cache <b>910</b> and thus is a read miss. The centralized controller <b>944</b> may also check the victim cache <b>910</b> to determine that the addressed memory location is not stored as a write-miss in the victim cache <b>910</b>, or is being flushed out of the victim cache <b>910</b>. If the addressed memory location is stored as a write-miss in the victim cache <b>910</b>, then the centralized controller <b>944</b> may stall the read request to flush the addressed memory location. The centralized controller <b>944</b> may then issue a request to a higher level cache or memory for the addressed memory location.</p><p id="p-0104" num="0102">In certain cases, if a read or a write request is a hit in the main cache <b>908</b>, the results of the victim cache <b>910</b> may be disregarded. Where the main cache <b>908</b> is configured as a one way associative cache, cache request conflicts as with multiple datapaths are straight forward. Cache request conflicts from the multiple datapaths may be an issue for in the victim cache <b>910</b> where the victim cache <b>910</b> is fully associative and can store write-miss entries as well as cache entries. Cache request conflicts for two datapaths may be handled as described in the following examples. Of note, in the following examples cache operations are described in the context of a particular datapath. However, it may be understood that the examples are directed to combinations of particular cache operations, and which datapath a particular cache operation is on does not matter.</p><p id="p-0105" num="0103">In a first example, there is a cache read miss for the first datapath and a cache write hit for the second datapath, with two different memory addresses. In certain cases where the victim cache <b>910</b> is fully associative, cache requests can go to any location within the victim cache <b>910</b>. Referring to <figref idref="DRAWINGS">FIG. <b>7</b></figref>, address generation <b>728</b> for a location within the victim cache occurs in the E2 pipestage along with address lookup in the victim cache tag RAM <b>704</b>, thus address generation <b>728</b> for a location within the victim cache is performed before it is known whether an address of the cache request is a hit or miss. Once centralized controller <b>944</b> determines that there is a read miss on the main cache <b>908</b>, a request to obtain the memory address of the read request is issued to a higher level cache or memory. Where the main cache <b>908</b> is one way associative, the memory address of the read request of the first datapath maps to a single location in the main cache <b>908</b>. If there is already cached data in the single location, the already cached data is evicted from the main cache <b>908</b> to the victim cache <b>910</b> to the pre-generated location within the victim cache <b>910</b>. If this pre-generated location is the same location the cache write of the second datapath is a hit on, a conflict occurs. This conflict may be detected by the centralized controller <b>944</b>. As indicated above, address generation for a location within the victim cache <b>910</b> occurs before it is known whether the address of cache request is a hit or a miss, thus there is an address generated for a second location within the victim cache <b>910</b> for the cache write of the second datapath prior to the determination that the cache write is a hit. Based on the detection of the conflict, this second location within the victim cache may be used to store the data evicted from the main cache <b>908</b> by the read miss.</p><p id="p-0106" num="0104">In another example, there may be a cache read miss for the first datapath and a cache write hit for the second datapath, as with the first example, but in this example, the cache read misses in the main cache and the cache write hits in the main cache as well. In certain cases, the main cache is a one-way associate cache (e.g., direct mapped cache) where particular memory addresses are mapped to particular locations within the main cache. In this example with a direct mapped cache, the cache read and the cache write are mapped to the same location in the main cache. In this example, due to the read miss, a request to obtain the memory address of the read request is issued to a higher level cache or memory and the already cached data is evicted from the main cache <b>908</b> to the victim cache <b>910</b> to a pre-generated location, here location A, within the victim cache <b>910</b>. In this example, the cache write of the second datapath hits the same location in the main cache which is being evicted. One possible solution to such a conflict is to load the requested read miss from the higher level cache or memory directly to the victim cache in a separate location. Another solution to the conflict is for the centralized controller <b>944</b> to stall the read miss such that the already cached data is not evicted to the victim cache <b>910</b> until after the cache write of the second datapath completes to location A in the main cache and location A is then evicted to the victim cache. In certain cases, the stall may occur while waiting for the memory write and eviction to complete.</p><p id="p-0107" num="0105">As another example, a first cache write may be received on the first datapath for the victim cache <b>910</b> and a second cache write is also received on the second datapath for the victim cache <b>910</b>. If the first cache write and the second cache write are addressed to different memory addresses, then both cache writes may proceed in parallel to the victim cache <b>910</b>. If the first cache write and the second cache write are both addressed to the same memory address and both are cache misses, then the victim cache controller <b>926</b> allocates a single location in the victim cache write-miss memory <b>928</b> and merges the first cache write and the second cache write in the victim cache store queue <b>930</b>. The merged data may then be written to the victim cache write-miss memory <b>928</b> along with merged byte enable, privilege, and color tag information. If the first cache write and the second cache write are both addressed to the same memory address and both are cache hits, both the first cache write and the second cache write are merged into the cache at the hit location.</p><p id="p-0108" num="0106">As another example a cache read may be received on the first datapath for the victim cache <b>910</b> and a cache write may be received on the second datapath for the victim cache <b>910</b>. In the cases where the cache read is a hit and the cache write is a hit to different locations in the victim cache <b>910</b>, the cache read and cache write proceed in parallel without conflicts. In the case the cache read is a hit and the cache write is a miss to different locations in the victim cache <b>910</b>, the cache read and cache write also proceed in parallel without conflicts. In the case the cache read is a miss and the cache write is a hit to different locations in the victim cache <b>910</b>, the cache read may use an address generated for a location within the victim cache <b>910</b> for the cache write as discussed above. In the case the cache read is a miss and the cache write is a miss to different locations in the victim cache <b>910</b>, both the cache read and the cache write use addresses generated for locations within the victim cache <b>910</b>.</p><p id="p-0109" num="0107">In another example, a cache read may be received on the first datapath for the main cache <b>908</b> and a cache write may be received on the second datapath for the main cache <b>908</b>. In certain cases, the cache read may be a hit for a location (e.g., cache line or slot) of the main cache <b>908</b>. The cache write may also be a hit for the same location of the main cache <b>908</b>. In such a case, the cache read and the cache write may proceed in parallel without conflicts as the cache read may be performed relatively quickly and conclude before the cache write needs to access main cache location as the cache write proceeds through the store queue. In another case, the cache read may be a hit for a location in the main cache <b>908</b>. The cache write may be a miss for the same location in the main cache <b>908</b>. In such a case, the cache commands proceed in parallel normally as the cache read may complete prior to the cache write needing to access the cache location. In another case, the cache read may be a miss for a location in the main cache <b>908</b>. The cache write may be a hit for the same location in the main cache <b>910</b>. In such a case, as similar to that discussed above, the cache read may be stalled until after the cache write of the second datapath completes to the location in the main cache <b>908</b> and is evicted to the victim cache <b>908</b>. The cache read then proceeds to read the set of addresses from the higher level cache or memory into the main cache <b>910</b>. In another case, the cache read may be a miss for a first location in the main cache <b>908</b>. The cache write may also be a miss for the same location in the main cache <b>908</b>. In such a case, the cache read and the cache write may proceed in parallel without conflicts.</p><p id="p-0110" num="0108">In another example, a cache read may be received on the first datapath for the victim cache <b>910</b> and a cache write may be received on the second datapath for the victim cache <b>910</b>. In certain cases, the cache read may be a hit for an address stored in the victim cache <b>910</b>. The cache write may also be a hit for the same address stored in the victim cache <b>910</b>. In such a case, the cache read may proceed first and the cache write may be stalled until after the cache read completes. Alternatively, the order of the cache write and cache read may be based on the datapath on which the cache write and cache read are received, with the cache command arriving on a lower (or higher) numbered datapath being completed before the other cache command. In certain cases, the cache read may be a miss for an address stored in the victim cache <b>910</b>. The cache write may also be a miss for the same address stored in the victim cache <b>910</b>. In such a case, the cache write command may be forwarded to a higher level cache or memory and then the cache read may obtain the data from the higher level cache or memory after the cache write command completes for storage into the victim cache <b>910</b>.</p><p id="p-0111" num="0109">In another example, a first cache read may be received on the first datapath for the victim cache <b>910</b> and a second cache read may be received on the second datapath for the victim cache <b>910</b>. If the first cache read and the second cache read are for different memory addresses, then there are no conflicts for either hits or misses. In certain cases, the first cache read may be a miss for a first address of a set of addresses. The second cache read may also be a miss for a second address of the same set of addresses. If the first cache read and the second cache read have different priority levels, a higher level cache or memory is accessed based on the higher of the different priority levels. Otherwise, the higher level cache or memory is accessed and the set of memory addresses obtained for storage in the victim cache <b>910</b>. The case where the first cache read and the second cache read are for the same address is handled identically.</p><p id="p-0112" num="0110"><figref idref="DRAWINGS">FIG. <b>10</b></figref> is a flow diagram illustrating a technique for caching data <b>1000</b>, in accordance with aspects of the present disclosure. At block <b>1002</b>, a caching system receives a write memory request for a memory address. For example, a caching system, such as a L1 cache, can receive, via a processor interface, a write request from a processor. At block <b>1004</b>, a first sub-cache of the caching system determines that the memory address is not cached in the first sub-cache. For example, the caching system may include two parallel caches, a main cache and a victim cache. Memory addresses of cache requests may be checked as against both the main cache and victim cache in parallel. A write-miss occurs when a write request is received for a memory address not contained within the caching system. At block <b>1006</b>, second sub-cache of the caching system determines that the memory address is not cached in the second sub-cache. At block <b>1008</b>, data associated with the write memory request is stored in the second sub-cache. For example, the data of the write memory request may be stored in the victim cache. Additionally, the address associated with the write memory request may be stored in a tag RAM of the victim cache and byte enable logic associated with the write memory request may be stored in a byte enable memory of the victim cache. At block <b>1010</b>, an indication that the stored data corresponds to a write-miss is stored in a line type bit of the second sub-cache. For example, the victim cache includes a line type bit associated with lines of the victim cache. A bit may be set in the line type bit indicating that a particular line of the victim cache includes a write-miss. At block <b>1012</b>, the stored data may be flushed based on the indication. For example, stored write-miss data may be flushed the victim cache to a higher level memory by checking the line type bits of the cache lines and flushing the lines associated with write-misses.</p><p id="p-0113" num="0111"><figref idref="DRAWINGS">FIG. <b>11</b></figref> is a flow diagram illustrating a technique for caching data <b>1100</b>, in accordance with aspects of the present disclosure. At block <b>1102</b>, a caching system receives a write memory request for a memory address. For example, a caching system, such as a L1 cache, can receive, via a processor interface, a write request from a processor. At block <b>1104</b>, a first sub-cache of the caching system determines that the memory address is not cached in the first sub-cache. For example, the caching system may include two parallel caches, a main cache and a victim cache. Memory addresses of cache requests may be checked as against both the main cache and victim cache in parallel. A write-miss occurs when a write request is received for a memory address not contained within the caching system. At block <b>1106</b>, second sub-cache of the caching system determines that the memory address is not cached in the second sub-cache. At block <b>1108</b>, data associated with the write memory request is stored in the second sub-cache. For example, the data of the write memory request may be stored in the victim cache. Additionally, the address associated with the write memory request may be stored in a tag RAM of the victim cache and byte enable logic associated with the write memory request may be stored in a byte enable memory of the victim cache. At block <b>1110</b>, an indication that the stored data corresponds to a write-miss is stored in a line type bit of the second sub-cache. For example, the victim cache includes a line type bit associated with lines of the victim cache. A bit may be set in the line type bit indicating that a particular line of the victim cache includes a write-miss. At block <b>1112</b>, a line of the second sub-cache storing the write-miss is evicted based on an indication that the line has been fully written. For example, a bit may be calculated based on the byte enable logic indicating whether all, or half, of the bytes of a cache line have been filled with write data. Cache lines which are filled, or half filled, may be evicted from the victim cache based on the bit.</p><p id="p-0114" num="0112"><figref idref="DRAWINGS">FIG. <b>12</b></figref> is a flow diagram illustrating a technique for caching data <b>1200</b>, in accordance with aspects of the present disclosure. At block <b>1202</b>, a caching system receiving a write memory command for a memory address, the write memory command associated with a first privilege level. For example, a caching system, such as a L1 cache, can receive, via a processor interface, a write request from a processor. At block <b>1204</b>, a first sub-cache of the caching system determines that the memory address is not cached in the first sub-cache. For example, the caching system may include two parallel caches, a main cache and a victim cache. Memory addresses of cache requests may be checked as against both the main cache and victim cache in parallel. A write-miss occurs when a write request is received for a memory address not contained within the main cache nor the victim cache. At block <b>1206</b>, a second sub-cache of the caching system determines that the memory address is not cached in the second sub-cache, wherein the second sub-cache is configured to store, in parallel with the first sub-cache, cache data evicted from the first sub-cache and write-memory commands that are not cached in the first sub-cache. At block <b>1208</b>, data associated with the write memory command is stored in the second sub-cache. At block <b>1210</b>, a color tag bit associated with the data is stored in the second sub-cache. For example, a color tag bit may be stored within a bit field of a memory of the second sub-cache, such as the MESI RAM. At block <b>1212</b>, the stored data is evicted based on the color tag bit. For example, cache lines storing write miss data associated with a particular color tag bit may be evicted while the processor is asserting a drain signal and a color tag priority indication. After all cache lines with the particular color tag bit have been drained, the caching system may assert an idle signal. If the processor continues to assert the drain signal, other cache lines storing write miss data associated with other color tags may also be evicted.</p><p id="p-0115" num="0113"><figref idref="DRAWINGS">FIG. <b>13</b></figref> is a flow diagram illustrating a technique for caching data <b>1300</b>, in accordance with aspects of the present disclosure. At block <b>1302</b>, a caching system receives a write memory command for a memory address, the write memory command associated with a first color tag. For example, a caching system, such as a L1 cache, can receive, via a processor interface, a write request from a processor. The write request may include in an indication of a color tag associated with the write request. At block <b>1304</b>, a first sub-cache of the caching system determines that the memory address is not cached in the first sub-cache. For example, the caching system may include two parallel caches, a main cache and a victim cache. Memory addresses of cache requests may be checked as against both the main cache and victim cache in parallel. A write-miss occurs when a write request is received for a memory address not contained within the caching system. At block <b>1306</b>, second sub-cache of the caching system determines that the memory address is not cached in the second sub-cache. At block <b>1308</b>, data associated with the write memory command is stored in a cache line of the second sub-cache. For example, the data of the write request may be stored in a cache line of the victim cache. Additionally, the address associated with the write memory request may be stored in a tag RAM of the victim cache and byte enable logic associated with the write memory request may be stored in a byte enable memory of the victim cache. At block <b>1310</b>, the first color tag is stored in the second sub-cache. For example, the color tag may be stored using two bits within a bit field of a memory of the second sub-cache, such as the MESI RAM. At block <b>1312</b>, a second write memory command for the cache line is received, the write memory command associated with a second color tag. For example, a second write request to a memory address targeting the same cache line as the first write request may be received. The second write request is associated with a second color tag. The second color tag may be the same or different from the first color tag. At block <b>1314</b>, the second color tag is merged with the first color tag. For example, where the first color tag and the second color tag represent the same color, merging the two tags continues to set that color tag. Where the two color tags are different, merging may set both color tags. At block <b>1316</b>, the merged color tag is stored. At block <b>1318</b>, the cache line may be evicted based on the merged color tag. For example, where the first color tag and the second color tag represent the same color, eviction may be based on that color tag. Where the two color tags are different, eviction may be based on either color tag.</p><p id="p-0116" num="0114"><figref idref="DRAWINGS">FIG. <b>14</b></figref> is a flow diagram illustrating a technique for caching data <b>1400</b>, in accordance with aspects of the present disclosure. At block <b>1402</b>, a caching system receiving a first write memory command for a memory address, the first write memory command associated with a first privilege level. For example, a caching system, such as a L1 cache, can receive, via a processor interface, a write request from a processor. At block <b>1404</b>, a first sub-cache of the caching system determines that the memory address is not cached in the first sub-cache. For example, the caching system may include two parallel caches, a main cache and a victim cache. Memory addresses of cache requests may be checked as against both the main cache and victim cache in parallel. A write-miss occurs when a write request is received for a memory address not contained within the main cache nor the victim cache. At block <b>1406</b>, a second sub-cache of the caching system determines that the memory address is not cached in the second sub-cache, wherein the second sub-cache is configured to store, in parallel with the first sub-cache, cache data evicted from the first sub-cache and write-memory commands that are not cached in the first sub-cache. At block <b>1408</b>, first data associated with the first write memory command is stored in a cache line of the second sub-cache. At block <b>1410</b>, the first privilege level is stored in the second sub-cache. For example, the first privilege level may comprise a two part privilege level, such as root/guest-user/supervisor. This two part privilege level may be stored using two bits within a bit field of a memory of the second sub-cache, such as the MESI RAM. At block <b>1412</b>, a second write memory command for the cache line is received, the second write memory command associated with a second level of privilege. For example, a second write request to a memory address targeting the same cache line as the first write request may be received. The second write request is associated with a second privilege level, which may be the same or different from the first write request. At block <b>1414</b>, the first level of privilege with the second level of privilege are merged. For example, the privilege levels may be merged based on a privilege merge table or may be merged by selecting the lower privilege level of the privilege levels being merged. At block <b>1416</b>, the merged privilege level are stored. At block <b>1418</b>, the merged privilege level is output with the cache line. For example, the cache line including a merged first write request and second write request may be evicted in a store miss packet including the merged privilege level to a higher level cache or memory.</p><p id="p-0117" num="0115"><figref idref="DRAWINGS">FIG. <b>15</b></figref> is a flow diagram illustrating a technique for caching data <b>1500</b>, in accordance with aspects of the present disclosure. At block <b>1502</b>, a caching system receives a write memory request for a memory address. For example, a caching system, such as a L1 cache, can receive, via a processor interface, a write request from a processor. At block <b>1504</b>, a first sub-cache of the caching system determines that the memory address is not cached in the first sub-cache. For example, the caching system may include two parallel caches, a main cache and a victim cache. Memory addresses of cache requests may be checked as against both the main cache and victim cache in parallel. A write-miss occurs when a write request is received for a memory address not contained within the caching system. At block <b>1506</b>, second sub-cache of the caching system determines that the memory address is not cached in the second sub-cache. At block <b>1508</b>, data associated with the write memory request is stored in the second sub-cache. For example, the data of the write memory request may be stored in the victim cache. Additionally, the address associated with the write memory request may be stored in a tag RAM of the victim cache and byte enable logic associated with the write memory request may be stored in a byte enable memory of the victim cache. At block <b>1510</b>, an indication that the stored data corresponds to a write-miss is stored in a line type bit of the second sub-cache. For example, the victim cache includes a line type bit associated with lines of the victim cache. A bit may be set in the line type bit indicating that a particular line of the victim cache includes a write-miss.</p><p id="p-0118" num="0116"><figref idref="DRAWINGS">FIG. <b>16</b></figref> is a flow diagram illustrating a technique for caching data <b>1600</b>, in accordance with aspects of the present disclosure. At block <b>1602</b>, a caching system receives two or more cache commands. For example, a caching system, such as a L1 cache, can receive, via a processor interface, a multiple cache commands using, for example, two or more data paths. At block <b>1604</b>, a conflict is determined to exist between the two or more cache commands. For example, a cache controller may determine that a cache conflict exists as between the two cache commands. A conflict can arise when the two cache commands cause conflicting changes to the same cache location. At block <b>1606</b>, a conflict resolution is determined between the received two or more cache commands. At block <b>1608</b>, two or more cache commands are sent to a first sub-cache and a second sub-cache, wherein the second sub-cache is configured to store, in parallel with the first sub-cache, cache data evicted from the first sub-cache and write-memory commands that are not cached in the first sub-cache.</p><heading id="h-0006" level="1">EXAMPLES</heading><p id="p-0119" num="0117">In the following section, further exemplary embodiments are provided.</p><p id="p-0120" num="0118">Example 1 includes a caching system comprising: a first sub-cache; and a second sub-cache in parallel with the first sub-cache, wherein the second sub-cache includes: a set of cache lines; line type bits configured to store an indication that a corresponding cache line of the set of cache lines is configured to store write-miss data; and an eviction controller configured to flush stored write-miss data based on the line type bits.</p><p id="p-0121" num="0119">Example 2 includes the caching system of example 1, wherein the second sub-cache further comprises: a tag random access memory (RAM) configured to store a memory address associated with the stored write-miss data; and a byte enable memory configured to store byte enable logic associated with the stored write-miss data, and wherein the eviction controller is configured to flush stored write-miss data by transmitting a memory write request to a higher level memory based the stored memory address and stored byte enable logic.</p><p id="p-0122" num="0120">Example 3 includes the caching system of example 1, wherein the caching system further includes a processor interface, and wherein the eviction controller is further configured to: monitor activity on the processor interface; and flush stored write-miss data based on the monitored activity.</p><p id="p-0123" num="0121">Example 4 includes the caching system of example 3, wherein monitoring activity on the processor interface comprises detecting idle activity on the processor interface.</p><p id="p-0124" num="0122">Example 5 includes the caching system of example 4, wherein detecting idle activity comprises determining whether memory requests have been received for a predetermined number of clock cycles.</p><p id="p-0125" num="0123">Example 6 includes the caching system of example 4, wherein the eviction controller is further configured to: determine that activity on the processor interface has resumed; and cancel flushing of the stored write-miss data.</p><p id="p-0126" num="0124">Example 7 includes the caching system of example 6, wherein determining that activity on the processor interface has resumed comprises detecting a cache request receipt from the processor.</p><p id="p-0127" num="0125">Example 8 includes a method for caching data, comprising: receiving, by a caching system, a write memory request for a memory address; determining, by a first sub-cache of the caching system, that the memory address is not cached in the first sub-cache; determining, by second sub-cache of the caching system, that the memory address is not cached in the second sub-cache; storing data associated with the write memory request in the second sub-cache; storing, in a line type bit of the second sub-cache, an indication that the stored data corresponds to a write-miss; and flushing the stored data based on the indication.</p><p id="p-0128" num="0126">Example 9 includes the method of example 8, wherein flushing the stored data comprises transmitting, by the second-sub cache, a memory write request to a higher level memory.</p><p id="p-0129" num="0127">Example 10 includes the method of example 8, further comprising monitoring activity on a processer interface, and wherein flushing the stored data is further based on the monitored activity.</p><p id="p-0130" num="0128">Example 11 includes the method of example 10, wherein monitoring activity on the processor interface comprises detecting idle activity on the processor interface.</p><p id="p-0131" num="0129">Example 12 includes the method of example 11, wherein detecting idle activity comprises determining that memory requests have not been received for a predetermined number of clock cycles.</p><p id="p-0132" num="0130">Example 13 includes the method of example 11, further comprising: determining that activity on the processor interface has resumed; and cancelling flushing of the stored write-miss data.</p><p id="p-0133" num="0131">Example 14 includes the method of example 13, wherein determining that activity on the processor interface has resumed comprises detecting a cache request receipt.</p><p id="p-0134" num="0132">Example 15 includes a device comprising: a processor; a first sub-cache; and a second sub-cache in parallel with the first sub-cache, wherein the second sub-cache includes: a set of cache lines; line type bits configured store an indication that a corresponding cache line of the set of cache lines is configured to store write-miss data; and an eviction controller configured to flush stored write-miss data based on the line type bits.</p><p id="p-0135" num="0133">Example 16 includes the device of example 15, wherein the second sub-cache further comprises: a tag random access memory (RAM) configured to store a memory address associated with the stored write-miss data; and a byte enable memory configured to store byte enable logic associated with the stored write-miss data, and wherein the eviction controller is configured to flush stored write-miss data by transmitting a memory write request to a higher level memory based the stored memory address and stored byte enable logic.</p><p id="p-0136" num="0134">Example 17 includes device of example 15, wherein the caching system further includes a processor interface, and wherein the eviction controller is further configured to: monitor activity on the processor interface; and flush stored write-miss data based on the monitored activity.</p><p id="p-0137" num="0135">Example 18 includes the device of example 17, wherein monitoring activity on the processor interface comprises detecting idle activity on the processor interface.</p><p id="p-0138" num="0136">Example 19 includes the device of example 18, wherein detecting idle activity comprises determining whether memory requests have been received for a predetermined number of clock cycles.</p><p id="p-0139" num="0137">Example 20 includes the device of example 18, wherein the eviction controller is further configured to: determine that activity on the processor interface has resumed; and cancel flushing of the stored write-miss data.</p><p id="p-0140" num="0138">Example 21 includes a caching system comprising: a first sub-cache; and a second sub-cache, coupled in parallel with the first cache, for storing cache data evicted from the first sub-cache and write-memory commands that are not cached in the first sub-cache, and wherein the second sub-cache includes: color tag bits configured to store an indication that a corresponding cache line of the second sub-cache storing write miss data is associated with a color tag, and an eviction controller configured to evict cache lines of the second sub-cache storing write-miss data based on the color tag associated with the cache line.</p><p id="p-0141" num="0139">Example 22 includes the caching system of Example 21, wherein the second sub-cache includes a bit field configured to store a state of the color tags.</p><p id="p-0142" num="0140">Example 23 includes the caching system of Example 22, wherein the bit field includes a bit storing the state for each color tag.</p><p id="p-0143" num="0141">Example 24 includes the caching system of Example 23, wherein the bit field is stored in a memory tracking a modified, exclusive, shared, and invalid (MESI) state of entries in the second sub-cache.</p><p id="p-0144" num="0142">Example 25 includes the caching system of Example 24, wherein the MESI memory is configured to store an indication that the corresponding cache line of the second sub-cache is storing write-miss data.</p><p id="p-0145" num="0143">Example 26 includes the caching system of Example 21, wherein the caching system further includes a processor interface, and wherein the eviction controller is further configured to: receive, on the processor interface, a color tag priority indication; and evict cache lines of the second sub-cache storing write-miss data based on the received color tag priority indication.</p><p id="p-0146" num="0144">Example 27 includes the caching system of claim <b>6</b>, wherein the eviction controller is further configured to assert an idle signal on the processor interface after all cache lines of the second sub-cache storing write-miss data with color tag bits corresponding to the color tag priority indication have been evicted.</p><p id="p-0147" num="0145">Example 28 includes a method for caching data, comprising receiving, by a caching system, a write memory command for a memory address; determining, by a first sub-cache of the caching system, that the memory address is not cached in the first sub-cache; determining, by second sub-cache of the caching system, that the memory address is not cached in the second sub-cache, wherein the second sub-cache is configured to store, in parallel with the first sub-cache, cache data evicted from the first sub-cache and write-memory commands that are not cached in the first sub-cache; storing data associated with the write memory command in the second sub-cache; storing, in the second sub-cache, a color tag bit associated with the data; and evicting the stored data based on the color tag bit.</p><p id="p-0148" num="0146">Example 29 includes the method of Example 28, further comprising: receiving a color tag priority indication from a processor; receiving a drain signal from the processor; and wherein evicting the stored data is based on the received color tag priority indication.</p><p id="p-0149" num="0147">Example 30 includes the method of claim Example 29, further comprising: asserting an idle signal after all cache lines of the second sub-cache storing write-miss data with color tag bits corresponding to the color tag priority indication have been evicted.</p><p id="p-0150" num="0148">Example 31 includes the method of Example 30, further comprising: continuing to receive the drain signal from the processor; and evicting stored data with color tag bits which do not correspond to the color tag priority indication.</p><p id="p-0151" num="0149">Example 32 includes the method of Example 39, further comprising determining that storing the data has not been completed; and waiting until the data has been stored,</p><p id="p-0152" num="0150">Example 33 includes the method of Example 38, further comprising storing the color tag bit in a bit field associated with a corresponding color tag bit.</p><p id="p-0153" num="0151">Example 34 includes a device comprising: a processor; a first sub-cache; and a second sub-cache, coupled in parallel with the first sub-cache, for storing cache data evicted from the first sub-cache and write-memory commands that are not cached in the first sub-cache, and wherein the second sub-cache includes: color tag bits configured to store an indication that a corresponding cache line of the second sub-cache storing write-miss data is associated with a color tag, and an eviction controller configured to evict the cache line of the second sub-cache storing write-miss data based on the color tag associated with the cache line.</p><p id="p-0154" num="0152">Example 35 includes the device of Example 34, wherein the second sub-cache includes a bit field configured to store a state of the color tags.</p><p id="p-0155" num="0153">Example 36 includes the device of Example 35, wherein the bit field includes a bit storing the state for each color tag.</p><p id="p-0156" num="0154">Example 37 includes the device of Example 36, wherein the bit field is stored in a memory tracking a modified, exclusive, shared, and invalid (MESI) state of entries in the second sub-cache.</p><p id="p-0157" num="0155">Example 38 includes the device of Example 37, wherein the MESI memory is configured to store an indication that the corresponding cache line of the second sub-cache is storing write-miss data.</p><p id="p-0158" num="0156">Example 39 includes the device of Example 34, wherein the caching system further includes a processor interface, and wherein the eviction controller is further configured to: receive, on the processor interface, a color tag priority indication; and evict cache lines of the second sub-cache storing write-miss data based on the received color tag priority indication.</p><p id="p-0159" num="0157">Example 40 includes the device of Example 39, wherein the eviction controller is further configured to assert an idle signal on the processor interface after all cache lines of the second sub-cache storing write-miss data with color tag bits corresponding to the color tag priority indication have been evicted.</p><p id="p-0160" num="0158">Example 41 includes a caching system comprising: a first sub-cache; and a second sub-cache, coupled in parallel with the first sub-cache, for storing cache data evicted from the first sub-cache and write-memory commands that are not cached in the first sub-cache, the second sub-cache including: color tag bits configured to store an indication that a corresponding line of the second sub-cache is associated with a color tag; and an eviction controller configured to evict cache lines of the second sub-cache storing write-memory data based on the color tag associated with the line, and wherein the second sub-cache is further configured to: receive a first write memory command for a memory address, the write memory command associated with a first color tag; store first data associated with the first write memory command in a cache line of the second sub-cache; store the first color tag in the second sub-cache; receive a second write memory command for the cache line, the write memory command associated with a second color tag; merge the second color tag with the first color tag; store the merged color tag; and evict the cache line based on the merged color tag.</p><p id="p-0161" num="0159">Example 42 includes the caching system of Example 41, wherein the first color tag and the second color tag represent the same color tag.</p><p id="p-0162" num="0160">Example 43 includes the caching system of Example 41, wherein the first color tag and the second color tag represent different color tags, and wherein the merged color tag comprises a first bit representing the first color tag and a second bit representing the second color tag.</p><p id="p-0163" num="0161">Example 44 includes the caching system of Example 43, wherein the second sub-cache is further configured to evict the cache line based on the first color tag.</p><p id="p-0164" num="0162">Example 45 includes the caching system of Example 44, wherein the second sub-cache is further configured to evict the cache line based on the second color tag.</p><p id="p-0165" num="0163">Example 46 includes the caching system of Example 41, wherein the first color tag and second color tag are stored in a bit field in a memory tracking modified, exclusive, shared, and invalid (MESI) state of entries in the second sub-cache data.</p><p id="p-0166" num="0164">Example 47 includes the caching system of Example 46, wherein the bit field includes a bit storing the state for each color tag.</p><p id="p-0167" num="0165">Example 48 includes a method for caching data, comprising: receiving, by a caching system, a write memory command for a memory address, the write memory command associated with a first color tag; determining, by a first sub-cache of the caching system, that the memory address is not cached in the first sub-cache; determining, by second sub-cache of the caching system, that the memory address is not cached in the second sub-cache, wherein the second sub-cache is configured to store, in parallel with the first sub-cache, cache data evicted from the first sub-cache and write-memory commands that are not cached in the first sub-cache; storing first data associated with the first write memory command in a cache line of the second sub-cache; storing the first color tag in the second sub-cache; receiving a second write memory command for the cache line, the write memory command associated with a second color tag; merging the second color tag with the first color tag; storing the merged color tag; and evicting the cache line based on the merged color tag.</p><p id="p-0168" num="0166">Example 49 includes the method of Example 48, wherein the first color tag and the second color tag represent the same color tag.</p><p id="p-0169" num="0167">Example 50 includes the method of Example 48, wherein the first color tag and the second color tag represent different color tags, and wherein the merged color tag comprises a first bit representing the first color tag and a second bit representing the second color tag.</p><p id="p-0170" num="0168">Example 51 includes the method of Example 50, wherein the evicting is based on the first color tag.</p><p id="p-0171" num="0169">Example 52 includes the method of Example 51, wherein the evicting is based on the second color tag.</p><p id="p-0172" num="0170">Example 53 includes the method of Example 48, wherein the first color tag and second color tag are stored in a bit field in a memory tracking a modified, exclusive, shared, and invalid (MESI) state of entries in the second sub-cache data.</p><p id="p-0173" num="0171">Example 54 includes the method of claim Example 53, wherein the bit field includes a bit storing the state for each color tag.</p><p id="p-0174" num="0172">Example 55 includes a device comprising: a processor; a first sub-cache; and a second sub-cache coupled in parallel with the first sub-cache, for storing cache data evicted from the first sub-cache and write-memory commands that are not cached in the first sub-cache, and the second sub-cache including: color tag bits configured to store an indication that a corresponding line of the second sub-cache is associated with a color tag; and an eviction controller configured to evict cache lines of the second sub-cache storing write-memory data based on the color tag associated with the line, and wherein the second sub-cache is further configured to: receive a first write memory command for a memory address, the write memory command associated with a first color tag; store first data associated with the first write memory command in a cache line of the second sub-cache; store the first color tag in the second sub-cache; receive a second write memory command for the cache line, the write memory command associated with a second color tag; merge the second color tag with the first color tag; store the merged color tag; and evict the cache line based on the merged color tag.</p><p id="p-0175" num="0173">Example 56 includes the device of Example 55, wherein the first color tag and the second color tag represent the same color tag.</p><p id="p-0176" num="0174">Example 57 includes the device of Example 55, wherein the first color tag and the second color tag represent different color tags, and wherein the merged color tag comprises a first bit representing the first color tag and a second bit representing the second color tag.</p><p id="p-0177" num="0175">Example 58 includes the device of Example 57, wherein the second sub-cache is further configured to evict the cache line based on the first color tag.</p><p id="p-0178" num="0176">Example 59 includes the device of Example 58, wherein the second sub-cache is further configured to evict the cache line data based on the second color tag.</p><p id="p-0179" num="0177">Example 60 includes the device of Example 55, wherein the first color tag and second color tag are stored in a bit field in a memory tracking modified, exclusive, shared, and invalid (MESI) state of entries in the second sub-cache data.</p><p id="p-0180" num="0178">Example 61 includes a caching system comprising: a first sub-cache; a second sub-cache, coupled in parallel with the first sub-cache, for storing cache data evicted from the first sub-cache and write-memory commands that are not cached in the first sub-cache, the second sub-cache including privilege bits configured to store an indication that a corresponding cache line of the second sub-cache is associated with a level of privilege, and wherein the second sub-cache is further configured to: receive a first write memory command for a memory address, the first write memory command associated with a first level of privilege; store, in a cache line of the second sub-cache, first data associated with the first write memory command; store, in the second sub-cache, the level of privilege associated with the cache line; receive a second write memory command for the cache line, the second write memory command associated with a second level of privilege; merge the first level of privilege with the second level of privilege; store the merged privilege level; and output the merged privilege level with the cache line.</p><p id="p-0181" num="0179">Example 62 includes the caching system of Example 61, wherein privilege level information is stored in a bit field in a memory tracking modified, exclusive, shared, and invalid (MESI) state of entries in the second sub-cache data.</p><p id="p-0182" num="0180">Example 63 includes the caching system of Example 62, wherein the privilege level comprises a two part privilege level.</p><p id="p-0183" num="0181">Example 64 includes the caching system of Example 63, wherein the bit field includes two bits for storing the privilege level.</p><p id="p-0184" num="0182">Example 65 includes the caching system of Example 61, wherein the second sub-cache includes a privilege merge table, the privilege merge table indicating how different levels of privilege are merged.</p><p id="p-0185" num="0183">Example 66 includes the caching system of Example 65, wherein the privilege merge table is predefined.</p><p id="p-0186" num="0184">Example 67 includes the caching system of Example 61, wherein merging the first level of privilege with the second level of privilege comprises selecting the lower privilege level.</p><p id="p-0187" num="0185">Example 68 includes a method for caching data, comprising: receiving, by a caching system, a first write memory command for a memory address, the first write memory command associated with a first privilege level; determining, by a first sub-cache of the caching system, that the memory address is not cached in the first sub-cache; determining, by second sub-cache of the caching system, that the memory address is not cached in the second sub-cache, wherein the second sub-cache is configured to store, in parallel with the first sub-cache, cache data evicted from the first sub-cache and write-memory commands that are not cached in the first sub-cache; storing first data associated with the first write memory command in a cache line of the second sub-cache; storing the first privilege level in the second sub-cache; receiving a second write memory command for the cache line, the second write memory command associated with a second level of privilege; merging the first level of privilege with the second level of privilege; storing the merged privilege level; and outputting the merged privilege level with the cache line.</p><p id="p-0188" num="0186">Example 69 includes the method of Example 67, wherein the privilege level comprises a two part privilege level.</p><p id="p-0189" num="0187">Example 70 includes the method of Example 69, wherein the second sub-cache includes two bits in a bit field for storing the privilege level.</p><p id="p-0190" num="0188">Example 71 includes the method of Example 68, wherein the merging is based on a privilege merge table indicating how different levels of privilege are merged.</p><p id="p-0191" num="0189">Example 72 includes the method of Example 71, wherein the privilege merge table is predefined.</p><p id="p-0192" num="0190">Example 73 includes the method of Example 68, wherein merging the first level of privilege with the second level of privilege comprises selecting the lower privilege level.</p><p id="p-0193" num="0191">Example 74 includes a device comprising: a processor; a first sub-cache; and a second sub-cache coupled in parallel with the first sub-cache, for storing cache data evicted from the first sub-cache and write-memory commands that are not cached in the first sub-cache, the second sub-cache including privilege bits configured to store an indication that a corresponding cache line of the second sub-cache is associated with a level of privilege, and wherein the second sub-cache is further configured to: receive a first write memory command for a memory address, the first write memory command associated with a first level of privilege; store, in a cache line of the second sub-cache, first data associated with the first write memory command; store, in the second sub-cache, the level of privilege associated with the cache line; receive a second write memory command for the cache line, the second write memory command associated with a second level of privilege; merge the first level of privilege with the second level of privilege; store the merged privilege level; and output the merged privilege level with the cache line.</p><p id="p-0194" num="0192">Example 75 includes the device of Example 74, wherein privilege level information is stored in a bit field in a memory tracking modified, exclusive, shared, and invalid (MESI) state of entries in the second sub-cache data.</p><p id="p-0195" num="0193">Example 76 includes the device of Example 75, wherein the privilege level comprises a two part privilege level.</p><p id="p-0196" num="0194">Example 77 includes the device of Example 76, wherein the bit field includes two bits for storing the privilege level.</p><p id="p-0197" num="0195">Example 78 includes the device of Example 75, wherein the second sub-cache includes a privilege merge table, the privilege merge table indicating how different levels of privilege are merged.</p><p id="p-0198" num="0196">Example 79 includes the device of Example 78, wherein the privilege merge table is predefined.</p><p id="p-0199" num="0197">Example 80 includes the device of Example 75, wherein merging the first level of privilege with the second level of privilege comprises selecting the lower privilege level.</p><p id="p-0200" num="0198">Example 81 includes a caching system comprising: a first sub-cache; and a second sub-cache coupled in parallel with the first sub-cache; wherein the second sub-cache includes line type bits configured to store an indication that a corresponding line of the second sub-cache is configured to store write-miss data.</p><p id="p-0201" num="0199">Example 82 includes the caching system of Example 81, wherein the second sub-cache further comprises a tag random access memory (RAM) configured to store a memory address associated with the stored write-miss data.</p><p id="p-0202" num="0200">Example 83 includes the caching system of Example 81, wherein the second sub-cache further comprises a byte enable memory configured to store byte enable logic associated with the stored write-miss data.</p><p id="p-0203" num="0201">Example 84 includes the caching system of Example 83, wherein the byte-enable memory includes memory positions corresponding with each cache line of the second sub-cache.</p><p id="p-0204" num="0202">Example 85 includes the caching system of Example 81, wherein the stored indication indicates whether the corresponding cache line of the second sub-cache is storing write miss entries or cache entries.</p><p id="p-0205" num="0203">Example 86 includes the caching system of Example 81, wherein the line type bits are stored in a memory tracking modified, exclusive, shared, and invalid (MESI) state of entries in the second sub-cache.</p><p id="p-0206" num="0204">Example 87 includes the caching system of Example 81, wherein the first sub-cache is a n-way set associative cache and wherein the second sub-cache is a fully associative cache.</p><p id="p-0207" num="0205">Example 88 includes a method for caching data, comprising: receiving, by a caching system, a write memory request for a memory address; determining, by a first sub-cache of the caching system, that the memory address is not cached in the first sub-cache; determining, by second sub-cache of the caching system, the second sub-cache coupled in parallel with the first sub-cache, that the memory address is not cached in the second sub-cache; storing data associated with the write memory request in the second sub-cache; and storing, in a line type bit of the second sub-cache, an indication that the stored data corresponds to a write-miss.</p><p id="p-0208" num="0206">Example 89 includes the method of Example 88, further comprising storing a memory address associated with the stored write-miss data in a tag random access memory (RAM).</p><p id="p-0209" num="0207">Example 90 includes the method of Example 88, further comprising storing byte enable logic associated with the stored write-miss data in a byte-enable memory.</p><p id="p-0210" num="0208">Example 91 includes the method of Example 88, wherein the line type bits are stored in a memory tracking modified, exclusive, shared, and invalid (MESI) state of entries in the second sub-cache.</p><p id="p-0211" num="0209">Example 92 includes the method of Example 88, further comprising: evicting a cache entry from a line of the second sub-cache, and wherein storing data associated with the write memory request comprises storing the data in the line.</p><p id="p-0212" num="0210">Example 93 includes the method of Example 88, wherein the stored indication indicates whether the corresponding cache line of the second sub-cache is storing write miss entries or cache entries.</p><p id="p-0213" num="0211">Example 94. A device comprising: a processor; a first sub-cache; and a second sub-cache coupled in parallel with the first sub-cache; wherein the second sub-cache includes line type bits configured to store an indication that a corresponding line of the second sub-cache is configured to store write-miss data.</p><p id="p-0214" num="0212">Example 95 includes the device of Example 94, wherein the second sub-cache further comprises a tag random access memory (RAM) configured to store a memory address associated with the stored write-miss data.</p><p id="p-0215" num="0213">Example 96 includes the device of Example 94, wherein the second sub-cache further comprises a byte enable memory configured to store byte enable logic associated with the stored write-miss data.</p><p id="p-0216" num="0214">Example 97 includes the device of Example 96, wherein the byte-enable memory includes memory positions corresponding with each cache line of the second sub-cache.</p><p id="p-0217" num="0215">Example 98 includes the device of Example 94, wherein the stored indication indicates whether the corresponding cache line of the second sub-cache is storing write miss entries or cache entries.</p><p id="p-0218" num="0216">Example 99 includes the device of Example 94, wherein the line type bits are stored in a memory tracking modified, exclusive, shared, and invalid (MESI) state of entries in the second sub-cache.</p><p id="p-0219" num="0217">Example 100 includes the device of claim <b>94</b>, wherein the first sub-cache is a n-way set associative cache and wherein the second sub-cache is a fully associative cache.</p><p id="p-0220" num="0218">Example 101 includes a caching system comprising: a first sub-cache; and a second sub-cache in parallel with the first sub-cache, wherein the second sub-cache includes: a set of cache lines; line type bits configured to store an indication that a corresponding cache line of the set of cache lines is configured to store write-miss data; and an eviction controller configured to evict a cache line of the second sub-cache storing write-miss data based on an indication that the cache line has been fully written.</p><p id="p-0221" num="0219">Example 102 includes the caching system of Example 101, wherein the eviction controller is further configured to evict a cache line of the second sub-cache storing write-miss data based on an indication that half of the cache line has been written.</p><p id="p-0222" num="0220">Example 103 includes the caching system of Example 102, wherein the eviction controller is configured to determine that no cache line of the second sub-cache storing write-miss data is fully written before evicting the cache line based on the indication that half of the cache line has been written.</p><p id="p-0223" num="0221">Example 104 includes the caching system of Example 102, wherein the second sub-cache further comprises a byte enable memory configured to store byte enable logic associated with the stored write-miss data, and wherein the byte enable memory includes a first bit storing the indication that the cache line has been fully written.</p><p id="p-0224" num="0222">Example 105 includes the caching system of Example 104, wherein the byte enable memory includes a second bit storing the indication that half of the cache line has been written.</p><p id="p-0225" num="0223">Example 106 includes the caching system of Example 105, wherein the first and second bits are determined based on the byte enable logic associated with the stored write-miss data.</p><p id="p-0226" num="0224">Example 107 includes the caching system of Example 106, wherein the first and second bits are determined based on the byte enable logic each time write-miss data is stored in the second sub-cache.</p><p id="p-0227" num="0225">Example 108 includes a method for caching data, comprising: receiving, by a caching system, a write memory request for a memory address; determining, by a first sub-cache of the caching system, that the memory address is not cached in the first sub-cache; determining, by second sub-cache of the caching system, that the memory address is not cached in the second sub-cache; storing data associated with the write memory request in the second sub-cache; storing, in a line type bit of the second sub-cache, an indication that the stored data corresponds to a write-miss; and evicting a cache line of the second sub-cache storing the write-miss based on an indication that the cache line has been fully written.</p><p id="p-0228" num="0226">Example 109 includes the method of Example 108, further comprising evicting a cache line of the second sub-cache storing write-miss data based on an indication that half of the cache line has been written.</p><p id="p-0229" num="0227">Example 110 includes the method of Example 109, further comprising determining that no cache line of the second sub-cache storing write-miss data is fully written before evicting the cache line based on the indication that half of the cache line has been written.</p><p id="p-0230" num="0228">Example 111 includes the method of Example 109, further comprising storing a first bit indicating that the cache line has been fully written in a byte enable memory of the second sub-cache.</p><p id="p-0231" num="0229">Example 112 includes the method of Example 111, further comprising storing a second bit indicating that the cache line is half written in the byte enable memory of the second sub-cache.</p><p id="p-0232" num="0230">Example 113 includes the method of Example 112, wherein the first and second bits are determined based on the byte enable logic associated with the stored write-miss data.</p><p id="p-0233" num="0231">Example 114 includes the method of Example 113, wherein the first and second bits are determined based on the byte enable logic each time write-miss data is stored in the second sub-cache.</p><p id="p-0234" num="0232">Example 115 includes a device comprising: a processor; a first sub-cache; and a second sub-cache in parallel with the first sub-cache; wherein the second sub-cache includes: a set of cache lines; line type bits configured to store an indication that a corresponding cache line of the set of cache lines is configured to store write-miss data, and an eviction controller configured to evict a cache line of the second sub-cache storing write-miss data based on an indication that the cache line has been fully written.</p><p id="p-0235" num="0233">Example 116 includes the device of Example 115, wherein the eviction controller is further configured to evict a cache line of the second sub-cache storing write-miss data based on an indication that half of the cache line has been written.</p><p id="p-0236" num="0234">Example 117 includes the device of Example 116, wherein the eviction controller is configured to determine that no cache line of the second sub-cache storing write-miss data is fully written before evicting the cache line based on the indication that half of the cache line has been written.</p><p id="p-0237" num="0235">Example 118 includes the device of Example 118, wherein the second sub-cache further comprises a byte enable memory configured to store byte enable logic associated with the stored write-miss data, and wherein the byte enable memory includes a first bit storing the indication that the cache line has been fully written.</p><p id="p-0238" num="0236">Example 119 includes the device of Example 118, wherein the byte enable memory includes a second bit storing the indication that half of the cache line has been written.</p><p id="p-0239" num="0237">Example 120 includes the device of Example 119, wherein the first and second bits are determined based on the byte enable logic associated with the stored write-miss data.</p><p id="p-0240" num="0238">Example 121 includes a caching system comprising: a first sub-cache; a second sub-cache, coupled in parallel with the first sub-cache, for storing cache data evicted from the first sub-cache and write-memory commands that are not cached in the first sub-cache; and a cache controller configured to: receive two or more cache commands; determine a conflict exists between the received two or more cache commands; determine a conflict resolution between the received two or more cache commands; and sending the two or more cache commands to the first sub-cache and the second sub-cache.</p><p id="p-0241" num="0239">Example 122 includes the caching system of Example 121, wherein the cache command is a read command and wherein the cache controller is further configured to: determine, based on a memory address of the read command, that the memory address is not cached in the first sub-cache; determine, based on the memory address, that the memory address is stored as a write-memory command in the second sub-cache; and stall the read command until the write-memory command is drained from the second sub-cache.</p><p id="p-0242" num="0240">Example 123 includes the caching system of Example 121, wherein the cache controller is further configured to receive two or more cache commands in parallel.</p><p id="p-0243" num="0241">Example 124 includes the caching system of Example 123, wherein the two or more cache commands include a read command and a write command, and wherein the cache controller is further configured to: determine, based on a first memory address of the read command, a first cache location in the first sub-cache; determine that the first memory address is not cached in the first sub-cache at the first cache location; receive a second cache location in the second sub-cache associated with the read command; determine, based on a second memory address of the write command, that the second memory address is stored as write-memory command in the second sub-cache at the second cache location; receive a third cache location in the second sub-cache associated with the write command; and evict a cached memory item from the first cache location in the first sub-cache to the third cache location in the second sub-cache.</p><p id="p-0244" num="0242">Example 125 includes the caching system of Example 123, wherein the two or more cache commands include a read command and a write command, and wherein the cache controller is further configured to: determine, based on a first memory address of the read command, a first cache location in the first sub-cache; determine that the first memory address is not cached in the first sub-cache at the first cache location; determine, based on a second memory address of the write command, that the second memory address is stored at the first location in the first sub-cache stall the read command; perform the write command; evict the performed write commend to the second sub-cache; and resume the read command after the eviction.</p><p id="p-0245" num="0243">Example 126 includes the caching system of Example 123, wherein the two or more cache commands include a first write command and a second write command, and wherein the cache controller is further configured to: determine that a first memory address of the first write command is not cached in the first sub-cache; determine that a second memory address of the second write command is not cached in the first sub-cache; determine that the first memory address and the second memory address match; merge the first write command and the second write command; and store the merged commands to the second sub-cache.</p><p id="p-0246" num="0244">Example 127 includes the caching system of Example 123, wherein the two or more cache commands include a read command and a write command, and wherein the cache controller is further configured to: determine that a first memory address of the read command is cached in the first sub-cache; determine that a second memory address of the write command is cached in the first sub-cache; determine that the first memory address and the second memory address match; stall the write command until the read command is completed; and resume the write command.</p><p id="p-0247" num="0245">Example 128 includes a method for caching data, comprising: receiving two or more cache commands; determining a conflict exists between the two or more cache commands; determining a conflict resolution between the received two or more cache commands; and sending the two or more cache commands to a first sub-cache and a second sub-cache, wherein the second sub-cache is configured to store, in parallel with the first sub-cache, cache data evicted from the first sub-cache and write-memory commands that are not cached in the first sub-cache.</p><p id="p-0248" num="0246">Example 129 includes the method of claim <b>8</b>, wherein the cache command is a read command and further comprising: determining, based on a memory address of the read command, that the memory address is not cached in the first sub-cache; determining, based on the memory address, that the memory address is stored as a write-memory command in the second sub-cache; and stalling the read command until the write-memory command is drained from the second sub-cache.</p><p id="p-0249" num="0247">Example 130 includes the method of Example 128, wherein the two or more cache commands are received in parallel.</p><p id="p-0250" num="0248">Example 131 includes the method of Example 130, wherein the two or more cache commands include a read command and a write command, and further comprising: determining, based on a first memory address of the read command, a first cache location in the first sub-cache; determining that the first memory address is not cached in the first sub-cache at the first cache location; receiving a second cache location in the second sub-cache associated with the read command; determining, based on a second memory address of the write command, that the second memory address is stored as write-memory command in the second sub-cache at the second cache location; receiving a third cache location in the second sub-cache associated with the write command; evicting a cached memory item from the first cache location in the first sub-cache to the third cache location in the second sub-cache.</p><p id="p-0251" num="0249">Example 132 includes the method of Example 130, wherein the two or more cache commands include a read command and a write command, and further comprising: determining, based on a first memory address of the read command, a first cache location in the first sub-cache; determining that the first memory address is not cached in the first sub-cache at the first cache location; determining, based on a second memory address of the write command, that the second memory address is stored at the first location in the first sub-cache; stalling the read command; performing the write command; evicting the performed write commend to the second sub-cache; and resuming the read command after the eviction.</p><p id="p-0252" num="0250">Example 133 includes the method of Example 130, wherein the two or more cache commands include a first write command and a second write command, and wherein the cache controller is further configured to: determining that a first memory address of the first write command is not cached in the first sub-cache; determining that a second memory address of the second write command is not cached in the first sub-cache; determining that the first memory address and the second memory address match; merging the first write command and the second write command; and storing the merged commands to the second sub-cache.</p><p id="p-0253" num="0251">Example 134 includes the method of Example 130, wherein the two or more cache commands include a read command and a write command, and further comprising: determining that a first memory address of the read command is cached in the first sub-cache; determining that a second memory address of the write command is cached in the first sub-cache; determining that the first memory address and the second memory address match; stalling the write command until the read command is completed; and resuming the write command.</p><p id="p-0254" num="0252">Example 135 includes a device comprising: a processor; a first sub-cache; and a second sub-cache coupled in parallel with the first sub-cache, for storing cache data evicted from the first sub-cache and write-memory commands that are not cached in the first sub-cache; and a cache controller configured to: receive two or more cache commands; determine a conflict exists between the received two or more cache commands; determine a conflict resolution between the received two or more cache commands; and sending the two or more cache commands to the first sub-cache and the second sub-cache.</p><p id="p-0255" num="0253">Example 136 includes the device of Example 135, wherein the cache command is a read command and wherein the cache controller is further configured to: determine, based on a memory address of the read command, that the memory address is not cached in the first sub-cache; determine, based on the memory address, that the memory address is stored as a write-memory command in the second sub-cache; and stall the read command until the write-memory command is drained from the second sub-cache.</p><p id="p-0256" num="0254">Example 137 includes the device of Example 135, wherein the cache controller is further configured to receive two or more cache commands in parallel.</p><p id="p-0257" num="0255">Example 138 includes the device of Example 137, wherein the two or more cache commands include a read command and a write command, and wherein the cache controller is further configured to: determine, based on a first memory address of the read command, a first cache location in the first sub-cache; determine that the first memory address is not cached in the first sub-cache at the first cache location; receive a second cache location in the second sub-cache associated with the read command; determine, based on a second memory address of the write command, that the second memory address is stored as write-memory command in the second sub-cache at the second cache location; receive a third cache location in the second sub-cache associated with the write command; and evict a cached memory item from the first cache location in the first sub-cache to the third cache location in the second sub-cache.</p><p id="p-0258" num="0256">Example 139 includes the device of Example 137, wherein the two or more cache commands include a read command and a write command, and wherein the cache controller is further configured to: determine, based on a first memory address of the read command, a first cache location in the first sub-cache; determine that the first memory address is not cached in the first sub-cache at the first cache location; determine, based on a second memory address of the write command, that the second memory address is stored at the first location in the first sub-cache; stall the read command; perform the write command; evict the performed write commend to the second sub-cache; and resume the read command after the eviction.</p><p id="p-0259" num="0257">Example 140 includes the device of Example 137, wherein the two or more cache commands include a first write command and a second write command, and wherein the cache controller is further configured to: determine that a first memory address of the first write command is not cached in the first sub-cache; determine that a second memory address of the second write command is not cached in the first sub-cache; determine that the first memory address and the second memory address match; merge the first write command and the second write command; and store the merged commands to the second sub-cache.</p><p id="p-0260" num="0258">The term &#x201c;couple&#x201d; is used throughout the specification. The term may cover connections, communications, or signal paths that enable a functional relationship consistent with the description of the present disclosure. For example, if device A generates a signal to control device B to perform an action, in a first example device A is coupled to device B, or in a second example device A is coupled to device B through intervening component C if intervening component C does not substantially alter the functional relationship between device A and device B such that device B is controlled by device A via the control signal generated by device A.</p><p id="p-0261" num="0259">Modifications are possible in the described embodiments, and other embodiments are possible, within the scope of the claims.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A caching system comprising:<claim-text>a set of cache lines; and</claim-text><claim-text>an eviction controller configured to:<claim-text>determine that a first cache line of the set of cache lines storing write-miss data is full; and</claim-text><claim-text>evict the write-miss data stored in the first cache line in response to determining that the first cache line is full.</claim-text></claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The caching system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the eviction controller is further configured to:<claim-text>determine that a second cache line of the set of cache lines storing write-miss data is half full; and</claim-text><claim-text>evict the write-miss data stored in the second cache line in response to determining that the second cache line is half full.</claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The caching system of <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein the eviction controller is configured to determine that no cache line of the set of cache lines storing write-miss data is fully written before evicting the write-miss data stored in the second cache line in response to determining that the second cache line is half full.</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The caching system of <claim-ref idref="CLM-00002">claim 2</claim-ref>, further comprising a byte enable memory configured to store byte enable logic associated with the stored write-miss data,<claim-text>wherein the byte enable memory includes a first bit,</claim-text><claim-text>wherein a value of the first bit indicates whether the first cache line is full, and</claim-text><claim-text>wherein the eviction controller is configured to determine that the first cache line is full by at least reading the value of the first bit.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The caching system of <claim-ref idref="CLM-00004">claim 4</claim-ref>,<claim-text>wherein the byte enable memory includes a second bit, and</claim-text><claim-text>wherein a value of the second bit indicates whether the second cache line is half full, and</claim-text><claim-text>wherein the eviction controller is configured to determine that the second cache line is half full by at least reading the value of the second bit.</claim-text></claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The caching system of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the first and second bits are determined based on the byte enable logic associated with the stored write-miss data.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The caching system of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the first and second bits are determined based on the byte enable logic each time write-miss data is stored in the set of cache lines.</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. A method for caching data, comprising:<claim-text>receiving, by a caching system, a write memory request for a memory address;</claim-text><claim-text>determining, by the caching system, that the memory address is not cached in the caching system;</claim-text><claim-text>responsive to determining that the memory address is not cached in the caching system, storing data associated with the write memory request in a first cache line of the caching system;</claim-text><claim-text>responsive to determining that the memory address is not cached in the caching system, storing an indication that the stored data corresponds to a write-miss;</claim-text><claim-text>determining that the first cache line is full; and</claim-text><claim-text>evicting write-miss data stored in the first cache line in response to determining that the first cache line is full.</claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The method of <claim-ref idref="CLM-00008">claim 8</claim-ref>, further comprising:<claim-text>determining that a second cache line of the caching system storing write-miss data is half full; and</claim-text><claim-text>evicting the write-miss data stored in the second cache line in response to determining that the second cache line is half full.</claim-text></claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, further comprising determining that no cache line of the caching system storing write-miss data is fully written before evicting the write-miss data stored in the second cache line in response to determining that the second cache line is half full.</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The method of <claim-ref idref="CLM-00009">claim 9</claim-ref>, further comprising storing a first bit in a byte enable memory of the caching system,<claim-text>wherein a value of the first bit indicates whether the first cache line is full, and</claim-text><claim-text>wherein determining that the first cache line is full by at least reading the value of the first bit.</claim-text></claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The method of <claim-ref idref="CLM-00011">claim 11</claim-ref>, further comprising storing a second bit in the byte enable memory of the caching system,<claim-text>wherein a value of the second bit indicates whether the second cache line is half full, and</claim-text><claim-text>wherein determining that the second cache line is half full by at least reading the value of the second bit.</claim-text></claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The method of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein the first and second bits are determined based on the byte enable logic associated with the stored write-miss data.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The method of <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein the first and second bits are determined based on the byte enable logic each time write-miss data is stored in the caching system.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. A device comprising:<claim-text>a processor;<claim-text>a set of cache lines; and</claim-text><claim-text>an eviction controller configured to:<claim-text>determine that a first cache line of the set of cache lines storing write-miss data is full; and</claim-text><claim-text>evict the write-miss data stored in the first cache line in response to determining that the first cache line is full.</claim-text></claim-text></claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The device of <claim-ref idref="CLM-00015">claim 15</claim-ref>, wherein the eviction controller is further configured to:<claim-text>determine that a second cache line of the set of cache lines storing write-miss data is half full; and</claim-text><claim-text>evict the write-miss data stored in the second cache line in response to determining that the second cache line is half full.</claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. The device of <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the eviction controller is configured to determine that no cache line of the set of cache lines storing write-miss data is fully written before evicting the write-miss data stored in the second cache line in response to determining that the second cache line is half full.</claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The device of <claim-ref idref="CLM-00016">claim 16</claim-ref>, further comprising a byte enable memory configured to store byte enable logic associated with the stored write-miss data,<claim-text>wherein the byte enable memory includes a first bit,</claim-text><claim-text>wherein a value of the first bit indicates whether the first cache line is full, and</claim-text><claim-text>wherein the eviction controller is configured to determine that the first cache line is full by at least reading the value of the first bit.</claim-text></claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The device of <claim-ref idref="CLM-00018">claim 18</claim-ref>,<claim-text>wherein the byte enable memory includes a second bit,</claim-text><claim-text>wherein a value of the second bit indicates whether the second cache line is half full, and</claim-text><claim-text>wherein the eviction controller is configured to determine that the second cache line is half full by at least reading the value of the second bit.</claim-text></claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The device of <claim-ref idref="CLM-00019">claim 19</claim-ref>, wherein the first and second bits are determined based on the byte enable logic associated with the stored write-miss data.</claim-text></claim></claims></us-patent-application>