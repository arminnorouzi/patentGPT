<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230004523A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230004523</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17363900</doc-number><date>20210630</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>15</main-group><subgroup>80</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>7</main-group><subgroup>487</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>7</main-group><subgroup>499</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>06</class><subclass>F</subclass><main-group>7</main-group><subgroup>501</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>15</main-group><subgroup>8046</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc><further-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>7</main-group><subgroup>4876</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>7</main-group><subgroup>49942</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>06</class><subclass>F</subclass><main-group>7</main-group><subgroup>501</subgroup><symbol-position>L</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></further-cpc></classifications-cpc><invention-title id="d2e43">SYSTOLIC ARRAY WITH INPUT REDUCTION TO MULTIPLE REDUCED INPUTS</invention-title><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Amazon Technologies, Inc.</orgname><address><city>Seattle</city><state>WA</state><country>US</country></address></addressbook><residence><country>US</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Meyer</last-name><first-name>Paul Gilbert</first-name><address><city>Rollingwood</city><state>TX</state><country>US</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Volpe</last-name><first-name>Thomas A.</first-name><address><city>Austin</city><state>TX</state><country>US</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>Diamant</last-name><first-name>Ron</first-name><address><city>Santa Clara</city><state>CA</state><country>US</country></address></addressbook></inventor><inventor sequence="03" designation="us-only"><addressbook><last-name>Bowman</last-name><first-name>Joshua Wayne</first-name><address><city>Austin</city><state>TX</state><country>US</country></address></addressbook></inventor><inventor sequence="04" designation="us-only"><addressbook><last-name>Desai</last-name><first-name>Nishith</first-name><address><city>Austin</city><state>TX</state><country>US</country></address></addressbook></inventor><inventor sequence="05" designation="us-only"><addressbook><last-name>Elmer</last-name><first-name>Thomas</first-name><address><city>Austin</city><state>TX</state><country>US</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">Systems and methods are provided to perform multiply-accumulate operations of reduced precision numbers in a systolic array. Each row of the systolic array can receive reduced inputs from a respective reducer. The reducer can receive a particular input and generate multiple reduced inputs from the input. The reduced inputs can include reduced input data elements and/or a reduced weights. The systolic array may lack support for inputs with a first bit-length and the reducers may reduce the bit-length of a given input from the first bit-length to a second shorter bit-length and provide multiple reduced inputs with second shorter bit-length to the array. The systolic array may perform multiply-accumulate operations on each unique combination of the multiple reduced input data elements and the reduced weights to generate multiple partial outputs. The systolic array may sum the partial outputs to generate the output.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="109.73mm" wi="147.66mm" file="US20230004523A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="126.75mm" wi="149.69mm" file="US20230004523A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="208.53mm" wi="94.83mm" file="US20230004523A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="128.86mm" wi="171.20mm" file="US20230004523A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="129.54mm" wi="171.20mm" file="US20230004523A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="126.58mm" wi="178.31mm" file="US20230004523A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="128.10mm" wi="161.88mm" file="US20230004523A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="125.65mm" wi="153.08mm" file="US20230004523A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="125.65mm" wi="174.41mm" file="US20230004523A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="124.80mm" wi="164.93mm" file="US20230004523A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="118.36mm" wi="142.58mm" file="US20230004523A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="117.52mm" wi="119.63mm" file="US20230004523A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00012" num="00012"><img id="EMI-D00012" he="117.52mm" wi="119.63mm" file="US20230004523A1-20230105-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00013" num="00013"><img id="EMI-D00013" he="204.64mm" wi="125.56mm" file="US20230004523A1-20230105-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00014" num="00014"><img id="EMI-D00014" he="205.66mm" wi="125.73mm" file="US20230004523A1-20230105-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00015" num="00015"><img id="EMI-D00015" he="201.34mm" wi="125.81mm" file="US20230004523A1-20230105-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00016" num="00016"><img id="EMI-D00016" he="201.34mm" wi="125.65mm" file="US20230004523A1-20230105-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00017" num="00017"><img id="EMI-D00017" he="204.05mm" wi="125.56mm" file="US20230004523A1-20230105-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00018" num="00018"><img id="EMI-D00018" he="202.78mm" wi="125.65mm" file="US20230004523A1-20230105-D00018.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00019" num="00019"><img id="EMI-D00019" he="203.88mm" wi="125.65mm" file="US20230004523A1-20230105-D00019.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00020" num="00020"><img id="EMI-D00020" he="203.03mm" wi="125.65mm" file="US20230004523A1-20230105-D00020.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00021" num="00021"><img id="EMI-D00021" he="110.41mm" wi="124.80mm" file="US20230004523A1-20230105-D00021.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0001" level="1">BACKGROUND</heading><p id="p-0002" num="0001">Artificial neural networks are computing systems with an architecture based on biological neural networks. A neural network may be implemented by circuitries and data paths, such as a systolic array. Systolic arrays can accelerate the performance of the training and inference phases of artificial neural networks. During the training phase, input data can be provided to train a model. During the inference phase, new inputs can be processed according to the model to obtain a predicted result. User applications often use the model in the inference phase, so the inference phase can often have time sensitivities, and latency during the inference phase can negatively impact the user experience.</p><p id="p-0003" num="0002">As more applications use artificial neural networks, the applications also use a wide range of numbers that may include numbers with increased bit-lengths (e.g., 32-bit floating-point numbers) that may require greater computational power or modifications to the neural networks. While computational support for numbers with the increased bit-lengths can provide increased accuracy for mathematical operations, providing support for the increased bit-lengths of these numbers can increase the complexity, size and cost of the processing elements in the systolic array. These increases can also affect the system processing speed and the system power consumption. Power consumption and the size of the systolic array can become highly important when a systolic array is required to support a wide range of numbers.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0002" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0004" num="0003">Various features will now be described with reference to the following drawings. Throughout the drawings, reference numbers may be re-used to indicate correspondence between referenced elements. The drawings are provided to illustrate examples described herein and are not intended to limit the scope of the disclosure.</p><p id="p-0005" num="0004"><figref idref="DRAWINGS">FIG. <b>1</b>A</figref> illustrates an example 4&#xd7;4 systolic array and an example column of reducers.</p><p id="p-0006" num="0005"><figref idref="DRAWINGS">FIG. <b>1</b>B</figref> illustrates an example 1&#xd7;8 column of a systolic array.</p><p id="p-0007" num="0006"><figref idref="DRAWINGS">FIG. <b>2</b>A</figref> illustrates a processing element for neural network computations with the inputs entering through separate reducers, according to certain examples of the disclosed technologies.</p><p id="p-0008" num="0007"><figref idref="DRAWINGS">FIG. <b>2</b>B</figref> illustrates a processing element for neural network computations with the inputs entering through the same reducer, according to certain examples of the disclosed technologies.</p><p id="p-0009" num="0008"><figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates an apparatus including zero detector circuits for reduced input data elements and reduced weights entering a systolic array for neural network computations, according to certain examples of the disclosed technologies.</p><p id="p-0010" num="0009"><figref idref="DRAWINGS">FIG. <b>4</b>A</figref> illustrates a reducer showing the selection of an input to be reduced and rounded, according to some examples of the disclosed technologies.</p><p id="p-0011" num="0010"><figref idref="DRAWINGS">FIG. <b>4</b>B</figref> illustrates a reducer showing the selection of a rounded input to be reduced, according to some examples of the disclosed technologies.</p><p id="p-0012" num="0011"><figref idref="DRAWINGS">FIG. <b>4</b>C</figref> illustrates a reducer showing the generation of multiple reduced inputs from a selected input, according to some examples of the disclosed technologies.</p><p id="p-0013" num="0012"><figref idref="DRAWINGS">FIG. <b>5</b></figref> illustrates a multiply accumulate datapath for neural network computations, according to certain examples of the disclosed technologies.</p><p id="p-0014" num="0013"><figref idref="DRAWINGS">FIG. <b>6</b></figref> shows an apparatus for neural network computations according to some examples of the disclosed technologies.</p><p id="p-0015" num="0014"><figref idref="DRAWINGS">FIG. <b>7</b></figref> shows a method executed by a reducer and a processing element for neural network computations, according to some examples of the disclosed technologies.</p><p id="p-0016" num="0015"><figref idref="DRAWINGS">FIG. <b>8</b></figref> shows a method executed by a reducer and a processing element for neural network computations, according to some examples of the disclosed technologies.</p><p id="p-0017" num="0016"><figref idref="DRAWINGS">FIGS. <b>9</b>A-<b>9</b>H</figref> show an example systolic array processing data over a sequence of systolic intervals.</p><p id="p-0018" num="0017"><figref idref="DRAWINGS">FIG. <b>10</b></figref> illustrates an example of a computing device, according to certain aspects of the disclosure.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0003" level="1">DETAILED DESCRIPTION</heading><p id="p-0019" num="0018">Generally described, the present disclosure relates to a systolic array that supports converting inputs of a higher bit-length than elements of the array natively support into one or more reduced inputs. Further, the input can be converted into a reduced input for single-pass reduced precision computations on inputs of a higher bit-length than elements of the array natively support. For example, the elements of the array may natively support single-pass computations on inputs of a particular bit-length of the systolic array and the systolic array may receive input from a reducer that reduces a bit-length of the input to match the bit-length natively supported by the elements during single-pass computations. The input may also be converted into multiple reduced inputs for multiple-pass full precision computations on inputs of a higher-bit length than elements of the array natively support. As described herein, the use of such a reducer to provide the reduced input to the systolic array can enable inputs to be given to a systolic array in an arbitrary bit-length, and the inputs may be programmatically adjusted to a particular bit-length (e.g., a highest bit-length supported during single-pass computations) such that a user need not be aware of the particular bit-length of the inputs to the processing elements of the systolic array. While a traditional systolic array may support different bit-lengths, the native support of single-pass computations for a higher bit-length can increase the size and power consumption of a systolic array. Further, this may affect processing of shorter bit-lengths. Therefore, traditional systolic arrays must balance the ability to do single pass computations for longer bit-lengths and the efficiency in processing shorter bit-lengths. This may result in systolic arrays that do not support longer bit-lengths due to a loss in efficiency in processing the shorter bit-lengths. Disclosed herein is a systolic array to support arbitrarily long bit-lengths at a reduced precision with a minimal loss in efficiency in comparison to processing the shorter bit-lengths. The systolic array may support inputs of arbitrary bit-lengths through a reducer that can drop excess bits from the significand of the input with an arbitrary bit-length and round the remaining bits. The dropping of the excess bits can enable the reducer to reduce the bit-length of the input to the maximum bit-length supported for single-pass computations by the systolic array, at the cost of reduced precision from the arbitrary bit-length. Further, the use of such a reducer can enable the systolic array that receives inputs of arbitrary bit-lengths to provide the same performance as achieved by a systolic array that receives inputs of fixed bit-lengths. Allowing a user to provide inputs with arbitrary (or non-fixed) bit-lengths may allow for lower-cost or lower-power elements to be used in a systolic array receiving inputs with a greater bit-length, while maintaining the overall performance of the systolic array due to the reduction in the bit-length of the input by the reducer. Further, by reducing the bit-length of the input (e.g., a 32-bit floating-point number), the reducer can provide a reduced precision version (e.g., a 22-bit floating-point reduced precision number) of the input. Therefore, the reducer can generate a reduced input from an input by reducing the bit-length of the input.</p><p id="p-0020" num="0019">The reducer can generate multiple reduced inputs from the input. The systolic array may utilize the multiple reduced inputs in a multiple-pass multiply-accumulate operation in order to retain the accuracy of the input. For example, each combination of reduced inputs (e.g., where the reducer generates two reduced inputs for the input data element and the weight, input data element <b>1</b> and weight <b>1</b>, input data element <b>2</b> and weight <b>1</b>, input data element <b>1</b> and weight <b>2</b>, and input data element <b>2</b> and weight <b>2</b>) may be passed through the multiple-pass multiply-accumulate operation. By generating multiple reducing inputs with reduced bit-lengths from the input, the reducer can reduce the bit-length of the input to the maximum bit-length supported for single-pass computations by the systolic array, at the cost of reduced performance from the arbitrary bit-length. Further, the use of such a reducer can enable the systolic array that receives multiple reduced inputs (with the bit-length reduced from an original bit-length) to provide the same frequency, power advantage, and/or size advantage as achieved by a systolic array that receives inputs of fixed (e.g., standard) bit-lengths at a cost of lower performance as compared to a systolic array that operates on inputs of the original bit-length. Allowing a user to provide inputs with arbitrary bit-lengths may allow for lower-cost or lower-power elements (e.g., power elements that are configured to operate on standard bit-lengths) to be used in a systolic array receiving inputs with an arbitrary bit-length, while offering an increased precision as compared to systolic arrays receiving inputs with standard bit-lengths.</p><p id="p-0021" num="0020">As described herein, a systolic array includes an array of processing elements (PEs), often arranged into two dimensions (e.g., columns and rows). The PEs of the array can be interconnected to enable data to pass through the PEs, which may conduct one or more mathematical operations on the data. For example, each PE may conduct a &#x201c;multiply accumulate&#x201d; operation, whereby inputs are fed horizontally into PEs of each row of the array, with each PE multiplying its respective input by a stored weight value and passing the product result to a PE in a subsequent row.</p><p id="p-0022" num="0021">One illustrative use of a systolic array is in conducting an inference phase of a machine learning application. Machine learning generally requires at least two phases: a &#x201c;learning phase,&#x201d; where a model is trained against training data, and an &#x201c;inference phase,&#x201d; in which the trained model is applied to production data to predict a result. Inference phase applications are often latency sensitive, in that they operate in production environments. Moreover, inference phase applications&#x2014;and particularly neural network applications&#x2014;often require dense algebraic calculations, such as matrix multiplications. Systolic arrays may be used to accelerate inference-phase workloads in machine learning applications.</p><p id="p-0023" num="0022">As noted above, the PEs of a systolic array may be divided into rows and columns. Each PE in the input layer may receive an element of an input data set, and scale the element with a weight (e.g., a filter) to indicate the element's degree of influence on the output. Each PE in the intermediate layers may receive at least one of the element and the weight (or filter) from another PE in the systolic array. Each PE in the intermediate layers may combine the elements received from a corresponding PE of the systolic array to compute a set of intermediate outputs. For example, each PE in the intermediate layers may compute a sum of element-weight products, and then produce the sum for application of an activation function to the sum (e.g., by a system separate from the PEs of the systolic array).</p><p id="p-0024" num="0023">Generally, an input data set (e.g., an input feature map) may be fed, one input data element at a time, into its respective row of the systolic array, and passed from one PE to another PE in a given row starting, for example, from a leftmost PE. Each row receives a specific input data element and weight which are fed into a first PE, in a row, and subsequently passed to an adjacent PE located to the right of the first PE in the same row. Further, an input partial sum may be fed, one input partial sum at a time, into its respective column of the systolic array, and passed from one PE to another PE in a given column starting from a topmost PE. Generally, an input partial sum may be fed from a first PE, in one column, to an adjacent PE located directly beneath the first PE in the same column. Further, each column corresponds to a specific input partial sum which is passed through each PE of a given column. This can be done to allow each PE of a given column to perform a mathematical operation on the input partial sum to produce an output partial sum. As the input data element passes through a PE, the input data element can be multiplied with the weight value, and accumulated with the input partial sum. The first PE, in one column, is provided an input partial sum and generates an output partial sum based on the mathematical operations performed by that PE. The output partial sum is then provided to an adjacent PE in the same column as an input partial sum. The adjacent PE may then perform further mathematical operations before generating an output partial sum and passing the output partial sum to a further adjacent PE. In some embodiments, input data may be fed into a systolic array in a cascading fashion, with a PE in a first column and row (a position that may be designated as [0, 0], indicating row and column 0) receiving an input data element and an input partial sum in a first clock cycle. Thereafter, data can generally flow to subsequent rows and columns at a given rate (e.g., advancing one PE per cycle). For example, the output partial sum of the PE at [0, 0] can be fed to the PE at [1, 0], along with an input data element for row 1, such that the PE at [1, 0] performs a mathematical operations on that input data element and partial sum during a second clock cycle. Similarly, the input data element of PE [0, 0] can be passed to a PE of a subsequent column (e.g., at position [0, 1]), which can also be fed an input partial sum, such that the PE at [0, 1] conducts a mathematical operation on that input partial sum and input data element during the second clock cycle. Assuming a convention in which rows advance downward and columns advance to the right, data therefore can generally flow down and to the right during operation of the array. To assist in these calculations, PEs within the array may be provided with weights prior to the first clock cycle, or may receive weights in the first clock cycle or during calculations.</p><p id="p-0025" num="0024">As machine learning applications and neural network applications proliferate, the demand for increased processing capabilities (e.g., the capability to handle larger numbers and/or more precise numbers) while achieving higher precision and maintaining performance has also increased. For example, the demand to support numbers with increased precision (e.g., the decimal places for a number and/or the significand for a number) has increased. Providing support for numbers with greater bit-lengths (e.g., 32-bit floating-point numbers) results in significant increases in integrated circuit die cost, power consumption, and circuit complexity in comparison to supporting only numbers with fixed (e.g., particular) bit-lengths (e.g., 16-bit floating-point numbers) as the traditional PE may not be capable of receiving numbers with bit-lengths exceeding a particular length. In a systolic array of hundreds or thousands of PEs, the added support for numbers with greater bit-lengths can cause an exponential increase in the integrated circuit die cost, power consumption, and circuit complexity. In some configurations, a PE supports performing mathematical operations on numbers with increased bit-lengths (e.g., 32-bits) with specialized circuitry configured for the larger bit-lengths. For example, a 32-bit floating-point systolic array may be specialized to perform mathematical operations on 32-bit floating-point (FP32) numbers. Such modifications may be particularly undesirable, may offer reduced performance, and may be costly and/or time consuming to implement. In other configurations, a PE does not support mathematical operations on numbers with bit-lengths exceeding a given size. For example, a 16-bit floating-point systolic array may not be capable of performing mathematical operations on numbers other than 16-bit floating-point (FP16) numbers. Such a lack of capabilities may be particularly undesirable and may offer reduced precision and/or reduced processing capabilities.</p><p id="p-0026" num="0025">The present disclosure provides a systolic array with significant advantages over prior implementations. The present disclosure enables a systolic array to support arbitrary bit-lengths and maintain performance for shorter bit-lengths relative to an array that natively supports single-pass computations on longer-bit lengths, without significantly increasing power consumption of the array. Moreover, the present disclosure can enable the use of numbers with arbitrary bit-lengths (e.g., 32-bit floating-point numbers) as input to the systolic array (e.g., as input to a reducer of the array). Further, the reducer of the systolic array can programmatically adjust the inputs to a particular bit-length (e.g., a highest bit-length supported during single-pass computations) such that a user need not be aware of the particular bit-length of the inputs that the processing elements of the systolic array receive. These advantages are provided by the embodiments discussed herein, and specifically by creation of a systolic array utilizing one or more reducers that reduce one or more inputs to be provided to the systolic array. Further, the one or more reducers can generate multiple reduced inputs for a particular input in order to retain the accuracy of the original input.</p><p id="p-0027" num="0026">The systolic array may support particular bit-lengths or data types. For example, the systolic array may support standard bit-lengths and/or data types (e.g., FP16 numbers). A consumer or user may be notified that the systolic array supports the particular bit-lengths or data types. Further, the reducer may receive inputs with arbitrary bit-lengths that do not correspond to the supported bit-lengths and/or data types (e.g., FP32 numbers). The reducer may convert the input with a non-supported bit-length into a reduced format (e.g., a reduced bit-length) and provide the input with the reduced format (e.g., 22-bit floating-point numbers) to the systolic array. The reduced format may be a non-standard format, a non-standard bit-length, and/or a non-standard data type. The consumer may not be notified that the systolic array supports inputs with the reduced format. Further, the input with the reduced format may have a higher accuracy or precision than inputs with the standard bit-lengths and/or data types and a higher performance than inputs with the arbitrary bit-lengths and/or data types as the arbitrary bit-lengths and/or data types may require specialized software and/or hardware to use these numbers. Further, the internal structure of the systolic array may be a superset of the components of each supported data type. For example, the internal structure of the systolic array may support a standard significand bit-length from A to B and a standard exponent bit-length from X to Y. Therefore, the maximum internally supported bit-length of the array may be 1+B+Y, where B and Y may be any number. Further, 1+B+Y may not correspond to a standard format (e.g., 1+B+Y may correspond to a 22-bit format) but the reducer may be able to downsize to this format for input to the array. Therefore, while a set of data types and/or bit-lengths may be exposed to the customer as supported by the systolic array, the reduced format (e.g., an intermediate bit-length between the arbitrary bit-lengths and the standard bit-lengths) may not be exposed to the customer and may correspond to a maximum format (e.g., bit-length) supported by the systolic array. This can enable an increased accuracy relative to inputs with standard bit-lengths and an increased performance relative to inputs with arbitrary bit-lengths.</p><p id="p-0028" num="0027">As disclosed herein, each reducer (e.g., bit reducer, zeroer, etc.) assigned to a particular row of the systolic array may reduce one or more inputs (e.g., change one or more bits to zero) provided to the reducer and output one or more reduced inputs based at least in part on the one or more inputs. The provided inputs to the reducer may be numbers represented by a significand and an exponent. For example, the provided inputs may be in floating-point format. The one or more reduced inputs may be represented in a modified format with a reduced significand and an expanded exponent. The reduced input may have a sign bit, exponent bits, and significand bits. The most significant bit of the significand bits may be implied or hidden. Each reducer may include one or more of the following: a rounder, an exponent expander, a trailing bit reducer, and a multiplexer. The reducer can adjust the inputs provided to the reducer by maintaining the exponent of the original input and reducing the significand of the original input. The reducer may utilize the rounder to round the reduced input generated by the reducer based on the unreduced number. In some embodiments, the input may be pre-rounded to a given precision (e.g., the number of bits supported for single-pass computations) and the reducer can drop the resulting, trailing zeros to generate the reduced input. The rounder may use various rounding techniques to round the input (e.g., any standard rounding technique). Further, the reducer may utilize the exponent expander to expand a quantity of bits of an exponent portion of the number and the trailing bit reducer to reduce the quantity of bits of a significand portion of the number. Each reducer may contain any combination of these components. Each reducer may utilize the components contained in the reducer to produce a reduced input and provide the reduced input to the systolic array or the processing elements of the systolic array. By producing the reduced input, the reducer is enabled to reduce or adjust arbitrary bit-lengths (e.g., arbitrarily long bit-lengths) to bit-lengths supported during single-pass computations by the processing elements of the array, with a loss of precision from the original input of the arbitrary bit-length.</p><p id="p-0029" num="0028">The reducer, by dropping bits and providing a single-pass computation through the systolic array, may lead to reduced precision (e.g., corresponding to the data of the dropped bits). For example, the final output may be a reduced output equal to the reduced weight times the reduced input data element. This precision may be recaptured by implementing additional passes through the array. For example, the reducer may convert a weight into a high reduced weight and a low reduced weight and an input data element into a high reduced input data element and a low reduced input data element. Further, the final output may include greater precision and may equal the low reduced weight multiplied by the low reduced input data element plus the low reduced weight multiplied by the high reduced input data element plus the high reduced weight multiplied by the low reduced input data element plus the high reduced weight multiplied by the high reduced input data element. While the multiple-pass computations may require a reduction in speed (e.g., based on the multiple passes through the array for a single total output), the multiple-pass computations may offer significant increases in precision over the single-pass computation for reduced precision. Therefore, the systolic array may be able support higher bit-lengths with hardware that natively supports a maximum bit-length that is lower than the higher bit-lengths by receiving inputs from reducers. Each reducer assigned to a particular row of the systolic array can receive a particular input data element and/or weight and generate multiple reduced inputs from the received input for multiple passes through (e.g., in) the systolic array for the original input. For example, the reducer can receive an input data element and generate multiple reduced input data elements based on the input data element in order to retain more precision of the original input data element as compared to reducing the input to a standard bit-length. The multiple reduced inputs may sum to generate the input. It will be understood that each input may be converted into any number of reduced inputs. The reducer may generate the reduced inputs as a first reduced input (e.g., a high reduced input) and a second reduced input (e.g., a low reduced input). The first reduced input may be based on the higher magnitude significand bits of the input and the second reduced input may be based on the lower magnitude significand bits. For example, the first reduced input may be based on the leftmost bits of the significand (e.g., the bits with the highest magnitude) and the second reduced input may be based on the rightmost bits of the significand (e.g., the bits with the lowest magnitude). Further, the significand of the input may be divided between the first reduced input and the second reduced input. For example, for a 23-bit significand, the first reduced input may be based on the first 11-bits of the significand as read from left to right (e.g., bits 22 to 12) and the second reduced input may be based on the next 12-bits of the significand as read from left to right (e.g., bits 11 to 0).</p><p id="p-0030" num="0029">The reducer may generate the first reduced input by zeroing a number of low bits of the original input. Further, the reducer may generate the second reduced input by zeroing a number of high bits of the original input. In some embodiments, the reducer may determine that the input is a normal (e.g., not a denormal or subnormal) number by removing an implicit leading bit and renormalizing the reduced significand (e.g., the significand after zeroing the number of leading bits). The reducer may renormalize the input by shifting the significand a number of bits based on a number of leading zeroes. For example, a leading one of the reduced significand may be shifted into the implied bit position. The reducer may further adjust the exponent based on the number of bits shifted by the reducer. As adjusting the exponent may cause the exponent to be outside of the range of the current exponent, the reducer may expand the exponent (e.g., from 8-bits to 9-bits) such that the adjusted exponent can be represented in the expanded exponent. For example, the range of an 8-bit exponent may enable an exponent value between &#x2212;126 and +127 and by expanding the exponent to a 9-bit exponent the reducer may enable an exponent value between &#x2212;254 to +255. As renormalizing a 32-bit input may require an exponent as low as &#x2212;149 (&#x2212;126&#x2212;23) to allow shifting across the full 23 bits of significand (e.g., where the exponent is &#x201c;00000000&#x201d; and the significand is &#x201c;00000000000000000000001&#x201d;), the reducer may therefore expand the 8-bit exponent of the input to generate the second reduced input. The reducer may expand the exponent of the first reduced input and the second reduced input. In some embodiments, the reducer may only expand the exponent of the second reduced input.</p><p id="p-0031" num="0030">Each of the first reduced input and the second reduced input may be represented with a reduced (e.g., compressed) format (e.g., a 21-bit length). One or more reducers may produce reduced inputs for the input data element and the weight. The one or more reducers may further provide each combination of the reduced inputs to the systolic array for the multiply-accumulate operations. The systolic array may implement multiple-pass multiply-accumulate operations for the combinations of the reduced inputs to generate a total output. For example, the multiply-accumulate operations may be performed on a first reduced weight and a first reduced input data element, a first reduced weight and a second reduced input data element, a second reduced weight and a first reduced input element, and a second reduced weight and a second reduced input data element. For example, the final output may be equal to the first reduced weight multiplied by the first reduced input data element plus the first reduced weight multiplied by the second reduced input data element plus the second reduced weight multiplied by the first reduced input data element plus the second reduced weight multiplied by the first reduced input data element. An adder can sum the output of each multiply-accumulate operation (e.g., each partial multiply-accumulate operation) to generate the total output. By generating the multiple reduced inputs (e.g., inputs with reduced bit-lengths) from an input (e.g., an input with an arbitrary bit-length), the systolic array may be able to perform multiply-accumulate operations on the input (multiple reduced input versions of the input) without being required to support the arbitrary bit-length of the input. The systolic array may have certain frequency constraints, size constraints, etc. in order to maintain performance goals. In light of these constraints, traditional systolic arrays may be unable to support arbitrary bit-lengths. By generating multiple reduced inputs for a particular input, the systolic array may satisfy these constraints while generating outputs based on inputs with arbitrary bit-lengths. It will be understood that any number of reduced inputs may be generated from an original input. For example, a 64-bit floating-point number may be converted into 5 21-bit reduced floating-point numbers. Each of the reduced inputs may correspond to a portion of a significand portion of the original input. For example, a first reduced input may correspond to a first portion of the significand portion of the original input, a second reduced input may correspond to a second portion of the significand portion, a third reduced input may correspond to a third portion of the significand portion, etc. The particular portion of the significand portion of the original input for a particular reduced input may be identified by zeroing other portions of the significand portion.</p><p id="p-0032" num="0031">In some embodiments, the reducer may contain or receive a signal from a multiplexer that selects among two or more inputs based on a control signal, such as an opcode or a data type indicator. For example, the multiplexer may identify a particular input for reduction (e.g., a weight or an input data element).</p><p id="p-0033" num="0032">In some embodiments, a systolic array can have separate reducers that receive one of either the input data element or the weight and provide the corresponding reduced version of that input to the systolic array. Each processing element in the initial column of processing elements of the systolic array may receive multiple reduced inputs from one or more reducers. For example, a first processing element of the initial column may receive a reduced input data element from a first reducer and a reduced weight from a second reducer and a second processing element of the initial column may receive a reduced input data element from a third reducer and a reduced weight from a fourth reducer.</p><p id="p-0034" num="0033">Each reducer may reduce the bit-length of numbers of 16-bits, 32-bits, or any number of bits. For example, a reducer may reduce the bit-length of a 32-bit floating-point number to a 22-bit floating-point number. In one embodiment, the 32-bit floating-point number has a 1-bit sign, an 8-bit exponent, and a 23-bit significand. From such a 32-bit floating-point number, the reducer may generate a reduced 20-bit floating-point number with a 1-bit sign, an 8-bit exponent, and an 11-bit significand. In some embodiments, the reducer may increase the bit-length of the exponent of the input in order to adjust the format of the reduced input to a format supported by the processing element. For example, the reducer can increase the exponent from 8 bits to 10 bits. In some embodiments, in order to reduce the bit-length of a particular number, the reducer can reduce a quantity of trailing bits of the significand of the number (e.g., the reducer can zero the low bits of the significand of the number). For example, the number may be a binary string &#x201c;10101010101111111111111&#x201d; and the reducer may zero the twelve trailing bits of the number to generate a reduced binary string &#x201c;10101010101000000000000&#x201d; and/or &#x201c;10101010101.&#x201d;</p><p id="p-0035" num="0034">Each reducer may further round the resulting reduced input to the systolic array. The reducer can round the reduced input to a particular precision or number of bits supported by the processing elements of a systolic array. For example, a reducer can round a number to generate a rounded number. By rounding the input to the systolic array, the systolic array can obtain a higher accuracy result for the calculations of the systolic array. In some embodiments, the reducer can round the reduced input. In other embodiments, the reducer can receive a rounded input (e.g., an input rounded by a separate system) and reduce the rounded input. The rounding may include one or more of stochastic rounding, rounding to nearest even, rounding to zero, rounding down, or rounding up. Further, a user, system, etc. may specify the rounding method for rounding the input (e.g., via a selection from a user interface).</p><p id="p-0036" num="0035">The systolic array may have PEs that each include a 22-bit multiplier and a 34-bit adder. The 22-bit multiplier may operate on 22-bit reduced, floating-point numbers reduced by the reducer from 32-bit floating-point numbers to generate a multiplier product with a sign bit, ten exponent bits, and 23 significand bits. The multiplier product may include 24 significand bits where the most significant bit is implied or hidden. The 34-bit adder may operate on 34-bit numbers (e.g., the 34-bit multiplier product). Further, the adder may operate on 35-bit numbers where one bit is implied or hidden. In some embodiments, the systolic array may be include an n-bit multiplier and an m-bit adder wherein n may be any number and the n-bit multiplier and m-bit adder may be operate on x-bit reduced floating-point numbers. The variables n, m, x, and y may be any number where n is greater than x.</p><p id="p-0037" num="0036">In the following description, various examples will be described. For purposes of explanation, specific configurations and details are set forth in order to provide a thorough understanding of the examples. However, it will also be apparent to one skilled in the art that the examples may be practiced without the specific details. Furthermore, well-known features may be omitted or simplified in order not to obscure the examples being described.</p><p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. <b>1</b>A</figref> illustrates an example 4&#xd7;4 systolic array <b>100</b>A. The systolic array <b>100</b>A illustratively includes four columns of PEs and four rows of PEs with four PEs in each row, and four PEs in each column. It will be understood that the systolic array <b>100</b>A is simplified for the purpose of description, and that a systolic array <b>100</b>A in accordance with the present disclosure may include any number of PEs in each row and column. Further, the number of PEs in each row may be different than the number of PEs in each column. It will be further understood that such a systolic array <b>100</b>A may be logically organized in any number of rows and any number of columns. Further, the number of rows may be different than the number of columns. The systolic array <b>100</b>A may be part of a neural network processor in a computer system. For example, the computer system may provide multi-tenant compute services for data processing applications such as an image recognition service, text-based data processing (e.g., processing of search queries), audio or video data processing, etc.</p><p id="p-0039" num="0038">Each PE may include a respective row input bus <b>102</b>, a respective column input bus <b>104</b>, a respective column output bus <b>106</b>, and a respective row output bus <b>108</b>. A PE may receive inputs from a left PE of the same row (or from external circuitries) via the row input bus <b>102</b>. The PE may also receive inputs from a PE of the same column above (or from external circuitries) via the column input bus <b>104</b>. The PE may perform arithmetic computations based on the inputs, and transmit the result of the arithmetic computations to a PE of the same column below (or to the external circuitries) via the column output bus <b>106</b>. The PE may also forward the inputs received via the row input bus <b>102</b> to a right PE of the same row via the row output bus <b>108</b>.</p><p id="p-0040" num="0039">The systolic array <b>100</b>A may perform arithmetic computations, including multiplication and addition operations, for the processing elements of a neural network. For example, each PE may include arithmetic units such as a multiplier and an adder. In some embodiments, the multiplier and the adder may be a fused multiplier adder. In the example of <figref idref="DRAWINGS">FIG. <b>1</b>A</figref>, each row of the PEs may handle one set of input data, and each column of the PEs may generate one set of output data based on the sets of input data received by each PE in a given column.</p><p id="p-0041" num="0040">A column <b>112</b> of the PEs (the leftmost column) may receive four sets of input data, with each set of input data being handled by one row of the PEs. A column <b>116</b> of reducers may provide four sets of reduced input data to the column <b>112</b> of the PEs, with each set of input data being provided by one reducer which can increase the overall performance of the array as compared to traditional arrays. It will be understood that the column <b>116</b> of reducers may provide any number of sets of reduced input to the column <b>112</b> of the PEs. For example, the number of reducers and/or the number of sets of reduced input may be based on a quantity of PEs in a given column. In the example of <figref idref="DRAWINGS">FIG. <b>1</b>A</figref>, the column <b>112</b> of the PEs includes four PEs (PE <b>112</b><i>a</i>, PE <b>112</b><i>b</i>, PE <b>112</b><i>c</i>, PE <b>112</b><i>d</i>) and the column <b>116</b> of reducers include four corresponding reducers (reducer <b>116</b><i>a</i>, reducer <b>116</b><i>b</i>, reducer <b>116</b><i>c</i>, reducer <b>116</b><i>d</i>). It will be understood that the column <b>116</b> of reducers may include any number of reducers. Each reducer in the column <b>116</b> of reducers may provide a set of reduced input data for a particular PE of the column <b>112</b> of PEs, wherein each set of reduced input data includes two or more reduced inputs. For example, the reducer <b>116</b><i>a </i>may provide a reduced input data element and a reduced weight to the PE <b>112</b><i>a</i>. Each reducer in the column <b>116</b> of reducers may convert the inputs into reduced inputs. For example, the reducer <b>116</b><i>a </i>may convert a 32-bit input data element into a reduced 22-bit input data element.</p><p id="p-0042" num="0041">Each reducer in the column <b>116</b> of reducers may further select a reduced input to provide to each PE in the column <b>112</b> of the PEs. For example, each reducer in the column <b>116</b> of reducers may contain a multiplexer to select a reduced weight or a reduced input data element to provide to the PE. In some embodiments, each reducer <b>116</b><i>a</i>-<b>116</b><i>d </i>may be implemented as multiple reducers (e.g., a first reducer and a second reducer). Further, the first reducer and the second reducer may provide one or more inputs to the column <b>112</b> of the PEs. For example, a first reducer of the reducer <b>116</b><i>a </i>may provide a reduced input data element to the PE <b>112</b><i>a </i>and a second reducer of a reducer <b>116</b><i>a </i>may provide a reduced weight to the PE <b>112</b><i>a</i>. In some embodiments, a PE may receive a reduced input (e.g., a reduced input data element) and a non-reduced input (e.g., a non-reduced weight) for arithmetic operations.</p><p id="p-0043" num="0042">Each PE in the column <b>112</b> may obtain, from the corresponding input data set received via the row input bus <b>102</b>, the reduced input data element and the reduced weight. Each PE in the column <b>112</b> may multiply the reduced input data element with the reduced weight to generate a scaled input. The scaled inputs generated by the PEs within any column (including the column <b>112</b>) can be accumulated by the adder of each PE. For example, a PE <b>112</b><i>a </i>(of the column <b>112</b>) may generate a first scaled input (from the first input data set), wherein the first scaled input may be based on the outputs of the adder. For example, the adder may generate a first output partial sum and the PE <b>112</b><i>a </i>may generate a first scaled input based at least in part on the first output partial sum. The PE <b>112</b><i>a </i>may transmit the first scaled input to a PE <b>112</b><i>b </i>via the column output bus <b>106</b> as a partial sum. The PE <b>112</b><i>b </i>may also generate a second scaled input (from the second input data set) and add the second scaled input to the partial sum. The updated partial sum, accumulated with the first scaled input and the second scaled input, is then transmitted to a PE <b>112</b><i>c </i>via the column output bus <b>106</b>. The partial sums are updated and propagated across the column <b>112</b>, and a PE <b>112</b><i>d </i>may generate a sum of the scaled inputs from the four input data sets.</p><p id="p-0044" num="0043">The sum generated by the PE <b>112</b><i>d </i>may correspond to an output data set, and may be fed back to the leftmost PEs after going through an activation function. Moreover, each PE in the column <b>112</b> can also propagate the input data sets to other PE columns (e.g., a column <b>114</b>), which can scale the input data sets with a different set of weights from the column <b>112</b>. Each column of the PEs can perform the arithmetic operations (multiplications and additions) to generate the output data elements for other processing elements in parallel. In the example of <figref idref="DRAWINGS">FIG. <b>1</b>A</figref>, the systolic array <b>100</b>A can generate output data elements for four PEs corresponding to the four columns of the systolic array <b>100</b>A.</p><p id="p-0045" num="0044">The systolic array <b>100</b>A may perform convolution computations in multiple waves. In one embodiment, a wave represents a stream of input data elements processed while reusing the same weights in the systolic array <b>100</b>A. For example, the respective weights may have been pre-loaded in each PE in the systolic array <b>100</b>A, sequentially or in parallel prior to starting a wave computation. The partial sums generated by the PEs may correspond to a single wave. As the PEs of the systolic array <b>100</b>A perform arithmetic operations for the convolution computations, dynamic power dissipated by all the multipliers in the PEs may be significant. This problem may be further exacerbated for a systolic array comprising a large number of PEs (e.g., several thousands). The arithmetic operations performed by a PE are further explained with reference to <figref idref="DRAWINGS">FIG. <b>2</b>A</figref> and <figref idref="DRAWINGS">FIG. <b>2</b>B</figref>.</p><p id="p-0046" num="0045">As noted above, an input may be reduced to generate a reduced input that is provided to the systolic array. Further, the input may be reduced into multiple reduced inputs for multiple single reduced precision computations that are combinable into a higher precision computation. The systolic array may include an aggregator in order to combine partial outputs into the higher precision output (e.g., a higher precision output relative to the single-pass computation). <figref idref="DRAWINGS">FIG. <b>1</b>B</figref> illustrates an example configuration of an eight-PE column <b>120</b> within a systolic array <b>100</b>B. The array <b>100</b>B may be similar to the array <b>100</b>A of <figref idref="DRAWINGS">FIG. <b>1</b>A</figref>, but illustratively includes 8 rows and one column. Specifically, as shown in <figref idref="DRAWINGS">FIG. <b>1</b>B</figref>, an input may be converted into multiple reduced inputs and each PE may perform a multiply-accumulate operation on each combination of reduced inputs and provide a partial output partial sum to corresponding adjacent PE. By varying the number of reduced inputs, the number of partial output partial sums generated and the number of multiply-accumulate operations may be similarly varied. Thus, each higher bit-length input may be converted into any number of reduced inputs with lower bit-lengths by the reducer for the systolic array in order to satisfy the bit-lengths natively supported by the systolic array.</p><p id="p-0047" num="0046">To facilitate calculation of a total output sum for a column, the column <b>120</b> in <figref idref="DRAWINGS">FIG. <b>1</b>B</figref> includes an aggregator <b>130</b>. The aggregator <b>130</b> may be located within or outside the array <b>100</b>B. For each pass through the array for a given input (e.g., for each combination of reduced inputs associated with a particular input), the aggregator <b>130</b> may store and sum the partial outputs. The aggregator <b>130</b> may add the partial sums generated for each combination of reduced inputs. The aggregator <b>130</b> may calculate a running sum (e.g., by iteratively adding the partial output sums for a given set of reduced inputs) for output as the total output sum. For example, the aggregator <b>130</b> may include a partial sum buffer <b>132</b>.</p><p id="p-0048" num="0047">In some embodiments, the systolic array may identify a particular order to pass the reduced inputs and the reduced weights through the array. For example, the reduced inputs and the reduced weights may be passed first through the array in order to retain the accuracy of the numbers with a lower magnitude. Therefore, the reduced inputs with lower magnitude may be accumulated first in order to retain accuracy. For example, the product of a low reduced input data element and a low reduced weight may be added to the product of a high reduced input data element and a low reduced weight (or a low reduced input data element and a high reduced weight) to generate a first partial output. Further, the first partial output may be added to the product of a low reduced input data element and a high reduced weight (or a product of the high reduced input data element and a low reduced weight) to generate a second partial output. Further, the second partial output may be added to the other of the product of the low reduced input data element and the high reduced weight or the product of the high reduced input data element and the low reduced weight to generate a third partial output. The third partial output may be added to the product of a high reduced input data element and a high reduced weight to generate a total output. By adding the reduced inputs with the lower magnitude first, the precision of the reduced inputs may be maintained in order to minimize the loss of precision of the low reduced inputs when added to the high reduced inputs.</p><p id="p-0049" num="0048">While an aggregator <b>130</b> providing pairwise summation is shown in <figref idref="DRAWINGS">FIG. <b>1</b>B</figref>, the aggregator <b>130</b> may alternatively implement other aggregation techniques. In some implementations, the column <b>120</b> of the PEs may not include an aggregator <b>130</b> and may provide an output data set consisting of partial sums for each combination of reduced inputs. In one implementation, the column <b>120</b> may not include an aggregator <b>130</b> and the column <b>120</b> may provide multiple partial output data sets. In some embodiments, the multiple output data sets may each correspond to a partial sum generated for each combination of reduced inputs of the column <b>120</b>. In another implementation, the aggregator <b>130</b> may provide more or less output data sets. The aggregator <b>130</b> may provide one or more output data sets each corresponding to one or more partial sums. In some instances, output of the aggregator <b>130</b> may be configurable according to a desired use of the array, and may therefore accept instructions as to what outputs should be provided. In some instances, the aggregator <b>130</b> may provide a combination of the above outputs (e.g., by providing the four partial sums corresponding to each combination of reduced inputs, as well as a final sum for the non-reduced input). In some embodiments, a portion of the aggregation of the partial sums may occur within the systolic array. For example, the systolic array may add (using one or more components) a first partial sum and a second partial sum to generate a third partial sum and may add a fourth partial sum and a fifth partial sum to generate a sixth partial sum. Further, the systolic array may provide the third partial sum and the sixth partial sum for accumulation to the aggregator <b>130</b>.</p><p id="p-0050" num="0049"><figref idref="DRAWINGS">FIG. <b>2</b>A</figref> illustrates a PE 00 in a systolic array for neural network computations, according to certain embodiments of the disclosed technologies. The PE 00 may be part of a systolic array similar to the systolic array <b>100</b>A in <figref idref="DRAWINGS">FIG. <b>1</b>A</figref>. <figref idref="DRAWINGS">FIG. <b>4</b>A</figref> and <figref idref="DRAWINGS">FIG. <b>4</b>B</figref> show additional details of the reducers <b>225</b>, <b>227</b> of <figref idref="DRAWINGS">FIG. <b>2</b>A</figref>. Some embodiments may be described with reference to neural networks, however, it will be understood that certain embodiments may be used in other applications, e.g. pattern recognition, image processing, audio processing, video processing, etc., without deviating from the scope of the technologies.</p><p id="p-0051" num="0050">The systolic array <b>200</b> includes reducers <b>225</b>, <b>227</b> and a plurality of processing elements including PE 00 and PE 01. The PE 00 may include one or more of a data element load generator <b>202</b>, an input data element register <b>204</b>, a weight register <b>206</b>, a multiplier <b>208</b>, an adder <b>210</b>, a skip calculation generator <b>212</b>, a skip calculation register <b>214</b>, a selector circuit <b>216</b>, an input partial sum register <b>218</b>, a cached weight register <b>220</b>, and an operation decoder <b>256</b>. The PE 00 may receive one or more of a reduced input data element <b>222</b>, a reduced weight <b>224</b>, a zero data element indicator <b>226</b>, a zero weight indicator <b>228</b>, an opcode <b>230</b>, a weight load <b>232</b>, and an input partial sum <b>234</b> to perform the convolution computations according to some embodiments.</p><p id="p-0052" num="0051">The PE 00 may be connected to a first reducer <b>225</b> and a second reducer <b>227</b>. The first reducer <b>225</b> may receive a first input (such as input data element <b>221</b>), and the second reducer <b>227</b> may receive a second input (such as weight <b>223</b>). The first reducer <b>225</b> may convert the first input into a first reduced input, and the second reducer <b>227</b> may convert the second input into a second reduced input. The first reducer <b>225</b> may provide the PE 00 with the reduced input data element <b>222</b> (e.g., a reduced version of the input data element <b>221</b>). Further, the second reducer <b>227</b> may provide the PE 00 with the reduced weight <b>224</b> (e.g., a reduced version of the weight <b>223</b>). In some embodiments, one or more of the first reducer <b>225</b> or the second reducer <b>227</b> may round the input and/or the reduced input. The rounding may be based on a rounding method identified by the system, a user, etc. (e.g., a user input may specify a particular rounding method). In other embodiments, one or more of the first reducer <b>225</b> or the second reducer <b>227</b> may reduce a pre-rounded input (e.g., the pre-rounded input may be rounded by a system local to or remote to the systolic array). Further, the first reducer <b>225</b> and the second reducer <b>227</b> may convert one or more floating-point inputs into a reduced representation. The floating-point inputs may include bit-lengths of 32-bits, 64-bits, or any number of bits.</p><p id="p-0053" num="0052">In some embodiments, one or more of the first reducer <b>225</b> or the second reducer <b>227</b> may detect when one or both of the input data element <b>221</b> and the weight <b>223</b> exceed a particular bit-length. For example, the first reducer <b>225</b> may determine if the input data element <b>221</b> exceeds 22-bits and the second reducer <b>227</b> may determine if the weight <b>223</b> exceeds 22-bits. Further, a user, the system, etc. may provide the particular bit-length for comparison with the bit-length of the input data element <b>221</b> and the weight <b>223</b>. Upon determining that a particular input (e.g., the input data element <b>221</b>) exceeds the identified bit-length, one or more of the first reducer <b>225</b> or the second reducer <b>227</b> can generate a reduced input (e.g., a reduced input data element <b>222</b>).</p><p id="p-0054" num="0053">In order to reduce the bit-length of the input data element <b>221</b> and/or the weight <b>223</b>, the first reducer <b>225</b> and/or the second reducer <b>227</b> can reduce the bit-length of a significand portion of the particular length. The first reducer <b>225</b> and/or the second reducer <b>227</b> can reduce the bit-length of the significand portion to match the maximum bit-length of the significand supported by components of the systolic array (e.g., the multiplier of each processing element). For example, the first reducer <b>225</b> and/or the second reducer <b>227</b> can reduce the bit-length of a significand portion of the input from 23-bits to 11-bits. In some embodiments, the first reducer <b>225</b> and/or the second reducer can expand an exponent portion of the input to a particular format required by the multiplier. For example, the first reducer <b>225</b> and/or the second reducer <b>227</b> can expand the bit-length of the exponent portion of the input from 8-bits to 10-bits.</p><p id="p-0055" num="0054">In the event that the significand portion of one or both of the input data element <b>221</b> and the weight <b>223</b> are already reduced, the first reducer <b>225</b> and the second reducer <b>227</b> can still extend the number of bits used to represent the exponent portion of each. Accordingly, subsequent arithmetic circuits such as the multiplier <b>208</b> can perform computations on numbers of a single format (e.g., 22-bit floating-point format).</p><p id="p-0056" num="0055">The PE 00 may receive the reduced input data element <b>222</b> via a first input port. The reduced input data element <b>222</b> may be an input data set, or any array of input data elements. The PE 00 may receive one reduced input data element at a time, in uniform time periods, from the input dataset. For example, a uniform time period may correspond to a clock cycle. The input data set may be similar to an input feature map comprising input feature map elements. As an example, the input data set may correspond to an input image, an audio clip, a video clip, a text portion, or any other data which may be provided for data processing to identify a certain pattern or an object. In some instances, the input data set may be an intermediate output dataset, which has gone through an activation function, e.g., ReLu or Sigmoid, as discussed with reference to <figref idref="DRAWINGS">FIG. <b>1</b>A</figref>. Each reduced input data element <b>222</b> may a floating-point data type or any suitable data type. Each reduced input data element <b>222</b> may include 22-bits, 21-bits, 20-bits, or any suitable number of bits. The reduced input data element <b>222</b> may be stored in the input data element register <b>204</b> for a period of time.</p><p id="p-0057" num="0056">The PE 00 may receive the reduced weight <b>224</b> via a second input port. In some embodiments, the reduced weight <b>224</b> may belong to a set of weight values corresponding to a convolution filter. The reduced weight <b>224</b> may be pre-loaded in the PE 00 prior to receiving the reduced input data element <b>222</b>. In some embodiments, the PE 00 may receive one reduced weight value at a time, in uniform time periods, from the set of reduced weight values, to pre-load each PE in a given row with a respective reduced weight value. The PE may pass the reduced weight value to the next PE in the respective row until each PE in the given row has been pre-loaded. Each PE may cache the respective reduced weight value to use for computations with the reduced input data elements. Each reduced weight <b>224</b> may be a floating-point data type or any suitable data type. Each reduced weight <b>224</b> may include 22-bits, 21-bits, 20-bits, or any suitable number of bits. The reduced weight <b>224</b> may be stored in a cached weight register <b>220</b> for a period of time.</p><p id="p-0058" num="0057">The PE 00 may receive the input partial sum <b>236</b> for a current operation via a third input port. In some embodiments, the input partial sum <b>236</b> can be a 16 bit, 18 bit, 32, bit, 33 bit, 34 bit number or have any number of bits.</p><p id="p-0059" num="0058">The PE 00 may receive the zero data element indicator <b>226</b> for a current operation via a fourth port. The zero data element indicator <b>226</b> may include a single bit or multiple bits. The zero data element indicator <b>226</b> may indicate (or be used to indicate) whether the reduced input data element <b>222</b> is zero. The zero data element indicator <b>226</b> may indicate whether the input data element <b>221</b> is zero. For example, a value of &#x201c;1&#x201d; for the zero data element indicator <b>226</b> may indicate that the reduced input data element <b>222</b> associated with the zero data element indicator <b>226</b> is zero, and a value of &#x201c;0&#x201d; for the zero data element indicator <b>226</b> may indicate that the reduced input data element <b>222</b> associated with the zero data element indicator <b>226</b> is not zero. Further, a &#x201c;0&#x201d; may correspond to a logical zero or a logical low, and a &#x201c;1&#x201d; may correspond to a logical one or a logical high. For example, the logical zero may be represented by a first range of voltage levels (e.g., 0-2 volts), and the logical one may be represented by a second range of voltage levels (e.g., 3-5 volts). It will be understood that other implementations to represent a &#x201c;0&#x201d; value and a &#x2018;1&#x201d; value are possible without deviating from the scope of the disclosed technologies. The zero data element indicator <b>226</b> may be generated by a circuit external to the PE 00, and passed to all the PEs in the same row sequentially, in the uniform time periods.</p><p id="p-0060" num="0059">The PE 00 may receive the zero weight indicator <b>228</b> via a fifth port. The zero weight indicator <b>228</b> may include a single bit or multiple bits. The zero weight indicator <b>228</b> may indicate whether the reduced weight <b>224</b> associated with the zero weight indicator <b>228</b> is zero. The zero weight indicator <b>228</b> may also indicate whether the weight <b>223</b> associated with the zero weight indicator <b>228</b> is zero. For example, a value of &#x201c;1&#x201d; for the zero weight indicator <b>228</b> may indicate that the reduced weight <b>224</b> is zero, and a value of &#x201c;0&#x201d; for the zero weight indicator <b>228</b> may indicate that the reduced weight <b>224</b> is not zero. The zero weight indicator <b>228</b> may be generated by a circuit external to the PE 00, and passed to all the PEs in the same row sequentially along with the reduced weight <b>224</b>.</p><p id="p-0061" num="0060">The weight load <b>232</b> may load the reduced weight <b>224</b> into the cached weight register <b>220</b> to provide a cached weight <b>246</b>. The weight load <b>232</b> may be asserted to cache the reduced weight <b>224</b> for the PE 00 in the cached weight register <b>220</b> before the reduced input data element <b>222</b> is fed into the array. As the weights are shifted into the array to pre-load each PE with a respective weight value, the weight load <b>232</b> may be asserted for each PE at certain time periods in order to pre-load each PE with the appropriate weight value.</p><p id="p-0062" num="0061">The operation decoder <b>256</b> may decode the opcode <b>230</b> to determine an operation to be executed by the PE 00 for different instructions represented by different opcode values. In some embodiments, a first opcode value may correspond to an instruction to shift the reduced weights from one PE to another in the systolic array. A second opcode value may correspond to an instruction to start the arithmetic computations by the PE. For example, once the reduced weights have been pre-loaded in the systolic arrays, the reduced input data elements may be read from the memory and the arithmetic computations may be performed as the reduced input data elements pass through the array. A third opcode value may correspond to an instruction to execute NOPs. The NOPS may be used to space two systolic array instructions, or when there are no reduced input data elements to be read from the memory. For example, the NOPs may be used to space the instructions to shift the reduced weights, and the instructions to start the arithmetic computations. For example, for a 4&#xd7;4 array, it may take up to 15 cycles to shift the reduced weights into all the PEs in the array before starting the arithmetic computations so 15 NOP cycles may be needed. The operation decoder <b>256</b> may decode the opcode <b>230</b> to generate a NOP <b>258</b>, and the start computations signal <b>260</b>. The operation decoder <b>256</b> may provide the start computations signal <b>260</b> to the weight register <b>206</b> that is connected to the multiplier <b>208</b> and to the adder <b>210</b>. The operation decoder <b>256</b> may also provide the start computations signal <b>260</b> to the multiplier <b>208</b>. The opcode <b>230</b> may include any suitable number of bits, e.g., two, four, etc. In some embodiments, the operation decoder <b>256</b> can also decode the opcode to determine a data type to provide a data type control signal.</p><p id="p-0063" num="0062">In some embodiments, the reduced input data element <b>222</b>, the reduced weight <b>224</b>, the opcode <b>230</b>, the zero data element indicator <b>226</b>, and the zero weight indicator <b>228</b> may belong to the row input bus <b>102</b>, as discussed with reference to <figref idref="DRAWINGS">FIG. <b>1</b>A</figref>. In other embodiments, a splitter (not shown) may be used in the PE 00 to split the row input bus <b>102</b> into different internal buses to carry the reduced input data element <b>222</b>, the reduced weight <b>224</b>, the opcode <b>230</b>, the zero data element indicator <b>226</b>, and the zero weight indicator <b>228</b> within the PE 00. For example, the reduced input data element <b>222</b> and the reduced weight <b>224</b> may belong to a first row input bus and the opcode <b>230</b>, the zero data element indicator <b>226</b>, and the zero weight indicator <b>228</b> may belong to a second row input bus.</p><p id="p-0064" num="0063">The data element load generator <b>202</b> may generate a data load signal <b>242</b> that may be used to allow the input data element register <b>204</b> to skip storing of the reduced input data element <b>222</b> in certain conditions. In some embodiments, the reduced input data element <b>222</b> may be loaded into the input data element register <b>204</b> when the data load signal <b>242</b> is asserted based on the zero data element indicator <b>226</b> and the NOP <b>258</b>. The data load signal <b>242</b> may be asserted when the zero data element indicator <b>226</b> corresponding to the reduced input data element <b>222</b> is &#x201c;0&#x201d; and the opcode <b>230</b> does not indicate a NOP (e.g., the NOP <b>258</b> is &#x201c;0&#x201d;). The data load signal <b>242</b> may not be asserted when the zero data element indicator <b>226</b> corresponding to the reduced input data element <b>222</b> or the NOP <b>258</b> is &#x201c;1.&#x201d; The data element load generator <b>202</b> may be implemented using an OR, NOR, NAND, or any suitable circuit.</p><p id="p-0065" num="0064">The input data element register <b>204</b> may store the reduced input data element <b>222</b>, or skip storing of the reduced input data element <b>222</b> to provide a stored input data element <b>244</b> based on the data load signal <b>242</b> for a current operation. In some embodiments, the input data element register <b>204</b> may store a Din input if a load input is &#x201c;1&#x201d;, and may hold the previous value if the load input is &#x201c;0.&#x201d; For example, if the data load signal <b>242</b> is &#x201c;1,&#x201d; the input data element register <b>204</b> may store a new value for the reduced input data element <b>222</b>, and if the data load signal <b>242</b> is &#x201c;0,&#x201d; the input data element register <b>204</b> may skip storing the new value for the reduced input data element <b>222</b>. Thus, in some instances, the input data element register <b>204</b> may only store non-zero value of the reduced input data element <b>222</b>. According to certain embodiments, skipping the storing of the new value by the input data element register <b>204</b> may result in not toggling the stored input data element <b>244</b> and holding the previous value of the stored input data element <b>244</b>.</p><p id="p-0066" num="0065">The weight register <b>206</b> may store the cached weight <b>246</b> to provide a stored weight value <b>248</b> based on the start computations signal <b>260</b>. In some embodiments, the weight register <b>206</b> may store a Din input if a load input is &#x201c;1,&#x201d; and may hold the previous value if the load input is &#x201c;0.&#x201d; For example, if the start computations signal <b>260</b> is asserted (e.g., the start computations signal <b>260</b> is &#x201c;1&#x201d;), the cached weight <b>246</b> may be loaded into the weight register <b>206</b>, else the weight register <b>206</b> may hold the previous value. Thus, the reduced weight <b>224</b> previously loaded into the cached weight register <b>220</b> using the weight load <b>232</b> may be shifted into the weight register <b>206</b> at the start of the arithmetic computations. In some embodiments, the stored weight value <b>248</b>, once loaded at the start of the arithmetic computations, remains unchanged as the input data element is fed into the PE 00, one element at a time, for computations corresponding to one or more waves through the systolic array.</p><p id="p-0067" num="0066">The PE 00 may provide the stored input data element <b>244</b> to a PE 01 based on the data load signal <b>242</b> for a current operation. The PE 01 may receive the stored input data element <b>244</b> via a first port as a reduced input data element <b>222</b>. In some embodiments, the input data element register <b>204</b> may store a Din input if a load input is &#x201c;1&#x201d;, and may hold the previous value if the load input is &#x201c;0.&#x201d; The PE 00 may provide the stored weight value <b>248</b> to a PE 01 based on a start computations signal <b>260</b>. The PE 01 may receive the stored weight value <b>248</b> via a second port as a reduced weight <b>224</b>. In some embodiments, the weight register <b>206</b> may store a Din input if a load input is &#x201c;1,&#x201d; and may hold the previous value if the load input is &#x201c;0.&#x201d;</p><p id="p-0068" num="0067">The multiplier <b>208</b> may perform a multiplication operation between the stored input data element <b>244</b> and the stored weight value <b>248</b>. The multiplier <b>208</b> may generate a product <b>250</b> based on the multiplication operation. The multiplier <b>208</b> may receive inputs of a fixed bit-length. For example, the multiplier <b>208</b> may receive 22-bit floating-point inputs. Therefore, the reducer can enable the systolic array to receive inputs of an arbitrary bit-length and provide the multiplier <b>208</b> with a reduced input of a bit-length supported by the multiplier <b>208</b>. In some embodiments, the product <b>250</b> may be an integer product, a floating-point product, or any other product. Further, the multiplier <b>208</b> may generate a product <b>250</b> of 8-bits, 16-bits, 18-bits, 32-bits, 34-bits, or any other number of bits. The multiplier <b>208</b> may be implemented using a multiplier circuit. The multiplier <b>208</b> may perform floating-point multiplication, integer multiplication, or multiplication involving any other data type. The multiplier <b>208</b> may be implemented using a 16-bit multiplier data path, an 18-bit multiplier data path, a 22-bit multiplier data path, or a multiplier data path with any number of bits. The multiplier <b>208</b> may support at least n-bits operations, wherein n is greater than or equal to the number of bits in the input (e.g., the input data element).</p><p id="p-0069" num="0068">The multiplier <b>208</b> may contain multiple data paths, for example, as further discussed with respect to <figref idref="DRAWINGS">FIG. <b>5</b></figref>. With respect to <figref idref="DRAWINGS">FIG. <b>2</b>A</figref>, the multiplier <b>208</b> may contain separate data paths for computing a sign bit, a significand, and an exponent. It will be understood that the significand data path and the exponent data path may include data of any number of bits.</p><p id="p-0070" num="0069">The multiplier <b>208</b> may provide the product <b>250</b> to the adder <b>210</b>. The adder <b>210</b> may perform an addition operation on the product <b>250</b> and the stored input partial sum <b>236</b> to provide an addition result <b>238</b>. The adder <b>210</b> may be implemented using an adder circuit. The adder <b>210</b> may perform floating-point addition, integer addition, or non-integer addition. The adder <b>210</b> may perform addition on inputs with 8-bits, 16-bits, 18-bits, 32-bits, 34-bits, or any number of bits. The adder <b>210</b> may be implemented using a 16-bit adder data path, an 18-bit adder data path, a 32-bit adder data path, a 34-bit adder data path, or an adder data path with any number of bits. In one embodiment, the adder <b>210</b> is implemented with given bit-size (e.g., with an adder data path of the given bit-size), which may represent a maximum bit size of an expected input to the array. In some embodiments, each processing element may include an adder with a larger bit-size and a multiplier with a smaller bit-size as adders of increased bit-sizes may be more cost efficient than multipliers of the same increased bit-sizes. Therefore, this disclose enables a systolic array to support, at reduced precision, larger bit-sizes using lower bit-size multipliers. In another embodiment, the adder <b>210</b> may be implemented with a smaller bit size than a maximum bit size of an expected input to the array. The adder <b>210</b> may support at least m-bits operations where m is equal to or larger than the value of the multiplier data path. The adder data path may be a superset of the multiplier data path.</p><p id="p-0071" num="0070">The multiplier <b>208</b> and the adder <b>210</b> may provide a fused multiply-accumulate operation. The multiplier <b>208</b> and the adder <b>210</b> may be integrated together to perform a single step multiply add operation. In some embodiments, no rounding may be performed on the output of the multiplier <b>208</b> prior to providing the output to the adder <b>210</b>. Further, the multiplier <b>208</b> may provide an accurate product <b>250</b> to the adder <b>210</b>. In other embodiments, the PE 00 may perform rounding on the output of the multiplier <b>208</b>.</p><p id="p-0072" num="0071">The selector circuit <b>216</b> may receive the addition result <b>238</b>, the input partial sum <b>236</b>, and the stored skip calculation indicator <b>254</b>. The selector circuit <b>216</b> may select either the addition result <b>238</b> or the input partial sum <b>236</b> to provide as an output partial sum <b>240</b> via a sixth port. In some embodiments, the selector circuit <b>216</b> may contain at least one multiplexer, the multiplexer may select the addition result <b>238</b> or the input partial sum <b>236</b> to be produced. The selector circuit <b>216</b> may select either the addition result <b>238</b> or the input partial sum <b>236</b>, based on the stored skip calculation indicator <b>254</b>, to provide as an output partial sum <b>240</b> via a sixth port. According to some embodiments, when a value of either the reduced input data element <b>222</b> or the reduced weight <b>224</b> for a current operation is zero, or the NOP <b>258</b> is asserted, the addition result <b>238</b> since the product <b>250</b> may hold a value for the previous operation. In such cases, the stored skip calculation indicator <b>254</b> may allow bypassing the addition result <b>238</b>, and selecting the input partial sum <b>236</b> to provide as the output partial sum <b>240</b>. For example, when the stored skip calculation indicator <b>254</b> provides a skip calculation signal of &#x201c;1&#x201d;, the input partial sum <b>236</b> may be selected as the output partial sum <b>240</b> for a systolic cycle, and when the stored skip calculation indicator <b>254</b> provides a skip calculation signal of &#x201c;0&#x201d;, either the addition result <b>238</b> may be selected as the output partial sum <b>240</b> for the systolic cycle.</p><p id="p-0073" num="0072"><figref idref="DRAWINGS">FIG. <b>2</b>B</figref> illustrates the figure shown in <figref idref="DRAWINGS">FIG. <b>2</b>A</figref> with a shared reducer <b>225</b> replacing the first reducer <b>225</b> and the second reducer <b>227</b>. The shared reducer <b>225</b> may receive the input data element <b>221</b> and the weight <b>223</b>. The shared reducer <b>225</b> may also receive the opcode <b>230</b>. The shared reducer <b>225</b> may perform a selection operation on the input data element <b>221</b> and the weight <b>223</b> based at least in part upon the opcode <b>230</b>. In some embodiments, the shared reducer <b>225</b> will produce a reduced input based at least in part upon the opcode <b>230</b>. For example, when the opcode <b>230</b> is a particular value, the shared reducer <b>225</b> may reduce the weight <b>223</b> and provide the reduced weight <b>224</b> to the PE 00. Further, when the opcode <b>230</b> provides some other set value, the shared reducer <b>225</b> may reduce the input data element <b>221</b> and provide the reduced input data element <b>222</b> to the PE 00. Therefore, the shared reducer <b>225</b> can reduce the bit-length of the significand portion of both the input data element <b>221</b> and the weight <b>223</b> to match the maximum bit-length of the significand supported by components of the systolic array (e.g., the multiplier of each processing element). In some embodiments, the shared reducer <b>225</b> may receive multiple input data elements and/or multiple weights and produce multiple reduced input data elements and/or multiple reduced weights. For example, the shared reducer <b>225</b> can produce any number of reduced input data elements (e.g., four) and/or any number of reduced weights (e.g., four).</p><p id="p-0074" num="0073">The shared reducer <b>225</b> may use a multiplexer to select between the input data element <b>221</b> and the weight <b>223</b>. In some embodiments, the reduced input data element <b>222</b> and the reduced weight <b>224</b> may be delivered to the PE 00 on separate buses. In other embodiments, the reduced input data element <b>222</b> and the reduced weight <b>224</b> may be delivered on the same bus. Further, the shared reducer <b>225</b> may reduce both the input data element <b>221</b> and the weight <b>223</b> in the same clock cycle and provide the reduced input data element <b>222</b> and the reduced weight <b>224</b> to the PE 00. In some embodiments, the shared reducer <b>225</b> may reduce the weight <b>223</b> and provide the reduced weight <b>224</b> to the PE 00 during a clock cycle. The shared reducer <b>225</b> may then reduce the input data element <b>221</b> and provide the reduced input data element <b>222</b> to the PE 00 during a second clock cycle.</p><p id="p-0075" num="0074"><figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates an apparatus <b>300</b> including zero detector circuits for reduced input data elements and reduced weights entering a systolic array for neural network computations, according to certain embodiments of the disclosed technologies.</p><p id="p-0076" num="0075">The apparatus <b>300</b> may include a two-dimensional systolic array <b>302</b> comprising PEs arranged into rows and columns. The systolic array <b>302</b> may be similar to the systolic array <b>100</b>A in <figref idref="DRAWINGS">FIG. <b>1</b>A</figref>. A first row of the systolic array <b>302</b> may include PE 00, PE 01, PE 02, . . . , PE 0y, a second row of the systolic array <b>302</b> may include PE 10, PE 11, PE 12, . . . , PE 1y, a third row of the systolic array <b>302</b> may include PE 20, PE 21, PE 22, . . . , PE 2y, and an Xth row of the systolic array <b>302</b> may include PE x0, PE x1, PE x2, . . . , PE xy. The x and y may include positive integers, e.g., 32, 64, 128, or any suitable number. Each PE of the systolic array <b>302</b> may be similar to the PE 01, and include means to perform arithmetic computations on reduced inputs using power efficient methods, as discussed with reference to <figref idref="DRAWINGS">FIG. <b>2</b>A</figref>, <figref idref="DRAWINGS">FIG. <b>2</b>B</figref>.</p><p id="p-0077" num="0076">In certain embodiments, a first (e.g., leftmost) PE in each row of the systolic array <b>302</b> may be coupled to a respective zero input data detector circuit to detect a zero value on an input data element, and a respective zero weight detector circuit to detect a zero value on a weight value entering the systolic array <b>302</b>. For example, the PE 00 in the first row may be coupled to a first zero input data detector <b>306</b><i>a </i>and a first zero weight detector <b>308</b><i>a</i>, the PE 10 in the second row may be coupled to a second zero input data detector <b>306</b><i>b </i>and a second zero weight detector <b>308</b><i>b</i>, the PE 20 in the third row may be coupled to a third zero input data detector <b>306</b><i>c </i>and a third zero weight detector <b>308</b><i>c</i>, and the PE x0 in the Xth row may be coupled to an Xth zero input data detector <b>306</b><i>x </i>and an Xth zero weight detector <b>308</b><i>x</i>. The first zero input data detector <b>306</b><i>a</i>, the second zero input data detector <b>306</b><i>b</i>, the third zero input data detector <b>306</b><i>c</i>, . . . , and the Xth zero input data detector <b>306</b><i>x </i>may detect a zero value on a respective reduced input data element in an input dataset0, an input dataset1, an input dataset2, . . . , and an input datasetx respectively. Similarly, the first zero weight detector <b>308</b><i>a</i>, the second zero weight detector <b>308</b><i>b</i>, the third zero weight detector <b>308</b><i>c</i>, . . . , and the Xth zero weight detector <b>308</b><i>x </i>may detect a zero value on a respective reduced weight value in a filter0, a filter1, a filter2, . . . , and a filterx respectively.</p><p id="p-0078" num="0077">Each zero input data detector and each zero weight detector in each row of the systolic array <b>302</b> may be coupled to a respective reducer to receive a reduced input. Each zero input data detector may receive a reduced input data element and each zero weight detector may receive a reduced weight. For example, the first zero input data detector <b>306</b><i>a </i>may be coupled to a first reducer <b>307</b><i>a </i>and the first zero weight detector <b>308</b><i>a </i>may be coupled to a second reducer <b>309</b><i>a</i>, the second zero input data detector <b>306</b><i>b </i>may be coupled to a third reducer <b>307</b><i>b </i>and the second zero weight detector <b>308</b><i>b </i>may be coupled to a fourth reducer <b>309</b><i>b</i>, the third zero input data detector <b>306</b><i>c </i>may be coupled to a fifth reducer <b>307</b><i>c </i>and the third zero weight detector <b>308</b><i>c </i>may be coupled to a sixth reducer <b>309</b><i>c</i>, and the Xth zero input data detector <b>306</b><i>x </i>may be coupled to an Xth reducer <b>307</b><i>x </i>and the Xth zero weight detector <b>308</b><i>x </i>may be coupled to an Yth reducer <b>309</b><i>x. </i></p><p id="p-0079" num="0078">The reducers <b>307</b><i>a</i>-<b>307</b><i>x </i>and <b>309</b><i>a</i>-<b>309</b><i>x </i>may be implemented as a separate entity external to the systolic array <b>302</b>. For example, the reducers <b>307</b><i>a</i>-<b>307</b><i>x </i>and <b>309</b><i>a</i>-<b>309</b><i>x </i>may be part of a circuit separate from the systolic array. In some embodiments, the circuit and the systolic array <b>302</b> may be part of a computing engine, which may perform arithmetic computations for the convolution operations. In other embodiments, the reducers <b>307</b><i>a</i>-<b>307</b><i>x </i>and <b>309</b><i>a</i>-<b>309</b><i>x </i>may be implemented as part of the systolic array <b>302</b>.</p><p id="p-0080" num="0079">In some embodiments, the first reducer <b>307</b><i>a </i>and the second reducer <b>309</b><i>a </i>may be a first shared reducer and the third reducer <b>307</b><i>b </i>and the fourth reducer <b>309</b><i>b </i>may be a second shared reducer and the fifth reducer <b>307</b><i>c </i>and the sixth reducer <b>309</b><i>c </i>may be a third shared reducer and the Xth reducer <b>307</b><i>x </i>and the Yth reducer <b>309</b><i>x </i>may be an Xth shared reducer. Each shared reducer may provide a reduced input data element and a reduced weight. In some embodiments, each shared reducer may contain one output bus and may select a reduced input to produce. In other embodiments, each shared reducer may contain multiple output buses and may output a reduced input data element and a reduced weight.</p><p id="p-0081" num="0080">The zero input data detectors <b>306</b><i>a</i>-<b>306</b><i>x </i>and/or zero weight detectors <b>308</b><i>a</i>-<b>308</b><i>x </i>can be arranged before the respective reducers <b>307</b><i>a</i>-<b>307</b><i>x</i>, <b>309</b><i>a</i>-<b>309</b><i>x </i>such that a zero input can be detected, and if the zero input is detected, then the respective reducer(s) <b>307</b><i>a</i>-<b>307</b><i>x</i>, <b>309</b><i>a</i>-<b>309</b><i>x </i>can be non-operational to conserve power. In some embodiments, both the zero input data detectors <b>306</b><i>a</i>-<b>306</b><i>x </i>and respective reducers <b>307</b><i>a</i>-<b>307</b><i>x </i>can receive the input datasets and operate in parallel instead of sequentially. Further, both the zero weight detectors <b>308</b><i>a</i>-<b>308</b><i>x </i>and the respective reducers <b>309</b><i>a</i>-<b>309</b><i>x </i>can receive the filters and operate in parallel instead of sequentially.</p><p id="p-0082" num="0081">Each of the input dataset0, the input dataset1, the input dataset2, . . . , and the input datasetx may belong to an image, a text, a video clip, an audio clip, or another type of data set which may need to be processed by a neural network processor for convolution computations.</p><p id="p-0083" num="0082">In some instances, the input dataset0, the input dataset1, the input dataset2, . . . , and the input datasetx may be associated with output dataset0, output dataset1, output dataset2, . . . , output datasety generated by an intermediate layer of the convolution operation. For example, the output dataset0, output dataset1, output dataset2, . . . , output datasety may go through activation functions and be fed back to the systolic array <b>302</b> as the input dataset0, the input dataset1, the input dataset2, . . . , and the input datasetx. The filter0, the filter1, the filter2, . . . , and the filterx may include different sets of weight values to convolve with the input dataset0, the input dataset1, the input dataset2, . . . , and the input datasetx. The weight values in the filter0, the filter1, the filter2, . . . , and the filterx may be pre-determined using supervised learning, non-supervised learning, or any suitable method of determining convolution filters.</p><p id="p-0084" num="0083">Each zero input data detector for the respective row may detect whether a reduced input data element from the input dataset entering the respective row is &#x201c;0&#x201d; and generate a corresponding zero input data indicator for that reduced input data element. Further, each zero input data detector for the respective row may also detect whether an input data element from the input dataset entering the respective reducer is &#x201c;0&#x201d; and generate a corresponding zero input data indicator for that input data element. The corresponding zero data element indicator may be passed into the first PE of the respective row along with the reduced input data element. For example, the PE 00 may be the first PE of the first row in the systolic array <b>302</b>. The PE 00 may receive reduced input data elements from the input dataset0 prior to other PEs in the first row (e.g., PE 01, PE 02, . . . , PE 0y). In some embodiments, one reduced input data element at a time may be fed sequentially, in uniform time periods, from the input dataset0 to the PE 00. The first zero input data detector <b>306</b><i>a </i>may generate the zero data element indicator <b>226</b> in each of the uniform time periods (e.g. clock cycles) for each input data element from the input dataset0. The zero data element indicator <b>226</b> may be fed to the PE 00 sequentially, in uniform time periods, along with each reduced input data element. The PE 00 may or may not store the reduced input data element <b>222</b> based on the value of the respective data load signal <b>242</b>. In some embodiments, the first zero input data detector <b>306</b><i>a </i>may include a comparator to compare the incoming reduced input data element with a zero to assert (e.g., set to &#x201c;1&#x201d;) or de-assert (e.g., set to &#x201c;0&#x201d;) the zero data element indicator <b>226</b> based on the value of the incoming reduced input data element. For example, the comparator may be implemented using an OR, XOR, NAND, or any suitable circuit.</p><p id="p-0085" num="0084">Each zero weight detector for the respective row may detect whether a reduced weight from a set of reduced weights entering the respective row is zero and generate a corresponding zero weight indicator for the reduced weight. Further, each zero weight detector may also detect whether a weight from a set of filters entering the respective reducers is zero and generate a corresponding zero weight indicator for that weight. For example, the first zero weight detector <b>308</b><i>a </i>may detect whether a reduced weight from the filter0 (e.g., the reduced weight <b>224</b>) includes a zero value and generate the zero weight indicator <b>228</b> for the reduced weight. In some embodiments, the first zero weight detector <b>308</b><i>a </i>may include a comparator to compare the reduced weight with a zero to assert (e.g., set to &#x201c;1&#x201d;) or de-assert (e.g., set to &#x201c;0&#x201d;) the zero weight indicator <b>228</b>. For example, the comparator may be implemented using an OR, XOR, NAND, or any suitable circuit. In one embodiment, a reduced weight, one at a time, may be fed sequentially, in uniform time periods, from the filter0 to the PE 00 for pre-loading the respective reduced weights to the PE 00 to the PE 0y prior to starting the arithmetic computations. The first zero weight detector <b>308</b><i>a </i>may generate a corresponding zero weight indicator for each of those reduced weights which may be fed to the PE 00 sequentially, in uniform time periods, along with the corresponding reduced weight. The PE 00 may pass the respective reduced weight and the corresponding zero weight indicators sequentially to the next neighboring PE until all the PEs in the first row have been preloaded with the respective reduced weights and the corresponding zero weight indicators. The respective reduced weights and the corresponding zero weight indicator may be cached in each PE before the respective reduced input data elements are fed to each row in the systolic array <b>302</b>.</p><p id="p-0086" num="0085">The second zero input data detector <b>306</b><i>b</i>, the third zero input data detector <b>306</b><i>c</i>, . . . , and the Xth zero input data detector <b>306</b><i>x </i>may be similar to the first zero input data detector <b>306</b><i>a</i>, and may generate a respective zero data element indicator, similar to the zero data element indicator <b>226</b>, to provide to the PE 10, PE 20, . . . , and PE x0, sequentially, in the uniform time periods, for power optimization. The respective zero data element indicator generated for each row may be received by a respective first PE in each row via the respective row input bus <b>102</b>, and propagated, sequentially, in the uniform time periods, by the first PE to all the PEs in the given row. The second zero weight detector <b>308</b><i>b</i>, the third zero weight detector <b>308</b><i>c</i>, . . . , and the Xth zero weight detector <b>308</b><i>x </i>may be similar to the first zero weight detector <b>308</b><i>a</i>, and may generate a respective zero weight indicator, similar to the zero weight indicator <b>228</b>, to provide to the PE 10, PE 20, . . . , and PE x0, sequentially, to pre-load each PE in the respective row along with the respective weight value prior to starting the arithmetic computations.</p><p id="p-0087" num="0086">In some embodiments, the zero input data detectors <b>306</b><i>a</i>-<b>306</b><i>x</i>, and the zero weight detectors <b>308</b><i>a</i>-<b>308</b><i>x </i>may be implemented as a separate entity external to the systolic array <b>302</b>. For example, the zero input data detectors <b>306</b><i>a</i>-<b>306</b><i>x</i>, and the zero weight detectors <b>308</b><i>a</i>-<b>308</b><i>x </i>may be part of a circuit <b>304</b>. In other embodiments, the circuit <b>304</b> and the systolic array <b>302</b> may be part of a computing engine, which may perform arithmetic computations for the convolution operations. Some embodiments of the disclosed technologies can provide reduced gate count and dynamic power consumption by detecting zeros on the input data elements and the weights entering a respective first PE in each row of the systolic array, and passing the zero indicators to all the PEs in the array as compared to using respective zero detectors within each PE in the systolic array <b>302</b>.</p><p id="p-0088" num="0087">Note that <figref idref="DRAWINGS">FIG. <b>3</b></figref> only shows the respective zero data element indicator and the zero weight indicator entering the first PE in each row of the systolic array <b>302</b> for ease of illustration, however it will be understood that each PE in the respective row of the systolic array <b>302</b> may also receive the respective reduced input data element and the respective reduced weight along with some control signals (e.g., opcode <b>230</b>, weight load <b>232</b>, data type, etc.), which may be propagated from the left to the right of the systolic array <b>302</b> for each row.</p><p id="p-0089" num="0088"><figref idref="DRAWINGS">FIG. <b>4</b>A</figref> shows an example reduction system <b>400</b>A (e.g., a 32-bit floating-point (&#x201c;FP32&#x201d;) reduction system) according to an example implementation. The reduction system <b>400</b>A includes a multiplexer <b>402</b>, a rounding identifier, and a reducer <b>405</b>. The reducer <b>405</b> may reduce input of an arbitrary bit-length to the maximum bit-length supported by elements of a systolic array during a single-pass computation. For example, the reducer <b>405</b> may reduce input to a 22-bit input where 22-bits is the maximum bit-length supported by a multiplier of the systolic array. The reducer <b>405</b> can include an exponent expander <b>406</b>, a rounder <b>408</b>, and a trailing bit reducer <b>410</b>. In some embodiments, the reducer <b>405</b> may include the exponent expander <b>406</b>. In other embodiments, the reducer <b>405</b> may not include the exponent expander <b>406</b>. For example, the reducer <b>405</b> may not expand the exponent of an input to generate the reduced input. In some embodiments, the multiplexer <b>402</b> may be separate from the reducer <b>405</b>. In other embodiments, the reducer <b>405</b> may include the multiplexer <b>402</b>. As previously discussed, the reducer <b>405</b> processes an original number <b>401</b>A to result in a reduced number <b>403</b>A.</p><p id="p-0090" num="0089">The reduction system <b>400</b>A may receive one or more numbers to be reduced. The one or more numbers may include one or more of an input data element <b>221</b> and/or a weight <b>223</b>. For example, the reduction system <b>400</b>A can receive a FP32 weight and an FP32 input data element. In some embodiments, the reduction system <b>400</b>A may receive the input data element <b>221</b> or the weight <b>223</b> without a multiplexer.</p><p id="p-0091" num="0090">The multiplexer <b>402</b> may receive the one or more numbers received by the reduction system <b>400</b>A. The multiplexer <b>402</b> may also receive an opcode <b>230</b> or other indicator of whether a weight or input data element should be selected. The multiplexer <b>402</b> may decode the opcode <b>230</b> to select a number to be operated on by the reduction system <b>400</b>A. The multiplexer <b>402</b> may output a different number for the reduction operation based on the value of the opcode <b>230</b>. In some embodiments, a first opcode value may correspond to an instruction to output the weight <b>223</b> as the multiplexer output <b>420</b> and a second opcode value may correspond to an instruction to output the input data element <b>221</b> as the multiplexer output <b>420</b>. For example, once the input data element <b>221</b> and the weight <b>223</b> have been provided to the reduction system <b>400</b>A, the multiplexer <b>402</b> may output the input data element <b>221</b> and, at a later time, the weight <b>223</b>, based at least in part on the opcode <b>230</b>.</p><p id="p-0092" num="0091">In the example of <figref idref="DRAWINGS">FIG. <b>4</b>A</figref>, the original number <b>401</b>A is an FP32 number with a sign bit portion, an exponent bit portion, and a significand bit portion. It will be understood that the original number <b>401</b>A can be any arbitrary bit-length number with any exponent bit-length and/or significand bit-length. The FP32 format of the original number <b>401</b> includes a 1-bit sign, an 8-bit exponent, and a 23-bit significand. In some embodiments, the original number <b>401</b>A may include more, less, or different bits. Further, the original number <b>401</b>A may include more, less, or different bits for the sign bit portion, the exponent bit portion, and/or the significand bit portion.</p><p id="p-0093" num="0092">The exponent expander <b>406</b> may receive the 8-bit exponent <b>428</b> from the original number <b>401</b>A. The exponent expander <b>406</b> may increase a quantity of bits representing the exponent <b>428</b> from 8 bits to 10 bits. In some embodiments, the exponent expander <b>406</b> may add 1, 2, 3, or any number of bits to the exponent <b>428</b>. The added quantity of bits can be sufficient to represent the number in a format expected by the PE (e.g., the PE may expect a 10-bit exponent). In other embodiments, the exponent expander may not add any bits to the exponent <b>428</b>. For example, the exponent expander <b>406</b> (or another component) may determine that a sufficient (e.g., adequate) quantity of bits are included in the exponent <b>428</b> and may not expand the exponent <b>428</b>.</p><p id="p-0094" num="0093">The exponent expander <b>406</b> may expand the exponent <b>428</b> and retain the value of the exponent <b>428</b>. The exponent expander <b>406</b> may expand the exponent using range translation by copying the most significant bit, appending a second, inverted, copy of the most significant bit, and appending the other bits of the exponent <b>428</b> to the end of the expanded exponent <b>434</b>. For example, if the exponent <b>428</b> has a value of &#x201c;10101010&#x201d;, the exponent expander <b>406</b> may copy the most significant bit &#x201c;1&#x201d;, invert the most significant bit once &#x201c;0&#x201d;, and append the final seven bits &#x201c;0101010&#x201d; such that the expanded exponent <b>434</b> is &#x201c;100101010&#x201d;. In some embodiments, the expand expander <b>406</b> may perform a different operation if the exponent begins with a leading zero. Further, the exponent expander <b>406</b> may expand the exponent using range translation by copying the most significant bit, appending a second copy of the most significant bit, and appending the other bits of the exponent <b>428</b> to the end of the expanded exponent <b>434</b>. For example, if the exponent <b>428</b> is &#x201c;00000000,&#x201d; the exponent expander <b>406</b> may expand the exponent <b>428</b> such that the expanded exponent <b>434</b> is &#x201c;000000000.&#x201d; In some embodiments, the exponent expander <b>406</b> might add the extra bits of data to any location of the exponent field depending on the endian format and signed or unsigned representation of the exponent. Therefore, the exponent expander <b>406</b> can expand the exponent <b>428</b> to generate the expanded exponent <b>434</b>.</p><p id="p-0095" num="0094">The exponent expander <b>406</b> may provide the expanded version of the exponent <b>434</b> as the 10-bit expanded exponent field of the reduced number <b>403</b>A.</p><p id="p-0096" num="0095">The reducer <b>405</b> may further receive the rounding identifier <b>404</b>. The rounding identifier <b>404</b> may identify a type of rounding to be performed by the reducer <b>405</b>. For example, the rounding identifier <b>404</b> may identify a rounding method such as stochastic rounding, rounding to nearest even, rounding to zero, rounding down, rounding up, or any other rounding method. Stochastic rounding may include randomly rounding to the next larger or smaller number. For example, stochastic rounding may include a 50% probability of rounding down and a 50% probability of rounding up. Further, in stochastic rounding, the probability of rounding up or rounding down may be based on the relative position of the number to be rounded. For example, a number x between y and z may have a first probability of rounding up to z equal to (x&#x2212;y)/(z&#x2212;y) and a second probability of rounding down to y equal to (z&#x2212;x)/(z&#x2212;y) where y and z can be any numbers and x can be any number between y and z. Rounding to the nearest even may include rounding to the nearest even number with a particular number of bits, rounding to zero may include rounding a particular number of bits to zero, rounding up may include rounding a particular number of bits up, and rounding down may include rounding a particular number of bits down. The rounding identifier <b>404</b> may be provided by a user (e.g., via a user interface), another system, etc. Further, the rounding identifier <b>404</b> may be a custom rounding identifier or a default rounding identifier.</p><p id="p-0097" num="0096">The reducer <b>405</b> may contain a rounder <b>408</b> to round the significand <b>430</b>. The rounder <b>408</b> may perform rounding based on the rounding method identified by the rounding identifier <b>404</b>. For example, the rounding method may be stochastic rounding, rounding to nearest even, rounding to zero, rounding down, rounding up, or any other rounding method. The rounder <b>408</b> may perform the rounding based on any bit of the significand. Further, the rounder <b>408</b> may determine a number of bits to be reduced by the trailing bit reducer <b>410</b> (e.g., a number of bits to be zeroed) and may initiate the rounding at the bit immediately prior to the bits to be reduced. Further, the rounder <b>408</b> can round the bits to be reduced by the trailing bit reducer <b>410</b>. For example, if the significand <b>430</b> includes bits &#x201c;1110111&#x201d; and the trailing bit reducer <b>410</b> determines that the trailing bit reducer <b>410</b> will reduce the three trailing bits (e.g., the first three bits reading from the left to right), the rounder <b>408</b> may perform rounding based on the &#x201c;0&#x201d; in position 4. Further, if the rounder <b>408</b> determines to perform rounding to zero, the rounder <b>408</b> may produce a rounded significand <b>432</b> &#x201c;1110000,&#x201d; if the rounder <b>408</b> determines to perform rounding up, the rounder <b>408</b> may produce a rounded significand <b>432</b> &#x201c;1111000,&#x201d; etc. In some embodiments, the rounder <b>408</b> may be located logically after the trailing bit reducer <b>410</b> and the rounder <b>408</b> may round a reduced significand.</p><p id="p-0098" num="0097">The reducer <b>405</b> may further contain the trailing bit reducer <b>410</b> to reduce the bit representation of the rounded significand <b>432</b>. The trailing bit reducer <b>410</b> may receive the rounded significand <b>432</b> as input. The trailing bit reducer <b>410</b> may identify a number of bits to reduce from the rounded significand <b>432</b>. The number of bits to reduce may be based on a difference between the bit-length of the rounded significand <b>432</b> and a maximum single-pass computational bit-length supported by elements of the systolic array. Further, the number of bits may be based on a user input or system input (e.g., an input identifying a maximum number of bits supported). The number of bits may be trailing bits of the rounded significand <b>432</b> (e.g., a number of rightmost bits or the least significant bits). For example, if the trailing bit reducer <b>410</b> determines 3 bits should be reduced from the rounded significand <b>432</b>, the trailing bit reducer <b>410</b> may identify the 3 bits from right to left in the rounded significand <b>432</b>. Further, the bits may correspond to positions 0, 1, and 2 within the original number <b>401</b>A. The trailing bit reducer <b>410</b> may identify the bits and zero the bits (e.g., reduce, eliminate, push to logical zero). In the example of <figref idref="DRAWINGS">FIG. <b>4</b>A</figref>, the trailing bit reducer <b>410</b> identifies that 12 bits should be reduced from the rounded significand <b>432</b> and zeros the trailing 12 bits of the rounded significand <b>432</b>. By reducing the bit representation of the rounded significand <b>432</b>, the trailing bit reducer <b>410</b> can generate a reduced significand <b>436</b> that includes only the non-reduced (non-zeroed) bits of the significand <b>430</b>.</p><p id="p-0099" num="0098">The trailing bit reducer <b>410</b> may provide the reduced significand <b>436</b> as the 11-bit rounded significand of the reduced number <b>403</b>A.</p><p id="p-0100" num="0099">The reduced number <b>403</b>A may be a second bit-length wherein the second bit-length is any number of bits smaller than the first bit-length. In some embodiments, the second bit-length may be the maximum bit-length supported by elements of the systolic array. It will be understood that the reduced number <b>403</b>A can be any arbitrary bit-length number with any exponent bit-length and/or significand bit-length. In the example of <figref idref="DRAWINGS">FIG. <b>4</b>A</figref>, the reduced number <b>403</b>A may be an 22-bit floating-point number with a sign bit portion, an exponent bit portion, and a significand bit portion and the original number <b>401</b>A may be a 32-bit floating-point number. The reduced number <b>403</b>A may contain a 1-bit sign (e.g., the sign <b>426</b>), a 10-bit exponent (e.g., the expanded exponent <b>434</b>), and an 11-bit significand (e.g., the reduced significand <b>436</b>). The reduction system <b>400</b>A may provide the reduced number <b>403</b>A as a reduced output <b>421</b>. The reduced output <b>421</b> may be a reduced input data element <b>222</b>, a reduced weight <b>224</b>, or any other reduced number.</p><p id="p-0101" num="0100"><figref idref="DRAWINGS">FIG. <b>4</b>B</figref> shows an example reduction system <b>400</b>B (e.g., a 32-bit floating-point (&#x201c;FP32&#x201d;) reduction system) according to an example implementation. The reduction system <b>400</b>B may include a reducer <b>405</b> that may reduce input of an arbitrary bit-length to the maximum bit-length supported by elements of a systolic array during a single-pass computation. For example, the reducer <b>405</b> may reduce input to a 22-bit input where 22-bits is the maximum bit-length supported by a multiplier of the systolic array. The reduction system <b>400</b>B includes components similar to the reduction system <b>400</b>A except that in <figref idref="DRAWINGS">FIG. <b>4</b>B</figref> an original number <b>401</b>B is rounded by a system prior to provision to the reduction system <b>400</b>B.</p><p id="p-0102" num="0101">In the example of <figref idref="DRAWINGS">FIG. <b>4</b>B</figref>, the original number <b>401</b>B may be a FP32 number with a sign bit portion, an exponent bit portion, and a significand bit portion. It will be understood that the original number <b>401</b>B can be any arbitrary bit-length number with any exponent bit-length and/or significand bit-length The FP32 format of the original number <b>401</b>B includes a 1-bit sign, an 8-bit exponent, and a 23-bit rounded significand. In some embodiments, the original number <b>401</b>B can include any number of bits or be associated with any other bit format. The 23-bit rounded significand may be rounded by a system external or internal to the reduction system <b>400</b>B.</p><p id="p-0103" num="0102">The reducer <b>405</b> may further contain the trailing bit reducer <b>410</b> to reduce the rounded significand <b>450</b>. The trailing bit reducer <b>410</b> may receive the rounded significand <b>432</b> as input and reduce the quantity of bits representing the rounded significand <b>450</b> (e.g., from 23-bits to 11-bits). The trailing bit reducer <b>410</b> can generate a reduced significand <b>452</b> that includes only the non-reduced (non-zeroed) bits of the rounded significand <b>450</b>. Further, the trailing bit reducer <b>410</b> may provide the reduced significand <b>452</b> as the 11-bit rounded significand of the reduced number <b>403</b>B.</p><p id="p-0104" num="0103">In some embodiments, the reduction system <b>400</b>B may not receive the rounding identifier <b>404</b>. For example, the rounding identifier <b>404</b> may be provided to the system rounding generating the rounded significand <b>450</b> in order to identify a rounding method. The reduction system <b>400</b>B may provide the reduced number <b>403</b>B as a reduced output <b>441</b>. The reduced output <b>441</b> may be a reduced input data element <b>222</b>, a reduced weight <b>224</b>, or any other reduced number.</p><p id="p-0105" num="0104"><figref idref="DRAWINGS">FIG. <b>4</b>C</figref> shows an example reduction system <b>400</b>C (e.g., a 32-bit floating-point (&#x201c;FP32&#x201d;) reduction system) according to an example implementation. The reduction system <b>400</b>C may include a reducer <b>405</b> that may reduce input of an arbitrary bit-length to multiple reduced inputs with a maximum bit-length supported by elements of a systolic array during a single-pass computation. For example, the reducer <b>405</b> may reduce input to a 21-bit input where 21-bits is the maximum bit-length supported by a multiplier of the systolic array. The reduction system <b>400</b>C includes components similar to the reduction system <b>400</b>A and <b>400</b>B except that in <figref idref="DRAWINGS">FIG. <b>4</b>C</figref> an original number <b>401</b>C is converted into multiple reduced inputs by the reducer <b>405</b>.</p><p id="p-0106" num="0105">In the example of <figref idref="DRAWINGS">FIG. <b>4</b>C</figref>, the original number <b>401</b>C may be a FP32 number with a sign bit portion, an exponent bit portion, and a significand bit portion. It will be understood that the original number <b>401</b>C can be any arbitrary bit-length number with any exponent bit-length and/or significand bit-length. The FP32 format of the original number <b>401</b>C includes a 1-bit sign, an 8-bit exponent, and a 23-bit rounded significand. In some embodiments, the original number <b>401</b>C can include any number of bits or be associated with any other bit format.</p><p id="p-0107" num="0106">The original number <b>401</b>C as an input <b>454</b> may be provided to the format detector <b>456</b> for normal and/or denormal detection. For example, the format detector <b>456</b> may be a denormal detector and/or a normal detector. The format detector <b>456</b> may detect whether the input <b>454</b> is normal or denormal based at least in part on at least one of the value of the 1-bit sign, the value of the 8-bit exponent, or the value of the 23-bit significand. For example, the format detector <b>456</b> may detect a denormal number when the 8-bit exponent contains zeros in each bit and the significand is nonzero. The format detector <b>456</b> may provide an enable signal <b>458</b> to the normalizer <b>455</b> based at least in part on the detection of a normal number. For example, if the format detector <b>456</b> detects that the input <b>454</b> is normal, the format detector <b>456</b> may provide a first value to the normalizer <b>455</b>. If the format detector <b>456</b> detects that the input <b>454</b> is denormal, the format detector <b>456</b> may provide a second value to the normalizer <b>455</b>. In some implementations, the first number may be a 1 and the second number may be a 0. The detection of a normal number may correspond to a logical high and the detection of a denormal number may correspond to a logical zero. In some embodiments, the format detector <b>456</b> may detect a normal number by zeroing out the significand <b>450</b> (e.g., replacing the significand <b>450</b> with zeros) and subtracting the original number <b>401</b>C with the reduced significand <b>451</b> from the original number <b>401</b>C with the zeroed significand to generate a normal identifier. Further, the normal identifier may contain the implied leading bit if the original number <b>401</b>C is normal and may equal zero if the original number <b>401</b>C is denormal.</p><p id="p-0108" num="0107">The reducer <b>405</b> may provide the 1-bit sign as a 1-bit sign of the reduced number <b>403</b>C and the reduced number <b>403</b>D.</p><p id="p-0109" num="0108">The reducer <b>405</b> may further contain the trailing bit reducer <b>410</b> and the leading bit reducer <b>453</b> to reduce the significand <b>450</b>. The trailing bit reducer <b>410</b> and the leading bit reducer <b>453</b> may receive the significand <b>432</b> as input and reduce the quantity of bits representing the significand <b>450</b> (e.g., from 23-bits to 11-bits). The trailing bit reducer <b>410</b> can generate a reduced significand <b>452</b> that includes only the non-reduced (non-zeroed) bits of the significand <b>450</b> by removing trailing (or low) bits of the significand <b>450</b>. The leading bit reducer <b>453</b> can generate a reduced significand <b>451</b> that includes only the non-reduced (non-zeroed) bits of the significand <b>450</b> by removing high bits of the significand <b>450</b>. Further, the trailing bit reducer <b>410</b> may provide the reduced significand <b>452</b> as the 11-bit reduced significand of the reduced number <b>403</b>C and the leading bit reducer <b>453</b> may provide the reduced significand <b>451</b> as the input to the normalizer <b>455</b>.</p><p id="p-0110" num="0109">As discussed above, the reducer <b>405</b> may further contain the exponent expander <b>406</b>A and <b>406</b>B to expand the exponent <b>428</b>. The exponent expander <b>406</b>A can generate an expanded exponent <b>434</b> and may provide the expanded exponent <b>434</b> as an exponent of the reduced number <b>403</b>C and the expanded expander <b>406</b>B may provide the expanded exponent <b>433</b> as the input to the exponent adjuster <b>435</b>.</p><p id="p-0111" num="0110">The reducer <b>405</b> may contain the normalizer <b>455</b> (e.g., a shifter). The normalizer <b>455</b> may be enabled based at least in part on the enable signal <b>458</b> received from the format detector <b>456</b>. The normalizer <b>455</b> may receive the reduced significand <b>451</b> from the leading bit reducer <b>453</b>. The normalizer <b>455</b> may shift the reduced significand <b>451</b> based at least in part upon the number of leading zeros of the reduced significand <b>451</b> (as detected by the normalizer <b>455</b>). The normalizer <b>455</b> may further shift the reduced significand <b>451</b> such that the first non-zero number is shifted out of the reduced significand <b>451</b> and represented with an implied bit. The normalizer <b>455</b> may shift the reduced significand <b>451</b> by adding bits containing logical lows or zeros to the right or end of the reduced significand <b>451</b>. The normalizer <b>455</b> may produce a shifted significand <b>452</b>, wherein the shifted significand <b>452</b> may be the same number of bits as the reduced significand <b>451</b>. For example, if the reduced significand <b>451</b> is 00001100000, then the normalizer <b>455</b> can count four zeros and further adjust the shift count to five, and the normalizer <b>455</b> may shift the reduced significand <b>451</b> a total of five times and produce a shifted significand <b>452</b> of 10000000000. The normalizer <b>455</b> may then provide the shifted significand <b>452</b> as the significand portion of the reduced number <b>403</b>D. In the event that the format detector <b>456</b> does not identify the original number <b>401</b>C is a normal number (e.g., the original number <b>401</b>C is a denormal number), the normalizer <b>455</b> can provide the reduced significand <b>451</b> as the significand portion of the reduced number <b>403</b>D. In some embodiments, if the format detector <b>456</b> determines the original number <b>401</b>C is normal, the reducer <b>405</b> may calculate a zeroed number by zeroing the significand of the original number <b>401</b>C. Further, the reducer <b>405</b> may generate the significand of the reduced number <b>403</b>D by subtracting the reduced significand from the zeroed number. In other embodiments, the reduced number <b>403</b>D may be determined by subtracting the reduced number <b>403</b>C from the original number <b>401</b>C.</p><p id="p-0112" num="0111">The exponent expander <b>406</b>B may provide the expanded version of the exponent <b>433</b> to the exponent adjuster <b>435</b> (e.g., a subtractor) based at least in part on the enable signal <b>458</b> when a normal format for the first input is detected by the format detector <b>456</b> and a signal <b>437</b> from the normalizer <b>455</b> identifying the renormalized significand <b>452</b>. The exponent adjuster <b>435</b> may receive the expanded exponent <b>433</b> from the exponent expander <b>406</b>B and a number of leading zeros from the normalizer <b>455</b>. The number of leading zeros may identify the number of leading zeros removed by the normalizer <b>455</b> in order to renormalize the reduced significand <b>451</b>. The exponent adjuster <b>435</b> may subtract a value from the expanded exponent <b>433</b> based at least in part on the leading zeros output by the normalizer <b>455</b>. Therefore, the exponent adjuster <b>435</b> may compensate the exponent value for the shift of the significand. For example, if the leading zeros output is equal to 5 and the expanded exponent is equal to 000011111 or 31, the exponent adjuster <b>435</b> may subtract 5 from 000011111 or 31, such that the adjusted exponent <b>439</b> is equal to 000011010 or 26. The exponent adjuster <b>435</b> may provide the adjusted exponent <b>439</b> as the 9-bit expanded exponent field of the reduced number <b>403</b>D. Otherwise, the expanded version of the exponent <b>433</b> can be stored as the 9-bit expanded exponent field of the reduced number <b>403</b>D. In some embodiments, the exponent expander <b>406</b>B may expand the exponent <b>433</b> prior to the normalizer <b>455</b> normalizing the reduced significand <b>451</b>. In other embodiments, the exponent expander <b>406</b>B may expand the exponent <b>433</b> after or in parallel with the normalizer <b>455</b> normalizing the reduced significand <b>451</b>.</p><p id="p-0113" num="0112">The reduction system <b>400</b>C may provide the reduced number <b>403</b>C and the reduced number <b>403</b>D as reduced inputs <b>457</b> and <b>459</b> for the original number <b>401</b>C. The reduced inputs <b>457</b> and <b>459</b> may be reduced input data elements <b>222</b>, reduced weights <b>224</b>, or any other reduced numbers.</p><p id="p-0114" num="0113"><figref idref="DRAWINGS">FIG. <b>5</b></figref> shows an example multiply accumulate datapath <b>500</b>. The example datapath <b>500</b> may be implemented as the multiplier <b>208</b> and the adder <b>210</b> discussed with respect to <figref idref="DRAWINGS">FIG. <b>2</b>A</figref> and <figref idref="DRAWINGS">FIG. <b>2</b>B</figref>. As shown in <figref idref="DRAWINGS">FIG. <b>5</b></figref>, the multiplier <b>208</b> may receive a reduced input data element <b>222</b> and a reduced weight <b>224</b> and provide a multiplication product to the adder <b>210</b>. The adder <b>210</b> may receive the multiplication product and the input partial sum <b>234</b> and provide an addition result <b>238</b>. By converting inputs into reduced representation before presenting inputs to the multiplier <b>208</b>, the multiplier <b>208</b> can omit support for numbers with larger bit-lengths (e.g., 32-bits), instead the multiplier <b>208</b> can support numbers with the reduced bit-lengths (e.g., 22-bits). Therefore, the systolic array can retain the performance offered by receiving inputs of shorter bit-lengths by receiving inputs of arbitrary bit-lengths and adjusting the input to a particular bit-length (e.g., the maximum bit-length supported by the processing elements of the systolic array).</p><p id="p-0115" num="0114">The reduced input data element <b>222</b> may be a 22-bit number. In some embodiments, the reduced input data element <b>222</b> may have any bit-length and/or be any number of bits. Further, the reduced input data element <b>222</b> may be a floating-point number. In some embodiments, the reduced input data element <b>222</b> may be a brain floating-point number. Further, the reduced input data element <b>222</b> may be a number of any data type. The reduced input data element <b>222</b> may consist of a sign bit field, an exponent field, and a significand field. The multiplier <b>208</b> can support reduced input data elements of different types. For example, the reduced input data element <b>222</b> may contain a 1-bit sign, a 10-bit exponent, and an 11-bit significand. Further, the reduced input data element <b>222</b> may contain a 1-bit sign, an 8-bit exponent, and an 11-bit significand. The multiplier <b>208</b> may support both of these types of reduced input data elements. In some embodiments, the reduced input data element <b>222</b> may contain an x-bit sign, a y-bit exponent, and a z-bit significand where x, y, and z may be any number. The reduced input data element <b>222</b> may be provided to the multiplier <b>208</b> via a first sign data path <b>511</b>, a first exponent data path <b>521</b>, and a first significand data path <b>531</b>.</p><p id="p-0116" num="0115">The reduced weight <b>224</b> may be a 22-bit number. In some embodiments, the reduced weight <b>224</b> may have any bit-length and/or be any number of bits. Further, the reduced weight <b>224</b> may be a floating-point number. In some embodiments, the reduced weight <b>224</b> may be a brain floating-point number. Further, the reduced weight <b>224</b> may be any data type. The reduced weight <b>224</b> may consist of a sign bit path, an exponent bit path, and a significand bit path. For example, the reduced weight <b>224</b> may contain a 1-bit sign, a 10-bit exponent, and an 11-bit significand. Further, the reduced weight <b>224</b> may contain a 1-bit sign, an 8-bit exponent, and a 10-bit significand. In some embodiments, the reduced input data element <b>222</b> may contain an x-bit sign, a y-bit exponent, and a z-bit significand where x, y, and z may be any number. The reduced weight <b>224</b> may be provided to the multiplier <b>208</b> via a second sign data path <b>512</b>, a second exponent data path <b>522</b>, and a second significand data path <b>532</b>.</p><p id="p-0117" num="0116">The multiplier <b>208</b> may contain a sign data path, an exponent data path, and a significand data path. The multiplier <b>208</b> may receive the first sign data path <b>511</b>, the first exponent data path <b>521</b>, and the first significand data path <b>531</b> from the reduced input data element <b>222</b>. The multiplier <b>208</b> may receive the second sign data path <b>512</b>, the second exponent data path <b>522</b>, and the second significand data path <b>532</b> from the reduced weight <b>224</b>. In some embodiments, the multiplier <b>208</b> may also receive a data type control signal. The multiplier <b>208</b> may perform multiplication operations on the received inputs.</p><p id="p-0118" num="0117">The sign data path of the multiplier <b>208</b> may receive the first sign data path <b>511</b> and the second sign data path <b>512</b>. The sign data path may output a partial sign data path <b>513</b> based at least in part on the first sign data path <b>511</b> and the second sign data path <b>512</b>. In some embodiments, the sign data path can be implemented as an exclusive or (XOR) function. The sign data path may provide the partial sign data path <b>513</b> to the adder <b>210</b>.</p><p id="p-0119" num="0118">The exponent data path of the multiplier <b>208</b> may receive the first exponent data path <b>521</b> and the second exponent data path <b>522</b>. The exponent data path of the multiplier <b>208</b> may contain an adder <b>526</b>. In some embodiments, the exponent data path of the multiplier <b>208</b> may include a mapper to adjust the output of the multiplier <b>208</b> into a format expected by one or more components of the systolic array (e.g., an adder separate from the adder <b>526</b>). For example, an adder of the systolic array may expect (e.g., operate on) an input with an 11-bit exponent. Further, the mapper may receive the first exponent data path <b>521</b> and the second exponent data path <b>522</b> and perform a mapping operation to add one or more bits to the exponent of each of the reduced input data element <b>222</b> and the reduced weight <b>224</b></p><p id="p-0120" num="0119">The adder <b>526</b> may receive the mapped or unmapped versions of the first exponent data path <b>521</b> and the second exponent data path <b>522</b>. The adder <b>526</b> may perform addition on the two values received from the first exponent data path <b>521</b> and the second exponent data path <b>522</b>. The adder <b>526</b> can also receive shift/carry information (not shown) from the significand data path. The adder <b>526</b> may provide a partial exponent data path <b>523</b> based at least in part on the addition performed on the two values. The partial exponent data path <b>523</b> can be 10 bits or other range sufficient to accommodate the exponent sum without overflow.</p><p id="p-0121" num="0120">The significand data path of the multiplier <b>208</b> may receive the first significand data path <b>531</b> and the second significand data path <b>532</b>. The significand data path of the multiplier <b>208</b> may contain a binary multiplier <b>534</b> and a format adjuster <b>536</b>. The binary multiplier <b>534</b> may multiply the value of the first significand data path <b>531</b> by the value of the second significand data path <b>532</b>. The binary multiplier <b>534</b> may generate a multiplier product based on the multiplication operation. In some embodiments, the product may be an integer product, a floating-point product, or any other product. Further, the binary multiplier <b>534</b> may generate a product of 8-bits, 16-bits, 32-bits, or any other number of bits. The product may have a bit-length of a maximum bit-length supported by the elements of the systolic array during a single-pass computation. Therefore, the systolic array can receive inputs of an arbitrary inputs and a reducer can reduce to a bit-length corresponding to the maximum bit-length supported by elements of the systolic array (e.g., a multiplier of a processing element). The binary multiplier <b>534</b> may further perform floating-point multiplication, integer multiplication, or multiplication involving any other data type. The binary multiplier <b>534</b> may be implemented using a 16-bit multiplier data path, an 18-bit multiplier data path, or a multiplier data path with any number of bits. The binary multiplier <b>534</b> may provide a multiplier product to the format adjuster <b>536</b>. In some embodiments, the binary multiplier <b>534</b> may be implemented using a multiplier circuit.</p><p id="p-0122" num="0121">The format adjuster <b>536</b> may adjust the format of the multiplier product produced by the binary multiplier <b>534</b>. The significand data path of the multiplier <b>208</b> may include the format adjuster <b>536</b> to adjust the output of the multiplier <b>208</b> into a format expected by one or more components of the systolic array (e.g., an adder separate from the adder <b>526</b>). For example, an adder of the systolic array may expect (e.g., operate on) an input with a 23-bit significand. The format adjuster <b>536</b> may add or reduce the number of bits used to represent the multiplier product, for example, by increasing the bit size to 23 bits. The format adjuster <b>536</b> may provide a partial significand data path <b>533</b> to the adder <b>210</b>.</p><p id="p-0123" num="0122">The adder <b>210</b> may contain a sign data path, an exponent data path, and a significand data path. The adder <b>210</b> may be implemented with given bit-size (e.g., with an adder data path of a given size). In some embodiments, each processing element may include an adder with a larger bit-size and a multiplier with a smaller bit-size as adders of increased bit-sizes may be more cost efficient than multipliers of the same increased bit-sizes. Therefore, this disclose enables a systolic array to support, at reduced precision, larger bit-sizes using lower bit-size multipliers. The adder <b>210</b> may receive the partial sign data path <b>513</b>, the partial exponent data path <b>523</b>, and the partial significand data path <b>533</b> from the multiplier <b>208</b>. The adder <b>210</b> may also receive an input partial sum <b>234</b>. The adder <b>210</b> may perform an addition operation on the multiplier product comprised of the partial sign data path <b>513</b>, the partial exponent data path <b>523</b>, and the partial significand data path <b>533</b> and the input partial sum <b>234</b>. In some embodiments, the adder <b>210</b> may perform addition operations on both floating-point and brain floating-point numbers. Further, the adder <b>210</b> may be a 34-bit floating-point adder, a 32-bit floating-point adder, or any other bit-length adder.</p><p id="p-0124" num="0123">The adder <b>210</b> may generate an addition result <b>238</b> based on the addition operation. The addition result <b>238</b> may consist of a sign data path <b>515</b>, an exponent data path <b>525</b>, and a significand data path <b>535</b>. In some embodiments, the addition result <b>238</b> may be an integer sum, a floating-point sum, or any other sum. Further, the adder <b>210</b> may generate a sum of 8-bits, 16-bits, 32-bits, 34-bits, or any other number of bits. In some embodiments, the adder <b>210</b> may be implemented using a binary adder circuit.</p><p id="p-0125" num="0124"><figref idref="DRAWINGS">FIG. <b>6</b></figref> shows an apparatus <b>600</b> for neural network computations according to some embodiments of the disclosed technologies. The apparatus <b>600</b> may be part of a computer system, e.g., a host server. For example, the host server may provide multi-tenant compute services for data processing applications such as an image recognition service, text-based data processing (e.g., processing of search queries), audio data processing, video data processing, etc. In some embodiments, a host device may operate a software application and communicate with the apparatus <b>600</b> to make a prediction based on computations with a prediction model utilizing a neural network processor. For example, the host device can make the prediction by identifying information included in an input data set for an image, text, audio, video, etc. using the prediction model.</p><p id="p-0126" num="0125">The apparatus <b>600</b> may include a neural network processor <b>602</b> coupled to memory <b>614</b>, a host interface <b>616</b>, and a direct memory access (DMA) controller <b>618</b> via an interconnect <b>620</b>. The neural network processor <b>602</b> may include a computing engine <b>604</b>, a computation controller <b>606</b>, a state buffer <b>608</b>, an output buffer <b>610</b>, and an activation engine <b>612</b>. The neural network processor <b>602</b> can provide the computing resources to support the computations with the prediction model. The neural network processor <b>602</b> may be implemented as a system on chip (SoC), a field programmable gate array (FPGA), or any suitable circuit.</p><p id="p-0127" num="0126">The memory <b>614</b> may store instructions, input data sets (e.g., pixel data of an image) and the weights (e.g., weights corresponding to certain visual and/or non-visual features) received from the host device. The memory <b>614</b> may also store outputs of the neural network processor <b>602</b> (e.g., one or more image recognition decisions on the input images in the form of output data sets). The memory <b>614</b> may include any suitable memory, e.g., dynamic random access memory (DRAM), synchronous DRAM (SDRAM), double data rate DRAM (DDR DRAM), storage class memory (SCM), flash memory, etc.</p><p id="p-0128" num="0127">The host interface <b>616</b> may enable communication between the host device and the neural network processor <b>602</b>. For example, the host interface <b>616</b> may transmit memory descriptors including the memory addresses of the stored data (e.g., input data sets, weights, results of computations, etc.) between the host device and the neural network processor <b>602</b>. The host interface <b>616</b> may include, e.g., a peripheral component interconnect express (PCIe) interface, or any suitable interface for communicating with the host device. The host device may include a host processor and a host memory.</p><p id="p-0129" num="0128">The DMA controller <b>618</b> may perform DMA operations to transfer data between the neural network processor <b>602</b> and the host device. For example, as discussed above, the host device can store the instructions, input data sets, and the weights in the memory <b>614</b>. The host device can provide the memory addresses for the stored instructions, data, and the weights to the neural network processor <b>602</b> (e.g., in the form of memory descriptors). The neural network processor <b>602</b> can then obtain the stored instructions, data, and the weights based on the memory addresses provided by the host device. The neural network processor <b>602</b> can also store the results of computations (e.g., one or more image recognition decisions) in the memory <b>614</b>, and provide the memory addresses for the stored results to the host device.</p><p id="p-0130" num="0129">The state buffer <b>608</b> may provide caching of data used for computations at the computing engine <b>604</b>. The data cached at the state buffer <b>608</b> may include, e.g., the input data sets and the weights acquired from the memory <b>614</b>, as well as intermediate outputs of computations at the computing engine <b>604</b>. The caching can reduce the effect of memory access bottleneck (e.g., caused by the latencies at the memory <b>614</b>, the DMA controller <b>618</b>, the interconnect <b>620</b>, etc.) on the performance of the computing engine <b>604</b>. The state buffer <b>608</b> can be an on-chip memory device and may include a static random access memory (SRAM) or any suitable memory.</p><p id="p-0131" num="0130">The computation controller <b>606</b> may provide controls to various components of the neural network processor <b>602</b> to perform neural network computations. In some implementations, the computation controller <b>606</b> may read the instructions stored in the memory <b>614</b> and schedule the executions of the instructions by the computing engine <b>604</b>. In the first embodiment, the computation controller <b>606</b> may perform scheduling of loading the weights into the computing engine <b>604</b> prior to reading the input data elements from the state buffer <b>608</b>. For example, as discussed with reference to <figref idref="DRAWINGS">FIG. <b>2</b>A</figref>, <figref idref="DRAWINGS">FIG. <b>2</b>B</figref>, <figref idref="DRAWINGS">FIG. <b>4</b>A</figref>, and <figref idref="DRAWINGS">FIG. <b>4</b>B</figref>, the computation controller <b>606</b> may provide the opcode <b>230</b> and the weight load <b>232</b> to the computing engine <b>604</b> based on the instructions received from the host device. The computation controller <b>606</b> may provide appropriate values of the opcode <b>230</b> to the computing engine <b>604</b> which may be decoded by each PE in the computing engine <b>604</b> to perform a corresponding operation. For example, the computing engine <b>604</b> may use the weight load <b>232</b> and the opcode <b>230</b> to pre-load the weights in all the PEs in the computing engine <b>604</b>. Once the weights have been pre-loaded, the computation controller <b>606</b> may perform scheduling of loading the input data elements into the computing engine <b>604</b>, sequentially, in uniform time periods, from the state buffer <b>608</b> to start the arithmetic computations.</p><p id="p-0132" num="0131">In the second embodiment, the computation controller <b>606</b> may perform scheduling of loading the weights and the input data elements into the computing engine <b>604</b>, sequentially, in uniform time periods, from the state buffer <b>608</b>. The computation controller <b>606</b> may schedule loading of the weights and the input data elements in a respective first PE of each row in the systolic array <b>302</b> using a respective row data bus. For example, a respective input data element and a weight value may be loaded per cycle in the first PE of the respective row.</p><p id="p-0133" num="0132">In another embodiment, the computation controller <b>606</b> may schedule loading of the weights in the systolic array <b>302</b> in parallel for each row using a respective column data bus for each PE in a given row. For example, weights for each row may be loaded in parallel per cycle. In some embodiments, the computation controller <b>606</b> may determine a data type for the input data set based on the instructions received from the host device. The instructions may be in the form of an opcode. The data type may indicate a size and a type of the input data element, e.g., 4-bit, 8-bit, 16-bit, signed, unsigned, or floating-point.</p><p id="p-0134" num="0133">The computing engine <b>604</b> may perform computations for the neural network. For example, the computing engine <b>604</b> may reduce the input provided to a systolic array to generate the reduced input. Further, the computing engine <b>604</b> may determine the maximum supported bit-length for the systolic array and generate the reduced input with the maximum supported bit-length. In some embodiments, the computing engine <b>604</b> may include a set of PEs performing one or more arithmetic operations involved in the neural network computations. Each PE may perform multiply-accumulate operations using input data sets and associated weights. For example, the computing engine <b>604</b> may include the systolic array <b>302</b>, and the circuit <b>304</b> comprising the zero input data detectors <b>306</b><i>a</i>-<b>306</b><i>x</i>, and the zero weight detectors <b>308</b><i>a</i>-<b>308</b><i>x</i>. In some embodiments, the zero input data detectors <b>306</b><i>a</i>-<b>306</b><i>x</i>, and the zero weight detectors <b>308</b><i>a</i>-<b>308</b><i>x </i>may be external to the computing engine <b>604</b>. The computing engine <b>604</b> may execute instructions as scheduled by the computation controller <b>606</b> to load the weights and the input datasets sequentially from the state buffer <b>608</b> into the computing engine <b>604</b>.</p><p id="p-0135" num="0134">In the first embodiment, the weights may be pre-loaded prior to reading the input datasets from the state buffer <b>608</b>, as discussed with reference to <figref idref="DRAWINGS">FIG. <b>4</b></figref>. The respective zero weight indicators corresponding to each weight may be cached locally in each PE and the cached values may be used to perform arithmetic computations with the respective input data element as the input data element is fed into the computing engine <b>604</b> along with the corresponding zero data element indicator. In the second embodiment, the weights and the input datasets may be read simultaneously from the state buffer <b>608</b>, as discussed with reference to <figref idref="DRAWINGS">FIG. <b>5</b></figref>. The corresponding zero data element indicator and the zero weight indicator may be provided by the respective zero detector circuits and propagated sequentially from one PE to another for the respective row. The weights and the input datasets can be obtained from the state buffer <b>608</b> using one or more interfaces. In certain embodiments, the computing engine <b>604</b> may perform the arithmetic computations to reduce the dynamic power consumption of the systolic array <b>302</b> using the respective zero data element indicator and the zero weight indicator signals as discussed with reference to <figref idref="DRAWINGS">FIGS. <b>2</b>-<b>5</b></figref>, and provide the computations results to be stored in the output buffer <b>610</b>.</p><p id="p-0136" num="0135">The output buffer <b>610</b> may include a set of registers to store the output data sets generated by the computing engine <b>604</b>. In some embodiments, the output buffer <b>610</b> may also enable additional processing such as, e.g., a pooling operation to reduce the size of the stored outputs. Further, the computing engine <b>604</b> can be operated to perform computations for a particular neural network layer, and the output buffer <b>610</b> can process the outputs of that neural network layer and store the processed output datasets (with or without processing by the activation engine <b>612</b>) at the state buffer <b>608</b>. The processed output datasets may be used by the computing engine <b>604</b> as the intermediate outputs. In some embodiments, the output buffer <b>610</b> may include adders to accumulate the partial sums generated for different sets of filters and input data sets to generate a convolution output array. The final output value of the convolution output array stored in the state buffer <b>608</b> can be retrieved by the computation controller <b>606</b> for storing at the state buffer <b>608</b>.</p><p id="p-0137" num="0136">The activation engine <b>612</b> may apply one or more activation functions (e.g., ReLu function) on the output of the output buffer <b>610</b>. For example, the activation engine <b>612</b> may include one or more lookup tables (e.g., in the form of multiplexer circuits) that can map the input to one of the candidate outputs representing the result of applying the activation function to the input. In some examples, the activation engine <b>612</b> may also include a bypass path to allow outputs from the output buffer <b>610</b> to be stored directly at the state buffer <b>608</b> when activation functions are not to be applied.</p><p id="p-0138" num="0137"><figref idref="DRAWINGS">FIG. <b>7</b></figref> shows a method <b>700</b> executed by a computing engine <b>604</b> utilizing a systolic array (e.g., a group of processing elements), according to some examples of the disclosed technologies. The array may be similar, for example, to the array <b>100</b>A, and include multiple PEs similar to, e.g., the PE <b>112</b><i>a</i>. The systolic array may include a plurality of PEs configured in a plurality of rows and/or a plurality of columns. For example, the systolic array might include 65,536 PEs which are further divided into 256 rows and 256 columns. The computing engine <b>604</b> may be a systolic circuit that includes the systolic array and one or more reducers (e.g., convertors) to receive an input with an arbitrary bit-length and convert the arbitrary bit-length input into an input with a reduced bit-length corresponding to the maximum supported bit-length for elements of the systolic array. For example, the one or more reducers can convert a plurality of input data elements (e.g., 32-bit input data elements) into a plurality of reduced input data elements (e.g., 22-bit input data elements) and/or plurality of weights (e.g., 32-bit weights) into a plurality of reduced weights (e.g., 22-bit weights).</p><p id="p-0139" num="0138">In block <b>702</b>, a first reducer receives a first input (e.g., a first number) with a first bit-length (e.g., 32 bits). The first input bit-length may be an arbitrary bit-length. The first input may be represented in floating-point format. Further, the first reducer can identify a quantity of trailing bits of the first input and reduce the quantity of trailing bits of the first input. The first input may represent an input data element. The first reducer may convert 32-bit floating-point numbers to 22-bit floating-point numbers. In some embodiments, the first reducer may convert m-bit floating-point numbers to n-bit floating-point numbers, where n and m can be any numbers where n is less than m.</p><p id="p-0140" num="0139">In block <b>704</b>, the first reducer generates a first reduced input with a second bit-length (e.g., 22 bits). The second bit-length may be a maximum bit-length supported by elements of the systolic array. For example, the first reduced input may be a 22-bit floating-point number. Further, the second bit-length may be less than the first bit-length (e.g., the second bit-length may be any bit-length less than the first bit-length). The first reducer may generate the first reduced input based on reducing the quantity of trailing bits of the first input. To generate the first reduced input (or any other reduced inputs), the first reducer may include a trailing bit reducer to reduce a quantity of trailing bits representing a significand portion of the first input and produce a reduced significand portion of the first input (e.g., the 32-bit first input). For example, the trailing bit reducer may zero the quantity of trailing bits. Further, the first reducer may include a rounder to round the reduced significand portion of the first input based at least in part on a remainder of the bits (e.g., a remainder of non-trailing bits of the first input) representing the significand portion of the first input not included within the reduced significand portion. For example, rounding the first input may include rounding a portion of the bits of the first input. The rounder may further round the first input to a particular number (e.g., a particular floating-point number). In some embodiments, the rounder may round the significand portion and the trailing bit reducer may generate the reduced significand portion from the rounded significand portion (e.g., the first input may be a first rounded input to the trailing bit reducer). In other embodiments, the first reducer may not include a rounder and the significand portion may be pre-rounded (e.g., rounded by another system) or not rounded). The rounder may round the input based on one or more of stochastic rounding, rounding to nearest even, rounding to zero, rounding down, rounding up, or any other rounding method. Stochastic rounding may include rounding the input up to a first number or down to a second number based on probabilities that are tuned based on the relative distance between the input and the first number and the relative distance between the input and the second number respectively. In some embodiments, the input may be rounded based on user input (e.g., a selection of a rounding method). The first reducer may further include an exponent expander to increase a quantity of bits representing an exponent portion of the first input. In some embodiments, the first reduced input may be stored in a 24-bit format.</p><p id="p-0141" num="0140">In some embodiments, the first reducer may generate a second input. In other embodiments, the computing engine <b>604</b> may include a second reducer to receive a weight in floating-point format with the first bit-length. The second reducer may identify a quantity of trailing bits of the weight and reduce the quantity of trailing bits of the weight. Further, the second reducer may generate the weight in floating-point format with the second bit-length based on reducing the quantity of trailing bits of the weight. For example, the second input may be a second 22-bit floating-point number.</p><p id="p-0142" num="0141">In block <b>706</b>, an individual processing element in at least one row of the systolic array multiplies the first reduced input by the second input (e.g., a second number) to generate a multiplier product. In some embodiments, the second input may be a second reduced input. For example, the second input may be a reduced weight. The first reducer may receive the first input and a weight and generate the first reduced input and the second input. Further, the first reducer can select the first reduced input or the second input to be provided to the individual processing element. The individual processing element may include a multiplier to multiply the first reduced input by the second input. For example, each processing element may include a 22-bit multiplier. Further, each processing element may include a multiplier to multiply at least two inputs with the second bit-length (e.g., n-bit numbers). Further, the multiplier may multiply two 22-bit floating-point numbers. The multiplier may include a 1-bit sign data path, an 11-bit significand data path, and a 10-bit exponent data path.</p><p id="p-0143" num="0142">In block <b>708</b>, the individual processing element adds an input partial sum with the multiplier product to generate an adder partial sum (e.g., an addition result). The individual processing element may further include an adder to add the input partial sum with the multiplier product. For example, each processing element may include a 34-bit adder. Further, each processing element may include an adder to add at least two numbers with a third bit-length (e.g., p-bit numbers where p is greater than n, the multiplier receiving n-bit numbers). Further, the adder may add two floating-point numbers. The adder may include a 1-bit sign data path, a 23-bit significand data path, and a 10-bit exponent data path.</p><p id="p-0144" num="0143"><figref idref="DRAWINGS">FIG. <b>8</b></figref> shows a method <b>800</b> executed by a computing engine <b>604</b> utilizing a systolic array, according to some examples of the disclosed technologies. The array may be similar, for example, to the array <b>100</b>A, and include multiple PEs similar to, e.g., the PE <b>112</b><i>a</i>. The systolic array may include a plurality of PEs configured in a plurality of rows and/or a plurality of columns. For example, the systolic array might include 65,536 PEs which are further divided into 256 rows and 256 columns. The computing engine <b>604</b> may be a systolic circuit that includes the systolic array and one or more reducers (e.g., convertors) to receive an input with an arbitrary bit-length and convert the arbitrary bit-length input into multiple reduced inputs with a reduced bit-length corresponding to the maximum supported bit-length for elements of the systolic array. For example, the one or more reducers can convert each of a plurality of input data elements (e.g., 32-bit input data elements) into a multiple reduced input data elements (e.g., 21-bit input data elements) and/or each of a plurality of weights (e.g., 32-bit weights) into multiple reduced weights (e.g., 21-bit weights).</p><p id="p-0145" num="0144">In block <b>802</b>, the systolic array (e.g., a reducer of the systolic array) receives a first input (e.g., an input data element, a weight, etc.) in floating-point format with a first bit-length. For example, the first input may be a 32-bit floating-pint number. The systolic array may also receive a second input (e.g., an input data element, a weight, etc.) for multiply-accumulate operations. The reducer may convert m-bit floating-point numbers to one or more n-bit floating-point numbers, where n can be any number less than m. For example, the reducer can convert 32-bit floating-point numbers to two 21-bit floating-point numbers.</p><p id="p-0146" num="0145">In block <b>804</b>, the systolic array generates a first reduced input (e.g., a high reduced input) with a second bit-length. The first reduced input may correspond to a set of most significant bits of a significand portion of the first input (e.g., the leading bits of the significand portion of the first input).</p><p id="p-0147" num="0146">In block <b>806</b>, the systolic array generates a second reduced input (e.g., a low reduced input) with a third bit-length. The second reduced input may correspond to a set of least significant bits of the significand portion of the first input (e.g., the trailing bits of the significand portion of the first input). The first reduced input and the second reduced input may sum to the first input. Further, the second bit-length and the third bit-length may be less than the first bit-length from the first input. For example, the first reduced input and the second reduced input may each be 21-bit floating-point numbers. Further, the reducer may convert an input data element and a weight into respective first and second reduced numbers.</p><p id="p-0148" num="0147">Each of the first reduced input and the second reduced input may be represented in floating-point format. In some embodiments, the reducer may generate the first reduced input and subtract the first reduced input from the first input to generate the second reduced input. For example if the first input includes a first significand &#x201c;11111111011010101010101,&#x201d; the first reduced input includes a first significand &#x201c;11111111011,&#x201d; by subtracting the first reduced input from the first input, the second reduced input may be determined as &#x201c;010101010101.&#x201d; The first reduced input and the second reduced input may be a maximum supported bit-length for the systolic array and/or a particular processing element. In some embodiments, the reducer may include a first sub-reducer to generate the first reduced input. The first sub-reducer may include a trailing bit reducer to reduce a quantity of trailing bits of a significand portion of the first input to produce a high reduced significand portion. The first sub-reducer may further include a first exponent expander to increase a quantity of bits representing an exponent portion of the first input to produce a first increased exponent portion. Based on the first increased exponent portion and the high reduced significand portion, the first sub-reducer may generate the first reduced input (e.g., the high reduced input). Further, the reducer may include a second sub-reducer to generate the second reduced input. The second sub-reducer may include a leading bit reducer to reduce a quantity of leading bits of a significand portion of the first input to produce a low reduced significand portion. The second sub-reducer may further include a second exponent expander to increase a quantity of bits representing an exponent portion of the first input to produce a second increased exponent portion. Based on the second increased exponent portion and the low reduced significand portion, the second sub-reducer may generate the second reduced input (e.g., the low reduced input). In some embodiments, the second sub-reducer may also include a format detector to detect if the first input is denormal or normal, a normalizer to remove an implied bit of the first input and renormalize the low reduced significand portion to produce a normalized significand portion, based on determining the first input is normal, and an exponent adjuster to adjust the second increased exponent portion to produce an adjusted exponent portion based on renormalizing the significand portion. Further, the second reduced input may include the adjusted exponent portion and the normalized significand portion.</p><p id="p-0149" num="0148">In block <b>808</b>, the systolic array performs a plurality of multiply-accumulate operations on the first reduced input, the second reduced input, and a second input. The first input may be an input data element or a weight and the second input may be the other of the input data element or the weight. In some embodiments, the second input may not be reduced. In other embodiments, the systolic array may reduce the second input to generate a third reduced input and a fourth reduced input for the plurality of multiply-accumulate operations. To perform the plurality of multiply-accumulate operations, the systolic array may calculate a plurality of partial sums. Further, for each combination of high/low reduced inputs, the systolic array can calculate a partial sum. For example, the systolic array can include processing elements to conduct multiply-accumulate operations on the reduced inputs. The processing elements may each include a multiplier to multiply two 21-bit floating-point numbers and an adder to add two floating-point numbers. Further, the multiplier may include a 1-bit sign data path, an 11-bit significand data path, and a 9-bit exponent data path and the adder may include a 1-bit sign data path, a 23-bit significand data path, and a 10-bit exponent data path. Further, the reducer may produce the reduced inputs and select the reduced inputs to be provided for processing by the processing element. The plurality of operations may be a plurality of ordered multiply-accumulate operations (e.g., a plurality of multiply operations and a plurality of accumulate operations for the first input). The processing element may include a multiplier to multiply at least two n-bit number and an adder to add two p-bit numbers, where p may be any number greater than n. For example, the multiplier be a 21-bit multiplier to multiply two 21-bit numbers and the adder may be a 34-bit adder. Further, to perform the operations, the processing element can multiply the second reduced input and a second reduced weight to generate a first product, multiply the first reduced input and the second reduced weight to generate a second product, multiply the second reduced input and the first reduced weight to generate a third product, multiply the second reduced input and the first reduced weight to generate a fourth product, add the first product to an input partial sum to generate a first sum, add the first sum to the second product to generate a second sum, add the second sum and the third product to generate a third sum, and add the third sum and the fourth product to generate a total product or output.</p><p id="p-0150" num="0149">The systolic array may generate a full precision total output from the plurality of partial sums for the first input and the second input (e.g., the input data element and the weight) based on the reduced inputs. In some embodiments, to generate the total output, the systolic array may provide each sub-product to an adder (e.g., an accumulator). The adder can perform chunk-based accumulation on the output of the systolic array (e.g., each of the sub-products).</p><p id="p-0151" num="0150">To better illustrate operation of a systolic array utilizing multiple combinations of reduced inputs, <figref idref="DRAWINGS">FIG. <b>9</b>A-<b>9</b>H</figref> illustrates an example four PE column <b>900</b> of a systolic array for neural network computations processing multiply-accumulate operations over systolic intervals 0 through 9 according to certain examples of the disclosed technologies. The PE column <b>900</b> may be part of a systolic array similar to the systolic array <b>100</b>A in <figref idref="DRAWINGS">FIG. <b>1</b>A</figref>, which may extend for any plurality of rows and plurality of columns. In some embodiments, the systolic array may include a full multiply-accumulate operation for each combination of reduced inputs (e.g., low input/weight and high input/weight) and the output of each operation may be summed.</p><p id="p-0152" num="0151">The PE column <b>900</b> includes four PEs labeled as PE00, PE10, PE20, and PE30 according to their row and column (RC) number. In the example of <figref idref="DRAWINGS">FIGS. <b>9</b>A-<b>9</b>J</figref>, the column <b>900</b> is implementing two-pass multiply-accumulate operations. For example, an input data element may be converted into two reduced input data elements for multiply-accumulate operations. The weight may be preloaded into the array and the weight may be used in multiply-accumulate operations for each reduced input to generate an output. In some embodiments, the weight may also be converted into two (or any number of) reduced weights). A first reduced weight (e.g., the low reduced weight) from the weight may be preloaded for multiply-accumulate operations with reduced input data elements and, subsequently, a second reduced weight (e.g., the high reduced weight) from the weight may be loaded for multiply-accumulate operations with the same reduced input data elements. The output for each combination of a reduced input and a reduced weight may be summed to generate a total output. It will be understood that the column <b>900</b> may implement n-pass multiply accumulate operations where n can be any number. For example, the weight can be converted into any number of reduced weights and each weight may iteratively loaded into the systolic array for multiply-accumulate operations with a set of reduced input data elements.</p><p id="p-0153" num="0152">Each PE illustratively includes a multiplier with a single systolic interval latency (e.g., inputs provided at interval n are provided as outputs at interval n+1) and an adder with a two-interval latency (e.g., inputs provided at interval n are provided as outputs at interval n+2). Adders with other latencies may be implemented. As shown in <figref idref="DRAWINGS">FIGS. <b>9</b>A-<b>9</b>H</figref>, each PE of the PE column <b>900</b> respectively includes a data register Data RegRC for receiving an input data element, a weight storing register Weight RegRC, a multiplier represented by an &#x201c;X&#x201d;, and an adder or accumulator represented by a &#x201c;+&#x201d;.</p><p id="p-0154" num="0153">Values provided as input partial sums at systolic intervals 0-9 are shown along the top, with PE00 receiving values A1. (While value A1 is shown for illustrative purposes, in some instances all partial input sums fed to a top row of an array may be set to the same value, which may be zero). Values provided as input data elements at systolic intervals 0-9 are shown along the left column, with PE00 in row 0 receiving values C1 and C2 at the illustrated times, PE10 in row 1 receiving values D1 and D2 at the illustrated times, PE20 in row 2 receiving values E1 and E2 at the illustrated times, and PE30 in row 3 receiving values F1 and F2 at the illustrated times. C1, D1, E1, and F1 may each be a first reduced input data element (e.g., a low reduced input data element) and C2, D2, E2, and F2 may each be a second reduced input data element (e.g., a high reduced input data element). G1, H1, I1, and J1 may be the weight. In some embodiments, the weights may be each converted into a first reduced weight (e.g., a low reduced weight) and a second reduced weight (e.g., a high reduced weight). When no value is illustrated, a zero or NOP can be assumed. Where indicated, the system is initialized with zero values for clarity and to facilitate understanding. However, other examples can occur at different states and/or with other internal values.</p><p id="p-0155" num="0154"><figref idref="DRAWINGS">FIG. <b>9</b>A-<b>9</b>H</figref> show the progression of data as multiply-accumulate operations are performed. The multiply-accumulate operations across the shown intervals include (as discussed in more detail below): multiplying weight G1 by input data element C1 and accumulating input partial sum A1; multiplying weight G1 by input data element C2; multiplying weight H1 by input data element D1 and accumulating input partial sum X1 from PE00; multiplying weight H1 by input data element D2 and accumulating input partial sum X2 from PE00; multiplying weight I1 by input data element E1 and accumulating input partial sum Y1 from PE10; multiplying weight I1 by input data element E2 and accumulating input partial sum Y2 from PE10; multiplying weight J1 by input data element F1 and accumulating input partial sum Z1 from PE20; and multiplying weight J1 by input data element F2 and accumulating input partial sum Z2 from PE20. The technology disclosed herein can extend to additional sequences of input data elements and input partial sums.</p><p id="p-0156" num="0155"><figref idref="DRAWINGS">FIG. <b>9</b>A</figref> shows the state of the PE column <b>900</b> at systolic interval 0. The weights G1, H1, I1, and J1 are each pre-loaded into respective weight registers. For example, the weights G1, H1, I1, and J1 may be pre-loaded in a weight load operation. In PE00, an input data element C1 is received for writing to and storing in Data Reg00 for use during the next systolic interval. All other inputs and other states are initialized to zero.</p><p id="p-0157" num="0156"><figref idref="DRAWINGS">FIG. <b>9</b>B</figref> shows the state of the PE column <b>900</b> at systolic interval 1. In PE00, an input data element C2 is received for writing to and storing in Data Reg00 for use during the next systolic interval. In some embodiments, the weight G1 may be preloaded into Weight Reg00 for multiply systolic intervals and may not be preloaded again. For example, the weight G1 may be preloaded for a plurality of multiply-accumulate operations with a plurality of reduced input data elements. The weight G1 may subsequently be replaced with a new weight, G2, for multiply-accumulate operations with the reduced inputs. For example, G1 and G2 may be reduced weights generated from a weight. Therefore, the weight G1 may only be preloaded into the array once. It will be understood that the combination of inputs or weights may be ordered such that any of the reduced inputs or weights may be stored in respective data registers for multiple systolic intervals and may not be reread into the PE. For example, the combinations of reduced inputs or weights may be ordered or distributed such that the weight G1 is not reread into the PE. The stored input data element C1 is read from Data Reg00 and provided as an input to both the multiplier of PE00 and a data register of a PE in a subsequent column. The multiplier in PE00 multiplies C1 by G1 to generate a multiplication result C1&#xd7;G1, which is provided to an adder for PE00. The input partial sum A1 is also received at the adder for PE00. Each adder is pipelined with a latency of 2 intervals, and as such processes the respective input partial sum and the respective multiplication result during a time period corresponding to the latency (e.g., the subsequent 2 intervals).</p><p id="p-0158" num="0157">In PE10, an input data element D1 is received for writing to and storing in Data Reg10 for use during the next systolic interval.</p><p id="p-0159" num="0158"><figref idref="DRAWINGS">FIG. <b>9</b>C</figref> shows the state of the PE column <b>900</b> at systolic interval 2. In PE00, the input data element C2 is read from Data Reg00 and provided as an input to both the multiplier of PE00 and a data register of a PE in a subsequent column. The multiplier in PE00 multiplies C2 by G1 to generate a multiplication result C2&#xd7;G1, which is provided to the adder for PE00 for use in an adder operation. Note that during systolic interval 2, the adder of PE00 continues to conduct an add operation between the multiplication result C1&#xd7;G1 and the input partial sum A1, as obtained during interval 1.</p><p id="p-0160" num="0159">In PE10, an input data element D2 is received for writing to and storing in Data Reg10 for use during the next systolic interval. The stored input data element D1 is read from Data Reg10 and provided as an input to both the multiplier of PE10 and a data register of a PE in a subsequent column. The multiplier in PE10 multiplies D1 by H1 to generate a multiplication result D1&#xd7;H1, which is provided to an adder for PE10.</p><p id="p-0161" num="0160">In PE20, an input data element E1 is received for writing to and storing in Data Reg20 for use during the next systolic interval.</p><p id="p-0162" num="0161"><figref idref="DRAWINGS">FIG. <b>9</b>D</figref> shows the state of the PE column <b>900</b> at systolic interval 3. In PE00, the adder completes the addition of A1 and C1&#xd7;G1 and generates an addition result, A1+C1&#xd7;G1. The addition result, A1+C1&#xd7;G1, is communicated to PE10 as an input partial sum. The additional result of a PE within a given column can generally be referred to herein as a &#x201c;partial sum.&#x201d; Note that during systolic interval 3, the adder of PE00 continues to conduct an add operation between the multiplication result C2&#xd7;G1, as obtained during interval 2.</p><p id="p-0163" num="0162">In PE10, the stored input data element D2 is read from Data Reg10 and provided as an input to both the multiplier of PE10 and a data register of a PE in a subsequent column. The multiplier in PE10 multiplies D2 by H1 to generate a multiplication result D2&#xd7;H1, which is provided to an adder for PE10. The input partial sum, C1&#xd7;G1+A1, is received from PE00 and is also provided to the adder for PE10 for use in the adder operation. Note that during systolic interval 3, the adder of PE10 continues to conduct an add operation between the multiplication result D1&#xd7;H1 and the input partial sum from PE00 (A1+C1&#xd7;G1).</p><p id="p-0164" num="0163">In PE20, an input data element E2 is received for writing to and storing in Data Reg20 for use during the next systolic interval. The stored input data element E1 is read from Data Reg20 and provided as an input to both the multiplier of PE20 and a data register of a PE in a subsequent column. The multiplier in PE20 multiplies E1 by I1 to generate a multiplication result E1&#xd7;I1, which is provided to the adder for PE20 for use in an adder operation.</p><p id="p-0165" num="0164">In PE30, an input data element F1 is received for writing to and storing in Data Reg30 for use during the next systolic interval.</p><p id="p-0166" num="0165"><figref idref="DRAWINGS">FIG. <b>9</b>E</figref> shows the state of the PE column <b>900</b> at systolic interval 4. the adder completes the addition of 0 and C2&#xd7;G1 and generates an addition result, C2&#xd7;G1. In some embodiments, the input partial sum A1 may be added to each combination of the reduced inputs. For example, where each input is converted into two reduced inputs resulting in four combinations of reduced inputs for each weight and input data element (e.g., a four-pass multiply-accumulate operation for a pair of inputs), the input partial sum may be added to each combination of reduced inputs. In other embodiments, a portion of the input partial sum may be added to each combination of reduced inputs. For example, the input partial sum may be divided across each combination of reduced inputs. The addition result, C2&#xd7;G1, is communicated to PE10 as an input partial sum.</p><p id="p-0167" num="0166">In PE10, the input partial sum, C2&#xd7;G1, is received from PE00 and is also provided to the adder for PE10 for use in the adder operation. Note that during systolic interval 4, the adder of PE10 continues to conduct an add operation between the multiplication result D2&#xd7;H1 and the input partial sum from PE00 (C2&#xd7;G1).</p><p id="p-0168" num="0167">Further, in PE10, the adder completes the addition of D1&#xd7;H1+C1&#xd7;G1+A1 and generates an addition result, X1. The addition result, X1, is communicated to PE20 as an input partial sum.</p><p id="p-0169" num="0168">In PE20, the stored input data element E2 is read from Data Reg20 and provided as an input to both the multiplier of PE20 and a data register of a PE in a subsequent column. The multiplier in PE20 multiplies E2 by I1 to generate a multiplication result E2&#xd7;I1, which is provided to the adder for PE20 for use in an adder operation. The input partial sum, X1, is received from PE10 and is also provided to the adder for PE20 for use in the adder operation. Note that during systolic interval 4, the adder of PE20 continues to conduct an add operation between the multiplication result E1&#xd7;I1 and the input partial sum from PE10 (X1).</p><p id="p-0170" num="0169">In PE30, an input data element F2 is received for writing to and storing in Data Reg30 for use during the next systolic interval. The stored input data element F1 is read from Data Reg30 and provided as an input to both the multiplier of PE30 and a data register of a PE in a subsequent column. The multiplier in PE30 multiplies F1 by J1 to generate a multiplication result F1&#xd7;J1, which is provided to the adder for PE30 for use in an adder operation.</p><p id="p-0171" num="0170"><figref idref="DRAWINGS">FIG. <b>9</b>F</figref> shows the state of the PE column <b>900</b> at systolic interval 5. In PE10, the adder completes the addition of D2&#xd7;H1+C2&#xd7;G1 and generates an addition result, X2. The addition result, X2, is communicated to PE20 as an input partial sum.</p><p id="p-0172" num="0171">In PE20, the input partial sum, X2, is received from PE10 and is also provided to the adder for PE20 for use in the adder operation. Note that during systolic interval 5, the adder of PE20 continues to conduct an add operation between the multiplication result E2&#xd7;I1 and the input partial sum from PE10 (X2).</p><p id="p-0173" num="0172">Further, in PE20, the adder completes the addition of E1&#xd7;I1+X1 and generates an addition result, Y1. The addition result, Y1, is communicated to PE30 as an input partial sum.</p><p id="p-0174" num="0173">In PE30, the stored input data element F2 is read from Data Reg30 and provided as an input to both the multiplier of PE30 and a data register of a PE in a subsequent column. The multiplier in PE30 multiplies F2 by J1 to generate a multiplication result F2&#xd7;J1, which is provided to the adder for PE30 for use in an adder operation. Note that during systolic interval 5, the adder of PE30 continues to conduct an add operation between the multiplication result F1&#xd7;J1, as obtained during interval 4 and the input partial sum from PE20 (Y1).</p><p id="p-0175" num="0174"><figref idref="DRAWINGS">FIG. <b>9</b>G</figref> shows the state of the PE column <b>900</b> at systolic interval 6. In PE20, the adder completes the addition of E2&#xd7;I1+X2 and generates an addition result, Y2. The addition result, Y2, is communicated to PE30 as an input partial sum.</p><p id="p-0176" num="0175">In PE30, the adder of PE30 continues to conduct an add operation between the multiplication result F2&#xd7;J1, as obtained during interval 5 and the input partial sum from PE20 (Y2).</p><p id="p-0177" num="0176">Further, in PE30, the adder completes the addition of F1&#xd7;J1+Y1 and generates an addition result, Z <b>1</b>. The addition result, Z1, may be communicated to another PE and/or to an aggregator for aggregation with additional combinations of the reduced inputs for a particular set of inputs.</p><p id="p-0178" num="0177"><figref idref="DRAWINGS">FIG. <b>9</b>H</figref> shows the state of the PE column <b>900</b> at systolic interval 7. In PE30, the adder completes the addition of F2&#xd7;J1+Y2 and generates an addition result, Z2. The addition result, Z2, may be communicated to another PE and/or to an aggregator for aggregation with additional combinations of the reduced inputs for a particular set of inputs.</p><p id="p-0179" num="0178">The examples states of data flow illustrated in <figref idref="DRAWINGS">FIG. <b>9</b>A-<b>9</b>H</figref> can be performed for one or more starting input data elements and for any number of starting input partial sums.</p><p id="p-0180" num="0179"><figref idref="DRAWINGS">FIG. <b>10</b></figref> illustrates an example of a computing device <b>1000</b>. Functionality and/or several components of the computing device <b>1000</b> may be used without limitation with other embodiments disclosed elsewhere in this disclosure, without limitations. A computing device <b>1000</b> may perform computations to facilitate processing of a task. As an illustrative example, computing device <b>1000</b> can be part of a server in a multi-tenant compute service system. Various hardware and software resources of computing device <b>1000</b> (e.g., the hardware and software resources associated with data processing) can be allocated to a client upon request.</p><p id="p-0181" num="0180">In one example, the computing device <b>1000</b> may include processing logic <b>1002</b>, a bus interface module <b>1004</b>, memory <b>1006</b>, and a network interface module <b>1008</b>. These modules may be hardware modules, software modules, or a combination of hardware and software. In certain instances, modules may be interchangeably used with components or engines, without deviating from the scope of the disclosure. The computing device <b>1000</b> may include additional modules, which are not illustrated here for the ease of illustration. In some embodiments, the computing device <b>1000</b> may include fewer modules. For example, one or more of the modules may be combined into one module. One or more of the modules may be in communication with each other over a communication channel <b>1010</b>. The communication channel <b>1010</b> may include one or more busses, meshes, matrices, fabrics, a combination of these communication channels, or some other suitable communication channel.</p><p id="p-0182" num="0181">The processing logic <b>1002</b> may include application specific integrated circuits (ASICs), field programmable gate arrays (FPGAs), systems-on-chip (SoCs), and network processing units (NPUs), processors configured to execute instructions or any other circuitry to perform logical arithmetic and floating-point operations. Examples of processors that may be included in the processing logic <b>1002</b> may include processors developed by ARM&#xae;, MIPS&#xae;, AMD&#xae;, Qualcomm&#xae;, and the like. In some embodiments, the processors may include multiple processing cores and each processing core may execute instructions independently of the other processing cores. Further, each processor or processing core may implement multiple processing threads executing instructions on the same processor or processing core, while maintaining logical separation between the multiple processing threads. Such processing threads executing on the processor or processing core may be exposed to software as separate logical processors or processing cores. In some embodiments, multiple processors, processing cores or processing threads executing on the same core may share certain resources, such as for example busses, level 1 (L1) caches, and/or level 2 (L2) caches. The instructions executed by the processing logic <b>1002</b> may be stored on a computer-readable storage medium, for example, in the form of a computer program. The computer-readable storage medium may be non-transitory. In some cases, the computer-readable medium may be part of the memory <b>1006</b>. The processing logic <b>1002</b> may also include hardware circuities for performing artificial neural network computations including, for example, the neural network processor <b>602</b>, etc.</p><p id="p-0183" num="0182">The access to the processing logic <b>1002</b> can be granted to a client to provide the personal assistant service requested by the client. For example, the computing device <b>1000</b> may host a virtual machine, on which an image recognition software application can be executed. The image recognition software application, upon execution, may access the processing logic <b>1002</b> to predict, for example, an object included in an image. As another example, access to the processing logic <b>1002</b> can also be granted as part of bare-metal instance, in which an image recognition software application executing on a client device (e.g., a remote computer, a smart phone, etc.) can directly access the processing logic <b>1002</b> to perform the recognition of an image.</p><p id="p-0184" num="0183">The memory <b>1006</b> may include either volatile or non-volatile, or both volatile and non-volatile types of memory. The memory <b>1006</b> may, for example, include random access memory (RAM), read only memory (ROM), Electrically Erasable Programmable Read-Only Memory (EEPROM), flash memory, and/or some other suitable storage media. In some cases, some or all of the memory <b>1006</b> may be internal to the computing device <b>1000</b>, while in other cases some or all of the memory may be external to the computing device <b>1000</b>. The memory <b>1006</b> may store an operating system comprising executable instructions that, when executed by the processing logic <b>1002</b>, provides the execution environment for executing instructions providing functionality to perform convolution computations for the computing device <b>1000</b>. The memory <b>1006</b> may also store, for example, software applications for performing artificial neural network computations. The memory may also store and maintain several data structures and tables for facilitating the functionality of the computing device <b>1000</b>.</p><p id="p-0185" num="0184">The bus interface module <b>1004</b> may enable communication with external entities, such as a host device and/or other components in a computing system, over an external communication medium. The bus interface module <b>1004</b> may include a physical interface for connecting to a cable, socket, port, or other connection to the external communication medium. The bus interface module <b>1004</b> may further include hardware and/or software to manage incoming and outgoing transactions. The bus interface module <b>1004</b> may implement a local bus protocol, such as Peripheral Component Interconnect (PCI) based protocols, Non-Volatile Memory Express (NVMe), Advanced Host Controller Interface (AHCI), Small Computer System Interface (SCSI), Serial Attached SCSI (SAS), Serial AT Attachment (SATA), Parallel ATA (PATA), some other standard bus protocol, or a proprietary bus protocol. The bus interface module <b>1004</b> may include the physical layer for any of these bus protocols, including a connector, power management, and error handling, among other things. In some embodiments, the computing device <b>1000</b> may include multiple bus interface modules for communicating with multiple external entities. These multiple bus interface modules may implement the same local bus protocol, different local bus protocols, or a combination of the same and different bus protocols.</p><p id="p-0186" num="0185">The network interface module <b>1008</b> may include hardware and/or software for communicating with a network. This network interface module <b>1008</b> may, for example, include physical connectors or physical ports for wired connection to a network, and/or antennas for wireless communication to a network. The network interface module <b>1008</b> may further include hardware and/or software implementing a network protocol stack. The network interface module <b>1008</b> may communicate with the network using a network protocol, such as for example TCP/IP, Infiniband, RoCE, Institute of Electrical and Electronics Engineers (IEEE) 802.11 wireless protocols, User Datagram Protocol (UDP), Asynchronous Transfer Mode (ATM), token ring, frame relay, High Level Data Link Control (HDLC), Fiber Distributed Data Interface (FDDI), and/or Point-to-Point Protocol (PPP), among others. In some embodiments, the computing device <b>1000</b> may include multiple network interface modules, each configured to communicate with a different network. For example, the computing device <b>1000</b> may include a network interface module for communicating with a wired Ethernet network, a wireless 1002.11 network, a cellular network, an Infiniband network, etc. In some embodiments, the computing device <b>1000</b> may receive a set of parameters, such as the aforementioned weight values for convolution computations, from a server through network interface module <b>1008</b>.</p><p id="p-0187" num="0186">The various components and modules of the computing device <b>1000</b>, described above, may be implemented as discrete components, as a System on a Chip (SoC), as an ASIC, as an NPU, as an FPGA, or any combination thereof. In some embodiments, the SoC or other component may be communicatively coupled to another computing system to provide various services such as traffic monitoring, traffic shaping, computing, etc. In some embodiments of the technology, the SoC or other component may include multiple subsystems as disclosed herein.</p><p id="p-0188" num="0187">The modules described herein may be software modules, hardware modules or a suitable combination thereof. If the modules are software modules, the modules can be embodied on a non-transitory computer readable medium and processed by a processor in any of the computer systems described herein. It should be noted that the described processes and architectures can be performed either in real-time or in an asynchronous mode prior to any user interaction. The modules may be configured in the manner suggested in <figref idref="DRAWINGS">FIG. <b>10</b></figref>, and/or functions described herein can be provided by one or more modules that exist as separate modules and/or module functions described herein can be spread over multiple modules.</p><p id="p-0189" num="0188">The specification and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense. It will, however, be evident that various modifications and changes may be made thereunto without departing from the broader spirit and scope of the disclosure as set forth in the claims.</p><p id="p-0190" num="0189">Other variations are within the spirit of the present disclosure. Thus, while the disclosed techniques are susceptible to various modifications and alternative constructions, certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood, however, that there is no intention to limit the disclosure to the specific form or forms disclosed, but on the contrary, the intention is to cover all modifications, alternative constructions, and equivalents falling within the spirit and scope of the disclosure, as defined in the appended claims.</p><p id="p-0191" num="0190">The use of the terms &#x201c;a&#x201d; and &#x201c;an&#x201d; and &#x201c;the&#x201d; and similar referents in the context of describing the disclosed embodiments (especially in the context of the following claims) are to be construed to cover both the singular and the plural, unless otherwise indicated herein or clearly contradicted by context. The terms &#x201c;comprising,&#x201d; &#x201c;having,&#x201d; &#x201c;including,&#x201d; and &#x201c;containing&#x201d; are to be construed as open-ended terms (i.e., meaning &#x201c;including, but not limited to,&#x201d;) unless otherwise noted. The term &#x201c;connected&#x201d; is to be construed as partly or wholly contained within, attached to, or joined together, even if there is something intervening. Recitation of ranges of values herein are merely intended to serve as a shorthand method of referring individually to each separate value falling within the range, unless otherwise indicated herein and each separate value is incorporated into the specification as if it were individually recited herein. All methods described herein can be performed in any suitable order unless otherwise indicated herein or otherwise clearly contradicted by context. The use of any and all examples, or exemplary language (e.g., &#x201c;such as&#x201d;) provided herein, is intended merely to better illuminate embodiments of the disclosure and does not pose a limitation on the scope of the disclosure unless otherwise claimed. No language in the specification should be construed as indicating any non-claimed element as essential to the practice of the disclosure.</p><p id="p-0192" num="0191">Disjunctive language such as the phrase &#x201c;at least one of X, Y, or Z,&#x201d; unless specifically stated otherwise, is intended to be understood within the context as used in general to present that an item, term, etc., may be either X, Y, or Z, or any combination thereof (e.g., X, Y, and/or Z). Thus, such disjunctive language is not generally intended to, and should not, imply that certain embodiments require at least one of X, at least one of Y, or at least one of Z to each be present.</p><p id="p-0193" num="0192">Various embodiments of this disclosure are described herein, including the best mode known to the inventors for carrying out the disclosure. Variations of those embodiments may become apparent to those of ordinary skill in the art upon reading the foregoing description. The inventors expect skilled artisans to employ such variations as appropriate and the inventors intend for the disclosure to be practiced otherwise than as specifically described herein. Accordingly, this disclosure includes all modifications and equivalents of the subject matter recited in the claims appended hereto as permitted by applicable law. Moreover, any combination of the above-described elements in all possible variations thereof is encompassed by the disclosure unless otherwise indicated herein or otherwise clearly contradicted by context.</p><p id="p-0194" num="0193">Various example embodiments of the disclosure can be described by the following clauses:<ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0194">Clause 1: A systolic array processor organized in rows and columns, each row comprising:        <ul id="ul0003" list-style="none">            <li id="ul0003-0001" num="0195">a reducer, the reducer configured to convert 32-bit input data elements into reduced 22-bit input data elements, the reducer comprising:            <ul id="ul0004" list-style="none">                <li id="ul0004-0001" num="0196">a trailing bit reducer configured to reduce a quantity of bits representing a significand portion of a 32-bit input data element of the 32-bit input data elements to produce a reduced significand portion of the 32-bit input data element;</li>                <li id="ul0004-0002" num="0197">a rounder configured to round the reduced significand portion of the 32-bit input data element to produce a rounded significand portion; and</li>                <li id="ul0004-0003" num="0198">an exponent expander configured to increase a quantity of bits representing an exponent portion of the 32-bit input data element to produce an increased exponent portion,</li>                <li id="ul0004-0004" num="0199">wherein the reducer produces a reduced 22-bit input data element based on the rounded significand portion and the increased exponent portion; and</li>            </ul>            </li>            <li id="ul0003-0002" num="0200">a plurality of processing elements, the plurality of processing elements configured to receive the reduced 22-bit input data elements from the reducer and to receive weights for performing multiply-accumulate operations.</li>        </ul>        </li>        <li id="ul0002-0002" num="0201">Clause 2: The systolic array processor of Clause 1, wherein the reducer is further configured to convert 32-bit weights into the weights.</li>        <li id="ul0002-0003" num="0202">Clause 3: The systolic array processor of Clause 1, wherein the reducer further comprises a first reducer, each row further comprising:        <ul id="ul0005" list-style="none">            <li id="ul0005-0001" num="0203">a second reducer, the second reducer configured to convert 32-bit weights into the weights.</li>        </ul>        </li>        <li id="ul0002-0004" num="0204">Clause 4: The systolic array processor of Clause 1, wherein the rounder is configured to round the reduced significand portion of the 32-bit input data element based on one or more of:        <ul id="ul0006" list-style="none">            <li id="ul0006-0001" num="0205">stochastic rounding;</li>            <li id="ul0006-0002" num="0206">rounding to nearest even;</li>            <li id="ul0006-0003" num="0207">rounding to zero;</li>            <li id="ul0006-0004" num="0208">rounding down; or</li>            <li id="ul0006-0005" num="0209">rounding up.</li>        </ul>        </li>        <li id="ul0002-0005" num="0210">Clause 5: A systolic circuit comprising:        <ul id="ul0007" list-style="none">            <li id="ul0007-0001" num="0211">a group of processing elements arranged into a plurality of rows; and</li>            <li id="ul0007-0002" num="0212">a first convertor configured to:            <ul id="ul0008" list-style="none">                <li id="ul0008-0001" num="0213">receive a first input represented in floating-point with a first bit-length;</li>                <li id="ul0008-0002" num="0214">identify a quantity of trailing bits of the first input;</li>                <li id="ul0008-0003" num="0215">reducing the quantity of trailing bits of the first input; and</li>                <li id="ul0008-0004" num="0216">generate a first reduced input represented in floating-point with a second bit-length based on reducing the quantity of trailing bits of the first input, wherein the second bit-length is less than the first bit-length, wherein the second bit-length corresponds to a bit-length supported by the group of processing elements;</li>            </ul>            </li>            <li id="ul0007-0003" num="0217">wherein an individual processing element in at least one row of the group of processing elements is configured to receive the first reduced input from the first convertor and to receive a second input for performing multiply-accumulate operations.</li>        </ul>        </li>        <li id="ul0002-0006" num="0218">Clause 6: The systolic circuit of Clause 5, wherein individual processing elements in the plurality of rows of the group of processing elements comprise:        <ul id="ul0009" list-style="none">            <li id="ul0009-0001" num="0219">a multiplier configured to multiply two 22-bit floating-point numbers, wherein the multiplier is comprised of a 1-bit sign data path, a 11-bit significand data path, and a 10-bit exponent data path; and</li>            <li id="ul0009-0002" num="0220">an adder configured to add two floating-point numbers, wherein the adder is comprised of a 1-bit sign data path, a 23-bit significand data path, and a 10-bit exponent data path.</li>        </ul>        </li>        <li id="ul0002-0007" num="0221">Clause 7: The systolic circuit of Clause 5, wherein the first input comprises an input data element and the second input comprises a reduced weight, wherein the first convertor is further configured to:        <ul id="ul0010" list-style="none">            <li id="ul0010-0001" num="0222">receive the first input and a weight;</li>            <li id="ul0010-0002" num="0223">generate the first reduced input and the second input; and</li>            <li id="ul0010-0003" num="0224">select the first reduced input or the second input to be provided.</li>        </ul>        </li>        <li id="ul0002-0008" num="0225">Clause 8: The systolic circuit of Clause 5, wherein the first convertor comprises:        <ul id="ul0011" list-style="none">            <li id="ul0011-0001" num="0226">a trailing bit reducer configured to reduce a quantity of bits representing a significand portion of the first input to produce a reduced significand portion of the first input;</li>            <li id="ul0011-0002" num="0227">a rounder configured to round the reduced significand portion of the first input based on a remainder of the bits representing the significand portion of the first input not included within the reduced significand portion; and</li>            <li id="ul0011-0003" num="0228">an exponent expander configured to increase a quantity of bits representing an exponent portion of the first input.</li>        </ul>        </li>        <li id="ul0002-0009" num="0229">Clause 9: The systolic circuit of Clause 5, wherein the first input comprises a first rounded input, wherein the first convertor comprises:        <ul id="ul0012" list-style="none">            <li id="ul0012-0001" num="0230">a trailing bit reducer configured to reduce a quantity of bits representing a significand portion of the first input to produce a reduced significand portion of the first input; and</li>            <li id="ul0012-0002" num="0231">an exponent expander configured to increase a quantity of bits representing an exponent portion of the first input.</li>        </ul>        </li>        <li id="ul0002-0010" num="0232">Clause 10: The systolic circuit of Clause 5, wherein the first reduced input comprises a first reduced rounded input, wherein the first reduced rounded input is rounded based on one or more of:        <ul id="ul0013" list-style="none">            <li id="ul0013-0001" num="0233">stochastic rounding;</li>            <li id="ul0013-0002" num="0234">rounding to nearest even;</li>            <li id="ul0013-0003" num="0235">rounding to zero;</li>            <li id="ul0013-0004" num="0236">rounding down; or</li>            <li id="ul0013-0005" num="0237">rounding up.</li>        </ul>        </li>        <li id="ul0002-0011" num="0238">Clause 11: The systolic circuit of Clause 5, wherein the first reduced input comprises a first reduced rounded input, wherein the first reduced rounded input is rounded based on a user input.</li>        <li id="ul0002-0012" num="0239">Clause 12: The systolic circuit of Clause 5, wherein:        <ul id="ul0014" list-style="none">            <li id="ul0014-0001" num="0240">the first convertor is configured to convert 32-bit floating-point numbers to 22-bit floating-point numbers,</li>            <li id="ul0014-0002" num="0241">wherein each of the processing elements comprises:            <ul id="ul0015" list-style="none">                <li id="ul0015-0001" num="0242">a 22-bit multiplier; and</li>                <li id="ul0015-0002" num="0243">a 34-bit adder.</li>            </ul>            </li>        </ul>        </li>        <li id="ul0002-0013" num="0244">Clause 13: The systolic circuit of Clause 5, wherein:        <ul id="ul0016" list-style="none">            <li id="ul0016-0001" num="0245">the first convertor is further configured to convert m-bit floating-point numbers to n-bit floating-point numbers, wherein n and m can be any positive integer, wherein n is less than m,</li>            <li id="ul0016-0002" num="0246">wherein each of the processing elements comprises:            <ul id="ul0017" list-style="none">                <li id="ul0017-0001" num="0247">a multiplier configured to multiply at least two n-bit numbers; and</li>                <li id="ul0017-0002" num="0248">an adder configured to add two p-bit numbers, wherein p is greater than n.</li>            </ul>            </li>        </ul>        </li>        <li id="ul0002-0014" num="0249">Clause 14: The systolic circuit of Clause 5, wherein to reduce the quantity of trailing bits of the first input, the first convertor is configured to:        <ul id="ul0018" list-style="none">            <li id="ul0018-0001" num="0250">set the quantity of trailing bits to zero.</li>        </ul>        </li>        <li id="ul0002-0015" num="0251">Clause 15: The systolic circuit of Clause 5, further comprising:        <ul id="ul0019" list-style="none">            <li id="ul0019-0001" num="0252">a second convertor configured to:            <ul id="ul0020" list-style="none">                <li id="ul0020-0001" num="0253">receive a weight represented in floating-point with the first bit-length;</li>                <li id="ul0020-0002" num="0254">identify a quantity of trailing bits of the weight;</li>                <li id="ul0020-0003" num="0255">reduce the quantity of trailing bits of the weight; and</li>                <li id="ul0020-0004" num="0256">generate the second input represented in floating-point with the second bit-length based on reducing the quantity of trailing bits of the weight.</li>            </ul>            </li>        </ul>        </li>        <li id="ul0002-0016" num="0257">Clause 16: The systolic circuit of Clause 5, wherein the first reduced input is stored in a 24-bit format.</li>        <li id="ul0002-0017" num="0258">Clause 17: A method, comprising:        <ul id="ul0021" list-style="none">            <li id="ul0021-0001" num="0259">receiving a first input represented in floating-point with a first bit-length;</li>            <li id="ul0021-0002" num="0260">reducing a quantity of trailing bits of the first input;</li>            <li id="ul0021-0003" num="0261">generating a first reduced input represented in floating-point with a second bit-length based on reducing the quantity of trailing bits of the first input, wherein the second bit-length is less than the first bit-length, wherein the second bit-length corresponds to a supported bit-length; and</li>            <li id="ul0021-0004" num="0262">receiving the first reduced input and a second input for performing multiply-accumulate operations.</li>        </ul>        </li>        <li id="ul0002-0018" num="0263">Clause 18: The method of Clause 17, wherein:        <ul id="ul0022" list-style="none">            <li id="ul0022-0001" num="0264">the first input comprises a 32-bit floating-point number;</li>            <li id="ul0022-0002" num="0265">the first reduced input comprises a first 22-bit floating-point number; and</li>            <li id="ul0022-0003" num="0266">the second input comprises a second 22-bit floating-point number.</li>        </ul>        </li>        <li id="ul0002-0019" num="0267">Clause 19: The method of Clause 17, wherein generating the first reduced input comprises:        <ul id="ul0023" list-style="none">            <li id="ul0023-0001" num="0268">rounding the first input to generate the first reduced input, based on a remainder of non-trailing bits of the first input, wherein the first input comprises a quantity of bits, wherein rounding the first input comprises rounding a portion of the quantity of bits.</li>        </ul>        </li>        <li id="ul0002-0020" num="0269">Clause 20: The method of Clause 17, wherein one or more of the first reduced input or the second input comprises a rounded, reduced input, wherein the rounded, reduced input is rounded based on one or more of:        <ul id="ul0024" list-style="none">            <li id="ul0024-0001" num="0270">stochastic rounding;</li>            <li id="ul0024-0002" num="0271">rounding to nearest even;</li>            <li id="ul0024-0003" num="0272">rounding to zero;</li>            <li id="ul0024-0004" num="0273">rounding down; or</li>            <li id="ul0024-0005" num="0274">rounding up.</li>        </ul>        </li>    </ul>    </li></ul></p><p id="p-0195" num="0275">Various example embodiments of the disclosure can be described by the following clauses:<ul id="ul0025" list-style="none">    <li id="ul0025-0001" num="0000">    <ul id="ul0026" list-style="none">        <li id="ul0026-0001" num="0276">Clause 1: A systolic array processor organized in rows and columns, each row comprising:        <ul id="ul0027" list-style="none">            <li id="ul0027-0001" num="0277">a reducer configured to convert 32-bit input data elements into two 21-bit input data elements, the reducer comprising:            <ul id="ul0028" list-style="none">                <li id="ul0028-0001" num="0278">a first sub-reducer configured to convert a 32-bit input data element of the 32-bit input data elements into a first 21-bit input data element, the first 21-bit input data element corresponding to a set of most significant bits of a significand portion of the 32-bit input data element, the first sub-reducer comprising:                <ul id="ul0029" list-style="none">                    <li id="ul0029-0001" num="0279">a trailing bit reducer configured to reduce a quantity of trailing bits representing the significand portion of the 32-bit input data element to produce a first reduced significand portion of the 32-bit input data element, the first reduced significand portion corresponding to the set of most significant bits; and</li>                    <li id="ul0029-0002" num="0280">a first exponent expander configured to increase a quantity of bits representing an exponent portion of the 32-bit input data element to produce a first increased exponent portion,</li>                    <li id="ul0029-0003" num="0281">wherein the first sub-reducer produces the first 21-bit input data element based on the first reduced significand portion and the first increased exponent portion; and</li>                </ul>                </li>                <li id="ul0028-0002" num="0282">a second sub-reducer configured to convert the 32-bit input data element into a second 21-bit input data element, the second 21-bit input data element corresponding to a set of least significant bits of the significand portion of the 32-bit input data element, the second sub-reducer comprising:                <ul id="ul0030" list-style="none">                    <li id="ul0030-0001" num="0283">a leading bit reducer configured to reduce a quantity of leading bits representing the significand portion of the 32-bit input data element to produce a second reduced significand portion of the 32-bit input data element, the second reduced significand portion corresponding to the set of least significant bits; and</li>                    <li id="ul0030-0002" num="0284">a second exponent expander configured to increase a quantity of bits representing the exponent portion of the 32-bit input data element to produce a second increased exponent portion,</li>                    <li id="ul0030-0003" num="0285">wherein the second sub-reducer produces a second 21-bit input data element based on the second reduced significand portion and the second increased exponent portion; and</li>                </ul>                </li>            </ul>            </li>            <li id="ul0027-0002" num="0286">a plurality of processing elements, a processing element of the plurality of processing elements configured to iteratively perform a plurality of pairwise multiply-accumulate operations on the first 21-bit input data element, the second 21-bit input data element, and a weight to provide a total output, wherein a 21 bit-length corresponds to a maximum supported bit-length for the processing element.</li>        </ul>        </li>        <li id="ul0026-0002" num="0287">Clause 2: The systolic array processor of Clause 1, wherein the first 21-bit input data element and the second 21-bit input data element sum to the 32-bit input data element.</li>        <li id="ul0026-0003" num="0288">Clause 3: The systolic array processor of Clause 1, wherein the second sub-reducer is further configured to determine the 32-bit input data element comprises a normal number, the second sub-reducer further comprising:        <ul id="ul0031" list-style="none">            <li id="ul0031-0001" num="0289">a normalizer to remove an implied bit of the 32-bit input data element and renormalize the second reduced significand portion to produce a normalized significand portion based on determining the 32-bit input data element comprises a normal number; and</li>            <li id="ul0031-0002" num="0290">an exponent adjuster to adjust the second increased exponent portion to produce an adjusted exponent portion based on renormalizing the second reduced significand portion,</li>            <li id="ul0031-0003" num="0291">wherein the second 21-bit input data element is further based on the normalized significand portion and the adjusted exponent portion.</li>        </ul>        </li>        <li id="ul0026-0004" num="0292">Clause 4: The systolic array processor of Clause 1, the weight comprising a first reduced weight and a second reduced weight, wherein the processing element is further configured to:        <ul id="ul0032" list-style="none">            <li id="ul0032-0001" num="0293">multiply the second 21-bit input data element and the second reduced weight to generate a first product;</li>            <li id="ul0032-0002" num="0294">multiply the first 21-bit input data element and the second reduced weight to generate a second product;</li>            <li id="ul0032-0003" num="0295">multiply the second 21-bit input data element and the first reduced weight to generate a third product; and</li>            <li id="ul0032-0004" num="0296">multiply the first 21-bit input data element and the first reduced weight to generate a fourth product,</li>        </ul>        </li>        <li id="ul0026-0005" num="0297">wherein the systolic array processor further comprises a partial sum buffer configured        <ul id="ul0033" list-style="none">            <li id="ul0033-0001" num="0298">add the first product, the second product, the third product, the fourth product, and an input partial sum to generate the total output.</li>        </ul>        </li>        <li id="ul0026-0006" num="0299">Clause 5: A systolic circuit comprising:        <ul id="ul0034" list-style="none">            <li id="ul0034-0001" num="0300">a group of processing elements arranged into a plurality of rows; and</li>            <li id="ul0034-0002" num="0301">a first convertor configured to:            <ul id="ul0035" list-style="none">                <li id="ul0035-0001" num="0302">receive a first input represented in floating-point with a first bit-length;</li>                <li id="ul0035-0002" num="0303">generate a first reduced input represented in floating-point with a second bit-length, the first reduced input corresponding to a set of most significant bits of a significand portion of the first input; and</li>                <li id="ul0035-0003" num="0304">generate a second reduced input represented in floating-point with a third bit-length, the second reduced input corresponding to a set of least significant bits of the significand portion of the first input, wherein the first reduced input and the second reduced input sum to the first input, wherein the second bit-length and the third bit-length are less than the first bit-length, wherein the second bit-length and the third bit-length correspond to a bit-length supported by the group of processing elements, wherein an individual processing element in at least one row of the group of processing elements is configured to receive the first reduced input and the second reduced input and perform a plurality of multiply-accumulate operations on the first reduced input, the second reduced input, and a second input.</li>            </ul>            </li>        </ul>        </li>        <li id="ul0026-0007" num="0305">Clause 6: The systolic circuit of Clause 5, wherein individual processing elements in the plurality of rows of the group of processing elements comprise:        <ul id="ul0036" list-style="none">            <li id="ul0036-0001" num="0306">a multiplier configured to multiply two 21-bit floating-point numbers, wherein the multiplier is comprised of a 1-bit sign data path, a 11-bit significand data path, and a 9-bit exponent data path; and</li>            <li id="ul0036-0002" num="0307">an adder configured to add two floating-point numbers, wherein the adder is comprised of a 1-bit sign data path, a 23-bit significand data path, and a 10-bit exponent data path.</li>        </ul>        </li>        <li id="ul0026-0008" num="0308">Clause 7: The systolic circuit of Clause 5, wherein the first input corresponds to an input data element and the second input corresponds to a weight, wherein the first convertor is further configured to:        <ul id="ul0037" list-style="none">            <li id="ul0037-0001" num="0309">receive the second input represented in floating-point with a fourth bit-length;</li>            <li id="ul0037-0002" num="0310">generate a third reduced input represented in floating-point with a fifth bit-length, the third reduced input corresponding to a set of most significant bits of a significand portion of the second input;</li>            <li id="ul0037-0003" num="0311">generate a fourth reduced input represented in floating-point with a sixth bit-length, the fourth reduced input corresponding to a set of least significant bits of the significand portion of the second input, wherein the third reduced input and the fourth reduced input sum to the second input, wherein the fifth bit-length and the sixth bit-length are less than the fourth bit-length, wherein the fifth bit-length and the sixth bit-length correspond to the bit-length supported by the group of processing elements; and</li>            <li id="ul0037-0004" num="0312">select the first reduced input, the second reduced input, the third reduced input, or the fourth reduced input to be provided.</li>        </ul>        </li>        <li id="ul0026-0009" num="0313">Clause 8: The systolic circuit of Clause 5, wherein the first convertor comprises:        <ul id="ul0038" list-style="none">            <li id="ul0038-0001" num="0314">a first sub-reducer comprising:            <ul id="ul0039" list-style="none">                <li id="ul0039-0001" num="0315">a trailing bit reducer configured to reduce a quantity of the set of least significant bits of the significand portion of the first input to produce a first reduced significand portion of the first input; and</li>                <li id="ul0039-0002" num="0316">a first exponent expander configured to increase a quantity of bits representing an exponent portion of the first input to produce a first increased exponent portion,</li>                <li id="ul0039-0003" num="0317">wherein the first sub-reducer produces the first reduced input based on the first reduced significand portion and the first increased exponent portion; and</li>            </ul>            </li>            <li id="ul0038-0002" num="0318">a second sub-reducer comprising:            <ul id="ul0040" list-style="none">                <li id="ul0040-0001" num="0319">a leading bit reducer configured to reduce a quantity of the set of most significant bits of the significand portion of the first input to produce a second reduced significand portion of the first input; and</li>                <li id="ul0040-0002" num="0320">a second exponent expander configured to increase a quantity of bits representing the exponent portion of the first input to produce a second increased exponent portion,</li>                <li id="ul0040-0003" num="0321">wherein the second sub-reducer produces the second reduced input based on the second reduced significand portion and the second increased exponent portion.</li>            </ul>            </li>        </ul>        </li>        <li id="ul0026-0010" num="0322">Clause 9: The systolic circuit of Clause 8, wherein the second sub-reducer is configured to determine the first input comprises a normal number, the second sub-reducer further comprising:        <ul id="ul0041" list-style="none">            <li id="ul0041-0001" num="0323">a normalizer to remove an implied bit of the first input and renormalize the second reduced significand portion to produce a normalized significand portion based on determining the first input comprises a normal number; and</li>            <li id="ul0041-0002" num="0324">an exponent adjuster to adjust the second increased exponent portion to produce an adjusted exponent portion based on renormalizing the second reduced significand portion,</li>            <li id="ul0041-0003" num="0325">wherein the second reduced input is further based on the normalized significand portion and the adjusted exponent portion.</li>        </ul>        </li>        <li id="ul0026-0011" num="0326">Clause 10: The systolic circuit of Clause 5, wherein the second input corresponds to a first reduced weight and a second reduced weight, wherein to perform the plurality of multiply-accumulate operations, the individual processing element is configured to:        <ul id="ul0042" list-style="none">            <li id="ul0042-0001" num="0327">multiply the second reduced input and the second reduced weight to generate a first product;</li>            <li id="ul0042-0002" num="0328">add the first product to an input partial sum to generate a first sum;</li>            <li id="ul0042-0003" num="0329">multiply the first reduced input and the second reduced weight to generate a second product;</li>            <li id="ul0042-0004" num="0330">multiply the second reduced input and the first reduced weight to generate a third product; and</li>            <li id="ul0042-0005" num="0331">multiply the first reduced input and the first reduced weight to generate a fourth product,</li>        </ul>        </li>        <li id="ul0026-0012" num="0332">wherein the systolic circuit further comprises a partial sum buffer configured to:        <ul id="ul0043" list-style="none">            <li id="ul0043-0001" num="0333">add the first sum to the second product to generate a second sum;</li>            <li id="ul0043-0002" num="0334">add the second sum and the third product to generate a third sum; and</li>            <li id="ul0043-0003" num="0335">add the third sum and the fourth product to generate a total output.</li>        </ul>        </li>        <li id="ul0026-0013" num="0336">Clause 11: The systolic circuit of Clause 5, wherein the plurality of multiply-accumulate operations comprise an ordered plurality of multiply-accumulate operations.</li>        <li id="ul0026-0014" num="0337">Clause 12: The systolic circuit of Clause 5, wherein:        <ul id="ul0044" list-style="none">            <li id="ul0044-0001" num="0338">the first convertor is configured to convert 32-bit floating-point numbers to a plurality of 22-bit floating-point numbers,</li>            <li id="ul0044-0002" num="0339">wherein each of the processing elements comprises:            <ul id="ul0045" list-style="none">                <li id="ul0045-0001" num="0340">a 22-bit multiplier; and</li>                <li id="ul0045-0002" num="0341">a 34-bit adder.</li>            </ul>            </li>        </ul>        </li>        <li id="ul0026-0015" num="0342">Clause 13: The systolic circuit of Clause 5, wherein:        <ul id="ul0046" list-style="none">            <li id="ul0046-0001" num="0343">the first convertor is further configured to convert m-bit floating-point numbers to one or more n-bit floating-point numbers, wherein n and m can be any number, wherein n is less than m,</li>            <li id="ul0046-0002" num="0344">wherein each of the processing elements comprises:            <ul id="ul0047" list-style="none">                <li id="ul0047-0001" num="0345">a multiplier configured to multiply at least two n-bit numbers; and</li>                <li id="ul0047-0002" num="0346">an adder configured to add two p-bit numbers, wherein p is greater than n.</li>            </ul>            </li>        </ul>        </li>        <li id="ul0026-0016" num="0347">Clause 14: The systolic circuit of Clause 5, the systolic circuit further comprising:        <ul id="ul0048" list-style="none">            <li id="ul0048-0001" num="0348">a partial sum buffer configured to perform chunk-based accumulation based on a plurality of outputs of the group of processing elements.</li>        </ul>        </li>        <li id="ul0026-0017" num="0349">Clause 15: The systolic circuit of Clause 5, further comprising:        <ul id="ul0049" list-style="none">            <li id="ul0049-0001" num="0350">a second convertor configured to:            <ul id="ul0050" list-style="none">                <li id="ul0050-0001" num="0351">receive the second input represented in floating-point with a fourth bit-length, the second input corresponding to a weight;</li>                <li id="ul0050-0002" num="0352">generate a third reduced input represented in floating-point with a fifth bit-length, the third reduced input corresponding to a set of most significant bits of a significand portion of the second input; and</li>                <li id="ul0050-0003" num="0353">generate a fourth reduced input represented in floating-point with a sixth bit-length, the fourth reduced input corresponding to a set of least significant bits of the significand portion of the second input, wherein the third reduced input and the fourth reduced input sum to the second input, wherein the fifth bit-length and the sixth bit-length are less than the fourth bit-length, wherein the fifth bit-length and the sixth bit-length correspond to the bit-length supported by the group of processing elements,</li>            </ul>            </li>            <li id="ul0049-0002" num="0354">wherein the individual processing element in the at least one row of the group of processing elements is further configured to receive the third reduced input and the fourth reduced input and perform the plurality of multiply-accumulate operations on the first reduced input, the second reduced input, the third reduced input, and the fourth reduced input.</li>        </ul>        </li>        <li id="ul0026-0018" num="0355">Clause 16: The systolic circuit of Clause 5, wherein the group of processing elements perform a first accumulation on a plurality of outputs of the group of processing elements to produce a reduced plurality of outputs, the systolic circuit further comprising:        <ul id="ul0051" list-style="none">            <li id="ul0051-0001" num="0356">a partial sum buffer configured to perform chunk-based accumulation based on the reduced plurality of outputs to generate an output.</li>        </ul>        </li>        <li id="ul0026-0019" num="0357">Clause 17: A method, comprising:        <ul id="ul0052" list-style="none">            <li id="ul0052-0001" num="0358">receiving a first input represented in floating-point;</li>            <li id="ul0052-0002" num="0359">generating a first reduced input represented in floating-point, the first reduced input corresponding to a set of most significant bits of a significand portion of the first input;</li>            <li id="ul0052-0003" num="0360">generating a second reduced input represented in floating-point, the second reduced input corresponding to a set of least significant bits of the significand portion of the first input, wherein the first reduced input and the second reduced input sum to the first input, wherein the first reduced input and the second reduced input correspond to a supported bit-length; and</li>            <li id="ul0052-0004" num="0361">performing one or more operations based on the first reduced input, the second reduced input, and a second input to generate an output.</li>        </ul>        </li>        <li id="ul0026-0020" num="0362">Clause 18: The method of Clause 17, wherein:        <ul id="ul0053" list-style="none">            <li id="ul0053-0001" num="0363">the first input comprises a 32-bit floating-point number;</li>            <li id="ul0053-0002" num="0364">the first reduced input comprises a first 22-bit floating-point number; and</li>            <li id="ul0053-0003" num="0365">the second reduced input comprises a second 22-bit floating-point number.</li>        </ul>        </li>        <li id="ul0026-0021" num="0366">Clause 19: The method of Clause 17, further comprising:        <ul id="ul0054" list-style="none">            <li id="ul0054-0001" num="0367">receiving the second input represented in floating-point;</li>            <li id="ul0054-0002" num="0368">generating a third reduced input represented in floating-point, the third reduced input corresponding to a set of most significant bits of a significand portion of the second input; and</li>            <li id="ul0054-0003" num="0369">generating a fourth reduced input represented in floating-point, the fourth reduced input corresponding to a set of least significant bits of the significand portion of the second input, wherein the third reduced input and the fourth reduced input sum to the second input,</li>            <li id="ul0054-0004" num="0370">wherein the one or more operations are further based on the third reduced input and the fourth reduced input.</li>        </ul>        </li>        <li id="ul0026-0022" num="0371">Clause 20: The method of Clause 17, wherein each of the first input and the second input comprises an input data element or a weight.</li>    </ul>    </li></ul></p><p id="p-0196" num="0372">The processes described herein or illustrated in the figures of the present disclosure may begin in response to an event, such as on a predetermined or dynamically determined schedule, on demand when initiated by a user or system administrator, or in response to some other event. When such processes are initiated, a set of executable program instructions stored on one or more non-transitory computer-readable media (e.g., hard drive, flash memory, removable media, etc.) may be loaded into memory (e.g., RAM) of a server or other computing device. The executable instructions may then be executed by a hardware-based computer processor of the computing device. In some embodiments, such processes or portions thereof may be implemented on multiple computing devices and/or multiple processors, serially or in parallel.</p><p id="p-0197" num="0373">Depending on the embodiment, certain acts, events, or functions of any of the processes or algorithms described herein can be performed in a different sequence, can be added, merged, or left out altogether (e.g., not all described operations or events are necessary for the practice of the algorithm). Moreover, in certain embodiments, operations or events can be performed concurrently, e.g., through multi-threaded processing, interrupt processing, or multiple processors or processor cores or on other parallel architectures, rather than sequentially.</p><p id="p-0198" num="0374">The various illustrative logical blocks, modules, routines, and algorithm steps described in connection with the embodiments disclosed herein can be implemented as electronic hardware (e.g., ASICs or FPGA devices), computer software that runs on computer hardware, or combinations of both. A processor device can be a microprocessor, but in the alternative, the processor device can be a controller, microcontroller, or state machine, combinations of the same, or the like. A processor device can include electrical circuitry to process computer-executable instructions. In another embodiment, a processor device includes an FPGA or other programmable device that performs logic operations without processing computer-executable instructions. A processor device can also be implemented as a combination of computing devices, e.g., a combination of a DSP and a microprocessor, a plurality of microprocessors, one or more microprocessors in conjunction with a DSP core, or any other such configuration. Although described herein primarily with respect to digital technology, a processor device may also include primarily analog components. For example, some or all of the rendering techniques described herein may be implemented in analog circuitry or mixed analog and digital circuitry. A computing environment can include any type of computer system, including, but not limited to, a computer system based on a microprocessor, a mainframe computer, a digital signal processor, a portable computing device, a device controller, or a computational engine within an appliance, to name a few.</p><p id="p-0199" num="0375">The elements of a method, process, routine, or algorithm described in connection with the embodiments disclosed herein can be embodied directly in hardware, in a software module executed by a processor device, or in a combination of the two. A software module can reside in RAM memory, flash memory, ROM memory, EPROM memory, EEPROM memory, registers, hard disk, a removable disk, a CD-ROM, or any other form of a non-transitory computer-readable storage medium. An exemplary storage medium can be coupled to the processor device such that the processor device can read information from, and write information to, the storage medium. In the alternative, the storage medium can be integral to the processor device. The processor device and the storage medium can reside in an ASIC. The ASIC can reside in a user terminal. In the alternative, the processor device and the storage medium can reside as discrete components in a user terminal.</p><p id="p-0200" num="0376">Conditional language used herein, such as, among others, &#x201c;can,&#x201d; &#x201c;could,&#x201d; &#x201c;might,&#x201d; &#x201c;may,&#x201d; &#x201c;e.g.,&#x201d; and the like, unless specifically stated otherwise, or otherwise understood within the context as used, is generally intended to convey that certain embodiments include, while other embodiments do not include, certain features, elements or steps. Thus, such conditional language is not generally intended to imply that features, elements or steps are in any way required for one or more embodiments or that one or more embodiments necessarily include logic for deciding, with or without other input or prompting, whether these features, elements or steps are included or are to be performed in any particular embodiment. The terms &#x201c;comprising,&#x201d; &#x201c;including,&#x201d; &#x201c;having,&#x201d; and the like are synonymous and are used inclusively, in an open-ended fashion, and do not exclude additional elements, features, acts, operations, and so forth. Also, the term &#x201c;or&#x201d; is used in its inclusive sense (and not in its exclusive sense) so that when used, for example, to connect a list of elements, the term &#x201c;or&#x201d; means one, some, or all of the elements in the list.</p><p id="p-0201" num="0377">Disjunctive language such as the phrase &#x201c;at least one of X, Y, or Z,&#x201d; unless specifically stated otherwise, is otherwise understood with the context as used in general to present that an item, term, etc., may be either X, Y, or Z, or any combination thereof (e.g., X, Y, or Z). Thus, such disjunctive language is not generally intended to, and should not, imply that certain embodiments require at least one of X, at least one of Y, and at least one of Z to each be present.</p><p id="p-0202" num="0378">While the above detailed description has shown, described, and pointed out novel features as applied to various embodiments, it can be understood that various omissions, substitutions, and changes in the form and details of the devices or algorithms illustrated can be made without departing from the scope of the disclosure. As can be recognized, certain embodiments described herein can be embodied within a form that does not provide all of the features and benefits set forth herein, as some features can be used or practiced separately from others. All changes which come within the meaning and range of equivalency of the Clauses are to be embraced within their scope.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-claim-statement>What is claimed is:</us-claim-statement><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A systolic array processor organized in rows and columns, each row comprising:<claim-text>a reducer configured to convert 32-bit input data elements into two 21-bit input data elements, the reducer comprising:<claim-text>a first sub-reducer configured to convert a 32-bit input data element of the 32-bit input data elements into a first 21-bit input data element, the first 21-bit input data element corresponding to a set of most significant bits of a significand portion of the 32-bit input data element, the first sub-reducer comprising:<claim-text>a trailing bit reducer configured to reduce a quantity of trailing bits representing the significand portion of the 32-bit input data element to produce a first reduced significand portion of the 32-bit input data element, the first reduced significand portion corresponding to the set of most significant bits; and</claim-text><claim-text>a first exponent expander configured to increase a quantity of bits representing an exponent portion of the 32-bit input data element to produce a first increased exponent portion,</claim-text><claim-text>wherein the first sub-reducer produces the first 21-bit input data element based on the first reduced significand portion and the first increased exponent portion; and</claim-text></claim-text><claim-text>a second sub-reducer configured to convert the 32-bit input data element into a second 21-bit input data element, the second 21-bit input data element corresponding to a set of least significant bits of the significand portion of the 32-bit input data element, the second sub-reducer comprising:<claim-text>a leading bit reducer configured to reduce a quantity of leading bits representing the significand portion of the 32-bit input data element to produce a second reduced significand portion of the 32-bit input data element, the second reduced significand portion corresponding to the set of least significant bits; and</claim-text><claim-text>a second exponent expander configured to increase a quantity of bits representing the exponent portion of the 32-bit input data element to produce a second increased exponent portion,</claim-text><claim-text>wherein the second sub-reducer produces a second 21-bit input data element based on the second reduced significand portion and the second increased exponent portion; and</claim-text></claim-text></claim-text><claim-text>a plurality of processing elements, a processing element of the plurality of processing elements configured to iteratively perform a plurality of pairwise multiply-accumulate operations on the first 21-bit input data element, the second 21-bit input data element, and a weight to provide a total output, wherein a 21 bit-length corresponds to a maximum supported bit-length for the processing element.</claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The systolic array processor of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the first 21-bit input data element and the second 21-bit input data element sum to the 32-bit input data element.</claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. The systolic array processor of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the second sub-reducer is further configured to determine the 32-bit input data element comprises a normal number, the second sub-reducer further comprising:<claim-text>a normalizer to remove an implied bit of the 32-bit input data element and renormalize the second reduced significand portion to produce a normalized significand portion based on determining the 32-bit input data element comprises a normal number; and</claim-text><claim-text>an exponent adjuster to adjust the second increased exponent portion to produce an adjusted exponent portion based on renormalizing the second reduced significand portion,</claim-text><claim-text>wherein the second 21-bit input data element is further based on the normalized significand portion and the adjusted exponent portion.</claim-text></claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The systolic array processor of <claim-ref idref="CLM-00001">claim 1</claim-ref>, the weight comprising a first reduced weight and a second reduced weight, wherein the processing element is further configured to:<claim-text>multiply the second 21-bit input data element and the second reduced weight to generate a first product;</claim-text><claim-text>multiply the first 21-bit input data element and the second reduced weight to generate a second product;</claim-text><claim-text>multiply the second 21-bit input data element and the first reduced weight to generate a third product; and</claim-text><claim-text>multiply the first 21-bit input data element and the first reduced weight to generate a fourth product,</claim-text></claim-text><claim-text>wherein the systolic array processor further comprises a partial sum buffer configured to:<claim-text>add the first product, the second product, the third product, the fourth product, and an input partial sum to generate the total output.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. A systolic circuit comprising:<claim-text>a group of processing elements arranged into a plurality of rows; and</claim-text><claim-text>a first convertor configured to:<claim-text>receive a first input represented in floating-point with a first bit-length;</claim-text><claim-text>generate a first reduced input represented in floating-point with a second bit-length, the first reduced input corresponding to a set of most significant bits of a significand portion of the first input; and</claim-text><claim-text>generate a second reduced input represented in floating-point with a third bit-length, the second reduced input corresponding to a set of least significant bits of the significand portion of the first input, wherein the first reduced input and the second reduced input sum to the first input, wherein the second bit-length and the third bit-length are less than the first bit-length, wherein the second bit-length and the third bit-length correspond to a bit-length supported by the group of processing elements,</claim-text></claim-text><claim-text>wherein an individual processing element in at least one row of the group of processing elements is configured to receive the first reduced input and the second reduced input and perform a plurality of multiply-accumulate operations on the first reduced input, the second reduced input, and a second input.</claim-text></claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The systolic circuit of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein individual processing elements in the plurality of rows of the group of processing elements comprise:<claim-text>a multiplier configured to multiply two 21-bit floating-point numbers, wherein the multiplier is comprised of a 1-bit sign data path, a 11-bit significand data path, and a 9-bit exponent data path; and</claim-text><claim-text>an adder configured to add two floating-point numbers, wherein the adder is comprised of a 1-bit sign data path, a 23-bit significand data path, and a 10-bit exponent data path.</claim-text></claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. The systolic circuit of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the first input corresponds to an input data element and the second input corresponds to a weight, wherein the first convertor is further configured to:<claim-text>receive the second input represented in floating-point with a fourth bit-length;</claim-text><claim-text>generate a third reduced input represented in floating-point with a fifth bit-length, the third reduced input corresponding to a set of most significant bits of a significand portion of the second input;</claim-text><claim-text>generate a fourth reduced input represented in floating-point with a sixth bit-length, the fourth reduced input corresponding to a set of least significant bits of the significand portion of the second input, wherein the third reduced input and the fourth reduced input sum to the second input, wherein the fifth bit-length and the sixth bit-length are less than the fourth bit-length, wherein the fifth bit-length and the sixth bit-length correspond to the bit-length supported by the group of processing elements; and</claim-text><claim-text>select the first reduced input, the second reduced input, the third reduced input, or the fourth reduced input to be provided.</claim-text></claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. The systolic circuit of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the first convertor comprises:<claim-text>a first sub-reducer comprising:<claim-text>a trailing bit reducer configured to reduce a quantity of the set of least significant bits of the significand portion of the first input to produce a first reduced significand portion of the first input; and</claim-text><claim-text>a first exponent expander configured to increase a quantity of bits representing an exponent portion of the first input to produce a first increased exponent portion,</claim-text><claim-text>wherein the first sub-reducer produces the first reduced input based on the first reduced significand portion and the first increased exponent portion; and</claim-text></claim-text><claim-text>a second sub-reducer comprising:<claim-text>a leading bit reducer configured to reduce a quantity of the set of most significant bits of the significand portion of the first input to produce a second reduced significand portion of the first input; and</claim-text><claim-text>a second exponent expander configured to increase a quantity of bits representing the exponent portion of the first input to produce a second increased exponent portion,</claim-text><claim-text>wherein the second sub-reducer produces the second reduced input based on the second reduced significand portion and the second increased exponent portion.</claim-text></claim-text></claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. The systolic circuit of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the second sub-reducer is configured to determine the first input comprises a normal number, the second sub-reducer further comprising:<claim-text>a normalizer to remove an implied bit of the first input and renormalize the second reduced significand portion to produce a normalized significand portion based on determining the first input comprises a normal number; and</claim-text><claim-text>an exponent adjuster to adjust the second increased exponent portion to produce an adjusted exponent portion based on renormalizing the second reduced significand portion,</claim-text><claim-text>wherein the second reduced input is further based on the normalized significand portion and the adjusted exponent portion.</claim-text></claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. The systolic circuit of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the second input corresponds to a first reduced weight and a second reduced weight, wherein to perform the plurality of multiply-accumulate operations, the individual processing element is configured to:<claim-text>multiply the second reduced input and the second reduced weight to generate a first product;</claim-text><claim-text>add the first product to an input partial sum to generate a first sum;</claim-text><claim-text>multiply the first reduced input and the second reduced weight to generate a second product;</claim-text><claim-text>multiply the second reduced input and the first reduced weight to generate a third product; and</claim-text><claim-text>multiply the first reduced input and the first reduced weight to generate a fourth product,</claim-text></claim-text><claim-text>wherein the systolic circuit further comprises a partial sum buffer configured to:<claim-text>add the first sum to the second product to generate a second sum;</claim-text><claim-text>add the second sum and the third product to generate a third sum; and</claim-text><claim-text>add the third sum and the fourth product to generate a total output.</claim-text></claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. The systolic circuit of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the plurality of multiply-accumulate operations comprise an ordered plurality of multiply-accumulate operations.</claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. The systolic circuit of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein:<claim-text>the first convertor is configured to convert 32-bit floating-point numbers to a plurality of 22-bit floating-point numbers,</claim-text><claim-text>wherein each of the processing elements comprises:<claim-text>a 22-bit multiplier; and</claim-text><claim-text>a 34-bit adder.</claim-text></claim-text></claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The systolic circuit of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein:<claim-text>the first convertor is further configured to convert m-bit floating-point numbers to one or more n-bit floating-point numbers, wherein n and m can be any number, wherein n is less than m,</claim-text><claim-text>wherein each of the processing elements comprises:<claim-text>a multiplier configured to multiply at least two n-bit numbers; and</claim-text><claim-text>an adder configured to add two p-bit numbers, wherein p is greater than n.</claim-text></claim-text></claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The systolic circuit of <claim-ref idref="CLM-00005">claim 5</claim-ref>, the systolic circuit further comprising:<claim-text>a partial sum buffer configured to perform chunk-based accumulation based on a plurality of outputs of the group of processing elements.</claim-text></claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. The systolic circuit of <claim-ref idref="CLM-00005">claim 5</claim-ref>, further comprising:<claim-text>a second convertor configured to:<claim-text>receive the second input represented in floating-point with a fourth bit-length, the second input corresponding to a weight;</claim-text><claim-text>generate a third reduced input represented in floating-point with a fifth bit-length, the third reduced input corresponding to a set of most significant bits of a significand portion of the second input; and</claim-text><claim-text>generate a fourth reduced input represented in floating-point with a sixth bit-length, the fourth reduced input corresponding to a set of least significant bits of the significand portion of the second input, wherein the third reduced input and the fourth reduced input sum to the second input, wherein the fifth bit-length and the sixth bit-length are less than the fourth bit-length, wherein the fifth bit-length and the sixth bit-length correspond to the bit-length supported by the group of processing elements,</claim-text></claim-text><claim-text>wherein the individual processing element in the at least one row of the group of processing elements is further configured to receive the third reduced input and the fourth reduced input and perform the plurality of multiply-accumulate operations on the first reduced input, the second reduced input, the third reduced input, and the fourth reduced input.</claim-text></claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. The systolic circuit of <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the group of processing elements perform a first accumulation on a plurality of outputs of the group of processing elements to produce a reduced plurality of outputs, the systolic circuit further comprising:<claim-text>a partial sum buffer configured to perform chunk-based accumulation based on the reduced plurality of outputs to generate an output.</claim-text></claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. A method, comprising:<claim-text>receiving a first input represented in floating-point;</claim-text><claim-text>generating a first reduced input represented in floating-point, the first reduced input corresponding to a set of most significant bits of a significand portion of the first input;</claim-text><claim-text>generating a second reduced input represented in floating-point, the second reduced input corresponding to a set of least significant bits of the significand portion of the first input, wherein the first reduced input and the second reduced input sum to the first input, wherein the first reduced input and the second reduced input correspond to a supported bit-length; and</claim-text><claim-text>performing one or more operations based on the first reduced input, the second reduced input, and a second input to generate an output.</claim-text></claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. The method of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein:<claim-text>the first input comprises a 32-bit floating-point number;</claim-text><claim-text>the first reduced input comprises a first 22-bit floating-point number; and</claim-text><claim-text>the second reduced input comprises a second 22-bit floating-point number.</claim-text></claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. The method of <claim-ref idref="CLM-00017">claim 17</claim-ref>, further comprising:<claim-text>receiving the second input represented in floating-point;</claim-text><claim-text>generating a third reduced input represented in floating-point, the third reduced input corresponding to a set of most significant bits of a significand portion of the second input; and</claim-text><claim-text>generating a fourth reduced input represented in floating-point, the fourth reduced input corresponding to a set of least significant bits of the significand portion of the second input, wherein the third reduced input and the fourth reduced input sum to the second input,</claim-text><claim-text>wherein the one or more operations are further based on the third reduced input and the fourth reduced input.</claim-text></claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. The method of <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein each of the first input and the second input comprises an input data element or a weight.</claim-text></claim></claims></us-patent-application>