<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE us-patent-application SYSTEM "us-patent-application-v46-2022-02-17.dtd" [ ]><us-patent-application lang="EN" dtd-version="v4.6 2022-02-17" file="US20230005489A1-20230105.XML" status="PRODUCTION" id="us-patent-application" country="US" date-produced="20221221" date-publ="20230105"><us-bibliographic-data-application lang="EN" country="US"><publication-reference><document-id><country>US</country><doc-number>20230005489</doc-number><kind>A1</kind><date>20230105</date></document-id></publication-reference><application-reference appl-type="utility"><document-id><country>US</country><doc-number>17807095</doc-number><date>20220615</date></document-id></application-reference><us-application-series-code>17</us-application-series-code><priority-claims><priority-claim sequence="01" kind="national"><country>DE</country><doc-number>13189770.4</doc-number><date>20131022</date></priority-claim></priority-claims><classifications-ipcr><classification-ipcr><ipc-version-indicator><date>20060101</date></ipc-version-indicator><classification-level>A</classification-level><section>G</section><class>10</class><subclass>L</subclass><main-group>19</main-group><subgroup>008</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source></classification-ipcr></classifications-ipcr><classifications-cpc><main-cpc><classification-cpc><cpc-version-indicator><date>20130101</date></cpc-version-indicator><section>G</section><class>10</class><subclass>L</subclass><main-group>19</main-group><subgroup>008</subgroup><symbol-position>F</symbol-position><classification-value>I</classification-value><action-date><date>20230105</date></action-date><generating-office><country>US</country></generating-office><classification-status>B</classification-status><classification-data-source>H</classification-data-source><scheme-origination-code>C</scheme-origination-code></classification-cpc></main-cpc></classifications-cpc><invention-title id="d2e61">METHOD FOR DECODING AND ENCODING A DOWNMIX MATRIX, METHOD FOR PRESENTING AUDIO CONTENT, ENCODER AND DECODER FOR A DOWNMIX MATRIX, AUDIO ENCODER AND AUDIO DECODER</invention-title><us-related-documents><continuation><relation><parent-doc><document-id><country>US</country><doc-number>16579293</doc-number><date>20190923</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>11393481</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>17807095</doc-number></document-id></child-doc></relation></continuation><continuation><relation><parent-doc><document-id><country>US</country><doc-number>15911974</doc-number><date>20180305</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>10468038</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>16579293</doc-number></document-id></child-doc></relation></continuation><continuation><relation><parent-doc><document-id><country>US</country><doc-number>15131263</doc-number><date>20160418</date></document-id><parent-grant-document><document-id><country>US</country><doc-number>9947326</doc-number></document-id></parent-grant-document></parent-doc><child-doc><document-id><country>US</country><doc-number>15911974</doc-number></document-id></child-doc></relation></continuation><continuation><relation><parent-doc><document-id><country>US</country><doc-number>PCT/EP2014/071929</doc-number><date>20141013</date></document-id><parent-status>PENDING</parent-status></parent-doc><child-doc><document-id><country>US</country><doc-number>15131263</doc-number></document-id></child-doc></relation></continuation></us-related-documents><us-parties><us-applicants><us-applicant sequence="00" app-type="applicant" designation="us-only" applicant-authority-category="assignee"><addressbook><orgname>Fraunhofer-Gesellschaft zur Foerderung der angewandten Forschung e.V.</orgname><address><city>Muenchen</city><country>DE</country></address></addressbook><residence><country>DE</country></residence></us-applicant></us-applicants><inventors><inventor sequence="00" designation="us-only"><addressbook><last-name>Ghido</last-name><first-name>Florin</first-name><address><city>Nuernberg</city><country>DE</country></address></addressbook></inventor><inventor sequence="01" designation="us-only"><addressbook><last-name>Kuntz</last-name><first-name>Achim</first-name><address><city>Hemhofen</city><country>DE</country></address></addressbook></inventor><inventor sequence="02" designation="us-only"><addressbook><last-name>Grill</last-name><first-name>Bernhard</first-name><address><city>Lauf</city><country>DE</country></address></addressbook></inventor></inventors></us-parties></us-bibliographic-data-application><abstract id="abstract"><p id="p-0001" num="0000">A method is described which decodes a downmix matrix for mapping a plurality of input channels of audio content to a plurality of output channels, the input and output channels being associated with respective speakers at predetermined positions relative to a listener position, wherein the downmix matrix is encoded by exploiting the symmetry of speaker pairs of the plurality of input channels and the symmetry of speaker pairs of the plurality of output channels. Encoded information representing the encoded downmix matrix is received and decoded for obtaining the decoded downmix matrix.</p></abstract><drawings id="DRAWINGS"><figure id="Fig-EMI-D00000" num="00000"><img id="EMI-D00000" he="104.99mm" wi="158.75mm" file="US20230005489A1-20230105-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00001" num="00001"><img id="EMI-D00001" he="202.18mm" wi="125.39mm" orientation="landscape" file="US20230005489A1-20230105-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00002" num="00002"><img id="EMI-D00002" he="239.35mm" wi="159.34mm" orientation="landscape" file="US20230005489A1-20230105-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00003" num="00003"><img id="EMI-D00003" he="101.18mm" wi="140.80mm" file="US20230005489A1-20230105-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00004" num="00004"><img id="EMI-D00004" he="164.00mm" wi="149.18mm" file="US20230005489A1-20230105-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00005" num="00005"><img id="EMI-D00005" he="201.25mm" wi="160.70mm" file="US20230005489A1-20230105-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00006" num="00006"><img id="EMI-D00006" he="142.92mm" wi="156.21mm" file="US20230005489A1-20230105-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00007" num="00007"><img id="EMI-D00007" he="127.51mm" wi="151.98mm" file="US20230005489A1-20230105-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00008" num="00008"><img id="EMI-D00008" he="240.11mm" wi="137.58mm" orientation="landscape" file="US20230005489A1-20230105-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00009" num="00009"><img id="EMI-D00009" he="199.73mm" wi="145.97mm" file="US20230005489A1-20230105-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00010" num="00010"><img id="EMI-D00010" he="238.93mm" wi="159.77mm" file="US20230005489A1-20230105-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure><figure id="Fig-EMI-D00011" num="00011"><img id="EMI-D00011" he="237.57mm" wi="159.77mm" file="US20230005489A1-20230105-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/></figure></drawings><description id="description"><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="lead"?><heading id="h-0001" level="1">CROSS-REFERENCE TO RELATED APPLICATIONS</heading><p id="p-0002" num="0001">This application is a continuation of co-pending U.S. patent application Ser. No. 16/579,293 filed Sep. 23, 2019 which is a continuation of U.S. patent application Ser. No. 15/911,974 filed on Mar. 5, 2018 which is a continuation of U.S. patent application Ser. No. 15/131,263 filed Apr. 18, 2016 which is a continuation of International Application No. PCT/EP2014/071929, filed Oct. 13, 2014, which is incorporated herein by reference in its entirety, and additionally claims priority from European Application No. 13189770.4, filed Oct. 22, 2013, which is also incorporated herein by reference in its entirety.</p><?cross-reference-to-related-applications description="Cross Reference To Related Applications" end="tail"?><?summary-of-invention description="Summary of Invention" end="lead"?><heading id="h-0002" level="1">BACKGROUND OF THE INVENTION</heading><p id="p-0003" num="0002">The present invention relates to the field of audio encoding/decoding, especially to spatial audio coding and spatial audio object coding, for example to the field of 3D audio codec systems. Embodiments of the invention relate to methods for encoding and decoding a downmix matrix for mapping a plurality of input channels of audio content to a plurality of output channels, to a method for presenting audio content, to an encoder for encoding a downmix matrix, to a decoder for decoding a downmix matrix, to an audio encoder and to an audio decoder.</p><p id="p-0004" num="0003">Spatial audio coding tools are well-known in the art and are standardized, for example, in the MPEG-surround standard. Spatial audio coding starts from a plurality of original input, e.g., five or seven input channels, which are identified by their placement in a reproduction setup, e.g., as a left channel, a center channel, a right channel, a left surround channel, a right surround channel and a low frequency enhancement channel. A spatial audio encoder may derive one or more downmix channels from the original channels and, additionally, may derive parametric data relating to spatial cues such as interchannel level differences in the channel coherence values, interchannel phase differences, interchannel time differences, etc. The one or more downmix channels are transmitted together with the parametric side information indicating the spatial cues to a spatial audio decoder for decoding the downmix channels and the associated parametric data in order to finally obtain output channels which are an approximated version of the original input channels. The placement of the channels in the output setup may be fixed, e.g., a 5.1 format, a 7.1 format, etc.</p><p id="p-0005" num="0004">Also, spatial audio object coding tools are well-known in the art and are standardized, for example, in the MPEG SAOC standard (SAOC=Spatial Audio Object Coding). In contrast to spatial audio coding starting from original channels, spatial audio object coding starts from audio objects which are not automatically dedicated for a certain rendering reproduction setup. Rather, the placement of the audio objects in the reproduction scene is flexible and may be set by a user, e.g., by inputting certain rendering information into a spatial audio object coding decoder. Alternatively or additionally, rendering information may be transmitted as additional side information or metadata; rendering information may include information at which position in the reproduction setup a certain audio object is to be placed (e.g., over time). In order to obtain a certain data compression, a number of audio objects are encoded using an SAOC encoder which calculates, from the input objects, one or more transport channels by downmixing the objects in accordance with certain downmixing information. Furthermore, the SAOC encoder calculates parametric side information representing inter-object cues such as object level differences (OLD), object coherence values, etc. As in SAC (SAC=Spatial Audio Coding), the inter object parametric data is calculated for individual time/frequency tiles. For a certain frame (for example, 1024 or 2048 samples) of the audio signal a plurality of frequency bands (for example 24, 32, or 64 bands) are considered so that parametric data is provided for each frame and each frequency band. For example, when an audio piece has 20 frames and when each frame is subdivided into 32 frequency bands, the number of time/frequency tiles is 640.</p><p id="p-0006" num="0005">In 3D audio systems it may be desired to provide a spatial impression of an audio signal at a receiver using a loudspeaker or speaker configuration as it is available at the receiver which, however, may be different from an original speaker configuration for the original audio signal. In such a situation, a conversion needs to be carried out, which is also referred to as a &#x201c;downmix&#x201d; in accordance with which the input channels, in accordance with the original speaker configuration of the audio signal, are mapped to output channels defined in accordance with the speaker configuration of the receiver.</p><heading id="h-0003" level="1">SUMMARY</heading><p id="p-0007" num="0006">According to an embodiment, a method for decoding a downmix matrix for mapping a plurality of input channels of audio content to a plurality of output channels, the input and output channels being associated with respective speakers at predetermined positions relative to a listener position, wherein the downmix matrix is encoded by exploiting the symmetry of speaker pairs of the plurality of input channels and the symmetry of speaker pairs of the plurality of output channels, may have the steps of: receiving encoded information representing the encoded downmix matrix from an encoder; and decoding the encoded information for obtaining the decoded downmix matrix, wherein respective pairs of input and output channels in the downmix matrix have associated respective mixing gains for adapting a level by which a given input channel contributes to a given output channel, and wherein the method may further have the steps of: decoding from the information representing the downmix matrix encoded significance values, wherein respective significance values are assigned to pairs of symmetric speaker groups of the input channels and symmetric speaker groups of the output channels, the significance value indicating if a mixing gain for one or more of the input channels is zero or not; and decoding from the information representing the downmix matrix encoded mixing gains.</p><p id="p-0008" num="0007">Another embodiment may have a method for encoding a downmix matrix for mapping a plurality of input channels of audio content to a plurality of output channels, the input and output channels being associated with respective speakers at predetermined positions relative to a listener position, wherein encoding the downmix matrix includes exploiting the symmetry of speaker pairs of the plurality of input channels and the symmetry of speaker pairs of the plurality of output channels wherein respective pairs of input and output channels in the downmix matrix have associated respective mixing gains for adapting a level by which a given input channel contributes to a given output channel, wherein respective significance values are assigned to pairs of symmetric speaker groups of the input channels and symmetric speaker groups of the output channels, the significance value indicating if a mixing gain for one or more of the input channels is zero or not, and the method may further have the steps of: encoding the significance values, and encoding the mixing gains.</p><p id="p-0009" num="0008">According to another embodiment, a method for presenting audio content having a plurality of input channels to a system having a plurality of output channels different from the input channels may have the steps of: providing the audio content and a downmix matrix for mapping the input channels to the output channels, encoding the audio content; encoding the downmix matrix in accordance with the inventive method; transmitting the encoded audio content and the encoded downmix matrix to the system; decoding the audio content; decoding downmix matrix in accordance with the inventive method; and mapping the input channels of the audio content to the output channels of the system using the decoded downmix matrix, wherein the downmix matrix is encoded/decoded in accordance with the inventive methods.</p><p id="p-0010" num="0009">Another embodiment may have a non-transitory digital storage medium having a computer program stored thereon to perform the inventive methods when said computer program is run by a computer.</p><p id="p-0011" num="0010">According to another embodiment, an encoder for encoding a downmix matrix for mapping a plurality of input channels of audio content to a plurality of output channels, the input and output channels being associated with respective speakers at predetermined positions relative to a listener position, may have: a processor configured to encode the downmix matrix in accordance with the inventive method.</p><p id="p-0012" num="0011">According to another embodiment, a decoder for decoding a downmix matrix for mapping a plurality of input channels of audio content to a plurality of output channels, the input and output channels being associated with respective speakers at predetermined positions relative to a listener position, wherein the downmix matrix is encoded by exploiting the symmetry of speaker pairs of the plurality of input channels and the symmetry of speaker pairs of the plurality of output channels, may have: a processor configured to operate in accordance with the inventive method for decoding.</p><p id="p-0013" num="0012">According to another embodiment, an audio encoder for encoding an audio signal may have an inventive encoder.</p><p id="p-0014" num="0013">According to another embodiment, an audio decoder for decoding an encoded audio signal may have an inventive decoder.</p><p id="p-0015" num="0014">The present invention is based on the finding that a more efficient coding of a steady downmix matrix can be achieved by exploiting symmetries that can be found in the input channel configuration and in the output channel configuration with regard to the placement of speakers associated with the respective channels. It has been found by the inventors of the present invention that exploiting such symmetry allows combining the symmetrically arranged speakers into a common row/column of the downmix matrix, for example those speakers which have, with regard to the listener position, a position having the same elevation angle and the same absolute value of the Azimuth angle but with different signs. This allows for generating a compact downmix matrix having a reduced size which, therefore, can be more easily and more efficiently encoded when compared to the original downmix matrix.</p><p id="p-0016" num="0015">In accordance with embodiments, not only symmetric speaker groups are defined, but actually three classes of speaker groups are created, namely the above-mentioned symmetric speakers, the center speakers and the asymmetric speakers, which can then be used for generating the compact representation. This approach is advantageous as it allows speakers from the respective classes to be handled differently and thereby more efficiently.</p><p id="p-0017" num="0016">In accordance with embodiments, encoding the compact downmix matrix comprises encoding the gain values separate from the information about the actual compact downmix matrix. The information about the actual compact downmix matrix is encoded by creating a compact significance matrix, which indicates with regard to the compact input/output channel configurations the existence of non-zero gains by merging each of the input and output symmetric speaker pairs into one group. This approach is advantageous as it allows for an efficient encoding of the significance matrix on the basis of a run-length scheme.</p><p id="p-0018" num="0017">In accordance with embodiments a template matrix may be provided that is similar to the compact downmix matrix in that the entries in the matrix elements of the template matrix substantially correspond to the entries in the matrix elements in the compact downmix matrix. In general, such template matrices are provided at the encoder and at the decoder and only differ from the compact downmix matrix in a reduced number of matrix elements so that by applying an element-wise XOR to the compact significance matrix with such a template matrix will drastically reduce the number of ones. This approach is advantageous as it allows for even further increasing the efficiency of encoding the significance matrix, again, using for example a run-length scheme.</p><p id="p-0019" num="0018">In accordance with a further embodiment, the encoding is further based on an indication whether normal speakers are mixed only to normal speakers and LFE speakers are mixed only to LFE speakers. This is advantageous as it further improves the coding of the significance matrix.</p><p id="p-0020" num="0019">In accordance with a further embodiment the compact significance matrix or the result of the above-mentioned XOR operation is provided as to a one-dimensional vector to which a run-length coding is applied to convert it to runs of zeros which are followed by a one which is advantageous as it provides a very efficient possibility for coding the information. To achieve an even more efficient coding, in accordance with the embodiments a limited Golomb-Rice encoding is applied to the run-length values.</p><p id="p-0021" num="0020">In accordance with further embodiments for each output speaker group it is indicated whether the properties of symmetry and separability apply for all corresponding input speaker groups that generate them. This is advantageous as it indicates that in a speaker group consisting, for example, of left and right speakers, the left speakers in the input channel group are mapped only to the left channels in the corresponding output speaker group, the right speakers in the input channel group are only mapped to the right speakers in the output channel group, and there is no mixing from the left channel to the right channel. This allows replacing the four gain values in the 2&#xd7;2 sub-matrix in the original downmix matrix by a single gain value that may be introduced into the compact matrix or, in case the compact matrix is a significance matrix may be coded separately. In any case, the overall number of gain values to be coded is reduced. Thus, the signaled properties of symmetry and separability are advantageous as they allow efficiently coding the sub-matrices corresponding to each pair of input and output speaker groups.</p><p id="p-0022" num="0021">In accordance with embodiments, for coding the gain values a list of possible gains is created in a particular order using a signaled minimum and maximum gain and also a signaled desired precision. The gain values are created in such an order that commonly used gains are at the beginning of the list or table. This is advantageous as it allows efficiently encoding the gain values by applying to the most frequently used gains the shortest code words for encoding them.</p><p id="p-0023" num="0022">In accordance with an embodiment, the gain values generated may be provided in a list, each entry in a list having associated therewith an index. When coding the gain values, rather than coding the actual values, the indexes of the gains are encoded. This may be done, for example by applying a limited Golomb-Rice encoding approach. This handling of the gain values is advantageous as it allows efficiently encoding them.</p><p id="p-0024" num="0023">In accordance with embodiments, equalizer (EQ) parameters may be transmitted along with the downmix matrix.</p><?summary-of-invention description="Summary of Invention" end="tail"?><?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?><description-of-drawings><heading id="h-0004" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading><p id="p-0025" num="0024">Embodiments of the present invention will be detailed subsequently referring to the appended drawings, in which:</p><p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. <b>1</b></figref> illustrates an overview of a 3D audio encoder of a 3D audio system;</p><p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. <b>2</b></figref> illustrates an overview of a 3D audio decoder of a 3D audio system;</p><p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates an embodiment of a binaural renderer that may be implemented in the 3D audio decoder of <figref idref="DRAWINGS">FIG. <b>2</b></figref>;</p><p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. <b>4</b></figref> illustrates an exemplary downmix matrix as it is known in the art for mapping from a 22.2 input configuration to a 5.1 output configuration;</p><p id="p-0030" num="0029"><figref idref="DRAWINGS">FIGS. <b>5</b>A and <b>5</b>B</figref> schematically illustrate an embodiment of the present invention for converting the original downmix matrix of <figref idref="DRAWINGS">FIG. <b>4</b></figref> into a compact downmix matrix;</p><p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. <b>6</b></figref> illustrates the compact downmix matrix of <figref idref="DRAWINGS">FIG. <b>5</b></figref> in accordance with an embodiment of the present invention having the converted input and output channel configurations with the matrix entries representing significance values;</p><p id="p-0032" num="0031"><figref idref="DRAWINGS">FIGS. <b>7</b>A and <b>7</b>B</figref> illustrate a further embodiment of the present invention for encoding the structure of the compact downmix matrix of <figref idref="DRAWINGS">FIG. <b>5</b></figref> using a template matrix;</p><p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. <b>8</b>A-<b>8</b>G</figref> illustrate possible sub-matrices that can be derived from the downmix matrix shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref>, according to different combinations of input and output speakers; and</p><p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. <b>9</b></figref> Part <b>1</b> and <figref idref="DRAWINGS">FIG. <b>9</b></figref> Part <b>2</b> illustrates a system in accordance with embodiments of the present invention for presenting audio content having a plurality of input channels to a system having a plurality of output channels different from the input channels.</p></description-of-drawings><?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?><?detailed-description description="Detailed Description" end="lead"?><heading id="h-0005" level="1">DETAILED DESCRIPTION OF THE INVENTION</heading><p id="p-0035" num="0034">Embodiments of the inventive approach will be described. The following description will start with a system overview of a 3D audio codec system in which the inventive approach may be implemented.</p><p id="p-0036" num="0035"><figref idref="DRAWINGS">FIGS. <b>1</b> and <b>2</b></figref> show the algorithmic blocks of a 3D audio system in accordance with embodiments. More specifically, <figref idref="DRAWINGS">FIG. <b>1</b></figref> shows an overview of a 3D audio encoder <b>100</b>. The audio encoder <b>100</b> receives at a pre-renderer/mixer circuit <b>102</b>, which may be optionally provided, input signals, more specifically a plurality of input channels providing to the audio encoder <b>100</b> a plurality of channel signals <b>104</b>, a plurality of object signals <b>106</b> and corresponding object metadata <b>108</b>. The object signals <b>106</b> processed by the pre-renderer/mixer <b>102</b> (see signals <b>110</b>) may be provided to a SAOC encoder <b>112</b> (SAOC=Spatial Audio Object Coding). The SAOC encoder <b>112</b> generates the SAOC transport channels <b>114</b> provided to an USAC encoder <b>116</b> (USAC=Unified Speech and Audio Coding). In addition, the signal SAOC-SI <b>118</b> (SAOC-SI=SAOC Side Information) is also provided to the USAC encoder <b>116</b>. The USAC encoder <b>116</b> further receives object signals <b>120</b> directly from the pre-renderer/mixer as well as the channel signals and pre-rendered object signals <b>122</b>. The object metadata information <b>108</b> is applied to a OAM encoder <b>124</b> (OAM=Object Associated Metadata) providing the compressed object metadata information <b>126</b> to the USAC encoder. The USAC encoder <b>116</b>, on the basis of the above mentioned input signals, generates a compressed output signal mp4, as is shown at <b>128</b>.</p><p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. <b>2</b></figref> shows an overview of a 3D audio decoder <b>200</b> of the 3D audio system. The encoded signal <b>128</b> (mp4) generated by the audio encoder <b>100</b> of <figref idref="DRAWINGS">FIG. <b>1</b></figref> is received at the audio decoder <b>200</b>, more specifically at an USAC decoder <b>202</b>. The USAC decoder <b>202</b> decodes the received signal <b>128</b> into the channel signals <b>204</b>, the pre-rendered object signals <b>206</b>, the object signals <b>208</b>, and the SAOC transport channel signals <b>210</b>. Further, the compressed object metadata information <b>212</b> and the signal SAOC-SI <b>214</b> is output by the USAC decoder <b>202</b>. The object signals <b>208</b> are provided to an object renderer <b>216</b> outputting the rendered object signals <b>218</b>. The SAOC transport channel signals <b>210</b> are supplied to the SAOC decoder <b>220</b> outputting the rendered object signals <b>222</b>. The compressed object meta information <b>212</b> is supplied to the OAM decoder <b>224</b> outputting respective control signals to the object renderer <b>216</b> and the SAOC decoder <b>220</b> for generating the rendered object signals <b>218</b> and the rendered object signals <b>222</b>. The decoder further comprises a mixer <b>226</b> receiving, as shown in <figref idref="DRAWINGS">FIG. <b>2</b></figref>, the input signals <b>204</b>, <b>206</b>, <b>218</b> and <b>222</b> for outputting the channel signals <b>228</b>. The channel signals can be directly output to a loudspeaker, e.g., a 32 channel loudspeaker, as is indicated at <b>230</b>. The signals <b>228</b> may be provided to a format conversion circuit <b>232</b> receiving as a control input a reproduction layout signal indicating the way the channel signals <b>228</b> are to be converted. In the embodiment depicted in <figref idref="DRAWINGS">FIG. <b>2</b></figref>, it is assumed that the conversion is to be done in such a way that the signals can be provided to a 5.1 speaker system as is indicated at <b>234</b>. Also, the channel signals <b>228</b> may be provided to a binaural renderer <b>236</b> generating two output signals, for example for a headphone, as is indicated at <b>238</b>.</p><p id="p-0038" num="0037">In an embodiment of the present invention, the encoding/decoding system depicted in <figref idref="DRAWINGS">FIGS. <b>1</b> and <b>2</b></figref> is based on the MPEG-D USAC codec for coding of channel and object signals (see signals <b>104</b> and <b>106</b>). To increase the efficiency for coding a large amount of objects, the MPEG SAOC technology may be used. Three types of renderers may perform the tasks of rendering objects to channels, rendering channels to headphones or rendering channels to a different loudspeaker setup (see <figref idref="DRAWINGS">FIG. <b>2</b></figref>, reference signs <b>230</b>, <b>234</b>, and <b>238</b>). When object signals are explicitly transmitted or parametrically encoded using SAOC, the corresponding object metadata information <b>108</b> is compressed (see signal <b>126</b>) and multiplexed into the 3D audio bitstream <b>128</b>.</p><p id="p-0039" num="0038">The algorithm blocks of the overall 3D audio system shown in <figref idref="DRAWINGS">FIGS. <b>1</b> and <b>2</b></figref> will be described in further detail below.</p><p id="p-0040" num="0039">The pre-renderer/mixer <b>102</b> may be optionally provided to convert a channel plus object input scene into a channel scene before encoding. Functionally, it is identical to the object renderer/mixer that will be described below. Pre-rendering of objects may be desired to ensure a deterministic signal entropy at the encoder input that is basically independent of the number of simultaneously active object signals. With pre-rendering of objects, no object metadata transmission is necessitated. Discrete object signals are rendered to the channel layout that the encoder is configured to use. The weights of the objects for each channel are obtained from the associated object metadata (OAM).</p><p id="p-0041" num="0040">The USAC encoder <b>116</b> is the core codec for loudspeaker-channel signals, discrete object signals, object downmix signals and pre-rendered signals. It is based on the MPEG-D USAC technology. It handles the coding of the above signals by creating channel- and object mapping information based on the geometric and semantic information of the input channel and object assignment. This mapping information describes how input channels and objects are mapped to USAC-channel elements, like channel pair elements (CPEs), single channel elements (SCEs), low frequency effects (LFEs) and quad channel elements (QCEs) and CPEs, SCEs and LFEs, and the corresponding information is transmitted to the decoder. All additional payloads like SAOC data <b>114</b>, <b>118</b> or object metadata <b>126</b> are considered in the encoder's rate control. The coding of objects is possible in different ways, depending on the rate/distortion requirements and the interactivity requirements for the renderer. In accordance with embodiments, the following object coding variants are possible:<ul id="ul0001" list-style="none">    <li id="ul0001-0001" num="0000">    <ul id="ul0002" list-style="none">        <li id="ul0002-0001" num="0041">Pre-rendered objects: Object signals are pre-rendered and mixed to the 22.2 channel signals before encoding. The subsequent coding chain sees 22.2 channel signals.</li>        <li id="ul0002-0002" num="0042">Discrete object waveforms: Objects are supplied as monophonic waveforms to the encoder. The encoder uses single channel elements (SCEs) to transmit the objects in addition to the channel signals. The decoded objects are rendered and mixed at the receiver side. Compressed object metadata information is transmitted to the receiver/renderer.</li>        <li id="ul0002-0003" num="0043">Parametric object waveforms: Object properties and their relation to each other are described by means of SAOC parameters. The downmix of the object signals is coded with the USAC. The parametric information is transmitted alongside. The number of downmix channels is chosen depending on the number of objects and the overall data rate. Compressed object metadata information is transmitted to the SAOC renderer.</li>    </ul>    </li></ul></p><p id="p-0042" num="0044">The SAOC encoder <b>112</b> and the SAOC decoder <b>220</b> for object signals may be based on the MPEG SAOC technology. The system is capable of recreating, modifying and rendering a number of audio objects based on a smaller number of transmitted channels and additional parametric data, such as OLDs, IOCs (Inter Object Coherence), DMGs (DownMix Gains). The additional parametric data exhibits a significantly lower data rate than necessitated for transmitting all objects individually, making the coding very efficient. The SAOC encoder <b>112</b> takes as input the object/channel signals as monophonic waveforms and outputs the parametric information (which is packed into the 3D-Audio bitstream <b>128</b>) and the SAOC transport channels (which are encoded using single channel elements and are transmitted). The SAOC decoder <b>220</b> reconstructs the object/channel signals from the decoded SAOC transport channels <b>210</b> and the parametric information <b>214</b>, and generates the output audio scene based on the reproduction layout, the decompressed object metadata information and optionally on the basis of the user interaction information.</p><p id="p-0043" num="0045">The object metadata codec (see OAM encoder <b>124</b> and OAM decoder <b>224</b>) is provided so that, for each object, the associated metadata that specifies the geometrical position and volume of the objects in the 3D space is efficiently coded by quantization of the object properties in time and space. The compressed object metadata cOAM <b>126</b> is transmitted to the receiver <b>200</b> as side information.</p><p id="p-0044" num="0046">The object renderer <b>216</b> utilizes the compressed object metadata to generate object waveforms according to the given reproduction format. Each object is rendered to a certain output channel according to its metadata. The output of this block results from the sum of the partial results. If both channel based content as well as discrete/parametric objects are decoded, the channel based waveforms and the rendered object waveforms are mixed by the mixer <b>226</b> before outputting the resulting waveforms <b>228</b> or before feeding them to a postprocessor module like the binaural renderer <b>236</b> or the loudspeaker renderer module <b>232</b>.</p><p id="p-0045" num="0047">The binaural renderer module <b>236</b> produces a binaural downmix of the multichannel audio material such that each input channel is represented by a virtual sound source. The processing is conducted frame-wise in the QMF (Quadrature Mirror Filterbank) domain, and the binauralization is based on measured binaural room impulse responses.</p><p id="p-0046" num="0048">The loudspeaker renderer <b>232</b> converts between the transmitted channel configuration <b>228</b> and the desired reproduction format. It may also be called &#x201c;format converter.&#x201d; The format converter performs conversions to lower numbers of output channels, i.e., it creates downmixes.</p><p id="p-0047" num="0049"><figref idref="DRAWINGS">FIG. <b>3</b></figref> illustrates an embodiment of the binaural renderer <b>236</b> of <figref idref="DRAWINGS">FIG. <b>2</b></figref>. The binaural renderer module may provide a binaural downmix of the multichannel audio material. The binauralization may be based on a measured binaural room impulse response. The room impulse response may be considered a &#x201c;fingerprint&#x201d; of the acoustic properties of a real room. The room impulse response is measured and stored, and arbitrary acoustical signals can be provided with this &#x201c;fingerprint,&#x201d; thereby allowing at the listener a simulation of the acoustic properties of the room associated with the room impulse response. The binaural renderer <b>236</b> may be programmed or configured for rendering the output channels into two binaural channels using head related transfer functions or Binaural Room Impulse Responses (BRIR). For example, for mobile devices binaural rendering is desired for headphones or loudspeakers attached to such mobile devices. In such mobile devices, due to constraints it may be necessitated to limit the decoder and rendering complexity. In addition to omitting decorrelation in such processing scenarios, it may be advantageous to first perform a downmix using a downmixer <b>250</b> to an intermediate downmix signal <b>252</b>, i.e., to a lower number of output channels which results in a lower number of input channel for the actual binaural converter <b>254</b>. For example, a 22.2 channel material may be downmixed by the downmixer <b>250</b> to a 5.1 intermediate downmix or, alternatively, the intermediate downmix may be directly calculated by the SAOC decoder <b>220</b> in <figref idref="DRAWINGS">FIG. <b>2</b></figref> in a kind of a &#x201c;shortcut&#x201d; mode. The binaural rendering then only has to apply ten HRTFs (Head Related Transfer Functions) or BRIR functions for rendering the five individual channels at different positions in contrast to applying 44 HRTF or BRIR functions if the 22.2 input channels were to be directly rendered. The convolution operations necessitated for the binaural rendering necessitate a lot of processing power and, therefore, reducing this processing power while still obtaining an acceptable audio quality is particularly useful for mobile devices. The binaural renderer <b>236</b> produces a binaural downmix <b>238</b> of the multichannel audio material <b>228</b>, such that each input channel (excluding the LFE channels) is represented by a virtual sound source. The processing may be conducted frame-wise in QMF domain. The binauralization is based on measured binaural room impulse responses, and the direct sound and early reflections may be imprinted to the audio material via a convolutional approach in a pseudo-FFT domain using a fast convolution on-top of the QMF domain, while late reverberation may be processed separately.</p><p id="p-0048" num="0050">Multichannel audio formats are currently present in a large variety of configurations; they are used in a 3D audio system as it has been described above in detail which is used, for example, for providing audio information provided on DVDs and Blue-ray discs. One important issue is to accommodate the real-time transmission of multi-channel audio, while maintaining the compatibility with existing available customer physical speaker setups. A solution is to encode the audio content in the original format used, for example, in production, which typically has a large number of output channels. In addition, downmix side information is provided to generate other formats which have less independent channels. Assuming, for example, a number N of input channels and a number M of output channels, the downmix procedure at the receiver may be specified by a downmix matrix having the size N&#xd7;M. This particular procedure, as it might be carried out in the downmixer of the above described format converter or binaural renderer, represents a passive downmix, meaning that no adaptive signal processing dependent on the actual audio content is applied to the input signals or to the downmixed output signals.</p><p id="p-0049" num="0051">A downmix matrix tries to match not only the physical mixing of the audio information, but may also convey the artistic intentions of the producer which may use his knowledge about the actual content that is transmitted. Therefore, there are several ways of generating downmix matrices, for example manually by using generic acoustic knowledge about the role and position of the input and output speakers, manually by using knowledge about the actual content and the artistic intention, and automatically, for example by using a software tool which computes an approximation using the given output speakers.</p><p id="p-0050" num="0052">There are a number of known approaches in the art for providing such downmix matrices. However, existing schemes make many assumptions and hard-code an important part of the structure and the contents of the actual downmix matrix. In &#x201c;Information technology&#x2014;Coding of audio-visual objects&#x2014;Part 3: Audio, AMENDMENT 4: New levels for AAC profiles,&#x201d; ISO/IEC 14496-3:2009/DAM 4, 2013, it is described to use particular downmixing procedures that are explicitly defined for downmixing from the 5.1 channel configuration (see ITU-R BS.775-3, &#x201c;Multichannel stereophonic sound system with and without accompanying picture,&#x201d; <i>Rec., International Telecommunications Union</i>, Geneva, Switzerland, 2012) to the 2.0 channel configuration, from the 6.1 or 7.1 Front or Front Height or Surround Back variants to the 5.1 or 2.0 channel configurations. The drawback of these known approaches is that the downmixing schemes only have a limited degree of freedom in the sense that some of the input channels are mixed with predefined weights (for example, in case of mapping the 7.1 Surround Back to the 5.1 configuration, the L, R and C input channels are directly mapped to the corresponding output channels) and a reduced number of gain values is shared for some other input channels (for example, in case of mapping the 7.1 Front to the 5.1 configuration, the L, R, Lc and Rc input channels are mixed to the L and R output channels using only one gain value). Moreover, the gains only have a limited range and precision, for example from 0 dB to &#x2212;9 dB with a total of eight levels. Explicitly describing the downmix procedures for each input and output configuration pair is laborious and implies addendums to existing standards, at the expense of delayed compliance. Another proposal is described in &#x201c;Enhanced audio support and other improvements,&#x201d; <i>ISO/IEC </i>14496-12:2012 PDAM 3, 2013. This approach uses explicit downmix matrices which represent an improvement in flexibility; however, the scheme again limits the range and precision of 0 dB to &#x2212;9 dB with a total of 16 levels. Moreover, each gain is encoded with a fixed precision of 4 bits.</p><p id="p-0051" num="0053">Thus, in view of the prior art known, an improved approach for efficient coding of downmix matrices is needed, including the aspects of choosing a suitable representation domain and quantization scheme but also a lossless coding of the quantized values.</p><p id="p-0052" num="0054">In accordance with embodiments, unrestricted flexibility is achieved for handling downmix matrices by allowing encoding of arbitrary downmix matrices, with the range and the precision specified by the producer according to his needs. Also, embodiments of the invention provide for a very efficient lossless coding so the typical matrices use a small amount of bits, and departing from typical matrices will only gradually decrease efficiency. This means that the more similar a matrix is to a typical one, the more efficient the coding described in accordance with embodiments of the present invention will be.</p><p id="p-0053" num="0055">In accordance with embodiments, the necessitated precision may be specified by the producer as 1 dB, 0.5 dB or 0.25 dB, to be used for uniform quantization. It is noted that in accordance with other embodiments, also other values for the precision can be selected. Contrary thereto, existing schemes only allow for a precision of 1.5 dB or 0.5 dB for values around 0 dB, while using a lower precision for the other values. Using a coarser quantization for some values affects the worst case tolerances achieved and makes interpretation of decoded matrices more difficult. In existing techniques, a lower precision is used for some values which is a simple means to reduce the number of necessitated bits using uniform coding. However, practically the same results can be achieved without sacrificing precision by using an improved coding scheme that will be described in further detail below.</p><p id="p-0054" num="0056">In accordance with embodiments, the values of the mixing gains can be specified between a maximum value, for example +22 dB and a minimum value, for example &#x2212;47 dB. They may also include the value minus infinity. The effective value range used in the matrix is indicated in the bit stream as a maximum gain and a minimum gain, thereby not wasting any bits on values which are not actually used while not limiting the desired flexibility.</p><p id="p-0055" num="0057">In accordance with embodiments, it is assumed that an input channel list of the audio content for which the downmix matrix is to be provided is available, as well as an output channel list indicative of the output speaker configuration. These lists provide geometrical information about each speaker in the input configuration and in the output configuration such as the azimuth angle and the elevation angle. Optionally, also the speakers' conventional names may be provided.</p><p id="p-0056" num="0058"><figref idref="DRAWINGS">FIG. <b>4</b></figref> shows an exemplary downmix matrix as it is known in the art for mapping from a 22.2 input configuration to a 5.1 output configuration. In the right-hand column <b>300</b> of the matrix, the respective input channels in accordance with the 22.2 configuration are indicated by the speaker names associated with the respective channels. The bottom row <b>302</b> includes the respective output channels of the output channel configuration, the 5.1 configuration. Again, the respective channels are indicated by the associated speaker names. The matrix includes a plurality of matrix elements <b>304</b> each holding a gain value, also referred to as a mixing gain. The mixing gain indicates how the level of a given input channel is adjusted, for example one of the input channels <b>300</b>, when contributing to a respective output channel <b>302</b>. For example, the upper left-hand matrix element shows a value of &#x201c;1&#x201d; meaning that the center channel C in the input channel configuration <b>300</b> is completely matched to the center channel C of the output channel configuration <b>302</b>. Likewise, the respective left and right channels in the two configurations (L/R channels) are completely mapped, i.e., the left/right channels in the input configuration contribute completely to the left/right channels in the output configuration. Other channels, for example the channels Lc and Rc in the input configuration, are mapped with a reduced level of 0.7 to the left and right channels of the output configuration <b>302</b>. As can be seen from <figref idref="DRAWINGS">FIG. <b>4</b></figref>, there is also a number of matrix elements not having an entry meaning that the respective channels associated with the matrix element are not mapped to each other or meaning that an input channel linked to an output channel via a matrix element having no entry does not contribute to the respective output channel. For example, neither of the left/right input channels is mapped to the output channels Ls/Rs, i.e., the left and right input channels do not contribute to the output channels Ls/Rs. Instead of providing voids in the matrix, also a zero gain could have been indicated.</p><p id="p-0057" num="0059">In the following several techniques will be described which are applied in accordance with embodiments of the present invention to achieve an efficient lossless coding of the downmix matrix. In the following embodiments, reference will be made to a coding of the downmix matrix shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref>; however, it is readily apparent that the specifics described in the following can be applied to any other downmix matrix that may be provided. In accordance with embodiments an approach for decoding a downmix matrix is provided, wherein the downmix matrix is encoded by exploiting the symmetry of speaker pairs of the plurality of input channels and the symmetry of speaker pairs of the plurality of output channels. The downmix matrix is decoded following its transmission to a decoder, e.g. at an audio decoder receiving a bitstream including the encoded audio content and also encoded information or data representing the downmix matrix, allowing to construct at the decoder a downmix matrix corresponding to the original downmix matrix. Decoding the downmix matrix comprises receiving the encoded information representing the downmix matrix and decoding the encoded information for obtaining the downmix matrix. In accordance with other embodiments, an approach for encoding the downmix matrix is provided which comprises exploiting the symmetry of speaker pairs of the plurality of input channels and the symmetry of speaker pairs of the plurality of output channels.</p><p id="p-0058" num="0060">In the following description of embodiments of the invention some aspects will be described in the context of encoding the downmix matrix; however, to the skilled reader, it is clear that these aspects also represent a description of the corresponding approach for decoding the downmix matrix. Analogously, aspects described in the context of decoding the downmix matrix also represent a description of a corresponding approach for encoding the downmix matrix.</p><p id="p-0059" num="0061">In accordance with embodiments, the first step is to take advantage of the significant number of zero entries in the matrix. In the following step, in accordance with embodiments, one takes advantage of the global and also the fine level regularities which are typically present in a downmix matrix. A third step is to take advantage of the typical distribution of the nonzero gain values.</p><p id="p-0060" num="0062">In accordance with a first embodiment, the inventive approach starts from a downmix matrix, as it may be provided by a producer of the audio content. For the following discussion, for the sake of simplicity, it is assumed that the downmix matrix considered is the one of <figref idref="DRAWINGS">FIG. <b>4</b></figref>. In accordance with the inventive approach, the downmix matrix of <figref idref="DRAWINGS">FIG. <b>4</b></figref> is converted for providing a compact downmix matrix that can be more efficiently encoded when compared to the original matrix.</p><p id="p-0061" num="0063"><figref idref="DRAWINGS">FIG. <b>5</b></figref> schematically represents the just mentioned conversion step. In the upper part of <figref idref="DRAWINGS">FIG. <b>5</b></figref>, the original downmix matrix <b>306</b> of <figref idref="DRAWINGS">FIG. <b>4</b></figref> is shown that is converted in a way that will be described in further detail below into a compact downmix matrix <b>308</b> shown in the lower part of <figref idref="DRAWINGS">FIG. <b>5</b></figref>. In accordance with the inventive approach, the concept of &#x201c;symmetric speaker pairs&#x201d; is used which means that one speaker is in the left semi-plane, while the other is in the right semi-plane, relative to a listener position. This symmetric pair configuration corresponds to the two speakers having the same elevation angle, while having the same absolute value for the azimuth angle but with different signs.</p><p id="p-0062" num="0064">In accordance with embodiments different classes of speaker groups are defined, mainly symmetric speakers S, center speakers C, and asymmetric speakers A. Center speakers are those speakers whose positions do not change when changing the sign of the azimuth angle of the speaker position. Asymmetric speakers are those speakers that lack the other or corresponding symmetric speaker in a given configuration, or in some rare configurations the speaker on the other side may have a different elevation angle or azimuth angle so that in this case there are two separate asymmetric speakers instead of a symmetric pair. In the downmix matrix <b>306</b> shown in <figref idref="DRAWINGS">FIG. <b>5</b></figref>, the input channel configuration <b>300</b> includes nine symmetric speaker pairs S<b>1</b> to S<b>9</b> that are indicated in the upper part of <figref idref="DRAWINGS">FIG. <b>5</b></figref>. For example, symmetric speaker pair S<b>1</b> includes the speakers Lc and Rc of the 22.2 input channel configuration <b>300</b>. Also the LFE speakers in the 22.2 input configuration are symmetrical speakers as they have, with regard to the listener position, the same elevation angle and the same absolute azimuth angle with different signs. The 22.2 input channel configuration <b>300</b> further includes six central speakers C<b>1</b> to C<b>6</b>, namely speakers C, Cs, Cv, Ts, Cvr and Cb. No asymmetric channel is present in the input channel configuration. The output channel configuration <b>302</b>, other than the input channel configuration, only includes two symmetrical speaker pairs S<b>10</b> and S<b>11</b> and one central speaker C<b>7</b> and one asymmetric speaker A<b>1</b>.</p><p id="p-0063" num="0065">In accordance with the described embodiment, the downmix matrix <b>306</b> is converted to a compact representation <b>308</b> by grouping together input and output speakers which form symmetric speaker pairs. Grouping the respective speakers together yields a compact input configuration <b>310</b> including the same center speakers C<b>1</b> to C<b>6</b> as in the original input configuration <b>300</b>. However, when compared to the original input configuration <b>300</b> the symmetric speakers S<b>1</b> to S<b>9</b> are respectively grouped together such that the respective pairs now occupy only a single row, as is indicated in the lower part of <figref idref="DRAWINGS">FIG. <b>5</b></figref>. In a similar way, also the original output channel configuration <b>302</b> is converted into a compact output channel configuration <b>312</b> also including the original center and non-symmetric speakers, namely the central speaker C<b>7</b> and the asymmetrical speaker A<b>1</b>. However, the respective speaker pairs S<b>10</b> and S<b>11</b> were combined into a single column. Thus, as can be seen from <figref idref="DRAWINGS">FIG. <b>5</b></figref>, the dimension of the original downmix matrix <b>306</b> which was 24&#xd7;6 was reduced to a dimension of the compact downmix matrix <b>308</b> of 15&#xd7;4.</p><p id="p-0064" num="0066">In the embodiment described with regard to <figref idref="DRAWINGS">FIG. <b>5</b></figref>, one can see that in the original downmix matrix <b>306</b> the mixing gains associated with the respective symmetric speaker pairs S<b>1</b> to S<b>11</b>, which indicate how strongly an input channel contributes to an output channel, are symmetrically arranged for corresponding symmetrical speaker pairs in the input channel and in the output channel. For example, when looking at the pair S<b>1</b> and S<b>10</b>, the respective left and right channels are combined via the gain 0.7 while the combinations of left/right channels are combined with the gain 0. Thus, when grouping the respective channels together in a way as shown in the compact downmix matrix <b>308</b>, the compact downmix matrix elements <b>314</b> may include the respective mixing gains also described with regard to the original matrix <b>306</b>. Thus, in accordance with the above described embodiment, the size of the original downmix matrix is reduced by grouping symmetrical speaker pairs together so that the &#x201c;compact&#x201d; representation <b>308</b> can be encoded more efficiently than the original downmix matrix.</p><p id="p-0065" num="0067">With regard to <figref idref="DRAWINGS">FIG. <b>6</b></figref>, a further embodiment of the present invention will now be described. <figref idref="DRAWINGS">FIG. <b>6</b></figref> again shows the compact downmix matrix <b>308</b> having the converted input and output channel configuration <b>310</b>, <b>312</b> as already shown and described with regard to <figref idref="DRAWINGS">FIG. <b>5</b></figref>. In the embodiment of <figref idref="DRAWINGS">FIG. <b>6</b></figref>, the matrix entries <b>314</b> of the compact downmix matrix, other than in <figref idref="DRAWINGS">FIG. <b>5</b></figref>, do not represent any gain values but so-called &#x201c;significance values.&#x201d; A significance value indicates if at the respective matrix elements <b>314</b> any of the gains associated therewith is zero or not. Those matrix elements <b>314</b> showing the value &#x201c;1&#x201d; indicate that the respective element has associated therewith a gain value, while the void matrix elements indicate that no gain or gain value of zero is associated with this element. In accordance with this embodiment, replacing the actual gain values by the significance values allows for even further efficiently encoding the compact downmix matrix when compared to <figref idref="DRAWINGS">FIG. <b>5</b></figref> as the representation <b>308</b> of <figref idref="DRAWINGS">FIG. <b>6</b></figref> can be simply encoded using, for example, one bit per entry indicating a value of 1 or a value of 0 for the respective significance values. In addition, besides encoding the significance values it will also be necessitated to encode the respective gain values associated with the matrix elements so that upon decoding the information received the complete downmix matrix can be reconstructed.</p><p id="p-0066" num="0068">In accordance with another embodiment, the representation of the downmix matrix in its compact form as shown in <figref idref="DRAWINGS">FIG. <b>6</b></figref> can be encoded using a run-length scheme. In such a run-length scheme, the matrix elements <b>314</b> are transformed into a one-dimensional vector by concatenating the rows starting with row 1 and ending with row 15. This one-dimensional vector is then converted into a list containing the run lengths, for example the number of consecutive zeros which is terminated by a 1. In the embodiment of <figref idref="DRAWINGS">FIG. <b>6</b></figref>, this yields the following list:</p><p id="p-0067" num="0000"><tables id="TABLE-US-00001" num="00001"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>1000 1100 0100 0110 0010 0010 0001 1000 0100 0110 1010 0010 0010 1000 0100 (1)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="17"><colspec colname="1" colwidth="35pt" align="left"/><colspec colname="2" colwidth="14pt" align="left"/><colspec colname="3" colwidth="14pt" align="left"/><colspec colname="4" colwidth="14pt" align="left"/><colspec colname="5" colwidth="14pt" align="left"/><colspec colname="6" colwidth="14pt" align="left"/><colspec colname="7" colwidth="14pt" align="left"/><colspec colname="8" colwidth="14pt" align="left"/><colspec colname="9" colwidth="14pt" align="left"/><colspec colname="10" colwidth="14pt" align="left"/><colspec colname="11" colwidth="14pt" align="left"/><colspec colname="12" colwidth="14pt" align="left"/><colspec colname="13" colwidth="14pt" align="left"/><colspec colname="14" colwidth="14pt" align="left"/><colspec colname="15" colwidth="14pt" align="left"/><colspec colname="16" colwidth="14pt" align="left"/><colspec colname="17" colwidth="14pt" align="left"/><tbody valign="top"><row><entry>0</entry><entry>30</entry><entry>3</entry><entry>30</entry><entry>3</entry><entry>3</entry><entry>4</entry><entry>0</entry><entry>4</entry><entry>30</entry><entry>1</entry><entry>1</entry><entry>3</entry><entry>3</entry><entry>1</entry><entry>4</entry><entry>2</entry></row><row><entry namest="1" nameend="17" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>where (1) represents a virtual termination in case the bit vector ends with a 0. The above shown run-length may be coded using an appropriate coding scheme, such as a limited Golomb-Rice coding which assigns a variable length prefix code to each number, so that the total bit length is minimized. The Golomb-Rice coding approach is used to code a non-negative integer n&#x2265;0, using a non-negative integer parameter p&#x2265;0 as follows: first, the number h=&#x2514;n/2<sup>p</sup>&#x2518; is coded using a unary coding, the h one (1) bits being followed by a terminating zero bit; then the number l=n&#x2212;h&#xb7;2<sup>p </sup>is uniformly coded using p bits.</p><p id="p-0068" num="0069">The limited Golomb-Rice coding is a trivial variant used when it is known in advance that n&#x3c;N. It does not include the terminating zero bit when coding the maximum possible value of h, which is h<sub>max</sub>=&#x2514;(N&#x2212;1)/2<sup>p</sup>&#x2518;. More exactly, to encode h=h<sub>max </sub>only h one (1) bits are used without the terminating zero bit, which is not needed because the decoder can implicitly detect this condition.</p><p id="p-0069" num="0070">As mentioned above, the gains associated with the respective element <b>314</b> need to be encoded and transmitted as well and embodiments for doing this will be described in detail further below. Prior to discussing the encoding of the gains in detail, further embodiments for encoding the structure of the compact downmix matrix shown in <figref idref="DRAWINGS">FIG. <b>6</b></figref> will now be described.</p><p id="p-0070" num="0071"><figref idref="DRAWINGS">FIGS. <b>7</b>A and <b>7</b>B</figref> describes a further embodiment for encoding the structure of the compact downmix matrix by making use of the fact that typical compact matrices have some meaningful structure so that they are in general similar to a template matrix that is available both at an audio encoder and an audio decoder. <figref idref="DRAWINGS">FIGS. <b>7</b>A and <b>7</b>B</figref> shows the compact downmix matrix <b>308</b> having the significance values, as is shown also in <figref idref="DRAWINGS">FIG. <b>6</b></figref>. In addition, <figref idref="DRAWINGS">FIGS. <b>7</b>A and <b>7</b>B</figref> shows an example of a possible template matrix <b>316</b> having the same input and output channel configuration <b>310</b>&#x2032;, <b>312</b>&#x2032;. The template matrix, like the compact downmix matrix, includes significance values in the respective template matrix elements <b>314</b>&#x2032;. The significance values are distributed among the elements <b>314</b>&#x2032; basically in the same way as in the compact downmix matrix, except that the template matrix, which, as mentioned above, is only &#x201c;similar&#x201d; to the compact downmix matrix, differs in some of the elements <b>314</b>&#x2032;. The template matrix <b>316</b> differs from the compact downmix matrix <b>308</b> in that in the compact downmix matrix <b>308</b> the matrix elements <b>318</b> and <b>320</b> do not include any gain values, while the template matrix <b>316</b> includes in the corresponding matrix elements <b>318</b>&#x2032; and <b>320</b>&#x2032; the significance value. Thus, the template matrix <b>316</b>, with regard to the highlighted entries <b>318</b>&#x2032; and <b>320</b>&#x2032; differs from the compact matrix which needs to be encoded. For achieving an even further efficient coding of the compact downmix matrix, when compared to <figref idref="DRAWINGS">FIG. <b>6</b></figref>, the corresponding matrix elements <b>314</b>, <b>314</b>&#x2032; in the two matrices <b>308</b>, <b>316</b> are logically combined to obtain, in a similar way as described with regard to <figref idref="DRAWINGS">FIG. <b>6</b></figref>, a one-dimensional vector that can be encoded in a similar way as described above. Each of the matrix elements <b>314</b>, <b>314</b>&#x2032; may be subjected to an XOR operation, more specifically a logical element-wise XOR operation is applied to the compact matrix using the compact template which yields a one-dimensional vector which is converted into a list containing the following run-lengths:</p><p id="p-0071" num="0000"><tables id="TABLE-US-00002" num="00002"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="259pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>0000 0000 0000 0000 0000 0000 0000 0100 0000 0000 0100 0000 0000 0000 0000 (1)</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="91pt" align="left"/><colspec colname="2" colwidth="84pt" align="left"/><colspec colname="3" colwidth="84pt" align="left"/><tbody valign="top"><row><entry>29</entry><entry>11</entry><entry>18</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></tbody></tgroup></table></tables><br/>This list can now be encoded, for example by also using the limited Golomb-Rice coding. When compared to the embodiment described with regard to <figref idref="DRAWINGS">FIG. <b>6</b></figref>, it can be seen that this list can be encoded even more efficiently. In the best case, when the compact matrix is identical to the template matrix, the entire vector consists only of zeros and only one run-length number needs to be encoded.</p><p id="p-0072" num="0072">With regard to the use of a template matrix, as it has been described with regard to <figref idref="DRAWINGS">FIGS. <b>7</b>A and <b>7</b>B</figref>, it is noted that both the encoder and the decoder need to have a predefined set of such compact templates which is uniquely determined by a set of input and output speakers, in contrast to an input or output configuration which is determined by the list of speakers. This means that the order of input and output speakers is not relevant for determining the template matrix, rather it can be permuted before use to match the order of a given compact matrix.</p><p id="p-0073" num="0073">In the following, as mentioned above, embodiments will be described regarding the encoding of the mixing gains provided in the original downmix matrix which are no longer present in the compact downmix matrix and which need to be encoded and transmitted as well.</p><p id="p-0074" num="0074"><figref idref="DRAWINGS">FIG. <b>8</b>A-<b>8</b>G</figref> describes an embodiment for encoding the mixing gains.</p><p id="p-0075" num="0075">This embodiment makes use of the properties of the sub-matrices which correspond to one or more nonzero entries in the original downmix matrix, according to different combinations of input and output speaker groups, namely groups S (symmetric, L and R), C (center) and A (asymmetric). <figref idref="DRAWINGS">FIG. <b>8</b>A-<b>8</b>G</figref> describes possible sub-matrices that can be derived from the downmix matrix shown in <figref idref="DRAWINGS">FIG. <b>4</b></figref>, according to different combinations of input and output speakers, namely the symmetric speakers L and R, the central speakers C and asymmetric speakers A. In <figref idref="DRAWINGS">FIG. <b>8</b>A-<b>8</b>G</figref>, the letters a, b, c and d represent arbitrary gain values.</p><p id="p-0076" num="0076"><figref idref="DRAWINGS">FIG. <b>8</b>A</figref> shows four possible sub-matrices as they can be derived from the matrix of <figref idref="DRAWINGS">FIG. <b>4</b></figref>. The first one is the sub-matrix defining the mapping of two central channels; for example, the speakers C in the input configuration <b>300</b> and the speaker C in the output configuration <b>302</b>, and the gain value &#x201c;a&#x201d; is the gain value indicated in the matrix element [1,1] (upper left-hand element in <figref idref="DRAWINGS">FIG. <b>4</b></figref>). The second sub-matrix in <figref idref="DRAWINGS">FIG. <b>8</b>A</figref> represents, for example, mapping two symmetric input channels, for example input channels Lc and Rc, to a central speaker, such as the speaker C, in the output channel configuration. The gain values &#x201c;a&#x201d; and &#x201c;b&#x201d; are the gain values indicated in the matrix elements [1,2] and [1,3]. The third sub-matrix in <figref idref="DRAWINGS">FIG. <b>8</b>A</figref> refers to the mapping of a central speaker C, such as speaker Cvr in the input configuration <b>300</b> of <figref idref="DRAWINGS">FIG. <b>4</b></figref>, to two symmetric channels, such as channels Ls and Rs, in the output configuration <b>302</b>. The gain values &#x201c;a&#x201d; and &#x201c;b&#x201d; are the gain values indicated in the matrix elements [4,21] and [5,21]. The fourth sub-matrix in <figref idref="DRAWINGS">FIG. <b>8</b>(<i>a</i>)</figref> represents a case where two symmetric channels are mapped; for example, channels L, R in the input configuration <b>300</b> are mapped to channels L, R in the output configuration <b>302</b>. The gain values &#x201c;a&#x201d; to &#x201c;d&#x201d; are the gain values indicated in the matrix elements [2,4], [2,5], [3,4], and [3,5].</p><p id="p-0077" num="0077"><figref idref="DRAWINGS">FIG. <b>8</b>B</figref> shows the sub-matrices when mapping asymmetric speakers. The first representation is a sub-matrix obtained by mapping two asymmetric speakers (no example for such a sub-matrix is given in <figref idref="DRAWINGS">FIG. <b>4</b></figref>). The second sub-matrix of <figref idref="DRAWINGS">FIG. <b>8</b>B</figref> refers to the mapping of two symmetric input channels to an asymmetric output channel which, in the embodiment of <figref idref="DRAWINGS">FIG. <b>4</b></figref> is, e.g. the mapping of the two symmetric input channels LFE and LFE2 to the output channel LFE. The gain values &#x201c;a&#x201d; and &#x201c;b&#x201d; are the gain values indicated in the matrix elements [6,11] and [6,12]. The third sub-matrix in <figref idref="DRAWINGS">FIG. <b>8</b>B</figref> represents the case where an input asymmetric speaker is matched to a symmetrical pair of output speakers. In the example case there is no asymmetric input speaker.</p><p id="p-0078" num="0078"><figref idref="DRAWINGS">FIG. <b>8</b>C</figref> shows two sub-matrices for mapping central speakers to asymmetric speakers. The first sub-matrix maps an input central speaker to an asymmetric output speaker (no example for such a sub-matrix is given in <figref idref="DRAWINGS">FIG. <b>4</b></figref>), and the second sub-matrix maps an asymmetric input speaker to a central output speaker.</p><p id="p-0079" num="0079">In accordance with this embodiment, for each output speaker group, it is checked whether the corresponding column satisfies for all entries the properties of symmetry and separability and this information is transmitted as side information using two bits.</p><p id="p-0080" num="0080">The symmetry property will be described with regard to <figref idref="DRAWINGS">FIGS. <b>8</b>D and <b>8</b>E</figref> and means that a S group, comprising L and R speakers, mixes with the same gain into or from a center speaker or an asymmetric speaker, or that the S group gets mixed equally into or from another S group. The just mentioned two possibilities of mixing an S group are depicted in <figref idref="DRAWINGS">FIG. <b>8</b>D</figref>, and the two sub-matrices correspond to the third and fourth sub-matrices described above with regard to <figref idref="DRAWINGS">FIG. <b>8</b>A</figref>. Applying the just mentioned symmetry property, namely that the mixing uses the same gain, yields the first sub-matrix shown in <figref idref="DRAWINGS">FIG. <b>8</b>(<i>e</i>)</figref> in which an input center speaker C is mapped to the symmetric speaker group S using the same gain value (see, for example, the mapping of the input speaker Cvr to the output speakers Ls and Rs in <figref idref="DRAWINGS">FIG. <b>4</b></figref>). This also applies the other way around, for example when looking at the mapping of the input speakers Lc, Rc to the center speaker C of the output channels; here the same symmetry property can be found. The symmetry property further leads to the second sub-matrix shown in <figref idref="DRAWINGS">FIG. <b>8</b>E</figref> in accordance with which the mixing among symmetry speakers is equal meaning that the mapping of the left speakers and the mapping of the right speakers uses the same gain factor and mapping the left speaker to the right speaker and the right speaker to the left speaker is also done using the same gain value. This is depicted in <figref idref="DRAWINGS">FIG. <b>4</b></figref> for example with regard to the mapping of the input channels L, R to the output channels L, R, with the gain value &#x201c;a&#x201d;=1 and the gain value &#x201c;b&#x201d;=0.</p><p id="p-0081" num="0081">The separability property means that a symmetric group gets mixed into or from another symmetric group by keeping all signals from the left side to the left and all signals from the right side to the right. This applies for the sub-matrix shown in <figref idref="DRAWINGS">FIG. <b>8</b>F</figref> which corresponds to the fourth sub-matrix described above with regard to <figref idref="DRAWINGS">FIG. <b>8</b>A</figref>. Applying the just mentioned separability property leads to the sub-matrix shown in <figref idref="DRAWINGS">FIG. <b>8</b>G</figref> in accordance with which the left input channel is only mapped to the left output channel and the right input channel is only mapped to the right output channel and there is no &#x201c;inter-channel&#x201d; mapping due to the gain factors of zero.</p><p id="p-0082" num="0082">Using the above mentioned two properties, which are encountered in the majority of known downmix matrices, allows to further significantly reduce the actual number of gains that need to be coded and also directly eliminates the coding needed for a large number of zero gains in case of satisfying the separability property. For example, when considering the compact matrix of <figref idref="DRAWINGS">FIG. <b>6</b></figref> including the significance values and when applying the above referenced properties to the original downmix matrix, it can be seen that it is sufficient to define a single gain value for the respective significance values, for example in the way as shown in <figref idref="DRAWINGS">FIG. <b>5</b></figref> in the lower part as, due to the separability and symmetry properties, it is known how the respective gain values associated with the respective significance values need to be distributed among the original downmix matrix upon decoding. Thus, when applying the above described embodiment <figref idref="DRAWINGS">FIG. <b>8</b>A-<b>8</b>G</figref> with regard to the matrix shown in <figref idref="DRAWINGS">FIG. <b>6</b></figref>, it is sufficient to only provide 19 gain values which need to be encoded and transmitted together with the encoded significance values for allowing the decoder to reconstruct the original downmix matrix.</p><p id="p-0083" num="0083">In the following, an embodiment will be described for dynamically creating a table of gains that may be used for defining the original gain values in the original downmix matrix, for example by a producer of the audio content. In accordance with this embodiment, a table of gains is created dynamically between a minimum gain value (minGain) and a maximum gain value (maxGain) using a specified precision. The table is created such that the most frequently used values and also the more &#x201c;round&#x201d; values are arranged closer to the beginning of the table or list than the other values, namely the values not so often used or the not so round values. In accordance with an embodiment, the list of possible values using maxGain, minGain and the precision level can be created as follows:<ul id="ul0003" list-style="none">    <li id="ul0003-0001" num="0000">    <ul id="ul0004" list-style="none">        <li id="ul0004-0001" num="0084">add integer multiples of 3 dB, going down from 0 dB to minGain;</li>        <li id="ul0004-0002" num="0085">add integer multiples of 3 dB, going up from 3 dB to maxGain;</li>        <li id="ul0004-0003" num="0086">add remaining integer multiples of 1 dB, going down from 0 dB to minGain;</li>        <li id="ul0004-0004" num="0087">add remaining integer multiples of 1 dB, going up from 1 dB to maxGain;</li>    </ul>    </li></ul></p><p id="p-0084" num="0088">stop here if precision level is 1 dB;<ul id="ul0005" list-style="none">    <li id="ul0005-0001" num="0000">    <ul id="ul0006" list-style="none">        <li id="ul0006-0001" num="0089">add remaining integer multiples of 0.5 dB, going down from 0 dB to minGain;</li>        <li id="ul0006-0002" num="0090">add remaining integer multiples of 0.5 dB, going up from 0.5 dB to maxGain;</li>    </ul>    </li></ul></p><p id="p-0085" num="0091">stop here if precision level is 0.5 dB;<ul id="ul0007" list-style="none">    <li id="ul0007-0001" num="0000">    <ul id="ul0008" list-style="none">        <li id="ul0008-0001" num="0092">add remaining integer multiples of 0.25 dB, going down from 0 dB to minGain; and</li>        <li id="ul0008-0002" num="0093">add remaining integer multiples of 0.25 dB, going up from 0.25 dB to maxGain.</li>    </ul>    </li></ul></p><p id="p-0086" num="0094">For example, when maxGain is 2 dB and minGain is &#x2212;6 dB, and precision is 0.5 dB, the following list is crated:</p><p id="p-0087" num="0095">0, &#x2212;3, &#x2212;6, &#x2212;1, &#x2212;2, &#x2212;4, &#x2212;5, 1, 2, &#x2212;0.5, &#x2212;1.5, &#x2212;2.5, &#x2212;3.5, &#x2212;4.5, &#x2212;5.5, 0.5, 1.5.</p><p id="p-0088" num="0096">With regard to the above embodiment, it is noted that the invention is not limited to the values indicated above, rather, instead of using integer multiples of 3 dB and starting from 0 dB, other values may be selected and also other values for the precision level may be selected depending on the circumstances.</p><p id="p-0089" num="0097">In general, the list of gain values may be created as follows:<ul id="ul0009" list-style="none">    <li id="ul0009-0001" num="0000">    <ul id="ul0010" list-style="none">        <li id="ul0010-0001" num="0098">add integer multiples of a first gain value, between the minimum gain, inclusive, and a starting gain value, inclusive, in decreasing order;</li>        <li id="ul0010-0002" num="0099">add remaining integer multiples of the first gain value, between the starting gain value, inclusive, and the maximum gain, inclusive, in increasing order;</li>        <li id="ul0010-0003" num="0100">add remaining integer multiples of a first precision level, between the minimum gain, inclusive, and the starting gain value, inclusive, in decreasing order;</li>        <li id="ul0010-0004" num="0101">add remaining integer multiples of the first precision level, between the starting gain value, inclusive, and the maximum gain, inclusive, in increasing order;</li>        <li id="ul0010-0005" num="0000">&#x2003;stop here if precision level is the first precision level;</li>        <li id="ul0010-0006" num="0102">add remaining integer multiples of a second precision level, between the minimum gain, inclusive, and the starting gain value, inclusive, in decreasing order;</li>        <li id="ul0010-0007" num="0103">add remaining integer multiples of the second precision level, between the starting gain value, inclusive, and the maximum gain, inclusive, in increasing order;</li>        <li id="ul0010-0008" num="0000">&#x2003;stop here if precision level is the second precision level;</li>        <li id="ul0010-0009" num="0104">add remaining integer multiples of a third precision level, between the minimum gain, inclusive, and the starting gain value, inclusive, in decreasing order; and</li>        <li id="ul0010-0010" num="0105">add remaining integer multiples of the third precision level, between the starting gain value, inclusive, and the maximum gain, inclusive, in increasing order.</li>    </ul>    </li></ul></p><p id="p-0090" num="0106">In the embodiment above, when the starting gain value is zero, the parts which add remaining values in increasing order and satisfying the associated multiplicity condition will initially add the first gain value or the first or second or third precision level. However, in the general case, the parts which add remaining values in increasing order will initially add the smallest value, satisfying the associated multiplicity condition, in the interval between the starting gain value, inclusive, and the maximum gain, inclusive. Correspondingly, the parts which add remaining values in decreasing order will initially add the largest value, satisfying the associated multiplicity condition, in the interval between the minimum gain, inclusive, and the starting gain value, inclusive. Considering an example similar to the one above but with a starting gain value=1 dB (a first gain value=3 dB, maxGain=2 dB, minGain=&#x2212;6 dB and precision level=0.5 dB) yields the following:</p><p id="p-0091" num="0107">Down: 0, &#x2212;3, &#x2212;6</p><p id="p-0092" num="0108">Up: [empty]</p><p id="p-0093" num="0109">Down: 1, &#x2212;2, &#x2212;4, &#x2212;5</p><p id="p-0094" num="0110">Up: 2</p><p id="p-0095" num="0111">Down: 0.5, &#x2212;0.5, &#x2212;1.5, &#x2212;2.5, &#x2212;3.5, &#x2212;4.5, &#x2212;5.5</p><p id="p-0096" num="0112">Up: 1.5</p><p id="p-0097" num="0113">To encode a gain value, the gain is looked up in the table and its position inside the table is output. The desired gain will be found because all the gains are previously quantized to the nearest integer multiple of the specified precision of, for example, 1 dB, 0.5 dB or 0.25 dB. In accordance with an embodiment, the positions of the gain values have associated therewith an index, indicating the position in the table and the indexes of the gains can be encoded, for example, using the limited Golomb-Rice coding approach. This results in small indexes to use a smaller number of bits than large indexes and, in this way, the frequently used values or the typical values, like 0 dB, &#x2212;3 dB or &#x2212;6 dB will use the smallest number of bits and also the more &#x201c;round&#x201d; values, like &#x2212;4 dB, will use a smaller number of bits that the not so round numbers (for example, &#x2212;4.5 dB). Thus, by using the above described embodiment not only a producer of the audio content may generate a desired list of gains, but these gains may also be encoded very efficiently so that when applying, in accordance with yet another embodiment, all the above described approaches, a highly efficient coding of downmix matrices can be achieved.</p><p id="p-0098" num="0114">The above described functionality may be part of an audio encoder as it has been described above with regard to <figref idref="DRAWINGS">FIG. <b>1</b></figref>; alternatively, it can be provided by a separate encoder device that provides the encoded version of the downmix matrix to the audio encoder to be transmitted in the bit stream towards the receiver or decoder.</p><p id="p-0099" num="0115">Upon receiving the encoded compact downmix matrix at the receiver side, in accordance with embodiments a method for decoding is provided which decodes the encoded compact downmix matrix and un-groups (separates) the grouped speakers into single speakers, thereby yielding the original downmix matrix. When the encoding of the matrix includes encoding the significance values and the gain values, during the decoding step, these are decoded so that on the basis of the significance values and on the basis of the desired input/output configuration, the downmix matrix can be reconstructed and the respective decoded gains can be associated to the respective matrix elements of the reconstructed downmix matrix. This may be performed by a separate decoder that yields the completed downmix matrix to the audio decoder which may use it in a format converter, for example, the audio decoder described above with regard to <figref idref="DRAWINGS">FIGS. <b>2</b>, <b>3</b> and <b>4</b></figref>.</p><p id="p-0100" num="0116">Thus, the inventive approach as defined above provides also for a system and a method for presenting audio content having a specific input channel configuration to a receiving system having a different output channel configuration, wherein the additional information for the downmix is transmitted together with the encoded bit stream from the encoder side to the decoder side and, in accordance with the inventive approach, due to the very efficient coding of the downmix matrices the overhead is clearly reduced.</p><p id="p-0101" num="0117">In the following, a further embodiment implementing the efficient static downmix matrix coding is described. More specifically, an embodiment for a static downmix matrix with optional EQ coding will be described. As also mentioned earlier, one issue related to multichannel audio is to accommodate its real-time transmission, while maintaining compatibility with all the existing available consumer physical speaker setups. One solution is to provide, alongside the audio content in the original production format, downmix side information to generate the other formats which have less independent channels, if needed. Assuming an inputCount input channels and an outputCount output channels, the downmix procedure is specified by a downmix matrix of size inputCount by outputCount. This particular procedure represents a passive downmix, meaning no adaptive signal processing depending on the actual audio content is applied to the input signals or to the downmixed output signals. The inventive approach, in accordance with the embodiment described now, describes a complete scheme for efficient encoding of downmix matrices, including aspects about choosing a suitable representation domain and quantization scheme but also about lossless coding of the quantized values. Each matrix element represents a mixing gain which adjusts the level a given input channel contributes to a given output channel. The embodiment described now aims to achieve unrestricted flexibility by allowing encoding of arbitrary downmix matrixes, with a range and a precision that may be specified by the producer according to his needs. Also an efficient lossless coding is desired, so that typical matrices use a small amount of bits, and departing from typical matrices will only gradually decrease efficiency. This means that the more similar a matrix is to a typical one, the more efficient its coding will be. In accordance with embodiments, the necessitated precision can be specified by the producer as 1, 0.5, or 0.25 dB, to be used for uniform quantization. The values of the mixing gains may be specified between a maximum of +22 dB to a minimum of &#x2212;47 dB inclusive, and also include the value &#x2212;&#x221e; (0 in linear domain). The effective value range that is used in the downmix matrix is indicated in the bit stream as a maximum gain value maxGain and a minimum gain value minGain, therefore not wasting any bits on values which are not actually used while not limiting flexibility.</p><p id="p-0102" num="0118">Assuming that an input channel list and also an output channel list is available which provide geometrical information about each speaker, such as the azimuth and elevation angles and optionally the speaker conventional name, for example according to <i>International Standard ISO/IEC </i>23003-3:2012, Information technology&#x2014;MPEG audio technologies&#x2014;Part 3: Unified Speech and Audio Coding, 2012; or <i>International Standard ISO/IEC </i>23001-8:2013, Information technology&#x2014;MPEG systems technologies&#x2014;Part 8: Coding-independent code points, 2013, an algorithm for encoding a downmix matrix, in accordance with embodiments, may be as shown in Table 1 below:</p><p id="p-0103" num="0000"><tables id="TABLE-US-00003" num="00003"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="280pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 1</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Syntax of DownmixMatrix</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="224pt" align="left"/><colspec colname="2" colwidth="21pt" align="center"/><colspec colname="3" colwidth="35pt" align="center"/><tbody valign="top"><row><entry/><entry>No. of</entry><entry/></row><row><entry>Syntax</entry><entry>bits</entry><entry>Mnemonic</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row><row><entry>DownmixMatrix(inputConfig, inputCount, outputConfig, outputCount)</entry><entry/><entry/></row><row><entry>{</entry><entry/><entry/></row><row><entry>&#x2003;equalizerpresent;</entry><entry>1</entry><entry>uimsbf</entry></row><row><entry>&#x2003;if (equalizerpresent) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;EqualizerConfig(inputConfig, inputCount);</entry><entry/><entry/></row><row><entry>&#x2003;}</entry><entry/><entry/></row><row><entry>&#x2003;precision Level:</entry><entry>2</entry><entry>uimsbf</entry></row><row><entry>&#x2003;maxGain = escapedValue(3, 4, 0);</entry><entry/><entry/></row><row><entry>&#x2003;minGain = escapedValue(4, 5, 0) + 1;</entry><entry/><entry/></row><row><entry>&#x2003;ConvertToCompactConfig(inputConfig, inputCount);</entry><entry/><entry/></row><row><entry>&#x2003;ConvertToCompactConfig(outputConfig, outputCount);</entry><entry/><entry/></row><row><entry>&#x2003;isAllSeparable;</entry><entry>1</entry><entry>uimsbf</entry></row><row><entry>&#x2003;if (!isAllSeparable) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;for (i = 0; i &#x3c; compactOutputCount; i++) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if (compactOutputConfig[i].pairType == SYMMETRIC) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;isSeparable[i];</entry><entry>1</entry><entry>uimsbf</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/><entry/></row><row><entry>&#x2003;} else {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;for (i = 0; i &#x3c; compactOutputCount; i++) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if (compactOutputConfig[i].pairType == SYMMETRIC) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;isSeparable[i] = 1;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/><entry/></row><row><entry>&#x2003;}</entry><entry/><entry/></row><row><entry>&#x2003;isAllSymmetric;</entry><entry>1</entry><entry>uimsbf</entry></row><row><entry>&#x2003;if (!isAllSymmetric) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;for (i = 0; i &#x3c; compactOutputCount; i++) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;isSymmetric[i];</entry><entry>1</entry><entry>uimsbf</entry></row><row><entry>&#x2003;&#x2003;}</entry><entry/><entry/></row><row><entry>&#x2003;} else {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;for (i = 0; i &#x3c; compactOutputCount; i++) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;isSymmetric[i] = 1;</entry><entry/><entry/></row><row><entry>&#x2003;}</entry><entry/><entry/></row><row><entry>&#x2003;mixLFEOnlyToLFE;</entry><entry>1</entry><entry>uimsbf</entry></row><row><entry>&#x2003;rawCodingCompactMatrix;</entry><entry>1</entry><entry>uimsbf</entry></row><row><entry>&#x2003;if (rawCodingCompactMatrix) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;for (i = 0; i &#x3c; compactInputCount; i++) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;for (j = 0; j &#x3c; compactOutputCount; j++) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if (!mixLFEOnlyToLFE &#x2225; (compactInputConfig[i].isLFE ==</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;compactOutputConfig[j].isLFE)) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;compactDownmixMatrix[i][j];</entry><entry>1</entry><entry>uimsbf</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;} else {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;compactDownmixMatrix[i][j] = 0;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/><entry/></row><row><entry>&#x2003;} else {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;if (mixLFEOnlyToLFE) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;compactInputLFECount = 0;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;compactOutputLFECount = 0;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;for (i = 0; i &#x3c; compactInputCount; i++) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if (compactInputConfig[i].isLFE) compactInputLFECount++;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;for (i = 0; i &#x3c; compactOutputCount; i++) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if (compactOutputConfig[i].isLFE) compactOutputLFECount++;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;totalCount = (compactInputCount &#x2212; compactInputLFECount) *</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;(compactOutputCount &#x2212; compactOutputLFECount);</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;} else {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;totalCount = compactInputCount * compactOutputCount;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;useCompactTemplate:</entry><entry>1</entry><entry>uimsbf</entry></row><row><entry>&#x2003;&#x2003;n = 3; if (totalCount &#x3e;= 256) n = 4;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;runLGRParam:</entry><entry>n</entry><entry>uimsbf</entry></row><row><entry>&#x2003;&#x2003;count = 0;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;flatCompactMatrix[totalCount + 1];</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;while (count &#x3c; totalCount) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;zeroRunLength; /* limited Golomb-Rice using runLGRparam */</entry><entry>varies</entry><entry>bslbf</entry></row><row><entry>&#x2003;&#x2003;&#x2003;flatCompactMatrix[count .. count + zeroRunLength] = {0, ..., 0, 1};</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;count += zeroRunLength + 1;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;count = 0;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;for (i = 0; i &#x3c; compactInputCount; i++) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;for (j = 0; j &#x3c; compactOutputCount; j++) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if (mixLFEOnlyToLFE &#x26;&#x26; compactInputConfig[i].isLFE &#x26;&#x26;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;compactOutputConfig[j].isLFE) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;compactDownmixMatrix[i][j];</entry><entry>1</entry><entry>uimsbf</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;} else if (mixLFEOnlyToLFE &#x26;&#x26; (compactInputConfig[i].isLFE {circumflex over (&#x2009;)}</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;compactOutputConfig[j].isLFE)) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;compactDownmixMatrix[i][j] = 0;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;} else {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;compactDownmixMatrix[i][j] = flatCompactMatrix[count++];</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;if (useCompactTemplate) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;compactTemplate = FindCompactTemplate(inputConfig,</entry><entry/><entry/></row><row><entry>inputCount,</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;outputConfig, outputCount);</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;for (i = 0; i &#x3c; compactInputCount; i++) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;for (j = 0; j &#x3c; compactOutputCount; j++) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;compactDownmixMatrix[i][j] {circumflex over (&#x2009;)}= compactTemplate[i][j];</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/><entry/></row><row><entry>&#x2003;}</entry><entry>1</entry><entry>uimsbf</entry></row><row><entry>&#x2003;fullForAsymmetricInputs;</entry><entry>1</entry><entry>uimsbf</entry></row><row><entry>&#x2003;rawCodingNonzeros;</entry><entry/><entry/></row><row><entry>&#x2003;if (!rawCodingNonzeros) {</entry><entry>3</entry><entry>uimsbf</entry></row><row><entry>&#x2003;&#x2003;gainLGRParam;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;generateGainTable(maxGain, minGain, precisionLevel);</entry><entry/><entry/></row><row><entry>&#x2003;}</entry><entry/><entry/></row><row><entry>&#x2003;for (i = 0; i &#x3c; compactInputCount; i++) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;iType = compactInputConfig[i].pairType;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;for (j = 0; j &#x3c; compactOutputCount; j++) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;oType = compactOutputConfig[j].pairType;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;i1 = compactInputConfig[i].originalPosition;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;o1 = compactOutputConfig[j].originalPosition;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if ((iType != SYMMETRIC) &#x26;&#x26; (oType != SYMMETRIC)) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;downmixMatrix[i1][o1] = 0.0;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if (!compactDownmixMatrix[i][j]) continue;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;downmixMatrix[i1][o1] = DecodeGainValue( );</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;} else if (iType != SYMMETRIC) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;o2 = compactOutputConfig[j].SymmetricPair.originalPosition;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;downmixMatrix[i1][o1] = 0.0;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;downmixMatrix[i1][o2] = 0.0;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if (!compactDownmixMatrix[i][j]) continue;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;downmixMatrix[i1][o1] = DecodeGainValue( );</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;useFull = (iType == ASYMMETRIC) &#x26;&#x26; </entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;fullForAsymmetricinputs;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if (isSymmetric[j] &#x26;&#x26; !useFull) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;downmixMatrix[i1][o2] = downmixMatrix[i1][o1];</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;} else {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;downmixMatrix[i1][o2] = DecodeGainValue( );</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;} else if (oType != SYMMETRIC) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;i2 = compactInputConfig[i].SymmetricPair.originalPosition;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;downmixMatrix[i1][o1] = 0.0;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;downmixMatrix[i2][o1] = 0.0;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if (!compactDownmixMatrix[i][j]) continue;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;downmixMatrix[i1][o1] = DecodeGainValue( );</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if (isSymmetric[j]) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;downmixMatrix[i2][o1] = downmixMatrix[i1][o1];</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;} else {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;downmixMatrix[i2][o1] = DecodeGainValue( );</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;} else {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;i2 = compactInputConfig[i].SymmetricPair.originalPosition;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;o2 = compactOutputConfig[j].SymmetricPair.originalPosition;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;downmixMatrix[i1][o1] = 0.0;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;downmixMatrix[i1][o2] = 0.0;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;downmixMatrix[i2][o1] = 0.0;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;downmixMatrix[i2][o2] = 0.0;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if (!compactDownmixMatrix[i][j]) continue;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;downmixMatrix[i1][o1] = DecodeGainValue( );</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if (isSeparable[j] &#x26;&#x26; isSymmetric[j]) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;downmixMatrix[i2][o2] = downmixMatrix[i1][o1];</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;} else if (!isSeparable[j] &#x26;&#x26; isSymmetric[j]) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;downmixMatrix[i1][o2] = DecodeGain Value( );</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;downmixMatrix[i2][o1] = downmixMatrix[i1][o2];</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;downmixMatrix[i2][o2] = downmixMatrix[i1][o1];</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;} else if (isSeparable[j] &#x26;&#x26; !isSymmetric[j]) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;downmixMatrix[i2][o2] = DecodeGain Value( );</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;} else {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;downmixMatrix[i1][o2] = DecodeGain Value( );</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;downmixMatrix[i2][o2] = DecodeGain Value( );</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;downmixMatrix[i2][o2] = DecodeGain Value( );</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/><entry/></row><row><entry>&#x2003;}</entry><entry/><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0104" num="0119">An algorithm for decoding gain values, in accordance with embodiments, may be as shown in Table 2 below:</p><p id="p-0105" num="0000"><tables id="TABLE-US-00004" num="00004"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 2</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Syntax of DecodeGainValue</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="154pt" align="left"/><colspec colname="2" colwidth="21pt" align="center"/><colspec colname="3" colwidth="42pt" align="center"/><tbody valign="top"><row><entry/><entry>No. of</entry><entry/></row><row><entry>Syntax</entry><entry>bits</entry><entry>Mnemonic</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row><row><entry>DecodeGainValue( )</entry><entry/><entry/></row><row><entry>{</entry><entry/><entry/></row><row><entry>&#x2003;if (rawCodingNonzeros) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;nAlphabet = (maxGain &#x2212; minGain) * 2 {circumflex over (&#x2009;)} </entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;precision Level + 1;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;gainValueIndex = ReadRange(nAlphabet);</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;gainValue = maxGain &#x2212; gainValueIndex / 2 {circumflex over (&#x2009;)} </entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;precisonLevel;</entry><entry/><entry/></row><row><entry>&#x2003;} else {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;gainValueIndex; /* limited Golomb-Rice using </entry><entry>varies</entry><entry>bslbf</entry></row><row><entry>&#x2003;&#x2003;gainLGRParam 7</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;gainValue = gainTable[gainValueIndex];</entry><entry/><entry/></row><row><entry>&#x2003;}</entry><entry/><entry/></row><row><entry>}</entry><entry/><entry/></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0106" num="0120">An algorithm for defining the read range function, in accordance with embodiments, may be as shown in Table 3 below:</p><p id="p-0107" num="0000"><tables id="TABLE-US-00005" num="00005"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 3</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Syntax of Read Range</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="147pt" align="left"/><colspec colname="2" colwidth="21pt" align="center"/><colspec colname="3" colwidth="49pt" align="center"/><tbody valign="top"><row><entry/><entry>No. of</entry><entry/></row><row><entry>Syntax</entry><entry>bits</entry><entry>Mnemonic</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row><row><entry>ReadRange(alphabetSize)</entry><entry/><entry/></row><row><entry>{</entry><entry/><entry/></row><row><entry>&#x2003;nBits = floor(log2(alphabetSize));</entry><entry/><entry/></row><row><entry>&#x2003;nUnused = 2 {circumflex over (&#x2009;)} (nBits + 1) &#x2212; alphabetSize;</entry><entry>nBits</entry><entry>uimsbf</entry></row><row><entry>&#x2003;range;</entry><entry/><entry/></row><row><entry>&#x2003;if (range &#x3e;= nUnused) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;range Extra:</entry><entry>1</entry><entry>uimsbf</entry></row><row><entry>&#x2003;&#x2003;range = range * 2 &#x2212; nUnused + rangeExtra;</entry><entry/><entry/></row><row><entry>&#x2003;}</entry><entry/><entry/></row><row><entry>&#x2003;return range;</entry><entry/><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0108" num="0121">An algorithm for defining the equalizer configuration, in accordance with embodiments, may be as shown in Table 4 below:</p><p id="p-0109" num="0000"><tables id="TABLE-US-00006" num="00006"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="266pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 4</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Syntax of EqualizerConfig</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="3"><colspec colname="1" colwidth="210pt" align="left"/><colspec colname="2" colwidth="21pt" align="center"/><colspec colname="3" colwidth="35pt" align="center"/><tbody valign="top"><row><entry/><entry>No. of</entry><entry/></row><row><entry>Syntax</entry><entry>bits</entry><entry>Mnemonic</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row><row><entry>EqualizerConfig(inputConfig, inputCount)</entry><entry/><entry/></row><row><entry>{</entry><entry/><entry/></row><row><entry>&#x2003;numEqualizers = escapedValue(3, 5, 0) + 1;</entry><entry/><entry/></row><row><entry>&#x2003;eqPrecisionLevel;</entry><entry>2</entry><entry>uimsbf</entry></row><row><entry>&#x2003;eqExtended Range;</entry><entry>1</entry><entry>uimsbf</entry></row><row><entry>&#x2003;for (i = 0; i &#x3c; numEqualizers; i++) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;numSections = escapedValue(2, 4, 0) + 1;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;lastCenterFreqP10 = 0;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;lastCenterFreqLd2 = 10;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;maxCenterFreqLd2 = 99;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;for (j = 0; j &#x3c; numSections; j++) {</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;centerFreqP10 = lastCenterFreqP10 + ReadRange(4 &#x2212;</entry><entry/><entry/></row><row><entry>lastCenterFreqP10);</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if (centerFreqP10 &#x3e; lastCenterFreqP10) lastCenterFreqLd2 = 10;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if (centerFreqP10 == 3) maxCenterFreqLd2 = 24;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;centerFreqLd2 = lastCenterFreqLd2 +</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;ReadRange(1 + maxCenterFreqLd2 &#x2212; lastCenterFreqLd2);</entry><entry/><entry/></row><row><entry/><entry>5</entry><entry>uimsbf</entry></row><row><entry>&#x2003;&#x2003;&#x2003;qFactorIndex;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;if (qFactorIndex &#x3e; 19) {</entry><entry>3</entry><entry>uimsbf</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;qFactorExtra;</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;cgBits = 4 + eqExtendedRange + eqPrecisionLevel;</entry><entry>cgBit</entry><entry>uimsbf</entry></row><row><entry>&#x2003;&#x2003;&#x2003;centerGainIndex;</entry><entry>s</entry><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;sgBits = 4 + eqExtendedRange + min(eqPrecisionLevel + 1, 3);</entry><entry/><entry>uimsbf</entry></row><row><entry>&#x2003;&#x2003;scalingGainIndex;</entry><entry>sgBit</entry><entry/></row><row><entry>&#x2003;}</entry><entry>s</entry><entry/></row><row><entry>&#x2003;for (i = 0; i &#x3c; inputCount; i++) {</entry><entry/><entry>uimsbf</entry></row><row><entry>&#x2003;&#x2003;hasEqualizer[i];</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;if (hasEqualizer[i]) {</entry><entry>1</entry><entry/></row><row><entry>&#x2003;&#x2003;&#x2003;equalizerIndex[i] = ReadRange(numEqualizers);</entry><entry/><entry/></row><row><entry>&#x2003;&#x2003;}</entry><entry/><entry/></row><row><entry>&#x2003;}</entry><entry/><entry/></row><row><entry>}</entry></row><row><entry namest="1" nameend="3" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0110" num="0122">The elements of the downmix matrix, in accordance with embodiments, may be as shown in Table 5 below:</p><p id="p-0111" num="0000"><tables id="TABLE-US-00007" num="00007"><table frame="none" colsep="0" rowsep="0" pgwide="1"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="287pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 5</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Elements of DownmixMatrix</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="91pt" align="left"/><colspec colname="2" colwidth="196pt" align="left"/><tbody valign="top"><row><entry>Field</entry><entry>Description/Values</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>paramConfig,</entry><entry>Channel configuration vectors specifying the information about</entry></row><row><entry>inputConfig,</entry><entry>each speaker. Each entry, paramConfig[i], is a structure with the</entry></row><row><entry>outputConfig</entry><entry>members:</entry></row><row><entry/><entry>AzimuthAngle, the absolute value of the speaker azimuth angle;</entry></row><row><entry/><entry>AzimuthDirection, the azimuth direction, 0 (left) or 1 (right);</entry></row><row><entry/><entry>ElevationAngle, the absolute value of the speaker elevation</entry></row><row><entry/><entry>angle;</entry></row><row><entry/><entry>Elevation Direction, the elevation direction, 0 (up) or 1 (down);</entry></row><row><entry/><entry>alreadyUsed, indicates whether the speaker is already part of a</entry></row><row><entry/><entry>group;</entry></row><row><entry/><entry>isLFE, indicates whether the speaker is a LFE speaker.</entry></row><row><entry>paramCount,</entry><entry>Number of speakers in the corresponding channel configuration</entry></row><row><entry>inputCount,</entry><entry>vectors</entry></row><row><entry>outputCount</entry><entry/></row><row><entry>compactParamConfig,</entry><entry>Compact channel configuration vectors specifying the information</entry></row><row><entry>compactInputConfig,</entry><entry>about each speaker group. Each entry, compactParamConfig[i], is</entry></row><row><entry>compactOutputConfig</entry><entry>a structure with the members:</entry></row><row><entry/><entry>pairType, type of the speaker group, which can be SYMMETRIC</entry></row><row><entry/><entry>(a symmetric pair of two speakers), CENTER, or ASYMMETRIC;</entry></row><row><entry/><entry>isLFE, indicates whether the speaker group consists of LFE</entry></row><row><entry/><entry>speakers;</entry></row><row><entry/><entry>originalPosition, position in the original channel configuration of</entry></row><row><entry/><entry>the first speaker, or the only speaker, in the group;</entry></row><row><entry/><entry>symmetricPair.originalPosition, position in the original channel</entry></row><row><entry/><entry>configuration of the second speaker in the group, for</entry></row><row><entry/><entry>SYMMETRIC groups only.</entry></row><row><entry>compactParamCount,</entry><entry>Number of speaker groups in the corresponding compact channel</entry></row><row><entry>compactInputCount,</entry><entry>configuration vectors</entry></row><row><entry>compactOutputCount</entry><entry/></row><row><entry>equalizerpresent</entry><entry>Boolean indicating whether equalizer information that is to be</entry></row><row><entry/><entry>applied to the input channels is present</entry></row><row><entry>precisionLevel</entry><entry>Precision used for uniform quantization of the gains:</entry></row><row><entry/><entry>0 = 1 dB, 1 = 0.5 dB, 2 = 0.25 dB, 3 reserved</entry></row><row><entry>maxGain</entry><entry>Maximum actual gain in the matrix, expressed in dB:</entry></row><row><entry/><entry>possible values from 0 to 22, in linear 1. . . 12.589</entry></row><row><entry>minGain</entry><entry>Minimum actual gain in the matrix, expressed in dB:</entry></row><row><entry/><entry>possible values from &#x2212;1 to &#x2212;47, in linear 0.891 . . . 0.004</entry></row><row><entry>isAllSeparable</entry><entry>Boolean indicating whether all the output speaker groups satisfy</entry></row><row><entry/><entry>the separability property</entry></row><row><entry>isSeparable[i]</entry><entry>Boolean indicating whether the output speaker group with index i</entry></row><row><entry/><entry>satisfies the separability property</entry></row><row><entry>isAllSymmetric</entry><entry>Boolean indicating whether all the output speaker groups satisfy</entry></row><row><entry/><entry>the symmetry property</entry></row><row><entry>isSymmetric[i]</entry><entry>Boolean indicating whether the output speaker group with index i</entry></row><row><entry/><entry>satisfies the symmetry property</entry></row><row><entry>mixLFEOnlyToLFE</entry><entry>Boolean indicating whether the LFE speakers are mixed only to</entry></row><row><entry/><entry>LFE speakers and, at the same time, the non-LFE speakers are</entry></row><row><entry/><entry>mixed only to non-LFE speakers</entry></row><row><entry>rawCodingCompactMatrix</entry><entry>Boolean indicating whether compactDownmixMatrix is coded raw</entry></row><row><entry/><entry>(using one bit per entry) or it is coded using run-length coding</entry></row><row><entry/><entry>followed by limited Golomb-Rice</entry></row><row><entry>compactDownmixMatrix[i][j]</entry><entry>An entry in compactDownmixMatrix corresponding to input</entry></row><row><entry/><entry>speaker group i and output speaker group j, indicating whether</entry></row><row><entry/><entry>any of the associated gains is nonzero:</entry></row><row><entry/><entry>0 = all gains are zero, 1 = at least one gain is nonzero</entry></row><row><entry>useCompaetTemplate</entry><entry>Boolean indicating whether to apply an element-wise XOR to</entry></row><row><entry/><entry>compactDownmixMatrix with a predefined compact template</entry></row><row><entry/><entry>matrix, to improve the efficiency of the run-length coding</entry></row><row><entry>runLGRParam</entry><entry>Limited Golomb-Rice parameter used to code the zero run-lengths</entry></row><row><entry/><entry>in the linearized flatCompactMatrix</entry></row><row><entry>flatCompactMatrix</entry><entry>Linearized version of compactDownmixMatrix with the predefined</entry></row><row><entry/><entry>compact template matrix already applied;</entry></row><row><entry/><entry>When mixLFEOnlyToLFE is enabled, it does not include the</entry></row><row><entry/><entry>entries known to be zero (due to mixing between non-LFE and</entry></row><row><entry/><entry>LFE) or those used for LFE to LFE mixing</entry></row><row><entry>compactTemplate</entry><entry>Predefined compact template matrix, having &#x201c;typical&#x201d; entries,</entry></row><row><entry/><entry>which is XORed element-wise to compactDownmixMatrix, in order</entry></row><row><entry/><entry>to improve coding efficiency by creating mostly zero value entries</entry></row><row><entry>zeroRunLength</entry><entry>The length of a zero run followeed by a one, in the</entry></row><row><entry/><entry>flatCompactMatrix, which is coded with limited Golomb-Rice</entry></row><row><entry/><entry>coding, using the parameter runLGRParam</entry></row><row><entry>fullForAsymmetricInputs</entry><entry>Boolean indicating whether to ignore the symmetry property for</entry></row><row><entry/><entry>every asymmetric input speaker group;</entry></row><row><entry/><entry>When enabled, every asymmetric input speaker group will have</entry></row><row><entry/><entry>two gain values decoded for each symmetric output speaker</entry></row><row><entry/><entry>group with index i, regardless of isSymmetric[i]</entry></row><row><entry>gainTable</entry><entry>Dynamically generated gain table which contains the list of all</entry></row><row><entry/><entry>possible gains between minGain and maxGain with precision</entry></row><row><entry/><entry>precision Level</entry></row><row><entry>rawCodingNonzeros</entry><entry>Boolean indicating whether the nonzero gain values are coded</entry></row><row><entry/><entry>raw (uniform coding, using the ReadRange function) or their</entry></row><row><entry/><entry>indexes in the gainTable list are coded using limited Golomb-Rice</entry></row><row><entry/><entry>coding</entry></row><row><entry>gainLGRParam</entry><entry>Limited Golomb-Rice parameter used to code the nonzero gain</entry></row><row><entry/><entry>indexes, computed by searching each gain in the gainTable list</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0112" num="0123">Golomb-Rice coding is used to code any non-negative integer n&#x2265;0, using a given non-negative integer parameter p&#x2265;0 as follows: first code the number h=&#x2514;n/2<sup>p</sup>&#x2518; using unary coding, as h one bits followed by a terminating zero bit; then code the number l=n&#x2212;h&#xb7;2<sup>p </sup>uniformly using p bits.</p><p id="p-0113" num="0124">Limited Golomb-Rice coding is a trivial variant used when it is known in advance that n&#x3c;N, for a given integer N&#x2265;1. It does not include the terminating zero bit when coding the maximum possible value of h, which is h<sub>max</sub>=&#x2514;(N&#x2212;1)/2<sub>p</sub>&#x2518;. More exactly, to encode h=h<sub>max </sub>we write only h one bits, but not the terminating zero bit, which is not needed because the decoder can implicitly detect this condition.</p><p id="p-0114" num="0125">The function ConvertToCompactConfig(paramConfig, paramCount) described below is used to convert the given paramConfig configuration consisting of paramCount speakers into the compact compactParamConfig configuration consisting of compactParamCount speaker groups. The compactParamConfig[i].pairType field can be SYMMETRIC (S), when the group represents a pair of symmetric speakers, CENTER (C), when the group represents a center speaker, or ASYMMETRIC (A), when the group represents a speaker without a symmetric pair.</p><p id="p-0115" num="0000"><tables id="TABLE-US-00008" num="00008"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="left"/><thead><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></thead><tbody valign="top"><row><entry>ConvertToCompactConfig(paramConfig, paramCount)</entry></row><row><entry>{</entry></row><row><entry>&#x2003;for (i = 0; i &#x3c; paramCount; ++i) {</entry></row><row><entry>&#x2003;&#x2003;paramConfig[i].alreadyUsed = 0;</entry></row><row><entry>&#x2003;}</entry></row><row><entry>&#x2003;idx = 0;</entry></row><row><entry>&#x2003;for (i = 0; i &#x3c; paramCount; ++i) {</entry></row><row><entry>&#x2003;&#x2003;if (paramConfig[i].alreadyUsed) continue;</entry></row><row><entry>&#x2003;&#x2003;compactParamConfig[idx].isLFE = paramConfig[i].isLFE;</entry></row><row><entry>&#x2003;&#x2003;if ((paramConfig[i].AzimuthAngle == 0) ||</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;(paramConfig[i].AzimuthAngle == 180&#xb0;) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;compactParamConfig[idx].pairType = CENTER;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;compactParamConfig[idx].originalPosition = i;</entry></row><row><entry>&#x2003;&#x2003;} else {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;j = SearchForSymmetricSpeaker(paramConfig, paramCount, i);</entry></row><row><entry>&#x2003;&#x2003;&#x2003;if (j != &#x2212;1) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;compactParamConfig[idx].pairType = SYMMETRIC;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;if (paramConfig.AzimuthDirection == 0) {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;compactParamConfig[idx].originalPosition = i;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;compactParamConfig[idx].symmetricPair.originalPosition =</entry></row><row><entry>j;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;} else {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;compactParamConfig[idx].originalPosition = j;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;&#x2003;compactParamConfig[idx].symmetricPair.originalPosition =</entry></row><row><entry>i;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;paramConfig[j].alreadyUsed = 1;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;} else {</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;compactParamConfig[idx].pairType = ASYMMETRIC;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;&#x2003;compactParamConfig[idx].originalPosition = i;</entry></row><row><entry>&#x2003;&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;}</entry></row><row><entry>&#x2003;&#x2003;idx++;</entry></row><row><entry>&#x2003;}</entry></row><row><entry>&#x2003;compactParamCount = idx;</entry></row><row><entry>}</entry></row><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0116" num="0126">The function FindCompactTemplate(inputConfig, inputCount, outputConfig, outputCount) is used to find a compact template matrix matching the input channel configuration represented by inputConfig and inputCount, and the output channel configuration represented by outputConfig and outputCount.</p><p id="p-0117" num="0127">The compact template matrix is found by searching in a predefined list of compact template matrices, available at both the encoder and decoder, for the one with the same the set of input speakers as inputConfig and the same set of output speakers as outputConfig, regardless of the actual speaker order, which is not relevant. Before returning the found compact template matrix, the function may need to reorder its lines and columns to match the order of the speakers groups as derived from the given input configuration and the order of the speaker groups as derived from the given output configuration.</p><p id="p-0118" num="0128">If a matching compact template matrix is not found, the function shall return a matrix having the correct number of lines (which is the computed number of input speaker groups) and columns (which is the computed number of output speaker groups), which has for all entries the value one (1).</p><p id="p-0119" num="0129">The function SearchForSymmetricSpeaker(paramConfig, paramCount, i) is used to search the channel configuration represented by paramConfig and paramCount for the symmetric speaker corresponding to the speaker paramConfig[i]. This symmetric speaker, paramConfig[j], shall be situated after the speaker paramConfig[i]; therefore, j can be in the range i+1 to paramConfig&#x2212;1, inclusive. Additionally, it shall not be already part of a speaker group, meaning that paramConfig[j].alreadyUsed has to be false.</p><p id="p-0120" num="0130">The function readRange( ) is used to read a uniformly distributed integer in the range 0 . . . alphabetSize&#x2212;1 inclusive, which can have a total of alphabetSize possible values. This may be simply done reading ceil(log 2(alphabetSize)) bits, but without taking advantage of the unused values. For example, when alphabetSize is 3, the function will use just one bit for integer 0, and two bits for integers 1 and 2.</p><p id="p-0121" num="0131">The function generateGainTable(maxGain, minGain, precisionLevel) is used to dynamically generate the gain table gainTable which contains the list of all possible gains between minGain and maxGain with precision precisionLevel. The order of the values is chosen so that the most frequently used values and also more &#x201c;round&#x201d; values would be typically closer to the beginning of the list. The gain table with the list of all possible gain values is generated as follows:<ul id="ul0011" list-style="none">    <li id="ul0011-0001" num="0000">    <ul id="ul0012" list-style="none">        <li id="ul0012-0001" num="0132">add integer multiples of 3 dB, going down from 0 dB to minGain;</li>        <li id="ul0012-0002" num="0133">add integer multiples of 3 dB, going up from 3 dB to maxGain;</li>        <li id="ul0012-0003" num="0134">add remaining integer multiples of 1 dB, going down from 0 dB to minGain;</li>        <li id="ul0012-0004" num="0135">add remaining integer multiples of 1 dB, going up from 1 dB to maxGain;</li>        <li id="ul0012-0005" num="0000">&#x2003;stop here if precisionLevel is 0 (corresponding to 1 dB);</li>        <li id="ul0012-0006" num="0136">add remaining integer multiples of 0.5 dB, going down from 0 dB to minGain;</li>        <li id="ul0012-0007" num="0137">add remaining integer multiples of 0.5 dB, going up from 0.5 dB to maxGain;</li>        <li id="ul0012-0008" num="0000">&#x2003;stop here if precisionLevel is 1 (corresponding to 0.5 dB);</li>        <li id="ul0012-0009" num="0138">add remaining integer multiples of 0.25 dB, going down from 0 dB to minGain;</li>        <li id="ul0012-0010" num="0139">add remaining integer multiples of 0.25 dB, going up from 0.25 dB to maxGain.</li>    </ul>    </li></ul></p><p id="p-0122" num="0140">For example, when maxGain is 2 dB and minGain is &#x2212;6 dB, and precisionLevel is 0.5 dB, we create the following list:</p><p id="p-0123" num="0141">0, &#x2212;3, &#x2212;6, &#x2212;1, &#x2212;2, &#x2212;4, &#x2212;5, 1, 2, &#x2212;0.5, &#x2212;1.5, &#x2212;2.5, &#x2212;3.5, &#x2212;4.5, &#x2212;5.5, 0.5, 1.5.</p><p id="p-0124" num="0142">The elements for the equalizer configuration, in accordance with embodiments, may be as shown in Table 6 below:</p><p id="p-0125" num="0000"><tables id="TABLE-US-00009" num="00009"><table frame="none" colsep="0" rowsep="0"><tgroup align="left" colsep="0" rowsep="0" cols="1"><colspec colname="1" colwidth="217pt" align="center"/><thead><row><entry namest="1" nameend="1" rowsep="1">TABLE 6</entry></row></thead><tbody valign="top"><row><entry namest="1" nameend="1" align="center" rowsep="1"/></row><row><entry>Elements of EqualizerConfig</entry></row></tbody></tgroup><tgroup align="left" colsep="0" rowsep="0" cols="2"><colspec colname="1" colwidth="63pt" align="left"/><colspec colname="2" colwidth="154pt" align="left"/><tbody valign="top"><row><entry>Field</entry><entry>Description/Values</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row><row><entry>numEqualizers</entry><entry>Number of different equalizer filters present</entry></row><row><entry>eqPrecisionLevel</entry><entry>Precision used for uniform quantization of the gains:</entry></row><row><entry/><entry>0 = 1 dB, 1 = 0.5 dB, 2 = 0.25 dB, 3 = 0.1 dB</entry></row><row><entry>eqExtendedRange</entry><entry>Boolean indicating whether to use an extended range </entry></row><row><entry/><entry>for the gains; if enabled, the available range is </entry></row><row><entry/><entry>doubled</entry></row><row><entry>numSections</entry><entry>Number of sections of an equalizer filter, each one </entry></row><row><entry/><entry>being a peak filter</entry></row><row><entry>centerFreqLd2</entry><entry>The leading two decimal digits of the center </entry></row><row><entry/><entry>frequency for a peak filter; the maximum range </entry></row><row><entry/><entry>is 10 . . . 99</entry></row><row><entry>centerFreqP10</entry><entry>Number of zeros to be appended to centerFreqLd2; </entry></row><row><entry/><entry>the maximum range is 0 . . . 3</entry></row><row><entry>qFactorIndex</entry><entry>Quality factor index for a peak filter</entry></row><row><entry>qFactorExtra</entry><entry>Extra bits for decoding a quality factor larger than </entry></row><row><entry/><entry>1.0</entry></row><row><entry>centerGainIndex</entry><entry>Gain at the center frequency for a peak filter</entry></row><row><entry>scalingGainIndex</entry><entry>Scaling gain for an equalizer filter</entry></row><row><entry>hasEqualizer[i]</entry><entry>Boolean indicating whether the input channel with </entry></row><row><entry/><entry>index i has an equalizer associated to it</entry></row><row><entry>eqalizerIndex[i]</entry><entry>The index of the equalizer associated with the input </entry></row><row><entry/><entry>channel with index i</entry></row><row><entry namest="1" nameend="2" align="center" rowsep="1"/></row></tbody></tgroup></table></tables></p><p id="p-0126" num="0143">In the following aspects of the decoding process in accordance with embodiments will be described, starting with the decoding of the downmix matrix.</p><p id="p-0127" num="0144">The syntax element DownmixMatrix( ) contains the downmix matrix information. The decoding first reads the equalizer information represented by the syntax element EqualizerConfig( ), if enabled. The fields precisionLevel, maxGain, and minGain are then read. The input and output configurations are converted to compact configurations using the function ConvertToCompactConfig( ). Then, the flags indicating if the separability and symmetry properties are satisfied for each output speaker group are read.</p><p id="p-0128" num="0145">The significance matrix compactDownmixMatrix is then read, either a) raw using one bit per entry, or b) using the limited Golomb-Rice coding of the run lengths, and then copying the decoded bits from flactCompactMatrix to compactDownmixMatrix and applying the compact Template matrix.</p><p id="p-0129" num="0146">Finally, the nonzero gains are read. For each nonzero entry of compactDownmixMatrix, depending on the field pairType of the corresponding input group and the field pairType of the corresponding output group, a sub-matrix of size up to 2 by 2 has to be reconstructed. Using the separability and symmetry associated properties, a number of gain values are read using the function DecodeGainValue( ). A gain value can be coded uniformly, by using the function ReadRange( ), or using the limited Golomb-Rice coding of the indices of the gain in the gainTable table, which contains all the possible gain values.</p><p id="p-0130" num="0147">Now, aspects of the decoding of the equalizer configuration will be described. The syntax element EqualizerConfig( ) contains the equalizer information that is to be applied to the input channels. A number of numEqualizers equalizer filters is first decoded and thereafter selected for specific input channels using eqIndex[i]. The fields eqPrecisionLevel and eqExtendedRange indicate the quantization precision and the available range of the scaling gains and of the peak filter gains.</p><p id="p-0131" num="0148">Each equalizer filter is a serial cascade consisting in a number of numSections of peak filters and one scalingGain. Each peak filter is fully defined by its centerFreq, qualityFactor, and centerGain.</p><p id="p-0132" num="0149">The centerFreq parameters of the peak filters which belong to a given equalizer filter have to be given in non-decreasing order. The parameter is limited to 10 . . . 24000 Hz inclusive, and it is calculated as</p><p id="p-0133" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>centerFreq=centerFreqLd2&#xd7;10<sup>centerFreqP10 </sup><?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0134" num="0150">The qualityFactor parameter of the peak filter can represent values between 0.05 and 1.0 inclusive with a precision of 0.05 and from 1.1 to 11.3 inclusive with a precision of 0.1 and it is calculated as</p><p id="p-0135" num="0000"><maths id="MATH-US-00001" num="00001"><math overflow="scroll"> <mrow>  <mi>qualityFactor</mi>  <mo>=</mo>  <mrow>   <mo>{</mo>   <mtable>    <mtr>     <mtd>      <mrow>       <mrow>        <mn>0.05</mn>        <mo>&#xd7;</mo>        <mrow>         <mo>(</mo>         <mrow>          <mi>qFactorIndex</mi>          <mo>+</mo>          <mn>1</mn>         </mrow>         <mo>)</mo>        </mrow>       </mrow>       <mo>,</mo>       <mrow>        <mrow>         <mi>if</mi>         <mo>&#x2062;</mo>         <mtext>   </mtext>         <mi>qFactorIndex</mi>        </mrow>        <mo>&#x2264;</mo>        <mn>19</mn>       </mrow>      </mrow>     </mtd>    </mtr>    <mtr>     <mtd>      <mrow>       <mrow>        <mn>1.</mn>        <mo>+</mo>        <mrow>         <mn>0.1</mn>         <mo>&#xd7;</mo>         <mrow>          <mo>[</mo>          <mrow>           <mrow>            <mrow>             <mo>(</mo>             <mrow>              <mi>qFactorIndex</mi>              <mo>-</mo>              <mn>19</mn>             </mrow>             <mo>)</mo>            </mrow>            <mo>&#xd7;</mo>            <mn>8</mn>           </mrow>           <mo>+</mo>           <mi>qFactorExtra</mi>          </mrow>          <mo>]</mo>         </mrow>        </mrow>       </mrow>       <mo>,</mo>       <mi>otherwise</mi>      </mrow>     </mtd>    </mtr>   </mtable>  </mrow> </mrow></math></maths></p><p id="p-0136" num="0151">The vector eqPrecisions is introduced which gives the precision in dB corresponding to a given eqPrecisionLevel, and the eqMinRanges and eqMaxRanges matrices which give the minimum and maximum values in dB for the gains corresponding to a given eqExtendedRange and eqPrecisionLevel.</p><p id="p-0137" num="0152">eqPrecisions[4]={1.0, 0.5, 0.25, 0.1};</p><p id="p-0138" num="0153">eqMinRanges[2][4]={{&#x2212;8.0, &#x2212;8.0, &#x2212;8.0, &#x2212;6.4}, {&#x2212;16.0, &#x2212;16.0, &#x2212;16.0, &#x2212;12.8}};</p><p id="p-0139" num="0154">eqMaxRanges[2][4]={{7.0, 7.5, 7.75, 6.3}, {15.0, 15.5, 15.75, 12.7}};</p><p id="p-0140" num="0155">The parameter scalingGain uses the precision level min (eqPrecisionLevel+1,3), which is the next better precision level if not already the last one. The mappings from the fields centerGainIndex and scalingGainIndex to the gain parameters centerGain and scalingGain are calculated as</p><p id="p-0141" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>centerGain=eqMinRanges[eqExtendedRange][eqPrecisionLevel]+eqPrecisions[eqPrecisionLevel]&#xd7;centerGainIndex<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0142" num="0000"><br/><?in-line-formulae description="In-line Formulae" end="lead"?>scalingGain=eqMinRanges[eqExtendedRange][min(eqPrecisionLevel+1,3)]+eqPrecisions[min(eqPrecisionLevel+1,3)]'scalingGainIndex<?in-line-formulae description="In-line Formulae" end="tail"?></p><p id="p-0143" num="0156">Although some aspects have been described in the context of an apparatus, it is clear that these aspects also represent a description of the corresponding method, where a block or device corresponds to a method step or a feature of a method step. Analogously, aspects described in the context of a method step also represent a description of a corresponding block or item or feature of a corresponding apparatus. Some or all of the method steps may be executed by (or using) a hardware apparatus, like for example, a microprocessor, a programmable computer or an electronic circuit. In some embodiments, one or more of the most important method steps may be executed by such an apparatus.</p><p id="p-0144" num="0157">Depending on certain implementation requirements, embodiments of the invention can be implemented in hardware or in software. The implementation can be performed using a non-transitory storage medium such as a digital storage medium, for example a floppy disc, a hard disk, a DVD, a Blu-Ray, a CD, a ROM, a PROM, an EPROM, an EEPROM or a FLASH memory, having electronically readable control signals stored thereon, which cooperate (or are capable of cooperating) with a programmable computer system such that the respective method is performed. Therefore, the digital storage medium may be computer readable.</p><p id="p-0145" num="0158">Some embodiments according to the invention comprise a data carrier having electronically readable control signals, which are capable of cooperating with a programmable computer system, such that one of the methods described herein is performed.</p><p id="p-0146" num="0159">Generally, embodiments of the present invention can be implemented as a computer program product with a program code, the program code being operative for performing one of the methods when the computer program product runs on a computer. The program code may, for example, be stored on a machine readable carrier.</p><p id="p-0147" num="0160">Other embodiments comprise the computer program for performing one of the methods described herein, stored on a machine readable carrier.</p><p id="p-0148" num="0161">In other words, an embodiment of the inventive method is, therefore, a computer program having a program code for performing one of the methods described herein, when the computer program runs on a computer.</p><p id="p-0149" num="0162">A further embodiment of the inventive method is, therefore, a data carrier (or a digital storage medium, or a computer-readable medium) comprising, recorded thereon, the computer program for performing one of the methods described herein. The data carrier, the digital storage medium or the recorded medium are typically tangible and/or non-transitionary.</p><p id="p-0150" num="0163">A further embodiment of the invention method is, therefore, a data stream or a sequence of signals representing the computer program for performing one of the methods described herein. The data stream or the sequence of signals may, for example, be configured to be transferred via a data communication connection, for example, via the internet.</p><p id="p-0151" num="0164">A further embodiment comprises a processing means, for example, a computer or a programmable logic device, configured to, or programmed to, perform one of the methods described herein.</p><p id="p-0152" num="0165">A further embodiment comprises a computer having installed thereon the computer program for performing one of the methods described herein.</p><p id="p-0153" num="0166">A further embodiment according to the invention comprises an apparatus or a system configured to transfer (for example, electronically or optically) a computer program for performing one of the methods described herein to a receiver. The receiver may, for example, be a computer, a mobile device, a memory device or the like. The apparatus or system may, for example, comprise a file server for transferring the computer program to the receiver.</p><p id="p-0154" num="0167">In some embodiments, a programmable logic device (for example, a field programmable gate array) may be used to perform some or all of the functionalities of the methods described herein. In some embodiments, a field programmable gate array may cooperate with a microprocessor in order to perform one of the methods described herein. Generally, the methods are performed by any hardware apparatus.</p><p id="p-0155" num="0168">While this invention has been described in terms of several advantageous embodiments, there are alterations, permutations, and equivalents which fall within the scope of this invention. It should also be noted that there are many alternative ways of implementing the methods and compositions of the present invention. It is, therefore, intended that the following appended claims be interpreted as including all such alterations, permutations, and equivalents as fall within the true spirit and scope of the present invention.</p><?detailed-description description="Detailed Description" end="tail"?></description><us-math idrefs="MATH-US-00001" nb-file="US20230005489A1-20230105-M00001.NB"><img id="EMI-M00001" he="9.48mm" wi="76.20mm" file="US20230005489A1-20230105-M00001.TIF" alt="embedded image " img-content="math" img-format="tif"/></us-math><claims id="claims"><claim id="CLM-00001" num="00001"><claim-text><b>1</b>. A method comprising:<claim-text>decoding an encoded downmix matrix obtaining a decoded downmix matrix, the downmix matrix for mapping a plurality of input channels of audio content to a plurality of output channels, the input and output channels being associated with respective speakers at predetermined positions relative to a listener position, wherein the downmix matrix is encoded by exploiting a symmetry of speaker pairs of the plurality of input channels and a symmetry of speaker pairs of the plurality of output channels,</claim-text><claim-text>receiving encoded information representing the encoded downmix matrix; and</claim-text><claim-text>decoding the encoded information for obtaining the decoded downmix matrix,</claim-text><claim-text>wherein respective pairs of input and output channels in the downmix matrix have comprise associated respective mixing gains for adapting a level by which a given input channel contributes to a given output channel,</claim-text><claim-text>the method further comprising:<claim-text>decoding encoded significance values from the encoded information representing the encoded downmix matrix for obtaining decoded significance values, wherein respective decoded significance values are assigned to pairs of symmetric speaker groups of the input channels and symmetric speaker groups of the output channels, wherein a decoded significance value indicates if a mixing gain for one or more of the input channels is zero or not; and</claim-text><claim-text>decoding encoded mixing gains from the encoded information representing the encoded downmix matrix for obtaining the mixing gains; and</claim-text><claim-text>wherein decoding the encoded significance values is based on a template, the template having the same pairs of speaker groups of the input channels and speaker groups of the output channels as the downmix matrix, wherein respective template significance values are assigned to pairs of symmetric speaker groups of the input channels and symmetric speaker groups of the output channels of the template.</claim-text></claim-text></claim-text></claim><claim id="CLM-00002" num="00002"><claim-text><b>2</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the decoded significance values comprise a first value indicative of a mixing gain of zero and a second value indicative of a mixing gain not being zero, and the method further comprising:<claim-text>decoding a one-dimensional vector using a run-length scheme, the one-dimensional vector concatenating the decoded significance values in a predefined order.</claim-text></claim-text></claim><claim id="CLM-00003" num="00003"><claim-text><b>3</b>. (canceled)</claim-text></claim><claim id="CLM-00004" num="00004"><claim-text><b>4</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, comprising:<claim-text>decoding a one-dimensional vector using a run-length scheme,</claim-text><claim-text>wherein the one-dimensional vector logically combines the significance values and the template significance values, the one-dimensional vector indicating by a first value that a significance value and a template significance value are identical, and by a second value that a significance value and template significance value are different.</claim-text></claim-text></claim><claim id="CLM-00005" num="00005"><claim-text><b>5</b>. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein one-dimensional vector comprises a list containing run-lengths, and wherein the run-length comprises a number of consecutive first values terminated by a second value.</claim-text></claim><claim id="CLM-00006" num="00006"><claim-text><b>6</b>. The method of <claim-ref idref="CLM-00004">claim 4</claim-ref>, wherein the run-lengths scheme comprises a Golomb-Rice coding or a limited Golomb-Rice coding.</claim-text></claim><claim id="CLM-00007" num="00007"><claim-text><b>7</b>. (canceled)</claim-text></claim><claim id="CLM-00008" num="00008"><claim-text><b>8</b>. (canceled)</claim-text></claim><claim id="CLM-00009" num="00009"><claim-text><b>9</b>. (canceled)</claim-text></claim><claim id="CLM-00010" num="00010"><claim-text><b>10</b>. (canceled)</claim-text></claim><claim id="CLM-00011" num="00011"><claim-text><b>11</b>. (canceled)</claim-text></claim><claim id="CLM-00012" num="00012"><claim-text><b>12</b>. (canceled)</claim-text></claim><claim id="CLM-00013" num="00013"><claim-text><b>13</b>. The method of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein a predetermined position of a loudspeaker is defined dependent on an azimuth angle and an elevation angle of the speaker position relative to the listener position, and wherein a symmetric speaker pair is formed by speakers having the same elevation angle and having the same absolute value of the azimuth angle but with different signs.</claim-text></claim><claim id="CLM-00014" num="00014"><claim-text><b>14</b>. The method of claim comprising 1, wherein the input and output channels further include channels associated with one or more center speakers and one or more asymmetrical speakers, an asymmetrical speaker lacking another symmetrical speaker in the configuration defined by the input/output channels.</claim-text></claim><claim id="CLM-00015" num="00015"><claim-text><b>15</b>. (canceled)</claim-text></claim><claim id="CLM-00016" num="00016"><claim-text><b>16</b>. (canceled)</claim-text></claim><claim id="CLM-00017" num="00017"><claim-text><b>17</b>. (canceled)</claim-text></claim><claim id="CLM-00018" num="00018"><claim-text><b>18</b>. (canceled)</claim-text></claim><claim id="CLM-00019" num="00019"><claim-text><b>19</b>. (canceled)</claim-text></claim><claim id="CLM-00020" num="00020"><claim-text><b>20</b>. (canceled)</claim-text></claim><claim id="CLM-00021" num="00021"><claim-text><b>21</b>. (canceled)</claim-text></claim><claim id="CLM-00022" num="00022"><claim-text><b>22</b>. (canceled)</claim-text></claim><claim id="CLM-00023" num="00023"><claim-text><b>23</b>. (canceled)</claim-text></claim><claim id="CLM-00024" num="00024"><claim-text><b>24</b>. A method for presenting audio content having a plurality of input channels to a system comprising a plurality of output channels different from the input channels, the method comprising:<claim-text>providing the audio content and a downmix matrix for mapping the input channels to the output channels,</claim-text><claim-text>encoding the audio content for obtaining encoded audio content;</claim-text><claim-text>encoding the downmix matrix for obtaining an encoded downmix matrix, the downmix matrix encoded by exploiting a symmetry of speaker pairs of the plurality of input channels and a symmetry of speaker pairs of the plurality of output channels;</claim-text><claim-text>transmitting the encoded audio content and the encoded downmix matrix to the system;</claim-text><claim-text>decoding the encoded audio content for obtaining decoded audio content;</claim-text><claim-text>decoding the encoded downmix matrix by receiving encoded information representing the encoded downmix matrix and decoding the encoded information for obtaining a decoded downmix matrix; and</claim-text><claim-text>mapping the input channels of the decoded audio content to the output channels of the system using the decoded downmix matrix,</claim-text><claim-text>wherein respective pairs of input and output channels in the downmix matrix have associated respective mixing gains for adapting a level by which a given input channel contributes to a given output channel, and</claim-text><claim-text>wherein decoding the encoded downmix matrix comprises:</claim-text><claim-text>decoding encoded significance values from the encoded information representing the encoded downmix matrix for obtaining decoded significance values, wherein respective decoded significance values are assigned to pairs of symmetric speaker groups of the input channels and symmetric speaker groups of the output channels, wherein a decoded significance value indicates if a mixing gain for one or more of the input channels is zero or not; and</claim-text><claim-text>decoding encoded mixing gains from the encoded information representing the encoded downmix matrix for obtaining the mixing gains, and</claim-text><claim-text>wherein decoding the encoded significance values is based on a template, the template having the same pairs of speaker groups of the input channels and speaker groups of the output channels as the downmix matrix, wherein respective template significance values are assigned to pairs of symmetric speaker groups of the input channels and symmetric speaker groups of the output channels of the template.</claim-text></claim-text></claim><claim id="CLM-00025" num="00025"><claim-text><b>25</b>. The method of <claim-ref idref="CLM-00024">claim 24</claim-ref>, wherein the downmix matrix is specified by a user.</claim-text></claim><claim id="CLM-00026" num="00026"><claim-text><b>26</b>. The method of <claim-ref idref="CLM-00024">claim 24</claim-ref>, further comprising transmitting equalizer parameters associated to the input channels or the downmix matrix elements.</claim-text></claim><claim id="CLM-00027" num="00027"><claim-text><b>27</b>. A non-transitory computer-readable medium storing instructions which, when executed by a processor, cause the processor to carry out a method comprising:<claim-text>decoding an encoded downmix matrix for obtaining a decoded downmix matrix, the downmix matrix mapping a plurality of input channels of audio content to a plurality of output channels, the input and output channels being associated with respective speakers at predetermined positions relative to a listener position, wherein the downmix matrix is encoded by exploiting a symmetry of speaker pairs of the plurality of input channels and a symmetry of speaker pairs of the plurality of output channels,<claim-text>wherein the encoded downmix matrix is decoded by</claim-text></claim-text><claim-text>receiving encoded information representing the encoded downmix matrix; and</claim-text><claim-text>decoding the encoded information for obtaining the decoded downmix matrix,</claim-text><claim-text>wherein respective pairs of input and output channels in the downmix matrix have associated respective mixing gains for adapting a level by which a given input channel contributes to a given output channel, and</claim-text><claim-text>the method further comprising:</claim-text><claim-text>decoding encoded significance values from the encoded information representing the encoded downmix matrix for obtaining decoded significance values, wherein respective decoded significance values are assigned to pairs of symmetric speaker groups of the input channels and symmetric speaker groups of the output channels, wherein a decoded significance value indicates if a mixing gain for one or more of the input channels is zero or not; and</claim-text><claim-text>decoding encoded mixing gains from the encoded information representing the encoded downmix matrix for obtaining the mixing gains, and</claim-text><claim-text>wherein decoding the encoded significance values is based on a template, the template having the same pairs of speaker groups of the input channels and speaker groups of the output channels as the downmix matrix, wherein respective template significance values are assigned to pairs of symmetric speaker groups of the input channels and symmetric speaker groups of the output channels of the template.</claim-text></claim-text></claim><claim id="CLM-00028" num="00028"><claim-text><b>28</b>. A non-transitory computer-readable medium storing instructions which, when executed by a processor, cause the processor to carry out a method, the method comprising:<claim-text>encoding a downmix matrix, the downmix matrix mapping a plurality of input channels of audio content to a plurality of output channels, the input and output channels being associated with respective speakers at predetermined positions relative to a listener position,</claim-text><claim-text>wherein encoding the downmix matrix comprises exploiting a symmetry of speaker pairs of the plurality of input channels and a symmetry of speaker pairs of the plurality of output channels respective pairs of input and output channels in the downmix matrix have associated respective mixing gains for adapting a level by which a given input channel contributes to a given output channel,</claim-text><claim-text>wherein encoding the downmix matrix comprises encoding significance values, wherein respective significance values are assigned to pairs of symmetric speaker groups of the input channels and symmetric speaker groups of the output channels, wherein a significance value indicates if a mixing gain for one or more of the input channels is zero or not, and</claim-text><claim-text>wherein encoding the significance values is based on a template, the template having the same pairs of speaker groups of the input channels and speaker groups of the output channels as the downmix matrix, wherein respective template significance values are assigned to pairs of symmetric speaker groups of the input channels and symmetric speaker groups of the output channels of the template.</claim-text></claim-text></claim><claim id="CLM-00029" num="00029"><claim-text><b>29</b>. A non-transitory computer-readable medium storing instructions which, when executed by a processor, cause the processor to carry out a method for presenting audio content having a plurality of input channels to a system having a plurality of output channels different from the input channels, the method comprising:<claim-text>providing the audio content and a downmix matrix for mapping the input channels to the output channels,</claim-text><claim-text>encoding the audio content for obtaining encoded audio content;</claim-text><claim-text>encoding the downmix matrix for obtaining an encoded downmix matrix, the downmix matrix encoded by exploiting a symmetry of speaker pairs of the plurality of input channels and a symmetry of speaker pairs of the plurality of output channels;</claim-text><claim-text>transmitting the encoded audio content and the encoded downmix matrix to the system;</claim-text><claim-text>decoding the encoded audio content for obtaining decoded audio content;</claim-text><claim-text>decoding the encoded downmix matrix by receiving encoded information representing the encoded downmix matrix and decoding the encoded information for obtaining a decoded downmix matrix; and</claim-text><claim-text>mapping the input channels of the decoded audio content to the output channels of the system using the decoded downmix matrix,</claim-text><claim-text>wherein respective pairs of input and output channels in the downmix matrix have associated respective mixing gains for adapting a level by which a given input channel contributes to a given output channel, and</claim-text><claim-text>wherein decoding the encoded downmix matrix comprises:</claim-text><claim-text>decoding encoded significance values from the encoded information representing the encoded downmix matrix for obtaining decoded significance values, wherein respective decoded significance values are assigned to pairs of symmetric speaker groups of the input channels and symmetric speaker groups of the output channels, wherein a decoded significance value indicates if a mixing gain for one or more of the input channels is zero or not; and</claim-text><claim-text>decoding encoded mixing gains from the encoded information representing the encoded downmix matrix for obtaining the mixing gains, and</claim-text><claim-text>wherein encoding the significance values is based on a template, the template having the same pairs of speaker groups of the input channels and speaker groups of the output channels as the downmix matrix, wherein respective template significance values are assigned to pairs of symmetric speaker groups of the input channels and symmetric speaker groups of the output channels of the template.</claim-text></claim-text></claim><claim id="CLM-00030" num="00030"><claim-text><b>30</b>. An encoder for encoding a downmix matrix, the downmix matrix mapping a plurality of input channels of audio content to a plurality of output channels, the input and output channels being associated with respective speakers at predetermined positions relative to a listener position, the encoder comprising:<claim-text>a processor configured to encode the downmix matrix wherein encoding the downmix matrix comprises exploiting a symmetry of speaker pairs in of the plurality of input channels and a symmetry of speaker pairs of the plurality of output channels</claim-text><claim-text>wherein respective pairs of input and output channels in the downmix matrix have associated respective mixing gains for adapting a level by which a given input channel contributes to a given output channel,</claim-text><claim-text>wherein, for encoding the downmix matrix, the processor is configured to encode significance values, wherein respective significance values are assigned to pairs of symmetric speaker groups of the input channels and symmetric speaker groups of the output channels, wherein a significance value indicates if a mixing gain for one or more of the input channels is zero or not, and</claim-text><claim-text>wherein encoding the significance values is based on a template, the template having the same pairs of speaker groups of the input channels and speaker groups of the output channels as the downmix matrix, wherein respective template significance values are assigned to pairs of symmetric speaker groups of the input channels and symmetric speaker groups of the output channels of the template.</claim-text></claim-text></claim><claim id="CLM-00031" num="00031"><claim-text><b>31</b>. A decoder, comprising<claim-text>a processor configured to decode an encoded downmix matrix for obtaining a decoded downmix matrix, the downmix matrix mapping a plurality of input channels of audio content to a plurality of output channels, the input and output channels being associated with respective speakers at predetermined positions relative to a listener position, wherein the downmix matrix is encoded by exploiting a symmetry of speaker pairs of the plurality of input channels and a symmetry of speaker pairs of the plurality of output channels,</claim-text><claim-text>wherein the processor is configured to decode the encoded downmix matrix by receiving encoded information representing the encoded downmix matrix, and decoding the encoded information for obtaining the decoded downmix matrix,</claim-text><claim-text>wherein respective pairs of input and output channels in the downmix matrix have associated respective mixing gains for adapting a level by which a given input channel contributes to a given output channel, and</claim-text><claim-text>wherein, for decoding the encoded downmix matrix, the processor is configured to</claim-text><claim-text>decode encoded significance values from the encoded information representing the encoded downmix matrix for obtaining decoded significance values, wherein respective decoded significance values are assigned to pairs of symmetric speaker groups of the input channels and symmetric speaker groups of the output channels, wherein a decoded significance value indicates if a mixing gain for one or more of the input channels is zero or not; and</claim-text><claim-text>decode encoded mixing gains from the encoded information representing the encoded downmix matrix for obtaining the mixing gains, and</claim-text><claim-text>wherein encoding the significance values is based on a template, the template having the same pairs of speaker groups of the input channels and speaker groups of the output channels as the downmix matrix, wherein respective template significance values are assigned to pairs of symmetric speaker groups of the input channels and symmetric speaker groups of the output channels of the template.</claim-text></claim-text></claim><claim id="CLM-00032" num="00032"><claim-text><b>32</b>. An audio encoder for encoding an audio signal, comprising an encoder for encoding a downmix matrix, the downmix matrix mapping a plurality of input channels of audio content to a plurality of output channels, the input and output channels being associated with respective speakers at predetermined positions relative to a listener position, the encoder comprising:<claim-text>a processor configured to encode the downmix matrix, wherein encoding the downmix matrix comprises exploiting a symmetry of speaker pairs in of the plurality of input channels and a symmetry of speaker pairs of the plurality of output channels,</claim-text><claim-text>wherein respective pairs of input and output channels in the downmix matrix have associated respective mixing gains for adapting a level by which a given input channel contributes to a given output channel, and</claim-text><claim-text>wherein, for encoding the downmix matrix, the processor is configured to encode significance values, wherein respective significance values are assigned to pairs of symmetric speaker groups of the input channels and symmetric speaker groups of the output channels, wherein a significance value indicates if a mixing gain for one or more of the input channels is zero or not, and</claim-text><claim-text>wherein encoding the significance values is based on a template, the template having the same pairs of speaker groups of the input channels and speaker groups of the output channels as the downmix matrix, wherein respective template significance values are assigned to pairs of symmetric speaker groups of the input channels and symmetric speaker groups of the output channels of the template.</claim-text></claim-text></claim><claim id="CLM-00033" num="00033"><claim-text><b>33</b>. An audio decoder for decoding an encoded audio signal, the audio decoder comprising a decoder for decoding an encoded downmix matrix for obtaining a decoded downmix matrix, the downmix matrix, mapping a plurality of input channels of audio content to a plurality of output channels, the input and output channels being associated with respective speakers at predetermined positions relative to a listener position, wherein the downmix matrix is encoded by exploiting a symmetry of speaker pairs of the plurality of input channels and a symmetry of speaker pairs of the plurality of output channels, the decoder comprising:<claim-text>a processor configured to receive encoded information representing the encoded downmix matrix, and to decode the encoded information for obtaining the decoded downmix matrix</claim-text><claim-text>wherein respective pairs of input and output channels in the downmix matrix have associated respective mixing gains for adapting a level by which a given input channel contributes to a given output channel, and</claim-text><claim-text>wherein, for decoding the encoded downmix matrix, the processor is configured to</claim-text><claim-text>decode encoded significance values from the encoded information representing the encoded downmix matrix for obtaining decoded significance values, wherein respective decoded significance values are assigned to pairs of symmetric speaker groups of the input channels and symmetric speaker groups of the output channels, wherein a decoded significance value indicates if a mixing gain for one or more of the input channels is zero or not; and</claim-text><claim-text>decode encoded mixing gains from the encoded information representing the encoded downmix matrix for obtaining the mixing gains, and</claim-text><claim-text>wherein encoding the significance values is based on a template, the template having the same pairs of speaker groups of the input channels and speaker groups of the output channels as the downmix matrix, wherein respective template significance values are assigned to pairs of symmetric speaker groups of the input channels and symmetric speaker groups of the output channels of the template.</claim-text></claim-text></claim><claim id="CLM-00034" num="00034"><claim-text><b>34</b>. The audio decoder of <claim-ref idref="CLM-00033">claim 33</claim-ref>, comprising a format converter coupled to the decoder for receiving the decoded downmix matrix and operative to convert the format of the decoded audio signal in accordance with the received decoded downmix matrix.</claim-text></claim><claim id="CLM-00035" num="00035"><claim-text><b>35</b>. A method, comprising:<claim-text>encoding a downmix matrix, the downmix matrix mapping a plurality of input channels of audio content to a plurality of output channels, the input and output channels being associated with respective speakers at predetermined positions relative to a listener position, and<claim-text>wherein encoding the downmix matrix comprises exploiting a symmetry of speaker pairs of the plurality of input channels and a symmetry of speaker pairs of the plurality of output channels,</claim-text></claim-text><claim-text>wherein respective pairs of input and output channels in the downmix matrix have associated respective mixing gains for adapting a level by which a given input channel contributes to a given output channel, and</claim-text><claim-text>wherein encoding the downmix matrix comprises encoding significance values, wherein respective significance values are assigned to pairs of symmetric speaker groups of the input channels and symmetric speaker groups of the output channels, wherein a significance value indicates if a mixing gain for one or more of the input channels is zero or not, and</claim-text><claim-text>wherein encoding the significance values is based on a template, the template having the same pairs of speaker groups of the input channels and speaker groups of the output channels as the downmix matrix, wherein respective template significance values are assigned to pairs of symmetric speaker groups of the input channels and symmetric speaker groups of the output channels of the template.</claim-text></claim-text></claim></claims></us-patent-application>